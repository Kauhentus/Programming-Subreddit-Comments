You are right that it's not allowed. But more importantly, parent is right that it can be. There isn't a well-defined method to determine if a C++ program is well-defined. 
I know tic-tac-toe is pretty small, but when you get to naming things like "box7" it's usually a sign you should be using a vector or multidimensional array or something. Might take a closer look later if no one else does, but no time right now. 
Thats why you ideally have many examples, *accompanying* the documentation. Qt does it really well: excellent documentation and many examples.
What does a turd smell like? It's hard to describe, and every turd smells a little different, but you usually have no doubt what it is the instant you smell it.
Thank you. I'll give it a shot.
+1 to lots and lots of abstraction layers. I maintain code like this and most of it is hardly needed. 
Unit tests can also be used as "documentation" for only people who can read code. As long as those tests are available to the person using the code.
Sure, np! Let me know if you need any help and I'll try what I can :D
Oh man. One time I had to maintain a web-based scheduling system that had too many layers of abstraction. I have no idea what the guy who coded it was thinking -- I can only imagine he wanted to be prepared in case someone told him it needed to work in a telnet prompt or as a stand-alone application. Everything, including the page rendering stuff, was under like four layers of abstraction.
Thanks for the tips! :)
Good list, but I'd like to challenge item #1. [One of Unix Philosophy](http://en.wikipedia.org/wiki/Worse_is_better) claims that for the sake of simplicity it is OK for the code to *not* be correct *all* of the time. They claim, "it is slightly better to be simple than correct."
What I think you probably don't like is just the overuse of template metaprogramming. Features like *auto*, *nullptr* or the new *for* syntax stuff just help clean the language a little bit. With your second point about old compilers, I'm the kind of person who uses the latest and greatest as soon as possible so I don't think that point is too important, at least for me.
Back around 1990-1992 when I was still in high school, I actually learned C++ before I learned C (all I knew up to that point was BASIC and Pascal). I loved the ideas of object oriented programming, and I loved the bare-bones utilitarian C style syntax in both languages. I ended up getting jobs a few years later where I did coding in both. I had a bit of a hiatus from them professionally however, when my career took me through stints of network administration and software development with other tools. I did some C occasionally, but didn't keep up with C++ as much. By 2007-2008, I'd realized the language had changed so much, a lot of modern C++ code was almost unreadable. And now most of the coding I do is for embedded (ARM Cortex, and some PIC), and that's all in C which for the most part is still the same language I learned as a teenager. I feel like C++ is marching on without me, and it's becoming so complex and so far removed from its original form I can't imagine what it must be like for new developers.
[Knee-deep in C++ s... code](http://www.viva64.com/en/b/0094/)
Yeah, I used to work for a well known telecomunications company, and many of the architects had abstractration layers for every possible scenario. Allowing for customization at any level. In the end we never changed any component of the system.
I'm a novice programmer with C++. I basically code it like C with objects. lol Can you elaborate what you meant with 'template metaprogramming'? Thanks. 
Abstractions are important. While most of the people think those introduce performance penalties, it is not necessarily true. Template-based abstractions can be quite faster than their C counterparts. Here's my variation of a famous example: * 1 - sort (myvector1.begin(), myvector1.end()); * 2 - sort (myvector2.begin(), myvector2.end(), myfunction); * 3 - sort (myvector3.begin(), myvector3.end(), myobject); * 4 - qsort(array, size, sizeof(int), cmyfunction); Speed of those, when compiled with gcc -O3. Array is of size 1MiB * 1 - Test: Original 46ms * 2 - Test: Function 56ms * 3 - Test: Class 36ms * 4 - Test: C QSort 63ms So, the C version is the slowest, followed by std::sort with a function pointer passed to it. The version with the most abstractions - generic algorithm (std::sort) and a functor (class) produced the fastest code. New C++11 improves safety, readability and performance compared to the old C++. It might be confusing if you are mostly a C programmer using a C++ compiler.
Check out what B. Stroustrup has to [say](http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style) on this topic.
I really don't understand how template meta-programming can be an productive way of coding. I can't think of where you can need it other than containers. I agree with the OP, but I admit that using the STL is preferable to using arrays or other stuff. But it's true, C++ allows you to organize your code a little bit, and C++ is not only about OOP, there's also a lot of other nice features which makes C. I agree than C++ don't make me change my habits of how I'd code things in C, procedural programming is simple enough for me, and that's how I do things.
&gt; I really don't understand how template meta-programming can be an productive way of coding. Many of the most basic C++ libraries are basically template meta-programming - like std::vector, std::string and that sort of thing. It's a perfectly useful tool as long as you don't overuse it in your own code. The last use I made of this is my digital audio program - where I need to be able to accept various different sample sizes and sample layouts. So I have a generic "Samples" class and then I have specific implementations that extract and convert the actual sample when I get down to it.
Could not disagree more. I learnt C++ as C++11 (or rather 0x at the time) and there are plenty of things that change the language for a novice in a highly beneficial way too. For example: for(auto i : { 2, 4, 5, 7 }) { } more important the way you design programs has changed. I program in a manner that causes little side effects, and function return values even if they are expensive, because I rely on R-values. That said, buying a good book is still important. I recommend Acellerated C++.
I think the only *problem* HTML5 has is that it is hard to keep the source closed.
So far, from my experience, the best C++ coders I've worked with all came from C. The problems I see with new C++ only programmers, is that they get so wrapped around code organization, and utilizing the features, that they don't understand what is actually going on. I've seen plenty of perfectly functioning C++ programs written by these people, that were astronomically bad in terms of memory use and performance. I'm talking about nested classes, cranking through a copy constructor, and performing 10,000 memory allocations per copy.... I didn't believe it either till I wrote some debug code and watched. For them, cranking through a single MP3 file went through 160,000 allocations. They had zero idea of what was under the hood, and even less about how to fix it without wrecking their whole class hierarchy. I agree that there is a time and place for C++, and I like many of the features myself, but I don't want to see it create a generation of lazy Java programmers either. I don't want to hear the "we have faster processors and more memory" so it doesn't matter. It always matters.
&gt;Visual C++ 6.0. It's easier to read because you've been using the old style for 14 years. You are missing out on a lot of improvements in the language. GCC and even VS 2012 express ([with c++ support](http://blogs.msdn.com/b/vcblog/archive/2012/06/12/10318952.aspx))are free downloads. I use to feel the same way but then I realized I was becoming a dinosaur, fast. At some point you stop looking at development with wonder and fascination and start looking at it as more boilerplate code to write before you can go home and not touch a computer. This is the mistake. Do whatever you need to do to keep interested in learning all the new tech. 
C++11 tends to simplify the code a lot, and render it far more readable. Compare for (std::vector&lt;MyLongType&gt;::const_iterator i= v.begin(); i != v.end(); ++i) and for (auto i: v) 
C++ can be programmed as a high level language such as Python. The difference is that if you want to write extensions in Python you use C(or C++). With C++, you write an "extension" in C++. It would be a mistake to say that Python is very complicated and then cite all the bad stuff you could do in C. With C++, I also think it is a mistake to say it is hard to use and then cite stuff that are there mainly for library writers. Such things as template metaprogramming, r-value references, etc are meant to be used by library authors. In fact, I think that delete should only be used by libraries. At Dr. Dobbs, Andrew Koenig http://www.drdobbs.com/cpp/c-primer-5th-edition-part-3-smart-pointe/240004805 has an article stating that it is hard to come up with an example where user written copy-constructors are required. I think the biggest deficit in C++ is the relative lack of standardized libraries compared to say Java or C# http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/C-11-VC-11-and-Beyond. The new features enable simpler libraries, and thus an easier to use language.
Ah I see. Thanks! My previous problem in coding was that the code was absolutely filled with if statements everywhere, so I was trying to cut down using them a little :)
Along the same vein, in C with the statement f(); taken out of context, you have no idea what happens. If you forgo all function calls you can have a good idea exactly what assembly code is being generated. 
 You are right. My comment is wrong. I believe Linus's argument was about maintaining the kernel (specifically, looking at the output of patch and merging), and not systems programming. 
vector and string are reusable code, not code written by programmers who make an user-end application. Well yes your audio example fits, but other that's not something you see often.
Note that "for (auto&amp; elem : range)" should be used by default. It observes and/or modifies elements in-place. "for (auto e : r)" copies each element. This doesn't permit in-place modification (e can be modified, but it will not affect the original range). Even if you're just observing, it's significantly less efficient if the element has a nontrivial copy constructor (e.g. string, etc.).
What about Ada which is used for systems programming and also supports operators redefinitions? Given that Symbian is coded in C++, Mac OS X uses C++ in the IO Kit and Windows is slowly migrating to C++ with COM at the kernel level, C++ will eventually take C's place, regardless of what Linus thinks. 
I think this applies to any developer that learned to program in the last decade, regardless of the language.
As an old C programmer, I prefer Java, but I can appreciate the changes added to C++11. What I have never been able to wrap my head around is why C++ became this. One of C++'s strengths is that it is, essentially, C ... very close to the metal, very efficient, very fast. It seems to me that C++11 is not really C++ at all, but a C++ - ish language that compiles into machine code. I see it having more in common with JavaScript/V8 (a la node.js) than with the C language. It is, essentially, very high-level programming language that gets turned into machine code prior to execution ... but your programming is never anywhere near the machine itself. It's not a bad thing ... but it's just not what I would have expected to become of C++. It's as if an entire programming paradigm disappeared right in front of our faces.
With some of the errors in that code I really think that you would highly benefit by reading through a good book like "Accelerated C++". I that-that book at least sets challenges for the reader to do so give you are pretty good way of learning C++. The code you have presented is far too bad. You have an incredible about global data, massive amounts repetition, way to much "inline" logic. 
Using it for straightforward type substitution *is* a kind of metaprogramming. The more abstract things you can do with templates (including compile-time computation and the truly magical things they did in Boost::Phoenix) are decidedly less often useful.
Oh, *God* no. &gt; It's much easier to read the older code (at least for me). This also makes it easier to get new programmers integrated into our existing code base. It may be easier to read the old code when you've been reading it for 14 years or so. The language has moved on and has improved significantly enough that I feel it's necessary to call it an entirely new language. &gt; It works on the compilers we already have. No need to get Visual Studio 2012 or the latest gcc just to compile code that already compiles and works. It even works in Visual C++ 6.0. That's just awesome if you ask me. Well, no, it doesn't. Several keywords have been deprecated or given a new meaning: `auto`, for example, does automatic type deduction now, and is no longer a storage class specifier. And code that once worked on Visual Studio 6 will throw numerous compile-time errors and warnings in newer compilers. Why is that? Well, Visual C++ 6.0 *never actually supported standard C++.* It supported a dialect that was riddled with bizarre bugs. VS6 programmers learned to avoid any code that would trigger surprising behavior long ago, but all of those things are fixed in any compiler that actually tries to comply with the standard. Even VS2012 fixed a lot of long-standing bugs, and I'm certain you could find code that VS6 compiled without error that VS2012 will now choke on. I have *looked forward* to the day that Borland C++ Builder and Visual Studio 6 would finally end the span of their useful life so we as a community could move on to bigger and better things. The language is better now. Yes, it's different, but it's better. A lot better. Enough so that it's worth learning modern idioms.
Did you just imply that *Walter Bright* misunderstands what template metaprogramming is?
At work, it took two developers 6 months to port a C++ project of almost 2 million lines from VC6 to VC10 (VS2010). Some fun bugs cropped up even after everything compiled successfully. A fun one was the change in behavior of std::auto_ptr (which is thankfully deprecated now!). The standard's definition of auto_ptr's behavior literally changed since VC6 and wrecked havoc on a small utility of our's that used them.
Some of my favorite C++ code was the BeOS gui code. Those guys really worked to keep it simple and easy to read. Quite a constrast with the ugly wxwindows or microsoft stuff. No macros, straightforward classes and inheritance. Super clean!
You're definitely correct here. I try to avoid a lot of the template metaprogramming stuff. The more complicated stuff is practically unreadable to me. I'm sure the majority of the STL is unreadable as well (to me).
Ada lacks an assignment *operator*, so this specific example doesn't work. Assignment can only be customized in a rather restricted way (compared to C++). You can install a type-specific callback which is invoked after the assignment has already happened.
Every generic container library worth mentioning written in C++ uses template meta-programming to support efficiently using any type. Any container library written in C is either less generic, because it doesn't support any type, less efficient because it uses void* (as in the case of qsort being much slower than std::sort) or it does meta-programming using macros. I have yet to see a library that is both as generic and as efficient as what is possible with TMP that doesn't do some form of meta-programming.
I know that, but it is also open to side-effects as snarfy was complaining about C++. We need better languages for systems programming, not something that it is mostly from 1970.
You can use template metaprogramming for things like creating DSLs, but it's mostly used for what I suggested. Even the DSLs, however, can be thought of as creating generic reusable components. For example, one can create a regex engine that generates custom code to deal with each particular regular expression.
Well that can be argued. The person you are commenting to though has very valid points, when maintaining code one should really look at how you write these sorts of things. I suspect such stubs need to be marked as suggested with TODOs or other comments. When it comes right down to it the biggest factor in bad code is the lack of comments or explanations. Good comments can clear up in your own mind, not just the minds of others, just what in the hell you are doing. If you can't explain in a simple comment what you are about to do then most likely you will end up with bad code. Note this doesn't mean you need to write your comments into the actual code base though that might be advisable as you would have to read them, but rather you should mentally be able to state your goal before thinking in terms of code. For example let's say you are writing code to drive an amplifier of some sort. Being able to say I'm about to write a function to increase the gain of the amp clarifies what your code should be. Further each time you have to say "and", "or" or whatever, you should sit back and ask your self why. There is likely a better term for this, but I like to think it is a lack of forethought that leads to some rather messy code we see. While it might strike some as a bit of insanity but talking to yourself might actually lead to better code for many, if you confuse yourself the route to good codes troubled. 
Visual Studio does not conform to the standard in many areas, this is one of them. You can enable a flag in VS to fix this issue, but according to the C++ standard, Wikipedia is correct and VS is incorrect. To give a more in depth answer, the standard allows an optimization to be performed where a copy is simply avoided and that's what's happening in your case, the compiler is simply ignoring making a copy of X. The standard, however, requires that the class properly define a copy constructor. Also in general if you want a good idea of what a standard compliant C++ compiler should do, use GCC, clang, or Intel. They all have much better standard compliance by default, and extensions must be explicitly enabled.
Redundant sure for simple tasks. However functions can be far from simple. You are right in that comments that duplicate code is less than useful. However it can be very constructive to enlighten yourself and future programmers to a number of important pieces of data. Any non trivial function should have comments that reference the science they are about to implement including references in the literature, equations or other information as needed. Frankly including files right in the source code management system may be in order as these days tracing documents becomes a challenge. In that regard a comment could include a reference to a PDF, a page and even paragraph, that explains the challenge that your function is about to implement. Some software is often written with a sort of belligerent attitude that assumes that the next person to read the code will be 100% aware of what is being attempted by the code. Even an educated person needs a reference from time to time. In the end the comments in the code really shouldn't look like the code at all. Rather they should be able to lead an educated person to a fuller understanding of what you wish to accomplish. 
Is that 300 lines a bad thing though? There is an unreasoned assumption that long functions are bad, which might be true as a general rule and certainly is when it comes to teaching novices. However is the deflate function really that long for what it does? By the way I don't know, as I've never read the code. However I think making functions short just for the sake of implementing some code metric like no more than one screen full of text is nonsense. The question should rather be does the function implement one piece of functionality logically. 
I think that's the distinction between "just using templates" and "template metaprogramming". 
The following compiles in VS2010 out of the box: struct X { X() {} X(X&amp;) {} }; int main() { X x = X(); } It is not supposed to. X() can be assigned to a const X&amp;, but not to an X&amp; which is what Visual Studio 2010 is doing.
I guess if it isn't broke then don't fix it. Amirite? But brand new code straight from the forge should be the new C++11 code. (I guess, I'm not much of a programmer so my word isn't definitive.) Besides, jump on the bandwagon or get left behind with the cow manure.
&gt; Does the compiler really use the copy constructor Maybe. The standard says that if using the copy constructor is impossible, then the compiler must output an error. What optimizations the compiler does is another problem.
Yes, seemingly the compiler needs one, but the runtime doesn't !?
You sure? X() is not constant, is it? struct X { X() {} X(X&amp;) {} }; int main() { const X xconst = X(); X x = xconst; } seems to NOT-compile just fine :)
There are two aspects at play here, one is an optimization, one is non-standard behavior. If you want to get the conforming behavior you need to compile with the flag /Za, go into Properties, select Language and it's one of the options under "Disable language extensions."
ok, cool thanks!
Point is that the BeOS toolkit was an example of good code from that late 90s era, IMO. 
thanks. I didn't realise you weren't making the comparison with modern code. I checkout the Beos code then. 
[This may help.](http://stackoverflow.com/questions/1051379/is-there-a-difference-in-c-between-copy-initialization-and-direct-initializati)
Well, the same problem happens in C++. I don't think that example addresses the objection sufficiently. The point is, C++ introduces more context-sensitive constructs as basic language features. I prefer C++ over C, by the way, mainly because I like objects and overloading operators (appropriately), and hate function pointers.
Given that I've been using C++ for about a month, and Boost for it's multi-dimensional arrays; tell me what I should get excited about :)
&gt; Is that 300 lines a bad thing though? There is an unreasoned assumption that long functions are bad, which might be true as a general rule and certainly is when it comes to teaching novices. However is the deflate function really that long for what it does? No it's not too long, and that's the point of my post.
There is an amazing article about boost.asio that does a wonderful job at explaining the fundamental design of it: http://en.highscore.de/cpp/boost/asio.html it goes to show that asio is actually a generic asynchronous main loop framework, and not just a networking library.
&gt; You should use auto const&amp; elem: range then. That's also fine. &gt; What do you mean by "significantly less efficient"? Consider vector&lt;string&gt; v. for (auto s : v) and for (string s : v) are equivalent. Each iteration, an element of v will be *copied* into s. string has a nontrivially expensive copy constructor.
VC is "nice" enough to warn when the Evil Extension is being activated: C:\Temp&gt;cl /EHsc /nologo /W4 /MTd meow.cpp meow.cpp meow.cpp(8) : warning C4239: nonstandard extension used : 'argument' : conversion from 'X' to 'X &amp;' A non-const reference may only be bound to an lvalue; copy constructor takes a reference to non-const Note that I am not defending the Evil Extension, which is an abomination that should be eradicated. I am saying that programs should always be compiled at /W4 .
In a platform-dependent manner. Some OS's have services for that, but it usually suffices to write a dozen of lines in assembly. It's not that hard.
I know a few commits reduced auto-link dependencies for a few libs, but i don't recall anything going to header-only from not. Most of the compiled libs are unnecessary, but the most commonly linked are probably system, date time, and chrono. 
The conclusion is clearly true for almost all projects
I agree. But it's not like these same people know how to write proper FORTRAN, Python or Perl either.
Hehe, so very true. It may not be proper, it may not be beautiful, but it (sometimes) works!
The author has updated this article to suggest an alternate title: *Why you should never, ever, EVER use linked-list* **for number crunching**. That's a whole lot less controversial than the somewhat-ambiguous original title. I read the original title as "I have crunched the numbers regarding linked-lists and determined that there is **always** a better data structure".
That article really could have used less random coloring and bolding.
I hope that part of the transition was to stop using auto_ptr and switch to unique_ptr, yes?
It wasn't my bug report, but I helped the developer with it. He didn't agree with the structure of the code, regardless of the goofy auto_ptr behavior. His fix resulted no pointers, let alone smart ones. I have since stressed the use of std::unique_ptr and std::shared_ptr in any new code. It's going fairly well, considering how many old C devs I work with who just want to default to raw pointers.
You are missing the point. `f()` does exactly one thing, it calls `f`, you can look it up by it's name and be done with it. `A = B` in C++ on the other side doesn't allow you to just look it up. None of the stuff that gets called is mentioned by name. It's hidden between layers of automatic type conversion, virtual functions, exceptions, proxy classes and operator overloading. You can try look it up for two hours and still have a wrong idea of what actually happens because you overlooked some obscure language detail. C shows you what the code does, as everything is explicit. C++ does not, as a lot of stuff happens implicitly due to automatic magic happening in the background that is not expressed in code. 
Templates are, by definition, a metaprogramming facility. Just like macros. Metaprogramming isn't just code that reasons about itself, it's also just code that "writes" other code in a structured manner (or unstructured in the case of macros). :-)
A lot of this is getting to know and becoming familiar with the idioms. One of the most commonly employed techniques in C++ template metaprogramming is reliance on [SFINAE](http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error). Recognizing when this pattern is used is one of the keys to understanding a lot of common idioms. But rest assured: It *is* possible to go from practically no understanding of the more complex C++ code to a fairly thorough understanding. It is humanly possible, and it doesn't require much more than a healthy sense of curiosity.
And yet, no sane C++ programmer manages to end up spending two hours finding the definition for the assignment operator of a well-defined type… Linus is being a drama queen, as always, and that's why we love him, but this isn't a particularly good criticism of C++. C++ does make it possible to do more things implicitly, but there's no requirement that it has to if that's not your preferred style of coding. Meanwhile, the stricter type system *alone* would be a good reason to use C++ over C in systems programming.
It is standard C++ (both C++98 and C++11 are supported, for that matter). As for the pre-compiler argument, we've already had [this discussion](http://www.reddit.com/r/cpp/comments/xiwcs/creating_command_line_applications_with_boost/c5n0r23) and you couldn't provide any rational argument for why a library-only solution is better than the one that requires a pre-compiler.
it is not a rational argument to have, it is a discussion of taste: Why would I rely on software that is bound to gcc? When there are other alternative that aren't.
Looks great but I prefer this [OTL] (http://otl.sourceforge.net/) More liberal license; very performant and easy to integrate into your project ( single header file )
&gt; OTL has a pretty comprehensive support for all major databases' features I doubt one can achieve this using the "least common denominator" API like ODBC. And quoting their documentation: "For the rest of database types (PostgreSQL, MySQL, Sybase, SQLite, MS ACCESS, Firebird, etc.), OTL has support via ODBC 3.x". &gt; array inserts / updates Fairly database-specific and not yet supported by ODB, though there are plans. &gt; stored procedures Check (see ODB views). &gt; subscriber API Again, very-database specific. &gt; statement pooling ( no connection pooling though) ODB does statement, connection, and even memory buffer pooling. Generally, ODB allows you to go as low-level as you wish. You can deal just with classes (no SQL whatsoever) or you can write some custom SQL if you wish (and for that, IMO, ODB provides much more convenient parameter passing and results handling than OTL). You can go as far as get the native connection handle and go at it using the native C API. 
&gt;f() does exactly one thing, it calls f Unless there is some macro somewhere...
Why not have an option to use the C preprocessor, instead of relying on a custom preprocessor? It just kind of hackish adding all these preprocessors to C++(ODB's preprocessor, Qt's preprocessor), when it has a preprocessor built-in to the language(and it approaches turing completeness). Plus, its designed to scan, and expand text. Which looks much cleaner than doing it in sed(which is turing complete as well), or even python(which doesn't have a built-in lexer). The only downside to using the C preprocessor is supporting MSVC. Which for that, you could just require the custom preprocessor for MSVC.
I ggree, OTL's support for the open source databases isn't the best but for the big major commercial databases ( Oracle 7 and up, DB2, MS SQL Server) OTL's is one of the best. I haven't used ODB but looking at the code at least seems clean and readable. Can't say the same about OTL. It is undecipherable --array insert /update are a must have feature in any database library in my view. In most situations you simply don't send one row at a time to the server.
It most probably wasnt about computers being fast, but rater std::vector (ie. block of memory) being cache friendly.
Sorry: I guess I mean, *I wish I didn't have to rely on non standard tools*. I use *wish* because I actually like the user facing API quite a lot it is very idiomatic. The thing is, if I am writing a big heavy industrial database application for a company, tools like your's are ideal, because I can regulate the tool chain right down to the OS etc... However for free/opensource software, it is pretty much required that it can be build from a tar.gz with all the includes bundled in, so that it may 1). be built for a specific architecture 2). be modified. (so distributing the post processed code is not an option). The issue is made worse by the fact that not only does everyone have gcc (MS), it seems as though some OS's (BSD, OSX) are trying to remove any gcc altogether, whilst most Linux folk are sticking to gcc pretty strongly. Finally, is it not possible to do something like what Boost has done with Boost.fusion, the following basically adds a layer of reflection to a type. http://www.boost.org/doc/libs/1_46_1/libs/fusion/doc/html/fusion/adapted/adapt_struct.html Could this not be done in your case? Thank You.
Yes, but those followed some fixed rules that you can look up and the compiler can give you a warning if you like. In C++ everybody can define his own rules and the compiler won't be of much help.
Look, I think we can argue about this forever. I can keep telling you from experience that there is no way you will be able to implement something practical (i.e., that doesn't take an hour to compile and doesn't run like a dog) even remotely approaching ODB. While you will keep sending links to toy examples where people added (by hand) very limited (yet already ugly) reflection for a class. I've been there, done that. So the only way to settle this is for you to put your money where your mouth is and write an ORM that can do, say, half of what ODB can. Are you willing to do that?
I'd happy to know whether STL (or anybody) has an opinion on the newly accepted Boost::TypeErasure that introduces concept-based polymorphysm. That allows dynamically dispatced functions without inheritance and proper value semantics. A very interesting step forward if you ask me.
VC11's devirtualization optimizations are type-based, not value-based (this deeply confused me until I got a compiler back-end dev to explain it to me in detail). When Link-Time Code Generation is enabled, the optimizer can see everything and will detect situations where (for example) a pure virtual function has only one derived class overriding it. In that case, it can unconditionally devirtualize the call. This sounds obscure and unlikely, but it actually happens a surprising amount of the time. (The optimizer also ensures that the program is not "invaded"; e.g. if you have a binary with a Base and only one Derived, but you call a DLL that returns Base *, the program has been invaded and the optimizer can no longer be sure that every Base * points to the Derived * it can see.) The optimizer is not doing what you would expect a human to do - track through the history of a pointer and determine whether it always points to a particular class. That would be both hard and slow.
&gt; While you will keep sending links to toy examples where people added (by hand) very limited (yet already ugly) reflection for a class. I've been there, done that. I actually use something like that but is more complex for serialization in production code. The link is just simplified to make it an easier to comprehend example. It does slow down compilation, but the preprocessor part is actually really fast. The problem is that the code for serialization has to be generated(from templated functions) in every translation unit that includes that header. By moving the serialization to the cpp file, it drastically decreases the compile times. It just requires putting code in the cpp file for every header to jump-start the serialization. &gt; So the only way to settle this is for you to put your money where your mouth is and write an ORM that can do, say, half of what ODB can. Are you willing to do that? Well my ultimate goal is to write a reflection framework first, where I can define a reflectable models like this: $(model(person) primary(int) id, (long) age, (string) name ) And then using an ORM framework, you could ultimately do typesafe queries like this: for(const person&amp; p : $(from(p, db.get_table&lt;person&gt;()) where(p.age &gt; 25) select(p.name))) { ... } In my free time, Im slowly working towards that, but im also working on other projects as well. So its going to take time. 
*the optimizer can see everything and will detect situations where (for example) a pure virtual function has only one derived class overriding it. In that case, it can unconditionally devirtualize the call. This sounds obscure and unlikely, but it actually happens a surprising amount of the time.* This isn't surprising to me at all. I call this "abstraction distraction" and is the result of a well meaning dev creating an abstract base class "in case we want to switch the implementation." One example was that we had a base interface "dataReader" that then had a mysql specific interface underneath. The thinking was that we might switch out mysql for something else at some point, so hide it behind an abstraction. There were a few problems with this- it was clear at that point that any upgrade wouldn't merely switching out one RDBMS for another, it was going to be something far different, either a key-value store, or a service accessed over the wire- it was going to be a big job either way, to the point where having an abstract interface in between . Second, we never intended to have more than a single implementation, and performance was a concern, so this didn't make sense. We had stuff like this all over the place, and it made debugging way harder than it had to be. 
Any call resembling the form: pType-&gt;Type::vfunc(...); ... should also be inline-able, right?
Holy shit! I recently turned down a candidate for a C++ position citing---not as the sole reason but nevertheless part of---that he had use "or" instead of "||."
The best bit is that the named tokens are just defines, so you can write code like int i; int *pi=bitand i;
This article is a tad disappointing, it doesn't even cover trigraphs. How can you be expected to call it "unusual C++" if you don't even support ??&lt; and ??=?
Well according to this article maybe he was too good!
No worries. That's indeed an evil example :)
Why thank you. I had fun with it. Hey, in your opinion, does the full slideshow seem like something that /r/cpp would be interested in? I'm cleaning it up anyways to use it for another presentation. (I wondered why this blog post seemed familiar...I got it emailed to me a little while ago. Small world.)
Better to post the relevant Wikipedia article... and recognize this is about C, not C++: http://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C
Most modern compilers that I have tested don't support trigraphs anymore anyhow.
[It just blew *my* mind that this isn't common knowledge for C++ programmers right now](http://en.wikipedia.org/wiki/C_trigraph#C). Then I realized this means not only I'm getting old, but also there is fresh blood in C++. Yay!
Because C++ is full of intentionally leaky abstractions, and "or" turning into "||" is one of them. A good C++ programmer understands how the features they use work, and if someone has to use "or" instead of "||" that shows they don't understand how "or" works. It's like not understanding that the vector class is backed by an array or that the list class is a doubly-linked list. You don't have to know that to use basic functionality, but you do have to know that to use those features well.
Fair enough. I parsed kirakun's typo as *he had used*, not as *he had to use*. Neither says IMO he couldn't make the connection between an operator and its meaning, it might be just a peculiar quirk or obsession. I'd even say neither necessarily prevents him from being an excellent C++ programmer, only he might be not suitable for a team. 
You know how people like to bash C++...
I use `or` all the time. I think it makes code easier to read. And it is standard C++.
Its not portable though.
&gt; Is there any kind of documentation on what gets generated by the pragmas? Pragmas don't generate anything. They are just a declarative language that says things like this is a persistent class and this data member is its object id. Then, the ODB compiler, based on the C++ model (i.e., the AST) and these annotations generates tailor-made database persistence code for the classes. I think that's the point that you and a lot of other people who suggest reflection-based ORM are missing: ODB generates custom code for each class. For example, if the person class has members email, name, and age ODB will generate specific SELECT statement like "SELECT email, name, age FROM person ...". In other words all this is done once at compile time. While what you are proposing is for the program to *interpret* the class structure (based on the reflection information) at runtime. So continuing with the above example, this implementation will have to iterate over class members and construct the SELECT statement on the fly. It is like writing: int a (1), b (2), c (3); if (i &gt; a * b * c) ... Instead of just: if (i &gt; 6) ...
I like to use "not". Especially for enable_if, compare the following: std::enable_if&lt;somecond&lt;T&gt;::value&gt;::type std::enable_if&lt; ! somecond&lt;T&gt;::value&gt;::type std::enable_if&lt; not somecond&lt;T&gt;::value&gt;::type The bang in the 2nd line is way too easy to miss. 
GCC 4.7 still supports it with -trigraphs, and complains at you if you accidentally make a trigraph somewhere else (like a comment, or a string literal)
'Portability' isnt really concerned with the standard, but the reality. Similarily, 'export template' is (or was, not sure if they actually removed it) standard, but using it anywhere means your code is non-portable.
Same here, on the other side I could totally see how somebody coming from Python would use them and one could even make an argument that they improve readability. I actually find it a little surprising that they get used so little.
MSVC++
Man, what are you talking about? I'm not fresh blood, I've been coding in C++ since 1997, and secondly when I showed this around at work, nobody else had seen it and some of my co-workers are 50+. And, so we're clear, its the &lt;% and %&gt; and "and,or, not" stuff that blew my mind, not the old C trigraphs.
&gt; Then, the ODB compiler, based on the C++ model (i.e., the AST) and these annotations generates tailor-made database persistence code for the classes. So what is the tailor-made database persistence code for this class? Is there a documentation on how this is made? #pragma db object class person { ... private: friend class odb::access; person (); #pragma db id auto unsigned long id_; string first_; string last_; unsigned short age_; }; &gt; While what you are proposing is for the program to interpret the class structure (based on the reflection information) at runtime. No, at runtime no. Im talking about interpreting the class structure at compile-time. (Just like in the example in the link i gave). Then the `select` statement could be generated at compile-time by either the preprocessor or it could be generated by using a combination of `constexpr` and vardiac templates.
It does if you compile with "/Za" or include the 'iso646.h' header.
I use *or*, *and*, and *not* over *||,* *&amp;&amp;,* and *!* all the time. Since the moment i learned of them, it was like "well that makes more sense." I don't know why more don't do it.
I don't understand why using **or** means i don't know what **||** means. Even if i define the **||** operator for some type, it should still make sense as an **or** operation lest it violate the principal of least surprise.
&gt; So what is the tailor-made database persistence code for this class? Is there a documentation on how this is made? No, these are implementation details. However, you can compile this class and take a look at the generated -odb.?xx files to get an idea. &gt; Im talking about interpreting the class structure at compile-time. If you look at the ODB compiler source code, you will see it is already a fairly complex piece of software. And here we have the full power and expressiveness of C++ at our disposal. What you are proposing is to re-implement pretty much all of this using some combination of C preprocessor and template metaprogramming. That's going to be quite a task...
They are also in Visual C++, but it'd be silly to write/title the article like it was about Visual C++.
These are not trigraphs.
Woman, what's your problem? I would suppose if you've been doing C or C++ for about a decade, it would be very rare not to have come across this. So, consider yourself and your coworkers special ;) I've always seen this mentioned in conjunction with trigraphs, but there seems to be a sizable proportion of coders who''ve seen the latter but not the digraphs. 
Okay that was hilarious. I just blew the minds of two old fogeys. Maybe in your circles the digraphs are known, but not around here!
Actually, it’s *not* a keyword, it’s an “alternative token” (§2.6). But apart from this minor nitpick, good explanation. (And just fort completeness’ sake, I filed a bug report about iso646 to Microsoft ages ago via Connect. Predictably, their response was “won’t fix”, with the reason given that nobody had complained about it before.)
`#include &lt;ciso646&gt;`. But yes, valid point. And Microsoft has expressed that they do not want to fix this. Hugely disappointing. Luckily, I’m not targeting Windows as a platform any more so I don’t have to care.
Bjarne Stroustrup has judged his own knowledge of C++ at a 7 out of 10. Whenever I get delusions of grandeur I remember this and re-adjust the assessment of my own knowledge of C++ to rank somewhere below its inventor.
Link? I'd love to read it.
I think this showcases a general problem with job interviews: the interviewers – by necessity – compare against their own knowledge. If the interviewee knows more this can make either a very good or very bad impression. I’m unsure of how this could be improved but maybe it’s generally a good idea to dig deeper after every “mistake” an interviewee makes to let them explain themselves. Kudos for honesty, anyway.
I'm also interested in this. At work I used Boost test and really liked how the asertion worked, giving you a lot of output (line where error occured and assertion message).
This looks like an interesting read. http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle
Seven years old though. I can't believe nothing has changed in so much time.
Why is it that when one says they *choose* to use "or", they get asked why they *have* to use it? Are we having a debate about free will?
Because my post says "has to", not "chooses to". I assumed that you were talking about the same thing as me since you were replying to my post, and weren't instead trying to get in an unrelated debate about semantics and free will.
I suggest you look at http://code.google.com/p/googletest/, i used it some time ago and remember that it came as 'better' then boost at my evaluation (cant rememebr why was that though, so you would need to have a look yourself). 
Read the whole post hoping he would explain what the problems he's talking about actually are, but alas.
I think he criticizes that the set of changes you can make to a C++ base class while preserving binary compatibility is very restricted.
I've seen a number of people make suggestions on how to solve this over the years, all breaking changes. Every time, it's difficult to avoid asking yourself "why not fix one more thing -- I've already lost binary compatibility anyway?" Reflection, sound types, and garbage collection later... :-) 
The two bigger ones are [Cinder](http://libcinder.org/) and [OpenFrameworks](http://www.openframeworks.cc/)
Elaborating : OpenFrameworks = Easy. Does tons for you. Bigger community. Tons of examples. API similar to processing. Not very C++ey (intentionally). Almost certainly better for you considering what you asked for. Cinder = Much more like a regular C++ library. Heavily templated. Uses boost. IMO the better one if you've got some experience with C++ and are doing "serious" things.
I would much sooner recommend Cinder. Yes the learning curve may be steeper if you don't know C++, but therefore it will teach you C++. If you're using a language I feel one should embrace it's style as early as possible.
While you definitely have a point, there is very much a definitive C++ style - the standard library. This is the style followed by Boost and many other, so-called, modern libraries, Cinder included. If someone is new to C++ I'd highly recommend they embrace that style unless there is good reason to do otherwise.
SFML (Simple Fast Multimedia Library) http://www.sfml-dev.org/ 
To be honest there is really no big difference between most of test frameworks for c++. But what is imo more important is support for mocking. And for this there is no better framework then [googlemock](http://code.google.com/p/googlemock/) - it is very easy to start using and at the same time is very flexible. You can use it with any test framework.
While I agree with you, openFrameworks is definitely the more appropriate recommendation for "I just want to fuck around a little like I used to with Processing". Especially with regards to the community around oF / Processing.
Great explanation. I would also add that the Greek letter *epsilon* is typically used for tolerance. const float EPSILON = 0.001; if (std::fabs(a - b) &lt;= EPSILON) {
Global variables galore. No classes or OOD. I suggest starting with a simpler c++ program that is well designed and implemented 
It does define FLT_EPSILON and DBL_EPSILON and LDBL_EPSILON, but not for this purpose. \*_EPSILON is the difference between 1.0 and the smallest number greater than 1.0. If the numbers you're comparing are greater than 1 then if there's any error it will not be smaller than this value, which makes it sort of useless as an error tolerance. A decent bound might be something like `*_EPSILON*(sum of the ulp errors of each operation+a small constant)*(average of the numbers you want to compare)`, but that's significantly more complicated, and sometimes impossible to actually compute. What you should do is test operations you'd like to compare as equal, measure their accumulated error, and pick an epsilon based on those measurements.
Generate code using Python and include it as part of your build or run it periodically.
How about using an enum?
No support for Linux? Pfft.
I like making a list of static const int variables, and putting them in a class relevant to their use. That way I can use intellisense to help bring them up when I need them in most IDEs with the scope resolution operator (::). Using enums works, but if you plan on porting your code between different C++ compilers, C, C#, or Java, static const int variables are more portable.
Your 'maybe' is bugged. This is because you have two 'invalid' states. One is explicit, your boolean flag. Another is a bug - initializing maybe with null pointer makes it 'valid' but operator T&amp; will cause undefined behavior. Realization that null shared pointer is also invalid state will fix the bug and also simplify the code (as the bool flag is now useless). Also, why is your shared_ptr in an union?
Are you aware of the fact that "static" (more accurately: internal linkage) is implied by "const" in C++ at this level?
This is IMO one of the best designed 2D drawing libraries out there, not to mention the excellent documentation with examples.
I think std::function covers that
For a long time now, you could template a function and pass another function in as an argument, then call that function from within the first with any arbitrary arguments. As mentioned, there's std::function, but i never, ever use it, which is not to say that i don't write code with higher-order functions. It's just that templates work well enough, and possibly more efficiently. BTW: http://en.cppreference.com/w/cpp/utility/functional/function
We use gtest at my job. Works very nicely for what we do.
I was attempting a joke. Chill out :) There are in fact quite a lot of people who don't like curly braces though. 
I think for anyone who sees the alternative operators for the first time, there'll be quite a lot of confusion, followed by trying to figure out how they work. I'm not sure people will immediately check the standard, so they might waste some time. After the initial confusion though, it's really obvious what the alternative operators are, isn't it? So perhaps it's not too big a deal if someone just starts using them. The digraphs are a different matter but I wouldn't suggest using them.
Why not? I think a lot of C++ programmers are interested in exploring the weird corners of the language. I'd definitely have a look at it.
Which is my point. It's not supported without additional effort both in the source and at the compile step. The compiler violates the standard and is therefore broken.
Type erasure is exactly what std::function performs, that is the entire purpose of std::function. It's actually used in quite a few other areas in C++, for the most extreme example of type erasure, have a look at boost::any.
Could you explain an application of type erasure in C++. I'm trying to understand when to use it.
In C++ it's basically an application of runtime polymorphism instead of "the usual way" with templates. You have a "holding" object (like `std::function`, `boost::any` or even `Base*`) and you forward all requests to it without knowing the specific type of the held data. There are a couple of situations when it's appropriate to do this. The first is when types will vary at runtime. The second is when you're worried about multiple template instantiations creating bloated object code. For the most part, though, you're better off with static polymorphism wherever possible.
First I've heard of a language extension that *removes* features. :)
Yep, #define's clashing with variable/function names can lead to some rather weird errors. 
Spamming is spamming. Doesn't matter if there was already spamming or not. If your comment does not further a discussion it's spamming.
Any compiler worth its salt will not make multiple copies of constants. There's no reason to make them static that I'm aware of. 
For an `int`, maybe. But what about an object? void foo() { /*static*/ MyClass const x; ... } 
&gt; Any compiler worth its salt will not make multiple copies of constants. Probably, but here, `static` expresses the intent.
By the way, I said only if a comment does not further a discussion does it make it a spam. This excludes opposing views. Opposing views often does promote discussion toward a more balanced picture. So, don't downvote just because you disagree. That's the wrong way to use it too.
The tags under the original question.
I fail to understand your logic. He doesn't mention it posting here, because this is already a cpp subreddit. It is kinda implicit that he wont be linking java here. 
That's not exactly true, otherwise 'const' would not be an adequate replacement for '#define'. You WANT the compiler to replace occurrences of 'varname' with the actual value. This will involve copies.
I think that answer may have been made before the improvements to boost.test and/or the author doesn't know how Boost.test works. You create tests in exactly the same way as they're saying is so bad ass in gtest.
I think you're right that it's good practice to make it explicit rather than leaving it up to the compiler to decide. I found the same discussion [here](http://www.gamedev.net/topic/553167-static-const-vs-const-in-function-scope) and that's the conclusion they came to.
Specially when they are truly and utterly pointless even if they were true. Say the gain would be 1 clock cycle or 2. What program would actually benefit from it compared to changing the actual algorithm or some other part of the program.
A quick answer is that it is a templated function that accepts an arbitrary number of template arguments. Variadic templates is a C++11 feature that facilitates this.
The term "portability" usually refers to targeting different platforms, not copy and pasting to different languages. Every language has its own idioms and it's good practice to express things in whatever way is idiomatic to the language, for reasons of readability and maintainability. If that means rewriting all your constant expressions (or creating a tool to do it for you), that's a much better idea than trying to satisfy every language with the same statements. 
This will be useful to know sometime in the distant future whenever I can use c++11.
What part of the question tags has you so confused? Have you never used StackOverflow? The question was tagged C++ by the writer of the question. Therefore, the question applies specifically to C++ and is to be answered from that perspective. That's how SO works.
A different language **is** a different platform. Do I have my definition wrong? I know I'm not the only programmer who has ever had to satisfy **multiple languages** *with the same code base*. Any developer building apps for iOS Objective-C and Android Dalvik (Java/C) simultaneously should be able to relate. This is kind of a big deal in B(usiness) to C(onsumer) development. Indie Game Programmers deal with this a lot. There are common polite behaviors in different human languages/cultures too. I enjoy hearing about how world travelers have adapted to them, and this seems like a fair analogy with that.
The author should put "std::list from &lt;STL implementation&gt;" in the title. Not all linked-list are created equal. Even with the "slow" std::list implementation found in popular platforms, sometimes std::list is faster than std::vector. If your code do both read and write, well designed algorithm using std::list *could be* faster than vector in multi-CPU environment. I implemented a linked-list data structure specifically for high performance number crunching. Unlike vectors, lists are not required to occupy continuous memory. Having complete control over which piece of data goes to which list node and where new node is allocated, my linked-list implementation is much more multi-CPU cache friendly than any vector and runs much faster. "never, ever" is a very long time and no one should never, ever, make claim like that. 
D'oh. I read the title as a general question, not a link to a blog. Oh well, take is as a TL;DR.
tl;dr because it isn't
A platform is the operating system and processor architecture. For instance, Win32 x86. It is possible to target that platform with all sorts of different languages. And the code will look and feel very different. Every language has not only its own strengths and weaknesses but its own style. If you're the only person looking at your code, by all means do whatever works for you. But when you've got even one other developer involved you should write code that has the feel of the language or you'll only throw them for a loop. 
Recursion is how you loop over the parameter pack. A loop is nothing more than a form of recursion, some languages don't even have loops, just recursion from which you can build up constructs like for-loops/while-loops. Rather than C++ introducing a whole bunch of new syntax and bloat to allow explicit looping over template parameters, and likely pissing off a lot of people, the language simply keeps it as simple as possible.
Check out Alexandrescu's "Modern C++ design" for more information about that whole head:tail shebang in C++ templates.
Try DirectXTK. It's got pImpl, map, std::function, anon namespaces, unique/shared_ptr, etc. [http://directxtk.codeplex.com/](http://directxtk.codeplex.com/)
Hey! From the sounds of your first assignment, you don't even need to write a single line of C++. :D All those things can be done as one-liners in bash. As an example, the "grep" command with a regular expression can be used to find those email addresses. The Unix philosophy is small composable tools, so start with that first. :) As for C++, I would say it is one of the most difficult languages to use correctly, as it has so many layers/features. One of the biggest recommendations I can make is not to have any preconceived notions about it, and learn it as if it was your first langauge. Many fall into a trap of "Oh, this looks like C, so I'll use it like this!", or "Oh, it has objects, it must be like Java". Because of its multitude of features, it's easy to fall into a "rut" of sorts, and misuse it. This post on stack overflow, has probably the best list of books on C++ out there: http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list Check it out! I highly recommend Effective C++ by Scott Meyers once you start writing some of your first programs. It will be very hard to grasp all the material in the book at first, but the most important thing it gives you is _awareness_ of features, caveats, and best practices. Eventually you will learn by researching the things that you're not familiar with (e.g. syntax), but the most important thing is to understand the idioms of the language to use it effectively. Another invaluable resource I have found is this reference for the standard library: http://en.cppreference.com/w/cpp . I use it every day! :D
Get at least one good book from [this list](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list). Since you have some programming experience, *Accelerated C++* should get you up to speed fairly quickly (heh). Don't go for online tutorials. If your computer doesn't already have a compiler installed, get [gcc](http://gcc.gnu.org/) or [Clang](http://clang.llvm.org/).
Thanks. I have been using gcc so far. I will definitely check those books out.
Manpages are also very useful reading. Kernel.org has the manpages for Linux online: http://www.kernel.org/doc/man-pages/online/dir_all_by_section.html Ctrl-F 'directory' finds eg `getdents`, `getdirentries`, and `readdir`. Those should get you going for your first assignment. edit: [`scandir`, `alphasort`](http://www.kernel.org/doc/man-pages/online/pages/man3/alphasort.3.html) man-page has almost the exact code you need in the example section.
Besides the C++ side of this, there is also the unix environment. It's all basically [POSIX](http://en.wikipedia.org/wiki/POSIX) so learning what's available will help a lot (things like windows has CreateProcess() but POSIX has fork()). Also, you will probably need to learn the basics of the 'make' command. You don't need to master it, but learn the basics. The command make foo will create an executable if the file foo.cc exists, no Makefile needed. If you are on windows at home, you'll probably want [cygwin](http://www.cygwin.com/).
If you're learning GCC right now, it's probably best to, at least, take a look at Clang. It *might* be that in the future Linux will switch to Clang. A few distros have already.
That's a good point. Are there any tutorials you prefer? In the past, I usually pointed people learning C++ at that site.
Which distros have switched to Clang?
&gt; RAW arrays do not abide by normal C++ passing semantics The reason the entire array isn't copied is because of the pointer decay mechanism, not because of passing semantics. After the array decays to a pointer, the pointer is passed by value, exactly as in C. You can pass arrays by reference just fine, so I'd say they do abide by normal passing semantics.
Another vote for Accelerated C++. I didn't use it when I was learning years ago, but I wish I did. It teaches C++ "the right way", showing you the C++ way *first*, rather than after messing around with a lot of straight C stuff.
I agree wholeheartedly. My objection was merely to saying they don't abide by normal passing semantics when that behavior is governed by a "feature" unrelated to passing semantics.
Really cool! The only downside is that it uses a macro preprocessor. But, it does what it promises.
Just a +++++ for Accelerated C++ to start with. It really does introduce people to C++ the right way. At your level it seems to be the right starting point and you should get through rather quickly. 
Thanks. Any advice for my problem in VS? 
I've never encountered this problem, so I'm just guessing here... Could it be that the debugger doesn't like spaces in the file name? Try creating a project in a simple path like C:\Test and then give it a simple, short name, too.
Did you actually build the project? Give us an overview of everything in projects\reddit's example\ folder and subfolders
no, no, no, this won't do at all. You can't just ask a question, and then say, 'Never mind, I figured it out'. Please help others who may see this issue in the future by posting what your solution turned out to b.
I was testing to ensure that I had in fact fixed the problem. Basically, Alexis hit it on the nose. I had neglected to move the new file to the project. After I did that, all went well.
&gt; It's to have type inference of return types for multi-statement functions without explicitly using decltype(), right? Yes, it ultimately comes from David Abrahams idea to make the function syntax less verbose, and a little more python like, but it of course has other advantages too.
yay! Hopefully the final release will follow not too long from now.
RAII is well within C++-03 style.
I never did get full C++11 support working on Snow Leopard because the standard C++11 library changed its binary interface definition, causing all sorts of horrible linking problems. (The internets failed me on how to get this to work as well.) Mountain Lion has a fully-working C++11 stdlib, so if you're moving forward with C++ in any way it'll be worth it for you to upgrade.
@pfultz2, I'm visually inspecting your code (don't have a C+11 compiler around) and fail to see one thing: how are you really supporting return type inference for multi-statement functions? If I write PYTHY(foo, x) ( if(x&lt;0)return -1; return 1; ) the thing seems to expand to: ... template&lt;typename T&gt; struct pithy_foo_523 { constexpr static auto *p = false ? pythy::addr() + [] (T x){ if(x&lt;0)return -1; return 1; } : nullptr; }; But the constructed lambda expression [] (T x){ if(x&lt;0)return -1; return 1; } is invalid since it does not explicitly state the return type, and this is only allowed for single-statement lambdas. I'm sure I'm missing something here. Thank you!
Exactly! I don't like std::list. But with boost.intrusive there is a way to create better lists without having to reimplement the same data structure over and over again. That's the problem with C. Every bigger project ends up with several implementations of the same data structure. And with this extra amount of low level work comes extra sources of errors and extra code to debug and to read. And getting them right is harder than most people think. 
TLDR; - I should have written it in C because I really haven't learned C++ very well.
AFAIK this is allowed for all lambdas, but those not of form 'return &lt;expr&gt;;' infer return type of 'void'. Either way, it only changes why its an error.
Wtf is he talking about with regard to the std::list 'helper' objects? If he had done std::list&lt;person&gt; instead of using std::list&lt;person*&gt; the 2 would been equivalent.
Well in both cases there are branching issues. I think a brancheless versions could be more efficient.
Upvoted for admitting you were wrong on the Internet.
Not particularly... I've been a coder for 18 years, I work on old legacy product that's half C++ and half C#. Whenever I get into the C++ code I have to tread more carefully and I can't do any of the well engineered short cuts C# can do. I'm sure my C++ code runs faster, but when you have 2.5mil lines of code and customers that just want more features, I could care less about speed.
The real reason MS coders steer clear of TMP is probably because they're compiler still doesn't do templates correctly :P I can make that thing blow its mind with my hands and feet tied behind my back...yes, I code with my dick. The argument that it's "hacking" and not "engineering" seems to me to be based on a rather broken view of software engineering. Although at college we learn all this useless crap about proving, kleen star this, draw out this big diagram thing and then code it...that's not how the real practice works. Software evolves and you'd damn well better be prepared for that! If we were to say that not using templates as a sort of glorified preprocessor was "hacking" we have to toss almost all of the STL out the window because clearly tag dispatching, type traits, etc...things that are in fact early forms of TMP, are "hacking". Don't even touch expression templates I guess since nobody ever intended operator + to return anything but a complete answer... In all honesty the very idea that software engineering is about using everything exactly as it was originally intended to must only exist in the mind of someone who's never, ever, ever written a single software product. I have _never_ seen a product that is exactly what it was originally intended to be and this very fact has been the bane of everyone's existence for many years. The entire philosophy behind agile methods and lightweight processes is in response to this unalterable fact of life: shit changes faster than you can plan for. So that's where I pretty much stopped reading. This guy sounds like he's full of crap and is quote mining to support his argument. The real reason to tend to avoid TMP is that it's fucking hard. There's no clear way to debug it, the syntax it creates is incredibly difficult to read, and the purely functional language it creates is difficult to think in. Recursion is almost always the most difficult way to approach a problem and with TMP that is ALL YOU HAVE! You have to know C++ very, very well and be rather brilliant to pull it off. The "average" developer (who's pretty much useless--don't be offended, if you post on reddit you're probably not "average" anything) is simply not up to it and these people are actually the majority of the industry. On the other hand, if you have one or two main stars in your team, or people that are actually interested in learning and challenging themselves (in other words, really weird people) there actually is some interesting and useful stuff you can do with TMP. The Boost.Units library is an example and I actually used that library in the development of software FOR engineers (imagine that, a type safe physics system is useful in correctly writing software that models the physical world). Another thing I managed to do was write a compile-time reflection system that allowed us to add new models in a matter of days...with all the dialogs and views in the system magically catching onto the new type and building completely new classes to edit and watch them. I was the only person on the planet that could read the code, but the whole team was using it...after an initial hump to learn some basics about metaprogramming. So no, in no way is TMP evil...it's just crazy....mad scientist crazy. The D language is perhaps making some headway toward making it better, I'm not sure...never used it. In C++ it's still pretty much only for the really crazy among us. ... and actually I was lying. I can't read my own TMP code.
Well, you're comparing C++ versus C# though.. I'm comparing the older C++ to C++11. I think most people would say they prefer C# over C++ assuming they're not working on an embedded device or something with low memory requirements.
What's the "Logic Paradigm"?
So this is typedef boost::optional&lt;boost::variant&lt;int,float,bool,char,std::string&gt;&gt; Bit; typedef std::unordered_map&lt;std::string,Bit&gt; BitBucket; , an operator T() for avoiding boost::get (*bit) and some fancy serialization. Or am I mistaking anything?
Agreed. What the hell is wrong with giving us libraries? Why do we need to recompile your whole library every time?
This is really impressive. This is one of the reasons I love C++! Does any other language support so many paradigms with good performance?
&gt; //set logName_ This is a terrible comment. Never write such comments.
First off: It's not a lot of code. However, it did take me a few days of work to nail everything down. I went through quite a lot of iterations until I got the behavior I wanted. Often when you look at the final product it looks a lot simpler than it was getting there. I think one of the clever bits was successfully implementing operator T() for the Bit class. Ignoring string, the current implementation returns the data the variant holds regardless of the conversion the user requests, and lets the language do the conversion. So this works: int x = bucket["float"]; and converts bucket["float"] from float to int naturally. For strings it attempts a lexical_cast. Otherwise, the error handling part. It took me a while to decide what I wanted to do (exceptions, crashing, error codes, console printing, or stack trace printing), and what is considered an error. Is this an error? int x = bucket["float"]; I decided to go with what is natural to C++ programmers, that's not an error, and you get a silent implicit cast. Reading and writing to files is helpful of course. I also made sure to keep the syntax and usage natural to C++ programmers (Implicit casts, inheriting from the std::unordered_map so the container can be used with STL algorithms). It's also the little touches, such as typedef Bit var. I realize the original post's tone may be hailing this as the next iPhone (Which was just to get some attention), and it's not a lot of code but hopefully it'll be useful to someone.
To expand a bit, don't write comments about what you are doing, write comments about why you are doing it. The CODE explains what you are doing. Having //includes over a series of includes is well, super redundant and silly. // Adding one to X X = X + 1 That comment was worthless crap. // Shift X by one to make it ready to be used by systemX which has arrays that start at 1 not 0 X = X + 1 not as crap! 
&gt; 10.. Getters and setters might be in books often, but generally are horrible. lolwut? You should ALWAYS use getters and setters. I don't have enough time to write out a full fledged response but you really should google this to learn why. One particular example: Let's say hat you've written a class which has already been shipped (customers are using it in their code already) which has all class attributes public (getters and setters don't exist). Now one of your high profile customers is on the phone and has discovered some quirky behavior which leads to race conditions. Turns out that your code is not thread-safe (what a surprise). If you used getters and setters then you can change the implementation to make it thread safe and your library header file will not have changed. What's even better is that your interface also remains the same. If your class attributes were public then the user has to replace all instances of "object.date = ..." with "object.setDateThreadSafe(...)". If you simply used getters and setters then you can just modify the internals of "object.setDate(...)" to make it thread safe and ship out the new library. The user just recompiles or relinks and life is good again (no source code modifications on the users end just because your code changed). **TL;DR** - The books say to use getters and setters for very good reasons although they may not articulate this well. For maintainability and robust interface design ,accessors and mutators are widely accepted industry practices which really should be followed. 
Is there a reason that beginSession is not called by the constructor itself? Is there a case where you construct the object but then won't beginSession until some later time? If so can you articulate this case? Also don't forget to call endSession in the object destructor in case the user forgets to do so. I would call beginSession in the constructor and endSession in the destructor however leave those functions as public still. Perhaps the user would like to temporarily pause a session with no logging which is now easily done by calling endSession and then calling beginSession again when they are ready.
I like it, but I'd probably just integrate Lua. Bit-Buckets look a lot like Lua tables, without the benefit of accessing properties with dot notation. Still, I think it would be useful and hope you don't get discouraged. 
More descriptive link here: http://mpprogramming.com/Cpp/Default.aspx
Wrong subreddit! Try /r/learnprogramming. Anyway you'll have to be more specific than "someone please solve this for me". What parts are you having trouble with? What things have you tried?
I like header-only libraries because, despite the longer compile times, I don't have to find a pre-compiled version of the library for my particular system, and I don't have to wade through a massively-ugly build processes to compile it myself (I'm looking at *you*, non-header boost libs). A header-only library will (for useful libraries) not have any system-specific elements and becomes much easier to just toss into a project (I'm looking at *you*, header-only boost libs). You also get the advantage of inlining and optimizations that can either only occur (or can only occur *well*) if the compiler has the code available. Link-time whole-program optimization is making this less of an issue, but it can still be an issue. 
A class composed of getters and setters is quite often not doing enough to justify its existence. A class should actually do stuff, not just provide a list of members, which is all you're doing when you make getter/setter for your members. Most members should be inaccessible to outside view or manipulation.
Adding to that, the formatting of the comments is inconsistent. Sometimes they start right after //, sometimes there is a space after // and then the comment. Sometimes the first word in the comment is capitalized, sometimes it is not. Sometimes comments are a sentence and end with punctuation, sometimes not. Always write full sentences and end your comments with punctuation. Personal preference: add a space after ifs. Use std::endl instead of "\n".
I'm not a big fan of labeling members as members. At best it is unnecessary. Since prefix const is often confusing about what it applies to, I prefer postfix const to remove ambiguity. Your "const std::string &amp; var" declarations would then change to "std::string const&amp; var". These are just nitpicking formatting preferences though. The first thing I would consider looking at your design is that there's already great libraries that do it better. Log4Cplusplus for example. That said, one thing I would consider for you is turning your "session" variable into a state object that is deferred to for operations that check the session variable for state and behave differently based on it. A session is on or off, the on one does stuff, the off one returns false, logs errors, etc... I'd consider giving the file stream to this object.
Your example of move semantics in the `Foo` class are wrong. The `Foo` constructor needs to look like this: Foo(std::string fn) : filename(std::move(fn)) {} The example of `Foo` that you provided is *worse* than the `Bar` example you provided. When your `Foo` is constructed, it creates a temporary string, moves it into the argument `fn` to `Foo`'s constructor, but then *copies* it into the filename member variable, and then destroys the string `fn`.
This looks a lot like json. With a value type Folly the facebook library has a dynamic type(https://github.com/facebook/folly) Also my library at https://github.com/jbandela/JRBJson Also has a value type Finally pocoproject at http://pocoproject.org/docs/Poco.DynamicAny.html Has dynamic any Did you consider also using json as serialization format?
Have a look at the newly accepted boost::type_erasure. It generalizes that kind of concept (and actually goes much further). You could have something like (very rough summary): map&lt;string, any&lt;mpl::vector&lt;ostreamable, copyable&gt;&gt;&gt; m; m["thing"] = [ any object that defines the &lt;&lt; operator ]; 
You're showing the disassembly of the call site, for a call that didn't get inlined. The two constructors have identical signatures, so their calls will look identical. Whereas `Bar::Bar` has a different signature, so its call will look different. Also, what optimization level?
Just in case you (or anybody else reading) wants a good reference on this, this series of articles is pretty great: http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/
Agreed. This idiom has a fancy name: resource acquisition is initialization (RAII). Open the log in the constructor, and close it in the destructor.
What happens if multiple threads or multiple processes want to use the log simultaneously? Holding the log open is a good way to ensure that multiple processes don't interfere (on a Unix-like operating system). Otherwise you might need to use file locking to ensure safety. Thread safety is also relatively easy to accomplish: the log object should have a mutex, which is locked while adding a record. 
I was thinking of RAII but wasn't sure if this really counted as resource acquisition.
I would strongly consider building a testsuite.
Google's style guide[[1]](http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Variable_Names) says to use trailing underscores. Honestly, it's your personal preference, just be consistent. 
Exactly. Since this is a logger, this is probably what you want (you don't want the program crashing without all the log messages being flushed.
sorry, I fail to see your point. The sort of code that the OP was talking about is the sort that doesn't use Boost, C++11 and smart pointers. I see it all the time and it is unsafe. 
true, but I never implied that is wasn't, non the less people still wrote code like that and people (like the OP) still code like that today. 
I'm gonna open a code repository hosting site and name it GitBucket.
Hrm. There's a lot of comments about implementation here that may or may not be important, but I don't see any comments on the most important aspect: your API is clunky and hard to use. Also, you need log levels. Here's how you want to use a log (as an example): LOGFN(GameLog, ERROR) &lt;&lt; "Got to state with less than 2 players. Ending immedately!"; and another: LOGFN(GameLog, INFO) &lt;&lt; "incoming player: player_id=" &lt;&lt; playerId &lt;&lt; " authToken=" &lt;&lt; authToken; a log is declared simply as: DECLARE_LOG(GameLog) and defined simply as: DEFINE_LOG(GameLog) I can't paste you the implementation here, but a few comments: "GameLog" is a log identifier. The macros use an underlying log class, and allow you to use different collectors and identifiers to produce output to different streams (that is, you can have more than one logger, and you can also log to something other than a file... it only cares about output streams). ERROR and INFO are log levels. The logger can be configured to ignore log messages above a certain log level, thus turning off debug output. LOGFN is defined to log to the stream with the file and line number prepended. There is an equivalent LOG macro that doesn't do that. Don't return an error from your logger. In any situation I can think of, if the logger can't log, you're in a FATAL or EMERG situation, anyways. The caller can't do anything with that error. You might want to throw an exception, or in cases where you want your library to not rely on exceptions, signal, or maybe even abort/exit. The nice thing about this implementation is that log output above the log level set on the logger instance turn into no-ops. The stream operators following the macro itself are not even invoked. I spent a lot of time thinking about this API over the years, and eventually ended up (after writing several logging frameworks) with this one. It's about as simple as you can get, and yet still powerful enough to be fully configurable and allow arbitrary output formatting. EDIT: Oh. I just went and looked at your implementation as well. You absolutely don't want to be opening and closing the log file with every new entry. The performance will be terrible. The logger in our server code is actually one of the biggest bottlenecks, especially if you want detailed output. 
Thank you very much for the detailed response. =] I really like your way of doing things, and wasn't satisfied with mine either. I am going to try and implement things in a similar way now, it seems a lot smoother. Really good point about returning errors from the log, I guess I didn't think that one through completely. I havn't actually started what the logger is for yet so wasn't sure about leaving it open, but I definitely don't want an unecessary bottle neck so I'll keep the file open too. Once again thanks for all your advice. 
I believe it works something like this: When you make a function call the compiler is going to create machine code that pushes the arguments onto the stack and then jumps to the correct location within the code. In C++ a constant can sometimes serve as a constant expression. This means that the value of the constant will actually be part of the machine code pushing values onto the stack. This differs from having a variable in that the value of the variable has to be fetched from memory first. The second is of course slower than the first involving more than just one CPU operation. This is in fact creating copies of a sort. These copies reside in memory where the code for your program resides. This is why in C++ a const value can actually replace a define. Whereas in C to get the first behavior (value in in the code itself) you need to use the macro, C++ is able to use it directly if the compiler knows the value. This is why const static integrals can often times be declared in the class, initialized there, and never actually defined. The compiler makes copies of the value into the code that uses it. If this did not happen then const variables could not fully replace preprocessor defines. Additionally to this behavior a C++ constant variable can be used in constant expressions, which have actually been extended even further in C++11.
1. Why do you open and close the file for every entry? Why don't you open the file in constructor and close in destructor? I'm not sure you want your app doing a lot of IO operations. On a laptops apps that do that together create poor performance. It is better to avoid needless IO. Unless this logger is for debugging purposes, but then there are better ways than writing to file. 2. You don't support std::wstring, only std::string. You might want to think about supporting that. 3. I don't see &lt;&lt; operator, which is more convenient than simple log("stuff") call. 4. You only support logging strings. When you want to log an int value, you need to do manual conversions just for the logger, writing messy code. Basically you would like to write: myloggerinstance &lt;&lt; "there are " &lt;&lt; 5 &lt;&lt;"objects" of &lt;&lt; typeof(somObject);
**Game and Graphics Programming for iOS and Android with OpenGL ES 2.0** by Romain Marucchi-Foino is a book documenting an open source, cross platform, C++ graphics/audio framework that works on both iOS and Android.
You actually don't need: std::ios_base::app | std::ios_base::out because std::ios_base::out is default for ofstream.
As thundaboom has said, I (creator of Sol) have written it with the intent to port it to some other platforms. But I am aware that most Android devices also support OpenGL ES 2.0, so portability was not the main concern in this issue. My thought was that, in a 2D game, you're most likely not going to see much difference, if any, between OpenGL ES 1.1 and 2.0. Your 2D game's performance is really not limited by the number of triangles you're rendering (most likely insignificant in comparison to a 3D game), but by your blending operations and fill rate, which shouldn't be different between GL ES versions. The statement that "2 would give much better performance" is only true if you can somehow optimize the shader to lessen the number of pixels you're drawing and blending. Of course, if anyone knows of a way to do that and achieve provably better performance, I will gladly incorporate an ES2.0 backend into Sol. I really do appreciate the feedback!
Thanks for teaching me. I'm still learning, and I'm looking forward to reading what you have to say.
Ya, but according to this 91% of Android devices currently support 2, so are you really buying all that much? http://developer.android.com/about/dashboards/index.html
I think the post didn't make my day better, but the discussion generated in the comments is interesting. So, I'm upvoting the link.
[10 days ago](http://www.reddit.com/r/cpp/comments/z4lx6/why_should_i_have_written_zeromq_in_c_not_c/). 
Good article, I was wrong during a long time thinking that references were always a disguised pointer. I was told that some plateform/compiler (suncc ?) does not allow a null reference and make the program crashes if this occur.
I like cprogramming.com. I think they have some pretty good tutorials/guides.
I think you could just initialize a dummy static global variable with a function.
Well, I'm kind of doing that, only without the assignment. I'm mostly worried about initialization order, i.e. if the container holding the scene providers is initialized already or if there might be some weird conditions. Lambdas might get rid of the begin, end pair, I guess.
Why even do this? Is dlopen not an option?
I've done this sort of thing before. I'm about to release a c++ unit testing framework that makes heavy use of this pattern. I would change the macro to expand like this, which will remove the need to have a macro pair. namespace filename100_static_initializer_ns { const struct filename100_static_initializer { filename100_static_initializer(); } filename100_static_initializer_instance; } filename100_static_initializer_ns::filename100_static_initializer::filename100_static_initializer() Also, if you make your registration function an *object* rather than a method, you could do something like this: #define INITIALIATION_TIME_CODE(scene) \ namespace { \ scene_provider_registry::register_provider reg_provider_ ## __FILE__ ## __LINE__ (new (scene)())); \ } \ If `new example_scene()` is just an example and you could have more complex initializer, then replace `(new (scene)())` with `(scene)`. (*Note that having a leading underscore, or double underscore anywhere in your code is not permitted by the standard.*)
Initialization order will be an issue regardless -- the order in which static initializers execute is undefined. You're going to need to rethink this if your code depends on some other code having already been run first. If you want a compiler-specific answer, gcc has [`__attribute__((constructor))`](http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html#index-g_t_0040code_007bconstructor_007d-function-attribute-2536) which can take an optional integer priority value that can be used to influence the order. 
Exactly. In every native application I've seen, the loader invokes a function with a well-defined name at load time to do just this. So if the loadee is named libmyextension.so, the loader would invoke myextension_init(some_reference_data) immediately after loading. See also the Python-C API for a good example.
Almost. Static initializers are executed in-order within a single file. It is the order between files that is implementation defined.
Good read, and a nice example of the C++-specific class design.
So as far as I can see this will not work as written. The issue is that these static variables are not guaranteed to be constructed before main is called. The only guarantee you get is that they will be [constructed before the use of any function or object in that translation unit](http://stackoverflow.com/questions/1271248/c-when-and-how-are-c-global-static-constructors-called). I have a cross-platform application where I wanted to do something similar. Unfortunately, at least on the Mac (where I do my primary development), it was the case that these static variables were _always_ initialized right before the first use of something in that translation unit - and sometimes this happened really late in the proceedings, long after main() was called (and in some cases, never, if I never called anything in that translation unit!) Later on, I discovered that this is [not true](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Attach_by_Initialization) for objects in the global namespace - they are guaranteed to be initialized before `main()`. So one way to do this is to make all these objects global. Of course, this brings with it possibilities for name collisions but you can work around that... EDIT: in fact, your use of `__FILE__` and `__LINE__` should mean that this is not an issue. Overall, global static variables in C++ are very dangerous since you have no idea of the construction order - you aren't even guaranteed that it is stable (which means that correct changes in your code might change the construction order and break code elsewhere). In your example, as long as you are sure that your initializers neither reference nor are referenced by any other global static variables, you'll probably be fine. And on an even higher level, you are introducing a certain risk and fragility into your codebase, for only a small benefit. You might be a lot better off explicitly calling all this from in `main()` - it's a little verbose but perhaps better than having to think about all these details.
Thanks, done.
What you can try is (windows, maybe possible under other OS) to compile with the NoStdLib option (or whatever is the actual name). I read a post in r/programming a while ago that explained what you could and must do with it. Sorry for the lack of details, I'm on my phone.
It doesn't need to. You can do it the way I said, and then during regular runtime initialization (i.e. during main()), you can move the data from the globals into the correct spot (i.e. your std::set).
&gt;Next time, I will go dynamic library though. Are there some wrappers to have it platform independent? (boost?) No much point in such. Its pretty much 3 functions on all interesting platforms. Either dlopen/dlsym/dlclose or LoadLibrary/GetProcAddress/FreeLibrary. You will achieve cross platformness in about 5 minutes.
I don't see how there can be something "less hacky" about executing code before main().
I have seen most of the online tutorials and to be honest they are all shit. I *strongly* recommend buying a good on the matter that teaches a modern C++ style, such as Accelerated C++ or C++ primer. I believe the latest C++ primer edition (5th) covers the C++11 standard.
That's not RAII first of all. You can also use bools instead of structs: http://stackoverflow.com/questions/4383602/how-to-force-inclusion-of-unused-object-definitions-in-a-library http://stackoverflow.com/questions/401621/best-way-to-build-a-list-of-per-type-data/401801#401801
I like google.
I think someone may have posted this lecture in another subredit or something, but I searched out one that didn't require silverlight. VERY good lecture. Well worth sitting back and watching in full.
WTF, you can't just ninja edit the key after inserting into a std::map. Why do you think it's const in the first place? std::map::insert has to plug it into the right place in a self-balancing tree.
&gt; I hate having that one big function one has to edit when adding a new module to the project. You'll hate debugging a static initialization order bug even more. Unless there's a strongly compelling reason not to do so, initialize your modules in the normal flow of execution. &gt; Are there some wrappers to have it platform independent? You might check Qt or WxWidgets or something similar for a cross-platform solution. I don't know of anything specific. 
The support that will be added is to be able to create programs that can be run on XP. I don't think you will be able to run VS2012 itself on XP.
Yes, you can. I was also WTF? in frist place, but then I realized that it is safe because std::map uses comparator to balance the three and when author changed that pointer he didn't changed the comparator logic (the right place in self-balanced tree as you say). The order is not dependent on pointer value but on value that the pointer points to (which stays the same).
The MSDN site provides WMV and MP4 downloads. No silverlight required whatsoever and better quality. http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style
If only I could cash in my variables.
Correct, the ability to create a program that can run on XP is not in this release of Visual Studio Express 2012, but a lot of people put pressure on Microsoft and they later committed to add support in a release later this year, thus is why I'm waiting. BTW, I use Windows 7. 
WHY ARE THE MENUS YELLING AT ME?
Very insightful, it cleared a lot of preconceived ideas about C++, the inheritance and "private" talk were also much relieving to hear about. I once asked on IRC about C++11 books, I heard they are being written. Can anyone confirm, or are there already books about c++11 ?
there's a lot of stuff about c++11 I just downloaded the wikipedia page, I'm far to be done with all of it.
On a related note, it's common practice in Windows COM code to use a 32-bit reference count (which you could have either inferred from IUnknown::AddRef returning a ULONG, reading and of the MSDN samples, or from stepping through the implementation of just about and COM object with a debugger). This is done on both 32 bit and 64 bit OSes. So be careful not to create 2**32+1 references to the same object. 
Wait, what? VS2012 doesn't support initialization lists? That seems like a pretty major omission if that's true...
Microsoft added a settings to change them back, but by default they stick to their "beloved" design.
Thanks for the suggestion, I'm going to check out C++ primer. Do you know how applicable Effective C++ by Scott Meyers is to the new standard? That's another C++ book I have.
Learning to program C++ on windows is an unecessary handicap for a beginner. I strongly recommend learning on a *Nix system. IDE's like VS hide so much of the tool chain which is critical to learn while you start.
Why do silly SO questions keep getting posted here? If you have anything close to a longs worth of `shared_ptr` then you have problems!
Well, I can understand what you've done there but I think a great many won't...as simple as it is. For the most part I think people will stick with `std::function` and I did consider making it templated on that as well, but I decided it wasn't worth it for a simple example. I guess it wasn't as complicated as I thought it would be though so...maybe I should have. I'm not sure the builder will ever get used. I guess it's easy enough, if you have a C++11 compiler with an operating `result_of` (2010 had it wrong), but the intended use of this thing is as a member variable so most of the time you won't be able to use it. I'm pretty sure you can't `auto` a member variable. Your `aligned_storage` trick is neat. I did not know about that one. I can see how it might work, but I had not thought of it. Been working for a C bigot and my skills began to atrophy a bit. I think there are a couple additions you need to make to this thing. Usually with a cached variable you want to invalidate it. So you need an invalidate function that will do the placement delete and clear the bool. All in all, great improvements. I didn't want to go overboard with it because I first of all don't know that it actually has that great of utility and second of all...what you've done is unfortunately hard for a lot of C++ developers to understand. If you don't mind though I'd like to take this comment, add the aforementioned functionality, and describe how it works for my readers.
I think there is one out there with Barbara Moo as one of the authors. I have a book where she collaborated with Koenig and it is quite good. I'd bet that the one she's worked on is probably good as well. I don't think I've ever read a technical book from cover to cover. I flip through them grabbing ideas. Exceptions might be the TMP book and the "Exceptional" books...because everything was good in those.
Well, when I try to watch the one on the channel9 site it bitches about silverlight so I searched down one that didn't. Linked it here for others that would rather not fight with a website and just want to watch the video. It was easy enough to find but I also think it's important enough a video to encourage people to watch it. I didn't see the format button because orange on white is hard for me to read. So now there are two options for people to watch. If they want to download it or view the slides they can check the channel9 link. If they just want to watch the video, don't need HD quality, and don't want to fuck with shit...there's the youtube one. It just works.
You can always new placement new and no deletion to find out.
I'll let you know if I come across any problems! Thanks a bunch
Problem solving is really the key, and consequently is the thing that you can't just learn out of a book. You need practice and more practice to get good at solving problems. Syntactically, this isn't more difficult than some string manipulation, so I'll try to talk you through the problem solving methods I'd use to tackle this problem. (I'm not going to go for the most efficient solution, but rather one I can talk out with you) We start by searching through our string and separating our character to replace with our input. Once I found a match (in this case for an 'x') I would take everything before that and move it to a new string which we will use to build our output. Next, we append our input to our output string and remove everything we've already ran through in our base string (so far 'Catx'). This will leave 'CatxCatx'. From there, we can rinse and repeat the same technique until there are not any characters left in the base string and we have built our output string appropriately. Problem solving at any level is just about breaking down what you want to do, and figuring out all the different ways you could make that happen, then executing your plan step by step. Of course, experience will eventually win out in simple problems like this, so now that you've followed my explanation above - check out http://www.cplusplus.com/reference/string/string/replace/ which is a string library member that will do what you want - just get the positions of each 'x' and use the replace function.
In case OP doesn't know how to use GDB: http://www.cs.cmu.edu/~gilpin/tutorial/
This will not do what you think it will do: cin &gt;&gt; stuNum[6]; Read up on your arrays. 
I don't care what color the UI is, I just hope they fixed IntelliSense for C++ so that it is actually useful for large projects. 
touché, still the point remains it is still better to delegate the task of parallelism to a library than try it yourself.
First the code I gave, will still default to `std::function&lt;&gt;` if you don't want to fuzz around with the templated option, none the less, you don't have to know how something works to be able to use it, do you know EXACTLY how std::bind works? With the exception of class members, I can't see when you wouldn't use the maker helper, it is inline with the standard auto-maker idiom (`std::make_shared`, `std::make_tuple`). &gt; 2010 had it wrong Gcc has it right ;). I develop to the standard not to a non conforming compiler, hopefully compiler support of the C++11 standard will get better across the board so we can all start using tools like this to write portable code. &gt; Your aligned_storage trick is neat it's not a trick, it is standard code design for purposes such as this. &gt; I think there are a couple additions you need to make to this thing. Usually with a cached variable you want to invalidate it. Agreed, but this isn't and wasn't supposed to be a fully featured class, just a suggestion for a better way to do it. I *MIGHT* make an article on it and go all out, but I would need an blog first. &gt; what you've done is unfortunately hard for a lot of C++ developers to understand. If you don't mind though I'd like to take this comment, add the aforementioned functionality, and describe how it works for my readers. Perhaps it is regrettable, but C++ is a language that is just too big for everyone to understand all of it, Stroustrup himself even admits to not know it all. So I think there is a point now, that we have to accept that we are going to have to use tools that are above our own understanding. That doesn't mean we shouldn't use them. (Also this is what tests are great for). Boost Spirit is a great example of a tool I couldn't write or live without! I don't mind if you want to include it in your article, but TBH I think I would rather/will also write about it myself, it took a few tries to get right, also I want to clean up the code a bit, I'll let you know when I have.
Why do you consider this question silly? Just because the answer is obvious to you? Just because you know it's not a problem on your platform? 
Just a small addition: IIRC the AddRef return value is intedned for debug purposes only and isn't guaranteed to be the actual refcount (which also would be very expensive when having cross-apartment interfaces). So the COM object can implement their reference count in an int64 or arbitrary precision integer. But you are right, most do use 32 bit. 
Exactly, the proxy holds one reference to the actual object, and counts "your" references. (Which exactly would make returning a true reference count expensive).
VC uses a 32bit long? I think a more interesting question than the one asked (which is still consider dull &amp; off topic) is why `std::size_t` wasn't used, at the end of the day `use_count` is never going to be negative, and it's max size is going to scale with memory.
certainly that question is more interesting. [Here's Raymond Chen's take on that](http://blogs.msdn.com/b/oldnewthing/archive/2005/01/31/363790.aspx)
If you're using the global (singleton) to initialize static objects, as the OP is doing, your program will not yet be using threads (before main start) so this will not be a problem. Also in the newer compilers (C++11) this is thread safe. 
Some of the problems there are really good, but honestly, your statement is ridiculous. Most of those problems are nothing more than masturbatory fodder for people who think they are much cleverer than they are. A programmer is someone who can get shit done, plain and simple. Need an app to fill some need? A programmer can code it - and likely won't need to figure out how to do string math in less than 40 bytes of assembly code. Just sayin' 
IDEs are available on osx/linux and command line is available on windows, imho learn the tools on the OS of your choice. 
You have to alter the Windows PATH environmental variable to include the compiler path.
Is g++ installed? g++ ./my file.CPP -o ./my file.exe
You just put "GNU make" and "simple" in the same sentence !
How about separating concerns? You could get rid of value and cached by using boost::optional&lt;T&gt;. The class template would be so simpler ... (no user-defined dtor, no placement new / explicit dtor call)
Because the VS toolchain ins't so different any other, except that it is mostly hidden from you. Linux is inherently more developer friendly, and a better platform to learn on, if only because it has a much strong free software and open source ethos.
thanks. ill use that in next time, its a long semester
You can find all of these tips in _effective C++_ by scott meyers. It's a short book.
No, you can't. This is not because of implementation details of map, but because the standard explicitly states that keys in map/set are immutable.
I am fully aware of Boost.Optional how I did not think it matched the use case here. Firstly it would have created a necessary reliance on boost, whilst I am a massive boost advocate for boost, I did not believe it to be necessary here. Secondly, I don't know how Boost.Optional is implemented, whilst there is partial the point of separating concerns, this particular object is used a some form of optimisation, that is delayed construction, single evaluation of function, there for if boost optional is implemented as a point to data on the heap (and I am not saying it is) then that would have an impact on performance. Finally, I do believe that construction is the concern of a "delayed construction" &amp; initailzation type However I would never begrudge anyone or anyone code who came to your design choice, I consider that as an as-valid solution, just I prefer mine.
Is there a example using them?
Basically, I'd advise against doing this. I really love the concept of CLU/Python/C# style generators, so a year or two ago I spent a few days writing a really nice set of macros like this based on Simon Tatham's 12-year-old post [here](http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html), which is likely where the macro-based idea originated. It's very enticing because it appears to really come close to giving you the yield keyword that you want in C++. Except that there are so many caveats that you have to keep in mind when using it that it negates the main benefit of generators in the first place, which is the ease and simplicity of writing them. Just hold on a little bit longer. Hopefully 1-2 boost revisions from now we'll have [real generators in C++](http://article.gmane.org/gmane.comp.lib.boost.devel/233860). 
Thanks!
I have a handful of books from Meyers, Sutter, Alexandrescu's "Modern C++ Design", and although they're years old a ton of their advice is still perfectly relevant in C++11. I can't stress enough, however, how important it is to at least check out what's new in C++11 with either an updated book, or online reference like cppreference.com.
&gt; If you create a local variable that lives throught yields (lexically), bad things will happen. If you can't access locals from previous iterations, that seems to negate like 90% of the awesomeness of coroutines. It's the difference between function pointers (yawn) and closures (awesome!).
That was my first reaction too, but then I realized that although you can't access local variables you *can* access instance variables which live from one iteration to the next, which accomplishes the same thing.
Ah, OK. That's slightly less crazy then.
That's fine and sort of what I expected. But is that is also an implementation detail. I still stand by my point.
I think the main difference is that with Wt::Dbo you have to write the database persistence code by hand. With ODB this code is automatically generated. Also ODB has statically-typed, C++-embedded query language while Wt::Dbo uses string-based queries. I am tempted to say that ODB is much more comprehensive, but I am obviously biased. So, instead, here is a list of [ODB features](http://codesynthesis.com/products/odb/features.xhtml) and [Wt::Dbo features](http://www.webtoolkit.eu/wt/features) (scroll all the way to the bottom). Hopefully, this will be a good starting point.
I might be misunderstanding what you are asking, but ... youre doing it wrong? Sorry, that isnt helpful. In c++ you want to know exactly what you are doing, you do not want the some tool guessing what package to use. Modify your class path, be specific about what packages you are using, and know them inside and out. Or am I way off base? Im sure there is some tool out there, but Im not going to search for it. 
&gt; Modify your class path, If your binary relies on the classpath to locate code, then you also are probably doing it wrong (unless you're writing code just for yourself). You have no idea if someone else's program that also uses the classpath has modified it, before or after you did, so that their alternate version of the library you're using appears ahead of the one you expect. Shared libraries made a lot more sense twenty years ago when memory sizes were small and virtual memory tight. Now that our binaries are usually tiny and our data far bigger, they do not. In most cases, static linking is the most robust solution for writing C++ binaries today.
Chill out, man - it's ok. Just use a C99 conformant compiler. Alternatively switch to C++.
If you're on Windows, there's hope: NuGet is working on adding C++ projects in the next release.
I don't know for sure, but the "One more strange loop" case might be a variation of `do { /* ... */ } while(false);` pattern
Possible. But the code looks strange and suspicious.
I usually call it "fisher price" mode myself. But after using it for a while, I get completely lost without it. It's tremendously useful, especially for code I haven't written myself.
I'm curious why you read this subreddit if you find C++ so problematic?
So you re-invented the syntax-highlighting-in-a-webpage wheel using mostly other people's code, and you're not open sourcing it yourself? Then why should I care? Why not just look at the code in KDevelop? How does this help me?
Yes, they are still maintaining it: http://blogs.msdn.com/b/vcblog/archive/2012/06/14/10320171.aspx Not really too much of a surprise. There is still a lot of commercial software out there that uses MFC.
I believe the acronym he was looking for was DRY.
More like Pat is still maintaining it ;) It really is a nice framework, especially considering all the insane work it takes to maintain backwards compatibility over so many years. 
Please stop trolling, Visual Studio is marketed as a C++ compiler and not as a C compiler. C++ != C
I don't know very well. [At a single glance, it looks a bit better](http://processors.wiki.ti.com/index.php/C99_Extensions_in_TI_Compilers)
It'll help you if you're dealing with large amounts of source code you don't want to download to your machine. If you are disappointed this isn't open source (I was at first) checkout [Mozilla DXR][1]. [1]: http://dxr.mozilla.org/ 
Probably the case that it is a bug in the implementation, but in the real work usage there is only 1 element, so it always works. Or they really just want the first one always and it is just terrible readability. There seems to be other areas where they are looping through the UPropSets but only care about the first property info "m_pUPropSet[ulSet].pUPropInfo[0].dwFlags" (note I am looking at the 2010 header)
I think this was a nice summary, and a great demonstration of how to use unique_ptr. Thanks for the article!
I think that should be doable. It's not something that has ever bothered me, but I can definitely see the appeal. I will look into that tonight. I'm thinking the description parameter is redundant, and I'll probably leave that out since xUnit++'s equivalents to Catch's `TEST_CASE` take more parameters.
Looks pretty good. With boost.test status being discussed, we need a good unit test library
I have played around a little more and now have the function: int array::makearray(int a, int b){ int i; int blok[] = {1, 2, 3}; int **table; for(i=0; i&lt;a; i++){ *(table+i) = (int *)new int(b*sizeof(blok)); } where a is input and blok is a temporary replacement of the objects, since I am working in a separate file to practice making the array.
Since you want to store pointers to Block objects, your type should be an array of Block* Block** table; The new operator infers the size to allocate based on the type you use it with. It does not require the use of sizeof() (malloc does, but that is more C-style). To use new, you would do it like this: table = new Block*[b]; //First allocate the array of pointers. // Now loop to allocate for each block for (int i = 0; i &lt; b; ++i) { table[i] = new Block(); } If you wanted to use malloc: table = (Block**) malloc(b*sizeof(Block));
Without knowing too much about Windows data structures, it looks like "handle" is a single item, not a list. So this is using the [uniform initialization](http://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization) syntax, not using initializer lists. An important benefit of the {...} syntax over (...) is that no implicit narrowing happens. If the value cannot fit into the data type, it's a compile-time error.
&gt; That doesn't reduce the deep nesting Yes, it does reduce nesting. Here's what it would have been without the `while` block (and I know of at least one compiler that does this exact transformation to make the loop have a single exit): if (m_pToolBar &amp;&amp; m_pToolBar-&gt;m_pInPlaceOwner) { COleIPFrameWnd *pInPlaceFrame = DYNAMIC_DOWNCAST(COleIPFrameWnd, pParent); if (pInPlaceFrame) { CDocument *pViewDoc = GetDocument(); if (pViewDoc) { // in place items must have a server document. COleServerDoc *pDoc = DYNAMIC_DOWNCAST(COleServerDoc, pViewDoc); if (pDoc) { // destroy our toolbar m_pToolBar-&gt;DestroyWindow(); m_pToolBar = NULL; pInPlaceFrame-&gt;SetPreviewMode(FALSE); // restore toolbars pDoc-&gt;OnDocWindowActivate(TRUE); } } } } The more of this "keep doing work until something fails" idiom you have, the deeper the nesting gets. I find Haskell's Maybe monad to be a particularly elegant solution to this problem, but that falls outside of the scope of this discussion. I kind of wish blocks could be named in C/C++, so that you could break/continue from the particular one you were interested in without being limited to the enclosing `switch`/`for`/`while`. And nested functions would be suuuuper handy, but I digress. &gt; , and it makes the code a lot less clear. I have to agree with you there. A set of `goto`s would have been clearer, but you're right, a separate function is the best option. 
Actually, it's up now. :)
Not having ever used a unit test framework: What does a unit test framework actually do beyond a glorified assert(), and why would I need such a thing? 
Don't use malloc to allocate instances of classes. Just don't.
A more appropriate place to ask these kinds of questions is stackoverflow.com.
Awesome! Thanks a bunch. I have an appointment now, but I'll definitely start building this as soon as possible. 
Wide characters and UTF-8 are two fundamentally different things. There's no way that you're going to be able to read UTF-8 just by plopping in wchar_t and reading into it. You're going to need to use some kind of unicode library. There's `std::wstring_convert` in C++11 (but that requires tool support) and there's the manual `mbstowcs()`/`wcstombs()` route. It's all around better to use a library. Edit: it also looks like you might be dealing with a file that's been double-encoded, because reading a file encoded with UTF-8 with a wifstream should produce pure garbage, not mostly-right-except-for-non-ASCII. Post a hexdump of this file so that we can see exactly what we're dealing with without having to guess. 
In this case, it's the same as member(val). I started writing member{val} out of habit now, as it works better in general. It avoids a few issues like the most vexing parse and unintended narrowing conversions. 
Use codecvt_utf8, it's available in VC2010. Sample: http://www.thradams.com/codeblog/utf8.htm
Thanks, that seems to be exactly what I need. I owe you one. :) Edit: Worked like a charm, thanks imag0r!
Exactly, so why do I need a "framework" for 5 lines of Makefile, and an assert macro or two? 
Hey, if it's working for you, maybe you don't. I personally don't want to keep track of the several hundred methods that assert my production code is working as I expect. Unit test frameworks automatically register or discover your test methods and handle running them for you.
http://www.parashift.com/c++-faq/new-vs-malloc.html
Thanks! Makes perfect sense. Thought it might be something along those lines.
 T* t=new T(...); is for all intents and purposes depricated, there are two ways in which it can be improved, and a major reason it is bad. It is bad because T* is dumb, it does't abide by C++ RAII (you should know what RAII is before you even touch `new`), that is it doesn't clean itself up when it goes out of scope or if an exception is thrown. The first improvement is: std::unique_ptr&lt;T&gt; t { new T(...) }; `t` now abides by RAII, the memory will now be automatically (at no cost!) be cleared when `t` goes out of scope or if an exception is thrown. The second improvement is to realise that you need a container, a raw memory buffer really isn't that helpful, you have to manage it's alloc/dealloc, you have to keep track of it's size, and modifiers are up to you to maintain... Much easier is using a std:: container, the default sequence container, applicable in at least 80% of use-cases is the vector, again you really should know how to use a vector BEFORE you use `new`. http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization http://en.cppreference.com/w/cpp/container/vector http://en.cppreference.com/w/cpp/memory/unique_ptr
Assuming that you want a single dimensional array on the heap where each element is an array of 3 elements, you can do it like this: int (*table)[3] = new int[x][3]; for (int i = 0; i &lt; x; i++) { table[i][0] = 0; table[i][1] = 1; table[i][2] = 2; } delete[] table; The first line declares `table` to be a pointer to an array of size 3. The amount of pointers that we have lined up is `x`, each pointing to an array of size 3. So, of course, we have `x` arrays (or blocks as you called them). We can loop from 0 to `x`, inserting values into each of the 3 elements of the block. We then remember to deallocate the array using `delete[]` (**not** just `delete`). I'll give you the benefit of the doubt because you're only learning C++ but just understand that a professional C++ developer is very unlikely to do it like this. As a general rule, you really want to avoid dynamic allocation on the heap (i.e. `new`). It's only going to introduce complexity and increase your chances of bugs. We had to think about manually deallocating the array when we were done. If we'd have forgotten to, all hell could break loose. The better ways to do this would be to use containers from the standard library. One way would be as follows: std::vector&lt;std::array&lt;int, 3&gt;&gt; table = {{{1, 2, 3}}, {{1, 2, 3}}, {{1, 2, 3}}}; Alternatively, you can my your "block" a struct and have: std::vector&lt;block&gt; table;
Oh, that's very cool. Thanks!
Why don't you just read the text file into a plain char array? This way the encoding stays intact. If you want to extract single characters (utf-8 is a multibyte encoding) or for getting the code points you can use a function like this: http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
Read Joel Spolsky's guide to Unicode. I must admit, I'm a little jealous that you're learning thist stuff in school..
Fix8 requires the followin third-party software (header files and libraries) being installed to build properly: - Poco C++ Libraries basic edition - Intel Threading Building Blocks - Berkeley DB C++ 
What is the difference between this engine and the QuickFIX C++ engine? Personally, if I made the library I would use the &lt;&lt; semantics for creating messages and use the move constructor semantics rather than using new. I have just looked at myfix.cpp so far, so that may be non-representative of the way it should be used.
Can you highlight some of the reasons to choose this framework over QuickFix?
What i don't like about your articles is that they only exist to make your product more popular.
How is this better or different than Google's gUnit?
Very interesting buddy and you are using a modern C++ approach also, gonna check it ;) thumbs up for ya
I see, you seem to have a different approach to managing the unit-test code, I'll think about it, thanks. 
The benchmark code and details of their test setup should be distributed along with the code to back up the high performance claim. At the very least it could serve to catch the attention of people for whom performance is critical, as it allows easy benchmarking on their hardware setup.
Oh, I thought you were one of the author of fix8. I saw what you posted on that site too, but I was looking for a contrasting argument between fix8 and quickfix.
I know the author and yes it has been used in production
Aren't all ``#pragma``s non-standard? (As in not a part of the C++ standard, but possibly standardized elsewhere, like OpenMP.)
They did the __keyword thing for the first version of managed c++, and everyone complained about it, so in the next version c++/cli they changed it.
Are chars 2 bytes? I always thought they were 1, and that the padding came from the compiler 4-byte aligning things.
sizeof(char) will always report 1 in C++, so yes ascii chars are represented by a byte.
If you define byte as 8 bits, I am not so certain that is true. There are plenty of emmedded platforms where the lowest common denominator is not 8bits. There is a marco constant `CHAR_BIT` that provides the bit width of a single char. i would be interested if you know otherwise.
The size in bits of a char is completely irrelevant. `sizeof(char)` is 1 by definition; it cannot be any other value. All sizes are based on the size of `char`, whatever that is. 
This person writes this whole article without even the faintest hint that this information is implementation-specific, platform-specific, and architecture-specific, making it pretty much useless for any real purpose. You can't depend on any of these things being true, and if you do you are probably doing something fundamentally very wrong. 
http://dlib.net -both nice code and nicely documented. 
The Scott Meyers book should be read by ever c++ programmer out there... and its well worth considering trying to present some of its points even at the intro level. Reason being... there are points in there that really caused me to push my understanding of how things worked. It might be a BIT over the heads of someone new to C++, but I think some things could be presented selectively... and its full of good examples that expose misunderstandings.
According to the C++11 standard, section 5.3.3 (Sizeof), sizeof (char), sizeof (signed char) and sizeof (unsigned char) are defined to always return 1. Any other sizeof of a fundamental type is implementation-defined. Section 3.9.1 (fundamental types) mentions that chars need to be big enough to represent the implementation's basic character set. So, though a char may be bigger (or smaller) than 8 bits on some platforms, sizeof(char) is always guaranteed to be 1.
You can try the example code from C++ Primer [here](http://www.informit.com/title/0321714113) (under downloads).
That just sounds like a version of the broken window fallacy to me. "C has a lot of sharp edges, and so you learn valuable bandaging skills what with your hands getting sliced open so often." Mistakes like forgetting to add 1 to account for the nul terminator or forgetting to free something simply don't happen when you take the top-down approach and start with high level language abstractions. The example in the link would be written: string hello = "Hello", world = "world", helloworld = hello + ", " + world; ...and both problems vanish. Now, please don't get me wrong: there are tons and tons of sharp edges in C++, far more than there are in C. Undefined behavior lurks at every turn, and you absolutely must ~~get cut~~ learn how to approach the concept of undefined behavior. Most certainly, that's an essential skill. However, the point being made is that you can ease into it. You can start with high level abstractions that have round edges, and as you write more sophisticated programs you can work your way down to minutiae and talk about all the underlying gremlins as they come up, rather than on day 1 when you're still trying to learn for loops and how to write a basic program.
The thing what happens is that when people hit C++ without prior C knowledge, they are simply overwhelmed. C++ really has very similar problems, that C has (not true for C++11). And what happens when people are overwhelmed? They oversimplify things. It is a path that easily leads to very bad programming patterns. Granted C -&gt; C++ is a harder and longer path, but it's the one that is more valuable. Going to C++ directly is possible, and for certain types of people it works perfectly, but for the typical programmer it's a very dangerous path. Of course I'm talking from my teaching experiences and most people that go through C and C++ course will never touch C or C++ again, so these may be the same people that can't handle C++ directly (again C++11 is changing that).
Beginners are not going to be able to "see" the style of the code. It will just look like gobbledygook. 
This is a really good point, I don't know if you have a recommended a text book yet, but if you are going with C++11 i would recommend The C++ Primer 5th edition, if not Accelerated C++ is still the best C++03 book.
There are a few things I think you need to tell us. * Are you teaching C++ or C++11? They are very different * Have you chosen a core text yet? * Are you teaching C++ so that they can actually be good C++ developers or as some sort of way of getting students to thing about pointers and the like -- if the latter just use C. * How good is your C++? do you know about the containers, algorithms, templates basically idiomatic C++?
I think I may have replied to you in another thread about this exact same thing but my GOD C++ Primer 5th edition really kicks the llama's ass.
Yes almost certainly, I regularly tout "The C++ Primer 5th" until "Accelerated C++11" comes along it is a the best book to learn from. And a good book is in my opinion the key to learning C++ properly (there are so many bad book and online tutorials out there).
sorry it has to be savitch
[That is a terrible way to go](http://xkcd.com/386/). Anything you can do in C is so much less painful and so much more easy to understand. 
I would recommend the Gang of Four books. All the Effective C++ books are good, Guru of the Week and Herb Sutters current blog, and Cert C++. I say, DO expose them to currency (Herb can help you there), DO expose them to C++ 11, and DO teach them the STL and smart pointers. Give focus on the algorithms, and incedental focus on the containers. I mean, teach them raw pointers, to be sure, but then be all, "Good. Now that you know raw pointers, you'll never have to write them, because we have shared pointers..." Teach them about make_shared, and Herb's make_unique. I say teach containers incedentally, because the STL isn't about the containers. I think you can cover their interfaces rather quickly, and not focus on their implementation. I think you should cover the trade-offs for each, because they all exist for a reason. DON'T tell them they can swap out containers later, because a map for a vector are nowhere near interchangable. Do make reference to design patterns. Do teach the S.O.L.I.D. principles. DON'T teach a framework or API, otherwise, your students will write everything as though it were a framework or API. Stress accessors and mutators are a bad sign, and violate encapsulation, data hiding, and exposes implementation. Do empower them to self study. Link them to the GotW, Sutters, Meyers, and the blog posts about everything a computer programmer should know about floating point numbers and the other everything a computer programmer should know about unicode.
Can you post what you have on pastebin or similar please?
Sounds like you're trying to access a member of the stuct with only a prototype? 
You don't need two sets of attributes for the struct. You only need one set, and to declare multiple objects from the struct. While your code would *technically* print two "different" humans, you're actually giving the same object two different sets of attributes, which isn't *technically* correct. struct Human { std::string name; const char sex; // 0 = Male; 1 = Female int age, health, strength, stamina, magic; } human1, human2; Then you would modify each obj (human1 and human2) separately: human1.name = "John Doe"; human1.sex = 0; [ ... ] human2.name = "Jane Doe"; human2.sex = 1; [ ... ] Would be better.
In C++, the only difference between a class and a struct is the difference between default access permissions (structs are public by default, classes are private by default). At least, [according to IBM](http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8a.doc%2Flanguage%2Fref%2Fcplr054.htm)
~~Structs don't have member functions.~~ It would be a good idea to take advantage of OOP if you're using C++, and having all of your variables publicly accessible isn't good practice for OOP. I would very much appreciate it if everybody leave a reply instead of just downvoting. You aren't adding anything to the discussion. You're actually hurting it by burring potentially useful information. It just frustrates me that I'm trying to post helpful information and I get downvoted. Maybe it will work with some compilers, but I'm pretty sure it's not part of the C++ standard to have member functions of structs. OP, you don't seem to understand how classes/structs work, so I'll try to help. The the class/struct is like a "blueprint" for the object. A new copy is made every time. Your struct "game" is a type, like a int or char. So you would have two instances, like "game player1, player2;" Then you set the variables separately for each instance. I still think you should call it "human" like the description says and you should use a class, and have all the variables private and set from the constructor. I would probably use a bool for the sex because you aren't going to have more than 2. You could have a member function that prints the information, so you could do something like player1.print() without having to access all the variables publically. Part of the idea behind OOP is abstraction. You don't know how cout works. You don't know how strings work. You don't really care or need to know how they work to use them. Every string you create is an object of the string class. cout is an object of ostream (output stream). They're both classes that are built into C++. So the idea is to get a smaller part of the program working that you can reuse, and then you never worry about having to make it work again. You should get your class working, and then treat it like you don't know what's going on inside, like a string. Your class might look like: class Human { private: string name; int age; bool sex; int health; int strength; int stamina; int magic; public: Human(string name, int age, bool sex, int health, int strength, int stamina, int magic); void print(); } I didn't write those functions for you, but basically, you already did.
funny you should mention C because that was my first language. I am really tempted to try an push C next year as the first language.
Thank you both for the answers. I never had to work with comparison of floating numbers up to now, and I probably would have tested it like integers.
In base 10 the value 0.2 seems simple enough; it can be represented with only one significant digit. But to represent it in base 2 requires an infinite repeating series of digits, much like how 1/3 in base 10 goes on forever. IEEE floats and doubles only have a fixed number of digits, so they can't represent 0.2 exactly, they must choose a nearby value that is very close but can never be exactly equal to 0.2. When you write the literal value `0.2` (or `0.2d`) in the source code of a C or C++ program, you are expressing the IEEE double precision value that equals 0.200000000000000011102230246251565404236316680908203125. When you write the literal value `0.2f` you are expressing the IEEE single precision value 0.199999988079071044921875. As you can see, these are not the same value -- as the double has more digits it can represent a value closer to the true value. Therefore when you write an expression like `float f = 0.2` you are implicitly changing the assigned value from the number represented by that previous first long string of digits to the value represented by the previous second somewhat shorter string of digits, because some digits had to be chopped off to make it fit. When you later try to compare it to that first long number, it's not equal. 1.5 can be represented exactly in both bases with a small number of digits (it's 1.1 in base 2) so the issue doesn't arise in your second example as there is no conversion necessary. You should really just never use `float` at all. Using `double` for everything removes a lot of the hassle of having to remember to add `f` to all your literals, and it also gives you a lot more head room for accuracy. In this day and age there is usually no benefit to using `float`, except in certain specialized circumstances.
aka [boost::irange](http://www.boost.org/libs/range/doc/html/range/reference/ranges/irange.html)
Just wait until you have to deal with NaN values ; ) Floating point is ... different. 
for (int i = 0; i &lt; 10; ++i) Just sayin. 
Another example of why we should be using ranges instead of iterator pairs and algorithms. `std::iota` should return an object with a `begin` and `end` like TFA's `enumerate`, not some useless algorithm that you can't even print out with `ostream_iterator`s.
I had never considered deriving from the unknown (but well-defined) lambda type. I'm going to have to think about that one.
Ah, I see. Though, with perfect forwarding, one can write a duplicate of the STL that *does* work on ranges. In that case, there is no difference between push and pull semantics in terms of the code generated. That's largely the point of the library I'm working on.
Good to know. Thanks.
&gt; In that case, there is no difference between push and pull semantics in terms of the code generated. I don't think that can really be true - even if everything is inlined and every branch is statically predicted, the organisation makes a real difference in the code generated, and can have (probably minor) performance ramifications. When you can't statically predict all of the branches, though, things get more interesting. Say the part of our code we're interested in naturally falls into two parts - a producer and a consumer of data. Neither is trivial - they're both moderately complicated and stateful processes. With a "traditional" design, one has to drive the other. Either the producer says, "I've finished making the next item, now you deal with it," or the consumer says, "I'm ready for the next item, please generate it for me." When control returns to the "master" function, execution resumes from the point of the child function call. For the "slave" function, though, it can be harder to "pick up where it left off" unless it's a proper coroutine/generator with something like "`yield`" instead of a regular function call. I'll give a simple example: command-line argument parsing. We'll have long flags, long options with arguments, short flags, and short options with arguments. Say the short options with arguments are '`a`' and '`b`'. The producer's job is to "normalise" `argv` from {"--long=5", "-sahello", "--", "-asdf"} into {"--long", "5", "-s", "-a", "hello", "--", "-asdf"} The job of the consumer is to use that token stream and set some variables appropriately. Now, assuming we don't use coroutines or true generators, which process should drive the other? Clearly the consumer is sensitive to context. If it has just parsed the option "--long", it should react to its next argument accordingly. If the consumer was the "master" function, part of it might look something like for (auto i : args(argv, argc, "ab")) { if (*i=="--long") { ++i; long_opt = atoi(*i); } else if ... } See how the context is preserved? We use the knowledge that one token was "--long" to know how the next one will be used. If this was the slave function, though, we'd probably have to do something crap like switch (status) { case NONE: if(arg == "--long") { status = LONG; return; } else if ... case LONG: long_opt = atoi(art); status = NONE; return; ... } There's no context when we enter the function, so we need to "restore" it with something like the `enum`/`switch` thing. Performance probably isn't an issue in this case, but indirect branches like that might be costly in different circumstances. On the other side of the coin is the producer function. It should be clear enough that it too has to maintain state across different calls, so you have a similar tradeoff to make. Life might be simpler if there were only one way to specify a given option, but if `{"--long=5"}` is the same as `{"--long", "5"}` you're pretty much stuck with one of them having to manually reconstruct its own context (or using coroutines).
Thanks, great article, a pleasure to read!
[PDF]
CLang already has some form of experimental support for them.
&gt; I have a thing against template meta programming, especially when i can achieve the same thing, and efficiency, without it. How so? Your `vmap` and `print` definitions are templates.
Does this mean no more #pragma __declspec(dllimport) ?
&gt; Clearly the consumer is sensitive to context. If it has just parsed the option "--long", it should react to its next argument accordingly. If the consumer was the "master" function, part of it might look something like for (auto i : args(argv, argc, "ab")) { if (*i=="--long") { ++i; long_opt = atoi(*i); } else if ... } &gt; See how the context is preserved? We use the knowledge that one token was "--long" to know how the next one will be used. Another possibility, although I haven't worked it out yet, is to write a parser with continuations so that when "--long" is encountered, the responding function is called on the next iteration.
There is a WG21 study group for modules (SG2) that is chaired by Doug Gregor, but the associated mailing list is very quiet. The only other document that has been posted is http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3426.html (Experience with Pre-Parsed Headers)
The operative word is *meta*. I use templates to write generic functions, not to describe generic compile time calculations. More specifically, we're talking about [compile-time class generation](http://en.wikipedia.org/wiki/Template_metaprogramming#Compile-time_class_generation), which at one point was an important technique for optimizing code generation, is now outdated as compilers have improved. The Factorial example wiki gives could be rewritten as a constexpr function and the compiler would be **forced** to generate the answer at compile time, given a literal number (fact(10) but not fact(x)), but it would also work on any number you threw in so it makes one wonder why someone would still write a Factorial class.
No, the problem this proposal wants to solve is not that one.
From the recent C++ Q&amp;A session: templates are *the* big problem (and a major reason it was pushed into a separate TR), but modules are supposed to solve / replace "export templates", too. But yeah, it's overdue. I just wonder how long it will take from "it's standard" until tool chains will be able to cope (i.e. IDE, Debugger, Profiling / Instrumentation etc.)
Why... What is your reasoning?
&gt; Static libraries don't work well (and often not at all) for modern C++. That's funny. I have virtually no problems with static libraries. It's dynamic libraries that I have a very difficult time with -- especially on Windows.
Actually there is a precedent for this already in the stdlib and in Alexander Stepanov book *'The elements of programming*' that is functions that take an iterator pair, should also provide an `f_n` functions, (like `std::fill_n`) which take an OutputIterator, The only problem is the stdlib hasn't given a `std::iota_n` which is shame.
Please let me elaborate: Static libraries do well what they can do. They can't (anymore) do what they are supposed to. Static libraries were supposed to distribute already compiled code, to reduce build times in large projects. They should also provide a reasonable isolation of public interface and implementation details (public interface in the headers, all the implementation details in the library.) They fail to do so in multiple ways. Large amounts of code moved to headers in the recent decades. Projects got much larger. Compile times did not improve with the massive improvements in hardware. C++ headers combine the "public" interface and the "private" implementation details (you can avoid that, but it costs extra). Common implementations can't define their own dependencies, dependency analysis that could be automated needs to be done manually. Large projects suffer from stale includes that are no longer required, increase compile times but are hard to remove. This was all not a problem back when a C header contained a few structs, defines and function declarations, and the majority of source were in .cpp files. C++ has changed that, lib's haven't. ---- [edit] I agree that dynamic libraries are even worse for C++. However, they, too, need better language support. 
&gt; write a parser with continuations [From the c2 wiki:](http://c2.com/cgi/wiki?ContinuationsAndCoroutines) &gt; Coroutines are just two or more continuations that call each other whenever they block, end, or just feel like being polite. At the end of the day I think all code wants to be "in control". It always looks nicer to write a `for` loop with a function call (or `yield`) in the middle rather than an iterator type supporting some operations, and it only gets nicer as what you're doing gets more complicated. Call/cc is probably too heavy for C++, but if coroutines can be implemented efficiently I think they're the best tool for the job. I haven't quite figured out how they work at the assembly level, though, so I don't know how efficient they can be, or how they'd interact with (or preclude) compiler optimisations.
You might be right about coroutines, but... &gt; Call/cc is probably too heavy for C++ [I think not.](https://github.com/splinterofchaos/Pure/blob/cont/Pure.h#L1647) Though, i have to admit I never bothered to implement the monadic callCC, just runCont. (Code's a mess, too.)
boogers should be pimpld or pickable...
There are so many good things about C++11, but then people like to overcomplicate things in the name of simplifying them.
I was dumb, like I said before I'm a newbie (never ever done any type of programming of any kind). The problem was that I chose windows application instead of console application, which was why the console never showed up, once I changed that I got the program up and running as it should have from the start. Thanks for your help and input though.
Can you make your implementation more abstract to work with numbers and strings? If you do that, I'll follow your blog and hope that your idea enter in the next C++ version. =)
I'd recommend you to use Microsoft Visual Studio. It's way better then DevC++. 
It shouldn't matter what program you use to compile, you should be able to get the same result from your program whether its compiled in Visual Studio, DevC++, or gcc. I'm sure the course material calls for DevC++ and I do agree, Visual Studio is pleseant to work with. Did you add the DevC++ directory to the Windows enviroment variables? If anything, post your source.
Yep. This is a good idea. I'll get the details of our test hardware and methodology onto the site. \dakka (author of fix8) 
Dev-C++ used to be a great alternative to Visual Studio, but that was many years ago. It's now pretty much a dead project, and lacks a lot of the polish that other IDEs have. You're handing in C++ code, and it doesn't matter what you write it in since the programs don't leave any kind of distinguishing mark on the program. I would recommend trying out other tools, since as I said above, pretty much all of them will be better than Dev-C++.
http://i.imgur.com/rhwUt.jpg
I downloaded both when I was having trouble with DevC++, for some reason the same code that ended up working in DevC++ didn't work in neither Code::Blocks nor Visual Studio...
I just thought that my source code was unnecessary (as it turned out to be), as you can see above where I figured out the problem, I don't think anybody would think that I was dumb enough to do what I did and not figure it out on my own. I'll have that present for other questions though, thanks.
d'oh! You bastards!
How about taking this to [r/cpp_questions] (http://reddit.com/r/cpp_questions) or stackoverflow? The amount of newbie questions on this subreddit is becoming depressing. And this question isn't even cpp, it's an IDE issue, and one which is utterly unsolvable given the lack of info OP has provided!
Thanks, didn't know about cpp_questions I am aware that its probably an IDE issue, but im kind of frustrated by the issue and thought maybe some people around here use VS and have seen this before. Sorry for my unclear post but as it stands i have very limited information/don't where to start to troubleshoot this.
The thought of approaching the subject from TDD is interesting
Are there any good C++11 resources out there?
I really enjoy cppreference.com for a user edited wiki. There are some new C++ books, some of which are referenced [here](https://groups.google.com/forum/?fromgroups=#!topic/comp.lang.c++.moderated/XjGZp8MYehQ). I cannot give personal recommendations because I haven't seen any of the books, just heard a few things.
Just FYI it's good practice to throw things descended from `std::exception`.
That was truly a beautiful read, you brilliant person! Upvote this post for visibility.
Nice! I do wish he had implemented CLOS instead ;)
reverse_wrap wouldn't work if step is different than -1. Also, the renumerate idea is more to a workaround than solution, but I'll follow your blog anyway.
C++11 auto/decltype are fundamentally different from dynamic typing. Given auto i = m.equal_range(k), i has a static type. It is fixed at compile-time. It is simply implicit in the source code, because the compiler already knows what the return type of equal_range() is. Therefore, i is eligible (as usual) for the full set of compile-time optimizations, including stuff like inlining. This is radically, fundamentally different from dynamic typing, which works at runtime.
It's implemented as a library: [Mach7: Open and Efficient Type Switch for C++](https://parasol.tamu.edu/~yuriys/pm/) 
I'm not a professional by any means, but wouldn't working on an open source project help you learn a little and help build a portfolio. If you still don't feel you know enough, pick every day computer tasks that you wish were more simple and make something for that.
Open source projects are a great and respected way to get deeper into programming. Especially with C++ experience is highly relevant, since you can do so much things wrong with it. In OSS projects you will get into contact with experienced programmers who can tell you what you did wrong. Search for something you are interested in, maybe something you actually use. Then just start fixing small bugs, later maybe add some new features. There is always some work to be done. Additionally you will learn about a lot of tools needed for everyday work like version control, that your school most likely didn't go into very much.
OPEN SOURCE. You can get any experience and practice that you want. Want to learn the depths of template madness? Go build something using Boost. Want to learn GUIs? Go work on KDE or something. There is no excuse for not having a programming portfolio, if you just make time to do it.
or QT
I meant to say... Look at rfcs for internet connections / protocol / socket development.. look at directx and opengl for graphics get good with the cstring and string library.. although I prefer c strings... practice your pointers and dynamic memory allocation both in the c++ way and the c way
KDE is actually one of the most pleasant and developer-friendly open source projects. I loved learning from KDE. But the environment itself. ZOMG.
Too bad I can't see this on an iPhone.
Collider is defined in the base class with type Collider and name Collider. That's the Collider.Location modified and leading to fuckups.
Oh man. Base classes. :) Okay, so here's another really important rule: * Wherever possible, build classes with composition instead of inheritance. An entire set of classes based entirely upon inheritance will cause you no end of grief, *especially* if you delve into multiple-inheritance. Always try the "has a" approach before "is a". I currently use inheritance for three limited scenarios: * I have a BaseObject class which implements boost::intrusive_ptr (so I get smart pointers w/out extra memory allocations), and support for memory pool allocation (via new/delete overloading) so my dynamically-allocated objects can be either pool-allocated or heap-allocated and still get deleted properly no matter where the allocation came from. * I use base classes when I'm going to need to have a collection of differently-typed (but strongly related) classes that are required to be in only a single collection instead of multiple collections. * I use base classes for when I need a set of consistent interfaces (Public API design is your friend) across different object types. These interfaces do not contain state and consist entirely of virtual methods. These are the *only* classes I will use in combination with multiple inheritance.
You did well to come here. Theres three big things I want to point out: 1. You should probably put n1-9 in an array, probably a 3x3 array. 2. That goto needs to be replaced with an actual for or while loop. 3. The massive if-else ladder that's looking for 3-in-a-rows should be made into loops as well (youll need that 3x3 array to do this). Probably one loop to look for verticals, one for horizontals, and then an if statement for each diagonal. Make those changes, then I'll take another look for you. Good luck!
out of interest, how are you learning? With respect, your code has basically no structure and is entirely controlled by if and gotos. This really isn't a good thing. With dedication C++ can be a first language but you should pick up a good book, such as "Accelerated C++". 
Whoa there. Is this the place to start _that_ discussion? C++ is a nice language. It's also very flexible about the type of programming you can do with it. If you start learning and you stick to its iostream i/o and STL patterns at first, you'll be ahead of the game in many ways.
it doesnt make a massive difference in terms of memory or performance, but generally if you know it's going to be fixed size it does make sense to use an array
Its always good time to start this discussion :) Especially for OP, who is just starting his adventure with programming. One way to keep being motivated is to get some nice visible results off the bat. With C++ he wont get to this anytime soon and some of the problems involved may not be interesting to solve. Picking language with 'less warts' like C# or Python, will both get him to some interesting stuff faster (rolling a 'simple' gui in C++ is something much harder) which will help motivation and let him concentrate on 'programming' instead of C++ specific things which may or may not be interesting for him. Im not saying C++ is bad language (i myself like it a lot, consider it 'best in slot' for many tasks, and it is my first language not counting short encounters with others), but flexibility is not something you really want on this level, when you are beginner. Flexibility means there is no 'right' way to do something, which can be overwhelming. C++ stdlib is laughably tiny compared to practically any other language stdlib out there. Not saying its a terrible idea, particularly if he's interesting in knowing more about inner stuff of lots of things, but definitely something to consider at such an early stage of education.
Any software certification will do. This is for my resume more than anything else. 
at the time I wrote this I was in the middle of grade 10 intro to computer science
There is Tic-Tac-Toe console implementation in the book of Michael Dawson - Beginning C++ game programming. It is a quite interesting read. See chapter six.
Unless you want to commit every single "Does it work now?" save, that would be an unacceptable solution.
You didn't get my point. Maybe you have an MS in CS, but what about all the other fields? Keep getting them if you keep wanting more.
Yep! C:\Temp&gt;type meow.cpp #include &lt;iostream&gt; #include &lt;ostream&gt; #include &lt;tuple&gt; #include &lt;utility&gt; using namespace std; pair&lt;int, int&gt; meow() { return make_pair(9, 10); } void print(int x, int y) { cout &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ", " &lt;&lt; x * x * x + y * y * y &lt;&lt; endl; } int main() { int a = 1; int b = 12; print(a, b); tie(a, b) = meow(); print(a, b); } C:\Temp&gt;cl /EHsc /nologo /W4 /MTd meow.cpp meow.cpp C:\Temp&gt;meow 1, 12, 1729 9, 10, 1729 tie(a, b) returns tuple&lt;int&amp;, int&amp;&gt;. pairs can be assigned to tuples, and assigning pair&lt;int, int&gt; to tuple&lt;int&amp;, int&amp;&gt; writes through the references to a and b.
Well you could return a pair&lt;&gt; and use auto myPair = myFunc(); but it won't automagically decompose into separate variables. So , no multiple return values afaik but assuming you're in control of the function then you could use references or pointers to achieve the same thing: //function to call void myFn(int &amp;val1, int &amp;val2) int x, y; x = y = 0; myFn(x, y); or //function to call void myFn(int *val1, int *val2) int x, y; x = y = 0; myFn(&amp;x, &amp;y); In both cases you would set val1 and val2 in your function and it'd change the value of x and y. As it stands you can't initalise the variables and assign in a single expression as they'd go out of scope. I prefer the pointer explicit syntax really as it makes it clearer in code that calls the function that the address is being passed and the variables will be modified (ignoring const correctness discussions) The other thing I'd question is if you're returning two related bits of information perhaps you should consider a struct or a class (like you were originally).
was it intentional that 1^3 + 12^3 = 9^3 + 10^3 = 1729?
Yep! This is the [Hardy-Ramanujan number](http://en.wikipedia.org/wiki/1729_%28number%29).
Because it's less readable, particularly when you have a lot of parameters already. Python, e.g., has this feature built-in without need for "tie": def foo(): return 23, 42 a, b = foo() Simple, clear, easy to read even if you don't know Python...
STL's answer is good, but as "virtual void" below points out, it's often better to return a struct. In particular, a struct allows you to avoid "position bugs": pair&lt;double, double&gt; getTemperature() { return make_pair(getCelsius(), getFarenheit()); } double f, c; tie(f, c) = getTemperature(); // Oops! printf("f=%d, c=%d\n", f, c); vs struct Temperature { double celsius_, farenheit_; }; Temperature getTemperature() { Temperature t; t.celsius_ = getCelsius(); t.farenheit_ = getFarenheit(); return t; // or return {getCelsius(), getFarenheit()}; in C++0x // but that has the same possible bug // though only in one spot... } Temperature t = getTemperature(); printf("f=%d, c=%d", t.farenheit_, t.celsius_); // No possible bug.
That's a ridiculous argument. If one learns an approach in one language, it is absolutely appropriate to make use of it in C++ if it offers advantages in some sense. I borrow concepts from Python, Haskell, and Lisp all the time when doing C++ development. Why wouldn't I? Other than just being ideologically driven about how 'C++' code should look, why wouldn't you adopt something you learned from another language for the sake of improving readability, maintenance, safety etc... I'd say the most recent example of me borrowing techniques from another language is Go. Having used Go and coming to appreciate its idiomatic approach to multithreading via channels and go-routines, I now use the same approach in C++ and am enjoying the benefits of it.
Ugh.
Similar to tie, you can use std::ref: #include &lt;iostream&gt; #include &lt;functional&gt; #include &lt;tuple&gt; std::tuple&lt;int,int&gt; foo() { return std::make_tuple(5,6); } using namespace std; int main() { int a; int b; make_tuple(ref(a),ref(b)) = foo(); cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl; } 
It might be worth to note that this is actually working pre-C++11
&gt;we are heading to a world that will make the invasions of Orwell's 1984 seem desirable by contrast He's a smart guy and all, but he should leave politics alone.
Care to explain the downvote?
No, that's not quite what I mean. I just found his alarmist views irrational.
The inotifywait command line tool is very handy for this kind of thing. I use a more sophisticated version of: while inotifywait -e modify /path/to/source; do make done to do a build every time I hit ":w&lt;ENTER&gt;".
He said this in the context of privacy. The privacy invasions of *1984* basically amounted to "you're on webcam all the time".
The C++11 support is still incredibly weak, lagging way behind clang and gcc, but the IDE is decent. Personally though I'm moving my Windows codebase away from VS and towards Mingw. As much as I like the VS IDE and came to learn C++ using it way back with VS 6... as of recent I like C++11 a lot more.
The IDE is great as far as I'm concerned and I think Microsoft has done a great job with .NET languages and support. C# is a blast to use so I really don't understand why both C and C++ get the short end of the stick with absolutely horrid support, bugs and a lack of standard compliance. I guess I get so angry about it sometimes because I feel rather helpless, like I'm pretty much stuck with MSVC for Windows development despite having to always fight against the compiler and restructure my program so it will work under MSVC. I'm using this product to see if it will make the transition to GCC easier while still allowing me to use the IDE: http://visualgdb.com/download/
There is quite a bit of fine print with respect to their 'full support' of the standard library. GCC is a lot more open and transparent about what they support and what they don't, so you can clearly look it up, whereas with MSVC you kind of just find out that something isn't properly supported when you try to use it and it fails miserably and you spend an hour trying to decipher whether you made a mistake, or whether Microsoft isn't being true to the standard. Case in point... std::bind The reason this matters so much in C++ is because things are overloaded in the language. So you make use of a function or method call and it turns out that MSVC only implemented one of the overloads, but not the other, and the compiler ends up converting your arguments to invoke the other overload that you did not expect to be called and so your program compiles just fine, only to crashes or behave in a strange way at runtime. That is not something fun to be spending hours or even days fishing out. As for releasing incremental updates, they said the same thing about VS2010, and they had one single service pack that added a few features, which was nice but no where near as comprehensive as they lead on about it. Can you tell how bitter I am over this?
IMO: std::unique_ptr and std::shared_ptr (with std::weak_ptr, too).
Unless everything you allocate is from RAII objects, you're going to have to call new/delete at some point. If you want to keep optimized lists (for example render matrices, animation skeletal data, etc) in tightly managed areas that are close together to minimize cache misses and fragmentation, I'm not sure how that could be accomplished with just RAII. I'm not too much of a systems guy though, so I'd be intrested if someone has done this. I've typically gone the route of managed pools - but of course that means I need to manage the memory myself.
* make constructor private * expose Create() that returns a shared_ptr to the object ...
Why do you need a garbage collector? I have never found a use for one in modern c++.
Simply put you shouldn't be forgetting to delete things, or be deleting things twice. Using smart pointers removes the need to delete manually and so mitigates both these problems.
Have you considered just using a tool like [valgrind](http://valgrind.org/) and fixing leaks, instead of trying for GC? There's a little inner OCD guy in me that, when using languages that aren't inherently GC'd, likes to make sure stuff doesn't leak in the first place.
Thanks, I'll give this a look into. But, I just want to be able to clean up my objects when I delete them, and fix those darn memory leaks, so could I just add a few headers and lines of code and be off? 
Yes! Thank you. 
You're using the wrong language if you have to ask that question. Alternatively, the project you have chosen for yourself is WAY above your current abilities.
1) boehm's gc. It's a little tricky to use in C++, but it will get the job done. 2) smart pointers. Your best bet. 3) my little own prototype system: https://github.com/axilmar/a5gc.git 
If you do this to get experience in C++, using a GC is not the way to go. There is no garbage collection in C++ for a reason. Understanding the constructor/destructor concept is central to understanding the language. Using a GC will lead you to programming the wrong way. One of the reasons to not use a GC is [RIIA](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization). There are other reasons, too. C++ on any level of expertise requires you to think about the life cycle of objects instead of just leaving it to a GC.
I am not convinced that adding a GC in the middle of the project will be less work than fixing the memory leaks. Also, if you wanted a quick prototype, why didn't you stick with C#? If the answer is speed, than adding a GC is pointless. In addition, current modern C++ tends to avoid raw pointers and use RAII and shared_ptr/unique_ptr.
C++ is not a prototyping language. If you're having memory leaks now, you'd better figure out why or it'll bite you in the ass later. Changing to a GC system means justifying your ignorance by claiming knowledge is unnecessary.
Ownership relations are inherently acyclic. Mesh triangles don't own neighbouring mesh triangles. The mesh itself owns the triangles.
I hope you are aware of the rule-of-three.
Or: why not just learn how to do a proper design in which only a tiny fraction of classes actually need a user-defined destructor. ;)
How about a virtual machine?
I'd go with the previous mentioned array or vector implementation. Break up your code a bit. Make some functions SetupBoard GetPlayerMove GetComputerMove DisplayBoard stuff like that. Makes it much easier to follow if things are broken up into meaningfully named subroutines.
Note however that there is a class of objects for which GC is just a huge conveniance. These are things like strings or other objects that are 'memory' only. Either way, its better imo to have a general solution then something that will sweep the garbage every now and then under the rug.
Because a GC *won't* just be adding a few headers to your code. Additionally, a tool like valgrind helps with fixing the root cause [memory mistakes] wheras a GC just kind of veneers over bad code problems. Also, get in the habit of using valgrind anyway; it'll find bugs in your code that you didn't know about, and might have been masked on your system but that might manifest somewhere else.
Well, C++11 has a GC API, and later standard might have a real GC.
&gt; The core part of this program's functionality is provided by cling, which is developed at CERN How do I get this job.
What does refactoring have to do with compilers? That's an IDE feature...
Sort of. To refactor properly in general, you really want to have a full C++ frontend (ie parser and semantic analysis). Having a separate parser just for the IDE means the refactoring tool may have subtle differences (bugs, interpretation of vagueness in the standard, etc) that can lead to issues. These days the trend is to put some refactoring capabilities in the compiler. Clang is a good example of a compiler that supports refactoring built-in, in a very general way. Of course you probably want to wrap that in an IDE. However, having the support in the compiler also lends itself to doing refactoring on the command line or through some scripting in an editor like emacs or vim. So it's not unreasonable to think of refactoring as a compiler feature, likely supporting some IDE.
Yes. :)
I have yet to see anything but a compiler that can parse c++ correctly.
You can't do variable renaming and other semantic analysis without compiler support. You can try and hack it, but a real solution requires the support of the compiler front-end, which is why it's included in this list.
If my memory serves me, it was [this](http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53223). &gt; I am unconvinced that MSVC's C++11 support is better than GCC's by any definition. I don't require that you share my opinion, but try to see it from my perspective. Our codebase is multi-platform, so a missing feature on any target means the feature simply doesn't get used. MSVC is a bigger limiter here, but continuing to do things the C++98 way is zero cost to us. We only require that the features that are supposed to work... work well.
Visual Assist X does the job well enough for me. Conformance 1, 2, 3 + performance 1, 2 were the only obvious answers. It sounds like the rest of this stuff is coming, but it may just be pushed back until VS2014.
You can have many different meshes that share triangles and are edited dynamically. You can have other polygon shapes also. Sure it is possible to have the memory owned by some finite set of "roots" which could be the distinct meshes or something else and use reference counting. It's always possible. The point though is that requires extra thought and extra coding compared to a simpler design using garbage collection. 
Yeah, this is very interesting, but the problem I have with it (in general) is the amount of knowledge required about the interiors of encapsulated structures to do the "right thing" every time. Programming the space shuttle replacement? Sure, why not. Anything else? Don't bother. Still really neat to know though.
Visual Assist X is a hack rather than a real solution, but it does a very impressive job nevertheless.
Pictures of cats!
The rest of them.
In VS 2012, open up the C++/CX header collection.h, and search for "meow". (Yeah, okay, it's not a picture.)
What the fsck javascript that page has? this is the first page that managed to make microb totally unresponsive! anyway, what I wanted to see is elimination of headers and the major features of c++11 implemented.
&gt; In my opinion the Visual Studio IDE is better than all competition. I disagree, but perhaps 2012 is much better: * Code completion is weak, and sometimes inaccurate. It only pops up when you press a `.`, `::` or `-&gt;`. * Sometimes it has difficulty finding the definition or implementation of a function. The compiler can find it but the "integrated" development environment visual studio can't find it. * No refactoring utilities, such as renaming function or variables. * Diagnostics is completely worthless, most of the time you have to compile to see the errors in your code. * Compiling is slow * The compile errors and warnings are just a very primitive black and white print out from the console. Its not in color, nor organized in a way to easily to sift through compile errors. * Some compile errors are difficult to figure out where the problem is in your code. For example, good luck finding where you accidentally copied an object with a private copy constructor(such as an iostreams object). * Plus, its a non-conformant C++ compiler. Visual studio in no way beats xcode(or even sublime). 
I'm sure he can tell them apart, but a significant part of users just doesn't care. 
YYYY-MM-DD
He probably means [C++ AMP](http://msdn.microsoft.com/en-us/library/hh265136.aspx).
Force implementations to treat class-scoped, inline-assigned static const integers in the same way it treats literals. I want this simple bit of code to link properly: #include &lt;algorithm&gt; struct S { static const int k = 0; }; int main() { return std::min(S::k, 1); } *NOTE*: ideone compiles this properly because g++ 4.3.4 compiles it as you would want. g++ 4.4 and later all emit a link error (as does clang). It isn't part of the standard, so it is probably way out of scope.
Using SublimeClang, you can get accurate code completion, diagnostics, and it will will jump to definitions and implementations. You can also integrate gdb using SublimeGDB. Its not as nice as xcode, but still very nice.
Yeah, you can run C/C++ like code on the GPU, but you have to restrict yourself in what you use and write, and the author of the poll does not seem to have a basic understanding how programming a GPGPU works. Both the "Increase speed of my program's compute-intensive parts" and "100%" are completely arbitrary and generally false assertions -- many/most algorithms cannot be sped up by a GPGPU at all, and if they can be, you can often get performance benefits larger (or smaller) than 100%.
surely you can think of how to do this with templates...
Interesting, but if you're using C++11 why stop at ints only? (EDIT: I see now that you stuck with ints to keep things simpler) We can define any unary function from T to bool as a characteristic function of a set. In C++: template &lt;typename T&gt; using Set = std::function&lt;bool (T)&gt;; Defining contains as template &lt;typename T&gt; bool contains(Set&lt;T&gt; s, T t) { return s(t); } And the rest falls from there.
Meh! Just use the RSE feature and add a remote location as a folder in your project. In other words, use Eclipse locally to directly edit files residing on a remote machine.
Start a second thread to process events, and use the event queue in GLUT, SDL, or something similar.
Well, really, I just need it to detect a keystroke. I've never used a GUI library though. A friend pointed me towards 'Windows Presentation Foundation', which I intend to try out tomorrow when I'm not tired. Not sure if it will work. I am still a beginner in c++, but I feel I'm on the level that I can begin to explore GUIs, I just haven't done so yet. Also, if I use openGL, wouldn't my application have to be rendered by openGL? or can I use openGL functions without using openGL for rendering?
How do I start a second thread?
They're external libraries. You download the package and configure CodeBlocks to know where the include directories are, and such. [This](http://wiki.codeblocks.org/index.php?title=BoostWindowsQuickRef) should be able to get you started.
Thanks much!
Threading and libraries that provide event queues are both valuable things to learn...but they aren't quick things to master.
Poorly chosen example! You'd provide one and use conversion to get the other. No reason for a temperature quantity to have two, redundant values. Makes maintaining them harder.
Emacs
Is this a feature you want adding to the compilers or to the C++ standard itself. Personally I don't want any non standard languages features from compilers.
Please note Herbs comment here: &gt; Re refactoring and IDE/compiler: Sorry for being sloppy, I meant “compiler” as in the whole compiler product, and besides that refactoring does need some compiler support including a real compiler front-end in the IDE (the IDE needs more than a tag parser, it really needs to fully and correctly parse the code and build ASTs and such).
See how far we've come... const auto r = (a &gt; c)? 1 : (a &lt;= c &amp;&amp; c &gt; b)? 2 : (a &lt;= c &amp;&amp; b &lt;= c)? 3 : 4; I guess that was the joke, though.
Or: Why not just use java
I'm questioning my programming ability as I know most of these, and do not necessarily find most of them evil. Maybe I'm just a terrible programmer, I'm sorry if I work with you some day. Ternary use is devious? He didn't even show off the fun part, nested Ternary Operations! #include "stdio.h" int main() { int x = 10; //cin&gt;&gt;x; int y=x&gt;0?x&lt;10?x:x&gt;9000?9001:0:0; printf("%d\n",y); return y; }
Eew. Parenthesize that stuff. That really was something that I should have added...maybe that will make it to v3.
Good, perhaps more obscure than evil.
More importantly, a void function can return ANYTHING void, including the RESULT of another void function (or a throw statement)
 class Shark { // ... } class LaserBeam { // ... } class SharkWithLaserBeamAttachedToHead: public Shark, public LaserBeam { // ... } /* Note: Class should be static because who remembers * the names of the henchmen who are dead. */ class Henchman { public: // ... bool isAlive(){return alive;} bool isDead(){return !isAlive();} private: bool alive; } class EvilGenius{ public: // ... void laugh(){ for(int i = 0; i &lt; 4; i++){ std::cout &lt;&lt; "MUHAHAHAHAHAHAHA!" &lt;&lt; std::endl; } } } 
Function pointers are bad? Lambdas are bad? The ternary operator is bad? Intentional fallthrough on a switch statement is bad? For-each is bad? Templates are bad? C++ is not Visual Basic 6. If you want a safe language with no control, then you may have made the wrong choice. Otherwise, learn how to use the language properly and make use of the gifts it has. Teaching developers that these (often) **amazing** aspects of the language are "evil" is kind of ignorant, and I would not want to have any one who thinks that way working with me.
My phone choked quite vigorously while I was trying to view that page.
There's nothing wrong with it. I don't know why such a big deal was made of it. Basically any expression can be cast to void which simply means to discard its evaluation. When you return from a void function, all you're doing is evaluating an expression, discarding its result, and exiting the function. Why this is made to be such a big deal is beyond me.
A void function does not return anything.
But, those uses are not at all evil. They're common.
However, the syntax for return requires an expression of the type of the function returning, which in this case is void. While technically the value is discarded as you said, the fact that the syntax allows this is the part that people are confused by.
&gt;However, the syntax for return requires an expression of the type of the function returning, which in this case is void. No it doesn't. The following is a return statement with no expression of any type, void or otherwise. void f() { return; }
I would say that most things in the presentation aren't bad, but like any other part of the syntax can be used for bad things - the fallthrough, as STL stated, can be useful (as in the actual example posted) but can also make the code much more confusing for maintaining. Similarly, I love range-based for loops, but I wanted to demonstrate how they can be exploited to do things other than the obvious uses (iterate over something that exists like an array, rather than doesn't like the Range) If you got "You shouldn't ever do any of these things" out of the presentation, that was certainly my own fault with the name (and the last slide or so). When I do the presentation in person, I make sure to mention how most of these have valid uses, but in several cases they should at least be documented. ("Why the hell is there a struct in this loop?")
That was awesome, you sir! Omg, I'm throwing money at the screen but it isn't working!
This guy is just plain wrong in most cases. Some could argue most cases are subjective, I suppose, but others are clearly, objectively mistaken. For example, the comma operator. The author describes this as not just for separating function arguments. The author apparently does not know that the use of the comma character here is NOT, I repeat NOT, use of the comma operator!!! Calling basic language features "tricky" also seems to be to be quite mistaken. There's nothing "tricky" about the sizeof operator nor is it at all, in any way, "evil". It is in fact quite necessary as a basic, every day language tool to make sure your code is easy to maintain and has a minimum of magic numbers. Calling anything "harmless" and "evil" at the same time seems to me to be ridiculous. Frankly, after fighting with the fucked up UI this thing is in I was incredibly disappointed by the content. I don't think I even made it half way through before deciding that NOBODY should read this.
This is an important language feature that was actually ADDED. The Boost.Function library has a bunch of nasty workarounds for compilers that do not support it. You should really rethink your stance on it being "bad".
I believe you are saying: If you write it like this: switch (x) { case:0 case:1 case:2 ... break; default: break; } and switch (x) { case:0 ... break; case:1 ... //INTENTIONAL FALLTHROUGH case:2 ... break; default: break; } Then yes, I completely agree with you. All other versions of intentional fallthrough are just bad coding, but to say that by allowing this practice is inherently bad, is just rubbish.
This is pretty lame and broken in places. For example, what's up with this code? http://www.csh.rit.edu/~msoucy/Presentations/evilC/#slide31 It doesn't link either way because `f()` has no body; as soon as you provide the body, it links fine either way.
For new C++ programmers, pointing out and even avoiding certain features in the language can be beneficial when first learning C++. Such as avoiding raw arrays, raw pointers, goto, mutable, and using the new or comma operator. Because as a programmer you can learn about the little nuisances of those features later on. However, calling important and very useful features in C++ evil(such as lambda, templates, ternary operators, and function pointers) is just ridiculous. 
It is safe to cast from void* to char*.
&gt; a void function can return ANYTHING void, including the RESULT of another void function This is an important point. I don't know why you're being downvoted here. It's useful to have `void` functions be able to contain `return` statements whose return value is some `void` typed expression. It lets you use `void` as a template argument in more places. C# *doesn't* support that and you have to work around it in nasty ways sometimes. &gt; or a throw statement A throw statement doesn't have a `void` result type. It doesn't have any result type: it's a statement. Even if it were an expression, it's type wouldn't be void, it would be a bottom type.
&gt; Conditionals require expressions. The difference between expressions and statements is that expressions have a value. Variable declarations are expressions, not statements. This is wrong. Variable declarations are most definitely statements. You cannot do: foo(int bar = 123); It's just that `if` allows an expression or a declaration as its condition.
The behavior is unspecified -- left to the compiler. I would propose changing the standard to require that compilers treat that bit of code as one would reasonably expect. However, I lack the skill with standardese to formally submit a proposal. Without non-standard features, we would have had to wait until C++11 to get atomic variables (unless you count inline assembly as "standard", which I wouldn't, given that the standard says `asm` is "conditionally-supported" and "implementation-defined") and still wouldn't have basic things like dynamically-sized arrays on the stack. Nor would we have a good way to make this work (until C++11): volatile bool gQuit; void foo() { while (!qQuit); }
I noticed that 12% of the people voted for more performance, more being only 5%. I really thought programmers where better educated than that. 5% is peanuts and often is eclipsed by the next processor update. More importantly code is often slow due to being poorly written or designed. I just don't get it really, sure better code translation is good but asking for 5% isn't exactly much of a reach. 
his point still stands. You have collections of the data, and you have an orthogonal structure which explains how they are connected. It's called "design".
GPU here means writing GPGPU programs, it does not mean to accelerate the compilation speed of C++. 
`std::to_string` comes to mind, msvc only a handleful of required overloads, so your code won't compile without adding casts.
Why should this not link? Class-scoped initialized static const built-in types do not need to be defined externally.
That's a special case though, where you're emulating the behaviour of arrays and the duality of `*(a+i)` and `a[i]` (or more precisely, `*(&amp;v[i]+j)` and `v[i+j]`).
No. It's the wrong thing to use here. You use MI when an object fulfills two interfaces. That's not the case here. How are you going to aim this laser beam? My bet is that it would be pretty much impossible as it has a shark attached to it. How do you trigger it? Swim up to the shark and turn it on? What you want is single inheritance. The most obvious direction to go is to subclass the shark since it seems to be the dominating interface. So you have Sharks, you have LaserBeams, and then you have SharkWithLaserBeam which *has-a* laser beam, not *is-a* laser beam.
The problem is a disagreement between the rules for external definition of a class-scoped inline-initialized static const integer and how values are passed to functions which take a reference. The compiler is free to not give an external definition for `S::k`, but at the same time, it is free to use the external definition of `S::k` to pass to `template &lt;typename T&gt; const T&amp; min(const T&amp;, const T&amp;)`. A compiler should either use the external definition if it chooses to emit it or treat it as a literal if it does not emit it. In either case, that simple bit of code should link on all compilers.
I strongly believe if you overload an operator, then your operation should observe the laws the operator normally would. For instance, if you overload *, then your operation should be associative, commutative, and have an identity element. 
You're right and I guess it makes sense to handle "static const integrals" the same as other class-static members. There might be programs out there which check static member object identity by checking the memory address... Anyway, good news is your program compiles and links in Visual 2010 and GCC 4.7, but not in GCC 4.6.3. So newer compilers seem smart enough to do the "right" thing, at least where it's obvious what that is like in your "std::min" example.
It's bizarre for a modifiable container's op[] to return an lvalue, but a const container's op[] to return an rvalue. There is nothing to be gained by such a practice except complexity and confusion.
That's because we implemented the C++0x Working Paper's broken specification at the time (I can dig up the PDF if you want proof). This was fixed in the final version of C++11, and accordingly implemented in VC11. Please upgrade from VC10 - [we fixed a bunch of bugs](http://blogs.msdn.com/b/vcblog/archive/2012/06/15/10320846.aspx). (As for bind(), I am well aware that it is a bug farm. I would like to completely rewrite it, but doing so without variadic templates would be difficult, so this has always been at the bottom of my priority queue. In any event, lambdas supersede bind() in 99% of cases, and the remaining 1% are better dealt with by writing dedicated functors.)
No need to dig out the paper, it wasn't an attack or anything I just had problems getting my standard C++ code to compile on MSVC, glad to hear it is fixed now. I think you point about bind is subjective, I personally prefer bind to lambdas in many cases as it shows intent very well. Any thanks as always for your reply.
Does anyone know how many web services are written in C++? I always figured they were in C#, Java or one of the dynamic languages. For the former (C#/Java) the developer tools just seem better, and for Python/Ruby you can get more done with less code.
I hate you people that are using C++11 features at work.
it is so sad that people have to resort to such ugly hacks just to be able to use handicapped versions of basic features that languages like python or ruby had for ages. what's next? coffeescript alternative for c++?
when you say "Until C++11", you know C++11 is here right? Atomics are supported at least in GCC and clang.
That is why he said 'would have had to wait' instead of 'will have to wait'
Sane stl errors :)
Any plans to add a working JOIN?
FWIW, PVS Studio appears to check printf format string validity. Also boost::format library will assert at runtime for mismatched or wrongly-typed parameters. I understand obviously that those are not the point of what you're trying to achieve here.
This provides a lot of insight, thank you. I guess I could remove all std.binds with lambda expressions. The syntax would be a little weird but might be worth doing at this point.
These days, many networked embedded devices expose a simple web interface/service. I could see many of these written in C++.
A more appropriate title would have been "How I installed VS2012 and set the include directories for my projects".
One question, when you load a VS 10 project into VS 11 the toolset is set to vc10. I'm just here wondering (out loud) if you left that unchanged, then having the include paths and such be shared with VS 2010 would make perfect sense.
I kind of get the impressions the author doesn't really think these are all bad, they're all open to abuse, but they go out of their way to point out examples of legitimate use for all of them. I took the "Evil" part as a tongue-in-cheek reference, that may be acts as link bait. A sure way to get a programming post noticed seems to be to attach "considered harmful" or "is evil" to the title.
http://gist.github.com http://codepad.org http://ideone.com To your question, yes, `std::ostream::put()` puts a single `char`^1 to the stream, while `std::ostream::operator&lt;&lt;()` (which I guess you mean by cout, which is actually just an instance of `std::ostream`) does all sorts of fancy formatting. You can use the `&lt;&lt;` operator with files too (see, it's actually quite clever that files and `std::cout` are both `std::ostream`), or you could use eg. `std::ostream::write()` 1) note that to write numeric values in human-readable form, you need to do some formatting, either with streams or with sprintf-family functions (or something else). Remember that `'0' != 0`
http://codepad.org/H1JAFfKm Thatś the relevant code. Is there any way to write variables to the file, for example if a = 10, how to write a to that file so that it displays 10?
For matrices multiplication isn't commutative. Now I still believe that Scott Meyer's rule of thumb, "Do as the ints do" (probably misquoted, I don't have the book at hand) is very valid. But operators in maths have lots of meanings depending on context.
I imagine Microsoft assumed that most people choose one version of VS and stick with it, instead of co-installing.
Awesome, that works now. Only thing is, it doesn't take the backslash command correctly, it seems like it ignores it. Right now I have this: uitvoer &lt;&lt; '\b'; But with the new rule marker, '\n', it works perfectly.
First thing I noticed is that you write `'\b'` to the file. Don't do that. `'\b'` is just a shorthand for number 8. You probably don't want your file to contain spurious 8s around. To write eg "10" to file, you first need to notice that you will need to write *two* characters^1, '1' and '0'. From that should be obvious that a simple put is not enough. Another thing to notice is that `'0'` has not the value 0. Instead it is shorthand for number 48. The easiest way to get your variables to the file would be `uitvoer &lt;&lt; kar;` etc. That way you do not need to think too much about characters and numbers and whatever. 1) I need to point out that `char`, despite its name, is not actually same as character. It is just a 8 bit integer type. A single character can be several `char`s long, depending on the character and the system (and it's encoding). In the most commonly used encoding, UTF-8, numeric characters (0-9) are one `char` each.
The basic pattern I've always used results in include paths, etc. being stored in the vcxprojs. This way we can use VS2012 for building things on our dev boxes while using VC2010 to compile the sources to maintain backward compatibility. You're certainly not forced to share include paths between versions. In this way, the directory path issue becomes less of a problem. It can be a bit of a burden when you're setting up a large number of vcxprojs, though. And yeah, the vcxproj format is shared between 2010 &amp; 2012, which was a request of the community to Microsoft. 
I was hoping for some useful insights. I don't care about someone else's include directory problems. 
Fair Question, but: Slide 2: prerequisites Slide 3: Warning Slide 4: Examples Slide 5: Explanation of the difference Slide 8: definition of "universal reference". 7:30 minutes. Yet, yes, the topic is complex, and the 1:30 doesn't seem to be wasted. Rule of thumb: if it's C++, and Scott Meyers considers it worth talking about it for an hour or two, it's worth listening, even if it appears trivial. 
He gives the audience a caffeine break at ~48 mins
Always nice to listen to: Stephan T. Lavavej, Andrei Alexandrescu, Herb Sutter, Bjarne Stroustrup, Hans Boehm, Chandler Carruth, can't remember more right now.
&gt;and gives slightly better performance. care to support this point somehow?
I [sure](http://www.macieira.org/blog/2012/02/the-value-of-passing-by-value/) [would](http://blog.qt.digia.com/2008/04/28/string-theory/). Presumably I don't have to back up why passing in registers gives slightly better performance than passing in memory. But, performance is all in the numbers, so [here are some numbers](http://ideone.com/Wihzi).
I think this is mistaken. Rvalue references are useful for pretty much anybody who writes classes. Setting aside move operators (move constructors and move assignment operators), rvalue references (in the guise of universal references) are very useful for perfect-forwarding constructors and setters. For example, if you have a data member of type std::string and you want to efficiently initialize it in a constructor, you'll want to use a universal reference as a constructor parameter. If you don't want to use a universal reference, you'll want to overload the constructor on rvalues and lvalues (again, assuming you want your initialization to be efficient), and the rvalue overload will take an rvalue reference. Rvalue references are a feature every professional C++ programmer is going to have to master. Even if you never use one in your code (highly unlikely, unless you don't write classes or don't care about efficiency), you'll still need to understand them in order to understand others' code. They are not a niche feature. 
Certainly std::move is something that "day-to-day" programmers will need to be aware of, but I don't believe the same would be true for perfect forwarding. I also don't believe that user-written move constructors will be common or necessary - in the same way that copy constructors and destructors are also slowly disappearing. Given proper use of RAII, the compiler-generated move constructor should be sufficient for the vast majority of cases - and even if not, the only cost to a missing move constructor is performance. &gt; For example, if you have a data member of type std::string and you want to efficiently initialize it in a constructor, you'll want to use a universal reference as a constructor parameter. If you don't want to use a universal reference, you'll want to overload the constructor on rvalues and lvalues (again, assuming you want your initialization to be efficient), and the rvalue overload will take an rvalue reference. This surprises me. We all know that in C++03 the advice was to (by default) pass by const (lvalue) reference for complex types. In C++11, I had heard - although I can't seem to find a source at the moment - that the new recommendation is simply to pass by value in this case and std::move the parameter into the member. If the caller passes an lvalue into the constructor, it will be copied into the constructor parameter. If the caller passes an rvalue into the constructor, it will be moved into the constructor parameter (given that the type has a move constructor, which std::string does). In both cases it should produce the optimal behavior, if I am understanding this correctly.
Unfortunately, the problem comes from C: const char * is a pointer, and as such, its value does not exist at compile time, it only exists in runtime. That is the exact same reason templates cannot have literal strings as parameters. It could have been otherwise, of course: 1) arrays could have been value types or 2) arrays could have had a compile time address, too, different from the runtime one. When the compile time pointer was used in a non-const expression, a run-time pointer would be created that points to a copy of the string. 3) a new type of literal could be introduced that would have been a value type when declared. 
be careful, `std::endl` is over used and can drastically slow down a program, use it only when you want to insert a newline onto the stream then explicitly flush it.
Well, this explains that the perfect forwarding can only be reached by UR. I wonder me if this optimization leads us to change the code in this way. //Not optimized class A class A { A(std::string str,std::fstream file) : _str{str}, _file{file} {} } //Optimized class A class A { template &lt;class T1, class T2&gt; A(T1 str, T2 file): _str{std::forward&lt;T1&gt;(str)}, _file{std::forward&lt;T2&gt;(file)} {} } Cause I think the problem here is not only that you have to put more boilerplate in, but that you dont make transparent to the class user which types are really used by the constructor parameters. It is just so clumsy that you maybe should balance wether it worths or not.
Definitely not true. DevC++ ships with an ancient compiler.
Will do!
I don't buy into the whole "we need an axillary class to do perfect forwarding." Just use template parameters and universal references template &lt;typename T&gt; MyObject::MyObject(T&amp;&amp;); If error messages are your big concern, then enable_if will help you out.
They're free less often than most people realize. std::vector::push_back needs to relocate objects from old memory to new if it has no room for expansion (i.e., no extra capacity), and, due to exception-safety guarantees, such relocation can't be done with moves unless the move constructor of the contained type is known not to throw. That's not the case for the standard containers, so doing a push_back on a std::vector&lt;std::list&lt;int&gt;&gt;&gt; with no extra capacity will *copy*--not move--all the lists in the vector. There are other edge cases, too, e.g., moving vectors with certain allocator characteristics runs in linear (not constant) time. It's important not to get into the mindset of thinking that moves are (1) ubiquitous or (2) so inexpensive as to not matter. They are often inexpensive, and that's great, but they're still more expensive than binding something to a reference. That's why perfect-forwarding constructors and setters are generally faster than pass-by-value versions. To get back to my main point: its a mistake to assume that rvalue references are a language feature of interest only to library writers. They're going to be used much more commonly than that, IMO. 
It isn't quite this simple. As I note in the talk that started this thread, the signature for one of std::vector::push_back's overloads is template&lt;typename T&gt; void vector&lt;T&gt;::push_back(T&amp;&amp; obj); Here you have a template with a T&amp;&amp; parameter, but this is an rvalue reference, not a universal reference. That's because there is no type deduction here, the fact that this is a template function notwithstanding. 
Thats cool, but in context of templates (and we discussed vector and such) this becomes real issue when you manage objects that can potentially be costly to copy. The microoptimization in case of int's (which probably doesnt matter anyway) may be major performance overhead for std::string - in general, for [] this would be bad.
You can't fully understand that C++ is a very horrible language if you don't understand C and Java. Most of C is already in C++, so they will need to know and understand it anyway. If I was in your place I would start by teaching them C, then i would go into objective programming, first using C and then showing them doing the same thing in the more "easy" C++ way but I would also let them know why most people in the industry now try to stay away from C++ and why most open source projects are C, not C++ http://harmful.cat-v.org/software/c++/linus http://esr.ibiblio.org/?p=532 http://harmful.cat-v.org/software/c++/rms 
In this context you only need one enable_if, as you only need one constructor taking universal references. Therefore the error you'll get is pretty straight-forward: "there's no constructor, but here's the one that failed." Here's an example of what I mean: class MyObject { string name; string address; public: template &lt;typename T1, typename T2, typename = enable_if&lt; is_same&lt;string, remove_reference&lt;T1&gt;&gt;::value &amp;&amp; is_same&lt;string, remove_reference&lt;T2&gt;&gt;::value&gt;::type&gt; MyObject(T1&amp;&amp; name_, T2&amp;&amp; address_) : name(forward&lt;T1&gt;(name_)), address(forward&lt;T2&gt;(address_)) { } // ... }; Yeah it's an ugly guard, but if this is a library I would rather have the error that no constructor exists than some deeper issue from constructing a member from an invalid type. For user-written code I would just skip the enable_if and reap the benefits of universal references and just make sure that I'm constructing the object correctly in my (teams) own code. When overloading functions with enable_if I do agree with you that the error messages are not helpful.
The compiler can elide the copying as well as moving, when you pass by value.
This is more of a quality of implementation thing than a problem with the concept. GCC's implementation right now either has no threads at all or one thread per task, depending upon the launch policy. It should be smarter, and the standard expects but doesn't require it to be smarter, and it isn't.
This article is a year old, and his complaint is now out of date (at least on Windows). The async implementation that ships with Visual Studio 2012 is based on the PPL library, which, as he points out early in the article, is a true task-based system. Old threads are re-used for tasks, rather than ended and new ones started. I haven't dug into G++ 4.7's implementation ([although I take advantage of it](https://bitbucket.org/moswald/xunit/wiki/Home) (shameless self-plug)), but I imagine if it doesn't provide the same guarantees, it soon will. As arvarin points out in his comment, this is entirely a quality of implementation issue.
Yes, you're right. But for lvalues, you have to copy-construct both the constructor parameter and the data member you're initializing, so pass-by-reference is definitely preferable in this case.
&gt; If value_type is known to refer to a built-in type `std::string` is hardly a built-in type. I agree that it's a microoptimisation, and for that reason I did say "slightly better" rather than "omg massively amazing". In general, yes, it would be bad, and I did mention that I'm playing devil's advocate, but you did challenge me to support the "slightly better", so I did.
std::vector::push_back is most certainly a function template, as the declaration makes clear. I agree that there is no type deduction, but your statement that "in templates and autos, &amp;&amp; means 'deduce refrence type', in other cases it is an rvalue reference" is an oversimplification.
Wait how do the key map to the values? Xor?
What's your problem?
`In&lt;T&gt;` really seems like unnecessary overkill for this. There's nothing wrong with just matrix operator+(matrix m, sometype t) { return m+=t; } For every type that `+=` can be called on (which is usually not that many). You can even handle every case with a single *simple* template if you're lazy or there are too many: template &lt;class T&gt; matrix operator+(matrix m, T &amp;&amp;t) { return m+=std::forward&lt;T&gt;(t); } In fact, on gcc this gives more comprehensible error messages for invalid types, because with the first solution gcc will enumerate every `operator+` it knows about (half of which print a 5 or 6 file backtrace and are templates 3 lines long), whereas the second will only enumerate the `operator+=` functions for the matrix class. There's no need for `enable_if` or rvalue testing macros to get a working and efficient solution.
Scott, It's good to see you on Reddit. Thank you for all that you've taught me. I'm hoping you have time to answer a question of mine about something you said in the video. You said in the video that in functions that use R-value references, the function would be suspect if it didn't use std::move() when accessing the variable whose type is an R-value reference (and similarly for std::forward with universal references). OK. To the question: Do you recommend using std::move() when accessing members of the variable or for move constructors? For example, would the following functions be OK? void Foo(Widget&amp;&amp; widget) { widget.sort(); // &lt;-- Is this suspect? Foo_worker(std::move(widget)); } Sprocket::Sprocket(Sprocket&amp;&amp; other) : Sprocket() { this.swap(other); // &lt;-- Is this suspect? } Is it really better to use the following lines in the above functions? std::move(widget).sort(); this.swap(std::move(other)); Thank you for the help in understanding!
If LHS is an rvalue the compiler will move into `m` rather than copy. And 95% of the time `+=` will operate on a const reference, so `sometype` will be a const reference, so there won't be any copy of RHS at all. And even if `+=` does operate on a value instead of a reference, you can deviate slightly and write two copies which take a const lvalue reference and an rvalue reference respectively (and this doesn't scale exponentially like the constructor example because each instance is a separate function, so it at most doubles the amount of `operator+` functions). And that's not even a problem in the template version, because it'll avoid the copy regardless and always forward some kind of reference.
&gt; If LHS is an rvalue the compiler will move into m rather than copy. How do you figure that? I see no justification for such a belief -- where would the move come from? I created the following testcase: #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; class Foo { public: Foo(int v = 0) : v_(v) { cout &lt;&lt; "default ctor\n"; } Foo(const Foo &amp;other) : v_(other.v_) { cout &lt;&lt; "copy ctor\n"; } Foo(Foo &amp;&amp;other) : v_(other.v_) { cout &lt;&lt; "move ctor\n"; } Foo &amp; operator=(const Foo &amp;other) { v_ = other.v_; cout &lt;&lt; "copy assignment\n"; return *this; } Foo &amp; operator=(Foo &amp;&amp;other) { v_ = other.v_; cout &lt;&lt; "move assignment\n"; return *this; } Foo &amp; operator+=(int v) { v_ += v; cout &lt;&lt; "operator+=\n"; return *this; } int val() { return v_; } private: int v_; }; Foo operator+(Foo lhs, int rhs) { return lhs += rhs; } int main() { Foo dest = Foo(1) + 3; return dest.val(); } Which prints: default ctor operator+= copy ctor No move. If you change it to: Foo operator+(Foo &amp;&amp;lhs, int rhs) { Foo dest(move(lhs)); dest += rhs; return dest; } Then you get a move instead of a copy: default ctor move ctor operator+= 
You don't see T? I think the fundamental problem is that you don't view member functions of a template class as themselves templates. But they are template functions in their own right. That's why they have to be defined using template syntax if they are not defined within the class template. 
I really wish the standard had gone further, `std::async` alone has some uses but not as many as it gets touted. (how many examples do you see would still run faster without threading or involve sleep?) On direction I think it should go is something like MS PPL. I don't have Win32 to see how this actually performs in a real code base but the theory looks good. For example being able to set up an `then` expression: a.then(...); or even: (a &amp;&amp; b).then(...); http://blogs.msdn.com/b/nativeconcurrency/archive/2011/03/09/tasks-and-continuations-available-for-download-today.aspx
Any comment that puts me in good company will get my upvote.
I see two big problems he describes with the standard: - a task cannot migrate to another thread once it has started (because of thread local storage) - a task that is blocked on one thread cannot be suspended in favor of another task on that same thread (because that could cause deadlocks, unless the suspended task can continue on another thread) You can do smarter things then GCC, like what he describes the just thread library doing now. But that might not be enough.
I believe this requires a copy because += returns a Foo&amp; but + returns a Foo, so to return from +, the Foo&amp; must be copied. It should be Foo operator+(Foo lhs, int rhs) { lhs += rhs; return lhs; // No need to copy lhs before returning. } like you wrote for the second test. I'm surprised the first version compiled because I first thought it returned a reference to a temporary. Then, I realized it copies the temp!
Thanks, I think we are mostly in agreement then. The whole auxillary thing is a hack at best. 
Yeah. If you require precise perfect forwarding of constructor arguments, then we already have a well-known mechanic to deal with it. Else, just use value types and enjoy the gained readability.
Very cool. I usually just use a sloppy wrapper over maps. This is better.
It does end up requiring you to define your recursive parameters, but if anything that could macro-ified (yes, bad, but it is harmless for this purpose) as I imagine it would be fairly consistent for arguments after the positional arguments. The other issue is that I can't really make any guarantees about the lifespan of the arguments or where they came from and that's why I provide only copy, const-ref, and pointer access. It seems reasonable, but I am sure there are better approaches to it.
As long as we are nitpicking: &gt; Literal suﬃx identiﬁers that do not start with an underscore are reserved for future standardization.
On the other hand, you can always add a pimpl, even if you don't use it, and then effectively freeze the size of your public data structures. I believe the KDE project does just that.
can you give more example how this can be useful ?
Agreed... I'm more than a bit confused.
It's useful with ambiguous arguments. PODs seem to fit this scheme. greet("Justin", 22, false, true, false); With boost and this method you could write: greet(_name="Justin", _age=22, _highschool=false, _college=true, _rmrf_home=false); greet("name"kw="Justin", "age"kw=22, "highschool"kw=false, "college"kw=true, "rmrf_home"kw=false); and get a better understanding of the function. Likewise the named parameter idiom would be something more like: Greeting_params params; params.name = "Justin"; params.age = 22; params.highschool = false; params.college = true; params.rmrf_home = false; greet(params); Your constructor would initialize these values to something of a default value. When that is all said and done, the named parameter idiom is probably the easiest to understand in the context of C++ as without libraries or additional work the keyword argument solution is not that well suited.
I meant that my solution doesn't require *other* libraries. Of course any solution is external to the person using it :)
Yeah ok, I really don't mean to be too critical, it is a really neat idea. But when it comes to header only libraries, arguing whether one needs more files than another is just silly. And that's all "header only" dependencies are really- extra files.
You could use this. It's a simple program i've been working on for my church. It's purpose is to take a set of DMX values (red, green, and blue) and convert them to 100% values. So DMX specifications range from 0 to 255, and 255 needs to = equal 100 and scale everything in-between. I'm still in the process of learning as well, but I think the code is written pretty well. But check it out. I think you could find it somewhat easy to use as an example. https://github.com/zebadee2010/RGB-Converter---C--
This is not really a place to ask for help on your homework, but as I am bored: #include &lt;iostream&gt; bool is_prime (const unsigned int number) { if (number &lt;= 1) { return false; } unsigned int i (2); while (i*i &lt;= number &amp;&amp; (number % i != 0) &amp;&amp; ++i); return number % i != 0; } int main (int, char**) { unsigned int begin (0); unsigned int end (0); std::cin &gt;&gt; begin &gt;&gt; end; unsigned int count (0); while (begin != end) { if (is_prime (begin++)) { ++count; } } std::cout &lt;&lt; count &lt;&lt; std::endl; return 0; } [(Based on this.)](http://stackoverflow.com/questions/1538644/c-determine-if-a-number-is-prime)
You can increment by 2 and cut your runtime down a bit. int counter(3); if((number % 2) == 0) return false; do{ if((number % counter) == 0) return false; counter += 2; }while((counter * counter) &lt; number); return true;
&gt; prime numbers there are under any given integer I would use the Sieve of Eratosthenes. Extremely fast.
s/move/forward/g
I mean I don't know how to turn it into an expression. I could make a nested loop but I just don't know how to make a mathematical equation that would lead to prime numbers, let alone pn's that get counted.
There's also another kind of named parameter idiom, which is a little more flexible, yet also more verbose: #include &lt;iostream&gt; class Foo { int m_p1; int m_p2; int m_p3; public: Foo() {} Foo&amp; Prop1(int p1) { m_p1 = p1; return *this; } Foo&amp; Prop2(int p2) { m_p2 = p2; return *this; } Foo&amp; Prop3(int p3) { m_p3 = p3; return *this; } void go() { std::cout &lt;&lt; "Foo{.m_p1=" &lt;&lt; m_p1 &lt;&lt; ", .m_p2=" &lt;&lt; m_p2 &lt;&lt; ", .m_p3=" &lt;&lt; m_p3 &lt;&lt; "}" &lt;&lt; std::endl; } }; int main() { Foo().Prop1(1) .Prop2(42) .Prop3(17) .go(); } 
Putting these 4 lines in a main function by themselves does not exhibit the error you are describing.
"NULL" is not C++. You probably have some stupid macro defined for NULL that is wrong and needs to die a fiery death. Use nullptr.
Nope. When you call the function 'widget.show', the compiler already knows the type of T. So, 'show' is not a template function, it is part of a template. 
No, it is not. A template is something that has compile time parameters. A member function that does not have compile time parameters but is a member of a class that has compile time parameters is not a template by itself. 
You should run a memory checker such as valgrind on your code that segfaults sometimes.
You're missing something, and if I had to guess it would be that you've got an overflowing array nearby that's stomping it with the '!' character, or the number 33.
Run your program though Valgrind, and tell us what happens.
Cool! Here's an idea for future extension: why not make the car and cdr members of type boost::any, so that way you can store anything at all in your cons list (including other cons lists, binary trees, dotted pairs, etc).
Why would you prefer `0` to `NULL`?
shared pointers and make_shared where added in C++11, (boost has had them forever, but they weren't part of C++03) Template typedefs (the using syntax) is C++11 only
Will try this (need to keep learning boost :)
I think Project Euler is more about learning problem solving, rather than learning a programming language.
This is almost certainly the case
In one of his [videos about core C++](http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-), Stephan T. Lavavej, the maintainer of the Visual Studio C++ standard libraries, talks about attempting to #define NULL as nullptr and failing, because there were just far too many cases where someone used NULL as an integer or character literal. Maybe you can get away with #defining it in your own code, but I think the intention of the standard was that you would stop writing both zero and NULL and start writing `nullptr` in your code, not depending on any macros to do it. 
They were part of tr1, which most C++ and msvc compilers had.
C++ is a multi-paradigm language, and if there were no use for boost.any then it would not have been created. Personally I would rather use boost.variant instead as at least I can constrain the possible types it can store, but since the author is simulating lisp cons cells (which can store references to anything) in C++, boost.any is the logical choice for storage. It beats using void pointers.
OK, so the short answer is that yes, it does deprecate volatile. From the standard: *Two expression evaluations conflict if one of them modifies a memory location and the other one accesses or modifies the same memory location.* *The execution of a program contains a data race if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens before the other. Any such data race results in undefined behavior.* Which basically means that unless you use atomic, mutex, or some other C++11 ordering construct, you will have undefined behavior in your program when accessing a shared variable.
Does the whole shared_ptr thing break with circular references? (e.g. if I try to cons(list,list))
Inspired by this one, i wrote my implementation(http://liveworkspace.org/code/23b7b842253eec369a09fd1f7e3bf883), it's nearly a compile time map, hence there's no overhead on argument fetching. Also, writing a function is just as easy as below: template&lt;typename T&gt; inline void bar(T t) { cout &lt;&lt; "user = " &lt;&lt; get&lt;"user"_h&gt;(t) &lt;&lt; ", home = "&lt;&lt; get&lt;"home"_h&gt;(t) &lt;&lt;"\n"; } and construction the named arguments are similar: int main(int argc, char const *argv[]) { bar(( kw&lt;"user"_h&gt;("jack"), kw&lt;"password"_h&gt;(456ull), kw&lt;"home"_h&gt;("/home/888"))); return 0; } Finally, if c++1y accept the gcc flag "-fstring-template-parameters", this could be even concise.
* *Professional C++* is a good book if you already know C++ ('98 or 2003). You could pick only the C++11 parts. * *The C++ Standard Library* is an introduction to the C++11 STL fully updated for C++11. In the end, it depends on your learning style, if you prefer to learn only the C++11 additions to C++ both are good books. Personally I would start with the first one, it is cheaper and it has a larger view over the language. If you are completely new to C++ none of the above books will be useful to you.
My gut feeling is that the interface of chrono is not very useful for the task of mesureing code performance (but i dont know it well). You would rather want to have something resambling stopwatch interface for that, instead of something that needs to know absolute time with good resolution. Also, seeing as current VC implementation doesnt use QPC (it cant really with 'now' interface) at all, id be cautious before using this for benchmarking.
That is quite awesome; ingenuity in the hashes as compile-time keys, but quite funky error messages when a key is used that doesn't exist. Good job!
I've been using `std::chrono` for timing things and I haven't had any problems.
Update (http://liveworkspace.org/code/a57c85b7d25105976f7574e3b6377d54) Now use static_assert to examine whether the key is exist. If a key is not found, the first error should be "static assertion failed: Error, no matched type has been found.".
I haven't really looked at these APIs myself yet, but the difference between a stopwatch API and an API that gives you absolute timestamps at high precision is requiring the use of a "-" operator on the part of the programmer. 
You could, temporarily, use boost::chrono instead of std::chrono, the syntax is the same and the steady_clock works as expected.
Huh, what was the issue with running as an admin? If you mean the problem linked in article, then it has nothing to do with admin, but instead MS using 'GetSystemTimeAsFileTime' in all their clocks (which is incorrect).
You should check out tuple&lt;&gt;. It is a cons list.
No new library in 1.52 ?
As an interesting side note (interesting to me), the landslide library used to generate these slides was developed by a guy from my college, along with other contributors. Pretty cool, as this college isn't well known for its computer science. =]
Regarding member variables, I tend to use only a trailing _, as per the [Google coding style](http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=Access_Control#Access_Control). It's a little less to read, and it appears at the end of the variable so obscures the meaning a little less. I'd call which naming convention to use a matter of taste, frankly... BUT I'd strongly agree that using SOME naming convention for member variables is a must.
I understand there is no idiomatic C++, but I'm sure there are good practices to share :) A namespace would work better than a class, you're correct. Never used smart pointers before - is the performance overhead noticeable in game development? And yes, I'm gonna use header files for the real project. Thanks :)
The overhead of unique_ptr is really tiny, use it for ownership and your code will be much more safer and cleaner. One thing that often happens when you arrive to C++ is that you turn into a performance taliban. Try to avoid that, it doesn't worth.
Trailing '_' is what I will eventually adopt, since I'm used to ReSharper automatically adding it in my C# projects.
A pure virtual class is a class that has one or more pure virtual functions. For example, `update` could be made pure virtual. This means you must override this function in a derived class if you want that derived class to be instantiable. About the last two points: well, here's where you run into problems. If you have a vector of shared_ptrs and weak_ptrs from elsewhere to the items, you will be able to tell whether a given item has already been deleted or not. On the other hand, if you just have a vector of pointers, there is no way for another pointer to check if an item still exists or not. Either keep it alive for as long as things using it may survive, or do the same thing shared_ptr does for you. The issue isn't specifically in the `vector&lt;Component*&gt;`. It isn't specifically in any function that takes a `Component*` or `Entity*`, either; at least, as far as I've seen, there's nothing atrocious. The problem is that as you keep adding pointers everywhere, your code will be harder and harder to manage. It is unclear who owns what, it is unclear whether this pointer is solitary or to an array, it is unclear whether the pointer can be NULL or not. The first case can be avoided using smart pointers, the second using iterators and the third using references; with that in place, any usage of a raw pointer is a special case, and can be treated with due diligence. If you have raw pointers everywhere, you can't invest that attention. Furthermore, smart pointers can often be implemented in a way that basically lacks all overhead. For example, the only cost a unique_ptr implies in terms of performance is that it is automatically initialised; with a pointer, chances are that you will want this anyway. If you want to see what C++ can do in terms of speed, look at what kind of abstractions you can build with no loss of it.
If you use a container that has your type T, it will automatically be handled. Do not use pointers use moves and copies. Taking advantage of scope is a very powerful thing. Also look up RAII.
An EntityManager is usually also used to make queries about the current scene — give me a list of monsters, give me the player character, whatever. In my engines, I usually have a similar object, that has complete ownership of the current set of objects in memory. I tend to call it a "Universe". It's a bit ambiguous at first, but it ultimately derives from the (enforced) invariant that entities from one universe never contain references to entities in another. Explicitly specifying ownership in these terms makes it easier to optimize memory management later on, as well as detect memory leaks etc. EDIT: Oh, yeah, I also never use raw pointers to point at entities. I usually use a smart pointer that knows about universes, and can be compiled in a way so it contains facilities to find reference leaks and the like. :)
Erm, so containers are not used to make queries? (And in any way does the name "Manager" hint at providing querying facilities). "Universe" does sound much better than AnythingManager.
Sounds interesting. Is your project open source? I'd love to see how you're using smart pointers for this
But using copies will actually copy the game entities (unless I'm missing something). I want to have a single game entity and references to it in the entity manager and other entities. Consider I have a door and a lot of buttons that open that door. I need to pass that door as a pointer to those buttons, otherwise they will open/close a copy of the original door, not the one in the game world.
Well, game entities are "anythings", really, so that seems reasonable.
Not yet, but I'm using fairly standard techniques. :)
Identifiers starting with an underscore are reserved for the implementation. Trailing underscore is usually preferred.
Be warned: starting class members with a `_` followed by a capital or another `_` is undefined behavior.
This is a misconception. Identifiers starting with underscore and lowercase letter are perfectly fine as class members. Such naming convention has also an added benefit that, if you use some kind of an IDE you get all the member variables together. Also, i find it pretty funny that a lot of people a freaking out on _member but are perfectly fine with #ifndef _MY_FILE_H_ in include guard.
To add to simonask's point, you're doing premature optimization without even measuring these inefficiencies. Unique_ptr is just as efficient as raw pointers, but infinitely more safe 
This should be interesting to watch. On a side note: Intel seems to be closely involved in the standardization process. I really hope they get some of the TBB stuff standardized.
While not specifically addressing the gamedev context*, take a look at the following: http://www.informit.com/articles/article.aspx?p=1944072 (since I'm assuming you're interested in general C++ pointers best practices, too, it may be just what you're looking for). *- although feel free to also take a look at the discussion(s) here: * http://www.gamedev.net/topic/627119-stdvector-vs-stdunique-ptr/ * http://www.gamedev.net/topic/631734-dangling-pointers-in-vectors/
You should be able to move the entity into the collection, and obtain references to it afterwards. Looking at [Iterator](http://en.cppreference.com/w/cpp/concept/Iterator) it will give you a reference. On the vector, operator[] returns a reference and so does list. So this may be a valid thing.
You're right. They're fine as class members, but underscore+lowercase is still illegal at global/file scope, and underscore+upper and underscore+underscore are illegal everywhere. It's because these rules are often hard to remember that people tend to just avoid the issue entirely and use trailing underscore. &gt; Also, i find it pretty funny that a lot of people a freaking out on That's kind of a straw man argument. I would expect someone to point out the illegality of such an include guard if it was used. (This does happen on /r/learnprogramming whenever it comes up, not sure if I've seen it here.) 
Does now() not return a uint64 or something? Seems like that's the only requirement for QPC to be the implementation...
Thanks!
&gt; Identifiers starting with underscore and lowercase letter are perfectly fine as class members. Perhaps, but they are reserved for the global namespace. &gt; Such naming convention has also an added benefit that, if you use some kind of an IDE you get all the member variables together. You can use `this-&gt;` and get the same benefit. And you can use that for your member functions as well(People usual ignore that aspect with these crazy naming conventions), which is really helpful to know many times. 
very well said sir. 
Could you give an example where `auto*` compiles?
Interesting; I'd expect `auto` to be deduced as `int*` and thus `auto*` as `int**`. Thanks for showing!
&gt; I would expect someone to point out the illegality of such an include guard Sure, im just talking about my experiences. Illegal tokens in include guards are hell more prelevant then anywhere else _in my experience_. 
&gt;You can use this-&gt; and get the same benefit. You cant. Really. Your favorite IDE will probably list members in alphabetical order. this-&gt; will popup a window with: bar_ baz() foo_ If you use leading underscore you are more likely to get these grouped 'correctly' _bar _foo baz() The whole argument is pretty weak (especially if you dont use IDE, or it sorts by members well anywyas) but at least its somewhat real, instead of fears that someone may mistype his member to instead start with an uppercase letter or an uderscore (thus forming double '_' or under +cap).
Just use VLC to stream your camera from rpi using a known protocol, you will be able to connect from any client that speak this protocol (http, rtsp, ...). You can use an other TCP socket to control the pi / send and receive info. 
I agree with think-free -- this sounds more like an integration exercise than a code-it-in-C exercise. I would look into using [GStreamer](http://gstreamer.freedesktop.org) where you would build a pipeline like Video "source" element -&gt; encoder element (optional) -&gt; streaming "sink" element GStreamer provides source elements for Video4Linux (so any camera with a v4l driver will work). There are also custom source elements available for specific cameras that have custom drivers. For the sink element GStreamer provides a basic HTTP sink, as well as sinks for streaming protocols like RTP. Back at the ground station you can use any client that supports that protocol. Googling for "gstreamer on raspberry pi" yields a bunch of promising results.
&gt; Also note that raw pointers are getting increasingly rare in C++ code in favor of shared_ptr, unique_ptr and the like. Depends on who you ask. I've found that C++ itself is becoming increasingly rare - except for in the games industry, where it's healthy as ever, and where I've yet to see anyone use shared_ptr or unique_ptr.
This [book](http://www.amazon.com/Programming-Principles-Practice-Using-C/dp/0321543726/ref=sr_1_1?ie=UTF8&amp;qid=1350472255&amp;sr=8-1&amp;keywords=Programming%3A+Principles+and+Practice+Using+C%2B%2B) is a good alternative to Accelerated C++, for a beginner programmer. Written by the creator of C++ and aims to be an undergraduate introductory programming book. Full to the brim with exercises and drills.
thats why i gave the website link www.cplusplus.com is almost like the Accelerated c++ book(80%), but if i need to know more of anything i can just follow a link in the tutorials. that book may be fast, but there are a few things which CAN be interpredted differently that it should be interpreted due to limited information in the subject. and like i said, that book lacks professionalism, if i didnt throw it away i would have shown you those lines that say "we arent entirely sure but apparently..." www.cplusplus.com is free fast and very informative. infact you dont need a book at all unless you want something for offline. fact is c++ is one of the hardest languages out there, so it doesnt make sense why you want a book that is a summary of a in depth book on one of the most complex languages to learn. 
this is a way better alternative
I really liked the [Thinking in C++ series](http://www.amazon.com/Thinking-Introduction-Standard-One-2nd/dp/0139798099/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1350474005&amp;sr=1-1&amp;keywords=thinking+in+c%2B%2B). But not exactly fast with 800 pages.
Vote down, but in vain. Collection has unique. This convenient collection anywhere else. It will be extremely useful for the authors of books dealing with security. And just interesting to study the patterns of errors.
Wait is this an Official website directly linked to the standardisation commitee? 
that book is 1272 pages long, do you really think you want that many pages from the off? I know if I was learning C++ I wouldn't finish it. 
I'm just starting a game project with it. I looked at it and I like that it's much simpler than Boost (of course, with much less features as well). Admittedly, it is more similar to Qt in style, but that suits me well. One thing I don't like about it is that it implements its own smart pointers and uses them in the API (although that might be avoidable, I'll have to look closer).
It's exceedingly common anywhere performance is critical. It's heavily used in finance, for instance, for existing and new application.
I have an (inherited) codebase that uses some features of POCO and some of Boost. POCO is kind of cool, but I've never really understood why the original author of our system decided to use both. 
poco is amazing and I chose it for an embedded http server in all honesty, boost's documentation is not that great and the API isn't always easy to use; whereas poco's documentation is amazing and the API is easy
Carruth, Stroustrup &amp; Sutter listed as directors/officers, that's a good sign. Each of those guys have probably forgotten more about C++ than I've ever known.
Well, we might be able to look forward to boost.coroutine soon (cooparative multitasking lib) http://comments.gmane.org/gmane.comp.lib.boost.devel/235206 
Sort of, yes. Read http://isocpp.org/about for details.
It is no coincidence that Intel is involved in the standardization process since they produce the Intel C++ compiler. There are several competing libraries regarding parallelism in C++, where Intel's TBB is one. However, Intel seems now to officially propose their Cilk Plus. Microsoft proposes their PPL and I guess there are other proposals regarding parallelism too. Read more about recent proposals: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012
Thank you so much I am exploring this idea right now!
Yes, using poco, and wish more people would use it and realize how good it is as a foundation library. boost doesn't have a consistent feel across all of the library, it really is just a collection of 50+ (?) libraries. Whereas poco is much more coherent IMO.
I had a rather good experience with poco, using it for its pre-written server features that are easy to extend.
These guys really do rock. They supported me in a student license for a write-up on a 64-bit clean port of Doom 3. Great communication and reputable articles and write-ups. This looks like a great resource as well. Keep it up!
This just seems to me like the worst idea ever. If you want the stack to manage memory, let your objects live in the stack. Otherwise use shared_ptr and friends. It's not that hard. Also, what happens when you pass one of these scope managed objects out to somebody else to take care of. Who owns it now? shared_ptr solves this. This Scope thing just makes a well-solved problem go pear-shaped. Finally... you have to derive from a common base class? Ridiculous.
Great tutorial, thanks for the share.
Change your Entity.h file: move the #include "Component.h" from the header and put it in the .cpp. Forward-declare the Component in the Entity.h file like you did for Entity in the Component.h file.
hm... i'd be interested to see what other people say, because I can't see the problem with it. The design looks good. Have you tried cleaning the project?
Tried doing that. I get the "method update() cannot be resolved" error. I think it's because I include Entity.h in Entity.cpp, and Entity.h forward declares Component without any method so Entity.cpp will not find update. Is there any solution to this?
There's no point in giving your system specs if you don't tell us what compiler you're using.
Yes, I clean before every build. Read my replies to the other comments, they may be useful 
The call to update() is part of what I mentioned. Did you really comment both places? You don't need to include Component.h in the cpp. Include in CPP pretty much means "stick these files together", it's not like packages in C#, etc. (oh, and yeah, you didn't implement your methods for entity...)
Clang, the default compiler on Mac OSX.
Done.
it's early days for C++, gcc and async. The functionality is there, but hopefully the QoI will improve. I guess this why the default launch policy for gcc's async (at least on my system, arch linux gcc 4.7-2) is `std::launch::deferred` rather than async.
I checked it against g++ 4.7.1 and clang 4.0 and it seems good. g++ Entity.cpp Component.cpp main.cpp -std=c++11 -o test clang++ Entity.cpp Component.cpp main.cpp -std=c++11 -stdlib=libc++ -o test These both work fine. clang -v Apple clang version 4.0 (tags/Apple/clang-421.0.60) (based on LLVM 3.1svn) Target: x86_64-apple-darwin12.2.0 Thread model: posix g++ -v Using built-in specs. COLLECT_GCC=g++ COLLECT_LTO_WRAPPER=/usr/local/Cellar/gcc/4.7.1/gcc/libexec/gcc/x86_64-apple-darwin12.1.0/4.7.1/lto-wrapper Target: x86_64-apple-darwin12.1.0 Configured with: ../configure --enable-languages=c --prefix=/usr/local/Cellar/gcc/4.7.1/gcc --datarootdir=/usr/local/Cellar/gcc/4.7.1/share --bindir=/usr/local/Cellar/gcc/4.7.1/bin --program-suffix=-4.7 --with-gmp=/usr/local/Cellar/gmp/5.0.5 --with-mpfr=/usr/local/Cellar/mpfr/3.1.1-p2 --with-mpc=/usr/local/Cellar/libmpc/1.0.1 --with-system-zlib --enable-stage1-checking --enable-plugin --enable-lto --disable-multilib --disable-nls Thread model: posix gcc version 4.7.1 (GCC) I would like to see your actual invocation of the compiler.
Why is your Component update pure virtual?
Of course, so you can override it by deriving classes. Entity is just a container. Did you try to delete: void Component::update() { } It serves no purpose.
The tears come when your compiler doesn't support constexpr or C99-style struct initialization (actually I wasn't aware that that was legal in C++11).
I really wish they'd give an in depth rundown of that system.
Ooh ooh, a question I can answer on here finally! All their stuff is here: https://github.com/okws/ If you want to know about the graph/network traversal stuff, I can't say exactly what they're doing, but I can say what my company used to do for a similar problem.
I'm not familiar with the project (yet) but it seems like it can block individual functions without using threads ([based on the Tamer blurb at least](http://www.read.cs.ucla.edu/tamer/))? I'm not clear how they pull that off, does this differ wildly from std::async from c++11, I'm guessing yes but how?
http://www.read.seas.harvard.edu/~kohler/pubs/krohn07events.pdf Seems fairly straight-forward to me. I like this a lot more than the absurdly irritating spaghetti-callback nonsense node.js often turns into. Reminds me a great deal of the promises stuff I've seen in Scala.
Well, that's obviously not true. count_dots does run. $ g++-4.7 -Wall -ggdb -std=c++11 test1.cc test1.cc: In function ‘int main()’: test1.cc:6:9: error: static assertion failed: not 2 dots The type of "." is not const char * but const char [2]. Thus the compiler has knowledge of the length and can make sure that one does not index out of bounds at compile time. 
why? if you can't have a directory called aux in windows then that is scumbag windows. Why the fuck would you specail case a directory name
There are proposals. I really really hope this makes it into a library release soon. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3428.pdf (note the submitters are all from Microsoft)
I didn't see anything about `&amp;&amp;` and `||` build dependancy trees in there. Aso I find it hard to trust a standards document so blantently written in word. I am so used to beautifully typesetted latex!
&gt; Supersonic : a column oriented query engine library written in C++ &gt; Supersonic Query Engine - a column oriented database query engine library. &gt; \- Google Project Hosting &gt; (code.google.com) Title brought to you by the Department Of Redundancy Department.
If you're using Linux, I recommend libusb. If using Windows, libusbX (note the X). I've used libusb heavily. LibusbX is cross platform (linux, windows, mac?). Libusb is linux only. Serial communications -- if in Linux, google termios. Windows... not so sure. If using Linux, feel free to PM me -- I've worked with both libusb &amp; termios a fair amount.
I think I've found my biography title.
http://www.robbayer.com/files/serial-win.pdf -- give that a try?
For serial port usage in linux, I've used libezV24. It's in Debian's main repository, and probably others. Or you can download here: http://ezv24.sourceforge.net/ Under windows, the following two source should help: http://msdn.microsoft.com/en-us/library/ms810467.aspx http://www.codeproject.com/Articles/992/Serial-library-for-C and this might be useful for testing under windows: http://com0com.sourceforge.net/
Good link, I was going to suggest the same one. 
thank you!
I'm suggesting boost::asio. Cross platform and a beautiful interface. I have also used it for robotics applications and it works very well. In any case, do avoid rolling your own implementation. Even though it seems simple at first, there are some subtle things you can do wrong which makes it fail sometimes with some devices. Edit: You may find http://www.webalice.it/fede.tft/serial_port/serial_port.html helpful
C++ * is very portable * can easily access and inter-operate with C libraries * can inter-operate with most other languages fairly easily (especially with tools like swig) * can run in low-memory and/or low-powered CPU environments * is more deterministic than garbage collected languages * does not require a run-time or interpreter * can be used with many paradigms (imperative, object-orientated, generics, ...) * has a type system that is more safe than most common alternatives * 'const' and RAII * has many tools to help develop, debug, refactor, test, and validate applications * compilers can optimize C++ a lot * compilers usually offer a way to inline assembly (especially useful for OSes and embedded applications) This isn't to say that C++ is the best language. Each (non-esoteric) language has a set of applications for which it is ideally suited. While C++ is a difficult language to learn and extremely difficult to master, it has a lot features that allow it to be used in a great many places.
freedom is what makes C++ good I think it is better to have two files for a class compared to one. Harder to navigate in one huge file
Thanks you definitely have some points i have never though about there. In the end Java and C++ are the only languages i know that could run on another platform. Could you tell me a little more about inter-operating with other languages, what does that mean? (I can google the rest) Thanks, +1
That's actually very true.
Most forums and tutorials say it is very bad practice to define functions in a .h file. I don't know why. That's why i used 2 files ever since. I have to agree with you on your second point, it does make the code a lot easier. Looks like portability is a big thing I have not though about. Thanks for the helpful answer. +1
My biggest complain with C++ is the need for header files. I think they're a ridiculous waste of effort.
Isn't const one of the messy features of C++. I don't see what makes const useful. Please explain.
&gt; Fortunately, this isn't true (I hate bloating up projects with a ton of files). You can, in fact, declare and define a class in a single file. Declaring classes in one file and defining them in another is just common style. You do not have to adhere to that practice. While true, this is only the case if you need to define types and use them in one compilation unit. Outside of creating cute class registries (Dynamically loading classes at runtime through some type of factory), you need the h files to be able to use the types defined in them in other compilation units.
&gt; I don't know why. If you are writing a shared library, you want your code to be compiled into the library itself, so that any program using the library can use an updated version of your library without having to be recompiled. There are all sorts of linking and runtime issues you can experience if your code is in header files instead of object files. It's a tool best reserved for very specific cases. 
const can save you so much headache, if you understand it. I recommend spending lots of time playing with it.
Hopefully C++ Modules will fix that.
I used to feel that way. However, with experience and discipline, they can save you a LOT of time. If you code in c++ like you're coding in Java or C#, you're not going to enjoy your experience.
Ask Linus Torvalds.
Actually, c++ can be very messy without const. Liberal use of const reduces the possibility of unintended side-effects taking place in your code, or other people's code using your code. It can also help with compiler optimization.
Most languages are implemented in or allow you to write extensions in C/C++. I'm talking nearly every popular language as well.
It facilitates almost every programming paradigm and because it is a native compiled language you can write it for almost anything ever. Because it doesn't have tons of hidden behavior What You See Is What You Get most of the time.
Yes
I would like to add multiple inheritance to that list, despite it's controversy. 
It should be, but it needn't be as far as I understand. A class is free to overload * and -&gt; separately. Of course, that class designer would be an ass, because that's like making + and - do unrelated things.
What is OOP if not an abstraction?. 
Yes.
Not basic from a language perspective, but rather C++ is at the base of the software stack. It compiles directly to assembly and it's about as close to the metal as you can get short of C.
PHP, Perl, and Haskell are cross-platform off the top of my head. As for inter-operating with other languages an example might be writing a DLL in C/C++ and accessing it in Visual Basic as an api. 
That's true until you write a class template. Then the conceptual separation between source and header files starts breaking down. Header files were a kludge in C that got brought forward into C++. Believing anything else is making excuses; the need for include guards should make this painfully obvious.
&gt; What do you mean by "referencing"? Including it? If yes, this argument is bogus because that's the compiler's work, not mine. If this bothers you so much, then why don't you jump ship to a language with a compiler that does more work? &gt; If you mean "reading up on the API", then here's an observation I made when documenting my headers with doxygen Doxygen and its siblings are crap. If you're involved in a larger project, then it's a necessary evil, but for the individual, it's usually crap. &gt; But my biggest gripe with header files is that they contain redundant information. Why do I have to tell the compiler twice what the method's signature is? Why do I have to change it in two places? They don't contain redundant information. One contains the declaration. The other contains the definition. It just so happens that the convention for definition looks very similar to declaration. Look, I'm not arguing that it's the best ever. I just think that, once you get over your personal gripes and fear of pressing more keys on the keyboard, it actually does have some nice advantages. Is it perfect? Hell no, but once you accept it and learn to live with it, it does have some good to it.
C++ is POOP. Procedural OOP.
C++ does not have a lot of hype.
I would love to see regex implemented in libstdc++. Not having regex is currently a big hole my favored toolchain, and one that other competing compilers. (It's in both Vis Studio and clang.)
&gt; Doxygen and its siblings are crap. Alright, if you say so. The argument still stands if you replace doxygen by "non-trivial block-comments explaining the method's functionality". &gt; They don't contain redundant information Yes they do. The method signature, barring default arguments. That's the same information in two places. Just because you give them two different names doesn't make them less redundant. &gt; it actually does have some nice advantages. Such as? So far, you only mentioned that header files are easier to read when they're undocumented.
1) It is based on C, which is the best portable abstraction of the fundamental operations on a computer. If you do not believe, name a major operating system or compiler or interpreter that does the majority of what it does without C. 2) It has high level concepts that cover a range that few languages do. You can do procedural development, OOP, functional, logic (see a library called castor), generic, generative. 3) The language trusts the programmer. It was developed by professional programmers for professional programmers. It gives you options and trusts you to make the right decision 4) Given the above, with the right libraries, C++ can be almost as easy to use and fluid as a scripting language but with high performance. 
&gt; Yes they do. The method signature, barring default arguments. That's the same information in two places. Just because you give them two different names doesn't make them less redundant. But they're two completely different things. They're not redundant. They serve two completely different purposes. You don't *have* to use declarations, but managing multiple projects without them gets very hairy, very fast. &gt; Such as? So far, you only mentioned that header files are easier to read when they're undocumented. Code generators that need type information about your classes generally work more reliably (read: simpler to implement) when all they have to parse are the declarations. See D's header processor, or Qt's MOC. Say what you will about closed/open source, being able to distribute just enough information to make your pre-compiled source useful without resorting to introspection tools is a plus, especially when your closed-source application needs to bundle some kind of plugin system. Their icons are red in my IDE. I like red. 
&gt; Header files work great for this. Well, OK, but so does any decent folding text editor, and it still works if you're using a language that puts everything in one file or writing class templates in header files in C++.
It's runner up for best acronym right after IANAL. 
I'm not sure I follow. I never define my classes across multiple files. I find the increase in build complexity to not justify the cost of doing so. All my classes are defined in the header file and if someone wants to use it they simply include the header file, no need to add any additional cruft to the make file, or link in any library or anything... simply include and go.
But C and usually C++ can be compiled on more hardwares than any other language. Plus because they are so close to the metal, they are perfect for low level and embedded systems. Those other languages are cross platform but not in the same way.
C is the lingua franca of computers. Simple, close to the hardware and fast enough for almost anything. (Very rarely is there something which requires Fortran.) But if you've ever tried to write a sufficiently large and complex piece of software in pure C, you'll see its short comings. It is possible but it is uglier than C++, and that's saying something. Some people will debate this point to the death, what's uglier C++ or C doing work better suited to C++. C++ is C with classes. It become popular because it started as a super-set of C. All C++ tools worked with C. You could stand on the shoulders of the giant C, and go even higher with C++. And it is still popular today *mostly* because there is a crap tone of legacy C++ code around. Also, while we have Objective C, C#, OCaml, etc, I don't think we have a better C with OO stuff, alternative. D lacks the tool support to be a proper competitor. And that's why C and C++ still dominate the embedded and high performance markets. But I am curious. Of all the people who work with C++ today here, has anyone worked on non-embedded, non-real time, non-high performance, not required to interface with legacy code, software which was *started* in the last 5 years and is in C++? The most recent C++ software I've worked on was 7+ years old and that was embedded too. I also know that Google and Facebook use a lot of C++ in their infrastructure but that's all high performance. Any *new* vanilla software projects written in C++? 
&gt; has a type system that is more safe than most common alternatives with the typedef system and the amount of casting that happens, I would disagree with this statement vehemently. I've worked in dozens of codebases with C++ and rarely is type management done properly. It's too permissive.
I am actually kind of surprised that no C++ compiler to date can just generate headers as a byproduct of compilation of the .cpp files.
Agreed. In fact, of the languages I know (that have static types), c++ is the least safe. NULL, no array bounds checking, pointer arithmetic, explicit memory management, etc. Now all of these things have positives as well and I use C++ regularly, but I'd never claim it was safe.
C++ isn't used more because it's better. it's used more because of the large code base of c that existed when it was created. Now that there's a lot of C++ code out there, there's even more inertia behind it. Integration with existing code is often a significant factor in choice of development platform and using C++ can be the least expensive choice. I don't find it very productive to discuss the strength of a language independent of a problem to solve but I have found that programming in C and C++ is more tedious than programming in Java, for example. I've been programming in C and C++ for 20 years. 
There are no alternatives *yet*. C++ has the cleanest dirty shirt. For all its flaws, cruft and baggage it's still the language you turn to write portable high-performance code. It gives you very fine control over data layout and data access patterns (I'm talking mostly about things like object layout and cache locality rather than manual memory management). Its performance model is more widely understood and it's easier to optimise, unlike JIT-ted code, which is still largely black magic. Enormous amount of man-hours put into the development of C++ compilers gives it a head start in terms of performance over other emerging systems programming languages, like Go and Rust. While they have potential, C++ is faster *right now*. The other such language is C, but it's simpler, more explicit, and, as a result more verbose. C is still preferred in some circles for its explicitness and simplicity and is easier to interoperate with other higher level languages, but C++ still dominates more monolithic apps and systems (complex desktop apps, games, HFT systems).
The D compiler uses the back ends of Digital Mars C++, gcc, and LLVM, so can take advantage of the optimization effort put into those compilers.
Virtual inheritance causes a large amount of complexity and difficulty for tools / compiler writers, which for the most part I'd say I personally think is not worth the additional cost of complexity.
I've been wanting to start e new IDE project using C++ and Qt. I've been starting to doubt that though
messy? You may be talking about the inconsistent syntax, but that can be avoided: In a type declaration, the 'const' normally applies to the element to the left of it, EG, int * const * is a mutable pointer to a constant pointer to a mutable int. The confusion arises when programmers put the 'const' all the way at the left of a type statement, in which case it applies to the part to its right. This syntax irregularity can be ignored if programmers abstain from putting const at the left.
Uhm, ok. Thanks for the answer I understand most of it. +1
Thanks for the answer. The comparison in prph2 is very motivating. +1
Well, the longest c++ program i have ever written had just over 500 lines. I suppose you are right. +1
Because const forces you to not be able to change it. You can then send that const variable into const functions (which will not change the variable), and then be assured that the variable has not changed. ed: Example: void Update(Enemy&amp; anEnemy); // Oooh shit I don't know what's gonna happen in there. void Update(const Enemy&amp; anEnemy); // Ah, nice. I don't need to worry about what happens in there.
All of these problems can be solved using genetic data containers from STL, or you could even write your own.
I'm actually puzzled by D's lack of popularity despite the language being on the market for a very long time (add to that the fact that I completely forgot about it in my post). Does it because it lack a big corporate overlord that can generate a lot of buzz? Or probably it resembles C++ too much, but people who hate C++ want a completely different language, and people who like C++ are happy with it and continue using it by inertia? Or maybe I just need to read Hacker News less.
When you're shifting from PHP every other language seems like a nice option. :-) 
Type safety is about ensuring that any well-typed program is safe. Compared to languages that care about type safety (like java, scala, haskell,...), C++ is nowhere close. It allows you to do many unsafe things. This isn't necessarily bad, it's just a trade off. The good news is that you're allowed to do unsafe things, which may perform much better. While you can restrict yourself to STL, for example, you certainly don't get *guarantees* that you aren't corrupting the heap/stack, while you would get those guarantees in a safer language. In general this is another point of C++: it has tons of great features -- but unless you pick the right ones to use, you can easily hurt yourself.
There are already proposals on the modules in C++. Too bad so much time was used up by concepts, instead of sometheing immediately useful.
Indeed, and I was trying to support your statement. :-)
Everything you mentioned was inherited from C and is not a huge problem if you're using modern C++ constructs (nullptr, std::vector/array, smart pointers etc) 
I prefer "data structure oriented programming" because every time people hear "OOP" you inevitably end up talking about Circles and Ellipses and AquaticLandWingedVehicle classes. C++ really only provides a mixed bag of relatively lightweight features that can be applied to structs to create something that approximates OOP (amongst other paradigms).
&gt; Compared to languages that care about type safety (like **java** Java has null and for generic containers has type erasure. 
That makes a lot of sence. It's a lot safer when it comes to using functions you didn't write. Thanks for showing that. +1
Thats an overkill given static local variables are guaranteed to be constructed only once, even in the presence of threads. CSingleton&amp; CSingleton::GetInstance() { CSingleton instance; return instance; } is as good but less convoluted.
Returning a reference to local variable there. You might want to add the static keyword.
yup, 'static' should be there ofc ;)
T&amp; Singleton&lt;T&gt;::GetInstance() { static T instance; return instance; } That is not thread-safe - if GetInstance() is called for the first time from multiple threads you might get different instances returned. EDIT: hm I might have been wrong. There is a clause about "Dynamic initialization ... with concurrency" at http://gcc.gnu.org/gcc-4.8/cxx0x_status.html which says "NO" as in "no implemented". However the linked page mentions that GCC implements function-local static-duration objects by means of using a lock. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm#Local
Why do you need a class if it doesn't have any member variables? Ie why not have just: template&lt;typename T&gt; T&amp; GetInstance() { static T instance; return instance; } That's actually almost identical to the singleton I have in my project.
For me, this is more of a stylistyc choice. With this function you can do: GetInstance&lt;int&gt;(); GetInstance&lt;float&gt;(); GetInstance&lt;std::vector&lt;std::map&lt;int,std::nothrow_t&gt;&gt;&gt;(); None of which make any sense. By making this a class template which users need to derive from, feature is opt-in per type, and you need to explicitly state which types are singletons.
Have you considered contributing to Qt Creator? I like it as a C++ Linux IDE. 
Enforce the singleton pattern. Your method does not enforce that a class can only be instantiated once.
Oh, that. In my case, I just make the constructors and assignment operators private (and friend the singleton-function) individually, so I guess inheritance would save me couple of lines there.
If code is ready, how often do you need to navigate?
The fact that the class does not have any fields is an implementation details. Conceptually inheritance conveys to people that you wish to provide your class with some kind of is-a relationship or trait that just having a naked function out in the wild does not. When your class A inherits from Singleton, you are saying that A 'is-a' Singleton. The meaning is clear; how that meaning is implemented behind the scenes is not particularly important, only the relationship you're exposing matters. At the end of the day this is a stylistic matter since you are right, functionally speaking you get a similar result using a plain ol function. But the purpose and the intention you convey to users of your API, in my opinion, is expressed a lot more clearly using inheritance than using a function. I am not going to act like my way is vastly superior or the one true way of doing things though. If in the codebase you work on it makes more sense to use a template function to express that, then go for it. The correctness is likely the same using either method.
I think the best way to learn C++ is to have a mini project and just go for it. One of the first C++ projects I did in school was to write a minesweeper game. You get to learn about classes, writing to and reading from a terminal, the STL, memory management, and lots of other good stuff. Additionally we were told to design it so we could swap in different UI components, so this way you learn about how to use interfaces in C++ as well. C++ is all about learning a ton of somewhat obscure rules, so don't worry if you get tripped up a bunch. That's natural and you'll get through it!
Singletons are basically the same as globals, and thus are hated mostly for the same reasons. Global mutable state makes reasoning the effects of functions harder.
Stylistically it would be better to use public inheritence, since private inheritence does *not* model "is-a" but "is implemented in terms of". This would also allow to get rid of the redundant "using Singleton&lt;MySingleton&gt;::GetInstance;". But that's just nit-picking. Your template class is well-done and idiomatic. One more thing: "inline" is missing for "GetInstance" :) .. enough picking...
Nitpicking is good and I appreciate your correction. You are right about public vs. private inheritance, as for the inline, it is not needed for templates as templates are always inlined by definition.
I think I know, but just to be sure, by a "self instantiating singleton" do you mean a class that has the "singletonness" built-in, as opposed to a normal class where another object makes sure to only create one instance? Also, absolute statements are always false, don't use them. (Sorry, couldn't resist.)
Enable warnings. :)
When its in C++, its not really OOP - as Alan Kay (who invented OOP) stated "When I coined the term object-oriented programming, C++ was definitely not what I had in mind). Unfortunately, most "OOP" languages learned from C++, rather than Smalltalk, so the name has become heavily abused.
Thanks for explaining, how would you characterize the main differnces between what you see as Data structure oriented programming and OOP?
Does any compiler actually implement that guarantee yet?
Singletons get a lot of hate for a reason, and not just for shits and giggles. 
That's the thing, I did! It's a bunch of templated member functions of class templates, and even with all warnings turned to eleven the compiler silently ignores the missing return. *edit: I was wrong, somebody reverted my addition of -Wall -pedantic to the Makefile.*
As with much of software development, people tend to adopt practices not based on a rational evaluation of the pros and cons, but based on religious or gut feeling reactions to words and fashions. When I hear people who are supposed to be engineers say things like 'it's evil, never use it...' etc... I tend to ignore it and actually find it one of the more disappointing aspects of this field. Chances are you use singletons all the time. You probably don't explicitly pass around a memory allocator to every class that needs to allocate memory, you just allocate it using the global heap. You probably don't pass around a Filesystem instance to every class that might open a file, you just use the global filesystem provided by your operating system. Chances are you make use of global data that expose underlying hardware resources in your application all the time. As an engineer it is more prudent for me to ignore absolutist statements and instead evaluate the different approaches, weigh the pros and cons, and then make a decision that reflects a much broader viewpoint.
That sounds like a compiler bug, then. What compiler and version are you having this issue with?
Looks like gcc does, but VC does not.
Sure, it's safe to stay at home than to get in the car, but it doesn't really get you where you want to go. If you'll excuse the brutal analogy. :)
Wouldn't when_any() and when_all() give you basically that? I am surprised &amp;&amp; and || aren't mentioned in this proposal, especially considering PPL supports them. I do find it odd they aren't following the typical proposal format. Then again, this may be part of the "call for libraries" which is now accepting more "casual" proposals for C++.
I've taken classes that covered the STL (and template programming in general) and a class that covered the book "Effective C++". Those were both amazing for me. 
Looks like you are trying to run the source file and not the compiled application. 
I partially disagree, whilst I believe the only way to get GOOD at coding is to code, it doesn't really help you learn a language like C++, there are to many idiom and "good" practices that you are highly unlikely to derive on your own but will help you imesurably
Ermmm, yes they seem to imply that you can do that, but the proposal makes no mention. when_any (of what?) when_all (of_what?) I do hope async goes in a sort of PPL like way. that of Intel borrows some of it's patterns for Intel TBB.
If you are learning C++, it is my advice to you not to bother with GUI's for the moment at least. you need to get the basics (and some of the not-so-basic) down first. Learning a new language is also a great time to learn to hone you ability to create great command line programs, there is an art to it.
I guess my point is that it doesn't make much sense to talk about *languages* as "safe" or "unsafe" — we should rather be talking about *code*. :-) My postulation is that it's not harder to write accident-free memory-safe type-safe code in C++ than it is in, say, Java, if you know how (i.e. avoid raw pointers, avoid unsafe casts, use exceptions).
GCC had thread-safe local statics by default long before C++0x even looked like making it to fruition. You can disable it with -fno-threadsafe-statics 
Sams Teach Yourself Visual C++ in 21 Days There are a part of it teaching the paint program
Well look at that... Thanks for the link. I guess I got it in my head that because calling a pure virtual function in the base class is such a big no-no that it might cause compile errors. TIL.
Day 8 , if not mistaken
http://www.cuteqt.com/blog/wp-content/uploads/2009/06/c-gui-programming-with-qt-4-2ndedition.pdf It also contains a chapter on C++ for Java/C#-developers.
In keeping with C++ style we should try and keep whatever information we provide minimal, I do however think some information to new comers would be welcome. Ok, I think as a community (?) we should encourage people to learn C++ in the most useful way possible, this invariably means buying a book -- the information on the interet is usually terrible. I believe the SO link here is the best resource for this (on the whole I don't like seeing SO links here, but this one is genuinely useful) http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list I think it would be of use to have a link to showing new comers to C++ how to get started with the compiler and editor. Nothing to extreme and ideally platform &amp; vendor independant. The rest of the toolchain usually get picked up in time.
That's not *just* what I was referring to, but I do have to defend headers a bit. Headers are a very capable way of controlling how objects are assembled at compile time. Unfortunately, this capability shuffles the requirements of ensuring that names are appropriately constructed to the developer. As of right now, there's no way for a C++ compiler to know what you mean when you refer to something not declared in the compilation unit's code. Hence, headers. Linking in C/C++ is such a delicate and error-prone process that I am afraid that any attempt to rectify this will end in failure. The proposed module system may be a step in the right direction, but due to the desire of the standards committee to keep current implementations up with the standard, and the wide variety of platforms these implementations are written for, I worry that this will not end well.
I included that link in my answer too, but wouldn't it be best to also include lots of high quality resources that are available for free? Just buying $30+ books might not be the optimal option for a high school student, or a college student on a very tight budget (I'm speaking from experience). 
I'm using eclipse to run it. You would think it would be so simple, but it isn't. I'm avoiding using cygwin directly because I'm intimidated by linking and makefiles and all that (I come from a Java background (as evidenced by my use of eclipse instead of VS))
Thanks! I'll take a look at those. Looked at the list, I have no problem starting from chapter 1.
One other thing not mentioned about "const". It lets the compiler make optimizations it could not otherwise make, in some cases. 
You can have a look a very old article from me, it uses Java though http://ai-depot.com/articles/minimax-explained/
Define high quality, so far the ones linked here aren't. The free stuff is usually accademic code, accademic code is often not production quality or idiomatic, this is stuff is important to learning C++ correctly.
Can you link them please?
That's too bad. His other video about universal references was very informative.
My understanding is that each process can request its on console... Were you implying someone could read the console from another process? 
It feels so wrong. But at the same time it feels so right. Great work!
That looks awesome.
If it makes you feel less wrong, this isn't that much different from stream manipulators.
so even though the `#include "whatever"` isn't in the same dir as the file that's including it, it'll still be found as per however the guru's have decided to set up search, that about right? I know it's being found, was just a bit confused as to the "how" since in school they didn't really cover this in too much detail, and just always told us to have the included file in the same dir....they left out a lot of stuff i've had to learn on the fly.
Yep. If you look at the command-line being invoked, you might even see how they're setting it up, as frequently this is configured by passing -I arguments to the compiler. A further note on "" vs. &lt;&gt; is that usually the search path for "" includes the search path for &lt;&gt;. And the &lt;&gt; search path is usually fixed for a given installation of the compiler. Whereas the search path for "" is specified by the build system for a specific body of code.
This is wrong. `#include &lt;file&gt;` will search for `file` in some implemantion-defined manner `A` (generally search the include path). `#include "file"` will search for `file` in some implemantation-defined manner `B` (generally in the current directory), and then in manner `A` if that fails.
While the search manners are implementation-defined, `#include "file"` will act as `#include &lt;file&gt;` if the initial search fails.
Basically, the C++ compiler searches various directories from a list. For both `#include "afile.h"` and `#include &lt;afile.h&gt;`, it uses a list of absolute paths. There is a built-in default list, where system headers reside (e.g. `/usr/include` on gcc/Linux, or `C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include` for Visual Studio 2012), and you can add to that list manually (e.g by using `-I` with gcc, or `/I` for VS, or setting the `INCLUDE` environment variable). Additionally, for `#include "afile.h"`, before doing the above, it searches relative to the current file, and relative to the directories of previous include files. There's pretty good documentation for this [on MSDN].(http://msdn.microsoft.com/en-us/library/36k2cdd4\(v=vs.100\).aspx)
From the error message, it's obviously windows.
Clang just looks more and more impressive by the day. Can't wait for the Windows port to be stable.
You can compile and use Clang on Windows under Cygwin and probably Mingw.
So the bottomline is, that the most common sort (std::sort) of gcc is slower than the clang variant for all but "random" input. Should be simple to fix the "unexpectedly not much to do" cases. Also this: &gt; Next set of results is for std::stable_sort [...] Notably, GCC performs much better than for std::sort. Is only true for "sorted decreasing" inputs. The other 3 cases are slower, as should be expected. Another case that might be interesting to test: partially sorted inputs (like merging a number of sorted vectors)
I personally don't see what was presented here as all that useful. you could have just as easily done: return make_info( creator, char_for_hw() ); At the end of the day if you still have to manually call `quality()` then it doesn't matter if it is a free function or a private member function. In fact I would argue the method I have shown is supior because the format of info would be "language" independant as would the conversion and calculation of it's "quality".
In limited scope, using namespace or namespace = is not evil at all. It just should not be on a global scope, such as included files, as you expose the whole namespace without the one including it knowing about it, which can lead to unexpected behavior. At most, I'm using using in function scope, and only if the namespace to write otherwise would be way too long. Like.. ::xml::parse::type::function_type::places_type::iterator. In that case, using namespace ::xml::parse::type might be acceptable.
I think this [link](http://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-a-bad-practice-in-c) will answer your question. I was also wondering the same thing.
Because often times online code is intended to be copied and pasted. 
yes, it did indeed, thanks
min &amp; max are others...(in WIN32, these are actually macros - ugh).
When to open a using namespace is generally very subjective and will differ from person to person. That said, I *generally* agree with this with wung said. Putting it in a .h file is bad simply because it changes behavior without the user knowing about it. Other than that, I'm pretty liberal about using it, more so than wung in this case. I would have no problem adding a using namespace std at the top of a .cpp file. Some will balk at this but I have never in my entire career had a collision with anything in std and the number of times it has saved me from typing out std:: is uncountable. 
My own pet peeve: 'using namespace' should *never* be found in sample code or documentation, because it makes it much harder to follow along when you're writing code in a context that does't choose to do the import for obvious reasons (headers, e.g.). The boost project consistently gets this wrong, and one has to waste time trying to figure out if it's boost::string_split_iterator or boost::string::string_split_iterator or boost::algorithm::string_split_iterator or any of 1000 other possibilities.
By the way, you can limit the scope of a *using* statement to the file it's declared in like so: namespace{ using namespace... } ...&lt;code that uses&gt; ... Strange syntax.
Yeah, this is the closest equivalent to the Java convention of doing a separate import for every class referenced. I tend to be quite liberal though, and just fully specify all references in header files, and pull in the entire namespace in cpp files.
Well, to play devil's advocate, those names are bad anyway, precisely because they're understood by C++ programmers to be std namespace symbols. So yeah, you can define a variable named "sort", but for the love of all that's holy, don't. No one wants to start walking up the lexical context looking to see if someone imported it or not. Of course, not all symbols are so obvious, so in practice it's not quite so clear cut. Still, I think the danger here is somewhat overrated. 
As explained in [this link](http://www.janko.at/Humor/Computerwelt/using%20namespace%20std.htm), "using namespace std" is like having a cargo hold full of tribbles dumped on your head.
Why would you guys downvote this guy for asking a question? Damn.
Actually, that's not at all the purpose of anonymous namespaces - the effect of that code is that anything within the anonymous namespace cannot be seen outside of the compilation unit! This is a replacement for one of the uses of the "static" keyword... So what you wrote will work - but the side-effect is pretty strong...
And by interpreter you mean compiler... I don't think there is a C++ interpreter.
I think this inside view of the committee helps explain why a committee approach to a language can be a very valuable one.
I'm not sure if this additional terminology provides much utility in understanding r-value references. I think the last thing that helps clarify T&amp;&amp; is to introduce yet another type of reference as if this new reference type were a thing in and of itself. I don't see what's wrong with just accepting that T&amp;&amp; is always an r-value reference period. But it just so happens that an r-value reference to an l-value reference or vice-versa is the exact same thing as an l-value reference. Apart from the convoluted terminology which C++ is full of, it's pretty clear and intuitive why that's the case. If instead of convoluted terms like r-value, l-value we just demonstrated this without that baggage it would become clear to most developers: T&amp; &amp;&amp; is simply the exact same thing as T&amp;. T&amp;&amp; &amp; is simply the exact same thing as T&amp;. Acting like on top of l-value and r-value there is also now this u-value reference bloats what is already overly complicated terminology to understand what is fundamentally a pretty simple concept.
While I do agree with Kranar that this behaviour can be considered a 'simple' reference collapsing after a parameter type deduction, I don't really think that it is bad to introduce new terminology for an unintuitive special case. IMHO, it doesn't need to be a part of the standard or anything, but since T&amp;&amp; really behaves differently than the people might expect, it is useful for understanding this special case. If nothing else, it allows us to easily remember when the "template argument deduction tweak", as STL nicely put it, happens.
If i use "using" at all it's for very local scope to keep declarations from line wrapping if possible. I guess "auto" may help with that since the bleedover usually comes from declaring iterators. I'm honestly not sure if Iike what "auto" may do to maintainability, however. It has the possible same issues that "using" has. To date at work we've so far only adopted rvalue ref and std::move from c++11.
I expected a photograph of a room with a bunch of middle aged people sitting in folding chairs.
^ Sounds dirty.
Never before have I seen italics used to display large chucks of code, now I know why; it's unreadable.
Interesting implementation challenge. Still not quite sure why you'd want to use fmap though. std::bind, std::for_each, std::transform and std::function all fill the need in one way or another? That variadic template function reference is sexy though.
Because when you're coding in Haskell, code using fmap, lifts, ap and so on is extremely concise and elegant. Unfortunately the same cannot be said of doing it in C++.
*std::bind*: I assume you mean for composition. Which syntax would you rather use? std::bind( f, std::bind(g,std::placeholders::_1) ); or fmap(g,f); *std::for_each*: Fmap creates a new list. std::for_each modifies the current if you supply a ref-taking function, but fmap expects the caller to supply a value-taking, value-producing function. In my own code, I have specialized fmap to modify the existing sequence if it's an rvalue, or copy then modify otherwise, but only when the return type of the function matches the value type of the sequence. Even with this, it calls std::transform, not std::for_each. *std::transform*: Here, we have the choice of writing SequenceType r; std::transform( std::begin(s), std::end(s), std::back_inserter(r), f ); and auto r = fmap( f, s ); Which do you think is more appealing? Though, it might make just as much sense to define a function, map, that only expects sequences and implement fmap for sequences in terms of map. It also makes sense to write a version implemented with std::for_each, but it can't be called map or fmap. So, why use fmap if we already have std::transform? Because you can't transform every type! For example, std::unique_ptr and std::tuple, both of which you can fmap. You could implement some sort of fmap for each type you wanted to apply regular functions to, or you could use fmap. So why use a generic solution over a specific one? To be generic! We don't always want to be generic, I know. It doesn't always make sense to write a generic template function if you only end up calling it with ints. Fmap isn't the only thing I want people to take away from this. I also wrote this article to share the technique of implementing super-generic functions and type classes. Fmap just happens to be the most basic, generic function that is unlocked, given C++11. *std::function*: Avoid using this at all costs if you care about efficiency. One rarely *needs* to specify an exactly-typed function and if you don't like perfect forwarding, passing by const reference is almost always good enough.
Nope I haven't, but am waiting for his newest revision covering C++11 and I will be getting that. Or is already out? Back on point, I suspect in print the italics could work very well, but on the lower dpi of a computer monitor they are very harsh
I think the idea of a C++14 is a great one. There's been a number of little niggles which have been revealed since C++11 was finalised (e.g. make_unique) so a small intermediate release to address them sounds good to me.
I would kill for Haskell that was a little more like OCaml (mutability more accessible when needed, strict semantics by default).
&gt; Excellent article full of sexy code ;) Thanks! I'm honored you feel that way. &gt; The former, because I know many (most?) C++ programmers wouldn't know what "fmap" means or does That is exactly what I'm attempting to change. I find a lot of vitriol between functional and imperative programmers, largely because functional programmers think imperative programming is dead and imperative programmers think FP is fundamentally different and incompatible. I want to see this culture and knowledge gap close and have a more integrated programming community at large. I think it's about damn time C++ programmers learned what fmap means and it only takes two minutes to explain it: Fmap takes a function, f, and a Functor, F(x), and applies f to x. With that explanation, and a few concrete examples that merely show where *x* comes from, I fail to understand why even Haskellers stumble over this concept. (Same for Monads.) If at the end of the day, we only wrote code that most C++ programmers would know what meant, then we could have never started experimenting with move semantics, perfect forwarding, or smart pointers. Every time a new feature was added to the standard, no one would be able to use it since *most* might not know it was there! &gt; In this respect std::transform is actually less to learn than fmap + whatever it takes to fill those functionality gaps in the Haskell world. Yes, for the reasons you noted, fmap would be insufficient and a more specific solution would be required; even Haskell doesn't rely on fmap alone. fmap is for situations that are more general than requiring the special features of iterators. Although, as for doing in-place transformations, this is a quality-of-implementation detail. For example, in my own code, I have several declarations of *map* that funnel to *mapExactly*, which takes an explicit template parameter, the return type, and delegates to *_map*, which takes an iterator to the resultant. template&lt; class X &gt; using Decay = typename std::decay&lt;X&gt;::type; template&lt; class A, class B, class R &gt; using ESame = typename std::enable_if&lt; std::is_same&lt;A,B&gt;::value, R &gt;::type; template&lt; class A, class B, class R &gt; using XSame = typename std::enable_if&lt; !std::is_same&lt;A,B&gt;::value, R &gt;::type; template&lt; class R, class F, class S &gt; auto mapExactly( F&amp;&amp; f, S&amp;&amp; s ) -&gt; XSame&lt;R,Decay&lt;S&gt;,R&gt; { R r; _map( forward&lt;F&gt;(f), std::back_inserter(r), forward&lt;S&gt;(s) ); return r; } template&lt; class R, class F, class S &gt; auto mapExactly( F&amp;&amp; f, S r ) -&gt; ESame&lt;R,S,S&gt; { _map( forward&lt;F&gt;(f), begin(r), r ); return r; } &gt; I'm not even sure why you'd want to use a mapping function on single pointer values when you can just dereference and apply it directly? You're focussing on the wrong part. The cool thing about fmap(f,ptr) is that it implicitly checks for null and only calls f when ptr isn't null. If you write a variadic version, it'll implicitly check for null on each. You can then string the value of that computation to the next function without needing to be entirely cognisant of the possibility of the pointer being null. In short: Less mental energy, guaranteed safety.
Amazon is currently claiming a release data of March 25, 2013 but of course that is only preliminary.
the rate at which articles about fp with c++ are popping up right now is sort of amazing.
Actually any well written text would be welcomed! Coverage of the latest standard has been slow in coming. 
Does anyone know if Andrei has plans to write Modern C++11 Design?
Even though the book is about Microsoft's IDE and I'm on Linux, I find that [this book](http://www.amazon.com/Ivor-Hortons-Beginning-Visual-2012/dp/1118368088) explains the language very well! I've used it to learn C++ by myself when I was in high school and I often advise people to read it! EDIT: but back then it was Visual C++ 6 so I'm assuming that the new editions are as good.
Don't do it!! Just kidding. :-) Python and C++ are my two fave languages. And it's the logical next step if you want to become a truly hard-core programmer. First, C++ has (unfortunately) several traps and idiosyncrasies that can make your life difficult. You should develop good habits in advance to prevent running into those traps - which include implicit conversions and other compiler-created methods, the difference between virtual and non-virtual functions, and some unintuitive parses relating to parentheses... The [Google C++ style guideline](http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml) is a bit heavy but covers pretty well all the bases. You should pick some sort of style which prevents these traps and use it every time. The reason you use C++ is because it's much faster and uses less memory than Python - so you should be always keeping that in mind. (Almost) always pass structures and classes by value (your style will probably prevent you from accidentally copying classes anyway). Consider looking at the machine language code that's generated to see what's going on - it seems hard initially, but it's not so bad. Templates are hard - though very useful. Use them only when forced to. Macros are extremely dangerous. Avoid using them for anything except [guards on your header files](http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#The__define_Guard) (which MUST be part of your style). The other book references here are good. I'm going to again add Scott Meyers's "[Effective C++](http://www.amazon.com/Effective-Specific-Improve-Programs-Designs/dp/0321334876)", which, while somewhat tough going, is extremely strong and also a good read.
&gt; For example, you'll have to deal with the compiler and linker, ABI issues, your IDE and/or build environment. It's quite likely that if he's working in an already-established work environment, these will already be set up for him. In my 20+ years of C++, I've actually only had to set these up myself for one C++ project - when I set up my own company.
&gt;The [1] Google C++ style guideline is a bit heavy but covers pretty well all the bases. I would recommend against using google coding standard. The coding style makes sense for them, but it forbids many useful features that will make your overall experience with language much worse. &gt;Avoid using them for anything except [2] guards on your header files (which MUST be part of your style). Unless you use '#pragma once', which is much better solution. Also when you are comfortable with language look [here](http://www.gotw.ca/gotw/).
&gt; it forbids many useful features that will make your overall experience with language much worse. Specifics, please? Quite a lot of these are suggestions rather than absolute orders: "Do not overload operators except in rare, special circumstances" (something I agree with heartily). The quality of the Google codebase is miles ahead of any other codebase I've read, and when I worked there I grew to appreciate some of the things that I initially felt were restrictive. Take the ban against default function parameters. I initially felt it was stupid - but then I realized that I'd earlier in my career run into several bugs that were very hard to track down that resulted from looking at the call site multiple times - but not realizing that the default choice wasn't working right. The same is true for the ban on function and method overloading. Now, these rules are particularly important with a large or very large codebase - when if you call a function or method "Set" the "next guy" reading it might not have the faintest idea where to find the definition of that "Set" (and unfortunately many C++ IDEs aren't particularly good at getting this task right if you link with libraries...) but they really do make for easier-to-read code with fewer traps in it. Remember that, unlike most languages, if you see a call like `someFunction(foo)` in some code, the rules that the compiler uses to decide which `someFunction` to call are quite obscure. Consider the rules involving [overloading vs. overriding vs. shadowing in C++](http://yosefk.com/c++fqa/inheritance-mother.html) - gnarly! Better not to have to know them. Particularly when you're starting out, and particularly in C++, I think it's good to follow a somewhat-too-restrictive style guideline that prevents you falling into a lot of classic traps and then once you're more mature in the language you can start to introduce new features when you're sure you need them. &gt; `#pragma once` [is better than guard macros] Excellent point, you're quite right. It's very likely if you are starting new development that `#pragma once` will work over all your target compilers. I am unfortunately still having to compile for legacy targets and so can't use this (or C++11) so I tend to forget about this. I'm hoping that in 2013 I can get rid of my last legacy system (XCode 3) and jump right to C++11. EDIT: someone claims [here](http://www.cplusplus.com/forum/beginner/7877/#msg36635): &gt; #pragma once can fail if the file system contains links to the same file that the compiler cannot follow. &gt; For example, NTFS5 (Windows) supports hard links, but you can't detect that files are linked if you access the file system across an (SMB) network. Thoughts?
"Modeling Derivatives in C++" by Justin London is NOT a good book to learn C++ from; here's why: http://www.nuclearphynance.com/Show%20Post.aspx?PostIDKey=61699 // see hammerbacher's reply http://www.wilmott.com/messageview.cfm?catid=11&amp;threadid=13831&amp;STARTPAGE=2#170270 http://www.wilmott.com/messageview.cfm?catid=11&amp;threadid=19133 http://www.wilmott.com/messageview.cfm?catid=11&amp;threadid=38937 http://www.wilmott.com/messageview.cfm?catid=11&amp;threadid=47917 OTOH, I can recommend "C++ Design Patterns and Derivatives Pricing" by M. S. Joshi, it's pretty decent (note: I don't know if you're doing "Q measure" (that would be, e.g., derivatives pricing) or "P measure" finance (that would be, e.g., econometrics, stat. arb. -- I'm guessing you might be here), but as the title suggests some further chapters might be slightly tilted toward the Q measure side -- that being said, the general foundation is pretty solid and generally applicable and it's still the best C++-for-finance book I'm aware of). However, it expects and builds upon a working knowledge of C++ -- so, definitely read "Accelerated C++ first. If you'd like to expand on C++11 knowledge (there are a lot of useful, new features that will make you more productive), then go for "C++ Primer", 5th Edition by Stanley B. Lippman, Josée LaJoie, Barbara E. Moo (textbook) and "The C++ Standard Library - A Tutorial and Reference" 2nd Edition by Nicolai M. Josuttis (reference -- as in, you'll find it handy to refer to it on a daily basis when you're finished with the earlier books and start using C++ at work). HTH, feel free to post if you have any further questions! // When you're finished with all of the above and feel relatively proficient in C++, feel free to also take a look at https://sites.google.com/site/luigiballabio/qlbook -- although some of the choices made by QL are somewhat skewed toward Design Patterns/OOP-style programming (modern C++ would be more flexible with using the multiparadigm aspect nowadays), it's still a solid piece of work, sticking to portable, Standard C++ (and definitely tons better to learn from than the London's stuff).
&gt;Unless you use '#pragma once', which is much better solution. Why is the non-standard pragma a 'much better solution'? I mean I can see it being an acceptable alternative in some use cases but actually there are also downsides to using it as well. If this is the standard by which Google's C++ style guideline bans useful features, then seems to me like not much of that importance is being banned.
MSVC isn't the only one holding back C++11 support. Clang is arguably the most featured, but GCC/G++ are also lacking in areas. The biggest problem currently is the major vendors are not supporting the same subset. Your comment reeks of the "blah blah blah M$ is holding us all back" mentality that is not helpful. All of the major vendors have made large strides in C++11 support.
As of GCC 4.8 it [supports almost everything](http://gcc.gnu.org/gcc-4.8/cxx0x_status.html) except some of the concurrency stuff (and even that's in better shape than that page suggests).
For the record, here's a [time converter](http://www.timeanddate.com/worldclock/fixedtime.html?msg=The+Future+of+C%2B%2B&amp;iso=20121102T1245&amp;p1=137).
Clang and GCC support a larger subset of C++ and have a history of more frequent releases (check the Apache comparison page). With MSVC their is a chance that it will be two years until they release their next major C++ compiler update. This means the gap could to widen in the next year and not get smaller. MS has said they are going to push out faster updates, and I would basically like more details and dates on this support.
&gt;Fmap takes a function, f, and a Functor, F(x), and applies f to x. &gt;With that explanation, and a few concrete examples that merely &gt;show where x comes from, I fail to understand why even Haskellers &gt;stumble over this concept. Well, from that explanation I understand that programmers are confused. Most programmers would think: Hmm, why pass that functor F if it aint used - since only f are applied to x? Mehh, I guess I'll stick with the stuff I know. Sort of...
I suggest you check Oracle (Sun) or IBM one ;)
thanks!