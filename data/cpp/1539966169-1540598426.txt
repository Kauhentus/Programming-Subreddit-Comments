He doesnt know anything. Hes just making quick assumptions so that he can boost his own ego by trying to appear superior 
Just use stdin and stdout like programming competitions. Students should already be familiar with cin and cout or whatever. You can easily write a harness in bash or [use someone elses](http://sigmod18contest.db.in.tum.de/).
Thats what i was thinking. Im just worried about sigsev or seg faults in student programs crashing my test script
I've been longing for this feature in a few of my projects. More recently I've been working on a VM for a programming language I'm inventing; this would simplify a lot of that code (dynamically allocated stack frames, hand-rolled vtables, etc). I only quickly skimmed it since I'm currently at work, but how would this interact with C++20's [efficient sized delete](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0722r1.html)? Ctrl-F 'allocator' shows no matches, but how would allocators treat FAM types? It looks like we may need to add overloads to allocator_traits&lt;A&gt;::allocate/deallocate: [[nodiscard]] static pointer allocator_traits::allocate(Alloc&amp; a, std::fam_size n); static void allocator_traits::deallocate(Alloc&amp; a, pointer p, std::fam_size n); I think this is a worthwhile feature, so definitely keep at it!
Half my competition submissions went down in flames so an existing harness should cover it, [but it's easy to detect when a program launched from a script crashes](https://askubuntu.com/questions/572820/re-run-an-application-script-when-it-crashes/572823) anyways -- it's the same as launching a program that crashes from the command line, the shell is unaffected. &amp;#x200B; That said, you'll probably still want to run them all in a sandbox in case someone writes something intentionally malicious.
Thank you! Very helpful. Ill look into sandboxing techniques since i think running in a VM would be kind of annoying
This is a question of competency and an extremely basic programming task. I'm not sure what pay has to do with it.
What JSON library are you using?
A fairly good comparison is precompiled headers. In fact it could be said that modules are kind of like slightly tweaked precompiled headers (though this might cause groaning from pedantic people). You can do good parallelization et al even with PCH enabled. &amp;#x200B; Unfortunately this approach can not be used as such, because currently the C++ standard does not recognize the existence of build targets such as executables and shared and static libraries (that I know of at least). Thus you can't "tie" a single module definition to a single target in the way you can with PCH files.
Yes, please!
It would have been interesting to hear performance comparisons to D's new CTFE regex engine which seems to have a similar design. [Here's a link](https://dconf.org/2017/talks/olshansky.html) to presentation slides about it.
You want better skills, you pay more, simple as that. Why on earth would someone who knows their stuff work as a TA when they can get a well paid internship at other companies who would cover their studies?
This isn't 'knowing your stuff' this is getting the files from a directory and running commands
You can solve this with a pure abstract class (commonly referred to as an interface) that allows the task to refer to a generic "task master" class, or a building to refer to a generic "worker" class instead of the specific implementation that you have. But in general, no I don't believe that circular dependencies are inherently buggy. I've seen in quite a few codebases the need to have a pointer back to some "owner" class to enable bi-directional communication. There's nothing inherently wrong with it as long as you're careful. 
Can you elaborate on the interface concept to solve this? I thought about writing some class that sounds like you propose but eventually it still seemed to depend on the building, so it just added a few indirections but kept the problem the same. I like the idea of solving the problem with something like this though, then I won't have to rely on the forward decl trickery.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
you can remove the compilation part of you already have a cake build then just point the `SrcFolder` to the place where your binaries are. Some minor changes will be needed but shouldn't be too hard. &gt;Do you think it would be more viable to have a cpp generate input &amp; test output, so that in the future, only this file would be swapped out to test different assignments? I mean it would basically be the same, you would only have to update the `generate_input` every time. It would be harder to do this using c++ 
Just about any sufficiently interesting, and large, codebase will have circularly defined classes in it. Most of them you can get away with with simple forward declarations.
Thanks, that eases my mind. I seem to have avoided forward declarations toying with /u/jonesmz suggestion of using an abstract base class. I honestly don't completely understand why it works but in my opinion it's pretty code this way, which was my goal!
I don't understand how but using an abstract base class worked and now I have circular dependencies without forward declarations. \`building\` and \`worker\` are now subclasses of \`entity\`, a \`task\` and other classes now store an \`entity \*owner\` and it works perfectly fine that way. Special users can downcast the entity, too, and I find this solution very elegant! It captures what I had in mind. Thanks!
I will try to benchmark it. But I don’t have any knowledge of the D language, so it will take a while.
Great thanks. I was certain I had seen benchmarks about it but it is hard to google for things about D. Anyhow, finally managed to find [their documentation page](https://dlang.org/articles/regular-expression.html#static-regex), which has a link to [benchmark results](https://github.com/DmitryOlshansky/FReD).
Interestingly it also compiles with `/permissive- /std:c++-latest` and "MSVC Pre 2018" (whichever version that exactly is). Is that worth a bug report in the VS bugtracker?
Yes, circular dependencies are a sign of bad design. Yes, every codebase has them. No, this doesn't make them excusable. 
I guess I'll swim against the current and say that circular dependencies should be avoided if possible (it's not an absolute thing). One thing that helps is dependency inversion which is more or less what the other commenters have brought up. When examining dependencies on other objects ask yourself "does it depend on that *object* or does it depend on something that object has?" I think a subtlety of the problem is why something like a worker needs a *long lived* reference (dependency) on a building. It only needs to be able to extract tasks from the building, right? If a worker needs information about a building it should maybe just get it from the task itself in some other form. Does it need the building or does it need to know where to go when it's done? Does it need the building or does it need some object that is a source of tasks? Think about those finer grained interfaces and make the building an implementation of those various interfaces you're interested in.
Do you have an ELI5 for complete noobs? The "2.2.1. Simple: Trivial" is too complicated. And something without raw new/delete please.
That's an interesting point, the temporal aspect. In this case, exactly, the worker needed to find what building to go to work on the task. But this information is a little more complex, because each building stores information what tiles are what I called "interact tiles", i.e. tiles a worker should be in in order to count as "if you stand here, you can interact". So if the task stores that information, it wouldn't only be a Vector2 for example, but a list of them. And I haven't fleshed out the actual working in/for a building yet, so the data may increase, which made me think "meh, just give full access to the building so each worker can query whatever he needs to know". Thinking further you may be right that I could solve it differently - once I have thought the job system through. I could see some kind of "job site" object which captures the subset of the building required for working on a task and this may solve the full-blown dependency!
FYI I've already filed a bug for this in the internal tracker. 
The problem with that is you're begging for silent UB. The issue is [dcl.constexpr]/6 (C++17): &gt; ... If no specialization of the template would satisfy the requirements for a constexpr function or constexpr constructor when considered as a non-template function or constructor, the template is ill-formed, no diagnostic required. If you put code in `curry` that isn't constexpr for any type it will still compile due to being a template but is technically ill-formed.
C has the same memory model.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9poynk/i_want_to_learn_c/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Any given entity may have relationships with a thousand other components of different types, there's no reason for that entity itself to be aware of them - this is a sign that your model has not been fully normalised. In the particular example you mentioned, a "boss" is just another employee with a different title. Maybe you need a 3rd company class that has a collection of all the employees and captures their relationships by mapping employees to a vector of their underlings
Why have this when we don’t have VLAs yet except as a compiler extension. Both Clang and GCC support them but it is nonstandard.
https://en.cppreference.com/w/cpp/language/pimpl
This is different from VLAs. VLAs have dynamic \`sizeof\` and are usually allocated on the stack, but maybe they're potentially allocated on the heap. VLAs were tread out a thousand times before, in papers like [https://wg21.link/n3662](https://wg21.link/n3662). It was not allowed into C++, mostly because it had unpredictable performance characteristics. This proposal would (not will, it hasn't been submitted yet) do something that is not at all related to VLAs.
I understand the concern about snowflake features. Having too many of those is a problem. But, we also already have a lot of C code with this defined in it: if we can't find a way to properly merge this into C++, then there's very little we can do for codebases that need to use and rely on these features except tell them to either rewrite the code entirely or similar drastic change. Is the definition of a well-boxed feature that has the same logical restrictions as its predecessor that bad of an idea? Most of the restrictions here are based purely on reasonable constraints both the language and implementations provide, so I feel like this is a defacto split already, just one we put our hands up in standard C++ and say "don't know what you're talking about, friend, that's not in ***my*** standard!". My definitions here are derived purely from existing practice. The exploratory papers changed everything, but changed far too much still in my opinion. I feel keeping parity with C here is critical without going too far off into the weeds, and that maybe there is a future where this can be extended. In my head, it's similar to constexpr: it was extremely restricted and really did cut the compile-time world into pieces (instead of being mostly templates). But as implementation experience and usage knowledge improved, further walls were knocked down. constexpr had the liberty of freedom from C, however: this one needs to be done a lot more carefully! In relation to the snippet of code you provided, I appreciate that idiom and how it works, but it still does things I am not comfortable with. For example, it assumes a std::allocator / new model under the hood for \`make\`. I'm sure it could be templated or changed to work in terms of all allocators, but now you're injecting the new/delete semantics into the value of the type, rather than keeping it separate. FAMs keep the invariants of the bits and bytes of the class separate from the allocation scheme, which means your example could be composed from either the default (which is just `new my_fam_type(...)` in my proposal) or spun up using std::malloc or some other allocator scheme, or having to make it into a std::unique\_ptr. This is a win in my opinion, but I really do need to work more on the problem (which is why this isn't in San Diego's mailing yet).
Of course that's a solution but isn't that contrary to how OOP is supposed to be? If an employee (if we stick to the example) object wants to schedule a shift he needs to communicate to his boss. Sure we can implement an outsider class responsible for shift scheduling, but at that point I might as well switch to a relational database model with an almighty god entity and a set of tables he manages. That's my main problem I think. OOP for me is "objects take care of their own business" but that usually leads to circular dependencies.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9pqemb/please_help_me_with_my_homework/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; They just seem so natural to me when designing a system in my head Everyone faces that. Research software engineering [anti-patterns](https://en.wikipedia.org/wiki/Anti-pattern#Software_engineering). They're pitfalls that are extremely common for a variety of reasons, and understanding them and learning how to avoid them is a big part of becoming a mature software developer. Learning about anti-patterns is just as important, if not more, than understanding common development patterns. I generally get the sense that a lot of people who dislike C++ or OO development in general are people that have tried it, immediately fallen prey to a few anti-patterns due to inexperience, and assumed it was a failing of the OO design or the language they're using. 
if using Perl, the tests could be written as standard tests that use [Test::Output](https://metacpan.org/pod/Test::Output), with functions that use `system()` to call the program with args, and use `prove` to run the whole test suite. 
That 2nd screenshot looks oddly familiar. I've been fascinated with Global Illumination and read a bunch of stuff about it about year ago because I love color bleeding a lot and I was surprised how difficult this actually is. I swear I read some paper that explained some probe-based GI with the same scene as your 2nd screenshot - am I correct or is this some kind of pseudo deja-vu for me?
Thanks for the pointer! I think I fit your description too, only I didn't give up but it definitely frustrates me a lot that I can hack together whatever I need but rarely feel I write clean code. Time to work on that now that I've gotten a few hints what to look out for.
The project repo: [https://github.com/cpp-taskflow/cpp-taskflow](https://github.com/cpp-taskflow/cpp-taskflow) Wiki: [https://github.com/cpp-taskflow/cpp-taskflow/blob/master/doc/home.md](https://github.com/cpp-taskflow/cpp-taskflow/blob/master/doc/home.md)
You may want to check the 'Large-Scale C++ Software Design' by John Lakos. There are few chapters there explaining why circular dependencies are bad and different techniques to avoid them. Although the book is pretty old, it's still worth reading because the general principles still apply, IMO. There was a presentation about these techniques at CppCon 2016 from the same person: [https://www.youtube.com/watch?v=QjFpKJ8Xx78](https://www.youtube.com/watch?v=QjFpKJ8Xx78)
Learn lots of systems. Make lots of mistakes. But always strive to find the better path. 
&gt; But, we also already have a lot of C code with this defined in it: if we can't find a way to properly merge this into C++, then there's very little we can do for codebases that need to use and rely on these features except tell them to either rewrite the code entirely or similar drastic change I don't find this compelling at all. C and C++ have significantly diverged; most newer C features (post C89) are not legal C++. Realistically anyone who has written C code in the last 10 years and didn't deliberate target both languages is going to have code highly incompatible with C++. We can't merge C features into C++ simply because it makes the common subset larger. I also see very little evidence that this is being factored into C++ decision making. E.g. designated initializers was accepted mostly (entirely?) on its own merits as a feature, not for improved C interop. &gt; In relation to the snippet of code you provided, I appreciate that idiom and how it works, but it still does things I am not comfortable with. For example, it assumes a std::allocator / new model under the hood for make. I'm sure it could be templated or changed to work in terms of all allocators, but now you're injecting the new/delete semantics into the value of the type, rather than keeping it separate. I'm not sure what you mean by "value of the type", it would actually injecting it into the type. But this is how all dynamic containers that use heap memory in C++ work; they follow the allocator model. Why would this be different? This is really nothing but a single instance of type T1, followed by n instances of type T2, in a contiguous block of memory, i.e. it is a very specific dynamic container, and should follow the same practices as other dynamic containers. In fact, I'm pretty confident that you can have quite a good, fully generic solution to this problem. That is, `template &lt;class H, class T, class A = std::allocator&lt;T&gt;&gt; class headered_array`. I don't really see any significant win that the language solution has over the library solution, certainly nothing even close to pulling its weight for the significant added language complexity. The thing is that everyone has something like this that they want to be first class in the language. A couple years ago I watched a Jon Blow video where he was trying to jointly allocate several arrays of different size and type in one contiguous block, a not-completely-different problem to this. He had some (not very good) C'ish code for doing this, that he said was error prone, so in his language he made "joint" keyword first class. I wrote a blog post showing that you could actually write some pretty nice generic C++ library code that could handle all this error prone logic once, that you could then reuse over and over. Is the use case discussed here more worthy than joint? Does the library solution fall short by more? I think not in either case. So the path we would be taking if we accepted this, and were consistent, is eventually a very bad path where we end up promoting many small use cases to be first class in the language, adding piles of complexity. I would expect that showing why library solutions fall short would be a natural first step for any language change proposal, so I think you should consider very specific and important ways in which you think that the best possible `headered_array` solution would fall short. I'm not really seeing *any*, to be honest.
The library looks very nice. Thank you for it. Do you have any plans to support task failures (when recovery is an option) and task exceptions (when further DAG execution is not feasible)?
When things like that happen, take a step back and ask yourself "does the student really need to know about the class? Does the employee really need to know about the boss?" Maybe the connections between the two can be represented in a more flexible or abstract way. What happens when an employee happens to have two or three bosses? Can a student work independently at home? Hard coded assumptions (I know they were just examples, of course) *may* tend to indicate a brittle design. By taking a step back and thinking about the problem to be solved in a more general way, which avoids those fixed dependencies, you can often create a more flexible and robust design. That being said, software developers have to walk a fine line between systems that may be too inflexible versus code that's over-designed and too complicated to easily maintain, of course. I'd never go so far as to say circular dependencies *always* indicate bad design. But you should view them with wariness, certainly, as it indicates tight coupling between two systems, which by nature makes them less modular.
You are welcome ;) I also think that TDD (test driven development) helps a lot to have a good architecture. If you don't know what TDD is, when you need to implement something, you first thing of what functionality you want to implement, then you implement a test (ideally a unit test), then you code until the test pass (and nothing more, it's important). At that point you refactor to have a cleaner solution. Rinse and repeat. The advantage of creating the tests first are the following: - Unit tests are like an "how to use my code" manual for future reader - It forces you to have nice to use interfaces (since you wrote code that use what you are implementing even before implementing it) - Your code is testable for oblivious reason! Witch means that your code can be modified (you have the safety net of the tests to be sure that you didn't broke anything in the process). - Your code will be modularized, because otherwise it's way to hard to create tests. If you like books, I also bought "Working effectively with legacy code" from Michael C. Feathers witch helped me to understand how to work on giant, extremely poorly maintained C++ codebases (and their is a lot of bad code in C++ unfortunately).
True that. I'm wondering wouldn't you expect `use_generate_n_with_reserve_with_resize` to be as slow as `use_gen_n` because it is allocating for each element again?
Rust does target cuda (the target is called nvptx). But rust does not have a memory model specification yet.
Should it somehow work differently?
Lets say in the simplest form, we have this in the scheme json file called shape.json "tp": "object", "properties": { "type": { "title": "Type", "description": "Type", "type": "number" }} at moment in the code I have to manually create struct shape{ json\_type&lt;int64\_t&gt; type{ "tp" }; }; which json\_type is a template class that has a map&lt;T, string&gt;
None of those languages have a proper memory model, as far as I am aware.
I would love such a library. There is Json serialization in protobuf if you are willing to use that. It’s a bit limited if you are using proto2 but I think it fully supports proto3.
As it turns turns out, the code he ran and the code he used in the video are different. If you check the github/quickbench linked at the bottom of the video, he mistakenly uses `begin(v)` in `gen_n_reserve_resize`, which explains the identical performance to `use_gen`. They're identical functions, both with a standard iterator. No capacity checking/size incrementing involved. `reserve(N)` allocates, `resize(N)` zeroes, same as initializing with `N`. The termination condition is just `N`, rather than `end(v)`. `gen_n_reserve_resize` with a back_inserter is much slower than `gen_n_reserve`, just as you would expect. The odd thing is that `gen_n_reserve_resize` is almost the same speed as `gen_n`. As far as I can tell from the assembly, the compiler magically optimizes out the capacity check in the loop, and just allocates 2*N at the start. Why it doesn't do this optimization in the case of `reserve`, I have no idea. You can prove this to yourself by doubling the value of `N` in `gen_n_reserve`. If`gen_n_reserve_resize`repeatedly allocated, it should be slower still. If it allocated all at once, they should be equal. However, it runs faster, implying a more efficient loop. &amp;nbsp; [Here is his quickbench with the back_inserter placed in `gen_reserve_resize`.](http://quick-bench.com/2v1fqgI-64ZU62WavzRaI9u5qz0) I also added the bonus `use_generator_n_with_reserve` where N is doubled. 
I find this: https://app.quicktype.io/ You can provide your Json Data or Json Schema and generate C++ (or other languages) classes. Maybe it can help.
Interesting. Is there something like this to generate C++ classes for an SQL database?
With this: https://codesynthesis.com/products/odb/features.xhtml you can generate Database (and other helpers) from classes. Don't know for the opposite.
Thanks!
This is not trivial. C++ is a low level language and doesn't have built in support for databases like other languages. To do this will require you to use third party libraries, of which there are any number that each have varying APIs, which may or may not support your development environment. I suggest you start simple and forget about connecting C++ to a database for now. If you insist then look at Qt's database support. But again, it's not really a suitable task for a beginner.
Yes, we are currently working on exception handling. It will hopefully be included in the next release.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [C++ Connect with Database (Bank project)](https://www.reddit.com/r/programming/comments/9puzrc/c_connect_with_database_bank_project/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Chech this one. With a macro allows you to serialize and de serialize json to a c++ class. With some limitations of course. https://github.com/Loki-Astari/ThorsSerializer
&gt; Can I connect a database like Oracle or mySql with Java? Yes, with appropriate library support. &gt; How can I make a pseudo-database in C++ (with .txt files)? That's easy to do -- just create a data table consisting of records (i.e. lines), each of which is broken into fields (i.e. segments of lines separated by tabs or commas or another suitable delimiter). Once you have established the table's format, you can add data to it, write it to a file, read it, and perform operations on it. When it's in memory, your table would be a two-dimensional array, accessible by specifying row and column indices. When it's in file form, it's a series of text lines separated by linefeeds (the "record delimiter"). Each line would be individually segmented by a unique delimiter like a comma, or a tab, or something similar (the "field delimiter"). This is a pretty simple idea, easy to begin working with, and it's the start of a full-fledged database.
Hi Freemanix, we will add an example soon!
Connecting C++ to a database is typically achieved in a few lines of code, the only problem being that they are not the same lines for every type of database. But it's hardly rocket science, so I don't quite get why you are discouraging him from attempting it at all.
[QxEntityEditor](https://www.qxorm.com/qxorm_en/manual_qxee.html) is able to generate C++ classes from database schema. Relationships are supported.
&gt; Well, int it... &gt; Oh, int it? &gt; Yes that's your answer. That's your answer to everything. &gt; Tattoo it on your forehead. using Socket = int; using Fd = int; using Handle = int; using Pid = int; using Atom = int; using Month = int; using Mode = int; using State = int; 
Hi, I wrote this library called json\_tools([https://github.com/jorgen/json\_tools](https://github.com/jorgen/json_tools)). It doesn't have support for json schema ([https://json-schema.org/](https://json-schema.org/)), but the idea is that the types define the schema. So if it requires a string but the input is a number, then the parsing will fail. It also checks if any of the "required" members did not get set by the input json and can report an error on that. It can also generate an error if there are members in the input json that are not in the struct. Obviously both states are available even though it doesn't generate an error. This requires some meta data, and this meta data is generated with some macros that are defined inside the struct definition. I'm planning on making it possible to generate meta information outside the struct definition, but I haven't had the time to do it yet. Please let me know if your having any problems using/testing it.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Is the "he/him" line on the title slide a joke? 
Looks great, I'll definitely give this a try in the future.
No tests? No CMake config?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9pxt1h/help_with_loop/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Tests as in, to compare the outputs of this version and the original to make sure that they produce the same results? Also, I've never dabbled with cmake before, but it is really nessessary for a single header?
No read me
Agreed. However, does anyone else hate the local variables being Uppercased? Makes it a little harder to scan through the code.
No cmake is not nessesary. But a test framework is. If we dont have any idea of what you have considered in your implementation, is is unfortuanatly useless in most cases. No one will consider this in a release if its performance cannot be checked by test cases.
CMake could at least set up a well exported target to make integration (with other CMake projects) more standardized. It could also drive the tests, but otherwise yeah it's not doing much -- just kind-of nice if it's available.
I had two in mind, the entirety of `meow_lane`, and the unaligned reads in AESLoad.
What about CMake RC? &amp;#x200B; [https://github.com/vector-of-bool/cmrc](https://github.com/vector-of-bool/cmrc)
WebAssembly has a memory model, the C++ memory model lowers to it. JavaScript has a memory model which purposefully interoperates with WebAssembly's.
Um, the lambda object is constexpr. The operator() may br, or might not. Not our problem.
Based on a small review * memcpy reinterpret_cast with uint8_t is still not safe, use std::byte or unsigned char, even when char is 8 bits it does not mean that uint8_t can be safe to reinterpret with * the memcpy you can't rely on the byte layout being the same for larger types * Avoid prefixing things with _ as they may be reserved (always in global namespace or followed by an uppercase character in any scope) * The assignment operator on hash_t does not check for if other is this, and memcpy to the same address is undefined behaviour * The attempted move assignment and constructor on hash_t is unnecessary, your not gaining anything for this type just more code to maintain and is actually doing one more unnecessary copy (argument being passed in) * With the constructor and conversion operator defined on hash_t be careful not declaring this explicit you might get conversions your not expecting (tbh I'd question any non-explicit conversion) * always inline is a bit of a smell, I dislike code bases filled with this stuff * no safe guards on hash_t[int] * unaligned_read is not endian-safe * the intX_t stuff limits the platforms you can support, they don't always exist * meow_hash_version_name is probably best being constexpr char static[] * When using _t variants of type traits (e.g. decay_t) you shouldn't need the typename * You should really be checking if the types are safe to examine the underlying representation 
We need "push back I promise there is room for it" and a back inserter that uses it.
There isn't a single platform I'm aware of where uint8_t isn't unsigned char, which is explicitly specified to be safe to memcpy reinterpret cast with. I don't understand your second point. Byte layout isn't known, but as long as it's consistent it shouldn't be an issue. While I am gonna remove the leading underscore for the underlying types, a single underscore is allowed outside of global scope. Good catch with the assignment operator, will fix it. I don't fully understand your fifth point. There isn't a move assignment operator anywhere. However, I will remove the non-default constructors, now that I've realized they're unnecessary. While ordinarily I'd agree on having explicit conversion operators, I feel that hash_t is enough of a special case to not warrant them, and that making the conversion explicit would hurt usability. I feel like always inline is warranted for such high performance code where a compiler not-inlining a function call would heavily degrade performance, and where the binary function size isn't a problem I don't know what safe guards to hash_t[n] I could possibly add short of throwing an exception, which any project needing performance enough to use this algorithm would have disabled anyway. I don't see how could I make unaligned_read endian-safe without either a costly runtime check or heavily limiting compatibility (std::endian isn't even supported in MSVC yet), and even then I don't know how would I write a big endian read that supports all the intended types. I don't really care about portability with platforms exotic enough to not have intX_t types defined, which are very unlikely to have an AES hardware acceleration this algorithm depends on anyway. Noted, changed the type of meow_hash_version_name. Removed the typename from decay_t. I don't understand your last point. From what I understand it's safe to examine every object byte representation via casting the pointer to it to std::byte or unsigned char.
I recommend writing Jinja2 templates to do C++ (or other language) code generation based on JSON data.. If you are maintaining the JSON directly, I'd further recommend instead using Jsonnet as the definitive description language. 
This isn't Rust, lol.
1. A test suite. Some sample inputs and outputs (for instance, hash of blocks of 0x00 or 0xFF and compared to their known outputs. 2. A test suite that also runs under UBSAN and ASAN. Obviously these are way too expensive to run in performant code, but test code is not under any such constraints. 3. Quibble/bikeshed, but common style guides suggest not indenting namespaces. I think it really hurts readability because visually we can see what a complete function scope is by aligning with the left edge.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9pzqb4/nested_functions/e85jt4b/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Regarding always inline -- compilers like LLVM set an internal threshold for how much it believes is worth inlining and perform some analysis of the compiled output of your code to see if it is under the threshold. Always inline is the code writer saying "I know better than the compiler" which is why it's frowned upon. It's also generally unnecessary outside of some very specific things (inline assembly, for example). You can always ask for `-O3` which is already heavily performance-oriented.
FLTK is the smallest and fasted GUI library I know of and it is very capable. I don't know if it has taskbar icons built in or not. JUCE is also very good. FLTK binaries start at around 400KB I think, while JUCE binaries will start around 2.5MB.
I tried fltk, but the UI is not very nice, us there anyway of making it look more native?
This is obviously some version of Makefiles I have to come across. There is so much arcane indecipherable madness in Makefiles for all non trivial projects I have ever had the misfortune to come across.
Good Point.. But I think I really need those Tray, and notification stuff. I don't need cross platform. Just windows
Thanks for your comments. We do no have any plan for now to go distributed. Right now we target on multicore shared memory model.
JUCE looks very good, until one day you encounter an undocumented bug and dig into its implementation. &amp;#x200B; I'd rather suggest you look into clipping QT. IIRC, a common GUI application without ICU, jpg or i18n in 5.8 can be clipped below 7MB.
Qt is very hard to implement, you have to download the whole framework, I just need a simple library. Thanks. 
`using Float = int;`
If you are courageous you can go for the fluent look with cppwinrt. https://github.com/Microsoft/Windows-appsample-photo-editor
thanks for the feedback. what do you expect to see in the readme? this lib is a work in progress.
I would also have a look at C++WinRT of your only targeting windows. You don't even have to write Xaml, you could do it all in native C++ code. That being said it only supports win 8.1 and win 10. Not sure off that's a killer for you. 
Usual info: intro, building, how to use, examples.
lookes nc, but win8.1 and 10? I don't think it would be nc.
That is confusing... how can it be hard to download something? 
If you're using vcpkg, you only need the qt5core package which is not that big or difficult to integrate into your project
Unless you show any benchmarks of it being faster somehow, nobody will care.
Thanks! 
It has its use cases and it makes sense to have some kind of VLAs alternative in C++. Otherwise it would be breaking its best performance promise. I think it is a worth addition
he was asking what to actually test for, not what tool to test with.
What you describe is kind of a (bad) mix between flat_map and slot_map xD
&gt; There isn't a single platform I'm aware of where uint8_t isn't unsigned char, which is explicitly specified to be safe to memcpy reinterpret cast with. &gt; &gt; Why not just do it right, anyhow?
Slightly related but the swagger-codegen using the cpprest template will generate classes based on the OpenAPI description of a REST API (the models part is related here). The generated classes will have (de)serialization from an to Json. refs: * [OpenAPI 2](https://swagger.io/specification/v2) * [Microsoft’s cpprestsdk ](https://github.com/Microsoft/cpprestsdk) 
What's wrong with wxWidgets?
&gt; I feel like always inline is warranted for such high performance code where a compiler not-inlining a function call would heavily degrade performance, and where the binary function size isn't a problem If you're claimingperformance, have you benchmarked your code Vs the original? And have you benchmarked your always inline Vs let the compiler decide? Also, binary/code size definitely matters, even for performance.
Can you elaborate a bit, what makes es it so hard for you to use Qt? Maybe it is easier to solve that problem than getting the functionality a different way. And what do you consider small? Qt is btw modular - you don't have to use all of it. 
&gt; two dozen abstract virtual base factory class factory provider enablers I've been there :( Don't forget the part where the entire documentation for each class is the class name with spaces between the words instead of using CamelCase, and you're struggling to find the class that's supposed to be the entry point. For C++, I only personally tried ODBC on Windows. It's not pretty but it's quite easy to look up how to do it: [https://docs.microsoft.com/en-us/sql/odbc/reference/syntax/sqlconnect-function?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/odbc/reference/syntax/sqlconnect-function?view=sql-server-2017)
I am working on a library which can be used to make compile time parsers and iterable strings and typelists. you can parse a string at compile time and generate a customizable AST. This library could be used to make reflection/metaprogramming libraries that operate on strings instead of DSLs or a combination of both.
Works for fixed precision float.
Try reading the manual.........https://www.gnu.org/software/make/manual/make.html
Looks like an interesting and useful library! I would like to suggest adding a readme file, with a bit of info about the library, I usually find that to be a good reference point when looking at the source. Also, a personal preference would be to see lots of comments :) Keep up the good work though! 
Could somebody catch me up why compile time string parsing seems to be such a popular topic these days? What's the use case for this? Should you be able to do all this parsing at static initialization time, for a minimal one-time cost? I'm finding it hard to justify meddling with const/constexpr strings and templates just to save a few milliseconds on startup
a common use case is for generating types, which can only be done at compile time
thank you. i've done a lot of rewriting so i haven't had a chance to document, but i'm working on it.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9q3ywm/little_help/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
The reinterptet_cast to void* into the memcpy is just noise. That conversion happens implicitly anyhow so just let it happen.
The whole `memcpy` call is nonsense. Using the implicitly defined array assignment operator will be at least as efficient, quite likely more so (it's a misconceptions that `memcpy` is the best choice for copying byte memory regions).
Code size is another thing. On embedded targets, it's not just about the few milliseconds of startup time but the memory required to perform that operation. If it can be done at compile time it might save some space.
What the parent suggested is exactly how a lot of my CS classes worked. It was critical to ensuring you code actually worked in the test harness, and that when submitted you will not get a zero for a slight misunderstanding. In theory there is no magic in your harness, many of our systems though were actually fully online, so you just submitted them and it kept the “hidden” result private. The Java ones worked in practice by linking in their own junit test suites, but other systems were used too.
I was long proponent of GUI wrapping native UI, thinking about Accesibility, look&amp;feel, etc. and was back then against Qt (which ends up imitating the look&amp;feel, not using draw controls). But then one day while debugging why a wxTextCtrl used for logging data (hundreths of MBs back then) was taking too long to position across, etc. I've found that overreliance on the native controls would put you in the infamous "leaky abstraction" situation, like code around here: https://github.com/wxWidgets/wxWidgets/blob/master/src/msw/textctrl.cpp#1772 - There is no way to design sanely around this in terms of performance, since it's abstracting too much, where a simple "get current line" instead of expected O(1) might take O(N), or similar - so now although wxWidgets wraps the native controls for you, you also have to think about that added complexity. But most of all, making a custom wxWidget control always felt a bit painful (to adjust, look good, etc.), while with Qt you have better control (IMHO). Recently coworkers have been stoked about IMGUI (in particular the Dear IMGUI) here, though myself I'm not completely sold: https://github.com/ocornut/imgui (occornut, the author recently added keyboard, gamepad + docking support). 
Right now we have to do forward-declarations for circular dependencies to be declared correctly. I'm mostly wondering whether modules have a "build order" problem with regards to circular dependencies, or whether they'll automatically take care of the issue (getting rid of the need for forward declarations).
In compilers like MSVC, you can get night-and-day performance improvements in some cases by forcing inlining. 
Thank you very much for the follow-up and publishing the library with a useful license :-)
You're welcome :)
No? Where did I claim that? It's fairly obvious by now you are just an idiot out for a fight, so I'll refrain from further posting on this thread. Have fun arguing the earth is flat or whatever other BS you seem to project onto my words, I'm out... 
Building a constexpr regex library is one example. Take a look at this one: [https://github.com/hanickadot/compile-time-regular-expressions](https://github.com/hanickadot/compile-time-regular-expressions) Her talk will be on Youtube CppCon channel soon. The key points: * Run several times faster than std::regex * Surprisingly compile several time faster than std::regex * You can perform compile time checks if the regex is ill-formed as well as compile time unit tests * Pretty good syntax: take a look at this example from the link above: &amp;#8203; if (auto [whole, year, month, day] = "^([0-9]{4})/([0-9]{1,2}+)/([0-9]{1,2}+)$"_ctre.match(s); whole) &amp;#x200B;
And with C++20 compatible compiler (Class Non-Type Template Parameters) the syntax will be even better :) if (auto [w,y,m,d] = ctre::match&lt;"^([0-9]{4})/([0-9]{1,2}+)/([0-9]{1,2}+)$"&gt;(s); w) { ... }
You should look into arrays however at your current level of programming (I'm assuming you're very new) an array can only be a fixed size so you can only store a limited number of values. You would create an array of ints, and then iterate through it using a for loop and set each value to the value of cin. You can then iterate through it again and output the values stored inside it. For storing an unknown number of values you would have to go into containers such as vectors but you should stay away from those for now. 
You have demonstrated no such thing. We both know that the OP can't just paste in your code and suddenly connect to a database. He will have to set up the include files, which are only trivial if you already know about include paths and how to set them up in your devenv. Then he'll have to deal with the libraries, did he install the correct ones for his compiler or will he have to build them himself? Oh, and nevermind that he will have to learn the difference between static and dynamic linking in the process and then correctly set that up in his make/project file. For experienced C++ programmers, all of that is par for the course and not too complicated. For someone brand new to C++ it's daunting when their main intent at first is to dive in and start coding. There's nothing more frustrating than spending hours setting up a development environment when all you want to do is start writing code. For someone brand new to C++ that is exactly what would happen.
You have demonstrated no such thing. We both know that the OP can't just paste in your code and suddenly connect to a database. He will have to set up the include files, which are only trivial if you already know about include paths and how to set them up in your devenv. Then he'll have to deal with the libraries, did he install the correct ones for his compiler or will he have to build them himself? Oh, and nevermind that he will have to learn the difference between static and dynamic linking in the process and then correctly set that up in his make/project file. For experienced C++ programmers, all of that is par for the course and not too complicated. For someone brand new to C++ it's daunting when their main intent at first is to dive in and start coding. There's nothing more frustrating than spending hours setting up a development environment when all you want to do is start writing code. For someone brand new to C++ that is exactly what would happen.
Both are such a big improvement compared to traditional regex libraries that I can't say if one is better than the other. Maybe you're right, the template one feels more natural than the literal. Anyway great job :)
Does he really? Maybe it would be more beneficial to learn high level tools like containers to get results quicker and only then go into lower level with raw arrays.
If you don't mind rolling your own IME support and don't care about it feeling lome a desktop application, dearimgui is a joy. Don't redraw unless you get an input event or are animating something and it'll do just fine as a regular app UI.
Strong enough opinions to downvote and no arguments = religious. It's interesting to do challenging things, just like climbing Mt. Everest. But it's of negative value to anyone but the one doing it.
yes i am new to this, and i was stumble upon this problem while learning loop's topic. i understand how array works, i thought there would be proper loop function to solve this. if its array i just need to use &lt;for (i=1;i=n;i++); cin&gt;&gt;number\[i\]&gt;.
There's one way to find out: [https://godbolt.org/](https://godbolt.org/)
Why should be only be able to create a fixed size array? std::vector&lt;int&gt; numbers; Stop teaching C!
It can if your compiler is ISPC
Can someone ELI5?
https://www.sourcetrail.com
`#include &lt;iostream.h&gt;` don’t use pre standard compilers.
I don't think that would help here. What's happening is the compiler won't mark your generated copy and move ctors as trivial. Maybe I'm missing something, feel free to share an example of what you're thinking about. This is a really unfortunate issue. Thx!
what can i say, my lecturer insist on using borland c++ compiler. c++ in internet not relevant on borland anymore. thats why i had code::block installed too.
After watching this, I now thoroughly understand the comment from Greg Law's "Debugging Linux C++" talk about the ptrace API.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9q5mvn/multiple_cin_in_loop/e875x7w/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Got a summary of what he said?
It was essentially "It's awful, but it works. Kind of." Which is definitely Simon's sentiment, as well.
That sure looks nice... &gt; To create and edit code maps, you need Visual Studio Enterprise edition ... Oh :(
Oh, yes, that’s an understatement. I don’t think it’s possible to design an API worse than ptrace. It baffles me that the API was ever even proposed, let alone accepted. I work on debuggers and debug servers. I have seen introduction to programming level students write better apis. 
I found that compilers were terrible at autovectorizing stencil/finite difference operation on 2d/3d data. I colleague showed me a trick the other day to reinterpret_cast a float* into a "reference to a multidimensional array" and it was able to vectorize but still was 2x slower than my hand written intrinsics. The assembly on godbolt was almost identical though so maybe I should post something on the GCC issue board.
For context, this was from the 2018 US LLVM Developers' Conference. [The talk was about Static Analysis of C++ with Clang](https://llvm.org/devmtg/2018-10/talk-abstracts.html#talk23), with this slide tracking all the different syntax in C++ for constructing an object, which is needed to track lifetimes.
I may be in the minority here, but AI find writing SIMD code easier in assembly than by using intrinsics, and usually work better than auto vectorization. 
Associated types would be great, but you can often emulate them just by adding more parameters. Does that work at all here?
Note that SSE4.2 comes with PCMP(I|E)STRM instructions that have mode "Equal any (find characters from a set)".
Wasn't an issue for me, since MS gives us free Ultimate Edition :). Well until I graduate, atleast.
Look into Ultimate++ https://en.m.wikipedia.org/wiki/Ultimate%2B%2B
I'm becoming completely convinced of the superiority of member initializer lists.
In this case you can get around it by making unchecked casts if performance is critical and you trust your code not to do something stupid.
yeah its called "google" you should check it out
I'm pretty sure it could work, I mean you're supposed to be able to do as much as SFINAE. There's pretty much all the types library that you can use as is. The [cppreference](https://en.cppreference.com/w/cpp/language/constraints) page shows an example with `is_base_of`, which requires 2 arguments. I haven't see what the syntax would be for the short version in this case. For the function T-&gt;U, I think a syntax like this should work: template&lt;typename T, typename F, typename U&gt; requires Converter&lt;F,T,U&gt; Where you'd define `Converter&lt;F,T,U&gt;` template &lt;typename T, typename F, typename U&gt; concept Converter&lt;F,T,U&gt; = std::is_invocable_r&lt;U,F,T&gt;::value; //check if when you invoke F with T as args it returns U. In the end I just changed the order or the arguments, I like putting the function type first and the return last in this case because it makes more sense to me at least.
You must be fun at parties. The only reason I decided to ask here, was because I can use google, but can't make an informed decision myself, since I am not informed. Other people can provide their insights on this matter. &amp;#x200B; I am sure, you can say "google" for almost every question that's asked in the subreddit. Doesn't this make this subreddit useless then? Since instead of asking everyone can google it :). Also this will be indexed by google, so others can also take advantage of this. There's no VS Equivalent solutions post (anywhere modern atleast) at google in the first few result pages :) &amp;#x200B;
read some text, match it against a pattern and turn it into a tree of types. That's as simple as i can explain it.
For GPU stuff, [RenderDoc](https://renderdoc.org/) is really good.
there was a talk about this at cpp 2018: https://youtu.be/V1t6faOKjuQ?t=641 tldr: gdb
&gt;AFAIK the closest you'll get is CLion or Eclipse CDT, which both have integrated profiling. CLion sadly doesn't seem to have a profiler "yet." I believe it's coming the next release though. **Few questions:** 1.) Most devs don't use IDEs in the Linux world &gt; I heard alot of people here use terminal editors, but is it truly customizable to the extent of an IDE? Like seeing documentation inside the terminal editors, and cool stuff like CLion's space+enter clang fix-it integrations. &amp;#x200B; 2.) In case it is, is it possible to integrate those standalone tools (the non cli ) one's with editors? I think emacs has a gui, and so do stuff like atom. Has there been any good person who wrote a good guide on how to integrate it all in together, because it's just so much more comfortable to have it all in your own custom built environment, and add the new stuff in, when it come's out :) &amp;#x200B; Thanks for taking your time to answer my question.
Thank you for sharing that video with me. I will give it a careful watch :)
That looks impressive. Thanks for sharing :)
What shape is it now? 
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9q9gjo/panorama_to_rectangular_image/e87phot/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
@22:49 "The value computations (but not the side effects) of an operator are sequenced before the value computations (but not the side effects) of its operands. \[intro.execution\] p10 s2" I think this one is the wrong way around, instead I believe the operands have to be computed before the operator can do its job on their values. [http://eel.is/c++draft/intro.execution#10](http://eel.is/c++draft/intro.execution#10) seems to agree: "The value computations of the operands of an operator are sequenced before the value computation of the result of the operator." Or am I misunderstanding what's in the slide?
non regular shape
Your argument `/std=c++17` is not understood by msvc (on the version hosted by compiler explorer). Are you sure this is how you activate C++17 with msvc?
I’m by no means an expert, but I’ve been using CLion to work on a side project and have found the experience reasonable for the majority of the daily work. The learning curve from VS to CLion isn’t as steep to other options.
Ah thank you. I switched it, and now it compiles with MSVC. https://gcc.godbolt.org/z/QagY7O Thanks! Looks like MSVC compile correctly as well, and is free.
I myself unfortunately cannot answer those questions, as I do not use terminal editors. I use VS code as my editor, which I configure with very popular plugins for clang static analysis of the code, and gitlens for better git integration. With this setup, I have symbol loopup and autocomplete for everything in the project, as well as on the fly error checking. Then, I just alt+tab and run the make command in a terminal windows, and run it in another.
And what happens when you want to target a different CPU, or a different ABI, or support both 32 bit and 64 bit builds ? Do you enjoy writing (and testing) lots of different variations of the same code ?
And what happens when you want to target a different CPU, or a different ABI, or support both 32 bit and 64 bit builds ? Do you enjoy writing (and testing) lots of different variations of the same code ?
AFAIK ptrace just exposes the raw syscall, without wrapping it into an API.
A unique_ptr with a custom deleter is not the right thing for my use case. I'm not just wrapping one object, its usually to handle some cleanup function at the end. There isn't always data associated, so a unique_ptr wouldn't be the right thing anyway.
Cool! I didn't think a make function would forward correctly, but turns out it does. That's cool. Would definitely be nice to have something in the standard for doing this though. Especially in 17 and above where the template inference makes it much cleaner.
/r/cpp_questions 
This is called a discussion, you should use Google and find out the meaning of
C++14 brings with it mandatory named-return-value-optimization, and also normal return-value-optimization. Most (all?) C++11 compilers implement it.
For debugging I use the GDB frontend built into QtCreator. Pretty much all of the tools have gdb frontends, so this should be similar no matter what tool you pick. For tracking memory usage you want to look at either heaptrack or massif (part of valgrind.) For profiling runtime performance your options are valgrind, gprof, or perf. I like valgrind with KCachegrind to view the results or hotspot as a frontend to perf. Valgrind also provides the memcheck module that helps find memory usage errors. Idon't know what all visual studio provides, but I haven't found my setup lacking anything in particular.
Or use MSVC?
I've noticed that Clang vectorizes much more often than gcc or msvc
I use QtCreator on Linux, which seems like a pretty comprehensive IDE to me, although I've never used VS. QtCreator has integrated debugging and profiling.
Since the result is something that can be used at compile time in C++, why not do the string preprocessing in a scripting language (it easy to invoke anything during a build); why effectively invent a custom DSL for that? Custom DSL = more to learn, more that can break, avalanches of ungood C++ diagnostics noise, limited, etc. Just my 2c. ;-) 
Looks related to the scope-guards proposal P0052 But I'm not sure if this proposal already leverages the template argument deduction facilities of C++17 
Usually I see this wrapped up in a defer macro, mimicing the syntax of other languages. A sample implementation would be #include &lt;utility&gt; template &lt;typename F&gt; struct Defer { Defer( F f ) : f( f ) {} ~Defer( ) { f( ); } F f; }; template &lt;typename F&gt; Defer&lt;F&gt; makeDefer( F f ) { return Defer&lt;F&gt;( f ); }; #define __defer( line ) defer_ ## line #define _defer( line ) __defer( line ) struct defer_dummy { }; template&lt;typename F&gt; Defer&lt;F&gt; operator+( defer_dummy, F&amp;&amp; f ) { return makeDefer&lt;F&gt;( std::forward&lt;F&gt;( f ) ); } #define defer auto _defer( __LINE__ ) = defer_dummy( ) + [ &amp; ]( ) //example usage- defer {fclose(file); }; Taken from https://handmade.network/forums/t/1273-post_your_c_c++_macro_tricks/3 With std::uncaught_exceptions I think you can now implement D's scopeguards. Check out https://tour.dlang.org/tour/en/gems/scope-guards The gist of it being that you have special version that execute if an exception is thrown or no exceptions have been thrown, which can greatly simplify exception handling cleanup, if that's a concern.
Std::function&lt;void()&gt;; Will work even in c++11
QtCreator has good valgrind/callgrind integration.
ISPC answers those questions trivially.
std::function isn't free though. It allocates space for the function.
Do you have any completion setup in emacs ?
std function should have a small function optimization where the function object is stored inside the std function if it's small enough. You'd still need the compiler to devirtualise the std function internals though, because std function performs internal type erasure.
I thought Vs code is available on Linux. Worth take a look.
gcc does not even enable vectorization until -O3. And then again it's a matter of luck. With OpenMP SIMD you can portably express that you expect this to be vectorized and depending on the compiler also get a warning if it couldn't. Furthermore it's a portable way to tell the compiler to ignore its own cost analysis and inform it of data alignment and aliasing.
**Company:** [Eppendorf Instrumente GmbH](https://www.eppendorf.com/EN-en/) **Type:** internship/working student **Description:** Eppendorf is a leading life science company that develops instruments for liquid-, sample-, and cell handling in laboratories worldwide. We are looking for interns to join our software developer team for embedded devices. Your mandatory skills should be: * a good knowledge of C++ and Python * fluency in German or English * combinatory and analytical capabilities **Location:** Hamburg, Germany **Remote:** no **Visa Sponsorship:** no **Technologies:** C++11 - C++17, Python, Embedded Systems (Cortex-M, FreeRTOS, OpenEmbedded), Linux and Windows **Contact:** Please e-mail Toni Neubert, [neubertt@eppendorf.de](mailto:neubertt@eppendorf.de) for any questions.
Hi, First few chapters speak about the modern C++ constructs that helps programmer to write declarative style C++(Modern C++!). It covers a lot of functional and reactive stuff in the last few chapters of the book. The book has good coverage about the standard Threading library and a dedicated chapter discusses how to use RxCpp with QT framework. I think its a good package!.
Nope. Because the T is templated, the compiler can completely remove any storage required for the lambda and inline the entire thing.
Don't expect to find an all in one solution in linux like VS. Instead, the whole linux ecosystem can be viewed as one giant IDE. you have amazing editors like vim and emcas and you also have amazing tools like valgrind, strace and such. it might look intimidating at first but you will get used to it and understand why things are the way they are. &amp;#x200B; However, if you need the closest thing to the VS, VSCode has a pretty decent c++ extension too. It will give you a decent enough syntax highlighter, an intellisense-like auto complete, and a basic gdb integration. there are other nifty extensions that you can add to it as well. such as cquery for huge codebases.
Performance gained by this feature should equally be gained by getting a pointer to the std::vector data and using them directly in a tight loop. So there is no real reason for this to exist.
I would add 'strace' to toolbox. It shows you what sys calls are made from given application.
Why would you need to do that for performance? high level typesafe features are not needed in high level programs, and low level programs use enough C that this kind of construct is redundant anyway. 
&gt;chryswoods.com/vector... That's true, but gcc does do better optimizations in other part of the code... :( 
With ISPC you kind of need to rewrite your algorithms from scratch, no? It seems closer to rewriting in CUDA than to just updating your old code, including the need for an additional compiler and a different language (C with language extensions vs C++). I am sure ISPC will give you better performance (particularly for more complicated code) at the cost of more development time, which is a fair trade-off for many applications. OMP SIMD is just a lot less effort to use, and for things like a simple dot product ([godbolt](https://godbolt.org/z/7utKov)) it produces much faster code than the auto-vectorization. On my machine, it's more than 10x for clang 6 with -O3. &amp;#x200B;
There was a proposal in 2014 ([N3949](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3949.pdf)) to add `scope_guard` and `unique_resource` to the standard. But I don't see any developments since then.
On the tools front: * For runtime correctness I use GCC/clang sanitizers (ASan, UBSan in particular) and Valgrind (only for projects where I don't have most of the source). On occasion I'll use `clang-analyze` for proper static analysis, and `clang-tidy` and `cppcheck` for more lightweight analysis. * For performance I tend to use plain `perf`. It can be a little low level and unwieldly at times but it gets the job done with minimal overhead. * For graphics I use `api-trace` and `RenderDoc` depending on the situation. It's worth knowing a minimal amount of GDB, as it's everywhere and at some point you'll inevitably have to drop into it. I've settled on CLion as an IDE for the time being because it's about the only system I found that required minimal setup, could actually navigate symbols across my codebase, and didn't trigger crashes in GDB. Things may have changed in the last couple of years though.
&gt; mandatory named-return-value-optimization It does?
In C++ it is usual to have each resource being handled separately and have its own handling and clean-up if needed. I'm still not sure in which cases you need a global clean-up that has no ressource linked to it. Isn't it some strange hidden codes?
Restoring LEAN_AND_MEAN isn't necessary. windows.h is include guarded and can't be meaningfully included a second time without dirt hacks anyway. Imo the user of the library has to deal with this situation.
Let me rephrase my point. I think the question is, whether there can be a negative impact from using OpenMP's SIMD capabilities? If the answer is no, then the obvious follow-up question is: why does the user have to add the annotations by hand and why wouldn't the compiler (in tandem with OpenMP, perhaps) just add the same annotations to every function and loop, automatically? You are correct in that part that ISPC requires one to rewrite the algorithms in a C-like language, but then again, it can be argued that OpenMP's extensions to C/C++ are also an alien area that needs to be grasped before utilizing the SIMD capabilities. ISPC makes vectorization very explicit and transparent, which I think is helpful, as one does not need to guess whether parts of the code were vectorized or not. 
Ok, I sent in my CV as I'm looking to go long term somewhere from January onwards.
just added a "readme", please check out
Oh! I'd misunderstood, I had it in my mind that you'd made your own `is_nothrow_copy_constructible`. That *is* a really unfortunate issue.
&gt; Well until I graduate, atleast. I think I'd prefer never having it than having to do without it... :P But then again I may be overestimating its usefulness for me. I'm still waiting for _the_ visualization tool.
i guess it comes down to personal preference.
IMHO SafeDeleter isn‘t a good name. There is nothing that makes it *safe* and it doesn’t delete.
For pre c++11, there is a book called modern c++ design. This is a nice introduction to template meta programming. &amp;#x200B; For C++11,14 and 17, try to search for * CRTP, std::enable\_if, constexpr * In cppcon 2018, there are two videos , Modern C++ Design * Videos related to range &amp;#x200B;
I have not watched the video yet but I have been dribbling around to find something for my taste. I cam e across conan and it worked fine for installing boost and a few other libraries. I went to install opengl and it wasn't available in the repo centre so I ended up using the OS's apt-get system. CMakeLists seems a lot more complicated to learn. Can somebody shed some light on this?
I may be misunderstanding something, but I thought you had to pass flags to gcc (For example `-march=native`) to allow it to create vectorised instructions? Else it has to generate code which could run on any CPU and wouldn't be able to take advantage of e.g. AVX intrinsics. I didn't read the whole tutorial but I didn't see any mention of this so thought I would ask to be sure. See the difference the assembly here: https://godbolt.org/z/_AJjEU
No, this doesn't work. In order to use `Converter`, you need to know `U` up front. But the point is - you don't know `U`. You need to determine it somehow. And Concepts can only give yes/no answers (`is_base_of` has a yes/no answer), they can't give you that type. They can only check if the type is correct.
[removed]
CMake isn't complicated, just a bit annoying. It's a stringly-typed language which means that the code gets ugly fast. I've also tried conan with cmake and it didn't work as well as you would hope. However, you should be fine using it for projects with few/popular dependencies. I've recently moved a few of my projects to Meson. It's a newer project with a smaller user-base and so-so documentation. But it has a saner type system, integrates well with the existing `pkg-config` system, and I feel it's easier to use. Also, OpenGL isn't a thing that you install on any operating system. The `GL/gl.h` that you include is for legacy OpenGL. Both Qt and Gtk have bindings for modern OpenGLs. If you want to use something lightweight (like SDL), you can try generators like [GLBinding](https://github.com/cginternals/glbinding) or [GLAD](https://github.com/Dav1dde/glad).
And 'ltrace' to track library calls
Why do C++ programmers always assume that all of reality could change at any point and what has been true for well over 30+ years will just suddenly stop being so to prove a point? *"It's not a matter of what the platform or compiler defines, its what the language decides. What might be true at the moment could change at any point in time, if you want to be safe from UB then you shouldn't be reinterpret casting to it. If your going to stick with this UB then you should static_assert they are the same"* *"Your doing a memcpy from std::array of hash_type&lt;N&gt;::type where the type differs betweeen destination and source. While you could make these assumptions now, the language does not define they must be the same. (e.g. endianess could impact this)."* *"I don't really care about portability with platforms exotic enough to not have intX_t types defined, which are very unlikely to have an AES hardware acceleration this algorithm depends on anyway."* *"I suggest reading The byte order fallacy"* Except that doesn't even matter. It literally doesn't matter. This algorithm is not portable *by definition.* Have you somehow managed to miss like two dozen lines of **x86_64 Vector Unit Extension Builtins** to make a point about abstract and irrelevant endian correctness? If I go ahead and explicitly say that this is a little-endian, heck, x86_64 only library will that please your internal language lawyer? *"High performance code? And heavily degrade performance? Unless you have tested it and proven this then it's not true."* Fine. I tested it. Couldn't find a consistent improvement. ***Happy now?*** 
Is Google test the most popular testing framework currently? What should one start a new project with (assuming no familiarity) 
How does ISPC help with making assembly code more portable ?
Visual studio is awful, btw.
Kdevelop is greaaaaat.
IDEs in general, the best ones are KDevelop, Eclipse CDT, plain Netbeans and Oracle Studio (Netbeans customized for Solaris/Linux development). Now if you cannot live without R#++, then there is only CLion. 
QtCreator has worked fine for me for years. You could always write your own if you're unhappy.
I've found NetBeans with the C/C++ plugin to be a decent experience. Prior to that I used CodeBlocks which was alright as well.
Suppose you rotate the coordinates of a scene in order to work with it. You want to ensure you un-rotate at the end of the function. While you have mutated the scene, the scene isn't really the "resource" owned. Instead, you have modified global or otherwise non-local state in a way that you want to invert at the end of the local scope. 
True - if it’s one-off or throw-away code then it probably doesn’t matter. Also if you’re not trying to squeeze out the last 10% of CPU performance then you probably don’t have to worry too much about optimal instruction scheduling etc.
Thanks, I will take a look on them Yea, I'm R# addict, but CLion seems to lack some R# features Also its UI and color schemes out of box makes me cry blood
It helps making SIMD code portable. You can compile code for multiple archs/instruction sets and the runtime will pick the best supported one.
Can you explain?
Andrei Alexandrescu covered such concepts some time ago: [CppCon 2015: Andrei Alexandrescu “Declarative Control Flow"](https://www.youtube.com/watch?v=WjTrfoiB0MQ) Worth a look.
Sure, but the comment was in response to the suggestion that writing assembler was somehow easier than using intrinsics for SIMD - I don’t see how ISPC is relevant to this ? 
You can potentially use my lib here to do that ([https://github.com/cbeck88/visit\_struct](https://github.com/cbeck88/visit_struct)) I have code in a game engine that converts structs to lua tables and back and validates them against the layout when parsing them back, and that works great. I haven't written the json version of it yet. We use this at my old job also for converting a bunch of structs to the hdf5 data format. The main advantage of doing it this way is that you don't require a script / extra steps in build system for codegen.
You can get IDE features in Visual Studio Code with the C/C++ extension: https://www.youtube.com/watch?v=rFdJ68WbkdQ
I’d recommend Catch! I switched from GTest because of Catch’s simpler syntax and loved it. They do the same thing, though, so don’t be afraid to just try one. I would say Catch was easier to integrate in my project and has a nice unified assert statement that works for everything. 
Perhaps I can. I have 3 different Visual Studios at work, while at home I'm happy with shell, vim, gdb, and gprof. The only feature I miss at home is TFS Annotate (git blame analog) tied to the TFS work items. This is indeed quite convenient. Otherwise, the feature-list is pretty even. It's not that I came home and wish I had a VS here. It's fine, but I don't want it that much. However, every time I come back to the office after holidays or even a long weekend I get frustrated by how sluggish and unreliable everything is with VS. It's that magic feeling when you start writing and you're not sure if it lags, or it will crash eventually, or you should just type harder, because nothing comes out. You can get used to it with time, but it's more of a Stockholm syndrome than an appreciation. Sometimes it gets completely catatonic but I'm not ready to kill the process because it parses something, or loads something, or "is busy" for some other reason, and I'm hoping for it to get better. When this happens, I run vim to get things done, and this kind of makes things bearable. But I tend to believe, IDE should be bearable without vim to be called a decent IDE. So it's not VS per se that is awful, it's rather VS for large solutions. 
&gt; So it's not VS per se that is awful, it's rather VS for large solutions. VS wasn't made for massive solutions, [SourceInsight](https://www.sourceinsight.com/) was however.
Yeah that's my problem. Had to skim over a 2 hours talk (Brown's) and the only takeaway is void_t. And other talks often just showcase their cool new project from a user's pov without really explaining how it's implemented. Would be nice to watch a more condensed talk focusing on generally applicable, advanced techniques and leveraging the new language features like generic lambdas, fold expressions, variable templates or whatever to make template code more elegant.
Is supposed to be used as a replacement for CMake, or does it aim to be a dependency management system akin to Maven for C++? 
codeblocks 
If this is through dreamspark, it's a regular product code and stays valid after graduation. You just don't keep getting access to new products after you graduate, obviously. (Or at least that's how it was when I was in school)
KDevelop's symbol tagging seems to be pretty awful to me. I swear that it frequently only tags the files I currently have open. Is there some setting I'm missing to get it to actual tag files properly?
Since nobody mentioned, take a look at clion. https://www.jetbrains.com/clion/
What exactly are you finding wrong with QtCreator? I have been using it for years with no problem. KDevelop is also pretty nice, but I'm not a huge fan of how the UI.
Perhaps I'm mistaken? I implemented my own version of ScopeGuard, and did some research on it at the time, and my memory tells me that those two optimizations were mandatory. That doesn't mean that my memory is working properly, I could be wrong.
Use CLion every day. If your project is based on CMake, this is the IDE to use.
[Cquery](https://github.com/cquery-project/cquery) provides even better code completion and stuff like semantic highlighting. It takes a little while to set up though.
I even prefer it on windows when msvc is an option. It is just reliable and has good integration with normal dev tools without some unneeded shit into my project.
And, most importantly to me, Find All References!
Seconded. I've tried every option i can find, and QtCreator has caused me the least grief with daily use. Paired with CMake.
Kdevelop and QtCreator feel and act very similar to me. 
I use it even without CMake. When it's someones external project, just open the folder, add a simple stub CMakefile and browse and edit the code anyway.
Text editor; not an IDE.
I use QtCreator with CMake and GCC/Clang. CMake provides the ability to do some static analysis as part of your process -- im not saying use all these at once but there are various options to help your keep your code neat: + gcc with `-Wall` + https://cmake.org/cmake/help/v3.13/variable/CMAKE_LANG_CLANG_TIDY.html + https://cmake.org/cmake/help/v3.13/prop_tgt/LANG_CPPCHECK.html + https://cmake.org/cmake/help/v3.13/prop_tgt/LANG_INCLUDE_WHAT_YOU_USE.html + https://cmake.org/cmake/help/v3.13/prop_tgt/LINK_WHAT_YOU_USE.html These actually work with any IDE that supports CMake. Plus QtCreator does some clang-based analysis on it's own. I'm not a fan of IDE-generated code other than completing braces etc, so i can't help much there. 
Kdevelop has everything but good profilers as I use it. Installed QtCreator now. How do I tell it what command and inputs it should valgrind? I need a simple to use profiler. For now, the easiest I have seen is Xcode, but I cannot run it for I don’t wanna buy a Mac. I have no good profiler therefore...
"C++ Templates: The Complete Guide (2nd edition)" is a great book. It's not quick, but it's well-written and relatively easy to digest. It has useful examples and usages of many of the things you'll learn, and covers C++11, 14, 17, and briefly addresses future directions and upcoming expansions to the language. It's definitely worth getting a copy of if you want to go deep into TMP!
Clion or vsCode 
CMake isn't terrible, don't get me wrong, especially when someone else has done the hard work for you. Meson is just better imo. With, CMake, `find_package` requires that you have a `Find&lt;module&gt;.cmake` file somewhere, and you sometimes have to write it yourself. Existing modules aren't consistent on the variable names. Is it `OPENGL_LIBRARY`, `OPENGL_LIBRARIES`, `OpenGL_LIBS`, etc. Variable name typos are silently accepted as empty string, so `target_link_libraries(... ${OPNEGL_LIBRARY})` will not be found until you get a linker error. In meson, something like `executable(..., dependencies: [opnegl_dep])` will give you an error at the beginning. Linking whole archives isn't possible in cmake unless you write out the linker arguments, which isn't portable. With meson it's `executable(..., link_whole: some_lib)`. In meson, if you use the `library` function (instead of `shared_library` and `static_library`), you'll be able to let the user decide how they want to compile with the `--default-library=` option. Checking if the target OS is Linux requires you to `UNIX AND NOT APPLE` (according to stackoverflow at least), which is also true for other Unices. In meson it's `target_machine.system() == 'linux'`. Installing executables is also easier on meson, with `library(..., install: true)`, which will do the right thing. --- There are more things I could list, but I digress. Meson has a better foundation, which should hopefully mean that it's not going to become a shitshow in 10 years, although anything can happen. Now obviously there's no reason to migrate a perfectly working CMake project, or even a not-so-perfectly working one. For new projects it might be an interesting idea, especially if it's open-source where you need to support multiple OSs and have a complicated build system. The major caveat is that there is virtually no editor support for meson at the moment.
I also go with catch2. Very simple very effective. 
Whish it had clang-format integration like Qt Creator :(
Regarding P0600R1, I seriously hope operator new will not be made [[nodiscard]]. There's plenty of stuff that gets new-ed into existence, and then registers itself with some service provider for tracking and eventual deletion. Regarding P1260, the examples on page 3 conflict: the first example features fallthrough in the switch, implying the inspect version also features fallthrough, but the second example does not feature fallthrough. Surely inspect is not going to have fallthrough again?
I'm disappointed that nobody has replied with a complex template setup that, when compiled, would evaluate to a reply.
No package manager. v_v
&gt; There's plenty of stuff that gets new-ed into existence, and then registers itself with some service provider for tracking and eventual deletion. That sounds like a staggering code smell.
Not really. It has built-in support for compiling and debugging, and you can pretty easily set up code completion and static analysis with plugins. It has a difficult learning curve and it's definitely not for everybody, but it's just plain wrong to think it's just a text editor.
I've recently come to enjoy gdb + tmux + [voltron](https://github.com/snare/voltron) for debugging with this workflow as well.
I would highly recommend Atom. Its one of the best modern editors out there, you can install variety of packages and use it as an IDE.
If you’re doing something unusual, inserting a void cast is an entirely reasonable request, so that the warning can continue to benefit the majority of code that isn’t being weird.
Looking at you QT...
How does perf fare in contrast to other profilers ? Perf certainly is the one that looks most recommended on various subreddits posts I searched, but in terms of features how does it fare to stuff such as gprof? Thanks for taking the time to reply.
No knock against Meson intended. I'm not very familar with it beyond hearing about it in passing, but I would like to check it out sometime. From your examples above, it seems pretty similar to CMake, or at least easy to pick up if you are familiar with CMake. Is that the case in your experience? Probably the reason I'm so 'smitten' with CMake is that our scons build before took almost a full minute to do a build with no changes. It was terrible. Also I haven't had to delve into `find_package` craziness because we have a monolithic repo and check in our 3rd party dependencies, which comes with its own set of problems of course. Thanks for sharing your thoughts.
This is very impressive. How did I never know of this. Would have saved me much time on my last few projects 😢 Thanks for taking the time to share. This is amazing. 
Thanks so much for sharing that :)
Makes sense - thanks!
Good to see that the 2D graphics proposal is alive.
Have you tried asking for help in the wrong place and without explaining your problem at all?
I used to use boost-test, but also switched to Catch. I've also used google-test but I didn't really like it and it was unnecessarily complicated to set up. (At some point you couldn't even just install it and link to it, because google apparently doesn't like proper package-management as seen on Linux.)
I doubt you are going to get much good feedback since you haven't stated any of your requirements that you are looking for. What is a VS+R#? what do you like about it? Is feeling like notepad bad or good? why? Ugly is in the eye of the beholder, what are you looking for? What are you using this IDE for? What IDE features do you value? Have you tried googling? Why are you asking here? &amp;#x200B;
In Qt code it is still pretty uncommon to construct an object and then not interact with it in some way.
Note that as per a separate proposal you can `auto __ = new Some(thing);`
they have, but reddit's servers are still compiling the response
* Don't redefine NULL -- include the appropriate header to guarnatee it exists. * Don't use NULL at all. Use nullptr. * Your list currently has an implicit requirement that "T foo = 0" is valid. There is no reason for this. * Write some tests and check them in next to your class. There are a lot of bugs here to shake out.
Thanks! I'll look over my code tommorrow.
At around 53:00 in the video /u/berium demonstrates adding the GPG fingerprint of the remote repository into a project manifest file, and points out that if you skip doing this they you will be prompted to manually authenticate the repository every time it rebuilds. Is this what you were after?
Ok, my reply mostly addressed the tedious maintaining part for different platforms.
Why? The resources are being tracked correctly, so what is bad about it? 
Couldn't this be implemented more easily with Range V3? Something like `zip( ints, source )`
No, it's a make-based project. I don't want it to have any knowledge of the build system at all, because it's impossible. All I want is something that will parse the code without requiring that it get its hooks into the build system. I realize that means that it can't figure out certain things, but I'm willing to live with that.
QtCreator, hands down. I'm not sure what you're finding in terms of deficiencies but I've never needed anything it or the "Unix-as-an-IDE" philosophy couldn't provide. Behind that is KDevelop, but it's code analyzer can take quite a while to run through a project. Eclipse CDT is okay, then VsCode is... okayish as an IDE. And, of course, vim or emacs are their own category.
Indeed, thank you! The new number is P0052 and the latest version seems to be [P0052r9](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0052r9.pdf) from 3 Oct 2018.
I love semantic highlighting. And the fact that it works with a lot of editors is awesome too.
Note that P0600R1 is referring to `::operator new()`, not new expressions. Cases where ignoring *that* return result is correct are far more obscure than the new expression case.
You seem to be mistaken about a number of things regarding copy elision. https://en.cppreference.com/w/cpp/language/copy_elision 
Greg Law has also a lighting talk on GDB to get you started: https://www.youtube.com/watch?v=PorfLSr3DDI * Time travel debugging * Python integration * breakpoints, watchpoits (breakpoints on variable state change) , catchpoints (breakpoints on syscalls/other events)
Catch2 is very easy to get started with. The only problem I faced was with testing assertions. I like to test that my assertions are being triggered correctly, and Catch2 cannot test those due to lack of death tests. However, with contracts coming in C++20, this will not be a problem for much longer.
You can also click import and it generates one, works extremely well by default
It was mentioned by OP: &gt;CLion is UGLY and buggy. Any other options?
Like he mentioned in the talk, one of the missing features is death tests. If you need such a thing, catch2 wouldn’t be an option. Death tests aren’t the most common but definitely have their use cases. Other than that it seems pretty good to me, but I don’t know that it beats google test in functionality, just in syntax and convenience. Unless you need death tests, I’d say it’s personal preference and you should POC both and pick the one you like better.
I implemented support for regex iterator/ranges in CTRE library and modified FReD (compile time regex in D) benchmark examples. Results are: on 1GB file (created with repeating of their example file multiple times) (\[a-zA-Z\]\[a-zA-Z0-9\]\*)://(\[\^ /\]+)(/\[\^ \]\*)? D: 18.491 sec CTRE: **6.189 sec** (\[0-9\]\[0-9\]?)/(\[0-9\]\[0-9\]?)/(\[0-9\]\[0-9\](\[0-9\]\[0-9\])?) D: **0.7944 sec** CTRE: 0.776 sec I also check the matched outputs are identical between D and CTRE benchmark.
My bad. 
http://doc.qt.io/qtcreator/creator-valgrind-overview.html
That the article do not list them does not mean there is no paper about package management. The article simply list some interest of the author. There is 276 papers this time. And the article refers to more than 5. &amp;#x200B; Here is the list of papers related to package management (which you can find by simply searching in the list for papers addressed to SG15). The first one is about an API to drive package handling whatever the tool you use: \- Package Ecosystem Plan : [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1177r0.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1177r0.pdf) \- [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1178r0.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1178r0.html) \- C++ Compile : [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1204r0.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1204r0.html) \- Canonical Project Structure : [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1204r0.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1204r0.html) \- Notes on C++ Package Management : [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1254r0.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1254r0.html) \- Let's Talk About Package Specification : [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1313r0.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1313r0.html) &amp;#x200B; There are other papers indirectly related to the subject (mainly related to where to find modules) but these are the most obvious ones. This is not curated, I'm still reading the paper dump. &amp;#x200B;
I believe `view::ints` was deprecated. Not sure what replaced it in the case where you don't know how many times it should iterate for.
C++14 indeed guarantees NRVO in certain cases: https://en.cppreference.com/w/cpp/language/copy_elision
Interesting. Good work!
\+1. as someone who works on large codebases (+5M LOC), cquery is the only option.
You can always define template&lt; class Some_type &gt; using type_ = Some_type; Then write e.g. type_&lt;int*&gt; a, b; Or define your own type builders like template&lt; class Type &gt; ptr_ = Type*; and then write ptr_&lt;int&gt; a, b; There is no need for new syntax to do this. I think a good reason to do it is that it supports prefix `const` and makes otherwise complex declarations much more clear and simple. One drawback is that it's verbose. Another drawback is that it supports declaring two or more variables in the same statement, as above. 
&gt; There is 276 papers this time. And the article refers to more than 5. \*jaw drops\*
it's not really an issue because the compiler will either warn you or raise an error if you mistype. furthermore, C++ versions stay backwards compatible as much as possible so you won't have any luck depreciating the current syntax. ---- btw this was a C feature. I'm guessing C programmers wanted it bc they had to declare all their variables at the top of their functions and if you had a lot of ints it was probably convenient to write it in one line. and it's a GOOD thing that C++ can compile most C. makes it easier to use C libraries
It doesn't look better from my perspective... It actually looks worse... Use a typedef and problem solved... Or you can: ```cpp int *a; int *b; ``` Also why is that so important? It's just a matter of style...
An example of the kind of documentation the tool can produce is here: http://stlab.cc/libraries/stlab2Fcopy_on_write.hpp/copy_on_write3CT3E/
I just changed my job and took part the same debate. int\* a or int \*a? So I remembered this idea as that time I had the same debate. 
This question is a little bit religious among developers. At least this is my experiment with it. Now half of our dependencies is in int\* a and other half is in int \*a. It is just annoying the same debate over and over again ...
A better one for this is `indices`.
So do you think this type of variable declaration is the way to go? You want to pollute this every class definition and every variable declaration, or in every parameter declaration? I think we need a dedicated syntax for it.
Because you're not explicit about it - anyone who has to read it will have to go through the implementation to see it.
So do you think this type of variable declaration is the way to go? Do you want to pollute this type\_ in every class definition and in every variable declaration, or in every parameter declaration? I think we need a dedicated syntax for it. And one more problem with that it doesn't prevent misuse: `type_&lt;int*&gt; a, *b;`
Shockingly, I have been pleased with VSCode.
Not the asterisk location, but the hidden rules that comes with that innocent decision. And the usual debate among team members. I just fed up with those silly debates. And there is no good solution today. int* a, b, c; // doesn't work like that but // this is ok, but really? int* a; int* b; int* c; &amp;#x200B;
Re: P1260, that's a bug in the `switch` example: https://github.com/mpark/wg21/issues/1 😐 Will be fixed in R1.
Just don't declare more than one variable (or thing) in a single statement. The word “pollute” is pretty loaded and subjective. Apparently you think of normal templates as pollution, and `:=` or whatever symbols you propose, as clean. With me it's opposite, I can't fathom why? 
I would definitely recommend having a look at meson. I found it a lot easier to pick up than CMake. That may be, because I already had experience with CMake, because meson didn't change that much yet, so you don't get as many tutorials doing the wrong things or it may just he the cleaner syntax. I'd bet that one hour would be enough to cover how to write simple meson build files. After that are only specific edge cases, that may need more reading on how to handle them. Meson is also blazingly fast. I haven't measured it, but meson seems to be faster than CMake or autotools and it feels, like I don't have to regenerate my build files that often. It also defaults to ninja, which is nice. Give it a try. It feels really nice.
Well U is a template parameter here, is there no way to have a deduction guide to make it work? I guess i didn't understand what the intent was exactly. 
I think the one line rule in this case is part of the problem. We shouldn't allow to alter the type after you specified it in a variable declaration. I think we need a common syntax for declaring variable in class/struct and in compound statements. On the other hand a dedicated **var** keyword would be a better syntax for me but you know it comes with a price. My problem is the duality. You have two half solution as I described earlier.
Did you read the post?
Your comment was auto-removed by the spam filter, presumably because it's a google search for a urldefense link to a wg21 link. Please try to avoid this in the future. (Reddit is fine with the wg21 redirector by itself.)
!removehelp
Another vote for CLion. Seriously. If you're a student, the bug-free release versions are free. (Not Early Access Program or EAP) 
Do you have an example of what the output looks like?
It says you want to have a concept for T-&gt;U, and the concept I wrote works for that. Obviously you need to know U. It makes no sense to ask the concept to return a type, that's not what concepts are for. And you can have U default to something if you don't want to type it yourself (as the website shows), so what's the problem?
Isn't the meeting just 5 days? How are they going to go through 55 papers per day?
Catch is very simple to use. I'm sure I don't use all its capabilities, but I'm quite happy with it.
so from what i understand you want to have a device that you connect to a PC and it will play the game automatically? Why tho? you can achieve your goal much easier with software. check out tools like Auto hotkey , etc. &amp;#x200B; If you insist on doing EXACTLY what you describe, i should warn you that it's not going to be an easy feat. Heres how i would do it in a nutshell: 1- a cheap camera to capture the PC screen + raspberry PI for some simple pattern recognition with openCV. 2- an arduino/teensy to act as the keyboard simulator. because last time i checked the rPI wasnt capable of doing so on it's own. &amp;#x200B; Your question is not c++ related and you will have a better luck searching for more info in hardware related subreddits.
Paper pc137 covers paper perusal mechanisms.
Is the typo in the discussion of text formatting some kind of joke going over my head? &gt; Easy and pwerfull text formatting support:
"*Sometimes a cigar is just a cigar." - Sigmund Freud*
Multitasking. Seriously. There are several rooms. And not all papers are 20 pages long.
In Linux land it's sometimes seen to create a DBus adapter using a Qt adaptor class. The standard way to do this is just `new` it and off it goes (though it would be easy enough to use a void cast).
Do you have a setup that allows code completion as well as jump to declaration/definition? Is it aware of object lifetime and able to find variable usages? Can it do all that by using the actual rules of the language (e.g. not relying on mere text search). Is it aware of "projects" and able to provide information from different compilation units, and files you've not necessarily opened during the current session? I'd love to jump to a pure CLI solution, to make remote development easier, but last time I looked I didn't find anything that actually hit all those points (usually it was missing several of them). Granted I was exclusively looking at vim plugins, so if emacs has more comprehensive options I'd be ecstatic (though I'd still have to enable evil mode!)
I was wondering the same thing!
&gt; [Compiling For The NVIDIA Kepler GPU](https://ispc.github.io/ispc.html#compiling-for-the-nvidia-kepler-gpu) When was this written, last millenium?
YMMV, of course, but my experience has been that when pushing performance on multiple tiers of x86/x64 SSEx ISAs that rewriting is necessary anyway. With SSSE3 you have the infinitely abusable PSHUFB, and with AVX there is the problem that weird in-lane nature of the 256-bit ops means that the 128-bit algorithm can't be straightforwardly translated. The compiler doesn't do a _bad_ job with intrinsics, and it's generally better than what you'd get from autovectorization or not using them. I've still seen too many cases where using compiler intrinsics leaves performance on the table over asm, especially in specific hot loops where there is a high payoff for optimization effort. The Intel intrinsics design is also kind of yucky, with weird naming conventions and the wrong pointers on some load/store ops requiring casts. Even in the case when generated code from intrinsics is fine, the assembly is sometimes more readable to me than the intrinsics code. But then again, I spent a lot of time writing and reading MMX and SSE2 code when the compilers were so bad that it was hard not to beat them with asm. 
Minor correction: that's not a GPG but an x509 certificate signature (sha256 one to be absolutely precise). In fact, I've already mentioned to /u/F-J-W on another occasion that in `build2` packages are signed and repositories are authenticated. But they must have forgotten.
\+1 CodeLite
You make some valid points, and of course it depends on priorities - I have to support 4 different compilers, 3 operating systems, 32 bit and 64 bit ABIs on each, 2 different assembler syntaxes, and CPUs from Westmere up to Skylake X (not AMD though, thankfully). I encourage you to look at the generated code from clang when using intrinsics - it does some pretty cool stuff during code generation, even sometimes subverting the intrinsics you’ve used and substituting more efficient SSE instruction sequences where appropriate.
You should change the `begin()` and `end()` implementations to handle custom implementations of `begin()` and `end()`: constexpr enumerate_wrapper_iter begin() { using std::begin; return {0, begin(container)}; } constexpr iterator_type end() { using std::end; return end(container); } You should also make `operator!=` into a free function, and make both signatures: constexpr bool operator!=(const enumerate_wrapper_iter&amp; lhs, const iterator_type&amp; rhs) { return lhs.value != rhs; } constexpr bool operator!=(const iterator_type&amp; lhs, const enumerate_wrapper_iter&amp; rhs) { return lhs != rhs.value; } constexpr bool operator==(const enumerate_wrapper_iter&amp; lhs, const iterator_type&amp; rhs) { return lhs.value == rhs; } constexpr bool operator==(const iterator_type&amp; lhs, const enumerate_wrapper_iter&amp; rhs) { return lhs == rhs.value; }
&gt; Why not start with Catch? Because one already knows how to use gtest and it fits the bill? 
atof
from sidebar: &gt; For C++ questions, answers, help, and advice see r/cpp_questions or StackOverflow. 
Why don't I see anything about compile-time reflection in here other than the name of a talk where something else is mentioned?
Because you don't address how (void)new DiscardableThing(); is a significant impact to programming.
It would be good if package management is standardized in an operating system independent way. In the same way threading did not need to be standardized and could have been left up to the os as it was pre C++11, but it's nice to have.
Yeah, but most importantly it can produce code for multiple targets and archs. All of the variations can be linked to the same binary and the best one can be picked at execution-time for the host in question.
boost::log is your friend. BOOST_LOG_TRIVIAL has replaced... hmm... I think actually ALL of my couts in my code over the past 3 years or so. I'm also all for logging at debug level pretty much any time you want to.
Streaming to cout using &lt;&lt; works like calling any regular method, there's no reason you can't use it in a non void function. I think you're confusing return value with console output.
Im very new to programming so I don’t really know it
You should ask these sort of questions in r/cpp_questions, this subreddit is more for discussion of news and articles about the language itself. But to answer your question: It doesn't matter what the return type is, you can think of a function as just some number of statements that you want grouped together. Doing int sum(int a, int b) { int result = a + b; std::cout &lt;&lt; "The sum of " &lt;&lt; a &lt;&lt; " and " &lt;&lt; b &lt;&lt; " is " &lt;&lt; result &lt;&lt; "\n"; return result; } would just mean that every time you call that function, you're going to output that sentence to the console, as well as return the result to wherever you called the function. You can use this for logging every single time you use this function for example, which can be useful. That being said, there are some methodologies that try to avoid doing side effects like that (There are entire programming languages built around avoiding side effects as much as possible, like Haskell for example). So if I didn't know what your function did internally, I would just assume it would return the sum, and if I use it like so: std::cout &lt;&lt; "3 + 4 = " &lt;&lt; sum(3, 4); Then I'd just end up with 3 + 4 = The sum of 3 and 4 is 7 7 Which obviously isn't quite what I would expect. But it's perfectly fine to use `std::cout` in functions, just be aware of what that really means and you're good to go.
Are there any other parts of the standard that directly address things that aren't related to the language? 
I've always wondered about how the compiler optimizes code with/without side effects. I know that in Haskell, any functions dealing with I/O are treated differently from other functions, which normally do not have side effects. Do C++ compilers generally recognize whether your function contains side effects or not?
why are you declaring three un initialized raw pointers... this is a rare problem
Looks really nice thanks!
The compiler.
I'm not an expert in any way really, but compilers do have optimizations for things like that for sure. You can play around with stuff like that in [Godbolt](https://godbolt.org/z/8gW7k3). The assembly might be a bit rough to read if you're not familiar, but you can see in the main label it does some funky stuff and doesn't even call the function you pass it because it knows it can add the two numbers better. If you get rid of the optimization flag at the top, you'll see that then it does everything verbatim. But if you use the `sum2` function, then even the optimized output still has a call to the `sum2`, because of the std::cout. If you have optimizations on and pass the no-side effect version two constants like 3 or 4, then it just gives you 7 immediately without even doing the calculation.
How would package management be part of the language?
Another solution would be to rethink the lifetime of your objects. The big advantage of couroutines is that they enable to completely avoid holding the state through shared\_ptr. The caller/owner of C will just have to `co_await c.coro()` thus c can not be destroyed before the caller. If you need a way to abort, see the [cancellation mechanics in cppcoro](https://github.com/lewissbaker/cppcoro#cancellation_token).
I thought they meant it's 276 papers for San Diego.
&gt; CLion is UGLY and buggy I'm curious on why you feel that way, I like it's looks out of all the other IDEs and have only had one or two small bugs (other IDE's have been way worse).
Threading absolutely needed to be standardized, because it is an inherent part of the language. Tooling isn't. 
Modules are a language level concept. Package management isn't. 
You can keep using range-v3 like I plan to (I hope).
Why not int *a, *b, *c; 
Imagine that two coroutines use `c`.
Funny, I’m just getting around to updating my for loops in some personal projects to use range for syntax, and (perhaps no surprise) ran into cases where indices were still needed. Even if the solution presented here is not perfect, glad to see someone come up with an idea to solve this problem.
Clang vectorized his code, GCC did not.
I have to completely agree. There might be some valid use cases for this, but in general this whole approach is just wrong. The caller side should take care of the lifetime.
It wasn't an inherent part of the language.
+1 codeblocks
Looks very interesting, but I'm not sure how it all works from the Readme and tests. So, we don't write documentation in source - good. But where we **do** write it? How the process looks like? I assume that after we first run Hyde on a yet-completely-uncommented code, we'll get output files for it with placeholders for class/method/field descriptions, which we can fill? And then update, as the source evolves?
ITT 'constexpr' doesn't mean what OP thinks it means.
[removed]
you could potentially have the definition of debug_printf be #ifdef'd out in a debug build, which you could specify through a define in your build
Depending on your compiler and IDE, either may set a certain Macro when using Debugging or Release mode. Then you can use ifdef for the output.
https://www.boost.org/doc/libs/1_63_0/libs/log/doc/html/index.html
Video was previously removed and now it's back up.
We are in the process of updating the docs etc to explain the process and the outputs etc, but yup that is the general gist of it. We are using it internally for exactly this. We are also going to work it into our CI system to block merges when docs drift out of date etc. This is probably a good topic for a blog post at some point in the future. 
how about if you name your variables in consecutive alphabet letters you get a * automatically added to every letter who's char code - 23 is prime
Fails to compile with MSVC: Error C3615: constexpr function 'en::enumerate\_wrapper&lt;container\_type&gt;::enumerate\_wrapper\_iter::operator ++' cannot result in a constant expression. To be constexpr, a function can only call other constexpr functions.
OK, thanks for the confirmation. Seems like a good tool, I don't have a project to try it on right now, but I'll remember it for the future. One thing I see is you should use find(module_name) instead of hard-coding path to Boost and Co. in CMakeLists.txt.
If you are interested in `unique_resource`, take also a look at [P1314](https://wg21.link/p1314) `unique_val`. It intentionally avoids (custom) deleters.
Note that if result type was size\_t (instead of int), then GCC also vectorizes.
Blog post was published a couple of months ago, but I haven't shared it here... until now. Hopefully you'll find it interesting and let me know if you have any feedback. Cheers! 
Let me put it differently: There was no c++ program with more than one thread before c++11. Any program that used more than one thread used an extension to c++ (you can make up names for those like pisix_gcc_c++). Multithreading - if present - is an inherent part of any programming language, because it heavily influences what you and the compiler are allowed to do. Tooling on the other hand could be integrated into the language (and you could argue that many pragmas do just that like auto linking libraries or suppressing warnings). But generally you absolutely can have excellent tooling without the language knowing of it.
As far as the type system is concerned, there is no difference between functions with and without side effect. So unless the optimizer can see the function implementation, it always has to assume that any function has arbitrary side effects.
Most voted feature request https://github.com/ericniebler/range-v3/issues/785
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9qmr56/debugging/e8adgyi/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
use a stringstream. or if its ASCII int = string - 48 
&gt;Edit: Passing in an array doesn't work. You need a specialization for pointer types, but I need to remember template programming first. You can use std::iterator\_traits - it has a specialization for pointer types
Thank for the pointer! However, I am not sure I can agree with the argumentation in the proposal. `unique_resource` has an advantage that it protects from forgetting calling a deleter, which eliminates the whole class of errors, and arguably, one of the most frequent ones. Also, the user shall not forget to check validity of the `unique_val` before calling the deleter function. I suspect it may turn out error-prone. 
Here's an alternative: ``` template &lt;typename Container, typename F&gt; void enumerate(Container&amp;&amp; container, F&amp;&amp; f) { std::size_t i = 0; for(auto&amp; x : container) { f(i++, x); } } ``` A real version would use perfect-forwarding where appropriate, but I find this way simpler than an iterator/range-based version if you don't need early return/break.
I completely agree with all of that - just surprised people think that it should be introduced to the C++ standard.
wow, libc++'s regex is very bad.
&gt;What should one start a new project with (**assuming no familiarity**) &gt;Because one already knows how to use gtest I don't think you read the original question correctly.
So maybe just avoid call chains in C++? Easy and safe!
Ok for a simple case like this, but when you have some 'continue' or more complex stuff inside the loop, that would be easy to skip the i++ by mistake.
&gt;but that's only in C++11 There are only a few weeks until it is 2019! Where is the problem?
Well, the group (SG15) that is trying to push that is part of the standard group, but it does not mean that all that is produced will end up in the same document. So I think the confusion is to be expected but it's not a problem. SG15 early on decided to not produce C++ standard but feedback and directions and maybe other related documents like standing documents. I think standards can be produced but not necessarilly C++ indeed.
Pretty much the summary of Modern Effective C++ by Scott Meyers
Maybe in in a struct?
Because it is not possible when coding style is declared as this form: int* a;
Init also doesn't work: int* a = nullptr, b = nullptr, c = nullptr; // doesn't work
What we really need is an attribute for constructors that register the object in this way.
I want to deprecate two old type of flawed variable declaration form and evolved them to a unified one. I think it is a simplification.
I think this is dictionary case of straw man fallacy https://en.m.wikipedia.org/wiki/Straw_man 
Depends on the regex you're using. For my use case it performed the same as libstdc++'s regex, which was still 2.5x slower than boost and re2.
Oh! Adding dependencies to your code is expensive. Typically I'm OK with boost, since you can brew install it pretty easily on OSX, get it into visual studio without too much trouble and install it via a package manager on Linux if you don't mind always being down a couple of revs from the current one that seems to inevitably be the exact one you want some latest feature from. Having to build it from scratch on Centos might be enough to make me reevaluate my position, though. Especially since they've moved a lot of stuff from boost into the C++ standard in C++ 11 and 17. There's a lot of cool stuff in boost, check it out if you get a minute. The syntax on some of their things can be a little esoteric, but I use boost::log on a day-to-day basis and boost::python makes adding python support to your code a snap. I also have high praise for the eigen C++ math library if you ever need math for anything, OpenCV if you ever need to do anything with images and Tesseract's pretty good for an open source OCR library. Reinventing the wheel can be OK if you're going to learn something in the process, but sometimes you just want to get something done without beating your head against a wall.
&gt;Qt itself is moving away from the Qt containers and have replaced &gt;most of its internal structures with the STL ones. Not really true. And Qt container will continue to be used in user APIs. Simply QList *might* become deprecated in Qt 6 &gt;There are subtle bugs that might be difficult to find because &gt; of the implicit sharing bugs? I don't think so. But yes, COW might happen if you don't take care. But this is not more subtle than std::vector and move semantics, like "std::vector needs that the elements have noexcept move ctors".
A tour of C++ 2nd Edition. It is not intended for beginner unlike Accelerated C++ but Bjarne gives a clear overview of modern C++ with plenty of examples and code.
**Company:** Nexustec GmbH www.nexustec.de **Type:** Full-Time **Description:** Nexustec GmbH is working in the area of industrial automation with focus on Industry 4.0, We are developing a next generation quality analysis and quality control systems for Industries everywhere. Your tasks will include working in advanced machine learning and AI related activities with emphasis on Signal / Image processing. **Location:** Munich, Germany (Working language is English, however, knowledge of German language is preferred.) **Remote:** NO **Visa** **Sponsorship:** You don't need VISA sponsorship in EU. **Technologies:** C++14, C++17, Python, TensorFlow, Qt, OpenCV **Contact:** Please apply via Indeed job portal [https://www.indeedjobs.com/nexustec-gmbh/\_hl/en\_US](https://www.indeedjobs.com/nexustec-gmbh/_hl/en_US)
You had to use a library, but that doesn't mean it wasn't C++. Threading absolutely belonged in the standard library though.
Hey there, thanks for your comment! By moving away from Qt containers I didn't refer to the external API. I'm sure the external API won't change in the near future as it will obviously then break the ABI and also make users very angry. I was just referring to the fact that Qt is now using the STL containers internally. Also perhaps it's a personal preference whether COW can lead to more subtle bugs compared to using STL's containers. My personal experience is that I've encountered more bugs using Qt containers compared to STL ones. In some circumstances, as described in the article, I found it tricky to know when the copy happens. Or unintentional copies. What's your experience? Cheers, Alex
I'm not so sure about 1276 being a slam-dunk. As written the 'void' returning main() would still return an int '0' to the calling environment, since there is no end of ways the runtime environment expects to capture an int return value. Claiming that we're not returning something is just wrong.
Not really. *Effective Modern C++* is for people who kind of know C++ but want to be better at using it. It's not at all a good source for how to learn C++ itself, like how templates work or what classes are available etc. Obviously you'll pick some stuff up, but that's not the book's purpose and so it's not very good at it. *Accelerated C++* is for people who know programming in other languages but are entirely new to C++.
It's not for the paint of heart, but here are two ressources to setup EMACS as an IDE: [EMACS as a c++ IDE.](https://nilsdeppe.com/posts/emacs-c++-ide2) [Another one!](http://syamajala.github.io/c-ide.html) Once running and once you remember the keyboard shortcuts, it's really effective and powerful.
This has little to do with style, but with parsing - you can declare anything that start with `int` `int i, * p, a[12];`
Same here. VSCode is so far the best linux IDE for me. Make sure to install Cpptools, CMake and CMake Tools extensions and you are good to go. The improvements over last few months are great. Lot's of stuff moved from plugins to core VSC or Cpptools. But TBH: Nothing beats Visual Studio with Visual Assist X. The code completion, generation and refactoring is unmatched. But big plus for VSC: Multi-Language in a single folder. I do that currently (C++ and Python with CMake) and it just works :)
That’s it exactly, actually.
Indeed, I'm strongly against `void main`. Not only for the reason you suggest -- it hides the fact we're returning an int to the OS -- but also because if I see `void main()` in a blog post, StackOverflow answer or (heaven help us) a textbook, I know I can stop reading immediately. It would be a shame to lose this valuable shibboleth.
This article is awesome! I tried clang-query recently, and failed to create my matcher, because I was not able to understand how to create it from the AST dump. I will re-try at home this evening, but I'm pretty sure it solved my issue!
What about baremetal projects that should never return from `main` as there is no OS/kernel/whatever?
If they don't have an OS, the standard says they don't need a `main`
\*\*Company:\*\* [Spirent](https://spirent.com) &amp;#x200B; \*\*Type:\*\* Full time &amp;#x200B; \*\*Description:\*\* This is a key position working on Spirent’s next-generation packet generation and analysis technology. In this role, you’ll have the opportunity to make a ground-floor contribution to a new project in Spirent’s Cloud &amp; IP business unit. We are looking for an experienced C++ developer. &amp;#x200B; \*\*Location:\*\* Raleigh, North Carolina or Calabasas, California &amp;#x200B; \*\*Remote:\*\* No &amp;#x200B; \*\*Visa Sponsorship:\*\* No &amp;#x200B; \*\*Technologies:\*\* This project is addressing an interesting set of problems at the forefront of modern infrastructure using modern software engineering approaches. Philosophies and technologies you'll find here: &amp;#x200B; * Generally shared-nothing concurrent programming via message passing * Shared data fast paths via lockless data structures * Multi-threaded user-mode TCP/IP stack * Modern C++17 codebase with support for embedded, functional JavaScript * Application of SPMD programming techniques on general purpose CPUs * Disciplined approach to unit testing and automated-accepted testing * macOS or Linux-based development environments (your choice) &amp;#x200B; Eventually we will also be writing CUDA or OpenCL kernels for execution on GPUs. &amp;#x200B; \*\*Contact:\*\* Apply at [https://recruiting.adp.com/srccar/public/nghome.guid?c=1208401&amp;d=External&amp;prc=RMPOD4&amp;r=5000411044906](https://recruiting.adp.com/srccar/public/nghome.guid?c=1208401&amp;d=External&amp;prc=RMPOD4&amp;r=5000411044906). PM me or email [david.joyner@spirent.com](mailto:david.joyner@spirent.com) with questions.
Glad you liked it! The next blog post will also be very useful to you I think. Also, I will be showing some future features of clang-query and clang-tidy in November at [code::dive](http://codedive.pl/index/speaker/name/stephen-kelly). If you already have experience with trying to create a clang-tidy check, it will make your eyes pop :).
In a freestanding environment, startup and termination is implementaion-defined. 
I guess it is subjective, because I am not very exited by any of the papers. "Nested Inline Namespaces" is confusing and probably unavoidably so. "nodiscard should have a reason" has too little motivation - nodiscard is used as a way to communicate the API, which is...questionable. The comparison with deprecated is not good, as deprecated should tell you what to do, when the API is not longer valid. "namespace std { namespace fs = filesystem; }" makes some sense, yet typing fs::path is shorter then std::fs::path, once introduced. Will the people like to write std::fs::path? Will it help learning? What is fs when reading code and you don't know C++(20) good enough? "offsetof For the Modern Era" seems to step in Reflections territory. "Literal Suffixes for size\_t and ptrdiff\_t" started nice (sz), but now... z... zu, naah. &amp;#x200B; &amp;#x200B;
That is the problem, you can mix the type with the variable names. You can't enforce today a rule where the type and variable name is separated. But you can do that with my proposal: int := i; int* := p; int[12] := a; int (int) := f; int (*)(double) := pf; int C::* := size;
Code::Dive talk? Great!
Why on earth would zip not make it? That's one of the most useful ones (I find).
I strongly disagree. From [http://eel.is/c++draft/basic.start.main#5](http://eel.is/c++draft/basic.start.main#5) &amp;#x200B; &gt;If control flows off the end of the [*compound-statement*](http://eel.is/c++draft/stmt.block#nt:compound-statement) of main, the effect is equivalent to a return with operand 0 (see also [\[except.handle\]](http://eel.is/c++draft/except.handle))[.](http://eel.is/c++draft/basic.start.main#5.sentence-2) &amp;#x200B; This means that a conforming main is `int main () {}` How is this different from a void function?
That's also a fair direction to go in, but that breaks plenty of existing code that hasn't covered those possibilities. A conforming main can be written as `int main () {}` Which is, essentially, a `void` function. 
Sorry for shouting, but apparently **yes there is a new version in the works.** Maybe 3 years ago I asked Andrew Koenig if the book would ever be updated, and he was non-commital. But Pearson (really Addison Wesley, I think?) [says that it is coming in early 2019.](https://www.pearson.com/us/higher-education/program/Koenig-Accelerated-C-Practical-Programming-by-Example-Practical-Programming-by-Example-2nd-Edition/PGM2060260.html) I think the recent revival of interest in C++ has spurred a new surge in good C++ books over the last 2-3 years. Too many to list here, but most people reading this can conjure up a list of at least 10 recent good books Stroustrups' 2nd ed of "Tour" largely fills the need that "Accelerated" filled almost 20 years ago, so I'm eager to see what "Accelerated" brings to the table. Since Koenig and Stroustrup go way way back (early AT&amp;T days), I'm sure Koenig is aware of "Tour"'s content and will have its own "spin on things"
What problem does shortening `std::filesystem` actually solve? Why not add Rust-like aliases like `u8`, `i32` etc. to std as well? The committee should not bother saving you a few characters of typing when the language already has first-class support for aliasing namespaces and types. Besides, shortening namespace names is actually barking up the wrong tree. The root of the problem are header files which require fully qualified names in the first place (to not pollute the users), and that is getting solved by Modules.
What problem does shortening `std::filesystem` actually solve? Why not add Rust-like aliases like `u8`, `i32` etc. to std as well? The committee should not bother saving you a few characters of typing when the language already has first-class support for aliasing namespaces and types. Besides, shortening namespace names is actually barking up the wrong tree. The root of the problem are header files which require fully qualified names in the first place (to not pollute the users), and that is getting solved by Modules.
Thanks for taking a look! I am not sure I follow what you mean in the first part. `unique_val` will call the destructor of the type it contains, if there is one (typically it won’t, for the most common use case); but you could in theory put it there, so there is no way you can forget it. If you mean instead the code that uses `unique_val` forgetting to call a function in a destructor; well, the same can be said about forgetting it in a wrong custom deleter. Also note that destructors cannot throw, i.e. in constructors we don’t have to worry about exceptional exits. As for the second part: actually the non-std implementation I wrote does have a second template class with two parameters to provide for that (e.g. `unique_val&lt;int, -1&gt;`). However, I didn’t include it in an effort to propose the simplest paper possible; but maybe it was a mistake. I may add it back for R1.
&gt; `auto &amp;addr = Address().Line1("...").Line2("...").State("CA").Zip(12345);` This looks suspicious - non const reference to an rvalue
I love this technique too. Combine this with std::embed(if it makes it) and you can do some things like RPC/GUI design in external tools and parse it directly to c++ without a preprocessing step. Think protobuff's but C++ parses the file directly into a type
Thanks.
That project is extremelly messy, so i decided not to put it public, but i might clean it up a bit and put it online.
&gt;Removing all the C only constructs especially C arrays and strings. How would you even store a std::vector or a std::array if the compiler had no support for c arrays? Why would you want that?
Good catch. Although as you probably know, \`const\` does not help in lifetime extension. Reference may be necessary if the \`Address\` is move-only (e.g., contains a \`unique\_ptr\`).
One simply can't use Qt if one doesn't know the Qt containers. But since Qt containers are easy to learn (easier than the rest of Qt!), that's no big deal. Personally I use both Qt and std containers. I find the Qt containers more convenient. 
[rtags.net](https://rtags.net) does a lot, if not all, of those things. It's built on libclang. [projectile](https://projectile.readthedocs.io/en/latest/) is great for jumping around projects
Or rather, the entry point is implementation-defined. Which means that `void main()` is completely acceptable by the current standard in those environments.
The goal here is indeed to encourage people to use the fully qualified name, the shorter the namespace's name, the less likely people are to do `using namespace std::filesystem` which is terrible. As for modules, sorry, they are not a scoping mechanism. A function `f` exported by module `foo` is still called `f` and not `foo.f` or `foo::f`.
The `i++` can't be skipped because it is part of `enumerate(),` not `f`. You wouldn't write `continue` in `f` because it can't see the `for()`; you would write `return` instead. There is no way to write `break`, as SuperV1234 mentions.
Those captions look accurate. Template metaprogramming uses a different lingo than you are used to.
The technique uses recursion to parse on a per-character basis. Currently constexpr is seriously restricted in terms of recursive depth. So that needs to be fixed. 
&gt; `using namespace std::filesystem` which is terrible Maybe. That depends on the scope. If the concern is that this will be done at a wide scope, why not just do `namespace fs = std::filesystem;` and move on? Why does the abbreviation need to be standardized?
Google Test provides and works with Google Mock right out of the box which is very convenient. Google Test can also supposedly run on embedded (bare-metal) targets. Catch has a simple, more readable syntax but I'm not sure it's support for parameterized tests (both types and values) is as mature. I'm also not sure with how well it integrates with mocking frameworks.
I think that Odin Holmes talked about trampoline techniques in the video. I am not sure how they apply, but it sounded like there is a technique to flatten the recursion
I’m working on it right now :)
Awesome work! What are the missing features that are preventing this link working in MSVC?
Just linking me to the cppreference page for copy elision, without elaborating on what you think I'm mistaken about, doesn't help me. I'm not expecting or asking for you to elaborate, but just pointing out that simply saying "You're wrong" and pointing to a large page of complex text without giving the person you're talking to a hint as to where to look for their mistake, isn't a good way to correct someone. I don't know what you think I'm wrong about, or really have any clue as to where the "a number of things" qualifier comes from. Are you saying that based on my posting history in some way? Or are you saying "A number of things" with regard to my mistaken memory telling me that C++14 has mandatory NRVO? I've read that linked page several times over the years. I've further created multiple thousands of lines of tests to verify the behavior of the compilers that I use, for the various aspects of behavior that I care about. For my use case with regard to the concept of ScopeGuard, the compilers I'm using are implementing the optimizations we're talking about here for the code I wrote tests for. I know this as a fact. That doesn't mean that it's valid for me to extrapolate that to a larger set of situations, which is what I did in error. I wasn't intending to mislead anyone. Human memory is fallible.
At my old company, we targetted both gcc and clang (because neither is perfect and they each have bugs from time to time, we get best warning coverage by using both). But in clang builds, we still used gcc for cuda targets, because our version of nvcc would not accept \`--ccbin=/usr/bin/clang\`. I don't know if nvidia has fixed this, somehow I doubt it. I remember reading online that you can instead try to use clang to compile cuda, and skip nvcc, which sounded wonderful but I never actually tried it.
Your comment triggered the spam filter due to the googl URL shortener; please avoid using that in the future. I’ve manually approved it.
I see. Can you put that sentence into words I'll understand, then?
The problem comes from when a new team try to choose a coding style. And there is no agreement usually because it is not possible. Both options are flawed. The pointer belongs to the type or not looks like a simple question but it isn't. If you choose the trivial answer so "pointer and ref is part of the type" you end up with a situation where every variables must be declare in a new line. If you choose the "pointer or reference is not part of the type" you end up with a tricky declaration syntax. With this new syntax you can enforce a trivial thing: pointer and reference is part of the type. But changing such a core element of the language is looks like impossible now. And the same syntax is needed in structs/classes so it is quite common to declare a variable with the same type.
People say that, but QString has great formatting capability that is simply not available on std::string. You can always get another lib like fmt, but having the Qt one why bother?
Agree with you, std::string &lt;&lt; QString. Might add something about it to the post! Thanks
Your rationale is flawed because the proposal doesn't remove the capability of writing \`int main()\` functions, it just proposes an alternative signature. Also, there's a sizeable number of programs that don't care about returning a specific value to the OS, they just want to report failure or success. You can already do this by returning normally in case of success, or letting an exception go uncaught in case of failure. Notably, \*you already don't\* control specific return value in case an exception gets propagated. Allowing for \`void\` entry points has a precendent in C#, where you can use any of: \`int Main()\`, \`int Main(string\[\] args)\`, \`void Main()\`, \`void Main(string\[\] args)\`. Allowing for multiple signatures has a precedent in C, where you can either have \`int main(void)\` or \`int main(int argc, char\*\* argv)\` You can trivially implement \`void main()\` by, for example, allowing to rewrite \`void main(whatever) { ... }\` to \`int main(whatever) { \[&amp;\](){ ... }(); return 0; }\`. So "omg but OS uses exit code" is also irrelevant to the proposal.
Is there a minimum clang-query version you are using as trying with 6.0.1 and it doesn't appear to work. `clang-query&gt; m functionDecl(hasName("addTwo"))` &amp;#x200B; `Match #1:` &amp;#x200B; `No bindings.` `1 match.` &amp;#x200B;
Okay, but if you have the suffix `t`, what does `ut` mean? Remember that an important part of **language** literals is that the "u" can be sprinkled on before or after the "main" suffix: if we are going to break that rule, then we had better have a really, really good reason for making C++ more inconsistent with even its literal suffixes in Yet Another Direct. Also, the paper explains why `sz` isn't picked: someone might be proposing `short float` in the future, wherein `sf` will start having a defined meaning to short. Is that `short size_t`?
Nothing I know of that gives the quality introduction that Accelerated C++ does. It should be noted that one could do a lot worse than using an old version of Accelerated C++. If the indications of a new version for early 2019 are correct it might be worth a wait. I have nothing to suggest otherwise due to no recent C++ reading. 
So, there no chance of a windows version of he lib that works but has a less usable interface? :)
social kneel accept customary scent birth businessman chair lesson gaiety fit mankind uncle thin continue well warm bath everything throat room rivalry numerous thirst border complete fit
I'm working on it now ... stay tuned :) at least in MSVC 15.8 it should work soon :)
Clang and GCC work on Windows, too. ;-]
`%ut` is allowed by `printf` as well, and it means the "corresponding unsigned integer type" to whatever `ptrdiff_t` is. I would recommend doing something similar for literals. The same goes for `%zd`, which is the "corresponding signed integer type" to whatever `size_t` is. I don't see too much conflict when it comes to a "short" modifier. Again, I'll refer you to how `printf` works. There's two axes here: the type of the argument, and the size of the argument. `l`, `ll`, and `z` refer to the size, while `u`, `d`, and `f` refer to the type. (For the purposes of a literal, the `d` is left off, but otherwise everything is consistent.) Thus, `sf` makes sense, but `sz` is a syntax error in the same way that `uf` would be a syntax error. Though, if we go by `printf`'s guidance, maybe `sf` isn't right, either. `printf` already uses `%hd` and `%hu` for `short` and `unsigned short`, so making `hf` be the suffix for `short float` makes logical sense, too (at least, from that perspective). `%sf` already means something different.
\&gt; The pointer belongs to the type or not looks like a simple question but it isn't. If you choose the trivial answer so "pointer and ref is part of the type" you end up with a situation where every variables must be declare in a new line. As I said, If you follow current best practices, that case happens so rarely it is really not worth arguing about. &amp;#x200B; Also about such style guides in general: You need to allow for some flexibility anyway - you can encode as many situations as you want, you will never cover all edge cases and I flatout refuse to believe that an inconsistent placement of the \`\*\` or \`&amp;\` leads to any major readability problems in a code base. (Or put differently: If that is all you have to worry about, your code really must be a work of beauty) \&gt; And the same syntax is needed in structs/classes so it is quite common to declare a variable with the same type. How often are you writing a class, where you have multiple raw pointers of the same type (but not in an array) that belong logically together (otherwise why would you want to put them on the same line) and you don't initialize them to nullptr? Or would you actually prefer this: &amp;#x200B; int\* := start\_ = nullptr, end\_=nullptr; &amp;#x200B; over &amp;#x200B; int\* start\_ = nullptr; int\* end\_ = nullptr; &amp;#x200B; Is vertical space really such a premium on your monitors that you have to worry about that? &amp;#x200B; Again: Could C have picked a better syntax? Sure! Is it worth introducing a new syntax now (without getting rid of the old one)? Certainly not!
You're getting a match but you have no bindings. Did you run set bind-root false ? Try set bind-root true or an explicit binding functionDecl(hasName("addTwo")).bind("myFunc")
Fantastic! :)
Done, I changed the parser to not use recursion. So there is no limit on input size now (only memory of your computer which can be eaten pretty quickly during parsing :)
If you start a brand new project and you want to add some dependency to it you will quickly realize that half of the dependency is in "int\* a" style and half of them in "int \*a". Some example: int \*a style: C++ REST SDK [https://github.com/Microsoft/cpprestsdk/blob/master/Release/include/cpprest/base\_uri.h](https://github.com/Microsoft/cpprestsdk/blob/master/Release/include/cpprest/base_uri.h) Godot Engine [https://github.com/godotengine/godot/blob/master/main/main.h](https://github.com/godotengine/godot/blob/master/main/main.h) EnTT [https://github.com/skypjack/entt/blob/master/src/entt/entity/prototype.hpp](https://github.com/skypjack/entt/blob/master/src/entt/entity/prototype.hpp) &amp;#x200B; int\* a style: Boost [https://github.com/boostorg/asio/blob/develop/include/boost/asio/associated\_allocator.hpp](https://github.com/boostorg/asio/blob/develop/include/boost/asio/associated_allocator.hpp) Chromium [https://github.com/chromium/chromium/blob/master/net/base/auth.h](https://github.com/chromium/chromium/blob/master/net/base/auth.h) Bitcoin [https://github.com/bitcoin/bitcoin/blob/master/src/chain.h](https://github.com/bitcoin/bitcoin/blob/master/src/chain.h) &amp;#x200B; And I think this is source of unwanted disputes about coding style and about code readabilities. In classes and struct those declarations are quite common. You are right that introducing a new syntax for such a core language component is hard now.
I think the variable declaration syntax has a cognitive overhead now. You have to think on meta rules. It would be much simpler if you don't have think on how to declare a variable. Now we have two form for it and this come with two different code formatting meta rules and other meta rules just like one declaration per line meta rule. And I think this is a problem. A unified declaration syntax can simplify the language.
Where did the preview go?
Seems correct
The big issue is that they just don't work on Windows. Clang will merge all functions with the same signature in inline variables together, while MSVC doesn't support merging the functions. You end up with unfortunate bloat in MSVC, and UB all over the place in clang. inline auto x = [] { return 0; }; inline auto y = [] { return 1; }; int main() { int foo = y(); return foo; }
Not agree. There's a lot of use case where you can work with qt without using/have to deal with their containers. Just take a look on their sample. 
&gt; you start a brand new project and you want to add some dependency to it you will quickly realize that half of the dependency is in "int* a" style and half of them in "int *a". I know. So whats the Problem? I'm working with a code base, where this isn't even consistent in a single file - I never had a problem with it. If I work on a project with a consistent style I use that style (or rather I let clang format do it for me). Again, that is really the least of my concerns regarding readability. &gt; In classes and struct those declarations are quite common. I've only glossed over them, but as far as I can tell, none of the files you linked to has a class with two member variables on the same line and most don't even have two pointers of the same type. Personally, I'd probably flip a coin and be done with it, but who am I to tell you what is important for you and your team. 
Who is Jonathan Blow and what did he do?
Incel memes on /r/cpp. Ugh.
This is not an incel meme... but ok. I guess you're trying to be down with the kids.
Why not just use tooling to solve the problem instead of adding complexity to the language? Just reformat it on checkout/checkin and move on with your life. Standardized coding styles aren't nearly as important as you seem to think they are.
Did anybody say they were? Also, you're replying to someone else. Maybe drop the weird defensive attitude and just have a civil discussion? 
Right, because calling people toxic is very civil...
If even /r/the_donald can't get shut down for being toxic, then why, pray-tell, would Reddit shut down /r/incels? Probably all the really awesome non-toxic conversations. Conversations like [this one](https://www.reddit.com/r/Braincels/comments/8jddvz/a_cum_dumpster_talks_about_what_its_like_being_an/)? Or maybe [for inciting violence against women?](https://www.nytimes.com/2017/11/09/technology/incels-reddit-banned.html) The best people. Jesus, why am I even bothering? 
Unrelated question: what is `template&lt;class T&gt; indexing(T)-&gt;indexing&lt;T&gt;;` ?
Friend, this meme has nothing to do with incels. Just let go. You don't know what you're talking about. Nobody here is defending incels. This has nothing to do with incels.
&gt; calling meme incel too bad I can't ask you to **** yourself :/
How is the Virgin/Chad template not an incel meme ?
Hmm... What's `stl_vector.find()`? I'm not aware of it. 
Buddy, it's literally a meme comparing an older looking guy who is a virgin to some show-off douchbag. If that's not an incel meme then I don't know what is. This meme is really dumb and degrades the quality of discussion on this sub-reddit, which is usually of a high caliber. I'd say let this one go and quit defending this incel crap.
&gt; If that's not an incel meme then I don't know what is. you clearly don't know what it is, since you decided to not even look it up or address anything I've just put in my comment... it is good you realise that though. &gt; quit defending this incel crap. You're the sort of person who screams your way through a discussion. I got it.
&gt;The format is not about incel topics, and it portrays chad under a good light, and **involuntary virgens** like loser You do realize incel stands for involuntary celibate, where celibacy is synonymous with virgin, right? But nah... definitely nothing to do with incels, it's just a coincidence I'm sure. Keep defending this toxic nonsense.
Ah yeah. Well, I'm just use to it as it's generic and also works with arrays. But I guess either works fine. 
You realise the format mocks the idea of being a virgin, and glorifies the idea of being chad. This meme format literally mocks the idea of being a incel as a total loser. But you're so caught up in arguing you're not even stop and thinking for a minute.
If you get riled up by a meme, imagine if you have to face actual life-changing events...
I know, God forbid whatever will I do with myself?! The horror!
Just want to say that your work is truly inspirational! Love the insight of using function overloads to map inputs to outputs as return types, without any function body. It reminded me of a trick Alexandrescu describes in Modern C++ design where he overloaded a function that accepts ... (ellipses operator) to swallow any args. Anyway, thank you for sharing this at CppCon!
no, but this is the definition of whoosh.
This is a great looking library Robert. I'm looking forward to giving it a spin real soon ... with a motor controller.
It would need to follow `_Ugly/__ugly` protocol, not have extensive Boost-internal dependencies, and support the Standard interface exactly. If it did, then we would be interested in using it.
So you want to change the language to play nice with your coding style guide? Seriously?
It isn't. You are confusing the fact that we have a shorthand for `return 0` with the actual signature of the function. Regardless of whether you write `return 0` or not, a value ***is*** returned.
&gt; also because if I see void main() in a blog post, StackOverflow answer or (heaven help us) a textbook, I know I can stop reading immediately. It would be a shame to lose this valuable shibboleth. Lol that's a lame-ass reason, my dude.
&gt; Your rationale is flawed because the proposal doesn't remove the capability of writing int main() functions, it just proposes an alternative signature. So? How is that related to what I wrote? &gt; Allowing for (...) Yeah. Other languages have other rules. How is that an argument? Are you really suggesting that this change is going to simplify porting code from C# or D to C++? &gt; You can trivially implement (...) No need to do tricks, because `main` already has a special rule for `return 0`. &gt; So "...but OS uses exit code" is also irrelevant to the proposal. Non sequitur.
A note on Byteswapping: While I welcome the addition of all those low-level-functionalities of most CPUs, I disagree with the notion that these should be used for endianess severely: Integers should always have the machine-byteorder, it's only when you read/write them from/to byte-ranges that the byte-order should ever matter. The right way to solve these would be to add the following four templates: template&lt;typename Integer&gt; Integer read_le(const std::byte*); template&lt;typename Integer&gt; Integer read_be(const std::byte*); template&lt;typename Integer&gt; void write_le(std::byte*, Integer); template&lt;typename Integer&gt; void write_be(std::byte*, Integer); Maybe also add overloads for `[const] char*`, but if you ever believe that you need more than this, you almost certainly have design-flaws somewhere. Also note that you can implement all of these in pure ISO-C++ without ever having to know the endianess of the system and won't suffer performance-penalties **if** your compiler is smart enough to recognize the pattern. I believe that adding these functions would be very valuable and is the one and only sensible solution to the byte-order-problem. And again: I'm not at all opposed to the byte-swapping-paper, but please don't consider endianess the reason why you should add it.
Enforcing style guides is very important because developers tend to spend a lot of time with formatting and arguing about what is the preferred formatting way. And that is a lot of money and time. And the problem is we have no good answer for this question. In your example why do you want to separate the pointer and array type from the "main" type? This is a very typical question in a debate. I had a lot of pointless debate on this. And I think I will have.
You posted this 8 days ago - please don't spam.
Removed as off-topic.
Regarding literal suffixes: The basic idea is good, but I have issues with the execution: * The problem that people have with user-defined literals is that they were provided in a very bad way: Hidden in the std-namespace and thus not available without `using namespace` somewhere in the code which makes them quite unattractive if you use them only once or twice per translation-unit as adding that line is more overhead than just writing the type out and using the constructor. This is **especially** retarded given that non-stdlib-UDLs must begin with an underscore, whereas stdlib-UDLs don't do that, meaning there wouldn't even be any issue putting all of them into the global scope where they really should be. * The reasons that people want a core-language-version probably boils down to exactly those issues plus that they don't want to require an include. * At least as important as getting those literals for `size_t` is getting them for `[u]intXX_t`, meaning that we should solve both of these at the same time. * The buildin-literals have some restrictions that among other things make the use of `sz` as suffix impossible and instead require the very ugly use of `z`. (Maybe this is different for people whose mother-tongue is English, but for German speakers these are VERY different letters and “z” is always pronounced like “ts” here.) As a result my impression is that this paper tries to be very small to get in more easily instead of cleaning up the entire mess that we currently have which would be the right choice in my opinion. In order to not just complain, here is my specific suggestion for the overall topic of UDLs; while this is certainly not completely suitable as it is and maybe not too well thought out, it might provide some food for thought: * Put all stdlib-UDLs into the global namespace * Rephrase all buildin-literal-suffixes (not that many) in terms of UDLs * Remove the current section on buildin-suffixes from the standard * Add a list of UDLs to the standard that must always be available, even without any include. All previous buildin-suffixes are listed there. * Add `i8, i16, i32, i64, isz, u8, u16, u32, u64, usz` to these buildin-suffixes with the obvious meanings (Yes `usz` and `isz` aren't that pretty either but as the committee made the terrible decision to add `us` for microseconds we cannot use it for `size_t` and since we want consistency we shouldn't use `is` for `ptrdiff_t`.) Alternatively use `sz` and `pd` for `size_t` and `ptrdiff_t`. * When we are add it: Allow integer-literals that receive the value as template-parameter, so that ugly constexpr-parsing of the char-parameter-pack can stop when a bounds-check is wanted at compile-time,
Targetlocationprediction is never updated.
How would I go about doing that?
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9qvmti/program_stuck_in_infinite_loop/e8c4qfb/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
One could easily enough implement `break;` in this idiom by having `f` return `bool` instead of void, and ending iteration early if it returns `false`. The definition of `enumerate` could of course be generic across `f` returning `bool` or something else. I think this is maybe better termed `for_each_indexed`
[Class Template Argument Deduction guide](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)
&gt; `_Ugly/__ugly` protocol We can blame that one on either boost or the weird STL requirements, but let's blame boost, since they could make it mandatory that new libraries follow that convention. &gt; Boost loves Boost, or why are dependencies for Boost.Filesystem &gt;100k lines over a lot of files Some boost libraries don't start as boost libraries. &gt; support the Standard interface exactly `std::path::absolute`comes to mind. Here we can't blame Boost without requiring them to break backwards compatibility. On the other hand some parts match the standard interface to letter. &amp;nbsp; Before this, I only considered the second reason as the explanation why STL implementations don't copy boost implementations. Yeah, it's even less feasible than I thought.
If I'm reading the change correctly, all of the work is now rolled up inside seed::operator+ and the fold expression? That's... Neat!
Catch is known for being very easy to use. It's a header-only library, meaning it's crazy simple to #include it and start using it. There's almost no boilerplate code required. Just used the supplied to macros to set up your cases, and you're off and running. I use Catch2 for all my open source projects, and am really impressed by how well it works and how simple it is to use.
How does that trick work?
There's really no excuse for sitting on an old compiler. Plus C++14 is such an important upgrade to 11.
Thanks for saving me time. Appreciate the summary 
You are correct :)
Has it been removed again? It is still unavailable for me.
Seems like it. Mods should probably sticky and flair
That's a nice thought, but: * The fixed-size integer defines in the library can not exist on certain platforms. See your friend neighborhood DSPs where 32-bit integers are the smallest thing you can talk to. Consequently, no fixed size integer literals. * But hey guess what there's a paper at least defining some of those suffixes you want (albeit in the library, which is one of the ways you don't want it): [wg21.link/p1280](https://wg21.link/p1280) * All UDLs in the global namespace already clash. `s` for string, also `s` for seconds: this can't be retroactively fixed unless we were to just arbitrary pick a winner that gets to the global namespace and a loser that stays in the old world. I appreciate you wanting me to fix the whole language, but that paper is ***never*** going to make it through the Committee alive. Someone already had a small reflector discussion on "hey let's put the string suffix in the global namespace" and boy howdy did that go down poorly: asking for all of them is going to be a LOT harder (read: impossible). The solution I prefer is coming up with a syntax that doesn't suck for referencing a User-Defined Literal in a namespace. Unfortunately, I'm having a really hard time picking a syntax that doesn't suck and/or has potential hair-pulling problems: * `std::123u8` \-- the safest and has the least grammar concerns. Objections are usually based purely on "that is ugly". Semi-agree, but the others solutions...: * `123std::u8` \-- this is fine, until you consider hex codes and namespaces. `0xEFfoo::bar::big_num` (where does the literal end there?) * `123_std::u8` \-- Okay, but now we have weird rules and also potential identifier clashes. Because we decided that non-underscore UDLs were holy, namespaces with underscores or that start with capital letters produce sequences of tokens and identifiers reserved for the standard library maintainers and compiler writers: `123_Blah::Woof` is illegal because underscore-Capital is reserved for the stdlib, and `123__qux::hlf` is bad because \_qux becomes \_\_qux which is an identifier reserved by the compiler. Also, do we put the non-standard UDL's underscore after the literal, or do we need it before too, such as `123_Meow::_Baa`? After going through these syntaxes, I definitely prefer the prefixed-namespace one. If we can access UDLs easier without a using statement it becomes less of a problem. This allows us to not flood the global namespace (bad) and gives us syntax to keep things shorter than `std::string_literals::operator""s("blah")`. You should have been in the room when UDLs were first designed. Maybe you could have put a stop to the insanity. But neither of us were there, and the little features put into the Standard preclude us from making smarter decisions about it as a whole. Sorry! The reason size\_t and ptrdiff\_t go in the language is because they can appear naturally in the core language from certain expressions and builtins. It is essentially a language-defined type, just given library clothing. The other types are not only not guaranteed to exist but are not used anywhere in the core language, so you are going to have a very hard sell to make them all global and exist forever. Not that I discourage you from writing the paper: if you think you have a good way to convince the C++ Committee, be my guest!
Does anybody know what solution Odin is referring to @ 52:12 https://youtu.be/QM3W36COnE4?t=3132
Nowhere in the blog and nowhere in the paper is endianess ever mentioned, at all. People might associate that with `ntohl`/`htonl` functions, but endianess was never the driving factor.
You may chek this one [https://github.com/ros2/ros2](https://github.com/ros2/ros2)
Because lots of c++ code resides in headers which means you can't keep such utility aliases file local if you want to use them there. And things like std::filesystem::path have a really bad signal to noise ratio.
There’s almost no substance here. The first one in particular criticizes an idea in a way that isn’t constructive and offers no meaningful alternative. 
Can't sticky someone else's post.
Working link: https://www.youtube.com/watch?v=QM3W36COnE4
`using namespace std::filesystem;` is terrible only because it pollutes the users of the header. It is 100% fine in cpp files, and Modules let you do this with no drawbacks.
I see the “make announcement” ability for others’ posts.
Commercial codebases. Stuff like determining which reader to use for a file by instantiating every possible type until the first one that doesn't throw. In general I've seen lots of catch(...){}.
Combining 2 ranges that represent position into a new range: https://www.youtube.com/watch?v=iwJpxWHuZQY&amp;t=1h9m40s struct Range(T) { T ptr; ssize len; } Range r1 = ...; // r1 and r2 are both 'position' ranges (r1.len == r2.len == 1) Range r2 = ...; // combine r1 and r2 into a new range // Range r3; if (r1.ptr &lt;= r2.ptr) { r3.ptr = r1.ptr; r3.len = r2.ptr - r1.ptr; } else { r3.ptr = r2.ptr; r3.len = r1.ptr - r2.ptr; } 
I'm using the same trick with (...) argument as a sink to reject everything which is not defined in LL1 table :)
Let's push for namespaced expressions: auto foo = std::(5h + 30min + 10s);
!removehelp
That's a shame. Sean Parent's talks are normally very enlightening and instructive. Will still watch it sometime, but won't bump it to the front of the line.
As I do not attend these meetings, can someone who does attend shed some light on how much committee time gets expended on "simple" papers?
Whenever some talks about the horrors of overloading core concepts (`operator!` here, `operator,` previously), I remember that lots of people really want to be able to overload `operator.`.
&gt; There are no issues there. The program's execution is unsuccessful, OS knows it, and the program prints the error message. This is literally what I want. No, sorry. There are no guarantees that you will see any error message (and even less a meaningful one). &gt; The point is: C++ already knows how it can tell the OS that the program execution was unsuccessful (in case of unhandled exception) or successful (control flow reaches end of main), without the explicit need to return an error code. Allowing for void return is trivial. Uncaught exceptions are *not* the way to tell the OS a program was unsuccessful. That is completely wrong. There is a *big* difference between "unsuccessful execution" and "aborted program". The rest you wrote follows those wrong assumptions.
The simplest papers are often the worst for bikeshedding.
It was a very good and enlightening talk. It was not about good software practices, but for those interested in how C++ evolved and evolves, and that really should be all of us, it could not be better.
A couple of notes: * If a certain integer-width doesn't exist, just disable the UDL in question. It's the same that we do with the typedefs, so I don't see an issue there. * I'm not fundamentally opposed to library-solutions here if we fix UDLs. I mean: A core-part of my suggestion is to fix those first and then use them. * `s` for string and `s` for seconds do *not* clash because the first only works on string-literals and the second only on integer-literals (maybe also on floating-point? not sure here). This is actually by design. And IIRC that fact was part of the justification. * Out of curiosity: Were there any actual arguments against putting `""s` into the global namespace or was this just another case of the committee being hyper-conservative to the point were it actively hurts the language? * `foo::23_bar` is clearly the best solution here. (Aside from putting the `std`-literals into the global namespace which really should be done as well.) * Well, even when C++11 got published I was so new to C++, that I wouldn't have made these points and nobody would have listened to me anyways... * I understand your point on `size_t` being special but I believe that we shouldn't approach language-design from a too technical perspective but ask what we need in practice to write good code. (On a personal note: Integers are currently one of the worst parts of the language that don't have a replacement and I would love to nuke them from orbit and replace them with something redesigned from scratch, but that is of course impossible.) With regards to me writing a paper, see my answer on byteswapping. I probably wouldn't be able to describe in specific detail how to fix the core-language literals, but I would assume that the library-UDLs shouldn't be too hard.
Don't we all want `operator.`?
Judging by what you have said about QList, it looks like it should be next to std::deque in your comparison table. std::deque also allows constant-time insertion at the front, and its elements remain in the same location in memory even after insertions and deletions (as must be the case with QList if it uses pointers internally as you said).
I had the same reaction when he said that. I suspect we're missing some deeper point, but I don't know what it is.
Why's that, my dude?
This works for contiguous ranges (e.g. `std::vector`, `std::array`, etc.), but does not work for any range that isn't contiguous (e.g. `std::deque`, `std::list`, etc.), and so it doesn't work in the general case.
We have two types in the stdlib that use `""s`: `chrono::seconds`, and `string`, which is why we have the namespacing. Also, I would *love* to make P1280 at the language level, however they're there to replace the `[U]INTXX_C` macros, and given that the `uint32_t` and friends are not even guaranteed to be *in* `&lt;cstdint&gt;` (implementations are not required to provide them), we can't really make it a part of the language *unless* we took a hard stand and said `i8` needs to exist. The problem is there are (apparently) some platforms where `char` is 32-bits, so you can't require it be everywhere.
That may work for arrays (or any contiguous iterator), but it wouldn’t work with std::deque or std::list. In fact, for list it would take a single pass through the original list to determine which “range” would come first. You shouldn’t have to depend on the original data structure to perform such operations. Even std::distance will fail (UB) when the first argument is the one which exists later in the collection.
&gt; Uncaught exceptions are *not* the way to tell the OS a program was unsuccessful &gt; The rest you wrote follows those wrong assumptions. The wrong assumption here is your assumption that all programs care (and *must care*!) about the distinction. Aborted program is necessarily unsuccessful. If the program can't fail in any other way, this is just as good. &gt; No, it is called *consistency*. Consistency with what? All the existing programs that already don't `return` anything? &gt; Ask yourself: do you like coding style guidelines? If yes, you should like writing `return 0;`! That's a fallacy ("doing X means you hate Y!"), as there are bad coding style guidelines and good coding style guidelines. Your coding style guidelines are bad, and I don't like them.
If you're the kind of person who's going to let good practice come second to a few keystrokes (and therefore are the kind of person who'd use `using namespace std::filesystem`) what makes you think you aren't also the kind of person who'd... ...let good practice come second to a few keystrokes, and `using namepsace std::fs`?
Alternately we can throw this entire debate out the window and people can just learn to type.
I liked the following talks. They are not in any way ordered. [Titus Winters "Modern C++ API Design" (Part 1 of 2)](https://www.youtube.com/watch?v=xTdeZ4MxbKo) [Titus Winters "Modern C++ API Design" (Part 2 of 2)](https://www.youtube.com/watch?v=tn7oVNrPM8I) [Robert Schumacher "Don't package your libraries, write packagable libraries!"](https://www.youtube.com/watch?v=sBP17HQAQjk) [Brand &amp; Nash "What Could Possibly Go Wrong?: A Tale of Expectations and Exceptions"](https://www.youtube.com/watch?v=GC4cp4U2f2E) [Kate Gregory "What Do We Mean When We Say Nothing At All?"](https://www.youtube.com/watch?v=kYVxGyido9g) [Kate Gregory "Simplicity: Not Just For Beginners"](https://www.youtube.com/watch?v=n0Ak6xtVXno) [Bob Steagall "Fast Conversion From UTF-8 with C++, DFAs, and SSE Intrinsics"](https://www.youtube.com/watch?v=5FQ87-Ecb-A) [Chandler Carruth "Spectre: Secrets, Side-Channels, Sandboxes, and Security"](https://www.youtube.com/watch?v=_f7O3IfIR2k) 
I see, thanks. The example was about the `gather` algorithm. AFAIK if that would return two ranges, then you would be easily able to combine the inner 2 ranges of the two `stable_partition` calls into one result range for gather, even for those containers, right?
I tend to agree that std::begin() and std::end() are pretty ugly. The justification for them, and the iterator_traits class, is that they work with arrays and any other class that you can't change... but in practice it's really just for arrays. IMO they should've bitten the bullet and just added the methods and typedefs to arrays and pointers to make them containers and random access iterators respectively. It wouldn't have broken backwards compatibility because if `a` is an array then `a.begin()` isn't valid syntax in C anyway. Rant over. But given there is now `std::array` that you can use if you really want C arrays, you might as well use `.begin()` and `.end()` methods on containers.
"Get Rich Quick! Using Boost.Beast WebSockets and Networking TS" - title is self-explanatory (and yes you can actually get rich using the application model I present in the talk).
A link would help.
Please read my third point again, the UDLs for `std::chrono::seconds` and `std::string` do **not** conflict! Also: What is the issue with making the availability of suffixes implementation-defined?
I prefer the using inheritance proposal a bit for that reason. I know how resolution works for inheritance, it seem just more natural to me.
He gives a disclaimer that it isn't his usual kind of talk at the beginning.
Really enjoyed this one: [CppCon 2018: Greg Law “Debugging Linux C++”](https://www.youtube.com/watch?v=V1t6faOKjuQ)
Overloaded `!` is not a useful motivation for that paper; even LWG - with its perhaps unreasonably high tolerance for overloaded operator shenanigans - is adopting the direction that `!` must behave as expected for boolean-y types.
Can't tell if trolling or serious.
You're not exactly unbiased though having presented the talk...
Great collection of posts, thank you! I tried to subscribe but couldn't find an rss feed, do you have one?
You have 3 integers only. You are writing and reading 5. Undefined behavior. 
I think what ThePhD's wrote about void main best captures it: &gt; All too often have I seen a pedant on Stack Overflow add to the comments or their answer about how wrong OP’s main is. I'd assumed you were joking w.r.t. not being able to ignore people who write "void main". Were you not?
I understand that. The first 5 numbers I u deter and also, but where do the huge numbers come from?
Undefined behavior is undefined. The compiler can do whatever it wants to do. 
Okay thanks!
I agree with the recommendations for the "What could possibly go wrong" talk. It starts off slow, but gets better. Also liked the talk about Spectre. &amp;#x200B; [CppCon 2018: Rishi Wani “Datum: A Compact Bitwise Copyable Variant Type”](https://duckduckgo.com/?q=datum+cppcon&amp;t=ffab&amp;ia=videos&amp;iax=videos&amp;iai=YdzbrFerlRY) [Jon Cohen "Ensuring Exception Safety Through Testing"](https://duckduckgo.com/?q=exception+safety+cppcon+2018&amp;t=ffab&amp;ia=videos&amp;iax=videos&amp;iai=XPzHNSUnTc4) This talk is kind of advanced and I didn't follow all of it, but it was interesting. &amp;#x200B;
Just found out that Clang currently discards unknown attributes and they don't appear in the AST. Bummer :(
What part are you having trouble with, and what have you tried?
My guess would be that because your array is on the stack, it could be just behind your 'count' variable : so, you could set her value to 100 in your loop when accessing the memory after your array (then, you have more iterations are more stack memory overwritten)
What is wrong with auto address = Address{}; address.zip().street()....; (Arguments of AAA aside) ?
Homework?
Chandlers Spectre talk and the rest was kinda boring (IMO)
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9r1ax4/why_does_this_happen/e8ddfak/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9r1jig/c_text_files/e8ddgov/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
1.) [Hana's compile time regular expressions talk](https://www.youtube.com/watch?v=QM3W36COnE4) 2.) Sean Parent's talk on UI (and I don't even do UI work)
What do feature attributes offer that feature macros don't? I'd I want to hide something from the compiler, the preprocessor seems to be exactly the place to do it.
I recommend that you look up how to stream input from a file (it will be similar to reading from cin). 
IMHO this is a really smelly way to use the builder pattern. Usually, what differentiates builder pattern from setters and getters is that in the builder pattern you just want to do these things once, at construction time. But, your class has all these methods that allow free setting of data members, meaning that your class just has no encapsulation at all. For that reason, you would typically define a separate class for building purposes, and use it like this: auto addr = AddressBuilder{}.Line1("...").Line2("").State("CA").Zip(12345).build(); And build simply returns by value. In this approach, the final `addr` object that is built no longer has methods like `Line1`, and such. I think it's also pretty weird and suspicious looking to do `auto&amp; addr = ....`, the expression on the right still looks like a temporary and normally you can't bind non-const lvalue references to temporaries at all. You ended up using `std::move` in either case in your example, so I don't realistically see any advantage to having a reference rather than a value (you might save a bit of performance, but it also might get RVO'ed). If your compiler supports designated initializers for the types you need, consider just using a simple nested strut that's passed to the constructor instead. Hopefully in C++20 builder pattern can officially die a horrible death.
I know how streams work but I might be doing something wrong logically. Thank you for the assistance
No problem. Thank you for your support!
100% serious, check out the repo: [https://github.com/vinniefalco/CppCon2018](https://github.com/vinniefalco/CppCon2018) The video should be up later this year.
Robert's packaging talk was pretty great too, I learned a few things and I have adjusted my development workflow thanks to it.
Please fix the formatting of your post.
&gt; Please read my third point again, the UDLs for std::chrono::seconds and std::string do not conflict! I had missed that point. My mistake. &gt; What is the issue with making the availability of suffixes implementation-defined? There isn't, as long as its part of the library. The language cannot make *some* syntax of the language optional. The compiler vendors can, but they would need good reason, and why would they implement that when it can be offloaded to the stdlib?
Without more detail about what you are trying and what is going wrong it will be difficult to provide more detailed answers. 
It's not "100%" fine, although it gives much better control over what happens. It drops down to the level of a glob import / import everything, which is still not always appropriate.
Any list will be instantly out of date. Any general benchmarks will also be wrong for whatever your actual code base is. So try it and see.
you already used the count to compute the average. For the max, think about as similar real world case. consider a friend handing you one playing card at a time, then after several cards asking what the highest value card you saw was. this is the logic you need to embed in your loop. example: look at first card and remember its value while being handed new cards { look at the new card if its value is more than the highest value so far then remember it } report the highest value
you already used the count to compute the average. For the max, think about as similar real world case. consider a friend handing you one playing card at a time, then after several cards asking what the highest value card you saw was. this is the logic you need to embed in your loop. example: look at first card and remember its value while being handed new cards { look at the new card if its value is more than the highest value so far then remember it } report the highest value
you already used the count to compute the average. For the max, think about as similar real world case. consider a friend handing you one playing card at a time, then after several cards asking what the highest value card you saw was. this is the logic you need to embed in your loop. example: look at first card and remember its value while being handed new cards { look at the new card if its value is more than the highest value so far then remember it } report the highest value 
Thank you...that's helpful 🙏🙏
Thank you...that's helpful 🙏🙏
I didn't use count for average
I guess CPP Con is determined to go full on click bait like everyone else.
I guess CPP Con is determined to go full on click bait like everyone else.
&gt; What is fs when reading code and you don't know C++(20) good enough? What else can it be? Especially since it'll onle be a part of other path-related types.
&gt; What is fs when reading code and you don't know C++(20) good enough? What else can it be? Especially since it'll only be a part of other path-related types.
&gt; What is fs when reading code and you don't know C++(20) good enough? What else can it be? Especially since it'll only be a part of other path-related types.
Sorry, P1028R1 is a bit out of date. Last updated in August or something. It'll get fixed for R2.
Sorry, P1028R1 is a bit out of date. Last updated in August or something. It'll get fixed for R2.
Sorry, P1028R1 is a bit out of date. Last updated in August or something. It'll get fixed for R2.
Sorry, P1028R1 is a bit out of date. Last updated in August or something. It'll get fixed for R2.
Sorry, P1028R1 is a bit out of date. Last updated in August or something. It'll get fixed for R2.
Sorry, P1028R1 is a bit out of date. Last updated in August or something. It'll get fixed for R2.
Sorry, P1028R1 is a bit out of date. Last updated in August or something. It'll get fixed for R2.
Indeed, but not with the given implementation, and an implementation that supported optional return values would no longer be so strikingly simple and clean.
Indeed, but not with the given implementation, and an implementation that supported optional return values would no longer be so strikingly simple and clean.
Indeed, but not with the given implementation, and an implementation that supported optional return values would no longer be so strikingly simple and clean.
Sorry, P1028R1 is a bit stale despite only just being published. R2 for Kona will be better.
Sorry, P1028R1 is a bit stale despite only just being published. R2 for Kona will be better.
Indeed, but not with the given implementation, and an implementation that supported optional return values would no longer be so strikingly simple.
&gt; It is just annoying the same debate over and over again Then don't debate it again. It's a relic from C that's not going anywhere.
But you have to choose one style...
`Address &amp; Line1(std::string l1)` is toxic, `Address &amp; Line1(std::string l1) &amp;` is correct; don't return lvalues to rvalues unless you are extremely clear about it. Doing `Address Line1(std::string l1) &amp;&amp;` is an option, but as noted this is a bit verbose. Address Line1(std::string l1) &amp;&amp; { return std::move(Line1(l1)); } while not very long, it adds up. Instead warn the user: auto&amp; addr = as_lvalue(Address()).Line1("...").Line2("...").State("CA").Zip(12345); which at least has a big red flag of a cast from rvalue to lvalue explicitly in it. We can go further: template&lt;class T, class F&gt; auto as_lvalue( T&amp;&amp; t, F&amp;&amp; f ) { return f(t); } which forces return-by-value. auto&amp; addr = as_lvalue( Address(), [&amp;](auto &amp;addr){ return addr.Line1("...").Line2("...").State("CA").Zip(12345); } ); which fails to compile, as it should, forcing the user to do: auto&amp;&amp; addr = as_lvalue( Address(), [&amp;](auto &amp;addr){ return addr.Line1("...").Line2("...").State("CA").Zip(12345); } ); and reference lifetime extension works. Of course you don't need the fancy `as_lvalue` helper; auto&amp;&amp; addr = [&amp;](auto&amp;&amp; addr){return addr.Line1("...").Line2("...").State("CA").Zip(12345)}( Address() ); All of this piles on top of the fact that `Line1` and other chaining methods refuses to be called with rvalues. So it forces the caller to convert the rvalue into an lvalue, which also warns them they need to do the inverse. These patterns make the inverse-as-lvalue *harder* than inverse-as-rvalue. 
Sorry, P1028R1 is a bit stale despite only just being published. R2 for Kona will be better.
I have no comments on the library itself since I am not even near opengl stuff, sorry about that, but I've checked the Github Page, I should say that the amount of detail you put on the project page is really impressive. Often it is hard to find a decent roadmap or work in progress section for libraries in Github but this has detailed projects-section, changelog and [WIP] pull requests from the author himself.
&gt; 6-pointer-size strings with virtual calls on every move are lightweight, seriously? They're a reasonable balance of tradeoffs given competing factors. The problem is that an error code domain may need to ask the OS for localised translations of error messages, which is expensive. So we permit that, and their caching, and the return from that cache using reference counted management. If you look at the Microsoft COM code domain for example, we even need to do a COM call per message retrieval as we have absolutely no idea what the COM component will return. Bear in mind COM error codes are theoretically infinite, best an implementation can do is cache the most recently used ones. Or, just let the reference count free the storage when it hits zero. For the same reason, string views are out. But so are strings, as they drag in the STL allocator and codec machinery, and we want those left out. I also want to emphasise that atomic reference counted strings are not the default, they're an option. The default returns an unmanaged static const char string literal. It's quite efficient, and compiler correctly optimises out most of the six pointers of storage under LTO. &gt; How is status_code&lt;void&gt; a descriptive name? By analogy with future&lt;void&gt;, I suppose its payload is empty? Unknown payload. Unmoveable, uncopyable, unconstructible. It's an erased form. &gt; By analogy with vector&lt;bool&gt;, we should avoid template specializations, which have significant semantic differences. They are not semantically different, rather there is the valued status code, and two forms of erased editions, one of which is not available if its requirements are not met. &gt; Why are protected members of status_code_domain underscored? They are accessible to users of this API, so their usage should be as nice as possible. I prefix underscore non-public member functions because they get different syntax colouring in some editors. I fully expect WG21 to remove that, but that's on them.
There is a "Valgrind (external command)" option.
interesting approach as well, and might be more flexible as it builds from more basic components. I wonder how the codegen of your approach is.
There's a Sean parent talk? That's exciting!
https://www.youtube.com/watch?v=QM3W36COnE4 https://www.youtube.com/watch?v=0DDrseUomfU https://www.youtube.com/watch?v=LfRLQ7IChtg&amp;t=860s
That man has always something interesting to say on a broad variety of subjects.
Making a major, breaking change in the language has no cognitive overhead..?
Calling correctness 'pedantry' in some cases and 'precision' in others is a reflection on the person speaking, not on the person calling attention to it. ;-]
That's quite literally Parkinson's Law of Triviality, where the term bikeshedding comes from. And, although the $2000 bike shed could be resolved in a single committee meeting, the debate on spending $57 annually on coffee, for a different committee, would extend over more than one, with much acrimony. 
Thank you for the kind words about `view::maybe`. Written at nearly the last minute, but I've used toList on similar types for ages. I sort of assumed it was going to be there already. &lt;g&gt;
&gt; You don't know me, and you're resorting to personal insults — ... &gt; Calling adherence to correctness 'pedantry' in some cases and 'precision' in others is a reflection on the person speaking 🤔 
Both D3D12 and Vk just require all the boilerplate to be written that is handled for you in D3D11/OpenGL. The real issue is support. Hard to test and make D3D12/Vk work on all configurations if you're independent.
The actual quote is &gt; Calling adherence to correctness 'pedantry' in some cases and 'precision' in others is a reflection on the person speaking, not on the person calling attention to it. Changing the context and entire = meaning of a quote is exactly the juvenile bullshit to which I was referring. I won't engage you further.
Emacs isn't a text editor, it's a lisp machine that happens to have good text buffer manipulation in the standard library it uses. I've been using IDEs since Turbo Pascal. And my emacs config has a nearly 30 year history. 
Having your full comment there doesn't change my reading. Here's how I read it, in case I misinterpreted: - In "is a reflection on the person speaking", the person speaking is the person calling someone or something pedantic - In "the person calling attention to it", the person calling attention is somebody pointing out the detail (it), which has been called pedantic by the other person Was this not what you intended?
Since things are getting testy down below I'd like to say that I didn't include your point about hiding the return code mechanism in the quote because I think it's a great argument against the proposal. The int return type is a useful breadcrumb for students. Apologies for not acknowledging that in my other comment.
Make sure to try also query (https://github.com/cquery-project/cquery) instead of the default C++ plugin. For me it provided a lot better results, when after I was able import the project via a compilation database.
The author's blog is pretty great too!
You mean the excitement operator? You use it to return an excited view of a string.
That video has not been made available yet. The Cppcon team is releasing a couple of videos each day so we will have to wait just a little longer for Parent’s talk.
&gt; ~~handled for you~~ presumed on your behalf Fixed that for you ;) If you just want a bog-standard configuration to draw a few triangles, you should be able to use someone's 500 line library so that you can 1-line `SetUpCommonVulkanConfig(&lt;5 most common parameters&gt;);` There's some discussion in the community about "Why doesn't this exist already?". Or, you could just use OpenGL/DX11. The whole point of Vulkan is to give developers game-console like levels of control and responsibility. If your app does not need anything special, don't pay for the option.
Lol, ok, I did it.
Removed - try ProgrammerHumor.
I'm not exactly sure, and that's what concerns me the most. I'm not sure it's bringing more to the table that the preprocessor, but I like the constexpr function \`std::feature\`.
I don't think there's really one way to do a C++ project. The ecosystem is not nearly as standardized as many other languages, so you will find a lot of different variations. Some people like separate include and source directories, personally I prefer to just put things together so they're easier to find. Besides, if you use templates there is not much distinction between source or header files anyway. I see you're already using CMake, so that should provide with a reasonable toolchain. For testing I like to use [Catch2](https://github.com/catchorg/Catch2). 
I can't give you much advice on workflow or anything, but I took a look at your CMakeLists.txt file and have some suggestions. Don't use `include_directories`, use `target_include_directories`. `include_directories` applies to the entire project, which usually isn't what you want, whereas `target_include_directories` only applies to the specified target. Always opt for the `target_xxx_xxx` versions. Also never use `file(GLOB)`. CMake can't track your source files for changes if you do that. Listing them manually, while a bit of a pain, is the best option. I think one of the latest versions added a better `GLOB`, but the docs still suggest listing the files manually.
Yeah there is tons of variation in every aspect. However, I would say the vast majority of projects I have looked at separates their source and headers. Often times people only need the headers when integrating the work, so it makes sense for those to be separated. Nothing wrong with your way though, it just seems less common to me.
It's the wild west
The workflow is very similar to the workflow of JavaScript project : come up with an overall design, sketch out the structure and start somewhere. As an individual developer, you pick a task and write the corresponding code, and the test explaining what it does/proving it does it right. The main difference I experienced compared to a JS project is that the individual features often don't make sense by themselves whereas in the front-end world you can usually show what a given module or component does by itself. What it means is that we rely even more on unit tests to communicate the intent of a class.
You'd think one of the oldest languages would have it together more...
Not any different from Javascript or Python projects, except the CI build configuration matrix is normally a bit wider. If you want an example, https://github.com/nlohmann/json is running a pretty mean workflow, CI setup, security checks, code coverage, thorough unit tests, roadmap planning etc. 
Is there a warning for this maybe to feed to -Wall? That I could get behind, otherwise, while I see where you are coming from, I feel like it's a change with far too many implications for little (to no) gain.
Mine is: 1. Code 2. Add or adjust tests 3. Build 4. Run a simulation to see the code working 5. Commit 6. Fuck I forgot to run unit tests 7. Build failure due to unit test failure 8. Fix tests 9. Commit 10. Wait successful build (if not, goto 7) 11. Call it a day 
If your project exposes an external API (eg: it's a library) then the headers for the public API can be separate. Even then it's not strictly necessary because if your project has a build script and installer, it can always install the public headers in an include/ directory at the destination regardless of where they come from. The only thing that putting them in a separate directory allows is for people to build against a source checkout, or for the build script to glob a subdirectory instead of having to have each public file specified explicitly. Apart from that, I see no reason to separate the header and source files, it just makes for more switching between directories when editing. Many large projects, including Mozilla, do it this way. &amp;#x200B;
did they do a 'grill the comittee' this year? I feel like cppcon2017 had more interesting/amazing talks than 2018; or maybe they're still going to trickle out later maybe because 17 was a release year?
Faster then your shadow?
There is no universally accepted workflow for big C++ projects for several reasons, with two of the most important being listed here: 1) A lot of big C/C++ projects are old, some before the wide internet availability, and there's no consistent toolset for them to use. 2) Big C/C++ projects are really big. They are in the millions of lines of code, thousands of files, with compilation that lasts for hours. The usual big JS project is modest sized in the C++ world (to make it easier to understand the scale of things). A lot of things don't work the same in the C++ world and the JS world. You can't have, for example a fast „write test, test breaks, fix code, run test, test red, fix code, all tests green” flow, because running tests is painfully slow. You'll probably want to fix more than a line at a time before re-running a test. So workflows involved in the C++ projects are really flows dedicated to tools external to your project. You have a CI flow, in which you need to make sure that all tests run properly on the CI machine after checking in. You have a certain flow for adding a file in the project, because tools like cmake are so poorly designed that they can't really follow the changes to your program. You have different flows to follow based on the needs of your project - there are many ways to solve your problem, and each comes with its own flow. In a sense, the C++ world is freer than the rest of the universe; you make your rules as you go, you adapt to the needs of the project. The flows come organically from the needs of the project, not because the creator of &lt;random-dictionary-word&gt;.js decided that the flow should look like this and who doesn't follow this will have big bubu. You'll find soon that following some other folk's workflow doesn't work, unless they are part of your team to adapt their flow to your project. If I was to give one flow suggestion: develop your own. Make sure you focus on the things that are important to you; is it security? is it testing? You make sure that what you need is what you do. It's hard to start, but after a while, using your own flow is its own reward.
But the debate remains. You can't declare more variable in one line. There is no such a feature in the language now. In a solo project this isn't a problem but working in a bigger company with multiple C++ projects and multiple C++ team.
In a bigger company with multiple C++ projects and multiple C++ team there is someone to make an executive decision. The "problem" here is manufactured.
That I can spot a glaring flaw in your logic means C++ isn't the language for me? Do you actually expect anyone to take you seriously..?
I feel much safer now
This might sound really wishful, but is there no *neater* way to include source files all together AND have it detect changes? Listing out all files seems a bit "hacky" (?), if you get what I'm saying.
&gt; Perhaps, string_ref could be reduced to just 1 intptr_t instead of 3 void* without loss of generality, as it was done with value of error? The 3 void pointers are to account for unusual `shared_ptr` implementations, most of which occupy two void pointers, but some may occupy more. Or some code domain may need to store a shared ptr, and an additional piece of state. The number wasn't chosen without good reason. I also think you're over micro optimising here. Fetching a message string is always expensive, it is unavoidably non-deterministic due to the potential memory allocation. Remember *you don't know* what an error's domain is, its message fetching function may be cheap or extremely (milliseconds!) expensive. Which is exactly the same as for `error_category` in today's `&lt;system_header&gt;`, which currently returns a `std::string` which is much worse again. The goal in P1028 was to be much lighter weight than the `std::string` returning `error_category::message()`, which is achieved, as logging often needs to be fast, and those needing fast logging will greatly appreciate the caching and reference counted lifetime. But we are constrained by hard needs, in particular the hard unknowability of what message strings could be. Regarding breaking out `string_ref` into the `std` namespace, if WG21 would like to do that, then great. A potentially owning, string view like, object would be a useful addition to the standard.
Faster than Chuck Norris' shadow
It's not the language's fault the management is shoving deadlines down developers' throaths and forcing them to hack around instead of having the time to think and do it right. Also, there's the whole thing about caring about the product of a hobby project vs the product of a paid project and how that affects your productivity.
It's not fear - many key things like socket connections, database cursors and `std::unique_ptr`s are intrinsically uncopyable.
That's why https://en.m.wikipedia.org/wiki/Test-driven_development exists.
Surprised this didn't get upvoted more - this is a nasty little trap that can produce UB unexpectedly. I vaguely knew there was some issue with reference lifetime extension, which is why I rarely use that feature. But I had no idea it was UB! Great article. Now I understand the extent of the problem, I'm more likely to use reference lifetime extension for what it was intended for.
That would require to scan the filesystem on every build. Just touch the CMakeLists.txt once after adding a file and you're good.
The committee are quite good at avoiding bikeshedding, except perhaps on naming. Rather, a really well written simple paper often touches a nerve. That sets people off, people read what is truth to them, better still if their truth looks like other people's truths so everybody thinks everybody else agrees with them, but in fact subtly don't.
Seeing this written in a nice blog sure is good for learning though.
It should be an option. For small projects, it is worth it to simply re-scan.
&gt; Listing out all files seems a bit "hacky" (?), if you get what I'm saying. No, it's not. You should do it, it's good practice. It's minimal effort - you will not add or remove files that often, and even if you do, it's just changing one line from time to time.
Thanks a lot for the appreciation! :)
I started writing English subtitles for the previous video, made 1/3 of the talk, took me more than two hours. Should I start over? I'm native Czech language speaker so I understand common mistakes Czechs make when speaking English so I could probably better comprehend what she wanted to say.
Sorry pal, this will have to go on the backlog.
Far too many people miss this tiny little thing, unfortunately.
We use phabricator at work. Like [LLVM](https://reviews.llvm.org/) does. Phabricator CI + build system and arcanist lint when diffing creates an easily enforcible workflow. There are some other major projects using phabricator as well like GHC for example. But yeah, something like a linter + CI system would be the first steps for any half decent project. Up to you to choose which linter and CI.
Your coding style for constructors is horrific. Still though, I refer a lot to your code when struggling with ASIO.
This is exactly what I was looking for. It weird I never noticed Labex before today, it is amazing.
Can you please be more specific? Maybe it is something I can improve!
Just nasty to read, that's all.
Umm...okay, but which part? The formatting? The enable\_if constraints? The definition?
Yes, the vertical-ness of it. People have large monitors these days
&gt; How are tests set up lol
\&gt; duplicates &amp;#x200B; So sort them. This way duplicates stand out. 
Ha! Check out some production Fortran code some time...
A better way: ( ͡°int* ͜ʖ ͡°int) x = 10;
&gt;My concern is not typing (that's what I have autocomplete for). My concern is readability, which suffers noticeably when you prefix every second function and type with std::filesystem. Which is solved by `using fs = std::filesystem`.
It seems like you're writing your tests after you write the code. It should be the other way around. 
It's mostly just screaming "FUCK!" or "WHAT THE FUCK?!" a lot
You are creating a **temporary object** that holds a socket somewhere inside and then you want an l-value reference to that socket? Are you sure? 
That's irrelevant :) The main point is that tests are automatically ran by our CI but not when building on the dev machine. Is there a flaw in the workflow? Of course. Is that related to TDD? Hell no! :)
1. Open up Rhapsody 1.a Fail to get license 'cause the dept failed to pay IBM again 2. Call it a day
hahaha, i know what TDD is. I also know that religious following of any practice is ... not healthy (to put it mildly). 
In the 3.12 version, they made [such an option](https://cmake.org/cmake/help/v3.12/command/file.html#glob): &gt; If the CONFIGURE_DEPENDS flag is specified, CMake will add logic to the main build system check target to rerun the flagged GLOB commands at build time. If any of the outputs change, CMake will regenerate the build system.
As others are touching on; there is a lot of variability in potential style. I glanced through the project, here is what I would start with: * Make "src" and "include" directories at the top level (not nested). * Research doxygen, and use that comment style on all of your methods and classes in the header. You can generate documentation from it, but you don't even have to. * Menu class could have static members, that way you don't need the object in your main function. * You might consider a build shell script so users can just run "./build.sh &amp;&amp; ./2048" * Little of your code has comments. There's something to be said for self-documenting code, but I don't see anything. * No error checking or useful clear error messages. For example "collectStatistics()" returns false if the file exists, but you never check it. Super important on larger projects.
I was addressing your general claim: "People are far too afraid of copies." But why shouldn't it be a temporary object if you only need it for a short scope?
&gt; I did not create the project ground-up adhering to C++ conventions and rules or even having a proper workflow Create/copy some coding style and fix the code to adhere to it. * use something common such as BSD/Allman * you can use [indent(1)](https://linux.die.net/man/1/indent) utility to do most of the heavy lifting * style needs to be consistent &gt; I am a JS developer primarily Double spaced indent already gave you away. &gt; how are professional, big, C++ projects maintained in the real world, where there are many collaborators? Don't think this is applicable to your use case, you should be asking how are open source projects maintained. Professional projects still have hierarchical command structure which cannot be enforced in open source. You probably want to look at linux kernel model and scale that down 100 times. &gt; How are tests set up You probably want to integrate something like [Travis CI](https://travis-ci.org/).
Been there, done that - reincarnation!
Real word problems of TDD are imho: * you can't travel to past and write tests for legacy code * company is already paying for QA testers, they can't write tests before you create code, else they would be sf architects * running entire test suit can take minutes/hours ... * ... or be impossible/difficult (hardware, UI, distributed systems) * time spent doing tests is time spent not doing coding * time == money * management won't allow it * refactoring is actually more difficult than it normally is * ... I couldn't agree with you more that TDD isn't one model fits all solution although it works quite well with small-medium sized projects and single team of people in same location.
Yeah, maybe I'm over optimising. It also seems like in case I know the error type (no type erasure), I will be able to fetch error information directly from `status_code&lt;T&gt;`, avoiding `string_ref` altogether: void open_file() throws; try { open_file(); } catch (permission_error e) { cout &lt;&lt; e.filename() &lt;&lt; e.required_permission() &lt;&lt; e.actual_permission()); } catch (file_locked e) { cout &lt;&lt; e.filename() &lt;&lt; e.lock_owner(); } catch (std::error e) { cout &lt;&lt; e.message(); }
The above wouldn't be idiomatic under [http://wg21.link/P1095](http://wg21.link/P1095). This would: void open_file() throws(file_io_error); // new proposed static exception specifications try { open_file(); } catch (file_io_error e) { // Non erased, no memory allocation, very fast // Do semantic matching ... if(e == std::errc::operation_not_permitted|| e == std::errc::resource_deadlock_would_occur) cout &lt;&lt; "Failed due to " &lt;&lt; e.message() &lt;&lt; " in file " &lt;&lt; e.path1() &lt;&lt; std::endl; } catch (std::error e) { // Causes implicit decay to erased std::error // (probably memory allocation) // But semantic comparison works just as before ... if(e == std::errc::operation_not_permitted|| e == std::errc::resource_deadlock_would_occur) cout &lt;&lt; "Failed due to " &lt;&lt; e.message() &lt;&lt; std::endl; } So don't catch specific errors by type. Catch *sources* of error by type, let the polymorphism in the value do (constant time) dispatch.
But what is your solution? It sounds like you work alone. If you do, GLOB may be fine. But if you work in a team, and you check in a new file, and every other dev on your project has to remember to manually run CMake, it's going to be annoying for everybody involved. It's a matter of pros vs cons. One person who adds a file has to add it to CMakeLists.txt is much better than many people having to understand random build errors.
&gt; I just did travel to the past and wrote 100% coverage for a fairly large module of legacy code i had written about 5 years ago. Good mocking and test framework are essential. I'm not arguing that it can't be done. Most managers I've ever came to contact with care about features, that's what they get their bonuses for and that's what sells. &gt; I'm confused. QA people have normally nothing to do with unit tests ? Unit tests are entirely in the developers domain. Fair point. 
I took a look at your repo again. Good on you for adding tests, however, as-is, your tests just verify that your program doesn't crash. Add some checks in there for expected values. For example, the size of a newly constructed list should be zero, it should grow to one once you add an element, go back to zero when you remove one, etc. When you add an element and then look it up, you should get the value you put in back. I'd also add a test for LinkedList&lt;SomeStruct&gt;. A linked list of bools/ints is not very useful.
Happy Cake day. 
Thanks for the advice, i was thinking about some problematic types and I thought about writing tests that write to a file and then the test script compares the 2 files, one which the test program outputs and one which has the correct values. Thanks a lot!
I did that for 4000 lines of Mathematica -&gt; python. It was hell.
Indeed. But the ranges proposals introduce overloading `operator|` as syntactic sugar for creating a data "pipeline", for example: std::vector&lt;MyType&gt; vec = ... auto view = vec | view::transform(func1) | view::transform(func2) | etc If we're going to get this syntax for ranges (and it seems like we are) then it would be nice if monadic functions on optionals worked the same way.
FYI: I didn't downvote you, but the people who are doing so are probably doing it because being a 'web developer' is not a very good source for being well-versed in the best practices for a professional c++ workflow.
Would that pipelining work with any free functions, not just ranges? 
What I mean is we could have something like std::optional&lt;int&gt; opt = maybe_get_int(); auto opt2 = opt | map(func1) | map(func2); where `opt2` is an optional of whatever `func2` returns. (But `map` would probably need a different name so as not to clash with `std::map`). Now I think about it, this is quite a lot like Range-V3's `action::transform`...
```data_base.open("database.txt", ios::out);``` hmmmm
&gt; For C++ questions, answers, help, and advice see r/cpp_questions or StackOverflow.
`ios::out` you want to read.
I deleted that, still not working
There's also a proposal for "workflow operator" (`operator|&gt;`).
&gt; Or, you could just use OpenGL ? The whole point of Vulkan is to kill off OpenGL. If apps aren't in the process of transitioning (or haven't already), then they're going to be in a world of hurt once GL gets put of the chopping block.
After trying all sorts of 'smart' things, indeed memcpy it is : [https://godbolt.org/z/qyGFXo](https://godbolt.org/z/qyGFXo) Those smart things were mostly optimized correctly by gcc, clang. for MSVC memcpy is the one that works.
 do { data_base &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e; if (name == a) test=1; } while (!data_base.eof()); Your while loop isnt even run once. A debugger would have told you that if you had used one. Next time go to r/cpp_questions
I would strongly disagree with this. You can either run your own hosted Jenkins boxes. And if you can't afford to run a few EC2 instances to do your builds, one should have no business in writing software with the intent do sell the product in the first place. Plus, for anything kept in open source, most cloud-hosted CI services like Travis, CircleCI offer reasonably sized free packages. 
It seems like you dont really know much about Cpp. Maybe you should try a more simple project and learn the language first. Instead of trying to run a snippet from another project, you should just experiment with ifstream until you know how it works
Just because I said people are far too afraid of copies doesn't mean there aren't legitimate scenarios, where a copy is too expensive or has the wrong semantics. But the scenario presented in the post (and similar ones I've seen over the years) isn't one of them.
Indeed, but not with the given implementation, and an implementation that supported optional return values would no longer be so strikingly simple.
There isn't really like a big pool of questions everyone uses so just trying to study solutions in the hopes you're asked that question is a bad idea. The purpose is to assess your thinking process, not that you get the right answer. If you already know the answer then they don't get to see how you work up to it which defeats the purpose. Your best bet is to practice the types of questions that are asked in interviews so you learn how to approach these problems and work through them. Cracking the code interview is good for this as contains many common problems for different topics, and it gives you hints like an interview might give if you were struggling so you can work through the problem. In the early chapters it goes into more detail about what I said above as well and includes great advice, so I recommend reading that too.
A dozen of agents will be enough for a small team to build and run unit tests, but we are taking about running integration tests which can indeed take hours to execute. So in the worst case you'd need like 3 times more agents than the number of active developers in your team to keep things running smoothly. Nightly builds can kind of solve this though. 
As I already said, the docs still suggest that you list them manually even though this exists now. I'm not 100% sure why.
Khronos has been very vocal that OpenGL is not going away. There will continue to be new versions of OpenGL released for the foreseeable future.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9rcxb4/recommend_book_for_a_beginner_2018/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt;How is sharing these interview questions unethical? Am I really supposed to explain this? It is kind of like the difference between uploading a whole movie on the internet and sharing the dvd with your close friends.
&gt; Your best bet is to practice the types of questions that are asked in interviews Well, this is my purpose actually. And achieving this would be through looking at real world examples. Am I not right? 
"O god why did we not write this in C#"
My answer would be a no. Would I also need to explain my answer? Or is it just plain wrong...
10/10 would code again
1. Write C++ code for 3h straight 4. Compile and run 5. Works at first try 6. Fight with QML for the rest of the day https://imgur.com/gallery/Q3cUg29
What kinda puts me off is that I don't know any of their presets apart from LLVM style. &gt; LLVM, Google, Chromium, Mozilla, WebKit indent comes with common unix styles: &gt; GNU, K&amp;R, Linux-kernel Might be my systemic bias, those are the ones that I immediately recognize because I code predominantly for Linux.
Yes? I think it would be accurate to say most people on this sub are not your code friends and you are trying to get people to share these questions on the internet. By your own definition, what you are doing is unethical. 
Raw string literals (`R"(...)"`) makes regular expressions much easier to write out. You can put non-empty delimiters in too: `R"UNiQuE(now i can use "(" and ")" inside too)UNiQuE"`
Tell this to the compiler.
The custom delimiter is so helpful
[removed]
Your comment has been automatically removed because it appears to contain disrespectful profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9rcg8t/c_interview_questions_midsenior/e8fyfwg/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; most people on this sub are not your code friends I don't know what "code friends" are, but I have a belief that some certain people can become regular friends through helping each other on the internet. It is unfortunate that you can't grasp this.
That only works if you know what the output looks like before you write it. Without that, writing R&amp;D style code, you literally have nothing to test because there is nothing that is known to work yet.
For reference: [https://en.cppreference.com/w/cpp/language/string\_literal](https://en.cppreference.com/w/cpp/language/string_literal) &amp;#x200B;
Haha ok man, calm down. This isn't a test, I'm just trying to figure out why you think this is unethical. 
5/7 perfect score
Great for embedding GLSL programs: const char* frag = R"GLSL( #version 450 #extension GL_ARB_separate_shader_objects : enable layout( location = 0 ) in vec3 fragColor; layout( location = 0 ) out vec4 outColor; void main() { outColor = vec4( fragColor, 1.0 ); } )GLSL"; That way the preprocessor won't choke on the GLSL preprocessor directives.
I am copying and pasting the header info of a test I was given a long time ago. I removed the company name. &gt;// This test is the proprietary and confidential information of \*\*\* and may not be &gt; &gt;// replicated, copied, disseminated or posted without the express written permission of \*\*\*. &gt; &gt;// (c) 2011 \*\*\*, Inc. &gt; &gt;//... Also several hackerrank tests I took just disappeared after submitting the assignment. Clearly they don't want interviewees distributing the "questions" on the internet. Not complying is simply unethical. (At least for me.) &amp;#x200B;
I feel a light 7 on this one
catch is [my favorite](https://github.com/ryanhaining/cppitertools/tree/master/test)
\&gt; share it with me &amp;#x200B; \&gt; I will never share
Glob was the main reason I started using CMake on my first C++ project on Linux, because I was so annoyed adding files manually to makefiles.
Where did you learn how to use SIMD instructions (i.e. SSE, AVX, etc.) in assembly?
&gt; we should share it among ourselves! Learn English.
I work on a fairly large project with 5 devs and rerunning CMake once in a while is really a non-issue. Some IDEs/editors rerun CMake on start, e.g. VSCode with CMake plugin.
Ah yes, clearly. Maybe next time, remember not everyone is like you and may not have seen something like this before hand. A simple, "they state that at the header" would have been nice instead of being rather insulting and talking down to people. 
Who is "ourselves"?
People who want to share.
If you need explanation for common sense, I have bad news for you. Clearly this question was not targeted at you, stop wasting everyone's time.
Yes. It was a joke. Totally. I'm a funny guy, what can I say.
Haha OK sorry, didn't realize I was wasting everyone's time. I thought I was just wasting your time :) 
Yes :D
The best way would be to read the file in a data-struct like struct database_data { string name; int b, c, d, e; }; And then you can work with it without reading it again and again. The ios::in shouldnt be necessary, its implicit for ifstreams (and it worked in my test without)
One var per declaration. Problem solved. You should be initializing when declaring anyway. Bare pointers are smelly too (in modern enough code). . Fallinghis pitfall is already extremely smelly code in the first place. 
Even more reason to have them on their own line. 
Cool! That's much easier than escaping or double quoting and having to remember which of the two it is....
&gt; QML Am I the only one who thinks $480 a month is crazy for a development tool? 
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9rebwp/help_with_a_c_file/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
How am I supposed to retrieve attached data when needed, after the `status_code` has been converted to `std::error`? Different people have different expectations and usages for `std::error`. It can't replace dynamic exceptions if downcasting is not allowed. void open_file() throws(file_io_error); void generic_intermediate_layer() throws; void cares_about_file_errors() throws { try { generic_intermediate_layer(); } catch (std::error e) { std::optional&lt;file_io_error&gt; maybe_fe = dynamic_error_cast&lt;file_io_error&gt;(std::move(e)); if (maybe_fe) { file_io_error fe = std::move(*maybe_fe); std::cout &lt;&lt; fe.filename() &lt;&lt; " permission required"; throw fe; } else { throw e; } } } `dynamic_error_cast` can easily be implemented by comparing `e.domain()` with `T::domain_type::get()`. It can also look inside `status_code&lt;indirecting_domain&lt;T&gt;&gt;`. Even better, there could be a hook like: class status_code_domain { protected: virtual optional&lt;std::error&gt; _nested_error() const noexcept = 0; }; Then `dynamic_error_cast` will also work with inevitable `boost::error` and others. Most importantly, if it can be implemented as a library solution (and it can!), why limit users to the ugly syntax I've shown above? The same could be expressed much better as: void open_file() throws(file_io_error); void generic_intermediate_layer() throws; void cares_about_file_errors() throws { try { generic_intermediate_layer(); } catch (const file_io_error&amp; e) { std::cout &lt;&lt; fe.filename() &lt;&lt; " permission required"; } } With this, exceptions and errors will be almost completely interchangeable.
Questions I typically ask: - tell me about a project you previously worked on - what went well - what problems did you run into - how did you handle them - &lt;some specific question, where you look surprised that I know that much about that problem space (but really, at some points, all problems look like something I've seen before)&gt; - do you think it makes sense that leaves are green? Would some other colour make more sense? Why? (I know you were looking for actual coding questions, but I find just having a conversation about code - or non-code even - to be more revealing.)
5 devs isn't a fairly large project. 5 developers is a fairly small team. The shared core libraries repo on one of the projects I'm on has about 40 people contributing to it regularly, split across about 5 teams. Large is when reading every commit overwhelms your email. 
Pain. Slow pain. 
&gt;How are tests set up Oh, such charming optimism! 
Nice work on the HTTPS support by the way. I saw you linked to a reddit comment where you adressed you didn't have any JS bloatware but that was kind of not getting the whole picture. Now with HTTPS nobody should be able to intercept traffic nor *add* their own bloatware or ads either. In theory by using Github the downloads would have already been secured but someone could have redirected the links on your site to a similarly named but different repo. Your website runs very well indeed and has been a pleasure to read and navigate. This is actually the first time hearing of your project so I can't make sense of everything in a comprehensive update post like this but it was actually suprisingly readable without having to reference an introduction page. I will definitely be reading more.
 namespace std { template&lt; class T, bool allow_references, bool assign_through&gt; class basic_optional; } Solved. Next!
I would've called bullshit but I work at the medical company and my workflow is basically the same.
&gt; I would appreciate if you could share it with me. &gt; I will never share the questions &gt; Edit: I have already lost my interest in this altruistic effort. Reddit users are not ready for this... This doesn't seem remotely altruistic to me.
If you're ok with GPL then it's free. 
I prefer that style also anyway. But looks like you never was a debate where one group want this style and other want the other style. Or just joining a team where one group start a rebell against one style. And if you look at closely this is not a style difference either. It is a difference in reasoning about a variable. In the int *ptr style the ptr is a named pointer to something in the int* ptr style it is just a variable with a given type. Both reasoning are true. 
Try to explain this to a bunch of people who just keep asking you "and how can I declare two pointer in one line with this style? I won't declare every variable in a new line just for this." So my experience is that enforcing this rule is hard.
I hope your first question isn't about set theory or circular references.
Faster than Lucky Luke :)
Agreed, writing tests after - when your code is already Green - is still better than no test at all. Tests might make your code Red again :)
Well if the measure is allowed to be destructive, I can guarantee they are all broken.
Thanks, I didn't notice this option before. &gt;If the `CONFIGURE_DEPENDS` flag is specified, CMake will add logic to the main build system check target to rerun the flagged `GLOB` commands at build time. If any of the outputs change, CMake will regenerate the build system. &amp;#x200B;
Beep boop just following up that I have indeed settled the papers into a new [github.io](https://github.io) that works: [https://thephd.github.io/vendor/future\_cxx/papers/d1039.html](https://thephd.github.io/vendor/future_cxx/papers/d1039.html)
You can move from it though. Smart compilers could even tell you that you forgot to say to move as your lvalue is unused after that.
&gt;How are tests set up I would recommend [Boost.Test](https://github.com/boostorg/test) for unit testing, it's simple so you could start adding tests quickly. [Google Test](https://github.com/google/googletest) seems more powerful but I think most the time Boost is enough. I just don't like long uppercase macro names of Boost.Test :) &amp;#x200B; This book is worth your reading too [Modern C++ Programming with Test-Driven Development](https://pragprog.com/book/lotdd/modern-c-programming-with-test-driven-development). &amp;#x200B; C++ unit testing isn't as sweet as [Jest](https://github.com/facebook/jest) in the JS world (I loved Jest when I was writing JS code).
A while ago when `variant` was being standardized, I said something similar. That if there are different design choices and they are mostly reasonable, we should allow for them by making the core structure a template with some configurability/policies, and then `using variant = basic_variant&lt;default_cons_first, ...&gt;`. I was told that this is a terrible idea, and that having policies / choices for such basic vocabulary types fragments the C++ ecosystem. I don't know if I agree or disagree these days. `string`/`u16string` represents the same kind of problem, but I guess we consider it a mistake? If I could go back and change variant and all of that to be more configurable, I think I would...
Learned a lot of it from Intel's MMX application notes while doing 2D graphics optimization. The current location for the notes: https://software.intel.com/en-us/articles/mmxt-technology-manuals-and-application-notes MMX is now of course obsolete, but many of the basic ideas still apply to current vector instruction sets. Most intrinsics are just direct mappings of the hardware supported operations, so while they'll save you the trouble of register allocation and scheduling, it's still your responsibility to figure out to best map your problem and data structures to the most efficient ISA operations, especially specialized quirky ones. 
&gt; Edit: I have already lost my interest in this altruistic effort. Reddit users are not ready for this... Come on man, this is cringe.
This is not just a simple app. The whole project is way too complex and customizable for it to work.
The beauty of `std::basic_optional` is that it is a non-breaking change. `std::optional` works as it does today, and if a project needs different behavior they can get it. The problem of course is when a library uses `basic_optional` in a public interface and needs to work with another library that uses the optional with different settings. Although this might be just a theoretical problem that does not occur in practice.
Nice way to cut my sentence off in the middle and have a completely different meaning. You should be a reporter.
Oh really? I am still here. I did not delete the post and still stand behind my idea. Actually the fact that people don't wanna share is cringy. 
I can't wrap my head around this. I give up.
If you are interviewing Google or Microsoft engineers, I agree that technical interview would be unnecessary. Thank you for the tips btw.
It sounds like you're just trying to create [leetcode](https://leetcode.com).
Except that there are tons of devices out there that don't do Vulkan and I am not speaking of those with Apple logo.
Or, you know, old-fashioned pointers: `int i = &amp;word - &amp;words[0]`. Plus some safeguards if you think somebody will find it "appropriate" to replace a vector or array with a dequeue or an int-keyed map/hashmap.
Really? Another one: https://old.reddit.com/r/cpp/comments/9qhe02/enumerate_rangebased_for_loop_with_indices/ And even with the solution I mentioned there referring to https://stackoverflow.com/a/51438566/1930508
Thanks a lot! Very good to know. I would have made it the default (because big projects have more time to look into their build system and flags; and are the ones likely to not use `GLOB` either).
Using an additional function call and calculating the distance can't be efficient, right? Also I find it less readable than an old fashioned for loop.
You're all overwhelmingly positive, thank you. The gist of the comment was that I had limited amount of time to get the site running and so I chose to spend it making it fast and bloat-free, which I think was better than having it initially running on wordpress with all the unwanted bloat &amp; tracking you can get, *but* through HTTPS. I'm aware of the threats, had "fun" with airport wifis inserting ads into Wikipedia articles :D In the end adding HTTPS was a matter of a few hours (plus reading up on things I didn't know before), far less than I initially thought. I'm trying to write the announcements in a way that is approachable to people unfamiliar with the project, the "veterans" usually just go through the dry changelog in the docs and that's it. Still there's a room for improvement, I should be writing many more introductory and overview posts.
tl;dr: Use std::distance.
Really. This looks like a solution looking for a problem. 
I just find it clearer to use a normal for-loop when I need to use indices.
&gt; the vectors only had 8 ints in them Am I misunderstanding something, or number of elements in vector wouldn't matter, because non-reference optionals introduce more moves, not copies?
Solution: change it to `co_&lt;=&gt;`
for me this is where the article peaked: int i = 0; for (auto const&amp; word : words) { std::cout &lt;&lt; (i + 1) &lt;&lt; " - " &lt;&lt; word &lt;&lt; '\n'; ++i; } after that it's downhill. if you don't to "leak" `i`, just wrap the whole thing in curlies. 
Interesting talks! Especially the one about C++14 reflection.
`co_real_&lt;=&gt;`
&gt; The solution in the article is just complexity for the sake of complexity. The whole things revolves around "doesn’t look very modern" at the beginning of the article.
Sometimes I think we should just tear down the whole of C++ and do one massive breaking change But then I suppose at that point you might as well just create a whole new language
Last time this happened, it took like 20 years to fix it :-P
Not so nice, once you have multiple places where you need to use the index. You'll have to make sure you are incrementing it exactly once.
Luckily this seems like a pretty easy one to find and replace before you do an upgrade, seeing there should be no instance of `operator&lt;=&gt;` in the codebase before the upgrade.
It's on my list for things to try out at some point, if that counts
C++++ is already kinda taken as C#. D is taken, too. So maybe call it C+=3 or something? Its file extension will be `.cpe3`.
C++: Reloaded
Why is nothing ever in New York, where I live. FeelsBadMan
I'm completely ok with that code being broken. That should be super uncommon.
GPL or LGPL?
Anybody writing that should not only have their code broken but also their keyboard.
Yeah that makes sense
C with Classes and something that start with C, or C³. File extension `ccc` or `c3`. 
Ah! Sometimes, with the emphasis on sometimes, C++ does the right thing.
C# is only a refinement of C++03 - Compared to C++11 it is annoying to me - too verbose, too full of OO nonsense. If you want to see a refinement of C and C++ that didn't quite hit its stride, check out the Clay language. 
I do realise that dynamic exceptions remain available. But first, there are various code styles and environments prohibiting dynamic exceptions. And second, many gurus are advocating for making the choice between static exceptions (no language support currently) and dynamic exceptions based primarily on their semantics. Specifically, dynamic exceptions are good when things go "wrong enough" and it will be necessary to unwind a lot of stack frames before dealing with the exception. Otherwise, static exceptions show better performance. Conversion between static and dynamic exceptions is important, because sometimes an API author and a user will disagree on the kind of exceptions used, or the error might seem more or less fatal in the caller environment. It would be best if static exceptions could have the same features as dynamic exceptions, except the general spirit of them being compact, low-overhead and not being "fatal enough" (see above). In the example, if the error wasn't specifically LLFIO's `file_io_error`, then it could be erased using `make_status_code_ptr()`. Well, if `indirect_domain&lt;T&gt;` stores the original error, then it should also provide a way to extract it. The API for extracting the original error needs to be provided by `&lt;system_error2&gt;`, because user code messing with `indirect_domain&lt;T&gt;` will be UB. And such a standard function will be useful anyway: there is no need to craft one for each use when it can be implemented in a generic fashion. While I agree that static exceptions should be dealt with right next to the throwing function call, if possible, and that caring about exception data after type erasure is rare, I can assure you that there are enough use cases for this that supporting it (even in the language!) is viable. For example, Swift (and some other languages) use static exceptions by default, and dynamic exceptions for panics. Of course, downcasting and type switching in `catch` is supported there, and they would be surprised (not really) if I told them that we, C++ developers, are going to have to jump over hoops to do that.
This isn't anything new. The [original proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0515r3.pdf) points it out: &gt; Code that uses the source character sequence &lt;=&gt; today tokenizes to &lt;= &gt;. The only examples I know of where that sequence can legally occur is when using the address of operator&lt;= to instantiate a template (e.g., X&lt;&amp;Y::operator&lt;=&gt;) or as the left-hand operand of a &gt; comparison (e.g., x+&amp;operator&lt;=&gt;y). Under this proposal such existing code would need to add a space to retain its current meaning. This is the only known backward source incompatibility, and it is intentional. (We could adopt a special parsing rule to keep such code working without a space, but I would discourage that as having too little benefit for the trouble.)
Qt Opensource license is mainly LGPL, but some components are GPL only. https://www.qt.io/download If you can avoid GPL-only components then you can stick with LGPL.
Actually, what we should do is stop using raw text files to store source code. A database would be a far better choice. A database can keep track of all definitions, entirely removing the need for headers. A database can very specifically track what needs compiling after something has been changed, rather than simply tracking hashes or timestamps and making adhoc assumptions about what needs recompilation. All in all it would be a much better solution - but of course the eco system to support it doesn't currently exist at all... 
True, I didn't put too much thought into it but I'm also in favour of the future directions of that proposal ¯\\\_(ツ)_/¯
I was gonna say... didn't we already have a similar problem and fix it?...
I keep trying and the tooling isn’t there yet. 
Then you get the Python effect. They've spent basically a decade trying to fix the schism in the community after doing that, and while much closer, still aren't all the way there yet.
SCons does this and I consider it a killer feature. If I actually did any development on a CMake or Meson project, or anything else that uses Ninja as a back end, I would be really tempted to patch Ninja to support it.
Use ccache to get this for free with your existing workflow. Result: for my medium-size C++ project, `make clean &amp;&amp; make all` (or switching branches and rebuilding) takes around a second.
`C&lt;=&gt;` obviously.
CLion with Material Theme. Here's what mine looks like: https://puu.sh/BRkwR/d378741be0.png
Having been working on game asset pipelines for a while now (file counts and data sizes and distributed needs that make even the very largest C++ project ever look like a dinky little child's toy), hashes are *amazingly awesome* and the problems you outline are trivial to resolve. Remember, you're already storing metadata in your build system: the dependency graph. That is, the `.d` files (or similar) that `make` and friends rely on. Instead of storing these as `Makefile` fragments, you can instead store them in a slightly more structured form that has the dependencies _and their hashes_. You have now added everything you need for a hash-based workflow with no _additional_ metadata storage needs (from a file perspective). However, the speed of re-hashing files can be a concern. Especially lots of little files, for more so than really big data files. As a pure optimization (albeit one that needs more state storage), you can write a cache of files and their hashes. Map mostly-reliable file attributes (size, mtime, inode, etc.) to their hash. Your speed of dependency checking is now back to file attribute scanning, just like the old mtime-based approach. Worst case would be a workflow where attributes change too often (e.g., `git` not preserving original mtimes) which just means you have to rehash a little more often than would be ideal. I've never once seen actual problems with false-positive hash cache hits, even with networked file systems (CIFS or NFS).
&gt; As a last point, I found it funny that the guy is asking himself how to accelerate the hash, without thinking to the very most obvious way, which is using the file length as an extra info. I really like that idea, that's clever.
C++: Resurrection
C++: Revengeance
C++2: Electric Boogaloo
C++: Resurgence
yeah, ccache is a good example. Unfortunately it only handles compiler commands. In LLVM this is a big problem as they build and use tools like TableGen that is used to generate some files that almost everything (transitively) depends on.
There's [an open-source effort](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines) from Stroustrup and Sutter to document what are the guidelines for a modern C++. It's essentially a "good practice" manual about programming in C++, and choosing which features to use (god, c++ is so convoluted to have this kind of thing). It's the closest thing we have to a leaner language, as they provide some hints for compiler developers to add some warning.
This sub is for discussion about the C++ language itself. Questions about how to use the language should be posted on r/cpp_questions. The moderators here will probably delete your post.
sounds like homework!
Fuck that shit! Pabst Blue Ribbon... Er.... I mean Python.
If you're asking about how to program a brute force solution, then r/cpp_questions if where you want to go. If you care about optimizing the algorithm, then you should look up dynamic programming. 
How about c**
Could please the c++ stop breaking things please? We only asked for auto.
Nobody said what type `C` is, though. You can easily make a class overloading both operators where `++C++` is accepted. And, for the answer, `C++` [has higher precedence](https://en.cppreference.com/w/cpp/language/operator_precedence) than `++C`.
The idea is solid and I hope we get to this point soon. Maybe initially just use a database which spits out text files for the current tools to work with and then the compilers, analyzers, and editors could be adapted to gradually use more features of this said tool.
[Waf](https://waf.io) also uses hashes btw :)
Yeah, we actually have hash-based caching built into one of our tools that generates C++ code, heh. That's only like 60 lines of Python, though. Moving all of the hashing/caching into the build system might be conceptually cleaner than ccache + custom caching, but also is probably less flexible unless a lot of complexity is added (and build systems are already complicated). For example, what if you know that you only want to hit the machine-local cache except for a few specific artifacts (because cpp compilation is usually pretty fast compared to getting something over the network)? And how do you deal with different compiler versions? You have to hash the compiler and all of its files too to really be sure.
C V: committee strikes back
There is potential for a conference on the east coast, maybe even in New York. Its kind of what got me started in 2012...
Which evaluates to C + 1 as opposed to C
I still hope that modules will allow us one day to use multiple different abi compatible dialects of c++ in one executable. Then people would have to worry about breaking changes much less, as long as they only influence syntax or e.g. defaults.
And with C++20, you can put that `i` inside the for: for (int i = 0; auto const&amp; word : words);
Of course, there is no denying that using `std::distance` is poor choice here. What I meant is, article OP's aim is to have a generic solution that works **regardless of the container**, thus pointer arithmetic solution doesn't work at all (I'm not saying that `std::distance` is good: it gives the expected in all cases, but with poor performance, which mean for many use case it actually won't be acceptable).
No problem, it's a very useful website.
If you're expecting IDEs, that's mostly true. Individual tools I've found to be much more ergonomic. Of course, the primary tool that blows anything in C++ out of the water is Cargo, but I've found editor tooling like autocompletion to be easier to set up than C++ by a good margin, but they end up about the same. I'm using vim for both btw What tooling issues have you run into?
Return of The R-Value Reference
\&gt; you have to hash the compiler and all of its files too to really be sure. yes, and all relevant environment variables. \&gt; And how do you deal with different compiler versions? In order to minimize cache misses everyone (within an organization / team) should use the same compiler. Some companies go to great lengths to ensure reproducibility. For instance, Unreal Engine build-system downloads the whole (clang-5) compiler toolchain as a part of the build process. \&gt; Moving all of the hashing/caching into the build system might be conceptually cleaner than ccache + custom caching We have good experience with [BUCK](https://buckbuild.com) which implements a (distributable) caching solution and ensures reproducibility. The network cache is also configurable.
So you will shake it really hard until all the eggs are broken? You must be very strong biceps.
Yeah... but just ignoring features doesn't really work since the old functionality that we rarely use sometimes encroaches on the new syntax anyway
That's more or less how [D](https://dlang.org/) came to exist.
Yes, it's much more turning the head the other way than a sound subset of the language but I find it better than nothing and it's quite useful.
We do the same in [plz](https://github.com/thought-machine/please) \- as do Bazel and a few other similar things. &amp;#x200B; I'm surprised Ninja doesn't tbh. There are just too many ways timestamps can go wrong. Hashing does often over-rebuild but it's the only way to be confident things are correct.
I'd just like to see a `-Wstrict20/17/14/11`that you can pass that disables old crufty techniques. 
In my case, IDEs are pretty critical in AAA game development where you're just trying to eke out as much performance as possible. Hardware breakpoints, disassembly viewers, and "nice" debuggers, and an out of the box Windows setup are all issues I've run into. The editor tooling on Windows just seems totally broken unfortunately, and I can tell the platform is not a primary first class citizen which is a non-starter for recommending for broader internal usage. I am fluent in vim and install vim plugins everywhere, but let's be honest, debugging is much harder than typing code/autocompletion. As for Cargo, it's easy for the use cases it supports but for heavier duty build systems that need to handle cross-compilation and custom flags per translation unit, etc, it's a bit opaque for me.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9rcg8t/c_interview_questions_midsenior/e8i2zfz/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; and I can tell the platform is not a primary first class citizen Windows is fully 100% supported. I use Windows at home, and Linux at work, and I do not have any issues with using Windows for Rust work. GDB and LLDB support Rust pretty well at this point. However, on a team of Rust developers, I have seen the team reach for a debugger once in past six months. Unless you're writing `unsafe` blocks, it's very unlikely that you'll need a debugger. Profilers exist, but that's an area that could use some improvement, and writing Rust doesn't magically make profilers obsolete the way that I've seen it make debuggers largely unnecessary. Disassemblers shouldn't care what language you're working in... your binaries are still binaries.
The filesize alone would almost always prevent rehashing.
you can do the increment at the start of the loop, then not much can go wrong. for (int index = 0; const auto&amp; word : words; ++index) { ++index; // not we start at 0 now std::cout &lt;&lt; index &lt;&lt; " - " &lt;&lt; word &lt;&lt; '\n'; }
File size alone is definitely not sufficient; it would avoid rehashing in cases where it _should_ rehash. Consider changing a public constant from 0 to 1, for example.
start at -1 then. Yeah, it's already better.
C cubed is actually not bad. 
Honestly if there was some kind of compile time flag that would prevent some pre C++11 stuff from compiling, that would be great.
Meh, C+=3 is too close to [C+=](https://github.com/ErisBlastar/cplusequality).
That's an excellent point actually. I guess i basically have this tool already lol.
I’m still waiting for integer generics! They keep putting it off. :(
private and static have different uses. private is suitable when you only want to access the function from within another member function of the class. static is suitable when you want to provide a function in a class that doesn't need to operate on the data of a specific object. They're two non-interchangeable use-cases.
HolyC
Wrong sense of static.
definitely, the new use is waaaaaaay more common. I can't really think of a time when I'd ever want to template an operator like that. I guess you could use it like a sort direction, but I feel like theres better ways to do that.
Yeah, most changes will involve a change to the size. That avoids hashing to determine if the file changed ... but the file still needs to be hashed anyway so the new hash can be stored for next time. The file size doesn't avoid any rehashing, in the end.
If you're doing anything commercial, Qt is pretty damn expensive. If you can stand the (L)GPL requirements, then it's a good option. 
?
non-class based functions are implicitly static, but not the same, so calling them static is pointless
That's what static code analysis is for.
As far as I understand, free functions are slightly more test-friendly but can impair readability. I guess the answer is "it depends" or maybe even "different strokes"?
I prefer to make a static (or in an anonymous namespace) free function whenever possible. That way I don't have to touch the header file causing a bunch of needless recompilation, and less to read for those that read the header file in order to figure out how to use the class.
&gt; it depends is my go to answer most the time! &gt;_&gt;
Thanks, needed someone to point me in right direction. Sorry for posting in wrong subforum. 
Well I might just be terrible but after a few hours last weekend I literally could not get the Rust extension to visual studio code to work properly.
For the most part, put unique private class stuff in private methods. Unless you're running into special cases or particularly worried about optimizing build times, the few downsides of private methods aren't important. Use free functions when you have generic operations that can be shared and reused. Use static free functions when you have a considerable amount of logic to write that it definitely only necessary in a single TU, e.g. as "internal" helper functions to break up an otherwise complex member function definitions. Static free functions honestly should be pretty rare, though. There are a few (minor) downsides to private member functions compared to static free functions, but they're only relevant to a teeny fraction of projects/developers. The first problem is that private member functions are still _exposed_ from the TU, meaning their symbols are mangled and made available for linkage to other TUs. That is required if you have inlined public member functions that need to invoke the private behavior, but is symbol bloat otherwise (again, not a major concern for the vast majority of users). A second problem is that since private member functions must be declared in the header, any change to private member function signatures will cause a recompile of all dependent TUs even though nothing about the public interface changed. That is not a big issue mostly because private member functions won't typically change interface much without some kind of public interface change (remember the size of a class is public interface, so adding/changing a private member variable still counts!) so it's not typically something you'd need to worry about. TL;DR: as _general guideline_ use private member functions for private class behavior, use free functions for reusable behavior, minimize use of static free functions to just being organizational fragments of non-reusable logic needed in a single TU only.
If you can declare the function as a static in a cpp file just do it: if you change the signature or private member function, all source files that include the header file where is declared C will need to be recompiled. The only reason to declare a private function is when it is called from within an inlined member function. &amp;#x200B;
I've started to take this view: &amp;#x200B; Everything in a class definition tells you something about it, even its private members. It's a message to the reader about the functioning of this class that not even comments can fully explain. &amp;#x200B; So if you have a function that can easily be static in the cpp file, then that tells me that function does not have an explanatory role for the class. Which means its inclusion in the class definition will muddy the waters. Sure, it may be convenient to be able to refer to members of the instance object without having to pass them to your static function but I think that is a very small price to pay for design clarity.
&gt; which is why it's frowned upon. It's not
No worries. Sorry for the brief answer it's just not my expertise. 
Sigh, does anyone here know C++? https://en.cppreference.com/w/cpp/language/storage_duration No, `static` on a free function *does* mean something. It means that you can't refer to it outside the compilation unit. It's essentially equivalent to putting it in an anonymous namespace.
Its ok, btw the problem is known as Knapsack problem.
Oh man, I had forgotten that we used to have to deal with that! -_-
It is worth noting that the mixin project has established itself well in early 2018, showing a record price for its coin, thereby proving its seriousness in the cryptocurrency arena. Website; https://mixin.one
The extension could not find the rustup toolchain no matter what i did and no amount of changing installation method or environment variables seemed to help. 
But are you able to use `cargo` from PowerShell? 
Yup all of that worked fine
Most of the time? What's your answer the rest of the time?
&gt; equivalent to putting it in an anonymous namespace so do that is my point
pareto princple
Just wait for JAI to be released.
C++: The Judgement Day
&gt; I would be very surprised if stack unwind by dynamic exception throw is ever faster than stack unwind by static exception throw. I do think, though, that on in-order CPUs static exception throwing code is going to be slightly slower in the success path. Whoops, that was some rubbish on performance aspects from me. The general idea was that it's often advised to choose between static and dynamic exceptions primarily based on performance aspects. "Will the function throw a lot? If yes, choose static exceptions." It's not "will you use features of dynamic exceptions, which static exceptions currently don't have?" We can also view it another way. Unlike many modern languages, C++ is multi-paradigm and mostly unopinionated. By that I mean that it gives us the tools, which are useful and somehow map to hardware, and allows us to decide how we want to use them, develop styles and guidelines. Herb Sutter++ have discovered a novel mechanism that allows faster error transmission, why limit it, comparing to dynamic exceptions? &gt; If you choose `std::error` for that, you explicitly give up flexibility in exchange for performance. There is no need to give up flexibility when choosing static exceptions. Complete support for `status_code_ptr` with downcasting and type-switching and ways to compose different errors would be zero-cost in "you dont pay for what you dont use" sense. These "rich" static exceptions are still faster than dynamic exceptions. &gt; I don't think you can say that. Most people bothering to return a local error type will be doing so specifically for maximum performance. Otherwise they'd just return a `std::error`. So chances are very high that any local error type will have lifetime issues if not destroyed at the `std::error` decay boundary. That's different to how I use exceptions in C++ and in other languages. Most of the data I want to capture are trivial things captured by value. There may be some intermediate results, which I might as well want to move into the exception, with little to no overhead. There may be some references, and there is indeed a point where they should be dropped, but everything else will remain. In general, all these steps can happen at different times down the call stack: - Upcasting the error (e.g. because of merging multiple possible errors) - Discarding some pointers because of lifetime issues (if they were there) - Stopping caring about details completely ("something went wrong. error code ###") This is true for dynamic exceptions, and this can happen as well for situations, which could gain from `std::error`. --- There was a previously proposed mechanism, which suggested using `std::error` as a handle to the packed exception, and user code would see little to no change. The current approach, as I see it, is to make developers tighten their belts, throw away the exception data, and switch to error codes, maybe with dynamic error message — if they want to use static exceptions. I disagree with this direction. Some of exceptions in use are, in fact, nothing but error codes, and they will benefit from `std::error`. Some of exceptions, in fact, have no use unless immediately caught and dealt with. But there are situations, where I'd want to use inheritance, upcasting, downcasting, type switching, etc. — all with static errors. What I'd want is the combination of that original "`error` ≈ `exception_ptr`" direction with the new idea of packing into `std::error` itself. `exception_ptr` becomes `status_code_ptr` in my model. The idea is, on type erasure, to pack the data into `std::error` directly when possible (status code) and into `status_code_ptr` otherwise. Full type switching in `catch` should be available in both cases. Even if you think it's crazy, could you still discuss this approach at a WG meeting?
Do any build systems that use hashes specifically use a hashing mechanism that is syntax aware? In theory, if I make whitespace only changes to my code, it would be cool if the hashing system recognized that this wasn't a meaningful change. 
We already have that. It's called Java.
Within an organization, you can limit the number of combinations, making binary artifacts practical by significantly reducing build time (no need to build dependencies over and over again). If only we had one tool to rule them all.
`co_c++`
ahhh yes i am dumb
Sorta! We’ve been working on the internals that enable it. It’s a highly desired feature, but also a lot of work. We’ll get there, but it’s not so much “putting it off” as it is “it’s non-trivial work and we’ll get there but it takes time.”
In C++ an anonymus namespace should be used instead of static for such a function.
Official language of TempleOS.
Oh hey, thanks for the reply and I'm glad to hear that's the case. Can you describe what does your editor/debugger setup look like? Do you cross compile when you develop or are you targeting a particular host platform? Do you have any visibility in targeting mobile or console platforms with the rust toolchains? I actually considered applying to work on the Rust compiler team a while back and am a fan of a lot of its ideas but life took me in a different direction.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9rosdm/to_learn_c_i_want_to_make_a_guitar_tuner_i_cant/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
And the prequel - "C with some class"... though, no, that'd be just plain C
Perhaps we should have the Patriarch of Python2stantinople and the Pope of Python3 talk in a locked room.
`C::operator ++()`
`C&lt;=&gt;C.operator++()`
`C&lt;&lt;=1`
`unordered_c++`... or maybe for /u/stl, `cmeow`.
I believe that [Go has already solved this problem for us](https://i.imgur.com/k8S00sM.jpg). Perhaps we should adopt it.
If a tree falls in a forest and no one has ever put `operator&lt;=` inside a template, does it make a sound?
In practice i really like writing tests to fix things as well, but for catching bugs that are timing sensitive (even with rust you can introduce races with other system resources like the gpu or audio buffers etc), it’s much cheaper to move breakpoints around and set hardware watch registers than to add a print and recompile. 
Oh totally! All I’m saying is that I do it really infrequently, YMMV. We’re investing in debugger support, regardless of how much I personally use it :)
I would like to see a compiler flag that reverses most of the defaults that C++ got wrong. For example: - const by default, you have to say mutable to get non-const. - explicit constructors by default. You have to say implicit to get that. - noexcept by default. You can to say except or throws. - etc.
Ah also good to hear than cheers. 
True, but the file that is hashed could be a different one that is sent to the compiler.
If you do compile time values/strings that aren’t just ints you could leapfrog c++ 
vim/emacs = text editors, mostly. Horrible as an IDE.
Lol, okay.
If I had to redo C++, Rust is about the opposite of what I'd want.
&gt;We’ve been working on the internals that enable it. It’s a highly desired feature, but also a lot of work. No it isn't. It's an extremely simple feature. 
This is the problem with Rust, IMO: every new feature is tiny, completely minimal, and yet it still takes forever for them to be added.
It’s a pretty recent development; I’m a lifelong Mac and Linux user.
Yeah, and more to read for those who need to make changes into your implementation. This is fine if you need to have access to one private data member, but if more? Will you pass all these members as arguments? It doesn't solve the problem when you need to add private data member. Also, there are possible some not obvious issues. For example, someone else won't see that your 'static int foo()' method exist and will add a method with the same signature to the class, and... surprise! All calls to your foo() implementation will be switched to the new one. Have a nice day with debugger. In my opinion, this is naive approach which does not solve the problem, but significantly complicates maintaining of your code. There are more common ways in C++ to reduce compilation time: split source code into modules, use pimpl idiom instead of your approach, forward declarations. And only in some rare cases free functions with internal linkage can be used.
At least boilerplate code will a little bit easier.
&gt;I want to make sure that Rust works well on Windows. Mainly dogfooding then, I guess? That makes sense. &gt;Additionally, most stuff is pretty cross platform these days; out of all of my tools, the only real work needed to convert was to learn to use PowerShell instead of bash. Your freedom isn't cross-platform: it fails to compile on closed source spyware operating systems. 
A New Standard
A build system should never, EVER modify source files.
&gt;Actually, what we should do is stop using raw text files to store source code. A database would be a far better choice. Absolutely wrong, for the same reasons that we use text files for configuration, text files for website, text files for everything. Text files are human-readable, human-editable, and universally supported across all operating systems and all software. There are a million text editors and we probably use different ones. I don't want to be forced to use one particular editor you decide to make for your shit database format. &gt;A database can keep track of all definitions, entirely removing the need for headers. Headers are a good thing: they document what is public and what is not. They're also a primitive abstraction mechanism: you can have multiple implementations of one header. Headers are not a bad thing. &gt;A database can very specifically track what needs compiling after something has been changed, rather than simply tracking hashes or timestamps and making adhoc assumptions about what needs recompilation. Which is not necessary. Having compilers that aren't dog-shit slow is what is necessary. &gt;All in all it would be a much better solution - but of course the eco system to support it doesn't currently exist at all... No. 'Solving' the problem of compilation taking too long is quite simple: make the compilers faster, and don't `#include` millions of lines of template garbage into every source file.
Let the compiler errors flow through you!!!
The files that would need to store the extra information are build artifacts, not source files. Source file hashes would have to be recomputed every time, not cached, since you'd have no way of knowing when to update the cache without performing the hash anyway. 
&gt;Source file hashes would have to be recomputed every time Which is why you use timestamps instead. Or you use a proper programming language with a compiler that isn't literal dogshit and you just recompile everything every time and it takes less than a second anyway.
&gt;Oh man, I had forgotten that we used to have to deal with that! -_- At least the errors we got were verbose