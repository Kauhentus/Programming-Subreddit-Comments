could you recommend me a follow up after that book?
I must say I attended Code::Dive for the first time in person, and I know that I will be there for next iteration !
I get how to solve the overload problem with values. I am uncertain how to solve it with `std::reference_wrapper&lt;T&gt;`s, because `operator()` on `reference_wrapper` doesn't match exactly the one on `T`. Maybe it doesn't do any better than the naive solution for reference wrappers? 
Something like proposed [`unique_resource`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0052r6.pdf) would be ideal for this.
&gt; @sphere991 reddit uses u/hpsutter Regarding std::ordered... please no... people who want to make fun of C++ have enough material already. comparing 3 values should not require a function call.
I too have no idea. It's a pity if not. SFINAE would be the way to go I guess.
Ok... 15.5.3 doesn't do that, though. You get an error message, but not an ICE. 
https://en.wikipedia.org/wiki/Pragma_once#Portability That's 14 compilers supporting it, and 1 that doesn't. Plenty portable enough for me, but if you really care about that one (rather obscure) compiler then sure, use include guards... Oh, and that "preprocessor detector" on that page is completely ridiculous. If it isn't support it must be ignored, no need to #ifdef it out... 
Just curious, what was your background before working on real time stuff at Tesla? What operating system do you guys use on the vehicles for the auto pilot? 
From the job opportunity perspective C++ is a horrible language. It's almost impossible to find a new project in C++. Highly probable your destiny will be to support 20+-years old crappy C-with-classes code. At the same time the salary for C++ developers is pretty low, because you're gonna compete with old farts who don't care about salary raise for decades or about learning something new. It's a freaking swamp to be honest. Yeah, now somebody tell you about fancy game engines, trading companies etc., etc., but you have to know that the amount of such projects on the market is so low that your chances to become a part of such team are also pretty low ( and even there amount of legacy is overwhelming ). Moreover, if you think about the opportunity to work remotely you can forget about it instantly. The ratio between remote javascript work and remote C++ work is about 100:1 or something. So, I would not recommend C++ if we considered career opportunities.
Hey I'm about to start learning it next term haha Just learned Java.
Why has no one mentioned that learning C++ will help you understand how a computer works at a low lever? This will become invaluable as you progress your career and give you a massive advantage over programmers who only know how to write code. 
My last job was a remote C++ job... so they exist, for sure.
Of course - including my current job, but e.g. take a look on r/cpp hiring thread - how many remotes do you see? Especially worldwide ones - these are getting rare and rare.
After you learn it, if you want to continue with it make sure to read Effective C++! 
&gt; WHY should I (or anyone) pick up C++ in 2018? - **High Performance Computing** - C++ is one of the few high level languages with high performance and and direct access to the operating system system calls that are exposed in C. Examples of HPC are programming related to physics, finance, fluid mechanics, finite element methods, games engines and so on. - **Develop firmware for embedded systems** such as microntrollers and embedded processors for controlling home appliances, car's fuel injection, motors, robots and so on. Those systems have memory constraints and many of them doesn't even have operating system. - **High performance software components or libraries** - It is possible to write libraries of higher level programming languages in C++ and getting the best of both worlds, for instance, one could write high performance python, java, R or C# libraries in C++. And also Excel addins in C++. - **Take full advantage of the operating system** - It means developing any program that requires access to all OS features and, graphical stack and system calls. - **Low level stuffs** - Device driver, interface hardware ... I would also add obfuscation and security research. 
Man, do you know the word 'probability' ? It's definitely possible to become a billionaire, as well as possible to find a new project in C++. But you know, that word, 'probability'...
Hi, thanks for your comment. This point was fixed yesterday, please check it again
I actually *just* had the first chance where I felt backed into a corner and forced to use `new`, and it's because I'm working on my library and keeping it DLL-friendly :(
Did you read the blog post the other day about the pleasure of writing a backend in Ada? https://www.reddit.com/r/programming/comments/7p66wx/going_allin_with_ada_a_manifesto_xpost_rada/
My condolences on your Java learning. :-( Try to forget many of the patterns when you learn C++. The languages look similar, but they are very different. In C++ try not to use `new` for everything. Treat classes the same way you treat ints.
pimpl all the things?
Computer vision, AR, VR, IoT, robotics etc all in c++
The catastrophic drop in performance (up to 30% for syscall heavy programs) is observed with the meltdown patch on a cpu without the PCID feature. IIUC the performance impact of the spectre mitigations (retpoline and lfence) is way smaller (see for example [this email](https://lwn.net/Articles/742980/). From the linked email: &gt;This is unfortunately measurable -- from 3 cycles on average to about 30. &gt;However the cost is largely mitigated for many workloads since the kernel uses &gt;comparatively few indirect branches (versus say, a C++ binary). Since we are on /r/cpp I optimistically read this like: (versus say any language with runtime polymorphism) :)
I've seen Mike Acton's CppCon talk on data-oriented programming, but what other resources can you recommend?
Eventually that's my plan, [as I'm realizing I'll probably require it lol](https://www.reddit.com/r/cpp/comments/7oz2m3/the_pimpl_pattern_what_you_should_know/dsdkp3d/) Latest changes were related to function signatures, though. Only have one function requiring `new` and (for how im using it with my higher-level library that uses this one) it'll just be dumped in a `unique_ptr` asap anyways
It's fixed in the preview version of the MSVC, not the current production version. As to your other point about MSVC bug tracker, I will respectfully disagree on that point and I actually appreciate hearing about MSVC specific bugs. For many of us we have to use MSVC on Windows for production code (as opposed to preview/beta versions). Because Microsoft does not provide any public or transparent means of identifying bugs the only way many of us have to identify compiler bugs, workarounds, and other MSVC specific details is through community posts such as this. For GCC, I can go to the public bug tracker here and review, discuss, and even contribute to discussions regarding bugs as well as view the progress: https://gcc.gnu.org/bugzilla/ For Clang I can go here: https://bugs.llvm.org/ Given that MSVC is the only option available if you want to deploy actual production desktop applications for Windows, then it's totally fair and appropriate for people to discuss and share MSVC related bugs in a forum specialized for C++ development.
Because it’s intrinsically more involved and difficult than a lot of other languages. That coupled with the existence of demand that has been adequately covered elsewhere here... You make a shitload of $$. Otherwise, a lot of people wouldn’t stick around. That also gives you a lot of leverage to make sure they keep you around. I’m actually a dev for a well known name in WA doing almost strictly C++. The majority of my peers from school wouldn’t get 10 minutes into the interview day, its hard to “snap back into” C++ if you’re not really a C++ dev. You don’t build the same skills. If I hadn’t stubbornly forced C++ into whatever I could through school, I’d never of gotten my job. 
Because it’s intrinsically more involved and difficult than a lot of other languages. That coupled with the existence of demand that has been adequately covered elsewhere here... You make a shitload of $$. Otherwise, a lot of people wouldn’t stick around. That also gives you a lot of leverage to make sure they keep you around. I’m actually a dev for a well known name in WA doing almost strictly C++. The majority of my peers from school wouldn’t get 10 minutes into the interview day, its hard to “snap back into” C++ if you’re not really a C++ dev. You don’t build the same skills. If I hadn’t stubbornly forced C++ into whatever I could through school, I’d never of gotten my job. 
My background was actually purely academic, this is my first industry job. I had a lot of open-source C++ work on the side. I have a lot of experience with gcc and clang in a classic linux dev environment, and it turns out that lines up perfectly with what we use. We use linux in the cars, with the "real time" scheduler patches. I think we may have some in-house patches to that also. Not totally sure, and not sure how much I can divulge, but I'm pretty sure the fact that we use linux to run the autopilot stack is public and not very sensitive. At least is was leaked by one of our customers who was reverse engineering his car: https://www.reddit.com/r/RealTesla/comments/7ozm5l/has_the_model_3_made_the_model_s_obsolete/dsizh6x/?context=3
Check out these books featured in the link in the sidebar https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list 
Have you read my initial message? It was not about 'C++ is useless', it was about how hard to find a new project (not legacy) in C++ if you try to find a job for living. You guys started argue with straw man, good luck.
&gt; For GCC, I can go to the public bug tracker here and review, discuss, and even contribute to discussions regarding bugs as well as view the progress: &gt; &gt; https://gcc.gnu.org/bugzilla/ &gt; &gt; For Clang I can go here: &gt; &gt; https://bugs.llvm.org/ And for Visual Studio you can go to: https://developercommunity.visualstudio.com/spaces/8/index.html
I think claiming they should be forgotten is too strong, interacting with C API's is absolutely one of the strengths of C++. I don't think it should be taught to a beginner, but an intermediate to advanced user will absolutely be less for not understanding and being able to work with these things.
What about it is too advanced? Does it skim over details of features that are familiar to those who know C? Does it introduce and use features while assuming it's obvious to you how they would be used? Are you getting bogged down in all the details of a given construct and you don't have enough context to process it and make progress? These all imply different steps and different books.
Pretty much. Not like the machines are doing anything else. ;-)
The FUD around CWG 1581 was too strong: people were imagining nightmare scenarios where `constexpr invoke` would break everything that touched `result_of` or `bind`.
I have never seen this before and didn't even know this existed. I am very happy to see this and appreciate you linking to it for me.
Rather: while(true){ processWindowEvents(window); if (!window.isOpen()) break; // render etc }
Yep, but isn't as descriptive as the comma IMHO
They should certainly be avoided. I feel it would be best to do an into course in modern C++ so the students form good habits. When they're used to C++, teach them the C parts, while showing why we prefer to not do it that way any longer. Knowing C is important. If only because there are a few large projects with managers that believe it's "much much easier to generate total and utter crap with [C++]".\* \* http://harmful.cat-v.org/software/c++/linus
Of that list of challengers, I'm not sure Go is meant to 'catch up' to C++ - it explicitly eschews much of the abstraction power that C++ provides (specifically, from templates). It's more like displacing C in implementing various kinds of network services.
No problem. You can also report bugs straight from the VS itself ("send feedback" in the upper right corner). I found that the VS team was quite good at responding to my bug reports and keeping me up to date on them.
Haskell has no SFINAE or other overloading-related quirks though.
If you need to output lots of it, humans can't read all of it. If you need humans to read it, it doesn't matter how fast you output it. Uh, right? I think I'm just not fully understanding your use case if something like rapid JSON isn't fast enough, but you also need human readability as a key aspect. It seems like you could use something like protobufs, and then just have a pretty-printer utility for the protobufs that a human actually needs to read, rather than doing everything in one place.
If you want my help on your project, you have to use C++. http://webEbenezer.net/about.html for more info.
Rust
That doesn't handle full overload resolution order; works for `first_overload` not for `overload`.
&gt; basic knowledge of algorithms/data structures (hard to read a book when you don't take calc until the next year) You don't need calculus to understand algorithms. Same for data structures.
Is `new` DLL-friendly? I know that `malloc` isn't (got bitten by a crash when calling `free` because it was the wrong one). My understanding of a DLL is you should never allocate stuff in the DLL then ask the user to free it.
We got `constexpr if`. Baby steps.
Upon reading your comment, I thought you made a mistake by including `new`/`delete`. I was a very competent C and C++ developer more than a decade ago. I went into management, but, now, I'm wanting to start developing again. Your comment was valuable to me, but it still makes me sad to realize just how much I have to learn.
&gt; It was not about 'C++ is useless', it was about how it's hard to find a new project (not legacy) in C++ Hmm... &gt; Tom listed a **fair amount of industries where C++ is still used a lot.** That's hardly as 'rare' as becoming a billionaire. They never said you claimed *'C++ is useless'*. Let's break that down. You said there aren't many jobs, and they rebuked that it's used in "a fair amount of [industries](http://www.dictionary.com/browse/industries)": the number of industries being indicative of a considerable job market share because being heavily used in a large number of *types* of businesses correlates to those businesses hiring people. --- To your original comment, higher-level languages will always, by nature, have more job listings because they're easier. JavaScript especially given its exclusivity in the web market (a low barrier to entry sector) and increasing use in server and offline application development- of course it will have a higher ratio of positions. That doesn't make C++ 'horrible', which is too strict an identifier for the reasoning. **Really, your entire point would have more weight if it weren't so heavily generalized and disparaging.** "If you're concerned about having access to an abundance of job opportunities, or have certain requirements like needing to work remotely, this may not be the language for you," would, perhaps, be a more palatable phrasing. &gt; You guys started argue with straw man Or you're intentionally misreading things to confirm your own biases. [Plus, a single fault in an argument does not invalidate the entire point](https://yourlogicalfallacyis.com/the-fallacy-fallacy), which you failed to properly identify and acknowledge. More so, you made the scope of your original claim too narrow *(jobs must be on new projects and have the ability to work remote)*, makes false claims *([pays poorly](https://www.payscale.com/research/US/Job=C%2B%2B_Software_Engineer/Salary))*, generalizes too much *("Highly probable your destiny will be to support 20+-years old crappy C-with-classes code")*, and is clearly full of personal grudges / prejudices *("you're gonna compete with old farts who don't care about salary raise for decades or about learning something new")* that devalue your insights. `TL;DR`: Your point *(that it may not be appealing due to a smaller job market with fewer concessions)* would be fine if it weren't full of grievous generalizations, clear prejudices, and falsehoods.
I'd consider that to fall under "can't fully utilize the hardware" IMO. If it eats up too much RAM which directly or indirectly affects the performance of the application, I'd say that's under-utilizing the hardware. Sometimes you don't really care about how much RAM it takes: your bottleneck lies elsewhere. It's fine to use Java/C# in that case.
Quite the opposite.
&gt; Remote jobs are only for self-starters and self-managers. It requires discipline, focus, ability, and of course, a task that can be done remotely. That said, I never work in my pajamas. How did you handle this part? Can you talk more about it and maybe give some advice based on your long-term experience(s)?
I don't get the chance to work with the new things that often myself.\* However, I just love the new paradigm. You get all the benifits of a garbage collected language with little (shared_ptr) or no (unique_ptr) overhead. I highly recommend these two talks if you want to see how things have changed: * [CppCon 2015: Kate Gregory “Stop Teaching C"](https://www.youtube.com/watch?v=YnWhqhNdYyk) * [CppCon 2015: Bjarne Stroustrup “Writing Good C++14”](https://www.youtube.com/watch?v=1OEu9C51K2A) PS: C++17 brings things like filesystem to the standard library (finally!), so no more awkward hacks or boost needed. \* Many projects want to work with older compilers.
The problem is the C API often sucks. Unscoped enums, macros, free functions...
I mean... did you get bitch slapped by a free function as a child? this feels more like stupid ideology than anything actually relevant.
Removed due to being off-topic.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7ps96t/i_have_the_c_primer_book_but_its_a_bit_too/dsk3u5k/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7plkfj/suggestions_for_c_books/dsk3ufg/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; You do No, you don't. &gt; lots of stuff is there that I personally don't understand Just because you don't get it, doesn't mean it's calculus.
&gt;You said there aren't many jobs, My gosh. Where did I say that? How many times should I repeat that I said about 'quality' of jobs? Not about their amount or existence. &gt; Really, your entire point would have more weight if it weren't so heavily generalized and disparaging. Oh sorry I touched C++ snow flakes' gentle soul. I didn't intend hurt you boys ( and girls ). But it's not 'generatlization', you know, it's the fact. Overwhelming majority of C++ jobs are old legacy crap. It's _the fact_. And nothing wrong to say about it. Because again it's the fact. 'disparaging', my ass. Am I talking with adult people or why the heck you are so 'touchy'? &gt;Or you're intentionally misreading things to confirm your own biases. Or you misreading my message and try to argue with nonsense I didn't say. Good luck again. &gt;More so, you made the scope of your original claim too narrow &gt;made false claims &gt;generalized too much &gt;that devalue your insights. I see you too smart to acknowledge your faults, I don't want to continue with such ignorant people. 
&gt; David Sankel: The Intellectual Ascent to Agda https://www.youtube.com/watch?v=vy5C-mlUQ1w
Which version did you forward? The one, where the already sorted array gets resorted over and over again? That would be highly misleading.
It’s similar with .NET. For every 10 node or Go jobs there is 1 for .net. Basically because it’s mainly used by big enterprise companies and they like to have you in person at the office. I don’t know why you are being downvoted. I receive the daily newsletter from remoteok.io and in the last month I don’t remember a single C++ job. Maybe the typical, in where they want you to know Java, Python, Clojure, Angular, React and C++ just in case. Of course they exist, but if there are few positions is even more difficult to get them. And if you don’t like the job is also more difficult to change than with something like nodejs.
That's MELTDOWN. We're talking about SPECTRE which is a compiler codegen problem
Not sure how meaningful that is without seeing the benchmark he ran, but I admit that I was probably wrong.
I just started an discussion, but will forward later tomorrow. That updated code is much slower (300us). This is even 1/3 slower than Haskell. Also I belief the Haskell Criterion lib is better at timing micro-benchmarks, so I have to update to a better library in this regard in C++. I will also benchmark the unstable Rust sort function as comparison. The Julia version is also very fast.
What level of ASIL are you guys using at Tesla? Seems like the autonomous driving functionally has been released a bit early.
A c++ University course that covers hardware stuff like the caches, branch prediction and That kind of stuff? That's rare.
Not yet. I'm interested why Tesla didn't consider Ada - or maybe they did and turned down?
It depends on you business. But with deepening of the container evolution, a language that can generate small container image is critical. Furthermore, today's AI industry is basically built upon c++. AI scientist, data analyst may prefer simple language bindings like python, but any serious project has to use c++ in its very core. So, I'd consider c++ is the language for the future containerized data world. It's hard, but necessary.
&gt; count down to 0 but no further Technically, [it does count further](https://blog.kloetzl.info/underflow/).
That is true, but better than getting an ambiguous call when you have to reference wrappers.
Have you ever tried teaching unique_ptr to new programmers? It's a mess, and move semantics aren't something that new programmers are equipped to deal with. Vectors (and other STL containers, as needed) are the better way to go for new programmers.
I don't see how that affects language extensions as an idea.
For your second language I suggest Golang
If you know C++ you can get a job in java, C#, python development etc, if you only know one of the others, good luck getting a job in C++ development.
I definitely don't believe that one bit. Good luck getting a job in java with no experience based on knowing c++ in London. I understans your reasoning, but to say that knowing c++ means you can do any language to a professional level is utter bullcrap. :p I agree it would be easier landing a job as a java developer with some experience of java (specifically in thr area you'd be working) and extensive knowledge in C++. But that's how far I'll go.
1. Read all the books &lt;insert meme here&gt;. The [Definitive List](https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) is a good place to get started, but it is incomplete. 2. Watch as many CPPCon, MeetingC++, and C++Now^1 videos that you can (most are on YouTube) 3. Go to CPPCon, MeetingC++, C++Now and interact with other C++ folks 4. Join your local C++ group. If there isn't one, start one. [1] I feel like I'm missing some...
Two reasons: C++ is used in the most interesting work. Not to say that other work in other languages isn't interesting, but C++ is used when other languages just aren't up to the task. Sure, you might find yourself in a maintenance and modernization effort on a legacy system, and that's interesting in its own right. But for performance, scientific, control, or systems work, C++ knowledge will take you far. The other reason is that C++ knowledge is a feather in your cap that your colleagues won't have. It marks you apart from the rest of the crowd. Everybody in the office will likely know Python and Javascript, and you should too. But if you have expertise in C++ then you are a deeper and more knowledgeable employee. It will add to your reputation. 
Believe what you want, but C++ programmers are seen as having a much better understanding of how computers work and what the code they write actually does. Hence they are seen as being able to pick up new languages that are higher level much more easily than developers in higher level languages picking up one that is lower level. I'm a C++ programmer, have been for over 8 years and I haven't done java since i was at uni. Pretty sure i could do a few weekends of java study and get a job don't full time java development.
Also: - prevent leakage of implementation details to the header file (because impl class can be forward-declared and implemented elsewhere) - increase build speed for all clients of your pimpl wrapper (in cases when writing an impl class means including many many dependencies)
It is the only common language across all iDevices, Android and UWP SDKs. Meaning less work doing any kind of integration and first class support on the SDKs respective IDE and debuggers. If you ever need to look under the hood of LLVM, node, Java or CLR, in case you are working on those eco-systems. It is the hidden workhorse of the Deep Learning and Big Data. The best option currently for writting graphics engines, audio and video codecs, GPGPU programming in terms of tooling, although other languages are improving there as well. Since C++11, C++ has gained new steam, released itself from the Better C stigma and turned into a pleasing language, with the necessary tools for writing safe code by anyone that cares how to use them.
While not the OP that is usually how I feel, when looking at the NDK APIs, written in safe C++, and exposed as unsafe C ones.
You can use malloc and new, but the same DLL also has to be the one calling free and delete.
One topic other people haven't mentioned, is that a lot of other languages were inspired by it so picking up those languages will be easier.
&gt; sad I posted this in another answer but here it is again: https://www.youtube.com/watch?v=LNXkPh3Z418#t=17m47s 
What he is saying is that you can easily make a java dev from a C++ dev, but not the opposite. And I think it is mostly true.
Bugs are like poop: only mine doesn't stink!
Exactly. A few weeks of study of C++ and you won't get a job as a C++ dev. A few weeks of study of java and you can get a job. It wouldn't even need to be intensive study, just to learn a few terms and how stuff is built.
Agreed. The key thing is that the instructor must be competent enough to press upon the students the differences and where to use what. The rest is up to the students, but not teaching them the basics doesn't make sense to me. The whole process will make them not only better equipped to handle situations that go awry, but also make them appreciate the reasons for using these higher level constructs in C++.
&gt;You pull "facts" out of your ass. Give me some data that support this. It's the fact. Try to look around, my little boy. &gt;So much hypocrisy. You can't accept, that the whole first half of your original comment is filled with bias, can't be supported by real data, and does not reflect the experience of the majority of people. Lol. You described yourself here. No real data, just "important opinion which I like" &gt;The only thing you wrote there that I agree with, is the sentence about JavaScript jobs. Your agreement or disagreement means nothing. But you suddenly don't demand 'some data' about the javascript point because 'you agree'. But the rest is 'hyperbolized' because, you know, you 'don't agree'. You behave like a kid. "The truth is what I like". So try to look in the mirror next time you pull out the word 'hipocrisy'.
That's the core of his statement, yes. And I agree with that. All I was saying is that believing that you can do java because you do c++ is incorrect. However, you can transition a lot easier. :)
That's getting ridiculous. I'm not sure, why I need dynamic memory allocation at compile-time, when I statically know a) the size of an array/object and b) the lifetime of it anyway. Maybe they should just build in a c++ interpreter and be done with it (wouldn't it be cool if I could write a file during compilation?).
When it comes to the Job market you may rarely see C++ on the top of any "most used languages" charts these days. However, unlike the other languages you see on those charts, C++ doesn't go through the fad cycle. What I mean by this is, when it comes to using languages like C# (which I use at work) and Java, or Python/JS/Ruby etc, they tend to go through fad cycles. One inexplicably becomes more popular than the others for a bit. Companies that use them often like to follow these trends. My workplace is switching to Java this year, for no decent reason. This isn't the fault of the languages ofcourse, it just seems to be something that happens with them. This doesn't really happen with C++. It's rarely the big language of the year, but it also isn't going anywhere any time soon and still holds a pretty sizeable chunk of the market. I also read that it is currently gaining traction in the mobile market currently. If you haven't learnt one of the lower level languages (out of the high level languages) such as C or C++, learning one of them properly will likely give you a much better insight and understanding of programming. At first it seems cumbersome and restrictive (due to all the errors you will encounter early on), once you get used to it though, you will realise the higher level languages are the restrictive ones and miss the freedom when not using it. Like most languages, it isn't the best tool for every job. If you need to put out something very quickly and performance isn't an issue, C++ will likely slow you down unless you are an expert. In terms of flaws/frustrating elements. C++ is a very deep language when it comes to features, and not all features are implemented equally. It can make it difficult and frustrating to learn at times. There is a lot of compiler magic that can cause issues when you aren't aware of what the compiler is doing. There is a good reason it does it, but it can be hard to find information on it that makes sense to a beginner.
To reuse regular code that uses new at compile time.
&gt; It's the fact. Try to look around, my little boy. When I go to the dirty toilet, look around, and see a lot of shit, does that mean that all the toilets are full of shit? If you saw shitty c++ jobs, then you saw only a negligible part of c++ job market in the world. I had completely different experience, but that does not make it right for me to go around saying that there are almost no bad C++ jobs and learning C++ will automatically land you a job in 2 months or less. &gt; Lol. You described yourself here. No real data, just "important opinion which I like" I am confused. What "opinion" are you talking about here? &gt; But you suddenly don't demand 'some data' about the javascript point because 'you agree'. I agree with that, because there are a lot of surveys and job listing statistics supporting that. The same can't be said about the rest of your original comment.
It's *placement* new and *placement* delete I believe only.
The more language features we can move under the `constexpr` umbrella, the better - because it means we have a better chance of being able to re-use existing code that way. Of course, for many features it might be more work than it's worth, or impossible, but overall, making a feature usable in `constexpr` has value if it's practical to do.
Swift is objective C based. 
I'm going to refine my advice now I've digested the SPECTRE whitepaper at https://spectreattack.com/spectre.pdf a bit. One can do a great deal to mitigate attacks with current compilers if you do the following: 1. Eliminate **all** shared libraries from your process space. Shared libraries are the main mechanism for gadget discovery. (Note that on Windows you cannot eliminate all shared libraries, NTDLL.DLL always remains, but let's assume Microsoft will issue a fixed edition some day soon) 2. When linking your binary, turn on LTO. This will remove most indirect jumps in your executable because virtual member functions will be finalised, and this will reduce the attack surface very considerably. These two steps will do a great deal to help, but in the end you're still held vulnerable by the OS. Nevertheless, worth considering.
When performance is absolutely critical because you're making real time systems, large scale AI, or scale is so huge that perf matters (Big 4 &amp; co.) C++ is the clear winner. My skill set is heavily c++ skewed and I have seen no shortage of high paying jobs. C++ is also a great language for building a lower level understanding of computers since it operates very close to the metal and concepts like cache locality start to become more relevant. Knowing how a system works under the hood will probably help you write better code in other languages too. On the other hand, if your goal is to learn webdev or something else where c++ isn't a good fit, you're probably better off learning something else.
Because cpp is life.
And here we see your true colors. When faced with truth, you dismiss it and instead turn to ad hominem attacks.
This is more C than C++ though. I think it can be good to write it that way to learn what the data structures are underneath, but it might be interesting to give the C++ equivalent. For example, the first problem ([nthToLastNode](https://github.com/mandliya/algorithms_and_data_structures/blob/master/linked_list_problems/nthToLastNode.cpp)) could be implemented like this (which seems simpler to me and doesn't leak memory): #include &lt;iostream&gt; #include &lt;list&gt; int main() { std::list&lt;int&gt; l{ 3,2,1,5 }; std::cout &lt;&lt; *std::next(l.rbegin(), 2 - 1); } This is on a doubly linked list, which might not be what the problem was asking for... But even for a singly linked list, we can solve it much simpler than the solution proposed: #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;forward_list&gt; int main() { std::forward_list&lt;int&gt; l{ 3,2,1,5 }; auto size = std::distance(l.begin(), l.end()); std::cout &lt;&lt; *std::next(l.begin(), size - 2); }
You can call the police also, kid.
I suspect almost all programmers who started with C or with a "C with classes" approach to C++ have been bitch slapped by the free function on multiple occasions...
Thank you for indirectly acknowledging that you are unable to back your opinions with any valid arguments.
C++ is not nice for network programming.
Is it really common for universities not to teach those things?
If you're timing the whole program, then you're doing it wrong. This program also includes the generation of random numbers which will dominate the performance here. (The random number generation is using a good generator and using the correct way to limit the output range instead of a modulo calculation; this correctness is slow.)
There are other examples where you use a [text file](http://docs.conan.io/en/latest/getting_started.html).
Your swap function only swaps the values to the function, which have their values (a and b) initialised from copies of those passed in at the function call site (first and second). When you change a and b to doubles, then your `swap(first, second)` line instead calls std::swap(int, int), which you have imported into the global namespace accidentally with your `using namespace std` line. So it's not calling your code at all.
See [Standard containers and constexpr (P0784)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0784r0.md)
Scott Meyers, Effective Modern C++ C++ coding standards by Sutter and Alexandrescu, though it is prior-modern C++ C++ Concurrency in action, by Anthony williamns And Programming principles and practice by Stroustrup if you didn't read it, which contains bit of interesting thing concerning C++ in a general purpose programmation book, like a bit of history on programming and how to use C++ for embedded stuff.
Take out the "`using namespace std`" - you're calling `std::swap` which does the *right* thing.
If you want to work in the games industry, learn C++. Even if you're an indie dev, eventually you'll have to venture into C++ land for one reason or another. Also embedded uses C++, but I know people who work at Google and Microsoft that use it still, so...
Thank you I get it now wow, its the funtion overloading thing isnt it :))
Were being thought it so we dont have to type std::cout all the time but yeah i understand 
Well, they are a central point of doing Windows development , more so with COM taking a central role in Windows APIs since Vista, so they are pretty much unavoidable.
If you master C++ then you will automatically have insight into how many other languages work under the hood. It forces you to constantly think about copying, referencing and moving, and the costs involved, and you’re always aware of how and where things are allocated. I think this C++ habit of being quite paranoid, or being an absolute control freak, is fantastic for writing efficient code, regardless of the language. It’s also a funny language because though it is super abstract / high level you still have to understand all the low-level implications of everything you write anyway. (Which, for me, kind of defeats the point of abstraction.) For instance, if you use a fancy operator that has been overriden by someone, you damn well better be sure you know what it does. But it’s still my favorite language.
thanks man
Well, you just found out that the downsides far outweigh the benefits. 
Really? Because someone on their first day might not realize that STD has a swap template?
Haha yeah it was kinda annoying to get my head around especially when dealing with loops and arrays. And also the fact that we had to majorly rush our learning because we lost a whole month of school due to a province-wide faculty strike so I feel like I didn’t learn as effectively as I should have. I wanted to start with C++ first but that’s just not how it works with the program layout. But thank you for your tip I’ll be sure to remember that!!
For me it was in comp architecture were we went over that material and assembly language 
I believe you mean it calls `std::swap(double &amp;, double&amp;)`...
My understanding AFAIK is that different versions of the runtime have different heaps. So I *think* that if everything's guaranteed 100% using the same runtime you're fine Which is obviously a guarantee you don't want to rely on as its terribly finickity
This is just my ignorance showing. I have to read up / ask at work about Ada and whether we considered it.
My understanding was that he was changing the signature of his function, so that the call would be that of the standard library, which would be `std::swap(int &amp;, int &amp;)` so I take your point on that and will edit the ampersands in.
There was a thread just yesterday, but it's been deleted I think. The top answer suggested A Tour Of C++ by Stroustrup. It has nothing about TDD though 
I have some trouble understanding what the intended audience for this book is supposed to be. Its contents are completely unstructured, with subjects thrown in in more or less random order. Much of C++ is touched upon, but there is precious little actual explanation for each subject. The disjointed selection of subjects give it a cookbook-like feel, but there are no recipes. Is it too early to nominate a book for "worst C++ book of the year" yet? 
Ah yes, you're right. Silly me.
(Not sure why you get downvotes because of opinion, but well...) I hired *a lot* of people in my career. I would be ok to hire a C++ dev that would want to switch to java (unfortunately, they would never pass through the recruiters — and I would not tell recruiters that I could ok such profile, or 90% of the candidates I would get would be of the wrong background) but not the opposite. I actually did recruit C++ dev for java positions in internal moves (“hey, f54280, I have mr CPlusplusDev that would like to go to java, do you think you have a spot for him?”). But a java dev that wants to do C++? [Probably not](https://youtu.be/4h-wVe9a6rQ)... Of course, it doesn’t mean that the C++ guy would crank java in the minute, but I’d be disappointed if he was not committing code within a week.
**Company:** Adaptive Vision **Type:** Full time **Description:** We provide software for industrial machine vision systems. We are looking for C++ developers with various levels of experience, but only for the ones who are really passionate about programming. The tasks will include algorithm development, deep learning or system programming. **Location:** Gliwice, Poland. Our office language is Polish. **Remote:** Occasional. **Visa Sponsorship:** No. **Technologies:** C++11/14, optional: TensorFlow/Caffe **Contact:** praca@adaptive-vision.com
I see your concern about pajamas. Well, this part was .... j/k I struggle with burnout, and my brain needs to be challenged with new work. So for me, the discipline aspect is managed by asking for challenging work. Once I have something to do, discipline is easy, and focus follows. I know it's a good task if I start on it and don't realize it's already time to go home. If only every task was like that! So on this I think it's about knowing what drives you, and accommodating that in work; the rest has, so far for me, easily followed. It's also important to convey this honestly to a manager; it helps them distribute work. From a management perspective, project management is easier if remote employees can break down tasks, do accurate estimations, and get it done. Estimation is hard; several years ago I tracked my predictions against actual results and was shocked. But it was eye-opening, and my estimates now are far more accurate (the adage about multiplying estimates by 2 is very close to what I've experienced). Accurate longer estimates are worth more than impressively short and incorrect estimates. If I was to sum it up, it's about knowing what drives you, and managing that.
[removed]
I love it :P 2 templates 15 for loops 19 keywords 
How do you feel about ASIO for network programming?
Rust FTFY
**Use &lt;vector&gt;.** Seriously, vector will work similar to a Python list. As a beginner, you are actively harming yourself by using `new/delete`. The major difference is doing `a=b` makes a copy of `b` instead of a reference to it. So, if you change `a`, `b` will NOT automatically change in C++. If you want `b` to change, use a [reference](https://www.cprogramming.com/tutorial/references.html).
Before I stopped coding, Boost was *hacky*, but it had some really nice libraries both for generic programming and scientific programming. I'm pleased to see that the concept of *smart pointers* have made their way into the standard. I even remember when the STL was first released. I loved the way it made generic containers available for classic algorithms. The syntax was a little kludgy, but even that seems to have been fixed some newer language constructs. In the late 1990s, many of my colleagues and I were afraid to use the STL for real projects because we didn't know if it would be supported long term. C++ has really evolved as a language over the past 20 years, which is really nice to see. Thank you for the kind reply and for the suggested videos!
If you either know the std library or have an IDE that has auto completion, you basically do know what you are pulling in. Also stepping through the function would show what you are actually calling. I don't globally include any namespaces typically, but I think that pragmatically it isn't nearly as big a deal as some people make it out to be. 
That isn't package creation, that's package consumption.
IIRC you can use both .txt and .py for package consumption - what I mean by that is what's used for the `conan install`. Usually you just want to list your dependencies, and maybe your generator and options. When creating packages you need to do more complicated stuff like specifying how to get the sources, what build options are available (if any), and so on. The documentation got different separate chapters for consuming (`Using packages`) and creating (`Creating packages`). Maybe you just overlooked it ;)
First chapter "hello world", second templates. What a crap.
Typo in the first example page. `str::strtok` -&gt; `std::strtok`
&gt; (wouldn't it be cool if I could write a file during compilation?) Writing probably isn't the best idea, but it would be very cool if files (e.g. images, audio, game assets) could be included directly in the binary (and the source!).
At some point the only way to get better is just to do it. You could find some little project to do and just start programming. It seems like there's a gap between learning and doing where you're afraid to do anything because you want the design to be perfect the first time and you never want to change anything. Well your design is probably never going to be perfect and you'll learn a lot just by plowing in and then finding out where things don't work quite right. Unit testing early and often will expose places where the design doesn't feel quite right sooner rather than later. OOP didn't really gel for me until I had a course in design patterns, much later. At a component level, reading up on design patterns will probably be helpful, if you haven't already. If you're stuck for a project, evaluating blackjack or poker hands is always a fun place to start -- easy enough to get started over a weekend, but complex enough not to be boring. And you can do it without having to bring in any frameworks.
Poco
If you type out the namespace all the time, you'll always know where everything came from. That's moderately important when it comes to figuring out what _that one_ object does. If I were teaching a class, I'd never tell my class that 'using...' was a thing.
&gt; its hard to “snap back into” C++ if you’re not really a C++ dev I've been doing c++ professionally for ~ 3 years now using 11/14. Lately, I've been doing some android dev for hobby projects. It's crazy how much c++ has influenced my development. I'm always thinking about ownership of data in every class/method/function I write. Always thinking about when I'm making unnecessary copies, and how in Java it feels like you are making unnecessary (in c++, anyway) local copies constantly.
Thanks. seems as if that proposal would give me exactly what I need - I just hope that it is not too ambitious.
&gt;C++ is marooned in the 1970s with its lack of standard support for graphical output to anything other than stdout. I think this belief is misguided: Not everything should be baked into the language and crystallized for all eternity (and as we see time and time again with the standard, it really is for "*all eternity*" since any change, no matter how small or how sane, breaks a bunch of perhaps terrible code that no one is willing to fix). Graphics in particular is an area that has undergone a lot of change in recent memory (in my lifetime GPUs have moved from essentially being a state machine that OpenGL modeled quite well with its API to a massively parallel floating point number cruncher which required an entirely new API to leverage effectively) so I think pulling it in and crystallizing it is probably misguided. There's nothing wrong with having a *de facto* standard library for a certain domain-specific task that everyone uses. The issue is that build systems and disparate platforms make this difficult given that C++ is truly native. I think just dragging everything including the kitchen sink into the standard is misguided. I mean look how rueful people are over I/O streams. At this point I feel like people are doing it because getting something into the standard feels prestigious and they want their little corner of the world to feel/be prestigious.
&gt;I already have the c++ primer sitting in a bookshelf back home. It's obviously a great book. However, whenever I pick it up, I get stuck in it for way too long, and the longer I look into it, the less I realize that I know and the more I start despairing even starting with programming in the language. :P So you find yourself picking up a book, realizing that there is something you don't know in it (that takes time to understand), and that makes you not want to learn the language? As an "experienced programmer", you would be capable to understand that, and also that concepts like TDD have nothing to do with a specific programming language. There is a link to a list of books on the sidebar that are all worth reading from cover to cover.
As far as I remember, this idea was introduced by Herb on GoingNative a few years back, with "beginner-friendliness" as the reason. This problem was solved in other languages with modules and proper packaging systems, so there is really no good reason for C++ to be an exception and bake this library into the language instead...
* C++ template complete guide: http://www.tmplbook.com/ * Effective Modern C++: http://shop.oreilly.com/product/0636920033707.do * Modern C++ Design : https://www.amazon.com/Modern-Design-Generic-Programming-Patterns/dp/0201704315 * C++ Concurrency in Action: https://www.manning.com/books/c-plus-plus-concurrency-in-action * C++ Template Metaprogramming: Concepts, Tools, and Techniques from Boost and Beyond: https://www.amazon.com/Template-Metaprogramming-Concepts-Techniques-Beyond/dp/0321227255 Apart from this :- * cmake online reference and MSBuild book I seriously doubt rust and golang developers, they may take over our jobs. So, you should learn rust or golang. 
Recent related discussion: https://www.reddit.com/r/cpp/comments/7nnfrp/mparkvariant_v130_release_support_for_gcc_48/
Yeah, I'm not sure, sorry.
I'm in the "Creating packages" section but it made the jump from `.txt` to `.py` without fanfare or clarification about the distinction.
Does Poco have async networking?
You can force it to, but iirc you have to use a different garbage collector and configure that... and it's expensive because it has to basically rebuild the heap. 
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7pwfk6/question_about_call_by_value/dsl109r/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
TIL there is std::get_if Does anybody knows why it takes variant by pointer, seems very unC++ish to me.
No no no no no. There is nothing wrong *at all* with pointers in modern C++. The only problem is that people confuse the advice not to have owning raw pointers with not having any raw pointers. There is a big difference between the two. To answer your question: I believe it is like that to avoid people passing in temporaries and then getting a pointer to a value in a variant that will get destroyed in the next statement.
No matter what they come up with, if someone wants to bypass it they will. They could use git hooks to remove the comments when pushing and add them when pulling, too.
Does std::variant have a valueless by exception state?
Correct me if I'm wrong, but can't variant be "valueless_by_exception"? In this case the else branch is incomplete and therefore not equivalent to visit. http://en.cppreference.com/w/cpp/utility/variant/valueless_by_exception
In that case, couldn't it take the variant by reference and then return an std::optional?
&gt; To answer your question: I believe it is like that to avoid people passing in temporaries and then getting a pointer to a value in a variant that will get destroyed in the next statement. IIRC temporaries can not bind to modifyable references, so I think `` template&lt;typename... T&gt; `` `` void get_if(std::variant&lt;T...&gt;&amp; var){ `` `` }`` would work fine.
Then in that case, it would need to return a reference to the object, so `std::optional&lt;T&amp;&gt;`, which is ill-formed currently.
Good point. But if you change the `visit` code to: if (v.valueless_by_exception()) return nullptr; return std::visit(...); and replace the `__builtin_unreachable` in the `if/else` code to `return nullptr`, then the two implementations should be equivalent but the visitor code still produces a huge overhead. 
Since std::optional&lt;T&gt; can't wrap a reference, that way the caller wouldn't be able to modify the requested T object inside the variant if it existed: the returned optional would have a copy of it. I guess an optional&lt;ref_wrapper&lt;T&gt;&gt; could be returned but that seems a bit silly ... semantically that's almost synonymous with a possibly-null T* anyway :-)
Interesting, I didn't know optional references are ill-formed. Thanks for the correction.
 void f(type&amp; x); f(x(params)); does not compile though.
The lineage of the function can be traced (best I can tell) back to `boost::get` which determines whether it returns a pointer (and doesn't throw) or a reference (and does) based on whether its argument is a pointer or a reference. Best I can tell the standard didn't like that and changed the name but kept the pointer-ness of the argument, which I think is dumb.
Yes
It kind of follows the pattern of `dynamic_cast` which can either use pointer semantics in which case it fails by returning a null pointer or use reference semantics and then it fails by throwing. I mean, it doesn't match up exactly, but that's the general idea. 
&gt;Throwing exceptions considered harmful: http://250bpm.com/blog:4 I really hate that blog. It starts out with a false equivalence and goes from there. &gt; With C, the raising of the error and handling it are tightly couped and reside at the same place in the source code. ... With C++ you just throw the error. That is just wrong. If you need error handling at a spot, then put error handling there. If you want to stop and throw an error use an exception. The equivalent C example is: int rc = fx (); if (rc != 0) goto exception; Except, for the love of god don't do what this blog does for the C++ example. Actually throw a relevant exception. At the least use `std::runtime_error('&lt;What went wrong&gt;')`.
"The C++ Notes for Professionals book is compiled from Stack Overflow Documentation, the content is written by the beautiful people at Stack Overflow." In other words, it's crap.
If I recall correctly, we will split this into smaller sub-proposals.
You're having such a meltdown. Take a breath, keep to the topic, try to bring yourself to reason and work *with* the person you're discussing with. It's not a competition to 'win', it's a discussion to expand ourselves and eachother. People have pointed out to numerous cases that contradict your claims, but you're throwing them out without backing (saying "it's the fact" is not sufficient) on a whim without even *trying* to acknowledge them, then dropping your own credibility even further by tossing in frivolous insults. This only harms you, not anyone else. You've closed off to discussion and are being one thing you've complained is a problem with c++ devs *("old farts who don't care [...] about learning something new")* Try arguing to the points and not attacking character (bn_n)b Also be willing to concede to other points, even if the presentation style is faulty. &gt; I see you too smart to acknowledge your faults I fail to see how you came to that conclusion from that particular quote, and my own faults were hardly the topic considering that was my first entry into this thread. You're changing the topic. &gt; I don't want to continue with such ignorant people This is exactly what I'm talking about. This discredits *you*, not anyone else; it's a tactic that's generally used when one has nothing to add to a discussion, but refuses to accept or adapt to another's point.
If you roll your own `if` based visit implementation, you get the same assembly: https://godbolt.org/g/4mnvU2
It depends on the return type of the function. If it returns int, then it will still work. If it returns another type (like void in Works2) it won't specialize `&lt;T, int&gt;` so it fails.
I suspect there will soon be separate proposals in front of WG21 to merge (1) the library of fundamental concepts from the Ranges TS into namespace `std`, and (2) the iterators and algorithms libraries from the Ranges TS into namespace `std2`. LEWG specifically requested (1) in Albuquerque: they want standard library concepts to which other proposals can refer rather than every proposal throwing together concepts ad-hoc. It's still very unlikely that we will see existing components in namespace std respecified to use concepts, primarily because the requirements we would want to apply to those components are substantially stronger than the existing requirements. WG21 is simply not going to break billions of lines of existing code.
No, man, people even didn't try to read my initial message. What they did is tried to oppose nonsense I didn't say, like 'C++ is useless', or 'you can't find a new project in C++'. And because of this I don't care what they are saying. Again, they didn't try to read my message, or just read it to pick random phrases and start to oppose nonsense I didn't say. Therefore I don't care what you or other people saying, you even didn't try to understand what I said, why should I listen to you then? P.S.: also you better advise your mom, my little domestic psychologist. P.P.S.: Ah, you're one of that pricks who started argue with the nonsense I didn't say. Ok. &gt;fair amount of industries where C++ is still used a lot Gosh. Try to find how it contradicts with any phrase in my initial message, you dumbass.
But not if you throw an exception on `valueless_by_exception()` like `std::visit` does; in that case you get [the same assembly](https://godbolt.org/g/txg2dW) as `std::visit`. This appears to be one of those edge cases where exceptions are a costly abstraction. Probably unavoidable.
I'd say it's a good rule of thumb to never change the cwd, except perhaps if you're a shell.
Hi johannes1971, some of the books were rendered incorrectly due to a bug sorting chapter index alphabetically rather than numerically, I have rebuilt this particular PDF for C++ and redeployed, thanks See [C Notes](https://www.reddit.com/r/C_Programming/comments/7nv9he/c_notes_for_professionals_book/) for a better reception, have a great day :)
Ok man.... Let me go tell all my coworkers and all the coworkers I've had over the years.... Look, not only have I always had C++ jobs... I frequently turn them down... and I've never had to go very long without a job... Isn't it possible that it's just that your particular experience hasn't crossed much with C++? I mean, it is still a top 5 programming language...
You can do: void f(Type&amp;&amp;) = delete; if you really want to disable temporaries. I'm not a fan of `std::get_if` taking by pointer. I also think it should return `std::optional&lt;T&amp;&gt;` bit that's another story.
&gt; the iterators and algorithms libraries from the Ranges TS into namespace std2 This is obviously the wrong way to do it(new code should get std and old should get std1, but since I know WG21 priorities I did not expect better). &gt; are substantially stronger than the existing requirements My question was mostly about concepts that existing std code already has. For example std::sort already expects 2 RA iterators, and currently those 2 arguments are vanilla typename(aka no restrictions on them). I do not follow how making them RAIterators(to give nicer errors to users) would break something(since existing implementations already are using the iterators in a way that makes sure the supported operations on iterators are exercised). For example see error messages for "concepts" sort (called here xsort) and normal sort: https://wandbox.org/permlink/yQpnvg2RMWraRGs0 I know this is not "fair" comparison, since it is just 1 overload of 1 algorithm, but this is just to give an idea. Anyway Casey thank you for all the work, I wish C++17 gave up on train model so we could get Concepts and fundamental concepts in C++18(and probably ranges in C++20), since this is now quite a long delay, but I can not always get what I want. :) 
&gt;I linked to a good [video](https://www.youtube.com/watch?v=YnWhqhNdYyk) from Kate Gregory that touches on it in another post. her recommendation was to do just that. Yes, I like that video. (It's possible you are the one who told me about it, if you're the Arthur that presents at CppCon.) But I've tried teaching unique_ptr to new programmers before and it's a train wreck. &gt;Don't touch pointers until late in the game Sure. &gt;avoid C[] arrays like the plauge. Agreed. &gt;Use &lt;string&gt; and &lt;vector&gt; wherever possible. Agreed. &gt;Say other containers exist, but don't worry about them in an intro course. Yep &gt;The reason I focus on `unique_ptr` is because of that video. It's easy to just put `shared_ptr` everywhere, but it's really bad practice. So. It depends what you mean by bad practice. Shared_ptr certainly is less performant, but it is easier for new students, so I think it has the win here. Same justification for teaching .at() over []. It's slower but safer, so it's a better choice for new programmers. .&gt;Plus most of the time students don't actually need to move a `unique_ptr`. Sure. But I've seen occasions where they would. In these cases shared_ptr "would just work" whereas unique_ptr forces you to have a conversation that they are not prepared for. 
Mostly, this is a bug in libstdc++. There is no reason for `__gen_vtable_impl::__visit_invoke()` to call `std::get` with its wide contract, since the fact that we are called via the vtable means we know the variant has the correct index. Indeed, we need is to replace `std::get` with `std::__detail::__variant::__get`: decltype(auto) static constexpr __visit_invoke(_Visitor&amp;&amp; __visitor, _Variants... __vars) { return __invoke(std::forward&lt;_Visitor&gt;(__visitor), __get&lt;__indices&gt;( std::forward&lt;_Variants&gt;(__vars))...); } With that fixed, and with your `valueless_by_exception` fairness fix [here](https://www.reddit.com/r/cpp/comments/7pya5s/stdvisit_overhead/dsl35yq/) the codegen becomes [a lot better](https://godbolt.org/g/dZtkPY); gcc codegens for `std::bad_variant_access`, but never actually uses it. Unfortunately, gcc still can't see through the manual vtable - but compiler optimizations are a bit out of my comfort zone. My own solution to the visit problem is to [generate a switch statement in the preprocessor](http://coliru.stacked-crooked.com/a/b5aef07bfb67e1a4). Even with Boost.Preprocessor it's pretty ugly.
When you say list, do you mean like a linked list, or a growable array? If it is the first, use &lt;list&gt;, if it is the second, use &lt;vector&gt;.
Created a [pull request](https://github.com/gcc-mirror/gcc/pull/20).
F35 uses C++ Also Chinese JF-17. ADA has very few people working on it in Silicon Valley/colleges so it was probably easier for TSLA to use C++.
Correct me if i'm wrong, but your solution doesn't check for exceptional cases as well as it's O(n), whereas std::visit is O(1)
Would you like to try https://github.com/lichray/oneof as well? It's designed as a drop-in replacement for mapbox (a subset of APIs) with even better codegen.
&gt; F35 uses C++ New systems for the F-35 are written in C++. They brought over a non-trivial amount of Ada-85 code from the F-22 for basic flight systems.
If I understand correctly, `std::variant&lt;char*, unsigned char*&gt;` can't possibly be valueless_by_exception (no constructor/assignment throws here). 
When I'm working with file descriptors I use the following RAII class I wrote. It's all a matter of style of course. /* * FileDescriptor.hpp */ #ifndef FILEDESCRIPTOR_HPP #define FILEDESCRIPTOR_HPP class FileDescriptor { const int fd_; public: FileDescriptor(int fd); ~FileDescriptor(); operator const int&amp;() const noexcept; }; #endif//FILEDESCRIPTOR_HPP /* * FileDescriptor.cpp */ #include "FileDescriptor.hpp" #include &lt;unistd.h&gt; #include &lt;cerrno&gt; #include &lt;iostream&gt; #include &lt;system_error&gt; // iostream using std::cerr; // system_error using std::system_category; using std::system_error; FileDescriptor::FileDescriptor(int fd) : fd_{fd} { if (__builtin_expect(fd == -1, false)) throw system_error(errno, system_category()); } FileDescriptor::~FileDescriptor() { switch (fd_) { case STDIN_FILENO: case STDOUT_FILENO: case STDERR_FILENO: return; default: if (__builtin_expect(close(fd_) == -1, false)) cerr &lt;&lt; "~FileDescriptor(): " &lt;&lt; system_category().message(errno) &lt;&lt; '\n'; } } FileDescriptor::operator const int&amp;() const noexcept {return fd_;}
Static libraries can work well and there are few times where you can't use them in replacement.
The problem with putting everything in the standard is also that it gets the "lowest common denominator" treatment ie. what can we do on all systems. Then there's the stl treatment where, in a language of paying only for what you need, a lot of unnecessary restrictions on containers etc. get added. Both contribute to bad implementations and force serious users then to use replacement libraries.
Sure, but you don't have to use the standard library, it's enough if it's decent general purpose. If you need something specific you'll use a third-party library anyway so whatever is standardised will not affect you.
Not sure I follow, of the languages I use C++ has by far the smallest standard library.
But that's the whole point of a standard library. You want something that is general purpose and good enough for most things. If you want something specific you'll use a third-party library anyway
&gt;I seriously doubt rust and golang developers, they may take over our jobs. So, you should learn rust or golang. You say you doubt them but they will still take over the jobs (assuming the C++ jobs)? Confused of this sentence structure here.
&gt; unordered_set buckets have to contain lists Their invalidation guarantees imply that they must be node-based, although only forward linking is necessary (MSVC's use of bidi lists is unnecessary). Requiring hash containers to be node-based is possibly not ideal. &gt; small vector optimization isn't legal By design, since this allows swaps/moves to preserve pointers/iterators. &gt; and list::splice between two lists has to be a linear time operation. Splice-some (versus splice-one or splice-all) was consciously chosen to be linear time; there is a tradeoff here between its efficiency and that of list::size(), and in C++11, list::size() won the battle.
Eh the contributers of the standard library surely are heavy users if it, and its design gets debated to death before it gets accepted. There will be oversights and it's not going to suite everyone, but if you prefer something different than what's in the standard library there is nothing stopping you anyway so I fail to see the downside
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/7q192q/noon_help_please/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Sounds like Ontario.
First two are admittedly up for debate, but performance wise they're pretty clear. I'd have taken consistent constant time list::splice() in a heartbeat over constant time list::size(), to me it's the basic essence of a list.
There's a point at which things get so large and complex that theres not enough time and qualified people to track and debate the issues - this is also a valid reason to not include everything and the kitchen sink in the standard.
Why does so much effort go into making sure operations on containers don't invalidate iterators? Is it a safety thing to prevent people shooting their feet off, or is there a use case for when preserving iterators after a swap is useful? I don't use many containers other than vector/array, and only use iterators for iterating, so I'm quite oblivious.
I use unpacked MVector that are sorted via the vector-algorithms package. That's the fastest known way (excluding GPU/parallel algos). The haskell code is a bit slower than R sort, and R sort seems to be pretty good.
I would much rather be able to throw from constructors. The purpose of doing that is too guarantee that an object is valid if it gets constructed. I don't want to test if objects have gotten created successfully before I can use them. That might even have a performance cost of its own.
If you really want to improve you don't need a guidance. You'll find the way by yourself. But if you don't want to improve you'll ask for guidance, books, tutorials, links, advices, etc. The only guidence is that - write the code, motherfucker.
Groawable array. I’ll learn vectors! I haven’t found the use case for linked lists yet. I guess they would come in useful when order is really important? Are linked lists easier to manipulate for order than vectors?
edited...I am not a native speaker
Neat? `cl.exe /c Main.cpp /errorReport:send`. One and done.
&gt; Given that MSVC is the only option available if you want to deploy actual production desktop applications for Windows As one of the developers of clang on Windows, which will soon be responsible for compiling 100% of the code in Google Chrome, I feel it necessary to disagree with you on this point :)
Hear, hear. I get the impression that those promoting PIMPL have never tried to use it in a non-trivial codebase. The maintenance headaches it creates alone are enough of a disincentive. Unless you are developing a framework that must preserve binary compatibility (and then something like COM is also worth considering) there's no real advantage.
It is. And it is. :)
Looks good! Thanks for clarifying.
Preserving binary compatibility can be quite a burden, and probably not something you want to worry yourself about in the early stages of a library. I suggest you wait until you have a relatively mature library with a decent number of users, and just focus on adding features and improving the interface and docs, etc. In any case, there are other ways of achieving what you describe that don't have the drawbacks that PIMPL suffers from. (See discussions elsewhere in this thread.)
Here's the most recent source I can find: https://groups.google.com/a/chromium.org/forum/#!msg/chromium-dev/Y3OEIKkdlu0/TCcT1SvwAwAJ Another source is me (I'm one of the clang-cl developers)
The main use for a linked list is when you need to repeatedly insert into the middle of an ordered list. This... doesn't happen very often. If you only need to add and delete at the end, vectors are what you want. This is probably the most common use case. If you need to be able to insert and delete at both the beginning and end, double-ended queues (deques) are the best data structure.
&gt; throwing in destructors is pretty much not allowed. Throwing from destructors is perfectly valid. It's just very easy to do it wrong.
That's really C. Today's C++ positively screams "high level". For someone who begins with modern C++, that lower level is invisible. It's amazing, really, because the compilers still "see" right through C++ code and give us very good assembly.
It can be if you assign something weird to it: struct Weird { operator unsigned char*() { throw 1; } }; int main() { std::variant&lt;char*, unsigned char*&gt; v; try { v = Weird{}; } catch (int) { std::cout &lt;&lt; std::boolalpha &lt;&lt; v.valueless_by_exception() &lt;&lt; '\n'; // true } } [Live](https://wandbox.org/permlink/cuQqinydCdTSXt8b)
But `HasHelloFunction&lt;T, double&gt;`, for instance, is still a specialization of `HasHelloFunction&lt;T, typename = int&gt;`, just with a different value for the second (unnamed) type parameter, right?
&gt; that nobody will ever care about, because the integer is discarded immediately afterwards. I thought so too, until LLVMs integer sanitizer gave me a warning for that. 
I don't think asymptotic analysis is very useful for something like this. Realistically, the number of types in a variant are going to be limited. Also, the "O(n)" method manages to completely optimize away.
RAII is superior to GC
Things like the small vector optimisation thing should not be an implementation detail, though. If I were to write software that relies on SVO to avoid countless small allocations (and I do, actually), I don't want to see my performance evaporate the moment I move to another compiler that doesn't implement this technique. So if there were SVO it should not be some optional optimisation, it must be part of the public API of vector itself. The careful wording in the standard serves to avoid this problem (although not always: apparently a bucket size of 1 is perfectly acceptable for std::deque, effectively turning it into a linked list). At the same time, it seems to be so specific that I've often wondered why the committee doesn't simply provide a reference implementation for compiler makers to at least base their version on. Having a well-polished base version of the standard library would eliminate a lot of duplicate effort, as well as the occasional deviation. And it's not as if this code doesn't already exist anyway. Any possible reference implementation could be maintained as an open source project, so we could all suggest improvements. 
How would that work, though? Would there be a garbage collector in the compiler? Or would we accept the possibility of memory leakage? And `new` implies pointers, which means the possibility of UB. Will we allow UB _during compilation_, or will there be some kind of validity analysis? 
Aaah, now I see. Thanks :-)
in this case, yes
bare in mind though that this has linear complexity to the number of types in your variant wheras the standards implementation of `std::visit` is constant
I know UB is out, but I don't know the details of how the idea works. People smarter than me seem to think it's feasible to implement, so I'm not too worried and I can look at the details when it starts making more progess through standardization.
`std::optional&lt;T&amp;&gt;` is an ergonomic disaster. There's just no good semantics for `operator=`. As for deleting `f(Type&amp;&amp;)`, I'd rather not. It would prevent the following: call_me(std::get_if&lt;T&gt;(&amp;make_tmp())); which is a perfectly fine usage of `get_if`, with that `&amp;` just enough of a reminder that you better pay attention to lifetimes.
How it helps? I mean, I've done couple c++ courses and didn't learn a thing about how things work under the hood. Which is why I'm currently trying to do something with c++, but I'vent really learned a lot yet. What would u suggest to do if one wants to learn more about how computers work at a lower level? Currently I'm trying to do a very simple game with c++ and SDL. 
I work in the aerospace and defense industry and for safety critical software and/or real-time there's really only C++ or C (ok maybe Ada). 
What I meant is that check will be there even if you know you will never try to construct your variant with something that can throw during construction. Only way to avoid it is to turn off exceptions completely.
Sure, you can do it, but no one's gonna like you if you do.
I prefer doing that with named constructors that return `optional` or `expected`. That way you avoid forgetting to catch errors, and you avoid the whole `valueless_by_exception` story.
No-one says to always use goto when using return code based error handling, it can be done with standard control flow primitives. Also, exceptions can't travel across module boundaries due to the lack of a well defined ABI, making them inappropriate for use in middleware API's. The author is simply saying if you need to write absolutely mission critical software, throwing an exception and hoping some other bit of code handles it correctly is too gung-ho to get away with in practice. Also, the try/catch blocks often look about as ugly return code checks, so the argument that it "looks better" (a subjective argument) doesn't really hold.
That still involves testing the validity of objects but given that we get a choice in whether we want exception throwing constructors or optional returning named constructors it seems reasonable. I'm curious. Would the extra exception cost of using std::visit go away if exceptions are disabled from the compiler?
I'm also curious about that! I'm no expert, but it'd seem like since there are no exceptions, you can't get into the valueless state, and hence the check would always be an `if false`, or alternatively `if valueless { unreachable(); } `.
In that case, this should be considered a bug in the sanitizer.
I kind of get your point but what even is "modern C++" formally? There are no section in the standard named "ancient C++" and then "modern C++". Most of what you could do before with the various core features, you can still do. That includes unchecked pointer arithmetic, so maybe it would be better to write "there is nothing wrong at all with pointers in modern C++ unless for all the parts that have not changed and that are still dangerous and that you should not use".
 template &lt;class T, class... Types&gt; T* get_if(variant&lt;Types...&gt;&amp;&amp; pv) = delete;
That's definitely true for this implementation, and I believe all the std::variant implementations I've seen. Whether it's true in general for std::variant, I'm not so sure. It doesn't seem unreasonable to test at compile time whether assignment to all of the underlying types can throw (or whatever other cases can cause the variant to be empty). But I haven't tried, so I don't know for sure. Perhaps it hasn't been considered necessary.
Nothing wrong with a switch. Your improved code above: getPtr(std::variant&lt;char*, unsigned char*&gt; const&amp;): movzx eax, BYTE PTR [rdi+8] cmp al, -1 je .L10 sub rsp, 24 mov rsi, rdi lea rdi, [rsp+15] call [QWORD PTR __gen_vtable&lt;void*, getPtr(std::variant&lt;char*, unsigned char*&gt; const&amp;)::{lambda(auto:1)#1}&amp;&amp;, std::variant&lt;char*, unsigned char*&gt; const&amp;&gt;::_S_vtable[0+rax*8]] add rsp, 24 ret .L10: xor eax, eax ret [Handrolled switch that's presumably code generated](https://godbolt.org/g/gRkHWi): getPtr(std::variant&lt;char*, unsigned char*&gt; const&amp;): sub rsp, 8 cmp BYTE PTR [rdi+8], -1 je .L11 mov rax, QWORD PTR [rdi] add rsp, 8 ret getPtr(std::variant&lt;char*, unsigned char*&gt; const&amp;) [clone .cold.9]: .L11: call auto custom_visit&lt;getPtr(std::variant&lt;char*, unsigned char*&gt; const&amp;)::{lambda(auto:1)#1}, std::variant&lt;char*, unsigned char*&gt; const&amp;&gt;(getPtr(std::variant&lt;char*, unsigned char*&gt; const&amp;)::{lambda(auto:1)#1}, std::variant&lt;char*, unsigned char*&gt; const&amp;, std::integral_constant&lt;unsigned long, 2ul&gt;)::{lambda()#1}::operator()() const [clone .isra.2] 
There are already libraries like SDL that solve this problem very well, work on every platform, and have a simple interface. With this proposal, every compiler would have to provide their own implementation, which would effectively be reinventing the wheel.
Iterators can be used as object pointers, which is why they often implement the same semantics as pointers.
Where can I get a copy of the slideshow? The cppcon 2017 github repository seems to not have it.
The same lines that might throw, might also return an error code. There is just more effort in handling each error individually when generated, since it may need to percolate through any number of layers before it can be handled. That, at least, happens automatically with exceptions. 
Possibly because iterator invalidation means the object in the container was moved to a different location in memory. Not every class supports copying or moving, so it is important to know which container functions require that functionality. 
Also pretty sure all functions in C are free functions by definition since they have no concept of namespaces or classes...
`new` and `delete` still very much have a place in writing modern C++ but it should almost always be abstracted away into some sort of RAII type pattern. Even then RAII doesn't cover all bases, such as objects that exist on the heap beyond the scope in which they were created and owned by no other scope (this mostly applies to threading implementations), which in that case you have to fall back on more traditional dynamic memory management techniques (or weird stuff like deleting yourself).
This is a good argument for me to use when people get hesitant to use the RT patches for Linux.
And there has been complaints that the F-35 codebase has grown to be unmaintainable with C++. I don't blame C++ for that, but Ada is very much a language that works to make itself maintainable by design.
Tbh if build tooling improves in C++, then there wouldn't even be a need to add 2D graphics into the standard library since anyone can just easily grab one of the many battle tested and feature complete graphics libraries out there.
&gt; retain linkage compatibility I think that is too weak, in a sense you need easier way to transition. I think you need to target C-&gt;C++, Java-&gt;Scala relationship where new language can easily use the old one. P.S. This is not me telling you are wrong, I am right, this is just my opinion. 
Yeah, I also don't know exactly what the considerations were, and why we didn't use a dedicated RTOS instead of linux. But it seems to have worked out fine for us.
That's a shame.
Pointers are already allowed during `constexpr`, and if you trigger UB during compilation by way of bad pointer operations, the program is ill-formed. This is definitely the case in C++14, I think it may also have been true in C++11. That is not the current barrier. The only thing that is missing to support `new` AFAIU is just that the standard allocator functions are not marked `constexpr`, and we would have to figure out some way that memory allocated at compile-time gets mapped into the executable's page when the process starts. I think one thing you could do is, allocate a large chunk of BSS and then make `new` serve requests from that chunk while it is called as `constexpr` basically? And when it is not called as `constexpr` it works normally?
You get a lot of benefits running on Linux vs. a slim RTOS for more computationally complex systems. I'd be surprised if other parts of the automobile do not run on a bare metal OS though.
Absolutely. In fact I can give a specific example. I contribute to a project that has a `config_file` class. I currently have to open, modify, then close the file every single time I want to do something with it. I'd love to just get a file handle at class construction, and relinquish it at destruction. However, I can't guarantee when that destructor runs. The program could immediately drop it, or it could hold on to that handle until the program itself closes.
Did you mean Microsoft's (formally managed C++) Visual C++ with managed? I'm not sure but there is a Stackoverflow's booklist: https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list
&gt; I loved the way it made generic containers available for classic algorithms. Now we even have [`&lt;algorithm&gt;`](http://en.cppreference.com/w/cpp/algorithm) so we don't have to re-invent the wheel every time. Honestly, it's sort of amazing. If you don't care about order, then it's amazing how much data processing you can do without ever writing a classic loop. The best part is those library writers could optimize the crap out of the code, even using specific x86 additions if they're available, and we get the benefit while writing less code.
Ah damned. I've been spoiled by Rust :(
There are a lot more implementations than just SDL out there, and if there are already lots of good examples, is it really reinventing the wheel?
Copy-pasting achieves nothing either.
If you wanna know about low level programming then learn C. Unless you have a reason to learn C++ specifically. And in my opinion starting with bare bones lets you see why C++ was necessary and why they add the features they do and also why some features have poor design. Spoilers, backwards compatibility.
Distilling lots of examples in to a simple library doesn't mean copy and pasting. SDL also comes with more than just a window and events. 
Absolutely, 100%, don't do this. What do you think takes longer? Learning the "wrong way", then learning the "right way", or just learning the right way? It is better to just learn C++ than try and understand its back story before jumping in. That will gain you very little. Here are some other people who are annoyed by having worked with C++ programmers who learned C first: https://www.youtube.com/watch?v=YnWhqhNdYyk https://www.youtube.com/watch?v=fX2W3nNjJIo https://youtu.be/D7Sd8A6_fYU
this attitude is what keeps C++ twenty years back. 
But boost::X has become std::X in a few cases.
I was wrong, I edited my post to be more reflective of OPs original intent "know the basics of software, but don't know low level nuances and basics." Which I think C is more suited for if that is all you want to know. But you are correct that C is not C++ and you don't program C++ like C. I didn't mean to talk about actual development, I meant to talk about just learning.
Others have listed great books, but since you explicitly called out the "managed" aspect, I wanted to bring extra attention to one thing in particular: RAII. In the absence of a garbage collector, a technique called Resource Acquisition Is Initialization (it's a bad name, sorry) is what you'll use to ensure memory -- and other resources that fit an acquire-release pattern -- gets released. https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management
It also turns out that the cache locality of std::vector dominates everything on modern architectures where main memory might as well be across the network. 
Is there a common language where anyone actually uses that languages standard support for graphical output, and is happy? Java does not make anyone happy, unless things have changed radically recently. I suppose if you conflate the browser environment with javascript, there is an argument that can be made there. 
C++ tends to be much worse in this regard. Most modern garbage collectors will compact, and it's easier to then discard unused address space. That doesn't happen naturally with C++. One thing allocated at the wrong place means that address space can never be retired, and may need to be repeatedly brought back into memory. 
I'm more active over on Quora.com, but I do have a few answers that might be helpful. tl;dr: Lots of cool programs are written in C++, and you can have in-on building these (or similar programs)! Longer (but not comprehensive) answer to 'Why do colleges still teach C and C++ when you can't even build anything with these programming languages?': http://qr.ae/TbSRRi Longer-still answer to 'When is an appropriate time to learn C++?': http://qr.ae/TbSRRJ &gt; One of my New Years resolutions this year is to learn at least two more languages to a commercial standard. If you _do_ decide to learn C++, I recommend that you strongly consider what is suggested here: http://qr.ae/TbSRRx This one is possibly off-topic, but it might be useful if you're scratching your head regarding projects on projects to build: http://qr.ae/TbSRRV &gt; How many pure C++ jobs are out there compared to other languages? Although I answer this in my first link, I think this question is too vague. Which industry are you interested in targeting? 
folly has something similar, without constraining it to c++17: https://github.com/facebook/folly/blob/master/folly/ScopeGuard.h. 
It doesn't cover C++14 :( Anyone have a good rundown of 14 things?
Every day the same post.....
Needs to be put into the sidebar. This is hardly a unique problem, and in any case, this is more suited for /r/cpp_questions.
Really nice introduction. I appreciated that it is kept very simple to get a first understanding of how JITs operate. 
I have created alternative implementation of std::visit which does not use function pointers but indicies and is therefore able to optimize the code of the post. [my_visit alternative to std::visit](https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZSAbAQwDtRkBSAJgCFufSAZ1QBXYskwgA5AHoAVAsVLlK1WvVyZHAAwBBeQGpdDApmIsmBPADdMBwQXQgQ1vIMIG8AWwAODTF6YLASWeKgsBpFRmjr6cgZeAJ4A%2Bq7uBFGZWdk5uZExeoZ5xSWlBgVxBgis6Ax4bAaoAGYGxJgEYhHWqHjoCW7uDSUV8hpj4%2BNaerHcAMz1yAwiWAYcswDCyA7oWE1r2DNc8yyLy3Zr600iJ1bhTAz7h8enKxcEiT6YyQTETISCj2mRwWS1eG2sTGIeFYBEBuliMhkBh4THcyAMaBYDkwAA8fMQDJDfolPL5/IFgqFwrFTGTLOcNu9PhZAgYACqkeyOZzuABeXwyLDhi1Rggx4WxeOIySJTESMwA7Hw9D4RAAjOrIECxTKYyX48VY0xSmXEYkQACUOqiHCV1sitoAIjM9LqJcaDXqPdLZYkIF7cfjTcTDQ5VlwAGyNAgIMxW102u0J7JNEgGCBMERETyrWaOrlOEB8gW2njaJ1rHg5sBgNb5oWzKv8fh4eO6XKl%2B15JgcACsPDwffzdejseIADoe/3B73nY2u5kK8nVgrndNlwGpaHvcG5eGo6hPr8iMQ6/73YGfWa91796O413O8vMqmCRms6gcyPtjy8PzvqW5arpW1a1nmBgNk2vAtm2HZJu2JRTgOQ65vmqAxmYk59shs6VguiZrgh2RtB05jlDGbh4cuS7whuF5bpm2aHmYlgkNhQ4QD%2BRZ/gKngWtu%2BGRAAtPs7Lbvuj7wbkJGdIS2EznOypESuhFdpuBqMZ%2BzHHmx/YcVxxbfHxgkGCJszYGJ3ARpJSnSe0slIQpVHKTR%2BI2PS2rLmycn9kKs6oSufDAfO0zBUpCJIupBKxgwR4GNmPysIIr5eAkIgmHgfh2PU%2BASGK2ZMPY9TAP4EWeCwWA4oSFUGGqTDIAA1oSwB/EKei0n49K5usBk8d844DQY%2BBeAC5mxA4xAiMgGReOlVi7ikOW4oqtlRIiBhNPVJ6Ej4fh4JgfQJbG5WVY0LQUWKw1BO41LLg4oTolFhIfiduIAGJbSQnHctx/4ZMNACSFW4rBiardkmmtO0AW9X9pa0BWIXKZkkOA6YBLfj9hmwkqQGKSZUBo2Yza8N1Q3eEDp1WVZ6YkeUI7DYIFoWqQA3jlaSN2aREQkSBkmqcu61oF4ar1HYs11FlJ14Hl8WfoVgwldlwM4l2HXMKY3VMkETCBGzBiUzLmCjQcd0hFYj30RpL3C6LLCYBAht5frOVG0zEGoLiEg%2BLC1FSTkkN05jhbY4BiPg1kqMU%2BjMNY31ONluHBMQEH0HgUtOIfdNX1E6e0G8Baciu3lLNsxzEeZDJZG85zBEusp62CHtGSK/4r1VfU2aCJgR70n0GddutF2eGKrDlbYxDdxt1zTWEETNOKIti1290W9ul7PV3zffSH8eL3bB38Swns4t7vsuf72RRQtFywwKnLFs0bMQIzHMWcXxvObkUdeADMfB7%2BOGuMk7PiiK%2BdMP8/7EzzHfACwCwrk1/jHGs34eJPwGi/bwTM%2Bb5x4LnUGxQP4An7LnFCI5bZi3QNwXsGcs4nkwUg4mvBaAWhkLQz6xAGFQOIOXEyVcIhEK/nXdcDckREBCAwCCIgRZmDOoSBgkjBFmweuvBiL0WDSLVGYZIzRkhBB%2BPtQQloPZex7ufRcl8sj8PbnQr6j8mjP1frwv2qkwr1zmHgJouwDAAFUABy6wAAS2B1gAGlsCOmSAAcWwGyJ4ZhiBpn8UEkJ4TIkxO8vcNoTB0Akl2JQ%2BJDBu5PE8d45I0S/E%2BPWOUp4%2BT7a%2BICcEsJETomxILM4cpWAQh4AYB01IkJoTBD6cAdohTilAlmHUuwySmlpNad5LiIzz5zCCPgPYEzVmePrutbwWUKRUnni0JIqQ3CEBpAETqmsLhqw%2BDrVkbJjYEHWHgUgNzmS6zsADQQAA1SiY09ATSmjNFIaRCDJF2Q8JG5y6RXI2G8u5dgHkOGea8s2u8/r6zSHCQF00EggtOQQcFZILhIqeS89pIAM7JG7gARxEEECQFw0hs0eP8%2BE8F1ZdWucubWLI7C/PSCQTk8K%2BX62%2BQMmEJtxrmxluVOo9TIbIHuAwCAK845/QxC8rsArCBpmppGAwoKTyouUuKqEkqJKRkxRK4I2DQoRxEIrAwABZXQAMAoS3mr6cFKtb4/QhOa4I1K%2BrWD9YWLASqUiwg2GawZBApXmRZWNKFdEjQb0hqYZFeAAqkuec4CESxMDOS7J41RBoICZrJWTV1ANnAaJkdKXR%2BioTG0tAQwKJlS0Vsec8gwKDwLIFbCZSu9kyLHKNUSvw3LkZ5C4p3TAwBfgMGSF6GEYbAH33ij27N/ADAI3MiasoFKqW0vpScIt4I3BJoOOZZwSqFGqtAcUQdh6j0UtfAAd0hFQmNBK2LmQgEakgLNh05C4p%2B79FxY2Sv2IBm18aLRlyEQ6YCy5rFzpYN0BqDsTLgZIF%2B4gP71g6pPLBoDPDX3ZBmaklpGSLg1p5NvStzyrT9ixbhADeHiAEaI9B21ZH4NM0QwNZx7LXH4xEXMa43jqPNPSbE7ZSJ7jowsFYWwpI9k61uBELu/qCXQsuQydYvKPkGBI0K%2BKtzRWDT4/GuE9R5V2EhuOglEBzMY0jDTcjnJbNin1RGa1gaEMrRLS0KAAa42CHHAW%2Bl/hBCCGSGqFIpifZz2MbadYGWy7tsyDGRJH6KV1XQP0oLMpkB5SMaJzIjriourdR6uaeAFo%2Bsquulw8Hg3/lDRsLibQvCoFsMkNoTQzAMpLDGwTrLsDXuQ5vT8t5B0BQYygVAS97ZwaC1FjOlokO10iNYlz6RJ2Qsy6AjDphF33BXe6NdPX1WbvLAe/CEaTC3J3s4LwTBsMtdxNSzAdKxu3zQQ4jBEXJVvzbfsO9yrH0zsiC%2B3DP0IOEag3%2B08AHyMgafe%2B/DkGJubYE5t4T7Ni2odonECYlOqeKCmJUbANUF6HY8BCgI%2BiDllBGNTrnExae1MwE0MWBgADKbJ8zlhEaMbnUvVC08MKSuW9hMB2AQKgArGEDAjPtseA64oVjgMyJzvFJz0gGAYKgVADUxR1Gw2%2BvInPpcO6ULzo4Uz2TYBFwYcX8JgQtDZO7uJIicUZAAEqjPtV2UPBBLSzcjxASP4krJVaiLH%2BP/mk%2BRFTwa7SrF0eOjj9DW8ieY/Qxptn0jeZ88ZDT7NgAfrH0TIDydB/ZI8kLPKLkayMyZvWg02RSuXPHsvX0LQQD75agLImBJQrcSIjNjz3vtaCxcTunIzdsE5Mgao6OLLWHoBSsHwRl/BHKKv8IwB6bmUNVwB%2B/r4MXCaGbywnJ0CiA1Benfsw2xPm9/MFoIvCIjrcz76uakqdirici74QHX6Gqf7FpHCYBFJFpoajoRBM5R6gF2jgGGp77WDQHWCwFQrwEVRbKhSqREFrLbKO5UFUGy7xCVrTw3BzwbSJKpS25sEc60FVAEAEA%2BCCAgCIgfqCHjhtA7CEDjjCwyDEAyDIC7TSGrYUjxoyAKg%2BCJBMC9iCAyDbAToDZmCxg5JIjlC0HUHGHc7O6TL86C5%2B4i7JAADyAACt5AjBMqWlYWyLYQ4fXN0L0OUEsnYT8OeEaPvnfhsJvpCHIJyNcO4MAPbH0KEcQHII8AatYPxG3j/qWv/l2OhnpukKqnpLOO%2BNmD7DwqZKJF4X0PEKWFDEAUUXzFgckXAbMAgeMspAdvijkexPkZDEUfxGZDvj0OUYFFUbJDUY2CpBAQ3uQSQWJvEsQesroFICzL0lIL2FIKQCwNINoKsagNIJlrgvYKIOIOcEcLQKsQQBsQsSzA1CAL2NoIwNIAACyrHrFSCbGkDbFSCrF8G3FnEvELGkBwCwBIDCw%2BA9JmDkCUDAmgnEAgDACCAWC8Eq4ECkAC4mBmB8EQBqjnGkB2yQiJDSAnGkDCwKE2EsAMB4m/GkBYCfZsD%2BBYn4BtCzy2B8EUm4iYDIBZiSBSAEnzpLGvEGJeDnGLGsDsAkwCB1Bqh8GQAsyHjabMlCTbB1icC4K0AKimQ2GzCfEHESB0CLHSArFrFYnvE4gAAcEYQkEY9xGu5W6YPw1wDU/EEAuAuqHmswe%2B6wq2IJ/gLpLCBguxfAvApxgplx1xtxSxjxBpFJ7xnxIA3xQZdxUgXATxhp0ggZvxzMpAE8N06x9xQAA%3D%3D%3D) In cases visitor could not be optimized gcc generates a sequence of compare and jump commands, not quite O(1). (see with #define TEST 1) In contrast clang can produce a jump table out of this, O(1). To make clang compile the &lt;variant&gt; from gcc header you have to quick fix the &lt;variant&gt; header and replace "private" to "public" at the corresponding location. /opt/compiler-explorer/gcc-7.1.0/lib/gcc/x86_64-linux-gnu/7.1.0/../../../../include/c++/7.1.0/variant:878:7: note: constrained by private inheritance here : private __detail::__variant::_Variant_base&lt;_Types...&gt;, ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ /opt/compiler-explorer/gcc-7.1.0/lib/gcc/x86_64-linux-gnu/7.1.0/../../../../include/c++/7.1.0/variant:235:74: error: '_M_u' is a private member of 'std::__detail::__variant::_Variant_storage&lt;true, int, long, char&gt;' return __get(std::in_place_index&lt;_Np&gt;, std::forward&lt;_Variant&gt;(__v)._M_u); 
I've got very minimal experience in all 3 of those languages and my resume is incredibly C++ heavy, whereas java and python aren't even on it. I've received interest and offers despite this from shops that use primarily C#, java, and python enough times that I am pretty confident I could land a job at a java/C#/python shop without brushing up on those languages.
Ah, a recursive implementation. That optimizes well but there is a disadvantage - it makes unoptimized debug builds slow and annoying to step through in a debugger. 
You don't have to enter the assembler instructions in hex, you can use assembler to build the code buffer: https://github.com/t0rakka/realtime 
It's trivial. pdqsort is written in the style of C++ std::sort, meaning it takes two iterators. As a raw pointer is a valid iterator in this case, you just do this: void sort_int_array(int* first, int size) { pdqsort(first, first + size); } Don't return anything, the array is sorted in place so you already know where it is. 
Also, in future it's better to use /r/cpp_questions for stuff like this. 
Pointers can be passed to standard algorithms as iterators (ie. there is a std::iterator_traits&lt;T*&gt; specialisation that defines the required typedefs) so you can just call std::sort/pdqsort like this: std::sort(array, array + numElements);
This one is better afaik, actively maintained and support for sind: https://github.com/herumi/xbyak
If you're calling C++ code from C, just be aware of things like whether the code you're calling could throw an exception. This feels like it would not, but I don't know pdqsort well enough to be certain. As only ints are involved, it's unlikely. You would have to catch the exception and turn it into an error code, if this is an issue. 
If @stvaccount want to use C++ library in C code that function should probably be compiled in separate compilation unit with `extern "C"`.
Not even probably - that's the only way to do it, otherwise the function name will be mangled. 
Garbage collectors never give back.... they allocate more efficiently within their memory space, but that's part of why it's harder for them to actually give it back to the system. If a java app uses 10 GB, and then doesn't need it... it will garbage collect it and java will be "using" much less but it still has the full 10 GB reserved from the operating system. 
This should get you 99% of the way: [std::array](http://en.cppreference.com/w/cpp/container/array) and [built-in array](http://en.cppreference.com/w/cpp/language/array).
C++ is really valuable for cross mobile platform apps. You write the business logic once and only wire the UI of android/iOS/windows phones to it. 
 template &lt;std::size_t... js&gt; T test_impl(std::size_t j, std::index_sequence&lt;js...&gt;) { using fptr = T(*)[]; fptr table[] = {f&lt;js&gt;...}; if(j &gt;= sizeof...(js)) throw_range_error&lt;T&gt;(); return table[j](); } 
So something like Maven dependency manager for C++ with a standard repo then pull in packages like SDL?
icit getters &lt;- the rest of the title
What benefit does this really provide? There's nothing wrong with not using explicit setters &amp; getters. How does this work for containers like std::vector, I don't think it works right now. If you make it work nicely with something like std::vector, I bet you can circumvent your setters. Also a tangent, but why do people like writing out the 'this' explicitly, is there any compelling reasons for me to not get annoyed by this?
I'm a self-taught man and I'm new to the computer languages, sorry if I have said something too strange for u but I srsly cant understand the differences. I've understood that array is a class but why should we use the class when we have built-in arrays? it looks like they do the same thing. I only want to learn more about c++ so if u could avoid answering "ok" that should be great!
to the `this` point, you could say that because sometimes you _need_ to use it(shadowed members) it is more consistent to always use it
Try out those links posted above, but the simplest explanation is that the built-in array is from C legacy, whereas std::array is a C++ addition. Unless you know exactly what you're doing, then use std::array.
Have you ever heard of const? It doesn't need useless getter setter, and prevents you to accidentally mutate members of your struct. I've seen so many classes that had useless setter and getter that actually did **nothing** but return and calling `operator =`. It get on my nerves how useless they are sometimes. Want something that cannot be mutate? Like the size of a vector? Make a getter. Fine. Have something that can also be mutated trivially? Expose it. Don't want to mutate accidentally a member? Make your instance const.
Good point. Yeah I see the use for it here. Most code bases I've worked with had a coding convention where members would have a prefix, so that's probably why I'm not used to 'this' being used for member access. I'll keep that in mind for the future.
Also https://github.com/asmjit/asmjit -- in addition also provides a compiler, which handles certain stuff while still giving you control you normally have when writing in assembler.
Problem with const members is that you often don't want to allow modification of an individual member, but you might want to be able to reassign the whole object which const members prevent you from doing.
That's not curated but seems like a laundry list. e.g. for GUI there is libRocket, which is basically abandonware.: https://github.com/libRocket/libRocket 
&gt; `assert(l != 0);` &gt; `for(; l != 0; l = l-&gt;next)` Please stop comparing pointers with `0` use `NULL` or even better `nullptr`. Or use "cast-to-bool" `assert(l);` or whatever is its name. I was confused for a while, I thought that the `l` variable was of type `int`.
He is talking about const instances, though, not const members. 
AsmJit is fantastic. This is the tool that RPCS3 uses FWIW.
What is the benefit other than being able to type "=" instead of the name of the getter (which doesn't even have to look like "get")? 
Yep, it's great. I cannot compare it to xbyak and other libraries as I haven't used them, but from what I've used AsmJit, it's been really awesome and have never felt the need to give another library a try.
In some cases, better to use an immediately evaluated function expression (IEFE) to avoid assigning a nonsense zero value you never plan to use: int f(MyEnum Val) { int x = 0; switch (Val) { case MyEnumA: x = 1; break; case MyEnumB: x = 5; break; default: assert(false); break; } return 5/x; // No warning. } vs int f(MyEnum Val) { const int x = [&amp;] { case MyEnumA: return 1; break; ... } } Also, the writing here implies that this is just handling false positives. Asserting your invarinants for functions with preconditions is something you should already be doing. If you work on a decent sized team I'd highly advise taking the time to replace `assert` with a decent set of defensive programming macros (Folly has a decent set IIRC). I wonder if there is a way to make such custom assert macros compatible with static analyzers? Other weird suggested solutions: if (a &gt; 1 &amp;&amp; b &gt; 1 &amp;&amp; c &gt; 1) { int ret; assert(a*b+c &gt; 0); while (a*b+c &gt; 0) { ret = 0; ... } return ret; // Warning, uninitialized value. } The normal way to show that a loop can run at least once, is to use a do while loop. It has identical behavior other than the condition not being checked the first time. However, writing the loop this way at all obscures what is actually going on. It's much better to write the return directly in the loop: if (a &gt; 1 &amp;&amp; b &gt; 1 &amp;&amp; c &gt; 1) { assert(a*b+c &gt; 0); while (true) { int ret = 0 ... if (a*b+c &lt;=0) return ret; } } It's weird to have a variable declared outside the loop, whose state is being reset in each iteration (and therefore is not being used to carry state across loop iterations). 
Or, with [p0707](https://wg21.link/p0707)-style reflection: template &lt;std::size_t n&gt; T test(std::size_t j) { switch (j) { constexpr { for (size_t i = 0; i &lt; n; ++i) { -&gt; { switch i: f&lt;i&gt;(); break; } } } default: throw_range_error&lt;T&gt;(); }
I think your supposed submit a pull request to add libraries 
Like what? 
If the extension affects overload resolution, like concepts do, all livraries have to enable the same extensions. Otherwise you could have ABI incompatibilities or subtle change runtime behaviour.
I wonder what does the lock icon mean on that page? That it can't be removed?
It means the link is `https` rather than `http`.
Like OpenImageIO, USD, OSL, embree etc...
&gt; `std::optional&lt;T&amp;&gt;` is an ergonomic disaster. There's just no good semantics for `operator=`. Why not? Rebinding the reference is the obvious behavior. 
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7qbhdi/how_to_write_c_wrapper_for_pdqsort_or_stdsort/dspce0k/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I hate to troll, but: &gt; I have performance critical code written in Haskell. I stopped reading after this :)
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7pnkum/how_long_does_it_take_to_sort_10_000_random_ints/dspcgie/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7pjl3u/data_structure_and_algorithms_problems_in_c/dspchrv/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
You have earned yourself a ban.
&gt; At the same time the salary for C++ developers is pretty low *checks bank account* lol
I'm pretty sure this has been posted here a few times before. Right?
I used to do this but was bitten more than once by "trivial" stuff that at one point started needing non-trivial stuff. Well, let me say just say that replacing every `x.foo = bar` by `x.set_foo(bar)` across a big codebase really removes the will of living.
Respectfully, perhaps a packaging system is best left out of a language standard? When a graphics library is pulled from that repo, it might also pull with it the next "left-pad" package. https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/
That's why I already write C++17 code. I recommend using the most recent C++ features (sometimes, getting people nerves because they can't compile these program on their preferred outdated Debian distros). But I can't recommend using something that is not defined in the C++ standard.
&gt; But I can't recommend using something that is not defined in the C++ standard. I was talking about this treatment of the standard as a god-holy document that should not be trespassed. Let me ask you this: how do you do when you have to program in a language without any official ISO standard ? (eg almost every language except C, C++, JavaScript, C#, ADA, COBOL and a few others). The problem with that reasoning is that it causes the standardisation process to drag on and drag on, because people limit themselves to "what's in the current standard" instead of looking beyond which then can serve to provide valuable insight to what's actually useful in the real world, instead of piling on fixes on later standard revisions. Eg look for instance at the amount of people who flat out refused to use `#include &lt;tr1/whatever&gt;` ten years ago, or `#include &lt;experimental/whatever&gt;` two years ago. Contrast this with the rust ecosystem where half the people run on nightly versions of the compiler. The standard should follow existing practice (that's what standardization means !), but currently it's the practice that follows what's in the standard, which is entirely wicked.
This list would be good if the PRs would be maintained indeed... There seems to be a lot missing and with so many PRs open and not even replied, it does not motivate one to do one more PR. 
While I'm not sure the language standard needs to define a package manager, having _any kind of standard_ defining one would be a Really Good Thing. We really need something that will let us do this: - Lets you download and prepare a library, starting with nothing but a URL and perhaps a version number: `pm get https://www.cairographics.org 1.15.2` -&gt; this should download the library, and its dependencies, and compile it for my system, using my compiler. - Lets you attach a library to a project: `pm attach cairo 1.15.2 c:\source\my_project` -&gt; this should set the project up so that you can #include that library, and link it. Together these two will take away 99% of the problems people currently have setting up C++ projects. It should also let you do some basic version management on libraries and projects: query which libraries you have, whether there are updates for any of them, install new updates as necessary, etc. There are some promising systems out there, but what is needed is for one of them to become a standard so library authors will start supporting it by default. Or perhaps it shouldn't even be a tool as such, perhaps it should be nothing more than a protocol or library that tools can use. We would also need to coordinate this with the C-world, since we share quite a few libraries with them. 
Haha thanks! Kind of embarrassing in hindsight. But I don't think this is too obvious... I don't see why it is important information there whether a link is https or not. I think it rather looks like it has something to do with the library (the actual information I'm looking for). If I want to know whether I'm clicking on a https link or not, I can just hover and check the link.
Thank you for the feedback, I will update the guide.
Thank you for the feedback, I will update the guide.
I guess I would not classify taking a C++ course as learning the language, that is something that would take much much longer. C++ (and C to a greater extent) expose the developer to concepts that other languages don't require any knowledge of at all,for example I'm sure there are python developers that don't know the difference between the stack and heap whereas you can't really get by without that in C++.
&gt; How well are PRs handled? It seems that not so good. For example, our PR is here since 2016 but it is not accepted, nor declined, nor replied... At the same time some PR are accepted. So it is hard to say what is going on.
Check the assembly output. If the __m128 is already in an xmm register, the union access operations could get converted to shuffles.
Try using option 2, but shifting your register to the right to get the specified channel. Such as by casting to a __m128i and using the _mm_srli_si128 instruction to shift right and get the element you want with _mm_cvtsi128_si32. Another option if SSE 4.1 is available is the _mm_extract_pd instruction. PS: there's a simd subreddit! /r/simd
Thanks, the first suggestion is a good idea, and it is likely to be faster than what I'm doing in 3. As for your second suggestion, isn't _mm_extract_ps giving back an integer? I guess that need a reinterpret cast to become a float again, I doubt it would be faster. Thanks, subscribed to the SIMD sub :)
It returns an integer since the instruction itself actually moves the value to a general-purpose register rather than another FPU register. You can safely hard-cast it to a float which will get you its proper value but yea it reeks of some nasty casting and useless register traffic. The only way to really keep it all in the simd registers entirely is to do the shuffling/shifting method which is probably the fastest method available given the usual context of extracting individual vector elements.
I think there are aliasing and undefined behavior issues with the union approach. I usually just use load and store intrinsics. 
Yes, I had the same concern about the cast, and I did some research online and it seems like shuffling is the fastest method. I still need to do some better profiling to see if the union access is faster than shuffling in case the vector is not in a register yet, or if the compiler automatically optimizes it.
Apparently not, it should work fine on both msdn and gnu, from what I could gather online. They actually both provide a union type themselves, for example in msdn you can access stuff with _m128_32f[0] or somethin like that. The union makes sure that the code is portable on both compilers. Anyway, I'm using intrinsics anyway, and removed the union, cause I want to use a consisten approach throughout the code.
Best book I would recommend, [C++ 14 Quick Syntax Reference: Second Edition](https://www.amazon.com/14-Quick-Syntax-Reference-Second/dp/1484217268). Very succinct and clear, it can help you learn most(all) the basics and nuances in a very short of time. 
&gt; What are your recommendations? `memcpy`. Feels less hackish than any of your solutions. Plus the compiler will optimize it to the optimal solution per platform.
SIMD registers don't have general purpose and FPU registers, all registers are equal. However, they may be handled by different execution ports. Depending on the microarchitecture, some ports will be allocated to only floating point instructions, some for integer and logical instructions, maybe some for both. Its very dependant on the microarch. There is usually a penalty for moving between ports (usually about 1 cycle). Agner Fog's (http://www.agner.org/optimize/)[optimisation manual 3] is a fantastic resource for the specifics.
I'd say the union - as long as disassembly shows the compiler supports it, it gives the compiler the freedom to read it from memory or shuffle for it if it's already in a register. The intrinsics would probably make it load the full _m128 even if it's currently in memory and it could have only loaded the single value.
If you don't mind and have some spare time at some point, could elaborate why the knowledge of stack and heap is so important for C++ programmers? How and when they are exposed to them? Asking because I might be one of those developers who've never really needed to think about it "almost" at all. Thank you. :)
That's exactly the point. This is not const, it's just not editable from the outside. A vector implementation for instance, should be able to change its inner size variable if the size of the vector changes. But a user of the class shouldn't be able to change the size variable just like that, because it would screw everything up (e.g. when the vector gets destroyed, it will destroy the new amount of members, even though that many weren't actually allocated). So changing the size should be done through an interface and all the stuff that goes with it should be withing the implementation of the class. However, just getting the value of size shouldn't necessarily be done through an interface and shouldn't look like a function call. If you wanted to use const to realize this, you'd need a private size variable with a different name, say _size and then a public const reference called size which gets initialized before the constructor is called via ": size(_size);". So now you have 2 (differently named) things representing one thing, are using extra memory and still need a setter. My code "solves" that. I'm not claiming there was actually a problem to solve, but like you I hate useless getters and setters and I spontaneously thought of a neat and fun way to get the best of both worlds that I wanted to share. I probably won't use it either in my code, but it's still cool imo.
There is an almost identical question on the front page of this subreddit right now. And it is asked regularly. I suggest using the search, and if you need to know anything more specific, ask on /r/cpp_questions
The benefits of the first one are just that. Not exactly the pinnacle of practicality, I agree, but neat nonetheless. The getter may not need to look like getX(), but it has to be named differently than the variable and has to have (), both of which annoy me. It's not really a function (in its purpose) and I don't like the fact that it has to be one. Of course, that changes if the getter actually needs to have some logic. The benefits of the second version, however are that you get a publicly accessible variable which is mutable only privately. You also don't have to use a getter like in the first version. And unless I'm mistaken, that's all without any overhead.
... and as everyday the „can you recommend books, resources about C++“ question ... 
Often, you have a variable which should be gettable from the outside, but not settable. That's why I used the vector example. This is of course not injectable into the std::vector template but if you make any new class with such a variable, you could use this. A vector's size is not constant but it should only be changed from the complex functions inside vector's implementation. A user doesn't do vector.size = 10, but calls push_back() or reserve() or resize() which then do a bunch of stuff and change the size along the way when they need to. However the size() function just gets the size by simply returning the variable. If you were to use a LockedProperty for the size variable, you would not be able to change it from anywhere outside the class, but writing "something = vector.size;" is completely legal and you don't have to use a getter function. Secondly, I think there's a benefit in using a setter function, because it prevents changing things by accident which could happen if you just make the variable public. E.g. making vector::size public is just a horrible, horrible idea. And a setter needs some logic far more often than a getter does, so just having one by default is future proof. As for this, it's mandatory everywhere in my code except with "this-&gt;lockedValue = new value". It used to be "this-&gt;lockedValue = lockedValue" but I changed it and didn't remove the explicit this. Generally, I always use it in constructors and setter for consistency and because it's too easy to write "a=a" and not get warned about it.
Yes, I spent hoalthoughurs of research on the exact same topic. 1) use Unions, UB and violation of strict-aliasing in C++, recommend by most online resources and even compilers. Works fine. 2) Write a small wrapper class about your scalar member (x,y,z) that refer to a reference of __mm128 and use the implicit cast operator and assignment operator to load/store. If everything is nicely inlined it shouldn’t hurt performance. You might want to overload the address-of operator as well. 3) use non-portable ways to access scalar values. For example on clang using operator[]. I personally used the union approach, although it’s technically UB. I am also very interested in the correct approach for this!
Or someone could update the sidebar with some of the better book suggestion threads.
Interesting. I deal with this kind of code a lot and I've never seen this approach. Would you mind expanding a bit more on this code? It's not clear to me how it would generate a warning or how it handles the default case. ```` int f(MyEnum Val) { const int x = [&amp;] { case MyEnumA: return 1; break; ... } (); return 5/x; } ````
Agree, the store instrinsics is usually optimized to do the same anyways. You can check the assembly gcc generates here: https://godbolt.org/g/j8MYWX
Everything you said is true, but a person's name or age is not necessarily a constant and you should be able to change it, so making a const instance doesn't always work. Of course, you could just make a new instance with the updated name in this simple example, but it's not something you'd want to do with a larger class or a vector. I wasn't talking about syntactic errors per se, but changing something (that should have the ability to change in general), but when you don't want to. The == versus = is just the simplest example I could think of. In my personal case, Resharper warns me about those and it's not something that affects me, but I couldn't think of another example off the top of my head (but I know I've had them in the past). It just seems to me, in some arbitrary personal programming philosophy, that changing something should be explicit while getting something should be as simple as possible and I tried to codify that.
I think the usual term is immediately **invoked** function expression?
Yes, I found that after you mentioned it and it had some good links, thanks. The getting started link on the sidebar gets me to Mr Stroustrup's "A Tour of C++" which looks ideal but I was also hoping to find a good introduction to the C++ ecosystem - such as it is. 
Thanks Bill, I'll give that a read.
I just implemented it, it does work, but it almost doubles the execution time. On the other hand it's really fast to read scalar from the union, which annoys me because I wanted an intrinsics-only solution, but hey, I'll live with it :)
Sometimes it's a good idea to look "what others did". CryEngine, for instance, uses the following to extract scalars. template&lt;int i = 0&gt; ILINE f32 get_element(f32v4 v) { if (i == 0) return _mm_cvtss_f32(v); else { #if CRY_PLATFORM_SSE4 f32 r; _MM_EXTRACT_FLOAT(r, v, i); return r; #else return _mm_cvtss_f32(shuffle&lt;i, i, i, i&gt;(v)); #endif } } https://github.com/CRYTEK/CRYENGINE/blob/release/Code/CryEngine/CryCommon/CryMath/Cry_Math_SSE.h 
That's why I included the second one: the standard (two iterator) use of sort is already a function with two arguments. That means we need two two argument overloads, where the overloading is on the concept. It could probably be done with SFINAE, but it won't be clean.
Getters and setters hardly ever actually lead to more maintainable code. In a code base of any size, it's pretty much impossible to narrow the contract on something. Even widening the contract can be tricky, if other components assumed the narrower contract. The one way I've seen getters/setters used well is in reflective code, where it's slightly easier to deal with uniformly with functions because some of the things do have tighter contracts that require a check, or there are variant/choice types in play. 
 void foo(std::string&amp; original) { std::optional&lt;std::string&amp;&gt; opt{ original }; if (original == "Hello") { opt = std::string(42, 'a'); } } Oops, should have used `*opt`; `opt` was accidentally bounded to a temporary (or a local). It's "reasonable" to use the semantics you describe, and I believe those are the semantics `boost::optional` implements, but it's an ergonomic disaster: forget the `*`, it crashes.
You're correct, my bad. I guess we should start to work towards making IIFE a standard term in C++.
i've read the paper on LTC area lights (sort of) recently and it honestly blew my mind, Awesome to see more and more projects implementing them.
/u/dodheim is right. There is a CSS rule on the site: `div#content a.external[href ^="https://"]` which adds the lock icon after links that point to https.
Yes, I think I found the same after a lot of profiling. In writing however the union approach is terribly inefficient. 
I tried to implement it now, and I'm not convinced. Sometimes it behaves the same way, sometimes it actually behaves worse. 
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7qk9ta/good_resources_for_people_moving_from_dynamic/dsq34y7/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
You are a gentleman and a scholar, sir.
I can update the sidebar. The stack overflow list is pretty good though. More importantly, updating the sidebar will do nothing to decrease the number of these threads. I'll just continue nuking them.
Try checking [Godbolt Compiler Explorer](https://godbolt.org/) to see what code was generated.
Yes, it can be done with sfinae and in fact there are already some other functions in the standard library (usually constructors) where the standard requires just that, so this wouldn't be an issue.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7q6h0b/best_resource_to_learn_c_with_managed_language/dsq3r74/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; First it prevents accidentally changing the variable with = when you don't want to. It makes the intent to change it explicit which is a plus. Using `=` _is_ a pretty damn explicit way of saying I want to mutate something... &gt;_&gt;
I'm partially responsible for this one. `yield` is a system call on many *nix platforms.
This looks cool. Send a paper to the next WG21 mailing
Ah, but what is returned in the default case? `assert(false)` won’t return anything in release build so what will happen?
Done, thanks!
Have you tried trying? 
Personally, I'm very much not in agreement that it would be a Really Good Thing, but instead of addressing whether a C++ Package manager is desirable, I'm going to address how a c++ centric package manager just isn't feasible. I have three main arguments here, which I'll try to address in order. * We already have pkg-config * There exists a package manager out there that has most of the features I would expect from a c++ pm. * Supporting all of the features that will be needed. Argument 1: pkg-config is already the "standard" linux way of describing how to take a library that's installed on a system, and link against it / include it's header files. It gets used by, what, 50% of libraries out there? Considering the complexity of pkg-config files is on the order of 10-20 lines on the high end, and so few projects have adopted it, the prospects don't look good for a c++ package manager. Argument 2: Gentoo's portage/emerge system is already the closest thing I know of to a standardized package management system for C++. Gentoo has a fairly strict standard definition for it's "ebuild" files called the PMS / Package Management Standard. There are multiple implementations of client software (emerge, pauldris, pkgcore, so on). The standard is fairly well defined, and evolves not too fast, but not too slow, and they even offer multiple years of backwards compatibility to ensure once a system is installed, it can be brought "up to date" for a very long time without needing a re-install. Portage accomplishes (effectively) everything you asked for and more. It already works on Linux / Windows / Mac / ***BSD. Support for Solaris, QNX, Android, and so on isn't available as far as I know, but I'm sure something could be done to get it there. Features include * "Ebuild" files can be as short as 5-10 lines of, not even code, just config like URLs and dependencies, for simple packages. * Supports any build system that can be run via bash. * Downloads the source code from the upstream release or from the local system. Wherever you tell it to. * Patches the code if needed/told to * Compiles it locally (so as to avoid binary compatibility issues with installed libraries) * Installs on the system with full capability to "cleanly" uninstall later. * Tracks when a version upgrade of any package breaks OTHER libraries and programs based on the dependency graph * Makes sure other packages can't overwrite a given packages files * Has support for various external tools, such as ABI compatibility/consistency checkers. * Compiler flags / Linker flags / Configuration script flags support on a per package / per package set / per system / global basis * Support for arbitrary source-code types. (E.g. python, ruby, rust, haskel, php, go, you name it) * Support for pre-compiled packages * Support for packages that can't be automatically downloaded, or must be installed from some non-internet source like CD Roms. * Support for complex dependency graphs that take package configuration into consideration, and not only version numbers. * Support for inline version upgrades with reverse-dependencies recompiled in case of ABI break. * Support for multiple versions of the same package being installed at the same time * Support for arbitrary combinations of version numbers across the entire system. E.g. Not every package needs to be the newest version. Sometimes you *need* a slightly out of date version for some reason. * Support for arbitrary numbers of custom repositories hosted locally / behind corporate firewall / anywhere * Support for "stable" / "unstable" / "experimental" versions of packages. Like, you can say "only install stable packages" if you want a system that sees less version churn and more testing by the community. * Support for packages that exist only to run a script, or to be placeholders in the dependency graph. * many more, I'm sure. If you've heard of Gentoo, unless you yourself are a Gentoo user, I think it's safe to assume you had some kind of negative reaction to my proposal to adopt portage/emerge. Gentoo has a reputation for being difficult to use, and for good reason. High customization capability comes with high cognitive load and high time cost. The reasons that make a very large number of people reject Gentoo as an operating system of choice is the same set of reasons people won't adopt a standardized package configuration system for c++. Unless you're proposing that the c++ package manager also be the operating systems package manager then in the generic abstract sense, how would the theoretical c++ pm inter-operate with: * Debian's dpkg/apt/apt-get/aptitude * RedHats rpm/yum/dnf * Arch's pacman * Gentoo's emerge * Mac's Dmg (is that what the format's called?)/Homebrew * Window's MSI/Chocolatey/NuGet * ***BSD's package manager, and their Ports collection * Solaris/OpenIndiana * QNX * Android * iPhone * Blackberry * WindowsPhone * Haiku * ReactOS * BeOS * AIX * HPUX * and so on and so on and so on? The list of existing package managers is very large: https://en.wikipedia.org/wiki/List_of_software_package_management_systems and reminds me of : https://xkcd.com/927/ I assume that, like all of the other language-centric package managers out there, it won't try to inter-operate with any existing package manager, and instead will attempt to FORCE OS level package managers to do things it's way. From what I can tell, this has been fairly soundly rejected by OS level package managers, who do things the way they've always done and bundle the source code with manual compilation and installation scripts, instead of calling to the language-pm. Argument 3: Commercial shops that currently use c++ will reject it. They need license compliance, version stability, the ability to patch and/or change the code of things they use, assurance that nothing can change out from under their feet, and above all else, the code actually does have to compile with all of the already in use stuff used by the shop -- that's a *really* tough thing to provide when each commercial shop out there has some zany way of doing things. I think a really key difference here between c++ and other languages like Java, NodeJS, or Python, and so on, is that c++ shops use c++ in large part because of the languages ability to provide zero cost abstractions. C++ can, when properly used, get as close to the metal as someone can get. Java, NodeJS, Python and so on simply *don't* provide anything like the customization capability that c++ provides. A package manager for those other languages simply *does not* provide anything resembling CXXFLAGS or linker flags. A few languages with built in package managers provide concepts like optional package features, but most don't as far as I know. With C++, you have to contend with * Optimizer settings * Compiler 1 for library A, compiler 2 for library B, compiler 3 for program X that links with library A and B. Don't forget using a different linker for each package (and not the ones the compilers shipped with, obviously!) * Compiler features (Potentially proprietary, or only available on some compilers) * Macros * Optional package components / features that involve compiling a different set of source files AND compiling them in a different way * dynamic / static linking * debug symbols, the level of debug symbols, the format of the debug symbols, compression vs no compression, in the .so/.dll or split into some kind of .debug/.pdb file. * A single shared library containing multiple versions of the same symbol. E.g. the BLAS (Basic Linear Algebra Subprograms), which load different functions depending on the specific model and family of processor you have. * Versioned symbols, like what glibc does to provide backwards compatibility And that list is *only* for how you can *compile* a give program. That's completely orthogonal to any of the following * License issues * ABI Stability * Library compatibility (linker problems, OR runtime problems) * Multiple versions of lib A, such as lib B wanting lib A-1.0.1, and lib C wanting lib A-1.0.2, and program X wanting lib B and lib C. How does the package manager account for this? I don't know if any other language-pm even tries? It's possible in C++, though not recommended obviously. * Distributed build systems * Patching the library prior to compiling -- sometimes it's a bug fix, sometimes it's a new feature. Companies do it all the time, Gentoo does it all the time. * Custom STL implementations * Target platforms. Java / Python / Ruby / NodeJS don't have to care about ARM vs. ARM64 vs. x86 vs. x86_64 * Target OS. Java / Python / Ruby don't have to care about Windows / Linux / BSD / others at compile time (they do, of course, at runtime). Heck, all this time I've been writing about a package manager that manages C++ packages on the source level. It didn't even occur to me to bring up issues with binary package distribution. That's it's own set of problems as well. If you distribute pre-compiled packages, you'll have a lot of compile targets to support, even if you're compiling them all the same way, just a different processor type. I agree that it's a nice pipe dream, but that's all it is. Any attempt to define some kind of standard format or protocol will be rejected by at least some non-trivial set of the overall c++ community because SOMETHING that they depend on won't be supported by the proposed package manager. I'm not saying don't try. If some PM comes along that somehow manages to handle all of the things that I personally care about, I'll adopt it in a heartbeat. What I am saying is that this problem is significantly more complicated than I've seen anyone talk about yet. And whether or not the problem is solvable to a level that I'm willing to adopt myself, I *do not* think that it should be a part of the language standard.
How can it enter default case if all enumerators are handled? 
&gt; It just seems to me, in some arbitrary personal programming philosophy, that changing something should be explicit while getting something should be as simple as possible and I tried to codify that. Well it certainly seems arbitrary that some member function with `set` in its name is somehow more explicit than the assignment operator. ;-]
Sure, so would the original though? It would just enter UB via divide by zero. In any case you are free to put whatever you want in the `default` case in the function to handle that case. I don't think my answer differs from the original on this point; the difference is in never having to assign zero, which is a meaningless value in this context.
The union approach is UB because you're accessing an inactive union member, not due to strict aliasing.
Effective Modern C++ from Scott Meyers. **The** single best resource for that. Otherwise, talks are the best resources, you can find it all on YouTube - CppCon, C++Now, MeetingC++.
Reading from a non-active member (i.e. not the last member written to) of union is UB in C++, not in C(11?) though.
This post from a recent thread was very illuminating to me regarding scalar access to simd. All of the talk about aliasing etc from other posts are explained here..... https://www.reddit.com/r/cpp/comments/7eq2tm/c_scalar_accessor_for_simd_vector_class/dq6v0n8
In C it is merely unspecified. See C11 6.2.6.1/7
:(
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/7qnlb6/recommended_books_for_learning_c98_embedded/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Yea, I think the people who do this would say, there are C libraries that also compile usefully as C++, and there are C libraries that do not. FWIW if its C, I'd rather just compile it as C. Just because it compiles as C++ doesnt mean it doesnt trigger undefined behavior in C++ but not C. How many authors really have a deep understanding of the differences of undefined behavior in both.
Don't you mean: std::string reverse(std::string input) { return std::reverse(input.begin(), input.end()), input; } 
Once the CPU cache has been loaded with rogue data, how does one go about accessing it without causing a cache miss? The article kinda glosses over that, but I'm curious. Edit: found it, it's a simple timing attack that retrieves data from the first of the two loads in the mispredicted branch.
Nonsense.
The standard sort functions are "optimized" to work well with any type that can be compared with &lt; or a function. If you can make assumptions about what you're sorting there can be a more special purpose algorithm that you can use, I suppose. Radix sort for integers is an example.
&gt; Today, I was told by an expert of C/C++ that the "std::sort" is not optimized for sorting arrays containing numbers such as an array of Int values. &gt; assumptions about what you're sorting there can be a more special purpose algorithm that you can use, I suppose. Radix sort for integers is an example.
As others have said, this is completely wrong. There might be an argument to be made that std::sort may not be optimal in some specific contexts (nearly-sorted arrays for example). However, his explanation is way off.
&gt; Today, I was told by an expert of C/C++ that the "std::sort" is not optimized for sorting arrays containing numbers such as an array of Int values. &gt; assumptions about what you're sorting there can be a more special purpose algorithm that you can use, I suppose. Radix sort for integers is an example.
That would depend on the actual algorithm used by a particular implementation of the standard library, what you're sorting, and how elements are being compared. It's not something you can make a blanket statement about. tl;dr: I don't think your "expert" is.
No, I did not know that.
Like most security exploits, the danger isn't from developers writing malicious code in their own apps. The danger exists in apps that accept untrusted input--such as apps that run plugins or take input from the user--and cross a trust boundary. Look at [buffer overflow attacks](https://en.wikipedia.org/wiki/Buffer_overflow) for an example of how this might be exploited. A user can input data into a program that completely overwrites a buffer's unchecked bounds. The data itself contains code that is later called (due to the original exploit or another used concurrently.) That code contains the actual exploit. The Wikipedia article linked has a good explanation of the end-to-end. This vulnerability is different, but the general idea of vulnerabilities is what we're getting at here. Whether or not you should use this switch completely depends upon the nature of your program. Some programs run at kernel privilege and accept untrusted input: USB device drivers are an example. Some programs have zero privilege and do nothing interesting: the built-in OS calculator is an example. You need to understand the full context of your program from a security point of view. `/Qspectre` is just one tool that provides assistance in mitigating one particular exploit or class of exploits.
Quoting your post again as if we can't read it is a shortcut to getting downvoted / ignored.
I'd say if you install an untrusted application on your system, no mitigation is going to save you.
"expert of C/C++"? What kind of expert would call themselves "expert of C/C++"? Have you verified this claim? At least measure the run-time?
Does anyone else get a sinking feeling when reading about spectre/meltdown? I mean really, what can be done? Is this just the start of an avalanche of new side channel vulnerabilities? these variants... they just seems so pervasive. So many apps deal with un trusted data. It used to be that they had actual bugs. UB or logic errors. Those are developer bugs. This is perfectly good code being let down by the CPU. I remember when timing attacks on password/checksum validation first came to light.. at first everyone was all “don’t worry, this is not viable in the real world”. Then it suddenly was, and it is just the new normal. Is spectre the new normal? Edit: to be clear, I don’t mean to completely blame the CPU here. It’s almost like this is a defect report against the c++ abstract machine.
A Spectre attack works by tricking some trusted code into revealing information about the data it can access. Compiler mitigations are used when compiling that trusted code, so that it won't expose as much about what it's doing when it transitions back to the untrusted, attacker code.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/7qq5qr/beginner_question_about_the_nature_of_programming/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Ah yes of course, thanks for the explanation. I was thinking only about people writing their own programs to exploit spectre/meltdown.
Lots of code could have been shaved off if it used Asio/libuv or similar framework. I often wonder why people keep reinventing these stuff for "not-that-small" projects. Also, it looks mostly C++ with no C, so why C/C++ ? For all the trouble of implementing networking layer, adding a `string_view` implementation would have been more beneficial :) Looks like something similar to `boost::intrusive_ptr` is implemented in `object.h`. Though I must say that I did not look into the details on how its used. URI parser looks incomplete, as in doest not seem to parse as per the RFC. 
Depends what you mean by being let down by the CPU. On one hand, the CPU was being aggressive about predictive execution in an effort to squeeze more performance out of the system. Much of the potential in CPUs is coming from out of order execution that attempts to keep the parallel execution pipelines busy, even when the code isn't naturally parallel. This class of attacks mimicks the class of attacks against crypto algorithms from the early 2000s. Basically, they take advantage of a pattern of "the only way that operation could be fast is if X is true". The only real way to mitigate that is to take a hit somewhere - either don't do speculative execution, or take a bigger hit on a branch miss (rewind all cache loads that were triggered in the speculative branch, some of which may also be used in the correct branch in many cases).
I still find it difficult to imagine scenarios where my application provides the necessary functionality so that an attacker can exploit this vulnerability but this patch would mitigate it. I can imagine e.g. JavaScript code in a browser exploiting it and reading memory outside of the sandbox, but in that case MSVC wouldn't know how the result of the array lookup is used and hence wouldn't apply the guard - right?
Thanks for your feedback. I will certainly start working on the URI standard. 
Because it is interesting? And also the half of MSVC team sit here :)
I wish C++ would implement the same union rules as Rust.
Yes, I have been thinking of `std::transform` when I wrote this example.
&gt; I always thought that ideally, a language should provide implicit getters and explicit setters for anything that's trivial in the sense that it doesn't actually need the getter function itself do anything other than return a value. No; A thousand times **NO**. Consider defining your API depending on operations performed on the class; That is, do not allow access to members implicitly, but depending on if/when you need them as part of the _public_ api. Otherwise, this just ends up exposing implementation details. When those are exposed, your client code will (probably) end up using them. Then, you end up with tight coupling and a maintenance mess. &gt; Someone's age, for instance, is not a function, but a variable and should look like a variable. Not to mention the problem of the getter name having to be different than the variable name in C++. Decide this depending on invariants of the members instead: - if you have no invariants on the data type, use a public member variable. - if you have restrictions on the value, use a method. Concretely, you could add an `public: int age;` to your class, but then an enterprising citizen might say their age is -250 years. You can address this with setting it to an unsigned type instead, but then you can also have persons with an age of 2200 years; Then , it turns out a person's age should (probably) be done through a setter, that checks the new value against some reasonable limits before modifying class data. &gt; And it's really tempting to make the variables public, but that means that you're opening yourself up to changing the name by accident. `const` is your friend. The reason you should not make members public is to respect class invariants, not to avoid accidentally modifying them. An example would be "avoid having a name in the system formed by 2000 `A` letters". Then can be solved as: - keep the name as a private string, and allow setting it through a validating setter function. - define a `person_name` class, and add the restrictions for a name in it's API; Then, expose it as a public member of your person (it's fine for it to be public, because all operations on the person's name will be validated by `person_name`'s public API. &gt; Often, the intent of data hiding isn't to actually hide the data, but to prevent it from changing accidentally from outside the class, because it's tied to the inner workings of the class. Then define a custom setter, or better yet, no setter at all. Getters and setters are many times a symptom of not enough API design. I think your solution is more suited to situations when you want to add metadata or a custom interface to your properties (such as register them by name to some control that interrogates them and shows the instance values). That is, if you needed `Property&lt;int&gt;` to be a named property, the `Property` class is where you should add this information. Defining a property for setter and getter sounds a bit like over-engineering to me.
&gt; [...] capable of solving a growing number of use cases. Our web spider can download and analyze information from thousands of different sources [...] Nice ad but can it keep what it promises? Can it crawl from Google Images and other sites that try their best to prohibit being crawled?
After all the enthousiasm about UB on the language level as a source of optimisation, I'm disappointed to see so many people complain about it on CPU level. Clearly it has brought us massive performance improvements, so it's good, right? 
This looks to be largely written in C++98. Can I ask why? Also, there's no such thing as C/C++. That might sound like a cheap snark but I think it's important to distinguish between the two in the case of stating the language a project is written in. 
I agree completely, it would be a defect against just about everything that is meant to run on hardware with prediction / prefetch / caches.
Yes, the main difference is that these types of attacks can gain information from completely unrelated modules as long as they share address space.
I know nothing of wxWidgets, but UI libraries tend to have thread affinity - "objects"[1] in these libraries are meant to be accessed from one (UI) thread only. I think, it's a question of performance and simplicity (both are easier/better when single-threaded). From that standpoint, nothing has changed and is unlikely to change, the advice still stands. There are ways to "transport" data from other threads to UI thread, use that. [1] can also be an XID or HWND, not an "object" in a C++/Java/... sense.
Spectre (branch prediction variant) can abuse caching of shared dlls and can be out of process.
So on GCC and Clang: int i = float_var; // warning, truncating float to int i += float_var; // no warning? And Visual Studio warns correctly?
No. No. And this is true of all UI libraries/frameworks out there. 
I've done the same thing. See my notes in the header here: https://gist.github.com/RaviGaddipati/d4e20c42d192a0196a9d5888408859a3 I ended up using reinterpret_cast
Got that on my Kindle... Started reading it again last night. Code formatting on the Kindle sucks though.
This is how I understood the blog post: With the new flag, the compiler adds a barrier, whenever it sees that the result of an array access is used as an index for another array, because the first operation might try to read memory from a location outside of the sandbox - so far so good. However, the compiler doesn't see the script code, so even if there is some vulnerable compile-time memory access function that the malicious script code can call, the compiler doesn't know, what the script code will do with the result. So imho this is something that needs to be implemented in the JIT or the interpreter - not in the compiler that creates the app/sandbox. Just to be clear: I don't doubt that those scenarios exist, I just couldn't come up with one and would have appreciated an example in the post.
The blog post doesn't go into a great amount of detail about possible exploits. It intentionally focuses on illustrating one very basic pattern: how it might look in code and an example of what the compiler might do. We (Microsoft and the MSVC team) are intentionally being a little quiet about Spectre. A lot of people and businesses depend upon our operating system and tools. While we like to be open and transparent about everything that we do, we're going to err on the side of silence to help protect our customers.
&gt; Like most security exploits, the danger isn't from developers writing malicious code in their own apps. The danger exists in apps that accept untrusted input--such as apps that run plugins or take input from the user--and cross a trust boundary. I don't understand this. No virtual machines, just a simple process loading in memory a secret file and then reading an untrusted file. Even if the untrusted file can create observable cache side-effects, without a malicious process how it is possible to access the memory of the secret file? 
Completely understandable. I was just curious, luckily I (currently) don't write software that executes untrusted code.
Think again about buffer overflow attacks. There's no malicious code in the vulnerable app. The malicious code comes from the overflowed buffer--the untrusted input being used as code. Buffer overflows are just an example. NOP sleds or heap spraying are other examples where you have to have untrusted code (or data treated as code) that the attack can execute. Spectre isn't an issue unless you can execute untrusted code. If you can execute untrusted code, then Spectre means you can snoop on processor cache data from trusted code. This is data that your untrusted code never should have had access to. The question you're stuck on is "how do I get untrusted code running"? I know that seems like a huge problem but we have decades of malware that illustrates it's possible. And again, sorry to be vague about Spectre in particular. Everyone from Microsoft is going to be kind of vague until the industry gets a handle on this thing. Security's sensistive like that. 
If you already share an address space, wouldn't it be much, much easier to just read the memory? 
Shouldn't that produce a warning? 
Using that snippet, on GCC 5.4.0 with `-Wall -Wextra` I get no warnings (after initializing `float_var` with a float), but on VS 15.5.1 with the default settings, I get: 1&gt;...main.cpp(4): warning C4244: 'initializing': conversion from 'float' to 'int', possible loss of data 1&gt;...main.cpp(5): warning C4244: '+=': conversion from 'float' to 'int', possible loss of data So both lines warn with VS, but neither with GCC with those options. 
VS literally pointed out this precision loss bug for me. I was doing Lloyd relaxation with Boost.Polygon's Voronoi diagram, and I believed my boundary edge-cutting was correct. For 200 points, it "converged" to a [stable version](https://i.imgur.com/DycCQh3.gifv), but for 1000 points, it produced a weird convergence towards [top left corner](https://i.imgur.com/9wvCrYM.gifv). It was definitely a precision loss bug somewhere, but I couldn't find it. Tried replacing `float` with `double`, nothing changed. I used -Wall -Wextra but no luck. Then I wasted hours to debug my edge-cutting implementation... Few weeks later, I compiled it with VS, using default compilation options, and VS printed out these warnings: 1&gt;H:\tools\vcpkg\installed\x64-windows\include\boost/polygon/voronoi.hpp(38): warning C4244: 'argument': conversion from 'double' to 'const int', possible loss of data 1&gt;H:\tools\vcpkg\installed\x64-windows\include\boost/polygon/voronoi.hpp(53): note: see reference to function template instantiation 'unsigned __int64 boost::polygon::insert&lt;VoronoiDualGraph::Coord,VB&gt;(const Point &amp;,VB *)' being compiled 1&gt; with 1&gt; [ 1&gt; VB=boost::polygon::default_voronoi_builder, 1&gt; Point=VoronoiDualGraph::Coord 1&gt; ] Turns out Boost.Polygon "only" accepts integer type for input points, and my Coord::x Coord::y are of double type. I have to scale and snap them to the integer grid, and the bug is gone. The requirements is right there in Boost.Polygon doc ["following set of limitations"](http://www.boost.org/doc/libs/1_66_0/libs/polygon/doc/voronoi_main.htm). Guess I should have read it more carefully.
How so? I understandthe shared dll part, but how can the data be read from another process? I thought meltdown is needed for that (same as it is getting kernel data out, really). No?
Only if you use `-Wconversion` (in GCC). We do not, because it causes a warning on `std::uint8_t b = 0; b += 1;` and all such operations on 8-bits and 16-bits values because the C standard specifies (and C++ inherits) that such operations are executed on `int` :(
That's really neat!
Can someone explain what this is for? I am unable to decipher the marketing speak on that site...
The issue here is that speculative execution also implies privileged access, when AFAIKT there's no reason why that need be the case. In other words, if speculative execution were bound by the same access restrictions as regular execution, there would be no problem, and no loss of performance.
This is not a reflection system for primitives, despite its name. The system violates DRY, in that each method has to be mentioned twice. There are ways to avoid this (have same set of macros define structure *and* reflection), but they also suck. offsetof only works on pod-ish types last I checked. You can improve `dump` in two ways. The first is to have a public `template&lt;class T&gt; dump(T*)` (with other args) that checks that the type matches before doing the `void*` version. The second is to define a bundle of type descriptor and `void*` that wraps the type-erasure up and ensures that the type descriptor and the `void*` are the same type. In effect, you get a "typed any" or "typed any ptr". Poping the stack even more, you can approach this kind of reflection by going all-out with type erasure. Imagine if instead of what you did, you relied on the existence of a free function `tie_data(T&amp;)` that returns a `tuple` of references to the contents of `T`, and `data_names(T const&amp;)` that returns an array of names. Then your macros can define those free functions. And your `TypeDescriptor` can consume them. Operations, like "foreach member" can now be written, where you are passed each type-erased element in turn. Augmentations, like `print` or whatever, get added as free functions and added to your type erasure system. But that is going a different way than yours, because it stores more of the layout of data in code flow instead of in data tables. 
I knew that there was a godbolt for rust, but I just thought it was just a fork and not officially supported. Heck, there is even Haskell and Swift, (though there is a lot of noise in Haskell output).
I made similar comments on the blog itself. I don't really agree that macros that define structure and reflection suck. It's possible to write macros that do the job in like 100 lines, using boost PP. They are not things of beauty by any means, but they work and they avoid repetition.
What is up with that code generated by Go? Is the language really *that* inefficient?
`int i{float_var};` warns as expected. To be honest I am more and more tempted to only use my own wrappers around the primitive types with proper namespace-based ADL, explicit constructors where appropriate etc. The mess inherited from C is getting…messy.
All valid points. I tried to limit the number of things I talked about in the post, since it's already very dense read... My real system has a `TypedPtr` as you describe, which is used heavily. I did consider renaming the post "A Simple Reflection System" for the reason you point out, but decided against it as things took shape :) ... "Rudimentary" maybe?
I prefer magic_get. It doesn’t clutter your class namespace with macros.
&gt;There is also a libraries section, that I've never noticed. That is simply amazing. It used to just be the icon so it could easily have been most
I read that page. Its definitely not an IDE, it plugs into VS or Eclipse. &gt; Intel® System Studio is an all-in-one, cross-platform tool suite, purpose-built to simplify system bring-up and improve system and IoT device application performance on Intel® platforms. That is exactly the marketing speak I couldn't decipher. What does that mean? What does the tool suite actually do? Is it a compiler? Assembler? Profiler? 
If you were using GCC `Wall` and `Wextra` don't set `Wconversion` for whatever reason.
GCC Wall and Wextra don't enable Wconversion for whatever reason, try adding that. 
What language would you rather be using?
Right?? 
Quick google got me this page: https://software.intel.com/en-us/system-studio If you scroll to the bottom it looks like it’s basically all their c++ tools. I’m going to sign up just for VTune. 
GCC, Clang, and ICC all generate slightly different code for `double` multiplication: https://godbolt.org/g/2oKbj7 - For `return x;` (no multiplies): Clang and ICC use `ret`; GCC uses `rep ret` (when there are multiplies, all 3 use `ret`) - For `return x * x;`: all 3 generate the same code - With 2 or more multiplies: GCC and Clang use `movapd`; ICC uses `movaps` - With 2 or more multiplies: GCC and ICC make the last multiply go into the return value register (`xmm0`); Clang does not (it uses `xmm1`), so it has to generate an extra `movapd` before the `ret`. rustc does, too, so I assume this is an LLVM thing.
Does anyone have a workflow that involves quickly looking at the generated assembly without using Compiler Explorer? What's your setup like?
On [Wandbox](https://wandbox.org/permlink/nvO3iLTtOX80xcR0) it does print out all float conversion warnings, but on [Coliru](http://coliru.stacked-crooked.com/a/4b7d3bc8ffc4995b) it doesn't for Boost.Polygon...
[Said monologue](https://www.reddit.com/r/programming/comments/7qsrxw/compiler_explorer_now_supports_sidebyside/dsrkypz/)
If you use CMake's Makefile generator, then it automatically generates targets for generating asm files for objects. Obviously non-portable to other configure systems of build-systems and it also doesn't have all the demangling/cleanup bells and whistles of Compiler Explorer, so I'm as interested as you what good alternative local workflows are out there.
Hi! This is something we are trying to get back, but unfortunately the editor we now use does lack some of the cool stuff from the old one, but we are on it! :)
A typed any is a *value* type. A typed any reference (typed or not) is a pointer (well, reference) type. One copies/moves/destroys. The other does not. Both are very useful. With care the typed any reference can be zero allocation, and the typed any value can use small buffer optimization to avoid allocation for small objects (or really, use std::any for storage). 
Note that this is mostly and example to showcase some of the languages. Also, you can always play with the UI, it's really flexible :) 
I think he means the same physical address space, not the same virtual address space.
Yes that I believe is where the trolly comes from. Beautliful image. But I took most of the details from cppcast's description. 
BeOS was basically on thread per window, right? So any given widget had a "main thread" that could touch it -- just not all widgets had the same main thread, IIRC. I never actually had to write anything for BeOS so my knowledge of the API's is pretty spotty, other than is_computer_on(void)
&gt; int i = float_var; // warning, truncating float to int &gt; i += float_var; // no warning? You may be using an old compiler. The following code: double float_var = 3.6; int i = float_var; i += float_var; Does produce warnings with clang 5.0.1 and gcc 7.2.1. 
MSVC emits some warnings from the FE and some warnings from the BE. The BE warnings are usually 4700-4900 series, but not always.
The trick here is that the page protection works. The problem is that OS level pages remain cached across process switches (i.e. os uses some mechanism to only flush userspace TLB). The mitigation was to flush the full tlb/cache on process switch (but not necessarily context switch). 
I'd probably go the Java route really.
Yes, I created this layout on a big tall monitor. As /u/Rrinconblanco says, the layout is configurable (but doesn't automatically re-layout to fit your current screen).
Julia request: https://github.com/mattgodbolt/compiler-explorer/issues/331 OCaml hasn't yet been asked for (other than here). Adding a new language is a little like adding a new compiler: https://github.com/mattgodbolt/compiler-explorer/blob/master/docs/AddingACompiler.md documents a lot of what would be needed. We're always looking for people to help!
BTW one minor nitpick: I think title of the video could have been phrased better. I do not consider this a "precision loss" although technically it is. I consider it just implicit conversion(or whatever is the proper way to call it?)/template argument deduction problem. Precision loss with Accumulate would be accumulating array with 10001 elements where 10000 elements is my net worth, and first element is Bill Gates net worth. :) 
So if they were designed with a clear interface and maybe an internal work queue, they were basically following the actor-model?
I try Jajauma's https://github.com/Jajauma/GlobalsDemo on ArchLinux: gcc is 7.2.1 while clang is 5.0.1. Both run OK for initial crash version: # ./Boom String too long for short string optimization String too long for short string optimization 
&gt; or you want to place a breakpoint trivially to see how the object is accessed and modified. This is the number one reason for me. 
If this is the new licensing model for the Intel C++ compiler mentioned by /u/erichkeane in [this thread](https://www.reddit.com/r/cpp/comments/7gjmgd/intel_offers_parallel_stl_implementation_to_gnu/dqjwyug/), then it is disappointing. Specifically, from the points I raised in that thread, these are still an issue: 1. License expires every 90 days and renewal is for the *latest* version only (a non-starter for supporting Intel C++ in a build system). 2. From skimming the FAQ, heinous flexlm is still used for license management (a serious hurdle for CI). Also, it seems the [Free Tools for Open Source Contributors](https://software.intel.com/en-us/qualify-for-free-software/opensourcecontributor) page hasn't been updated as it still talks about Parallel Studio XE.
Looks bit similar to how protobuf generates code out of its messages. Nice job!
Others have covered the direct answer, but I'd like to know - why do you ask? What problems are you hoping to solve with a threadsafe gui?
Check out the difference when non-strict floating point ordering is allowed: https://godbolt.org/g/3RjX2N gcc with -funsafe-math-optimizations gets x^6 down to 3 mults, whereas icc with -fp-model fast=2 still has 5!
Could you also bring back the old fonts/font rendering? It looks pretty horrible on every browser I tried.
Just VTune alone makes this awesome. Haven't found any other profiler that was as good for low-level code on Intel CPUs. AMD CodeXL is decent as a sampling profiler and is free, but can't do perf counters on Intel, and Visual Studio's built in profiler is... insufficient. 
You're not wrong, but at the same time, this is free and worth giving a shot for VTune alone. That all on its own is enough to pique my interest. 
Is there any advantage on storing the members offset instead of pointers to those members directly? iirc in the itanium ABI member pointers involve a trampoline, but there should be no memory overhead compared to storing a size_t. Maybe there's some interesting drawback or use case I'm not aware of. (I'm asking bc when writing reflection systems I usually store pointers in order to handle member functions and member variables in an homogeneous way with generic member readers/writers, where "reading" a member function is invoking it. See https://github.com/Manu343726/ctti/blob/master/tests/map.cpp, magic happens in the get/set_member_value() functions)
I, too, have [found](https://www.youtube.com/watch?v=w5Z4JlMJ1VQ) that gcc and clang can outdo icc when you throw lots of flags at them. :)
One more question (Sorry, I'm really obsessed with this topic). I see that dynamic reflection (metadata at runtime) is the most common in games for reasons such as simplicity of implementation (compared to template-magic-based static reflection) and integration with tooling (engine editors, asset pipeline, etc). Do you think game development would benefit directly from an static reflection API, or would be a way to "automagically" register types into their existing dynamic reflection systems? In other words, is there any use case static reflection offers, apart from type registration, that dynamic reflection does not currently handle? Thanks.
C++ should abandon the concept of "standard library" and should go with "standard repository". Software modules placed into the standard repository shall have to follow specific guidelines, be packaged in a specific way etc. 
Hi. What other subreddit directed you here?
Your generated RSS misses a pubDate field, for when an entry was published...
Can you send a signal from other thread to the GUI thread?
Ahh ok.
Finally, good choice
The proper place to take the hit is for hardware vendors to add an instruction to indicate to the hardware that a security boundary is being crossed, and thus cached data like this (not just dcache, but also branch predictor state, etc.) needs to be discarded. Alternately/in addition to, put that state into the context and save/restore it on process context switch instead of allowing it to cross boundaries like that.
Has magic_get been used at scale in production in any project?
`initReflection` has access to private member variables.
Interesting. So you mean instead of storing `TypeDescriptor_Struct::Member::offset` as `size_t` ([seen here](https://github.com/preshing/PrimitiveReflection/blob/429025b8384f704c06b19b26d73ba04ab515f622/Reflect.h#L65-L69)), store a pointer-to-member? Wouldn't it have to be wrapped in some kind of polymorphic wrapper, in that case? Every pointer-to-member has a different underlying type.
&gt; Every pointer-to-member has a different underlying type. sorry, I always talk with the bias of someone who writes static refl first then dynamic on top of it. That's true, you would need some kind of type erased member pointer. In my case https://manu343726.github.io/siplasplas/doc/doxygen/master/classcpp_1_1typeerasure_1_1_field.html (which is obviously bigger and slower [vtable-based plus type tag] than your simpler offsetof. It seems that I answered myself....)
A lambda expression that initializes a member variable of class A has access to private members of class A. See https://godbolt.org/g/nqktqG
MSVC is not too happy about it though :( https://godbolt.org/g/dSc8ie
I just noticed you've already implemented hashing on top of your own static reflection library. What other uses do *you* see for static reflection? You probably have a better idea than I do...
At work 80% of my time writing C++ involves the manipulation of serialization protocols, passing data from/to the business model. I see a lot of potential in the automatization of this kind of serialization in a type safe way. I did one example a year ago in a talk where I mapped at compile time an arbitrary C++ class to a google protobuf message, following some naming rules. While this same use case could be implemented using dynamic reflection, the type checks provided by static reflection help a lot both in efficiency (no type erasure involved in the wiring, direct 1 to 1 calls) and matching (not only match by name but also by getter/setter signature). In general, I don't know of any specific use case where dynamic reflection cannot do the job, I think is just a matter of requirements (overhead vs build times, compile time checking vs extensive runtime QA, etc). If we finally get metaclases into the lang, my answer would be completely different. A built-in codegen API at the language level that uses static introspection. Imagine a world with no custom code generators in your build pipelines, with the same flexibility codegen-based frameworks offer. That's, indirectly, the greatest contribution of static reflection to the lang imo.
Have you been following the proposals? I haven't really, but from what I can tell this seems to be the leading one: [P0194R4](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0194r4.html)
I also wrote [static reflection](https://github.com/maxis11/ideal-couscous) (mostly for myself). Instead of attributes, it uses generators(foreach in tuple + SFINAE) to provide custom [interaction scope](https://github.com/maxis11/ideal-couscous/blob/master/examples/tutorial/04_invokes/main.cpp) (for now it's plain/objects/static methods, plain/static vars) and [inheritance](https://github.com/maxis11/ideal-couscous/blob/master/examples/tutorial/05_inheritance/main.cpp). If you're interested, I can write how it works.
It's not part of boost, i think the author is only preparing to get it into boost
This is great! MIT completely removes the licensing barrier! I see it has a lot of supported platforms. Does anyone that has more experience with this framework know what the dependencies are? I imagine it uses boost, by i can’t find a comprehensive list of dependencies. I’d love to use this on embedded devices running an FreeRTOS and LWIP.
&gt; Does anyone have any idea what could be causing the slowdown here? Passing by value.
Look at HexRays Decompiler (Best available tool for reverse engineering) or if you do not have access to it you could try this project : https://retdec.com/decompilation/ 
Use const Strings &amp;... rest in arguments: [gist](https://gist.github.com/onto/387ba3f2a0a9205cd448339084799e87)
http://www.catb.org/esr/faqs/smart-questions.html
!removehelp
http://cppcms.com/wikipp/en/page/cppcms_1x_build#Requirements Boost isn't one of them
Might not change the assembly, but if using 17 then you could add: if constexpr(sizeof...(Strings) == 0)
Happy to see you back. You had a few years of hiatus, thought you completely abandoned it. 
Lots of stuff about disassemblers and decompilers in r/ReverseEngineering. Decompiling to "nice" C or C++ code is generally impractical but simple, minimally-optimized code can sometimes be decompiled meaningfully. Cracking a simple algorithm like you describe would typically be done directly from the machine code. I'd treat it as an exercise in keeping up with assembly. 
Static reflection would help, but only in certain cases. I'm mainly talking about serialization in this case. 1. The game state may need to be saved or loaded 2. Certain data need to be synchronized over the network 3. The game development process requires data editing and saving (e.g. editing a level) 4. Games are "data driven" Suppose we want to serialize data of this class: struct FVector { float x, y, z; }; and the result of serialization being the text representation of that value. The memory of FVector{30, 30, 0} would map to a string "FVector{30.0f, 30.0f, 0.0f}". In case 1, the game state cannot be known at compile time, therefore the serialization has to loop through all objects it cares about. Static reflection has the potential to generate more optimized serialization function for each type (no allocation, no lookup, inlining) but serialization itself is usually not the performance bottleneck. Case 2 is similar to 1, but much more sensitive to performance. Having reflection can potentially save us from using other out-of-box solutions such as protobuf. Case 3 and 4 are the most interesting ones, because those shouldn't require serialization at the language level, but serialization at compiler and IDE level. Technically, all games can be hardcoded with just text editor, in reality it wouldn't work because the text editor is not the right tool for editing visual data. It is already difficult to hardcode UI without previewing, and more so for 3D applications where it's impossible to imagine a shape from numeric data. So we created game engine which has an editing tool for the virtual world, serialize the data between the runtime world and the memory instance. Finally we serialize and save them to packages. But wait, why must we have the separation between code and data in the first place? If only the tools we have allow us to extract information from code (i.e. reflection!) and generate code from those information, we wouldn't need to have all these indirect and slow data systems at runtime. It's not compile-time either, in fact the reflection would happen at "editor time" or "intellisense time", and the program that receives reflected data does not have to be the same program that contains the structures. I would even go one step further to claim, reflection data is USUALLY used by another program rather than the program itself, and reflection does not have to be implemented at the language level but rather at tools / compiler level.
This completely clobbers all existing flags: set(CMAKE_C_FLAGS "-fsanitize=undefined,address -fno-omit-frame-pointer") Why not append: set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fsanitize=undefined,address -fno-omit-frame-pointer")
I did this in my implementation, but I forgot about it when I wrote the post. I'll update the post to include it, thanks.
I thought it was a 1 and OP was testing the fundamental axioms of mathematics.
Uhm this adds the flags globally, doesn't it? Aren't you supposed to use `target_compile_definitions` or something like that?
!remove
OP, A human moderator (u/blelbach) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7r2d9w/possibility_of_deciphering_a_small_portion_of/dstzt50/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
It is not simple at all, if the data is changing the attack doesn't work since it is necessary to do it multiple times to reduce the noise in your sampling, and the multiplication by 64 (one cache line size) helps a lot to know the state of the less significant bits. 
Okay, but is it still not better to use the target-based approach? Wasn't this one of the main reasons why that was introduced?
&gt;It includes a unified and easy to use IDE based on Eclipse* with Intel extensions to make your experience consistent across all phases of the development cycle. Dont know what to tell you. In addition to that it seems to have debugging and code analysis tools. The whole thing seems to be focused on IoT development. 
Also @OP change your MIT.txt file to a proper license.md file that GitHub will recognise.
Yeah, intel makes IoT devices. It's an intel product designed to interface with intel products. I don't understand what you're trying to get at?
&gt; Others I am doing state-of-the-art in GUI research. And our system works threadsafe, you can have 100s of threads updating the GUI. The problem I am solving is Marketing. I want to make certain that when I present my work and say "We can solve the problem of thread safe GUI updates; and others cannot (for example wxWidgets or GTK)" that it is really true. Basically this topic is too advanced for reddit (e.g., how this works). Most (99.9% or more) wouldn't understand and react with downvotes and criticism. 
Check my other recent commen.
Their architectures also account for a rather significant percentage of desktop and server devices. ;-] What about the product is advertised as better for one than the other?
&gt; I am doing state-of-the-art research in GUI research. And yet you asked a rather beginner question that belies a complete lack of understanding of the underlying issues. &gt; Basically this topic is too advanced for reddit (e.g., how this works). Most (99.9% or more) wouldn't understand and react with downvotes and criticism. The lack of self-awareness here is amazing.
Their words, not mine. For one, they have a tool for monitoring power consumption of Soc's. That's pretty specific. They've also mentioned atom processors with their "Intel® Integrated Performance Primitives", which is used in their single board computers I think. 
Unfortunately, Compiler Explorer is still using MSVC 19.10.25017, which is ancient by MSVC standards. That code compiles fine with compiler v19.13.26117.
The problem is that you wouldn't be able to use any native platforms, because none of those are thread-safe. That's going to be a big hurdle for getting others to use your platform. And it's not like you CAN'T call widget functions from other threads. It works fine in debug mode, and in release mode everything will pass testing. It might be hours or days later, but eventually it will throw an exception when you modify a pointer during the microsecond the widget is being painted.
I've modified the design a bit, but it offers flexibility and the opportunity to avoid using a global logger.
To me anyone using a GPL or even an LGPL is just tossing Richard Stalman's salad. Why would anyone help that self obsessed self promoting baby boomer? 
This pattern can exist in a lot of other places as well like filesystem paths, URI paths, and string formatting ops (which some software deals with in large quantities), where one would want to do something akin to Path.Combine("foo", "bar", "car", "blarg") or have the string formatter at least estimate the approx size of the resulting string _before_ a series of formats into it etc. Unfortunately the stl remains rather un-useful in practice. No URI class at all (and when it does come I expect the same mistakes), no meaningful string formatting, and filesystem's path hides it's implementation behind the very poor operator/ overload and doesn't provide a useful abstraction like Path.Combine in the first place. The fact that there was a bug in your implementation, and others like it, points even more towards the stl failing at its job; forcing users to implement over and over again very simple things. 
We have a core library that has our allocator classes, interfaces etc, and we use target_compile_definitions(CoreLib PUBLIC &lt;blah&gt;) and then anything that uses core (so everything) will get the flags. 
No need to create your own. If you are concatenating a lot reserve space beforehand. Estimate a value that can cover 99% of cases, and pass by reference. Even in olden times wasting up to 250 bytes wasn't that bad since most of the time those are short-lived strings. Anyway you can call shrink_to_fit() if you consider that saving memory is more important than avoiding the performance hit of reallocating memory. 
&gt; dynamic computations of function derivatives. Differentiation?
It's actually creating n! Universe. 
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7r7lvb/which_gui_library_is_easy_to_use/dsutv03/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Oh, that's a really great tip! I can definitely do something similar for our build.
Yep. I guess I just wanted to emphasize/use "computations"...
What's with these "license" hoops to jump though? Why would I ever use this compiler if I can get GCC or VC++ without any of that license nonsense?
Did you compare which steps your implementation did on these strings set and which steps trivial implementation did? At least, you're may be doing extra strlen() sorry each char*. BTW, why your variable args template implementation returns 0 if 1 element provided?
Great overview of the different reflection proposals. I really hope, that we will get reflection in some form before C++30!
So, raise hands everyone who would actually want to work at the "header file problem" people. Is there anyone here who uses a similar rule? (the rule, for those too lazy to click on the link, is "header files may not, themselves, include other header files"). I've seen some weird rules over the years, but this easily beats them all for braindead idiocy... 
He's trying to avoid collisions with other header guards, and really wants to support that single C++ compiler that doesn't support `#pragma once`. 
I just read their blog post on the subject and it is one of the worst-argued rationales I've ever come across. 
Trying to avoid collisions...
This looks more like symbolic differentiation rather than automatic differentiation.
do the terms denote two mutually exclusive features? (I thought symbolic differentiation was one way to do automatic differentiation)
I've seen at some big corporates a commit check which looks for any new `#include` in the master header files, and if so always rejects the commit. There are like two people in the company with the power to add an `#include` to the headers included into every compiland, and the reason starts to make sense when you think of a million compilands or so ... Problem is, I've also then seen junior engineers simply copy and paste the header they wanted into said master include files. But then there is usually a build time trend graph running, and if anyone is caught doing that they are given a massive bollocking. That then results in nobody ever touching the master headers at all ever, and causing all sorts of problems and tech debt by avoiding the correct engineering choice. Basically, you be dammed if you do, and dammed if you don't. Million file projects are uniquely a mature programming language problem. Rust, Go et al haven't really tackled that yet. I'd love to know actually if Swift has or not.
&gt; First, the templates are only used in the .cpp files. Thus, the .h files never need to include them. Second, the templates themselves are written in .inl files rather than .h files, and we don’t have any rule against .inl files including other .inl files. In other words, you can write a template that depends on another template. "so, we have this rule that headers can't include other headers, but since the language we use actually requires headers to include other headers we just say "let's call thes header files 'absolutely-not-header-files' so that we can bypass the rule we just imposed on ourselves" wtf guys
C++ builder ... If i recalling it corectly
Symbolic differentiation is your standard mathematical differentiation, e.g. calculating that d/dx ln(x) = 1/x. [Automatic differentiation](https://en.wikipedia.org/wiki/Automatic_differentiation) is an interesting and useful technique for calculating the derivative of a function as the function is evaluated, and is generally useful in computer applications (rather than pencil and paper). The name is very generic, but it refers to something quite specific.
It is, and in my opinion there is no reason not to use the `target_*` commands whenever possible, which is nearly always.
My answer also refers to that, so it's ok ;)
&gt; C++ builder From some googling: "Support for #pragma once was added in C++Builder 2010"
That's the "Portland Group C/C++" compiler, to be precise. https://en.wikipedia.org/wiki/Pragma_once#Portability 
Beep boop. I am a bot that sniffs out spammers, and this smells like spam. At least 65.79% out of the 38 submissions from /u/plakucisf appear to be for Udemy affiliate links. Aside from the general annoyance that is spam, many of the courses that get spammed are by brand new creators on Udemy, which are actually just selling pirated content that is free for now to get views/ratings, then gets pay-walled. Don't let spam take over Reddit! Throw it out! Bee bop.
&gt; Basically this topic is too advanced for reddit (e.g., how this works). Most (99.9% or more) wouldn't understand and react with downvotes and criticism. Yes, the level of reddit is extremely low, but there are some (few) knowledgeable people here. Anyway, if you can (at some point in the future) enlighten us how do you achieve thread-safe UI without some kind of locking mechanism (mutexes, or something else), I'd be all ears. There have been thousands of man-years of research poured into this since the '70s. Who knows, maybe someone would come up with a better approach, even if its different. But, until the day I see the technical and theoretical breakthrough that you made, I am sceptical and I say is all bullshit.
Fairly sure that only refers to the old PG compiler, since nVidia bought them I think it's based on GCC.
For this: #define FWD(...) std::forward&lt;decltype(__VA_ARGS__)&gt;(__VA_ARGS__) #define LIFT(X) [](auto &amp;&amp;... args) \ noexcept(noexcept(X(FWD(args)...))) \ -&gt; decltype(X(FWD(args)...)) \ { \ return X(FWD(args)...); \ } I prefer #define RETURNS(...) \ noexcept(noexcept(__VA_ARGS__)) \ -&gt; decltype(__VA_ARGS__) \ { return __VA_ARGS__; } #define LIFT(X) \ [](auto&amp;&amp;... args) \ RETURNS( X( decltype(args)(args)... ) ) which generates a useful `RETURNS` macro and is shorter and identical in result. 
Not at all, a good question. As was mentioned, I am avoiding name collisions. I use the guuid generator for that. I prefer not to use pragma once. Being "100%" standard-compliant gives a piece of mind ). I put together a helper shell script to generate the guards, https://github.com/egladysh/mkh. Take a look. Pragma once is compiler specific. For example, there are concerns with its consistency with sym links.
There is no release 1.0.0 yet and I am still hesitating about the syntax for defining (= specializing, or overriding) a method. Currently it looks like this: // open method with single virtual argument &lt;=&gt; virtual function "from outside" declare_method(std::string, kick, (virtual_&lt;Animal&amp;&gt;)); // implement 'kick' for dogs begin_method(std::string, kick, (Dog&amp; dog)) { return "bark"; } end_method; // implement 'kick' for bulldogs begin_method(std::string, kick, (Bulldog&amp; dog)) { return next(dog) + " and bite"; } end_method; It turns out that I can deduce the return type, so I can make this work as well: // no return type here // ----------V begin_method(kick, (Dog&amp; dog)) { return "bark"; } end_method; It breaks the symmetry with declare_method though. Anybody has an opinion on this?
It's an interesting tactic: instead of adding a full affiliate link, we have a twitter --&gt; link shortener --&gt; affiliate link. OTOH, the course matches the subreddit topic.
Yes, overall you should prefer to use target_compile_options and target_compile_definitions when developing your build infrastructure. This is an interesting use case though. First instead of keeping the logic for sanitize in a single toolchain it will be a part of your CMake core build, additionally since these compile options need to be on all targets that are built you will need to identify all roots of your project and add some conditional logic like: if(ENABLE_SANITIZE) target_compile_options(&lt;target&gt; PUBLIC $&lt;BUILD_INTERFACE:-fsanitize=undefined,address -fno-omit-frame-pointer&gt;) endif() 
&gt; header files may not, themselves, include other header files It is a good rule as an ideal, but as a reality, it is practically impossible to achieve, and even that page mentions some common exceptions. There has been times where I wished there were more standard forwarding headers. 
good bot. It looks like this one specializes in Udemy spam.
[removed]
I had a short look at this. I'm intrigued. I'm familiar with other implementations of symbolic differentiation using C++ expression templates. This one looks like it's off to a good start. I would encourage you to finish this. I am also a developer of two Boost Libraries. I would love to see something like this in Boost. It's a long way from being ready for that though. It lacks comprehensive tests and documentation. If you're interested in pursuing this, consider doing the following: a) sign up for the boost developer's mailing list. b) checkout the boost library incubator www.blincubator.com c) for my personal advice on getting your library into boost see https://www.youtube.com/watch?v=ACeNgqBKL7E Robert Ramey
EWG rejected P0573 because the SFINAE requirement interacts poorly with lambda captures, and it rejected P0644's unary `&gt;&gt;`in favor of a hypothetical keyword - except that it then rejected both candidate spellings of said hypothetical keyword. I wouldn't hold my breath for either.
You can do: namespace lift { inline auto&amp; detail_foo() { static auto x = LIFT(lib::foo); return x; } static const auto&amp; foo = detail_foo(); } This loses the constexpr, but in the vast majority of situations this will not matter since the lambda is stateless (you'll have problem in contexpr contexts, but in non constexpr contexts codegen will be unaffected). Here the initialization is dynamic, not static. In every translation unit, `foo` will be initialized by calling `detail_foo`. This is required to pass through the same definition of `detail_foo`, which means that every single `foo` will be pointing at the same object. AFAIK there aren't any ODR issues with this. I'm about 99% sure this will work perfectly with any of the linux linkers, for any combination of static and shared libraries, less sure about windows.
It won't help if the same header is included from different paths. At least it's not required to.
Though interesting is hard to know what you have here w/o sources and the thesis itself, the web is scanty. It's a pitty because your proposition in intriguing.
Sounds like a bug in the Clang MSVC driver. Report to Clang.
&gt; Why would I ever use this compiler Because you care about performance. You heavily use intrinsics. Your code is amenable to autovectorization.
Is LIFT macro in this just ripped from Boost ? BOOST_FIT_LIFT?
 I've evangelized it a few times before ([here](https://www.reddit.com/r/cpp/comments/6lu4vz/abbreviated_lambdas/djx94xj/) and[here](https://www.reddit.com/r/cpp/comments/708tpd/c_abbreviated_lambdas_for_fun_and_profit_gcc72/dn1v4pa/) and [here](https://www.reddit.com/r/cpp/comments/708tpd/c_abbreviated_lambdas_for_fun_and_profit_gcc72/dn1r3gg/)), but I'm going to do it again. If dreams really do come true, something akin to hyper-abreviated lambdas would be mine. A hyper-abreviated lambda would solve this, and add a lot of additional niceties. I use the prefix `@` because it's not a token in C++ at the moment. auto do_stuff(range r) { return std::reduce( r.begin(), r.end(), init(), @foo(@...) // &lt;-- The magic! ); } The `@` operator would expand to a lambda. The `reduce` call would become: std::reduce( r.begin(), r.end(), init() [=](auto&amp;&amp;... xs) noexcept(noexcept(foo(std::forward&lt;decltype(xs)&gt;(xs)...))) -&gt; decltype(foo(std::forward&lt;decltype(xs)&gt;(xs)...))) { return foo(std::forward&lt;decltype(xs)&gt;(xs)...)); } ) You could also do more than just forward exactly the arguments you'd been given: auto do_stuff(range r) { auto&amp;&amp; some_param = get_reduce_param(); return std::reduce( r.begin(), r.end(), init(), @foo(@..., some_param) ); } Now we pass `some_param` as the last argument to each call to `foo`. I've evangelized enough today, but it would be my dream-come-true.
Any more information on the P0573 rejection? I'd be curious to know.
I haven't read through this whole thing, but I did take a look at part 1. It pains me to see them creating C++ wrappers to call C# functions, that are essentially wrappers for C++ engine code. There's *probably* a way to get the native function pointer from disassembling the IL, though IIRC they sometimes do some massaging of the inputs in C# land before passing them on to native code, so that won't work 100% of the time.
Thanks for your encouragement! I just watched your talk and took a short look around www.blincubator.com. These are awesome resources that are useful for library developers in general not just boost ones. Nice talk! I'll look at the boost submission requirements in more details. If you know anyone willing to contribute to metamath, by all means let me know. You can send me a private message. I think metamath could be "easily" extended to many-variable functions, complex domain and even some elements of linear algebra... just have to know where to stop.) Eugene
Is the name a purposeful reference to the ymm registers in AVX? If not, why did you chose such a strange name?
Haha no. It stands for Yorel's Open Multi-Methods, and yorel is my surname, reversed. I picked a strange name because there is no standard for reserving namespaces like there is in Java, so I thought that yorel::yomm2 was unlikely to clash with anything. And "yomm" is pronounceable too.
https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/time-travel-debugging-overview For those interested
Is this like rr?
Similar, but better. It supports multiple threads, for example. There is a brief comparison with rr in the talk and at the link @adzm gave above (if I remember correctly). Of course it is Windows-only.
Instant mancrush! Don’t know how much Matt has thought out what and how he was going to explain things - without whiteboard - but it was so fluent and easy to listen. Next step: seek out all Matt’s public speeches. 
I think MSVC is wrong in not producing a diagnostic. Reduced: template&lt;class...Args&gt; struct tuple {}; template&lt;class Head, class... Tail&gt; struct tuple&lt;Head, Tail...&gt; : tuple&lt;Tail...&gt; {}; template&lt;int, class... Args&gt; char get(tuple&lt;Args...&gt;); struct Test : tuple&lt;int&gt; {}; char x = get&lt;0&gt;(Test{}); `Test` does not match the pattern `tuple&lt;Args...&gt;`, so per [\[temp.deduct.call\]/4](http://eel.is/c++draft/temp.deduct.call#4) (in particular, [\[temp.deduct.call\]/4.3](http://eel.is/c++draft/temp.deduct.call#4.3)) the base classes of `Test` will be taken into consideration. However, there are two bases of `Test` that match the pattern: the direct base `tuple&lt;int&gt;` and the indirect base `tuple&lt;&gt;` (because in MSVC STL, `std::tuple&lt;int&gt;` inherits from `std::tuple&lt;&gt;`). This should result in deduction failure, as pointed out by clang.
This is **far** more about the profilers and libraries than the compilers IMO.
Yeah, I guess it's for special cases. The vast majority of software ships with builds done on VC++ or GCC. There's also the worry that shipping ICC-built binaries might hurt perf for AMD users. Not sure if that's FUD or real though. From what I can see, not even video games (which are very perf sensitive) ship ICC-built binaries. So it looks like it's not the compiler that people want, it's the tools.
I've been using gdb-reverse everyday for work for years! What's bad about it. It fundamentally changed my debugging practices and increased productivity significantly.
As I said - I don't want to share it via Github before I finish my stuff with university. But, if you want, I've temporarily shared sources here: library: https://dinemic.io/libdinemic-0.1.6.tgz tests for it (and some examples of usage): https://dinemic.io/tests-0.1.6.tgz But, please don't redistribute it yet :)
this post from meetingcpp https://meetingcpp.com/blog/items/reflections-on-the-reflection-proposals.html is the last thing I have read on the topic iirc, I don't know what's the current state of the proposals. But I must say I'm 100% with value based reflection instead of template heavy traits just for nerds. Of course one could build a value based one on top of the classic tmp based (which makes sense if you're writing a codegen tool with current C++), but since we are talking about language support (i.e. we are fee to get compiler data and expose it as natural as possible) keeping with template heavy metadata representation will be a lost opportunity imo.
This is true. I first heard of it as an intern in the mid-2000s and first used it during development of Windows 7. When it could be used it was invaluable.
I might be wrong, but I think it's been lowkey included as a tool in Windows Debug Kit for years, the dump decorded is played back in WinDBG, the thing they added to release it is the query scripting on top as well as the new UI
It does the job, but relative to other solutions (TTD, undo...) it's worse in both space and speed
&gt; Its not a blockchain like others, with cryptocurrency and other stuff, but tool for synchronise databases across split-brained environments with ORM for C++ (only the "chain" remained from the "blockchain" :). This is mostly to cover environments where you can trust your own nodes and network sometimes fails and makes split brains of systems. So what is different about this one? Why should people take an interest in this instead of [Paxos](https://en.wikipedia.org/wiki/Paxos_\(computer_science\)) ([some implementations here](http://libpaxos.sourceforge.net/)) or [Raft](https://raft.github.io/)? 
This is the best time of the year! All /u/ned14 boost submissions start so many flamewars that the boost mailing list almost feels alive again. Yeahhhhhhh! Take them down Niall! Take. Them. Dooooown!
May I ask what do you mean by space? You mean architectures that are supported? Or threading or what?
async io with gui, this is good thing(although it is c#, VB): https://www.codeproject.com/Articles/1029693/Async-Await-Unblock-Gui-without-any-additional-Lin
If you have an expressive enough logic (say linear types and/or Martin Löf type theory) you can express properties of a thread-safe UI in the type system. This is the more general solution that is not ready yet. A part from that there a GUIs (say with functionally independent components) where the subparts never get into the way with each other. Maybe that is not a real world GUI example, but disallowing multi threading in those simple examples is conceptually not smart in my eyes. There is a lot of advanced state-of-the-art GUI toolkits research where the implements of Qt, wxWidgets, GTK, toolkit from LibeOffice are totally unaware of it.
**Company:** [BiblePay](http://biblepay.org/) **Type:** Full time, Part time, Startup **Description:** BiblePay is a new Christian Charity Cryptocurrency, 10% of mined coins go to Charity, the project is already sponsoring 180+ Orphans monthly! [View Job Description](https://www.reddit.com/r/BiblePay/comments/7ph4k8/hiring_c_developer/) **Location:** Remote **Remote:** Yes **Technologies:** C++, Blockchain, Cryptocurrency **Contact:** rob@biblepay.org
Well it is easier on the end user. This toolchain approach isn't discoverable by the end user and doesn't interact with ccmake or the cmake-gui. Consider something like this as an alternative. sanitizers.cmake ``` option(sanitizer.asan "Enable address sanitizer" OFF) option(sanitizer.ubsan "Enable undefined behavior sanitizer" OFF) option(sanitizer.tsan "Enable thread sanitizer" OFF) option(sanitizer.msan "Enable memory sanitizer" OFF) option(sanitizer.recovery "Continue on failure" OFF) if(sanitizer.asan OR sanitizer.ubsan OR sanitizer.tsan OR sanitizer.msan) set(sanitizer.frame_pointer ON CACHE INTERNAL "") endif() add_library(sanitizers INTERFACE) target_compile_option(sanitizers PUBLIC $&lt;$&lt;Bool:${sanitizer.asan}&gt;:fsanitize=address&gt; $&lt;$&lt;Bool:${sanitizer.ubsan}&gt;:fsanitize=undefined&gt; $&lt;$&lt;Bool:${sanitizer.tsan}&gt;:fsanitize=thread&gt; $&lt;$&lt;Bool:${sanitizer.msan}&gt;:fsanitize=memory&gt; $&lt;$&lt;Not:$&lt;Bool:${sanitizer.recovery}&gt;&gt;:fno-sanitize-recover=all&gt; ) ``` CMakeLists.txt ``` ... include(sanitizers) target_link_libraries(myTarget PRIVATE sanitizers) ... ```
It's fun and safe!
It feels like it doesn't it! No, just once before, last May. It's come up here and at conferences lots of times though, and at WG21.
This submission was a group effort, I led it out but there were significant contributions since the last review from other Boost members. In theory it thus should be uncontroversial, and should slide into Boost with barely a fuss!
The solution is to pack gui calls into events which are posted to the main thread's event queue. Gui event queues are thread safe. 
Just browsed through the documentation and I have to say that it's much improved on the previous, more conversational style. Contains a rationale, guidance over when to use it, example usages, and a reference. It's as if the library wants to be used. If other projects came with that kind of detail, I'd be more likely to use them. So kudos on that, Niall.
It's 100% Andrzej who achieved that. I'm lousy at documentation, as you probably noticed the last review. But I'm glad it's made a good first impression, the documentation uses very new tooling, and we are worried people won't like it because it's so different. BTW did you notice the search box searches semantically as well as by keyword? Some may still prefer a proper index, others may feel the lack of PDF docs to be deal breaker. We'll see how it goes.
I am wondering about the wisdom of designing such a macro-heavy library (besides looking really ugly, of course) when considering Modules TS. Is there something in the upcoming C++ standards (17, 20, etc) that will allow you to get rid of macros?
It's important to note that GCC optimizes it. Some embedded compiler for an obscure architecture might not be able to.
Outcome v2 is very, very definitely not macro heavy when compared to almost any other Boost library. v2 is also now free of the preprocessor metaprogramming which v1 was implemented with. v2 uses lots of template metaprogramming instead to achieve the exact same thing, which at the time of the last review I warned would be just as confusing to reviewers plus with a hefty additional impact on compile times, but there was a consensus against me. But to answer the question, the Modules TS doesn't help fundamental libraries like Outcome. It's much more useful for niche libraries like AFIO, and AFIO is Modules ready. The reason why is that the Modules TS only really shows any gain over precompiled headers for non-templated libraries like AFIO. The cause is template instantiation, all-template libraries like Outcome can't be accelerated any more than doing the parsing stage into a AST, something precompiled headers already does. Non-templated libraries, on the other hand, can reuse instanced code much later down the processing pipeline, thus avoiding redoing it. That said, I've yet personally to see any gain with Modules over a well designed non-LTO static library based build. I think Modules will improve over a LTO build though, so it'll land somewhere in between.
That looks fantastic! One might additionally constrain these so they only show on compilers/platforms that support them (I guess clang and gcc); On MSVC I guess these would be different or most of them might not exist (or in a completelydifferent form).
&gt; Outcome v2 is very, very definitely not macro heavy when compared to almost any other Boost library. Yeah, that's not a good reference point in my books ;-). &gt; But to answer the question, the Modules TS doesn't help fundamental libraries like Outcome. By "help" I assume (from the rest of your post) you mean speeding up compilation. Modules are as much (if not more) about code hygiene as about speed. Things like not leaking names (including macros) that I haven't asked for into my translation units. &gt; I've yet personally to see any gain with Modules over a well designed non-LTO static library based build. We've observed 3x speedup in pretty much this setup. See my CppCon video for details.
Yeah I know. But it contains the right information.
&gt; By "help" I assume (from the rest of your post) you mean speeding up compilation. Modules are as much (if not more) about code hygiene as about speed. Things like not leaking names (including macros) that I haven't asked for into my translation units. As a brand new library, Outcome of course is never anti-social :) But if you examine the source for the standalone edition, you'll notice Modules support is in there. It's just not used as I've not found any benefit from it (... yet, Modules implementations will surely improve) &gt; We've observed 3x speedup in pretty much this setup. See my CppCon video for details. If Outcome v2 is accepted, there will be a v3 which will be so lightweight to `#include` that any need for Modules will be obviated. But first I need to go get sign off from WG21 to replace `&lt;system_error&gt;` with something not so compile time heavy. Be aware v3 is at the very least 18 months out from now.
There are two minor comments about docs: - The "View this code on Github" links refer to file and line, but not specific revision. The links will become wrong after the code changes. (to get a link to specific revision, press 'y' while viewing the file on Github). - Underscores are not visible in code snippets, at least on my setup (Firefox 57 on Ubuntu 17.10).
Please change the "Type" line to read Volunteer/Internship, as this is not a paid internship according to the linked description. Also, please make sure to answer all of the questions on the form including visa sponsorship.
1. Good point, but I very much doubt that the tutorial code will change much once the library is accepted. 2. Firefox has caused by far the most problems for rendering. Eating underscores is actually one of the more benign issues. But after the review we'll be upgrading the tooling used to generate the site, and according to its changelog, many of these rendition issues have been fixed. But thanks for the report.
I'm just nitpicking here (and maybe I'm wrong), but this "Decision Matrix" here https://ned14.github.io/outcome/use-matrix/ isn't a decision matrix at all, it's a flow chart. A matrix would have column, rows, and entries. :-) PS: I don't want to start any flame-wars but I personally perceive the second sentence of below snippet a bit cocky. I also see no reason to mention it like that so why risk any offence. But maybe that's just me. &gt; This is the v2 Outcome designed in response to feedback from a Boost peer review held in May 2017. This library is expected to pass a second Boost peer review in January 2018. Good luck with the review, hope all goes well! :-)
Very cool, can it also find regular old-fashioned memory leaks?
Cool! Sounds great :-)
QT, wxWidgets or GTK are not implementing those "state of the art GUI toolkits" because they're just toy, research projects with no real-world applicability. As for the linear types or Martin Lof .... that sounds quite very much not applicable to UI systems, but hey, prove me wrong. Show me the code that does that and I'll believe you. Until then, is all in the realm of research that doesn't go anywhere more than just having a paper written.
[removed]
C++ is a programming language.
You need an IDE, I use microsoft visual studio. After that is downloaded, you need to open the installer choose modify and then select the c++ thing.
From v1 vs v2 &gt; Stuff removed: &gt; - Anything even faintly smelling of monads. From FAQ &gt; Outcome believes that the monadic use case isn’t as important as Expected does. Specifically, we think that 99% of use of Expected in the real world will be to return failure from functions, and not as some sort of enhanced or “rich” Optional. Outcome therefore models a subset of Variant, whereas Expected models an extended Optional. This rationale doesn't make sense to me. Any further background from the review? In gaining familiarity with these kind of concepts via Rust's `Result`, I consider the combinators an important part of the ergonomics of this. Judicious use of them can make the code cleaner by maintaining one coherent thought by having it be one expression rather than the thought being split across expressions, even if the end result is to return on error. I also find it weird that we need two types of `Result` to target different use cases. This seems like a fundamental vocabulary item for code and will make life annoying mixing code meant for one with the other.
&gt; This rationale doesn't make sense to me. Any further background from the review? So, the first review after we had battered the subject to death came to the conclusion that as a maximum, only one eighth or so of C++ programmers would care about monadic programming, but they would be extremely passionate about it, and thus seem more numerous than they are. I can't remember where that estimate came from, but after the discussion it seemed about right. Outcome v2 is very much a subset of v1 as per the previous review's recommendation. So Outcome v2 fits into the proposed generalised C++ monadic programming framework currently before WG21, and does not innovate on that like v1 did. WG21 has a majority opinion that Expected ought to be some sort of enhanced Optional with dual use as a function return object and a slot filling object. I think the first review kinda showed how the second use case is building something only a small minority actually needs into the standard to the detriment of the first use case, and I said so in a recent WG21 paper which was ignored. My hope would be that this Boost review will help convince WG21 to change direction. It's still possible, Expected is in the LWG, though I admit it's unlikely now. &gt; I also find it weird that we need two types of Result to target different use cases. This seems like a fundamental vocabulary item for code and will make life annoying mixing code meant for one with the other. WG21 are of one opinion, Boost of a different opinion. Historically WG21 would have deferred to Boost on matters of library design, but WG21 has taken a much more activist role on that in recent years. We'll have to see how the cards land - I deliberately have a single file include edition of Outcome so we can see how much code ends up choosing Expected over Outcome out there in the real world as the years go by. 
This isn't a bug. The problem is the `static_assert(false)` -- you need to use something that is dependent on the template parameter. Something like [this](https://godbolt.org/g/LCBfFi) would work. (This also comes up with `if constexpr`, where it's common to want to `static_assert` that a final `else` condition it never reached.) 
it makes sense, didn't knew that not having a dependency in the template parameter makes the compiler take the short path when evaluating the things haha thanks a lot, your solution works perfectly! 
Thanks for the explanation! And I know how bikeshedding like this can be frustrating, so thanks for working through this to bring it to C++! Sometimes in my C++, I'd like to reach for a `Expected` / `Outcome` / `Result` but without it being a common vocabulary term, I worry about creating an out of place niche in my overall code base. &gt; So, the first review after we had battered the subject to death came to the conclusion that as a maximum, only one eighth or so of C++ programmers would care about monadic programming, but they would be extremely passionate about it, and thus seem more numerous than they are. I can't remember where that estimate came from, but after the discussion it seemed about right. I worry the way the question was posed biased the answer. It seems reasonable that people who care about monads for monads sake (gross over simplification of FP crowd) are a minority, especially those who want to do "purely monadic" programming. I came to Rust from C++ (~20 years) and Python (~10 years). I was initially put off from Rust's `Result` combinators because of the foreign / FP term but I started adopting them because they were sometimes the most pragmatic way to keep the code clean. I don't use them everywhere. I still make heavy use of `?` (ie `TRY`) to return early. In fact, my use of combinators is usually immediately followed by a `?` / `TRY`.
Depends on your major. Computer engineering classes cover it. Computer Science not so much.
&gt; Sometimes in my C++, I'd like to reach for a Expected / Outcome / Result but without it being a common vocabulary term, I worry about creating an out of place niche in my overall code base All three meet the `ValueOrError` Concept, and thus interoperate seamlessly. In Outcome's case, all you need is to explicitly convert. I believe the current plan for Expected is also an explicit conversion. Obviously all the monadic operators work implicitly on anything meeting the Concept. &gt; I don't use them everywhere. I still make heavy use of ? (ie TRY) to return early. In fact, my use of combinators is usually immediately followed by a ? / TRY. There is a proposal before the committee for `?` to work on functions returning types matching the `ValueOrError` Concept. It'll be C++ 23 though, at least.
&gt; All three meet the ValueOrError Concept, and thus interoperate seamlessly. In Outcome's case, all you need is to explicitly convert. I believe the current plan for Expected is also an explicit conversion. Obviously all the monadic operators work implicitly on anything meeting the Concept. Ah, wasn't familiar with `ValueOrError` and knowing its there, had to dig pretty deep in `Outcome`s documentation to find a reference to it. Am I reading the proposal correctly, that all of `ValueOrError`s helpers are done as free functions? Unless this is being design with the intent of some form of UFC syntax being accepted, this seems burdensome to use. Unless I'm in some concept-centric templated code, I'd probably just write the logic myself.
&gt; Am I reading the proposal correctly, that all of ValueOrErrors helpers are done as free functions? I believe that is the current proposal before WG21. You're right that we could do with some language support on this, but that's definitely a post-2025 possibility. Even extending operator `?` in time for C++ 23 will be a big ask.
You should start with binary. Very simple. All you need to know is 0 and 1.
Btw.: Even if you don't use an IDE, it's not like you have to look for compiler, linker and library individually.
&gt; slot filling object can you explain by example what is this? Sorry if it is a dumb question...
good, std::forward is abomination that should be killed off... Language should support a way for types to say that it is ok to treat template&lt;typename T&gt; f(T&amp;&amp; t){g(t);} as function body contained std::forward: {g(std::forward&lt;T&gt;(t))}; Unfortunately I predict that this will never be added to the standard. 
&gt; Code seems to require from programmer to know that some EC can be translated to std::exception and what EC need to be thrown as filesystem_error. In other words this is like std::visit on exception type but you do not get the compile time error if you forget one exception type. But as we know C++ gives you no way to statically check you are handling all the exception types :/. Outcome only throws exceptions if you tell it to do so. The default behaviour is actually hard UB. See https://ned14.github.io/outcome/tutorial/default-actions/happens1/ &gt; Also the code comments could be better: "If we would like Outcome to do something other than the default action" When? Aka what scenarios we are customizing here? https://ned14.github.io/outcome/tutorial/default-actions/ &gt; nitpick: your code example for convert of string to int is wrong( &gt; I know you just want to show simple usage of error codes, but I think it is good practice to make sure code works correctly). Can you explain? All the tutorial code is compiled to make sure it works. Is there something wrong with the logic? 
WTF, Python? Do you hate that kid or something? 
&gt; Can you explain? All the tutorial code is compiled to make sure it works. Is there something wrong with the logic? Try this code with "-1" and std::to_string(int64_t(INT_MAX)+1); outcome::result&lt;int&gt; convert(const std::string&amp; str) noexcept { if (str.empty()) return ConversionErrc::EmptyString; if (!std::all_of(str.begin(), str.end(), ::isdigit)) return ConversionErrc::IllegalChar; if (str.length() &gt; 9) return ConversionErrc::TooLong; return atoi(str.c_str()); } 
So, most of my usage of `std::optional&lt;T&gt;` tends to be of the slot filling design pattern. Imagine you have a set of optionals in your class, or on the stack. You then call a series of "transformations" on your class or on the stack via reference capturing lambda. These transformations examine the current configuration of the optionals, and based on logic will modify those optionals to some new state. Multiple transformations are usually applied to arrive at some configuration of slots either filled, or unfilled. Bear in mind that these transformations may in fact be the program executing over time. That's my lion's share use of optional personally, and I find it very handy for that. Some leading members of WG21 think that instead of empty, some reason why it's empty would be useful. Hence the push for the proposed design for Expected. My personal belief - and I think that of Boost after the first review - is that slot filling will not be a common use case for Expected in practice. The reason why is simple: C++ is generally success-orientated, and failure is almost always either handled immediately, or stack unwound. Usefully storing failure into slots is not how much C++ is written, nor do I - we - think it ever will be. Outcome's `outcome` is actually mostly used by me personally for slot filling in my own code, lots of people wonder why it's in there, for me I find it very useful for accumulating heterogeneous `result` and/or C++ exception throws into. But Expected would not substitute easily for `outcome` because really you'd prefer a `variant` for slot filling over Expected for that use case. I appreciate "slot filling design pattern" is hardly well understood. Does the above make sense? Be aware I'm shortly about to get off a train and into my car for a multi-hour long drive home (I work far away from home during the weekdays currently). So replies after this won't be till late tonight.
From my point of view you are the troll. 
I'm reading about both now - I didn't had opportunity to get familiar with it. But as far as I can understand, both have some algorithms to take decisions in behalf of whole cluster. In my version each node gets only information about changes done in database - signed, unsigned, forged and other. Here, an application by applying various filters on database models will define what shape will have its local database - thus, there won't be the one, universal and consistent state of database. In each case it depends on application logics and the way how it handles various updates received by node. I know, that first impression might be like "what a mess" :) But that is my idea, to define how such system works, how to design some critical functionalities, to test it and to show that it not exaclty makes a mess. At this time I'm trying to implement the cloud in such approach. In a nutshell - each application in cluster is a single point of failure, but by thinking different, it could be simply replicated. For example storage for images/objects in cloud. Once we have one storage, it is single point of failure. Usually by uploading image to cloud, the backend makes it replicated. But here I'd like to uploading application find more than one storage and assign one image to both of them. So instead making redundant storages, you create redundant image duplicated on various, independent storages, chosen by application. Additionally framework now allows to encrypt image with your credentials or the storage's credentials. In such approach you can for exampe force the storage to reencrypt image for compute node, where it will be used. It should make it safe to transfer over public, untrusted networks or store data in various public storages. Of course it is very simple example and even in this case, there is much more to be done (how to share images, networking, handling transfers, virtual machines, migrations etc.). You can find simple example here: https://dinemic.io/documentation/first-application-chat/ and its code here: https://github.com/cloudOver/libdinemic/tree/master/chat Maybe it will explain more about API of framework.
Heh, you're right. Logged to https://github.com/ned14/outcome/issues/105. Thanks for the bug report!
Heh, you're right. Logged to https://github.com/ned14/outcome/issues/105. Thanks for the bug report!
If you are talking about something like this then I understand: struct ParsingFailedTag {}; struct ParsingNotAttemptedTag {}; // We either successfuly get both metadata or not. struct OffsetsCache { ArchiveOffsets control; ArchiveOffsets data; }; // Tries to get control.tar and data.tar metadata. std::variant&lt;ParsingFailedTag, OffsetsCache&gt; GetAllMetadata(); std::variant&lt;ParsingNotAttemptedTag, ParsingFailedTag, OffsetsCache&gt; offsets_; Note that I liked this usage of variant, but this was the first time I used variant in a real toy project so it could be I was just amazed by some new feature... and that I would hate it in the long run...
Ever since I have been into Haskell, the quality of the C++ code I write at work has significantly improved. Not quite sure what exactly is the cause of it, maybe because Haskell makes you think more about what you are going to write down.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
This is part of the "two-phase name lookup" behavior that MSVC does not yet (fully) support, and didn't _at all_ support until very recently. It obviously impacts more than _just_ name lookup so the nomenclature is a little off. :) Basically, MSVC would completely ignore the contents of templates until instantiation, while conforming compilers will semantically evaluate template contents as early as possible. Non-dependent names and other compile-time elements like `static_assert` will thus be evaluated at the definition, and dependents will be evaluated at the point of specialization. This is probably the single biggest source of inter-compiler portability problems I've encountered or heard of other people encountering. The name resolution part in particular can drastically alter the meaning of code between MSVC and other compilers in non-trivial ways; I've seen code in the past that would take many man-months to get working on conforming compilers because the developers intentionally and extensively relied upon MSVC's non-conforming behavior. MSVC is now implementing the two-phase lookup behavior and has it partially done as of 15.5 iirc (the most recent MSVC 2017 update) and I believe expects to have it fully done in a future 15.x MSVC 2017 update.
As far as I am concerned, there is much more to gain from having multiple compilers than the trusting trust attacks. However, the first thing when talking about compilers is to distinguish between front-ends and back-ends, even though the main C++ compilers tend to bundle them together. For example, the issue of implementing C++ features is mostly a front-end issue. The new C++ features are mostly transparent to back-ends. And on the pros of having multiple front-ends, the improvements in diagnostic clarity seen in recent years in GCC and Clang as they play catch-up with each others is pretty nice :)
&gt; I'm reading about both now - I didn't had opportunity to get familiar with it. But as far as I can understand, both have some algorithms to take decisions in behalf of whole cluster. In my version each node gets only information about changes done in database - signed, unsigned, forged and other. Here, an application by applying various filters on database models will define what shape will have its local database - thus, there won't be the one, universal and consistent state of database. So, since you don't require global consistency (or, I assume, [linearizability](https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html)), you can have both availability and partition-tolerance. &gt; In each case it depends on application logics and the way how it handles various updates received by node. &gt; &gt; I know, that first impression might be like "what a mess" :) But that is my idea, to define how such system works, how to design some critical functionalities, to test it and to show that it not exaclty makes a mess. At this time I'm trying to implement the cloud in such approach. In a nutshell - each application in cluster is a single point of failure, but by thinking different, it could be simply replicated. As far as I can tell, this is quite similar to the idea underlying resolution of in-doubt transactions in the [X/Open Distributed Transaction Model](http://pubs.opengroup.org/onlinepubs/009680699/toc.pdf). In our case here though the application is expected to resolve [in-doubt transactions](http://documentation.microfocus.com/help/index.jsp?topic=%2Fcom.microfocus.eclipse.infocenter.edtest%2FGUID-8CD21B4B-D51C-483F-9191-1861BC0A8263.html) ([also here](http://www.oracle.com/technetwork/products/clustering/overview/distributed-transactions-and-xa-163941.pdf) and other places). The problem is that automated resolution of conflicting or in-doubt transactions is difficult because it requires some understanding of the semantics of the data (and the changes) and may require understanding of the end-user's actual intent. See for example [a description of conflict resolution in git](https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/). That has now been slightly automated with [`git rerere`](https://git-scm.com/docs/git-rerere) but only for cases where the user manually resolved the conflict already once (see also [this description of rerere](https://hackernoon.com/fix-conflicts-only-once-with-git-rerere-7d116b2cec67)). &gt; For example storage for images/objects in cloud. Once we have one storage, it is single point of failure. Usually by uploading image to cloud, the backend makes it replicated. But here I'd like to uploading application find more than one storage and assign one image to both of them. So instead making redundant storages, you create redundant image duplicated on various, independent storages, chosen by application. Well, the distinction being made here is whose responsibility it is to manage redundancy and resolve conflicts: the storage layer, or its client? A well known example of having the storage layer do this is [GFS](https://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf). &gt; Additionally framework now allows to encrypt image with your credentials or the storage's credentials. In such approach you can for exampe force the storage to reencrypt image for compute node, where it will be used. It should make it safe to transfer over public, untrusted networks or store data in various public storages. I'm not sure what this really means. Key management is almost always the hardest part of this kind of system. &gt; Of course it is very simple example and even in this case, there is much more to be done (how to share images, networking, handling transfers, virtual machines, migrations etc.). &gt; &gt; You can find simple example here: https://dinemic.io/documentation/first-application-chat/ and its code here: https://github.com/cloudOver/libdinemic/tree/master/chat Maybe it will explain more about API of framework. I didn't find that very illuminating - because it's a framework, I didn't get an idea of how the framework works by reading a simple client. I think I wanted more to read the [architecture overview](https://dinemic.io/documentation/architecture-overview/). &gt; &gt; ps. I'm working on documentation, so soon it should be better explained at website. ps2. in consensus algorithms known from other systems, usually changes made by detached nodes or part of cluster are discarded, if conflicting. The one of points was to handle it better - to leave decision how to handle such conflict to your local application and object, which is the most interested. As I mentioned, this sounds a little bit like XA with application-level resolution of in-doubt transactions. 
&gt; But as far as I can understand, both have some algorithms to take decisions in behalf of whole cluster. Both are normally used for systems in which there are many facts about which consensus is to be maintained. For example, a separate quota value for each of N users. 
/r/ProgrammingBuddies 
OP, A human moderator (u/blelbach) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7rl6uh/finding_c_devs_for_a_project_best_place_to_look/dsxqu3w/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
See the pinned thread in this subreddit.
&gt; catastrophic effect on performance Easy to avoid with code like this before accessing memory: index = index &lt; limit ? index : 0; That a decent compiler will turn into branchless code equivalent to: index &amp;= -(index &lt; limit); BTW, fuck ones' complement. 
It's important to stoke the fires in the winter.
Partly to blame is the long term service releases of some OSes, which may be running GCC 4 or 5, and still in widespread use. 
You can activate only the partial implementation of two phase name lookup in your project by passing /Zc:twoPhase since Visual Studio 2017 15.3 : https://blogs.msdn.microsoft.com/vcblog/2017/09/11/two-phase-name-lookup-support-comes-to-msvc/ . It can be useful because /permissive- does a lot more than activating twoPhase ;) .
This reddit is about C++. You need r/unrealengine/
Yes, in unreal engine you program c++
Not sure if that's really a problem. e.g. [python implementations](https://wiki.python.org/moin/PythonImplementations) I guess the difference here is that C++ multiple compilers with reach in the same order of magnitude, there's not one that "basically everyone uses".
Talk about Ubuntu... 14.04 has what, cmake 2.8... 16.04 is not much better I think. So many people held back by that...
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7rmclw/what_courses_to_study_to_be_able_to_make_video/dsy0v6r/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Yep, pretty much the design pattern I mean. Optional is great for that. I'm far less convinced that Expected will be.
Also the GameDev Forums Ben has set up with the course is a great place for Programmers to share information and help each other out along the way.
Acknowledging an improvement in the quality of compiler warnings due to competition implies nothing about the absolute quality compared to anything else, nor does it imply that the competition is the only driver of quality. 
I've been through the course and it's very valuable for learning unreal engine, but for learning C++ it can be kind of suspect after the first section since you have to do everything the Unreal way.
It’s a nice library :)
You achieved a3x speed up with modules of template only header only library like code? Link to the video? STL implementations and range-v3 achieve only 20%-30% compile time reduction, so I am a bit suspicious.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/7rpbil/guys_i_need_in_help_doing_this_assignment/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
No, the problem is tying the compiler toolchain with the OS (and more generally, the linux school of thought that one distro means one fixed version of every package and you have to upgrade the whole OS if you want the next gcc / firefox / libreoffice / krita). This makes sense for base utilities and libraries but absolutely nothing more.
Looks like most employers have a different mindset in this regard. Unfortunate.
Any constructive feedback is appreciated! Thanks!!
Thanks!
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/7rpiwn/how_are_goalkickercom_books/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Yep that's exactly what I'm doing, but I wanted to keep the example simple
&gt; Numerical Differentiation That implies a discrete approximation like a finite difference. It's much more manual in that you have to explicitly code it, and it has a lot more complexity in the infinite number of ways you can come up with approximations and how that affects accuracy and stability. "Automatic differentiation" refers to a program that directly manipulates source code operation by operation to produce new source that computes a derivative, hopefully somewhat "exact."
Encouraged by your comment I started the proposal on the c++ std-proposals forum: [Proposal Ternary Right Fold Expression](https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/MhP3pHEBIkc) The full proposal text can be found on GitHub [Proposal Ternary Right Fold Expression](https://github.com/zingsheim/ProposalTernaryFold/blob/master/ProposalTernaryFold.md) Note: In contrast to the idea presented here I added the right fold without initial value to the proposal. 
**Competition of course!** C++ has an installed user-base, it will carry on for years by sheer momentum even if all development on its compilers ceased today. Rust, on the other hand, is the new kid on the block. It has to prove itself. Nice diagnostics is one way to lure out developers freaked out by the walls of text that GCC and Clang can spew. On top of that, rustc is relatively attractive to newcomers: it's on github, which people are used to, and its developers are nice to newcomers. It has made it very easy for someone to come in and contribute nothing more than a little tweak of wording here and there. The same applies to documentation. I think that the willingness to make it easy for one-time contributors has paid off in terms of diagnostic and documentation quality. By comparison, contributing to GCC is full of hurdles. Just registering on the gcc-specific bug-tracker tool is already annoying: registration is blocked and one first need to contact an administrator by e-mail. By *text* e-mail, which meant I had to dig into Outlook's documentation to configure my work-account. And then wait for approval. Losing momentum.
What are you using to generate that beautiful documentation :O
Personally it was Rust which helped a lot. When you see: std::vector&lt;int&gt; v = {1, 2, 3}; auto&amp; e = v[0]; v.push_back(4); You know there's an issue, and can explain it, but in more complex cases staring at the code just leaves you with an intuition, a gut feeling, that there's something funky going on. So you try to imagine different execution paths, and see what could go wrong, but even if you *don't* you can't shake off this feeling that this look quite right. I had dabbled in Rust for a while when I finally saw a talk by one of the core team members where they explained that all the Rust ownership+borrowing boiled down to a simple rule: **Aliasing XOR Mutability**^1 And suddenly, all these experiences crystallized in my mind! *Finally*! So now, when I get this gut feeling, I apply the Aliasing XOR Mutability rule to my C++ code to quickly narrow down the cause of the funkiness. And then I either leave a comment explaining why it's safe, or I've found a bug :) ^1 *It's been noted that XOR is not quite the right operator, NAND would be, whatever...*
Hugo + Standardese. Bleeding edge tooling, literally trunk. Have you had a try of the semantic search yet?
I agree. I am really of mind that the world needs *two kinds* of package managers: - a user's package manager, such as Ubuntu's, Fedora's, CentOS', ... is about providing compatible, vetted, libraries to a user, no matter which language they are written in. - a developer's package manager, such as conan.io in C++, npm in JS or cargo in Rust, is about providing a developer compatible libraries, no matter which which platform they target. And even then, the user's package manager seems harder and harder to maintain in a world where people expect instant access to new applications, and applications are to be updated frequently. I am really not sure that a distribution's package management team can really keep up with the onslaught of updates, and deliver a consistent environment when different applications shift technology at different paces. I wonder if it would not be easier to simply package applications as self-contained entities (static binaries?) and let each of them pick its own version for each of its dependencies rather than try to figure out the common version of a DLL which will satisfy all of them :x
&gt; &gt; &gt; I wonder if it would not be easier to simply package applications as self-contained entities (static binaries?) and let each of them pick its own version for each of its dependencies rather than try to figure out the common version of a DLL which will satisfy all of them :x well that's in my experience the only sane thing to do: let the developer ship with the exact libs the software was QA'ed with. In my experience on linux, even just a minor patch release in a system library can break stuff or change them in subtle ways - for instance an updated freetype might have improved kerning, which will mean that a glyph will be out-of-place by one pixel which may need a pixmap to change, or stuff like this. Likewise, even core stuff like glibc sometimes mistakenly break ABI in subtle ways that are noticed only many months later but happens to break your software hard when it runs on an older machine so even this you have to ship.
My experience with glibc has been rather bad in this context :x Just accidentally building on a newer kernel will mean your software now depends on a new version of glibc even if you do not use any new feature, and suddenly the loader barfs when you attempt to run the program on an older kernel :x In both companies I've been in, the work-around has been the same, setup the compilation environment such that a specific version of glibc is linked against, no matter which kernel you compile on. And of course select said version so as to be compatible for all kernel versions on which the program will run.
Most of the Conan quality packages are in Bincrafters repository now. I wish they advertised it better on the official site. 
I see you have some comparisons against other libraries, but I don't see a clear selling point. What's great about your library that would make someone prefer it?
That is an ill formed program no diagnostic required. 
Ill formed no dignostic required "solution".
A generic lambda has a template call operator. All templates must have a valid instantiation. Any template that has no valid instantiation means your program is ill formed, no diagnostic required. "Solutions" that fool a compiler so it does not detect the ill formedness of your lambda are hacks. You just have an ill formed program that the compiler didn't detect, yet. The program resulting could be broken in arbitrary ways, as the result of the compile is no longer described by the C++ standard. And even if it *works*, the next compiler upgrade or patch, or a change elsewhere in your program, could cause your program to fail to compile (if you are lucky) or behave in arbitrary ways (if you are not). Any way to hack around this *must leave open the possibility that the function is well formed*. One approach is: template&lt;class...&gt;struct always_false:std::false_type{}; struct never_use_this{}; template&lt;&gt;struct always_false&lt;never_use_this&amp;&amp;...&gt;:std::true_type{}; auto do_not_call=[](auto&amp;&amp;...args){static_assert(always_false&lt;decltype(args)...&gt;{});}; now the only way to make a valid call is to pass an rvalue `never_use_this`. This matches both the letter and spirit of the standard. (The theoretical reason why that rule exists is that it leaves compilers and future standards wide latitude to detect bad code in a template beyond what the current standard requires; as worded, it is much stronger permission.) 
wow, this makes a lot of sense. Thanks for writing a complete explanation + valid example, really
I'm thinking, doesn't this rule invalidate the usability of void_t? It's implemented this way: template&lt;class... _Types&gt; using void_t = void; there is NO possible way that it becames a different type than void, so the compiler can omit the template and destroy the utility of it
[CWG 1558](http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1558) ensures that SFINAE applies to alias templates regardless of whether the template parameters are used.
Today I was browsing the Microchip website, their commercial compilers apparently are stuck in C90 and C++98.
with alias you mean usings, right?
I apologize if this comes across as overly negative, and I really do mean this in a constructive manner since the last thing I want to do is discourage you from sharing your code on the web. But I also feel that this is something you need pointed out: The general code quality of your example is very low, and teaches bad practices to people who are in the process of learning C++, or to code in general. Your function names are misleading, you pass strings by value when you are not taking ownership of them, `using namespace` (though some people find that one a bit contentious). Also, having functions that can only be validly called at specific points in the program without any error checking. 
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/7rschh/need_help_with_c_tutorial_error_ltexture_does_not/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Who's a troll? 
 Can you gave us an example how it should have been done?
Report it!
This is an interesting paper and presentation but I'm a bit sceptical about the precision of Mathematica. It probably OK, but this is just an assumption.
Ah yes with non-template Heavy code that speed up sounds more or less what we get as well (2x-5x) but the moment we use range-v3 or boost compile times are back to non-modules-like code.
`using`s that are templates as opposed to `using`s that are just prettier `typedef`s, yes.
Assuming you are referencing my comment, here's a better version of the same code. I would personally have had the utility functions return strings (or better yet, lazy-evaluated ranges), but I made an effort to maintain OP's approach of not generating any intermediate strings: #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;stdlib.h&gt; // pick and choose names added to current namespace using std::cout; using std::string; using std::ostream; // escape user data void output_escaped(ostream &amp; stream, const string&amp; data) { for(auto c: data) { switch(data[pos]) { case '&amp;': stream &lt;&lt; "&amp;amp;"; break; case '\"': stream &lt;&lt; "&amp;quot;"; break; case '\': stream &lt;&lt; "&amp;apos;"; break; case '&lt;': stream &lt;&lt; "&amp;lt;"; break; case '&gt;': stream &lt;&lt; "&amp;gt;"; break; default: stream &lt;&lt; c; break; } } } // function name says what it does, // take string by const reference. void output_content_type(const string&amp; content_type) {, stream &lt;&lt; “Content-type: “ &lt;&lt; content_type &lt;&lt; “\r\n\r\n”; } void output_title(ostream &amp; stream, const string&amp; title) { stream &lt;&lt; “&lt;title&gt;” &lt;&lt; title &lt;&lt; “&lt;/title&gt;\n”; } void output_h1_text(ostream &amp; stream, const string&amp; text) { stream &lt;&lt; "&lt;h1&gt;"" &lt;&lt; text &lt;&lt; “&lt;/h1&gt;\n”; } int main() { // disable output buffering cout.setf(std::ios::unitbuf); output_content_type(cout, “text/html”); // Output HTML boilerplate cout &lt;&lt; “&lt;!doctype html&gt;\n” &lt;&lt; “&lt;html lang=\”en\”&gt;\n” &lt;&lt; “&lt;head&gt;\n”; output_page_title(cout, “Hello, World!”); cout &lt;&lt; “&lt;/head&gt;\n” &lt;&lt; “&lt;body&gt;\n”; output_h1_text(cout, “Hello, World!”); output_escaped(cout, getenv(“QUERY_STRING”)); cout &lt;&lt; “&lt;/body&gt;\n” &lt;&lt; “&lt;/html&gt;”; return 0; }
I think that adding some comparison to other libraries will be good if you want to attract users. Take a look at seastar (https://github.com/scylladb/seastar) as an example. Their main selling point is improved performance with a relatively simple model (after you get familiar with the library). The benchmark that they show you in the example projects creates all the required buzz for people to be interested in the library. Another thing that I was wondering about is why you focus the README around the fact that you are using a graph. Why isn't that considered as an implementation detail, i.e why users of the library should care that you used a graph and not a different data structure?
Cool project! Wouldn't it be simpler to just use docker images for the distros you want to support? You just grab a list of distros from docker hub and run your build in the relevant image.
Sure, but the whole point is to avoid using an entire os install just to build a program. The ideal would be if you could specify a glibc version at build / link time. Also, that would be a build per distro which is a massive pain to maintain.
Upvoted, that's a reasonable improvement. For the sake of brevity, I would prefer something like this for `output_escaped`: void output_escaped(ostream &amp; stream, const string&amp; data) { auto constexpr escape = [](char const&amp; c) -&gt; std::string_view { using namespace std::string_view_literals; switch (c) { case '&amp;': return "&amp;amp;"sv; case '\"': return "&amp;quot;"sv; case '\'': return "&amp;apos;"sv; case '&lt;': return "&amp;lt;"sv; case '&gt;': return "&amp;gt;"sv; default: return {&amp;c, 1}; } }; for(auto c: data) { stream &lt;&lt; escape(c); } } Also, n.b. writing explicit `\r`s to a text-mode stream is wrong 99% of the time.
Assuming that your end goal is that users will be able to download a binary and just use it on their distro wouldn't you need to maintain such a list anyway? I.e Ubuntu 16 users download X and fedora users download Y?
Sweet!
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7rpmv7/msvc_decltype_template_variable_bug/dszc5or/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7rscqh/msvc_bug_variadic_type_expansion_inside_using/dszc6ki/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Read up on [`std::invoke_result_t`](http://en.cppreference.com/w/cpp/types/result_of).
Hi, I already know how to do that, im not asking for help. The problem is MSVC that isn't compiling properly on certain cases like expanding variadic types. A nice example can be found in the link. I just want to confirm that this is a bug in vc++
!removehelp
For actual production code I'd use https://www.webtoolkit.eu/wt .
No, the whole point is one binary for all linux installs
It's probable that MSVC 2017 RTM had bugs here, yes, but it seems a little academic to me since this works and is more sensible anyway: https://godbolt.org/g/V4aks9 I don't have a link to your original code to test it with the current release so I'll leave it to you to bisect the two to find out where the error begins to manifest. ;-]
Yes, you are right. But the dot "operator" can also be used to access static variables and functions. :P
Up until last year I worked for a game company. I needed that, It's amazing !
Best answer. Explained so clearly. Really appreciate the examples. 
Cool! I'll take a look, thanks!
Hi, thanks for the response. Maybe I was simplifying my example too much, do you know how to make it work without touching the enable_if_returns but only modifying enable_if_all_returns?
Please don’t use URL shorteners - Reddit’s spam filter hates them, and I had to manually rescue your comment.
Like I said, I don't have a link to your original code — you'll need to repost it. :-] (Your post text is gone now, though it may still appear to be there for you.)
&gt; https://godbolt.org/g/d839wp oh sorry
We did that 25 years ago. What's new? Nowadays we can even use FCGI and we can even have long-lived programs. And now we even have C++ frameworks that don't even need a web server at all, they just embed it inside (quite performant too, although obviously not at nginx level). So, yet another article about how water is wet and fire burns?
Yeah, that's pretty much why I made this. It's super annoying to see Linux as a platform fail because of basic usability issues
This seems like a good idea, but I'm worried about bigger projects when using this, especially with dependencies. Right now, we use steam-runtime + SDL2 for our game engine (we compile SDL2 in manually, so we can control compile flags), but if this gets battletested a bit more, it may be worth trying out :)
Would love to see a libstdc++ version of this header
Neat. We use crosstool-ng to create a static toolchain using an old glibc (also 2.13). We can then use this toolchain on any distro and the resulting binaries will run everywhere where glibc &gt;= 2.13. If we want to make truly static binaries that will run no matter how old the system glibc we use the musl c library which is designed with static linking in mind. 
No, I can't find a workaround that doesn't involve changing `enable_if_returns`. It still repros with compiler v19.13.26119 so I would definitely file a bug report!
No, I can't find a workaround that doesn't involve changing (or altogether avoiding) `enable_if_returns`. It still repros with compiler v19.13.26119 so I would definitely file a bug report! (Or maybe /u/STL or /u/AndrewPardoe will do it for you despite this thread being deleted... ;-])
Works with my project using SDL2 (https://github.com/wheybags/freeablo). I use https://GitHub.com/ruslo/hunter as a package manager which packages SDL2 so I can compile it with the same flag, it still depends on some system audio thing Hough so it doesn't quite work but that's an SDL cmake issue not an issue with this project
Why not just use -static-libstdc++ ?
[`imgui`](https://github.com/ocornut/imgui) is great for adding debug consoles and widgets to your game. It's easy to integrate into any engine. Preprocessor directives cannot be modified at runtime. The preprocessor is the first step of compilation. You can define "DEBUG_MODE" at compile-time, either in a header `#define DEBUG_MODE 1`, or by passing a flag in your build system (`-DDEBUG_MODE=1` for gcc).
Python is a completely different language with completely different rules. Python doesn't require immediate name resolution, Python doesn't have ADL, and Python doesn't even _have_ different entity kinds: a Python module is an object, a Python class is an object, and a Python object is an object, and even primitive values are objects. Comparing the design of Python with C++ is like comparing the design of a 1976 Honda Civic with a Russian T-90 main battle tank. That said, the answer you were provided above didn't really answer your question. :) Whether you write `foo.bar` or `foo::bar`, the compiler first looks up `foo` and determines what it is. The tokens being different isn't really solving any problems. Part of the reasoning for the different token - I imagine - is that C had different name lookup rules for entities. In original C, you could have both a struct a variable named `foo`, but used the `struct` keyword to disambiguate. e.g., `struct foo { int foo; }; struct foo foo;` was legal. C eventually removed the need to put `struct` everywhere and just used a name lookup table to disambiguate on context. C++ originally inherited - and then eventually lost - that same split struct/variable namespace. The different tokens were likely C++'s way to handle the disambiguation back before compilers just got smarter and eliminated the problem with more capable parser algorithms.
Compilation is not a problem if the process is fully automatic/hands free. C/C++ compilations are far from this.
The advantages and disadvantages are described in the readme and demonstrated in the examples and unit tests. If you’re just looking for a high-level summary of why this library may be useful to you then have a look at the top summary and the bottom conclusions of the readme. 
There is a comparison to other libraries as part of the readme. It is absolutely necessary to understand that tasks are organized in a graph to avoid race conditions on shared data. It is also useful to apply optimal executors to the tasks. And lastly, when visualized it gives you an overview of your processing chain. 
&gt; Use transwarp if you want to model your dependent operations in a graph of tasks and intend to invoke the graph more than once. What I don't see described anywhere is why the latter part is relevant/important. To me, at least, the latter part is the _interesting_ part – avoid race conditions on shared data is a given.
In addition I might point out that namespaces are like static functions of a class. (I'm not being careful with semicolons below). namespace a{void b()} is pretty much the same as: class a{static void b()} and both are referred to as: a::b Yes, you could use a.b for the static function, but I think it less readable and transparent.
Isn't it? I've never had any problems with it?
Preprocessor directives (things that start with hash) run before the code is compiled. They modify the code on a text level. You can not put define in a function and toggle it at runtime.
D&amp;E §3.11.3: &gt; In C with Classes, a dot was used to express membership of a class as &gt; well as to express selection of a member of a particular object. This &gt; had been the cause of some minor confusion and could also be used to &gt; construct ambiguous examples. Consider: &gt; &gt; class X { &gt; int a; &gt; public: &gt; void set(X); &gt; }; &gt; &gt; void X.set(X arg) { a = arg.a; }; // so far so good &gt; &gt; class X X; // common C practice: &gt; // class and object with the same name &gt; void f() &gt; { &gt; // ... &gt; X.a; // now, which X do I mean? &gt; // the class or the object? &gt; // ... &gt; } &gt; &gt; To alleviate this, `::` was introduced to mean membership of a class, &gt; and `.` was retained exclusively for membership of object. 
library1::libraryInsideOfLibrary myLibrary; myLibrary.functionToBeUsed(); here I create an object of the class libraryInsideOfLibrary and call it myLibrary. and then I have that object call it's member function. The library1::... scope just says that it's from a namespace, and the namespaces try to help prevent overlapping names. You could have multiple people trying to write a class called, "MyClass" and without a namespace, you wouldn't know which one to be referring to. But FrozenFirebat::MyClass and mw130::MyClass are different. Now, you could call a function in scope: library1::libraryInsideOfLibrary1::functionToBeUsed(); This refers to the function defined by the class and not any specific object. Typically you'd see this for static Methods, which in C++ are like globals, but exist in a scoped namespace. You might use that in a singleton pattern (which even then, there are few reasons to ever use singleton pattern). You might run into an example of library1.libraryInsideOfLibrary1.functionToBeUsed() if you create an object called library1, which carries a nested object called libraryInsideOfLibrary1 that gets instantiated on creation of library1, and that object has a function called functionToBeUsed(). Personally, I try to avoid that as it's easy to just create roots that end up being object.topLevel.subLevel.subSubLevel.subSubSublevel.function1(); ... and interfaces or wrappers can make it so much cleaner. as for "using namespace xxx" ... it can be touchy... what using namespace std; does for example, is make it so std::string would only need to be called string because it assumes anywhere std:: scope could be used, it will. So if you aren't sure what the namespace has in it, it can be dangerous. If, for some reason, your program also had a class called string, it would only know to use your string or std::string if you didn't use "using namespace std"
We also use -static-libstdc++ without issues on Linux. We have shipped several games with this, so seems to work fine :)
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/7ruy41/how_can_i_turn_my_cpp_file_into_a_app_file_sorry/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I actually think the idea of creating a binary that risks not working due to the version of a user's libc is ridiculous in this day and age. I want to produce a single executable file with no dependencies if at all possible.
I have never been clear on the licensing effect of statically linking either: https://gcc.gnu.org/onlinedocs/libstdc++/manual/license.html. So I have stayed clear of doing it.
Why not just simply link statically against musl? Up until recently I worked in a team developing a C++ system for an embedded (Cortex A9) device running Linux. One of the challenges we'd been facing was that we had no control over the kernel or core libraries (business dpt. fail) which were (unsurprisingly) supplied in ancient versions. We really (me especially) didn't want to give up on modern technologies like C++17 though, so I later came up with a proposal: to link all our code into a single binary. It would contain multiple "`main`" functions for different `argv[0]` values (*the symlink trick* used by *busybox* and others) and had everything compiled with `-ffunction-sections`. We used quite a lot of external libraries like Boost, Protobuf, Flatbuffers ... so the total size of library archives on linker's input went well over 60MB. The resulting binary was ~ 17MB though and could get even smaller if we used LTO. But there was no need, the size was more than satisfactory already. 
I'd be really surprised if gpl prohibited static linking. Many targets such as embedded systems *require* static linking because there isn't an os to handle dynamic libraries.
Also writing concurrent graph based event system (inspired by google's [breadboard](https://github.com/google/breadboard) and OpenCL ), but it's much complex comparing to this: 1. Tasks is an interfaces, you can implement your own type(python tasks, [cling](https://github.com/root-project/cling) tasks, plain c++ functions e.t.c.) 2. Tasks group in packages, packages have their own logic. 3. Tasks logic: run once, after, before, foreach(broadcast) and force flag(run in thread-pool if it's queue is empty, otherwise create thread). Same logic for packages. 4. Timeout tasks(needs thread for time handling). 5. Thread-safe input (needs to specify it explicitly), because inputs can be shared between multiple tasks. 6. Children tasks can be added while package already running. 7. Lock-free hash tables for task's names (tasks with no name don't allocate space in the hash table). 8. Placement new for tasks where it possible(condition: previous task size &gt;= new task size). P.S:Very many components are still in the initial / unfinished state, so I can import it on github not earlier than in 2-3 months.
Good job, also writing concurrent graph based task system (inspired by google's [breadboard](https://github.com/google/breadboard) and OpenCL ), but it's much complex comparing to this: 1. Tasks is an interfaces, you can implement your own type(python tasks, [cling](https://github.com/root-project/cling) tasks, plain c++ functions e.t.c.) 2. Tasks group in packages, packages have their own logic. 3. Tasks logic: run once, after, before, foreach(broadcast) and force flag(run in thread-pool if it's queue is empty, otherwise create thread). Same logic for packages. 4. Timeout tasks(needs thread for time handling). 5. Thread-safe input (needs to specify it explicitly), because inputs can be shared between multiple tasks. 6. Children tasks can be added while package already running. 7. Lock-free hash tables for task's names (tasks with no name don't allocate space in the hash table). 8. Placement new for tasks where it possible(condition: previous task size &gt;= new task size). P.S:Very many components are still in the initial / unfinished state, so I can import it on github not earlier than in 2-3 months. 
Well, I ain’t a sales man. And I am not doing this to entertain anyone. I assume that people read carefully if they care. 
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Sounds like a cool project! Would be interested to check it out once it’s public. 
But buffer overflows happen when UBis triggered. What's scary about this is that you can exploit code that is completely UB-safe in c++ standards.
Use clang and libc++
Not every project can share source code. Not every customer cares for learning how to operate a build system (even if it is as simple as entering a directory and typing a single command). And even when they do, you will run into tiny little system differences that somehow cause builds to fail. 
For me it was quite opposite, rust seems much familiar because everything it does is what I was already doing in c++ so I never understood the hype behind borrow checker and the rule you mentioned until one day when it finally clicked :D 
Oh I like this! In a way, is this not similar to the way in which OSX (now macOS) handles the similar scenario using the mmacosx-version-min flag? If I'm not mistaken that flag defines macros that in essence turn certain headers to their older versions. 
That only works if you don't need to `dlopen` plugins, as the static musl doesn't support dynamic loading. But even if you link to musl dynamically and ship the libc.so file alongside your binary, if you have closed-source 3rd-party dependencies that were compiled and linked against glibc I believe you will run into ABI compatibility problems. Assume e.g. that your code has to create an object of a 3rd-party library type (using new which then internally forwards to musl `malloc`) an then passes ownership of that object to the 3rd-party library. Then that library will try to dispose of that object using glibc's `free`.
Can anyone elaborate about: &gt; C26435 SINGLE_VIRTUAL_SPECIFICATION Methods should clearly state the kind of their virtual behavior by using a single specifier (‘virtual’, ‘override’, or ‘final’). First of all I assume **Methods** apply to `virtual` methods only. Secondly I suppose `final` implies `override` so one of two: 1. Why isn't `final override` a syntax error? 1. Why should the checker disallow `final override`? (I think its pretty readable)
0. One implies the other, so there's no harm. 0. One implies the other, so it's redundant noise.
That technique is nothing new, it's been used for a long time already in the wild. It works just fine, as long as you don't rely on bugfixes in glibc and you're fine with an old version!
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
This really shows that there needs to be a real solution to be able to package the library with your application. While this project is nice for its purpose, it's really a workaround rather than a solution. Having to use an old library version because Linux tells you that you can't use a newer version on an older distro is super silly.
An excellent answer, but there is still the question of 'why'. Could C++ have been designed using '.' instead of '::' as the scope qualifier for classes and namespaces? Or would that have introduced some parsing ambiguity somewhere? namespace bla { struct foo { static int x; void bar (); }; foo f; }; bla.foo.x = 0; // Alternative syntax, but seems ok as well bla.f.bar (); // same (and yes, I realize the answer could very well be "it seemed like a good idea at the time"...) 
With regards to your `class X X` example, in C there is no ambiguity because `struct` is mandatory in `struct X X;`, and serves to disambiguate the uses of X. The problem here is that C++ relaxed the rule, possibly a little too far. IMHO the following code should have been illegal: struct X {}; X X; Same as how this is illegal: typedef struct {} X; X X; 
Am I the only one who can't add comments to the post?
I'm one of the cmake-init maintainers. We are absolutely aware of this problem and are in the process of creating documents, websites and other materials to provide documentation. Surprisingly, cmake-init built a community even before it was properly released.
Over half of the links to individual guidelines lead to 404s... 
&gt; CentOS 4 Welp, that's severely outdated and unsupported.
Yes, you're right, plugins don't go well with statically linked binaries. musl is mostly ABI-compatible with glibc - they're C libraries after all. I've run into issues with symbols missing from musl when I was linking static 3rd party dependency compiled against glibc but those were quite easy to overcome by providing dummy/wrapper symbols just to have them defined. 
Yea that's annoying but, to be fair, they did warn us. &gt;Note that some of the links to docs.microsoft.com do not yet resolve. Not all of the official documentation has yet been written for this topic. 
If you want a learning opportunity just join the C++ slack community: https://cpplang.now.sh/ I suspect there are quite a few students there as well
&gt; One implies the other, so it's redundant/noise. final does not necessarily imply override. There are valid reasons to have for instance a method marked as `virtual final`: struct foo { virtual int blah() final; }; this way you ensure that no one writes a subclass with a `int blah()` method that accidentally overrides your stuff.
I'm a bit confused what these reasons would be? Forcing a vtable/non-pod? In which case, I'd prefer `virtual ~Foo() = default` but it smells pretty bad to start with.
The libstdc++ license is a bit unique in that you are granted an exception to the GPLv3 viral terms for statically or dynamically linking to it as long as you use GCC without GPL violating extensions, plugins. Specifically: &gt; A Compilation Process is "Eligible" if it is done using GCC, alone or with other GPL-compatible software, or if it is done without using any work based on GCC. For example, using non-GPL-compatible Software to optimize any GCC intermediate representations would not qualify as an Eligible Compilation Process. &gt; &gt; 1. Grant of Additional Permission. &gt; &gt; You have permission to propagate a work of Target Code formed by combining the Runtime Library with Independent Modules, even if such propagation would otherwise violate the terms of GPLv3, provided that all Target Code was generated by Eligible Compilation Processes. You may then convey such a combination under terms of your choice, consistent with the licensing of the Independent Modules. 
Correct me if I'm wrong, but I think this only works with static libraries linked against glibc because there the undefined symbols still have their C name (e.g. `malloc`, `memset`). Looking at the output of `objdump -T libc++.so.1.0 | grep GLIBC` it seems that this dynamic library that was linked against glibc is looking specifically for the glibc versioned symbols, e.g. for `malloc@GLIBC_2.2.5` and `memset@GLIBC_2.2.5`. 
I'm quite against the idea of only using one specifier. considering that override and final appear at the end of the signature and virtual is at the start, I find that using both virtual and override improves readability. Omitting virtual when you have override or final makes it less clear at a glance if the function is going to be part of the vtable or not. I normally scan the methods by looking first for virtual, then for possible additional specifiers like override/final.
And at least you get a 404 and not one of those super-annoying auto-redirects to a generic "support" page.
Yes I agree we just rebuild on each platform we intend to support.
What part was a pain? Never had any issues
Yes, buffer overflows work at the level of the languages abstract machine, whereas Spectre is at the level of the processor's abstract machine. At the language level you can use good coding practices, code checkers, etc. to defend yourself. At the processor level there aren't the same tools. Correct C++ code can be exploited. 
Is there a way to exclude files or folders from the check? I would like to be able to filter out third-party libraries that are part of my solution, to reduce the noise in the analysis results. 
In 10% of the cases, automake works 100% of the time!
Does this exclude clang?
&gt; C26433 OVERRIDE_EXPLICITLY When a **method** overrides a base virtual function it should clearly state this by using the ‘override’ specifier. &gt; C26435 SINGLE_VIRTUAL_SPECIFICATION **Methods** should clearly state the kind of their virtual behavior by using a single specifier (‘virtual’, ‘override’, or ‘final’). &gt; C26443 NO_EXPLICIT_DTOR_OVERRIDE Destructors are very special **methods** and guidelines for them differ from the OVERRIDE_EXPLICITLY rule: it is recommended to rely on implicit overriding if the base class has a virtual destructor. Wait. They use the word "method"? I always think the correct, concise, formal, standard term is "virtual member function". I always think formal texts and technical texts like the C++ Core Guidelines and compiler diagnosis must never call it "method".
Only solution based or can I use it with my CMake projects?
On Windows they ship a million versions of the c/c++ runtime library, one for every vs release. Ever wondered what the "vs2015 redist" every steam game wants you to install actually was?
The grey area I have seen discussed is the wording of “runtime library”. A static library is not a runtime dependency, it is only relevant at compilation time. And further more, after compilation, it is no longer “a file” as optimizations likely strip out all unused objs. I’m not saying this is the correct interpretation but it is one. Most people just say “talk to a lawyer” to make sure. Not sure why this type of stuff is left up to any interpretation at all, seems like it should be make explicitly clear. It mostly comes down to wording which is always how licenses work. Seems like it is written to be 100% sure you have to get a lawyer, which is pretty dumb in my opinion.
Interesting, so why isn't being able to install/ship the runtime libraries a solution on linux too? EG on windows I can just say "install this package" (or realistically most of the time it just works), whereas on linux it seems to be a lot more effort
Well, you can (iirc steam does this), but it's a pain in the ass to set up. The main issue is there is no authoritative set of binaries. On windows ms issues an installer for each runtime version, and that's it. On Linux you get the glibc source tree and that's it.
Looking at your code, there are a couple of issues: * `namespace {`: An unnamed namespace in a header file is odd, I'd suggest naming it `detail` or something like that. * `constexpr std::chrono::milliseconds DEFAULT_TIME_TRUE_MILLISECONDS;`: You should only use CAPSLOCK for macros. * `TBool(std::chrono::milliseconds life)`: This constructor should be `explicit`. * `TBool(size_t life)`: This constructor should be removed, it undermines the type safety provided by chrono. If you really want, I'd suggest a `static` `fromMilliseconds()` function. * Copy constructor and destructor declaration are unnecessary and should be removed. * `bool operator==(bool right)`: This should be a non-member function to allow `true == my_tbool`. I'd also suggest comparison between two tbools itself, maybe? * `operator bool() const noexcept`: This operator should be `explicit`. There is a special rule for `explicit operator bool` that allows things like `if (foo)`, `if (!foo)` but prevents `int i = foo`. Then you can also remove the `operator!`. * `return ( (time_set + life) &gt; std::chrono::steady_clock::now() );`: Minor thing, the extra parenthesis are unnecessary.
Thank you. Great feedback, I really appreciate it.
Cool, thanks!
This is over abstraction. Based on the described problem you have a few very specific use cases. I would personally just write the logic in the couple places you need it and be done with it, abstraction adds extra load and unless you are literally using this all over the place I wouldn't bother. For your specific use case where you need 5 of them set to true, I would just have a 'lifetime' counter and increase it by 1s each time you detect a "wiggle". If it ever exceeds 4s you know you've hit the 5 "wiggles" within your desired timeframe.
This will be very useful for game development. Thank you!!
 .... std::chrono::time_point&lt;std::chrono::steady_clock&gt; m_previousTick; std::chrono::milliseconds m_life; .... const int c_requiredWiggles = 5; const std::chrono::milliseconds c_wiggleLifetime = 1000; void Tick() { const auto now = std::chrono::steady_clock::now(); const auto delta = now - m_previousTick; m_previousTick = now; m_life = std::max(0, m_life - delta); } void OnWiggle() { Tick(); m_life += c_wiggleLifetime; ) bool ShakeDetected() { Tick(); const std::chrono::milliseconds requiredLifetime = c_wiggleLifetime * (c_requiredWiggles - 1); return (m_life &gt; requiredLifetime); } That's literally all the logic you need.
Glad this game out, the previous version of it was horrible with resharper and now it's all fixed :)
Have you noticed anything else from Rust? I was thinking of trying that beast out...
It's not great feedback, it's mostly circle jerky bike shedding, but you've taken the high road.
Neat idea. Though I wonder what you're giving up by linking against ancient glibc versions - presumably years of security, performance and bug fixes?
Of course it's bike shedding, that is how it works: https://twitter.com/iamdevloper/status/397664295875805184?lang=en
I also agree that this is an over abstraction. But if I were to build something like this, I would make it have an integer value instead of just a Boolean. I would have each refresh increment the counter, and when a timeout occurs it goes back to zero. This way after one second has passed, all you have to do is check to see if the counter is 5... I can see this being useful for detecting things like a triple and quadruple Mouse clicks as well, but I'm finding it hard to come up with many more use cases that make this abstraction worth it.
I'm working with normal c++ not 11 nor 14, so I was wondering why my pause command kept on failing?
I don't think you are trading power for sanity. Languages like python trade power for sanity and Assembly trades performance for sanity.
in games you have to track time anyway so why use this?
The original code isn't complex enough to consider the abstraction a downside. It's short, does its job and is reusable. Your version isn't reusable. And yet the difference in complexity is negligible. Also, global variables? Really? 
I mean I'd generally agree with you but unnamed namespace, badly named macros, inconvenient overloaded operators, extraneous parantheses are annoying stuff and I don't think they're bikeshedding.
https://www.youtube.com/watch?v=rX0ItVEVjHc Stop trying to force abstractions where they don't belong. Just because something _can_ be reused doesn't mean it _should_ be reused. Don't solve the general case; solve the problems you actually have. What do you think is easier - reading and reasoning about a straightforward implementation of some logic, or seeing the unknown type TBool, having to go figure out what it does; and remembering what it is everytime you come across it? What do you think would happen if we abstracted all things like that? Let's just abstract all basic logic and see what happens. Consider my code more pseudo-code than actual code. Although I did hope the ellipses and the naming convention would imply I was expecting the m_* to live on an object somewhere rather than be in the global namespace. If you want to be pedantic, there are a few precision and other issues that should be addressed as well.
It was just as short and simple to write the reusable version. Given the choice in that case, that's what you should go for. As it turns out, there's an obvious candidate for the object in which to place those variables. Extending something I didn't say to an extreme nobody suggested is not a counter argument. 
So by "normal" you mean C++17?
But it's not. The reusable version uses 10 variables. Mine uses 2. Why? Because I'm solving a specific problem. Mine can be abstracted to a million "wiggles" with minor performance impact, the original will be vastly slower. I feel you are focussing on the details, and missing my entire point.
Don't do `system(pause)`, do `ctrl-F5` instead.
Actually, unnamed namespaces in headerfiles are usually not a problem unless you rely on variables/functions having the same address in your program. On the other hand it makes the optimizer's life easier. Tha being said - I don't see the advantage of wrapping an constexpr variable into an unnamed namespace - most likely, this has zero effect (at least I can't think of any). 
&gt; Tha being said - I don't see the advantage of wrapping an constexpr variable into an unnamed namespace - most likely, this has zero effect (at least I can't think of any). Right, they already have internal linkage.
We track time quite a bit, so I'll probably modify the code a little such there aren't as many calls to chrono, but it would be nice to see if this library reduces some of the branching logic in controller input.
Knuth hasn't even finished it yet!
[Here](https://wandbox.org/permlink/RQDwQ8dHajzrs1pe) is what I use for named parameters (copy-pasted from [this](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0424r0.pdf) proposal). It is not standard yet and does not work on MSVC, but I don't care (clang and gcc compile this just fine).
[This function](https://github.com/travisdowns/uarch-bench/blob/master/x86_methods.asm#L478-L487) is not restoring `r15` like it should; it may crash.
It's better to avoid the virtual function completely so you can save the indirection. Your compiler might actually optimize it away.
I'm sorry, but your code/suggestions provide no discernible benefit as far as I can see. Once written properly, there is no performance difference or excessive variable usage with a general approach compared to your specific approach. While I certainly wouldn't have created a TBool class to solve this problem, I would have provided more encapsulation and abstraction than you have, which is none. You may as well go use C if you think these things are bad.
It is not a huge problem, but macro approach does not always work, for example this will not compile: struct foo { foo(std::initializer_list&lt;double&gt;){} operator double() const { return 42.0; } }; gluLookAt( eyeX = foo{1,2}, eyeY = 0, eyeZ = 0, centerX = 0, centerY = 0, centerZ = 0, upX = 0, upY = 1, upZ = 0 ); Can be fixed with extra parentheses: gluLookAt( eyeX = (foo{1,2}), eyeY = 0, eyeZ = 0, centerX = 0, centerY = 0, centerZ = 0, upX = 0, upY = 1, upZ = 0 ); 
I have to say it: in meson this is a build ootion and done :)
MSVC has a bug reporting function... Use it to report bugs!
Technically, the standard library doesn't have to be implemented in terms of header files. The compiler could just know all standard library elements provided by a #include &lt;standard_header&gt; and only consider those when doing lookup.
Slack
Package management and the build system were what got me hooked. The compile errors are amazing too, inspired by Elm if you're familiar. It felt like when I jumped from gcc to clang a few years ago. I often read an error message and think to myself "Why yes, that is what I should have done."
But this doesn't solve the problem of using C++17 features in the source code does it?
I encountered `propagate_const` earlier but never (untill this post) found an explanation what it is for. Good article ___ On a side node - in a const method, isn't `this` of type `const T* const`?
If you're young, then why not? Dubai is not too bad a place to go for a bit after graduation. But be aware that they struggle to retain people over there and for a long list of good reasons. There is a reason why the pay and perks appear to be so great.
Dubai is better than most in that region. If you're male, young, single and heterosexual, hold a Western passport and are there under a high skilled visa, and do not do anything in public outside the walled enclosures set aside for Westerners, you'll be fine. But as I mentioned, few Westerners stay there once into their thirties, generally people don't prefer to raise their children there inside walled communities all the time. Doesn't feel right.
Want to comment on the const-ness of a member std::vector&lt;int&gt; blah; Accessed through const methods... Should it be a read only vector (no insert/remove) but allow individual items to be modified, or also want const items...
When I saw the title, I thought "member pointer" means "pointer to member" (i.e. `T C::*p`).
I did [this experiment](https://github.com/LucHermitte/NamedParameter) some times ago. Alas it requires a non standard extension at this point, and I find that writing function body quite clumsy.
There is no general answer to this. The comparison makes no sense, especially since your didn’t specify what kind of „AI programming“ you’re talking about.
Containers emulate actually "containing" the elements, so const is completely propagated (if the container is const, so are the elements).
Your right. In the waggle my mouse application the state check of the TBool array is performed as part of the mouse even handling routine. This saved writing a second thread, as probably the best way of implementing the temporal concept of when is to write a second thread which monitors (polls) the states of the TBools. 
There are a bulk of additional uses I could think, hence why releasing it. I hinted at a few of them in the readme. - Simple monitoring of application's SLA - Deterministic programming; not just coming to a result, but where the quality of the result is time bound. - simple ways to implement CEP (complex event processing) like functionality without a full blown CEP engine - implementation of simple low pass filters Perhaps I should elaborate more on these in the readme?
That would be a great idea. I'd be really interested to see if this helps at all. One of the interesting things in temporal logic (and not implemented in TBool, yet.. am considering extending it) is the use of the future state definitions. If x is true now and holds for y seconds then z becomes true and both hold for a further 3 seconds the we've reached a new state and perform a function. I should also have included a link to the Wikipedia page on temporal logic. (A todo for me) Please do keep me posted, if it helps at all, or if you think further concepts would he useful.
Additionally, this TS was published before C++17 was finalized, but only `void_t`, `conjuction`/`disjunction`/`negation`, `not_fn`, and `gcd`/`lcm` made it in to C++17. I don't believe there's been any revisions or updates since then, so it seems less likely that this will be in C++2a
There’s nothing wrong with a naming convention that states that compile-time constants should be ALL_CAPS. The other comments are helpful.
&gt; isn't this of type const T* const? `this` is an rvalue (`&amp;this` is wrong), and a pointer rvalue can't be `const`. The type can also be queried with `decltype`.
Asserts compile, but not the declaration #include &lt;type_traits&gt; struct A { void foo() const { static_assert(std::is_same&lt;decltype(this), const A*&gt;::value, ""); static_assert(std::is_same&lt;typename std::add_rvalue_reference&lt;decltype(this)&gt;::type, const A*&amp;&amp;&gt;::value, ""); const A*&amp;&amp; const x = this; } }; main.cpp: In member function 'void A::foo() const': main.cpp:12:26: error: 'const' qualifiers cannot be applied to 'const A*&amp;&amp;' const A*&amp;&amp; const x = this; ^ &gt; pointer rvalue can't be `const` qualified Any specific reason? The language allows const rvalue references
Work with many folks from UAE. It is better than Japan and US, so be sure you never go to one of those. Those other countries practically have institutionalized lower classes. (Though I am Nordic, so my view when living in various places around the world is a bit social liberalism-colored, and Japan and the US are the most anti-social liberal societies in the world, so I get very discomfortable at times there.)
Completely agreed, I think it improves readability to have the virtual keyword in front of virtual member functions even if you add final or override. It allows you to parse all virtual functions much faster. That's why I think it's similarly bad to write (even though some people argue that's the correct way to write modern C++ code): auto main() -&gt; int { return 0;} auto someComplicatedFunction() -&gt; std::vector&lt;Foo&gt; {...}
Very cloudy question but in my experience the programming part of AI is tipicaly easy. It's a lot of exploratory work, though.
Small question, how does it keep adding to array if the instruction is: 4046d9: c5 f5 fa c8 vpsubd ymm1,ymm1,ymm0
`vpcmpeqd ymm0,ymm0,ymm0` compares `ymm0` to itself, which fills the register with all ones in binary -- in [two's complement](https://en.wikipedia.org/wiki/Two%27s_complement) representation this corresponds to `-1` (with subtracting -1 being equivalent to adding 1). "Why subtract -1 instead of adding 1's? Just because the speed is the same, and creating a YMM constant of -1's can be done with a single VPCMPEQD instruction. This isn't a really useful optimization in this case, but doesn't hurt." - https://dendibakh.github.io/blog/2018/01/18/Code_alignment_issues#comment-3718889834 - https://stackoverflow.com/questions/37469930/fastest-way-to-set-m256-value-to-all-one-bits
I would lean towards the consulting firm because you will probably get more exposure to different people and sectors. You will meet more people and learn more about business, and get a sense of what you like and dislike. It will increase your optionality for the next job. I feel getting entrenched in niche technical area like HFT right off the bat is a more limiting move, unless you're really sure that sort of engineering is what you want to do for many years to come. I also suspect that whole area of data center/network solutions is rapidly commoditizing and has falling profits. It *was* very profitable and exciting, but less and less so now. If you can find out the financials of this engineering firm that might be useful.
I've misread the description of [pcmpeqd](http://www.felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html), thought it set 1/0 as value/ not bit. Thanks for the explanation!
Ohh yeah, that was intended to be some pseudo-esk code to describe what could be done. The C++ code in the readme should be syntax hight lighted and formatted correctly.
&gt; There is a special rule for `explicit operator bool` TIL
are there people doing research on how to get compilers to have better heuristics so that they can align stuff better automatically ? 
&gt; Japan and the US are the most anti-social liberal societies in the world lol. &gt; I am Nordic Figures.
You also can publish your positions now at Meeting C++ via this form: https://meetingcpp.com/mcpp/jobsubmission/
We prioritize getting the blog post out so developers know the new checkers are available. When you find this page later through a web search the links will all resolve. This is just another "problem" introduced by the fact that we're shipping VS about every month now as opposed to about every three years. 
Thanks, I learnd something new!
The compiler toolchain works with CMake, and CppCoreCheck is part of the compiler toolchain. All the individual parts should work if you wire them up in CMake. I don't know how much of the wiring our CMake team has gotten in place for code analysis yet.
Maybe? Can you comment on other VC Blog posts? Nothing's changed with our WordPress settings. I don't see other comments, though, so maybe there's an issue?
Fair point, though I think the message is still pretty clear. The [Core Guidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md) uses the term "method" to mean "function" a few times.
Shoot me a message with your user name after you post this time. I'll check the spam filter. Some legitimate comments do get caught, but there are thousands of actual spam comments in there so I can't go fishing around for the good ones. 
We may have a different meaning of "power" :) Mine was closer to *control*; in C++ I have the power to decide on the memory layout, where my memory goes and when I access it.
Meh I call that performance since the only reason you would want to do that is performance or in the rare case of registers.
I don't think its a bad thing to redo something that already exists.
Completely disagree. I don't like superfluous keywords littering the code and I don't think it makes it more readable at all, just longer lines and line breaks. It's mostly about getting used to it. C++ has verbose enough syntax already, please don't add unnecessary keywords.
Furthermore having them exclusively also makes it clearer at what point a virtual function is introduced. Having just one would help you if a parent class adds a virtual function that you introduced in the child.
`const A*&amp;&amp; const` isn't even a legal type, you mean `const A* const&amp;&amp;`?
Indeed, now it works
changed! thanks!
LOL. That tweet is brilliant, and scarily true. When the code is small we can more easily see what it is doing and why, and it is easier to comment on. Large blocks of code are a pain, and we tend to point out on the really bad stuff. foonathan: Thanks for the feedback, coming back to C++ after a while away it is great to get the feedback and pointers. I really do very much appreciate it.
so `m_vector.push_back(elem);` in a const method won't work. But of course `m_vector.size();` - works ok, as it's marked as a const method. Still, if your m_vector is a pointer to a vector (for some reason), then you can call non const methods in your const method...
The feedback was great, coming back to C++ after a time away, trying to remember what you did your last c++ team, and then playing catchup on the latest standards, it was really good to get the feedback. Thanks to everyone who took a look at it.
Umm... yes, when I was last doing C++ constants and macros were both ALL_CAPS. And depending on the OS we were writing for constants would sometimes be K_variable_name. But it was environment dependent. 
hmmm... the site http://en.cppreference.com/w/cpp/experimental/lib_extensions_2 at the end mentions the merged features. But is this for sure that we won't see other elements from this TS?
A problem is the lack of an efficient "reference to vector contents where the contents are constant/mutable, but the container is not". Well, outside of `gsl::span`. 
Great, my post didn't work either. Now how will i send the prince's money overseas before the revolutionaries get it? 
If publicly visible types change their layout, you will need to recompile. You can avoid this with PIMPL. Adding functions or overloads allows using the old functions, assuming they are unchanged and not removed. Global variables should be avoided, but can be added without limitation. Of course, when removing anything, you will break stuff.
1) It depends on who allocates these struct objects. If the library instantiates the structs, and the struct declaration is only used to read members from library-provided pointers, you'll be fine, but this is still walking on thin ice. It will also only ever work if members are appended at the end of the struct. If the user instantiates the structs on his side, then it will not work. 2) 3) 4) These all fall within the same category: adding new symbols to a DLL is fine, which is what all 3 cases do.
Okay, that's what I thought, and also what I needed to know. Thanks for your reply.
Great, thanks for your reply.
A bit of a clarification for 2): Do not expect you new overloads to ever be called by non-reocompiled code. For example if you had `void foo(int);`, and added `void foo(short);`, `foo((short)3);`will still invoke `foo(int)`;
As could we all! But thanks for that. For completeness, I've verified that our docs people have a policy of using "function" rather than "method", and I've also asked Sergiy to update these diagnostics. 
You'll find useful input in this talk : https://youtu.be/Ia3IDPjA-d0?t=1474 At 24:34 he talks about breaking &amp; non-breaking ABI changes. He also talk about API changes (0 to 24).
I've managed to use the checker with the following setup on CMakeSettings.json: { "name": "vs-analyze", "generator": "Ninja", "configurationType": "Debug", "inheritEnvironments": [ "msvc_x64_x64" ], "buildRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\build\\${name}", "installRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\install\\${name}", "cmakeCommandArgs": "-DCMAKE_CXX_FLAGS=\"/analyze /analyze:plugin EspXEngine.dll /EHsc\"", "buildCommandArgs": "-v", "ctestCommandArgs": "", "environments": [ { "esp.extensions": "cppcorecheck.dll", "esp.annotationbuildlevel": "ignore", "caexcludepath": "${env.INCLUDE}" } ] },
Is this supposed to compile to wasm?
&gt; I didn't want to use a "static constexpr" as this still requires initialisation within a code block I don't know why you think this; at namespace scope `constexpr` implies `static`, which is why it has internal linkage without being in an anonymous namespace. &gt; Obviously an unnamed namespace in a code block works well, in a header file is has no effect at all Again, I don't know why you think this; an anonymous namespace has the same effect in both places (how could it not??), it's just not necessarily a _desirable_ effect for code in a header file...
Thanks, I'll check it out!
Constants have scope and linkage, macros have neither – macros alone get ALL_CAPS, because they're the only odd ones out.
Are the slides for this talk available yet?
Available under: https://github.com/psteinb/meetingcpp2017
&gt; I try to show them that I can make a cow speak and that I can resize my terminal Like you can in Windows?
The compiler needs to know how many times you'll have to run this loop, and it's also likely to be much better to unroll the loop instead.
I never thought this would get any real world usage. Oh well! FWIW, I've been thinking about expanding that into a proper library lately. It might happen, we'll see.
Having to use macros to wrap function calls is an absolute no-go in my opinion.
Not quite true. The UDL will be standardized, but perhaps in a slightly different form (that does not use parameter packs, but a `char const*` instead). The usage would be the same.
It's a really recent thing though, you used to have to right click and go to properties to change the terminal size.
Thanks! I'll take a look. 
Note that adding overloaded virtual methods does break binary compatibility, at least on Windows. Adding overloads in general can break source compatibility, as you may introduce ambiguities.
If the first company is Corwil I have heard good things from people working there about the company culture. As for your decision: depends on what you want(for me traveling is boring, but I see it being exciting for some...), but I think you are right that it is easier to get into ML after 4 years in C++, than reverse.
There is quite a bit more to making msvc work as a cross-compiler. You might have noticed that the author was careful to only use relative paths in the `cl` command lines (`/I`, `/LIBPATH`, input and output files, etc). That's because you would need to translate them back (and even forth, for example, in the `/showIncludes` output). We are doing all this in [msvc-linux](https://git.build2.org/cgit/etc/msvc-linux/) which is part of `build2`. In fact, we've been using msvc as a cross-compiler for a couple of years now and the experience has been liberating -- I can quickly test thing with the three major compiler (and even several versions of msvc) without leaving emacs.
Visual Studio is actually pretty good and worth using, but you can install the build tools stand-alone. As far as libraries, you'll pretty much have to find (and maybe compile) those on your own. [http://landinghub.visualstudio.com/visual-cpp-build-tools](http://landinghub.visualstudio.com/visual-cpp-build-tools) If you want to use Clang/LLVM, you still need VS2017 first: [https://arvid.io/2017/08/03/using-clang-on-windows/](https://arvid.io/2017/08/03/using-clang-on-windows/) Or you can use GCC with MinGW: [http://mingw-w64.org/doku.php](http://mingw-w64.org/doku.php) or Cygwin: [http://preshing.com/20141108/how-to-install-the-latest-gcc-on-windows/](http://preshing.com/20141108/how-to-install-the-latest-gcc-on-windows/) 
Just get the [Visual Studio Build Tools](https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017) at the bottom of the page. That said, there's not really anything to learn for your day-to-day-usage. Shortcuts for compile, run/debug, etc. You're going to want a debugger eventually, so just get the community edition and use CMake to generate your solutions like everybody else does. If learning VS is your stopping point, you're in for a rude awakening when it comes to doing GUIs on Windows. Whether it's Qt, Juce, wxWidgets, or one of the other frameworks, it's not just going to be a walk in the park. There will be build system integration (so you're going to need something, whether you like it or not) and a whole host of new domain specific logic to pick up.
Thanks. The work of yours and your team is so important and I appreciate so much that I really hope the wordings in these diagnostics can reflect the quality and seriousness of your work. To clarify, I think the term "method" is alright in many occasions. But it is after all not a formal or well-defined term in C++ proper. This is one of several cases I would care about ambiguity and formality.
&gt; Sometimes, I look down on developers using Windows, wondering how the eff they manage to get anything done by clicking on things. So, do you look down on your colleagues using Linux who use Eclipse or NetBeans for C++ programming? I use VS on Windows. I use a bunch of keyboard shortcuts. I use T4 templates for generating C++ code when I need some code generation. Powershell to script my programs (you get that for free if you wrap them in a COM interface). I used to use Linux 8 years ago. It was a bunch of small irritations, but when copy-paste in gnome suddenly stopped working, i ditched it for Windows which fell nicely with me getting a job in a Windows-shop. I can tell you: after having learned the tools (yes, wow, you have to *learn* stuff on windows too, but the shiny icons somehow make people overlook that so they end up complaining about having to click too much) I became 2-3x more productive in development than I ever was on Linux. &gt; But there is this thing. Windows is an “ ecosystem “. Yes, and it's a good thing. Esp. for deployment. To get the same stuff that comes with a default installation of Linux (windows installation, btw, can be trimmed to 12-14 GB of diskspace + 1.5GB used RAM after boot) you'd need to install 100+ different libraries and hack together some ad-hoc scripts. (Things are getting slowly better with systemd though.) And some things don't even have an equivalent. Cross your fingers that dependencies work out, esp. on your customer's computers. &gt; and make sure nobody learn about that other OS legends speak of. Oh, can we please stop glorifying the cruft designed in 70-ies that we must still live with today?
Yeah I also felt old when I had this discussion... https://www.reddit.com/r/cpp_questions/comments/7otjcu/problems_with_outputfunctions/dsf1422/
&gt; Just get the Visual Studio Build Tools at the bottom of the page. only for 2015 apparently, 2017 still needs you to run an installer :( too bad, else with what's in the [thread about msvc on linux](https://www.reddit.com/r/cpp/comments/7sa8b0/a_c_hello_world_and_a_glass_of_wine_oh_my_cross/) this could maybe have been scriptable.
&gt; Now I want to write some GUIs, but can't stand Tk. What is Tk?
&gt; The line length is not an issue for me. Large monitors are pretty affordable. The tiny terminals with limited characters from the days of yore are past. I have two very large monitors so I can have multiple files, debuggers, documentation all visible side-by-side at the same time, not to have a single editor with large lines. Monitor size has nothing to do with line length. &gt; Also, if something extends an interface, having the virtual keyword nicely aligned makes it much easier to quickly see which methods were (probably) inherited. You can confirm this by seeing override as a secondary glance. This is not my experience. How quickly I can spot which methods are inherited is mostly about familiarity with the syntax. &gt; In my experience, the "we need to minimize text to keep code readable" mantra makes code less readable. For example, having names that clearly explain what the thing is is much more readable and self-documenting than shortened/truncated names. No that's not what that means. We want to minimize unnecessary text that doesn't add anything, so that it becomes easier to read. It's exactly like variable names, too long variable names is just as bad as too short.
&gt; [...] your demonstration of cl.exe on wine back in 2015 (?) [...] Yes, it was a C++Now 2015 lightning talk. I still remember at the end someone from the audience asked if I am running GCC from Windows Subsystem for Linux ;-). 
LLVM has a bunch of heuristics and things you can tune. For example, you could tell it to align all loops and functions without a preceeding fallthrough block; i.e. only add NOPs which won't be executed.
This still has a lot of cruft. I usually rip out everything but the lib/bin and include directories.
&gt; If anybody is innovating in the OS space, it's Microsoft with Windows. What do you think are the major innovations in Windows recently(for the OS itself)? Personally I count windows subsystem for linux as one.
http://lmgtfy.com/?q=tk%20gui%20toolkit
I do not understand how this is supposed to work. So the function declaration in the header file corresponds to a particular version and all this does is force to link against a different version instead (which might not be compatible with the declaration in the header file). Why should I have any confidence that the result will work?
If I knew it is a gui toolkit
If you are able to compile your code on GCC, this tool is what everyone in the industry uses to check for API and ABI breaks in shared library binaries: https://lvc.github.io/abi-compliance-checker/ Just stick that into a nightly CI. Some places actually run it as a precommit hook, and reject any commits which break API or ABI. It can be made to work for Windows code, so long as that code can be grokked by GCC. I have seen it working, but never configured it to work that way myself. Good luck!
I wonder if you see the irony...
Use GCC or Clang, use Qt for GUI
I wouldn't say it's certain, but it seems to me that if the feature was proposed in 2015 and not adopted for C++17, it's unlikely to be in the next standard. It's such a straightforward feature, I doubt there were any design objections. More likely it was decided that it wasn't useful enough to justify the overhead of adding it to the standard library. That overhead is for the people who have to maintain the code, obviously, but also for the people who use the standard library. If you add in every borderline useful feature, it quickly becomes too big for the users to have a sense of what's available.
Some folks do work in bad conditions --- and I agree that these conditions are slave-like in all sense that we think matters. However, these are folks from very poor countries, and as I understand it, these bad UAE conditions help them support their families back home. So... just another anti-social construct gone unchecked: anti-social capitalism. I would seriously consider moving to an undemocratic country for a long time, but I also know that when you are moving to any country other than your own (democratic) country, you don't have a say anyways. So why bother with the democracy of the nation you live in unless you are at home?
Or you can use conemu and not care about what version of Windows you're on.
The VS2017 Build Tools actually have a lighter-weight installer than the VS2015 Build Tools. And you can install the VS 2015 tools (if you need them) from the VS2017 Build Tools installer. The difference between the Build Tools installer and the regular installer is that the Build Tools doesn't require you to install the core editor. 
&gt; Now I want to write some GUIs, but can't stand Tk. If you're going native Win32, try [WinLamb](https://www.codeproject.com/Articles/1184175/WinLamb-using-Cplusplus-lambdas-to-handle-Win-mess) library.
Thanks for sharing. Appcontainers sounds like mandatory access control, and is more user-friendly compared with selinux. The idea of windows defender guards is very similar to what QubesOS's security by compartmentalization. https://www.qubes-os.org/intro/ I haven't tried unattended Linux boot from an encrypted partition.
Right, exactly! - That is what we would need to do to implement more of the temporal logic tool set. But since the state changes by time, the only way to know about a state change would be to monitor the current time and compare that to the time stamps held inside the TBool. ... the only way to do this, that I could think of, would be to have a thread running concurrently that would constantly check the status (compare timestamp in TBool to current system timestamp) of all created TBools and then trigger notifications when the state changes from True &lt;--&gt; False. There maybe a better way to do that, but I'm not sure what it is. Any ideas?
&gt;I don't know why you think this; Hey dodheim, as I said in the original post, I'm playing catchup on the, ,changes in c++11, I'm returning to c++ after a few years. As I mentioned "my bad", I got it wrong, and I really appreciate the guidance and correction provided here. *goal* What I was attempting to do is to limit the scope of a constant compile time variable to the class it is associated with. I also wanted to have the entire class (because it is such a simple implementation) in a header file. *question* So if the scope of the variable is to be valid only for the class definition, which is contained within the header file, and not resolvable out side the header file, how do you do it? *rule out private constant static member data* Normally I'd make the variable a private static const member variable, but then I need to initialise the variable in a translation unit. This means creating a .cpp file for the class, and I want to avoid that. *current solution* I know that trying to cram everything in to a header file isn't normal. But for small reusable simple classes it can be a useful approach. At the moment I'm using: #define DEFAULT_TIME_TRUE_MILLISECONDS std::chrono::milliseconds(500) class TBool { ... } #undef DEFAULT_TIME_TRUE_MILLISECONDS But this seems really "unpretty" and I was trying to find a nicer way to achieve the same effect.
&gt;You admit it yourself that with two keywords, determining if a method is overridden requires two glances, whereas if you only used one keyword you'd immediately see if the class declares a new virtual method or overrides an existing one. If a class has a hundred methods and 5 of them override some interface, it's much faster to zip through and look for the virtuals first (vertical scan) followed by looking for a keyword at the end of each line (horizontal scan). In the absence of the vertical scan, you have to scan to the end of every method. You're parsing the entire file at this point. I don't understand how this is not obvious. &gt;No that's not what that means. We want to minimize unnecessary text that doesn't add anything, so that it becomes easier to read. It's exactly like variable names, too long variable names is just as bad as too short. "Doesn't add anything" is subjective. Additional text can assist in faster parsing. Additional text can help create jump points that your eyes can immediately go to. For you, "virtual" doesn't add anything if there's already override/final. For me and many other c++ programmers I know, it most certainly does.
Thanks for the guidance. I'm guessing this is now an industry wide convention? - I've seen google adopt the "k" for constant practice. https://google.github.io/styleguide/cppguide.html#Naming
&gt; people are free to vote for the politics they want, HA HA HA HA HA!!! That is epic brainwashing. 
Well the guy wrote (and you quoted) _Now I **want to write some GUIs**, but can't stand Tk._ But yea, now you know ;-)
Use a constexpr private static member - the key thing to know is that if it is constexpr, you can initialise it there and then, there's no need to do so in a translation unit. In C++17 even non-constexpr static members can have this property if marked inline.
There's no such thing as an industry wide convention in C++ when it comes to style. There are some suggested defaults, though, in the C++ Core Guidelines - https://github.com/isocpp/CppCoreGuidelines I recommend looking at them, not just for style, but for general good practice. 
Thank you, that's awesome guidance. Let me try that out. I really appreciate the help!
Thank you! - I've just added that to my todo list.
You can use Clang without VS2017 by getting it from Msys2: http://www.msys2.org 
~10% most likely; just a typo
Says you. Every company I worked at had a style guide that preferred otherwise.
Polling is not the recommended way to do this. Subscribing to events in a mechanism similar to what bdellar described is the most common and widely accepted approach.
Rather than reset to 0, I would just decrement by 1. That way if you shake the mouse twice, then before the one second ends, you shake it 3 more times followed by 2 more times immediately after the one second ends, it will still trigger since you've still shaken the mouse 5 times within one second, it just so happens that the first 2 didn't count. It's like a moving 1 second window.
You could do that, I would make it configurable via a template parameter at compile time 👍. However that does result in what some may consider unexpected Behavior. Imagine a user that shakes at four times, then pauses for 2 seconds, then shakes it once, then pauses for 1 second, then finally shakes it two more times... Your approach would trigger on that final Shake, mine would not. I'm not sure that I would consider triggering on that behavior expected. It doesn't mean that such behavior is wrong, but I would find it surprising.
That reminds me of a [thread in the Lua Mailing List](http://lua-users.org/lists/lua-l/2015-07/msg00433.html) where just changing the name of the interpreter executable resulted in a &gt; 50% performance difference in a particular microbenchmark. The verdict was that the length difference in argv causes some other memory to be aligned differently. It also linked an interesting paper: [Producing Wrong Data Without Doing Anything Obviously Wrong!](http://cis.upenn.edu/~cis501/papers/producing-wrong-data.pdf)
Sorry I should clarify. Each shake would increment the counter by one and schedule a decrement exactly one second in the future. That way it would only ever trigger if there were at least 5 shakes in the last 1 second. It should not have the problem you mention.
How about China?
Its mostly a very vocal minority that irrationally hates on systemd
Since the error report is from a compiler-provided file, I think that means it's doing template expansion, but that doesn't narrow it down much. I assume type_traits doesn't really have 16707566 (0xFEEFEE) lines. That implies some kind of stack/memory corruption in the compiler, breaking the error report. IIRC 0xFEEEFEEE is used to fill unused heap memory in debug builds, and the line number is 1/16 of that. 
You've lost me here. I understand the concept of call backs and event subscription. I'm confused, because something needs to generate the event (spot when a TBool's state has changed) and trigger the call back / event notification. Because the only way the TBool's state changes is if: 1. A predefined period of time passes from when it was last set true 2. A user deliberately changes the state of the TBool Point 2. Is easy to check for, but what about point 1, the elapsed time? As far as I know there is no built in solution to this in C++11. Rather we would need to write one. So I searched and the closest to what we'd need to implement are these two links: 1. https://github.com/bradley219/Thread-Pool-Timer 2. https://stackoverflow.com/questions/14650885/how-to-create-timer-events-using-c-11 Both approaches implement one or more additional threads. In both solutions the extra thread sleeps for a predefined period of time, before generating an event. For a TBool the second thread would need to sleep, wake, check to see if the necessary elapsed time had occurred (the reason to generate an event), then generate and event and signal that back to the source. There are two options here; 1. An implementation with a main thread + thread per TBool 2. An implementation with a main thread + one other thread which checks state of each TBool. Essentially both solutions to the same thing: loop with a sleep delay and then a value check. Either 1) the thread when it wakes from its sleep checks only one value. Or 2) the thread when it wakes checks all known TBool values. If this were platform specific and we were to implement this for Win32 or Win64, we could register for TM_EVENTs from the system event bus, but then we'd need to carefully manage these TM_EVENTs and ensure that we create enough for all the necessary delays for all the currently alive TBools, canceling the ones we don't need when the user sets a TBool to false. This is doable; but it would be platform specific. I don't know of a platform agnostic way to do this, without using the C++11's threads ... a loop of some sort... and a check / poll of actual elapsed time.... I am picking up C++11, after a long time away, so perhaps I'm missing something that can generate these timed events really easily? - I'd love to learn about it, if one exists? Do you know of one? 
Write your own make_unique, it's trivial. Lift it from libstdc++ or libc++, or use the implementation on the cppreference.com page. Use boost for string_view or use string_span from the Guideline Support Library.
OK, I gave that a go, and got a linker error. A quick search finds this post on [stack exchange](https://stackoverflow.com/questions/8452952/c-linker-error-with-class-static-constexpr) So, to get it to work I needed to use a basic type, and then create a temp version of it... small gotcha, but addressed now... and it works... yay!! - I've updated the git copy with the change. Thanks for all the help!
The compiler _crashed_. Of course it's a bug. :) &gt; Is this enough to file a bug report? You may be able to come up with a shorter repro case, but that' already pretty short as is. I'd say it's a pretty good example of what a bug report should look like. :)
Seems to work in the latest MSVC on godbolt, so they might have fixed it already?
Godbolt is currently running VS 2017 RTW, which is an old build (two toolsets out of date; 15.3 and 15.5 are newer).
If webcompiler.cloudapp.net is gone and godbolt is using some old version of VS2017 (which doesn't even seem to have the /std:c++17 switch...), do you have any other recommendations for an online msvc compiler?
 for(auto e : this-&gt;entities) were you intending to copy the entity? I'd expect to see something like for(auto&amp; e : this-&gt;entities)
The helpful link: https://aka.ms/compilercrash. Yes, please report this bug. That page gives you all you need to know to do so. You've already got a pretty clean repro, just send it along. You can also report from inside of VS using https://aka.ms/vs-rap. But in the case of an ICE it's probably easier to prepare a repro and send a mail. 
If you read the article you would get the answer. &gt;PowerFake relies on using GNU ld’s --wrap option to provide a replacement function for the original function while linking.
Can you actually make a change that is source incompatible but binary compatible then? By adding an overload that makes a call ambiguous if recompiled, but the old binary still works since the function it calls is still present and unchanged?
It's actually really easy to replace a function, under the circumstances described there. For a function defined in a shared library, you can do it in multiple ways; it's often called function interposition. The most common/famous is probably the ld preload trick. When running your binary you force the dynamic loader to first load some shared library that defines the function in question in an alternate way; now when the loader loads the executable and other shared libraries it will just silently drop their definition of the function because it already has one. Replacing malloc by setting the MALLOC_CHECK_ env variable is another famous example of function interposition (I assume that this also involves pre-loading another shared library maybe with dl open but that's just a guess).
To fill in some more. I find it innovative in itself that an *out of the box* OS provides the following, among other things: - transactional database (https://en.wikipedia.org/wiki/Extensible_Storage_Engine) - transactional filesystem (though, getting deprecated because it didn't get hold at developers): https://en.wikipedia.org/wiki/Transactional_NTFS - ordered startup with dependency/restart/control management (service control manager; that's why I wrote that things are slowly getting better on Linux with appearance of systemd) - XML parsing and XPath support - distributed transactions (https://msdn.microsoft.com/en-us/library/windows/desktop/ms679938(v=vs.85).aspx) - access control lists on all "objects" (processes, threads, files, etc.) - component model (COM) - etc. Here's a full categorized overview: https://msdn.microsoft.com/en-us/library/windows/desktop/bg126469(v=vs.85).aspx Again, this is included in the OS. No external libraries needed.