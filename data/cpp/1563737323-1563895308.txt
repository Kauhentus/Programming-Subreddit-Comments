Out of curiocity, what kind of bugs can it catch?
Very well said!
This is going to be the most important effort from the usability point of view in the next years. Looking forward.
That surprising case already happens when a compiler allows for tail padding reuse with "liberal enough" `[[no_unique_address]]` use.
Any discussion around std::expected?
I'm just wondering if there's some kind of constraints that seems obvious to said experts but completely eludes us :/
The `sizeof` vs `strideof` distinction either is unique to Swift AFAIK.
The following also got deprecated volatile int x = 0; x += 5; // Oops, not in C++ any more
I believe there is.
&gt; 2) PCG http://www.pcg-random.org Even better, though highly complementary, ChaCha20 would be great to see. Copy Rust's `random`, basically.
I'd also recommend [https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/](https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/) then
You can also message me. We have a clear agenda for at least Belfast.
That's the approach Java took, providing window, button, checkbox, etc, etc. It was awful and roundly rejected by users. No one wanted a UI that was at best subtly different than everything else on the platform.
When boost::uuid generation absolutely DESTROYED our HTTP server's performance the only way to fix it was to have a threadlocal engine. Not sure why OP thinks this is bad, the RNG stuff isn't thread-safe anyway. (We receive may thousands of HTTP requests per second and we recently moved to giving each one a UUID).
this looks more like an advertisement for a hastily written.. I'm not even sure what.. than anything else.
The C++ standard barely acknowledges that C++ source lives in files. Getting from there to build systems is hard to do, especially if we want it to be portable. That said, SG15 will be producing a Technical Report to deal with Modules and how they are spoke, which is baby steps towards package management.
You need to allocate memory to store state. State information is necessary. That’s why it’s not a function call already.
/u/jfbastien?
Could you not generate m/billions of random numbers, save them to file and get your reproducibility from that?
How is that a problem? The presence of any function in the code probably takes more bytes than the state required for a random number convenience function.
What's wrong with MT?
People think that using Hunter means that you need to modify your CMakeLists.txt with their API, but you can use it the same way you would use vcpkg and conan, you can write a CMakeLists.txt file which downloads your 3rd party dependencies, compiles them, installs them into a folder, and gives you a toolchain file which will set up the wiring for your `find_package` calls. cmake_minimum_required(VERSION 3.14) file( DOWNLOAD https://raw.githubusercontent.com/hunter-packages/gate/master/cmake/HunterGate.cmake ${CMAKE_BINARY_DIR}/HunterGate.cmake) file(WRITE ${CMAKE_BINARY_DIR}/hunter_config.cmake [=[ hunter_config(pcre2 VERSION ${HUNTER_pcre2_VERSION} CMAKE_ARGS PCRE2_BUILD_PCRE2_8=OFF PCRE2_BUILD_PCRE2_16=ON PCRE2_BUILD_PCRE2_32=OFF PCRE2_SUPPORT_JIT=ON) ]=]) set(HUNTER_ROOT ${CMAKE_CURRENT_SOURCE_DIR}/hunter) include(${CMAKE_BINARY_DIR}/HunterGate.cmake) HunterGate( URL "https://github.com/ruslo/hunter/archive/v0.23.187.tar.gz" SHA1 "c62a35f423e6358ff0ec4325572527a9c8ddd5c8" FILEPATH ${CMAKE_BINARY_DIR}/hunter_config.cmake ) set(HUNTER_CONFIGURATION_TYPES Release) project(3rdparty) hunter_add_package(freetype) hunter_add_package(ZLIB) hunter_add_package(PNG) hunter_add_package(double-conversion) hunter_add_package(pcre2) # Create a toolchain file which sets CMAKE_PREFIX_PATH file(READ ${CMAKE_BINARY_DIR}/_3rdParty/Hunter/install-root-dir hunter_install) file(WRITE ${CMAKE_CURRENT_SOURCE_DIR}/hunter_toolchain.cmake "list(APPEND CMAKE_PREFIX_PATH \"${hunter_install}\")\n") if (CMAKE_TOOLCHAIN_FILE) file(APPEND ${CMAKE_CURRENT_SOURCE_DIR}/hunter_toolchain.cmake "include(${CMAKE_TOOLCHAIN_FILE})\n") endif()
It was a reference to one of the rejected proposals, part of library fundamentals TS v2. It proposed to have a c-like global thread-local rng if you include &lt;random&gt; library, with free global functions randint and reseed. I don't agree with such design - of course, there are some cases that having a thread local generator will be the best option, but it should be up to the developer to choose this solution.
Probably takes more bytes? Are you saying C++ should allocate memory to store state information for random number generators by default even if you don’t use them? How would that work with multi threading? How would that work with different generators? Store state for all common ones? What about for different outputs like int and float? Do you fully understand what you’re asking?
A very good library (PCG) is already here, so I'm not sure making (yet another?) library is a good solution. Did PCG help in any way so far to improve &lt;random&gt;?
It's a completely deterministic pseudo-RNG. And sizeof(mt19337) is huge.
As a library author, I think the reason for this is when you write a library you become a soft expert in what you're writing, that's really the only way you can write it in the first place. which means that you start using the terminology that nobody else understands, because it already describes precisely what you're trying to explain, which only makes the issue bigger. The real challenge is in becoming an expert enough to write what you need to write, and then forgetting enough of it (or documenting the terminology as you go?) so that in in 6 months you can come back with the perspective of a noob to actually document what you've forgotten.
Yes, and this allows you to use it for a project that doesn't use cmake. It should be made more accessible imo
Someone has to write the paper telling the committee about it. Preferably someone who knows what they are doing, because we mostly know just enough to know that getting random numbers right is hard and getting them wrong is dangerous.
There was a proposal to make random much more convenient: http://www.pcg-random.org/posts/ease-of-use-without-loss-of-power.html And the proposal: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0347r1.html It's from 2016, I don't know though what's the current status
&gt; there is always something missing, like contains in STL containers, trim in STL string, ... and dependencies is my biggest reasons. If I need to add something later on down the line to my own projects, I just do it. I don't need to coordinate with others, or try pushing shit upstream, or forking which would end you up in the exact same spot a when I am to begin with. you just do it.
It is very difficult to interpret, especially regarding what capture groups should capture. The C Standard is better and the C++ Standard is *much* better about clarity of specification.
which paper was that? the one I saw was only for class members
So you're excluding everyone that doesn't use Windows... thanks.
&gt; If c++ can't be taught to new developers it will not be used outside of legacy software. While you didn't directly say it, there's a slight implied meaning here that C++ current'y can't be taught to new developers. In which case, how did any of us learn it in the first place? &gt; c++ should only be usable by experts" attitude is just stupid. That is not my attitude by any means. My attitude is "A proposal who's only motivation is to improve teach-ability will, as a by-product, harm the thing which it aims to make more teachable."
The fact that something is built to work as a system and shipped as such doesn't mean it's monolithic. That would require it be all in one giant library. My stuff is split up into many libraries. But they are all designed to work together from the ground up. And it's a bit of a stretch to conclude that it's bad if it's not a standalone library. Ultimately the sum of the parts counts for a lot. When everything shares the same architectural features, the power you get from that, IMO, is a lot larger than anything you lose from the fact that every piece isn't the ultimate implementation. In fact the ultimate implementation, IMO, is often not all that great because it's created with the problem domain in mind, not with the process of building systems in mind.
Y’all can stop now.
&gt; Are you saying C++ should allocate memory to store state information for random number generators by default even if you don’t use them? There is already one, rand(), it's just that it is useless. I'd expect the compiler to shed any function that is never used in an executable. Also, if it's more than 8 bytes, I'd believe it should be possible to allocate anything beyond 8 bytes at runtime on the first call to the function using some mechanism like a local static state variable. &gt; How would that work with multi threading? I don't know but whatever the solution is, it can't be worse than not having a convenience random function. What's the solution for rand() right now? &gt; How would that work with different generators? A convenience function does not need a choice of generators. &gt; What about for different outputs like int and float? Just need float and double between 0 and 1, that's what a large amount of other languages already offer and what users can use to easily create random numbers within a range by multiplying the random number. It's not crypto perfect, but it's great for most other use cases. &gt; Do you fully understand what you’re asking? I do not understand why C++ committee always picks the most powerful options over the most needed options, even they are not mutually exclusive and could exist side by side. Same for all the functional stuff like transform, copy_if, etc. that need begin and end iterator, even though you'd want to apply the transform function on the whole list most of the time. All the extra hoops and hurdles are useless noise that make code bloated and less readable.
oh wow, it's expanded since the last time I saw it.
How do you suggest handling allocation in a string library without making the same security mistakes that C's string library has, by creating a string size parameter and having the user allocate it themselves? it's pain in the ass, having a user manage each one of their strings especially when there's no real reason they would know the answer to how large the string needs to be anyway. not to mention if that user provided parameter is incorrect, you're REALLY fucked security wise. Seriously, what's the alternative?
Well, I would never depend on software, which will die if not enough donations will be posted.
I'm not sure I understand what you're saying. You want to generate a list of things that are going to be evaluated as part of the literal later? A tuple? How would that be simpler? An example would help a lot.
Well, you, for one, here on reddit a few weeks ago. As I said before, the machinery that the standards committee users to do it's work is far too complex for people like myself to participate in beyond the occasional discussion with a committee member. The time cost is high. The prerequisite knowledge of procedure and format is high. The insider knowledge of who to talk to in order to reduce the time and "procedure and format" cost is high. All around, the cost of interacting with the standards committee is high, and the "The committee only takes input from papers." way of doing things is a direct contributor to those costs. I have no direct suggestions that will address these high costs of participation, just the observation that the costs are there.
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1152r3.html#expr.ass Compound assignments are deprecated.
Compound assignments were on the deprecation radar since R0.
Isn't that the purpose of libcxx-abi? Any idea if/when it'll be fully compatible?
&gt; Jesus... &gt; &gt; Do you know what? I has been using C++ for long as 10 years now and attitudes like you are the cancer of the comunity Thanks, always feels good to be insulted for an opinion. &gt; so you want it to be hard and complex so no one can use it and make you proud that you can? No, that is not what I said, nor can you directly infer this meaning from my words. I'm not saying C++ *should* be a language for experts. I said that it is intended for experts. That's an opinion based on my observations of the way the language is used, and the pitfalls that it has. Got nothing to do with how I think things *should* be, simply how I think things *are*. &gt; Fine, and when all the "experts" retires who will use it? The same kind of person who picked the language up before all the efforts at teachability came to fruition. E.g. people like you, people like me. &gt; And while that can be true a decade ago with things like go, Node or Rust among others pushing so strong it is the wrong call, it is a suicide move Don't understand what you mean here, sorry. Parsing error, I think. ---------------------------------------------------------------------------- All I was trying to say is that proposals motivated, ONLY and EXCLUSIVELY by "lets make X easier to teach", generally result in X being less useful after the modifications in question. Proposals such as "Lets make solving programming task XYZ easier" are fine. And generally enhance teachability at the same time. But "Lets throw a 2D graphics library into the standard that can't actually be used for anything beyond toy projects", which was regularly and nearly exclusively (in my understanding. I could have missed something of course) touted as motivated by teachability to the exclusion of other motivating factors, will harm the language significantly. Not the least reason of which is that it will drastically increase the amount of work needed by the members of the standards committee to keep the feature in question up to date with changes to the underlying language syntax as the language evolves.
Pm me your email please, I'll send you an email
&gt; Many of us remember the BGI, OWL, MFC training wheels None of those are, as far as I can tell, intended to be exclusively "make XYZ easier to teach" things. Something being inherently easier to use, or inherently more powerful/expressive/maintainable for the same quantity of programmer effort does not imply that they were created based on the motivation to make them easier to "teach" than what came before. Those frameworks that you named, as far as I can tell, were simply better than C for the goals they were trying to solve. Just because something is easier to teach to people does not imply that the thing in question is better. On the flipside, something being better doesn't imply that it is easier to teach. My point is that if a proposals only motivation is that it makes X easier to teach, without consideration for other things, then if that proposal is implemented, the thing X will be worse off for the people who already know it, because the act of making it teachable frequently (but not always) requires changes that remove capabilities, or make it cumbersome to use. The main take away should be that if a proposal that makes the language any of 1. easier to use for the same expressive power 2. able to do things that were not previously possible 3. able to be maintained at lower cost than before and so on with similar bullet points while *simultaneously* making the language easier to teach, then please, by all means lets do that. But if the only bulletpoint being considered is: 1. Make it easier to teach Then I think it's a dangerous thing to implement, because it's motivation is suspect, and it's implementation will require changes that aren't motivated by other goals that serve existing experts. Without those existing experts need being considered, even marginally, the likelyhood of harm to their use-case increases. That's all I was trying to get across.
Maybe donate to projects of which you are dependent?
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
I re-read our conversation, and while you indeed bring up a lot of good and intelligent points -- they're all points brought up in committee already, and the consensus didn't agree with you. Even if I agreed with you we work by consensus. I do indeed get input from reddit, but unless you agree to have someone raise your point in committee, it's not quite fair to say "the committee didn't listen to me". And it's not quite fair to say that because you talked to a member they're required to agree with you, or champion your opinion. Committee participation is expensive for me too. It uses up my vacation time and my personal money, and the jet lag is very much being felt right now and tomorrow at work.
&gt; I re-read our conversation, and while you indeed bring up a lot of good and intelligent points -- they're all points brought up in committee already, and the consensus didn't agree with you. Even if I agreed with you we work by consensus. Thank you for re-reading our conversation. However, I wasn't trying to revisit that subject, other than to simply answer your question: &gt; Which committee members did you give your feedback to? ------------------------ &gt; I do indeed get input from reddit, but unless you agree to have someone raise your point in committee, it's not quite fair to say "the committee didn't listen to me". I hope you don't think that I was saying "the committee didn't listen to me.", that's not at all what I was trying to get across. &gt; And it's not quite fair to say that because you talked to a member they're required to agree with you, or champion your opinion. Yes, I agree with you on this point. &gt; Committee participation is expensive for me too. It uses up my vacation time and my personal money, and the jet lag is very much being felt right now and tomorrow at work. Absolutely, and obviously I'm grateful that you're willing to pay those costs, and I personally appreciate the effort you, and the rest of the committee, puts into the work you do. ------------------- The only information I was trying to convey is that the various costs for participating in the C++ language standardization process is so high that I'm not willing to pay it. I identified &gt; The committee only takes input from papers. As a significant (but not exclusive) reason for not being willing to make the investment into further participation. I have no ideas how to improve the situation. I'm only pointing out one of the big reasons why I'm not going to participate. If, somehow, some way, that situation (The committee only takes input from papers) changes, then I suspect the committee will see more participation. More participation may be a good thing, or it may be a bad thing. I'm not the one to judge the pros versus cons.
&gt; Cannot be implemented as an external library But you keep complaining about the lack of a network library...?
To build on this: Consider a system where C++ source code lived in a form of database, instead of files. Each function, and variable, and so on, in this situation could be it's own record in the database. That's one of the various ways the C++ language standard "barely acknowledges that C++ source lives in files". Further, there exist operating systems that behave significantly differently than Windows / Posix as far as filesystem behavior. So to standardize things in a truly cross platform way would require machinery to generically handle all of the possible implementations of a filesystem. And finally, a standardized packaging system would need to somehow address ABI differences between compilers, which is quite unlikely.
He's been running it for free for years now, basically solo. Its basically a job. There comes a point where you can't afford to spend so much time working for free
I think another person was saying "the committee didn't listen" to them. Patches to C++ standard come in the form of papers, and most open source single implementation languages take their patches in terms of source code. I appreciate the bar is high enough to keep out talented contributors, which is regrettable, but C++ is already awash in papers it can't keep up with, and the claims is other languages handling the same work with ease are exaggerated. 200 people with 300 written positions is hard to reconcile, and refusing to meet face to face doesn't make it easier.
Many random number engines just require a couple of bytes of state that could easily be put into a thread local or even global variable. I said this a couple of times now: A simple convenience function neither has to be zero overhead, nor completely flexible. If you have specific requirements, you'll pick a particular, (thread-) local RNG object of a particular type, seed it in a particular way and use a specific method/distribution anyway. But for lots of simple day to day stuff, using a RNG with a small footprint whose state may or may not be shared across different threads (e.g. by just using an atomic) and only uniform distribution is good enough.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;What's up with the '`no_return`' type used as a return type from some of your functions? Are the semantics of returning it equivalent to those of a function returning '`void`' labeled with the '`[[noreturn]]`' attribute?
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;It'd be interesting to see what this would look like after hardening it against external calls to '`pthread_exit`' using the `pthread` managed by '`pthread_joiner_t`,' but your article implies by avoiding to do this that doing so might be hard.
The demonstration using iostreams represents close to the best case scenario for modules. Its written in an old-school style using next to no templating, which really does benefit a lot from modules. However I suspect you may feel disappointed when applying modules to a codebases that spend a significant fraction of their (respective) total compilation times in template instantiation. I feel like a lot of the community has an expectation that modules will somehow cache template instantiations or something between compilations, but as it stands, that isn't the case. Projects leveraging boost, ranges-v3, or even HPX (given their starting to lean into concept emulation to support ranges) will likely see very little benefit.
I was looking forward to contracts :(
HPX has a lot of templates, but there's also a large shared library component. I expect some wins there.
If you want to take a look at how Microsoft developed their calculator, you should check out [its repo on GitHub](https://github.com/Microsoft/calculator).
You're describing Spack
Same history again with C++ package managers, one of the reasons I simply avoid them.
Success after failures is an inspiration for someone.
I feel like if Sutter's metaclasses proposal makes it into the standard your idea would be doable in terms of a library instead of being baked into the language.
yeah
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;The Swift programming language is moving in this direction with [SE-XXXX on 'Function builders'](https://github.com/apple/swift-evolution/blob/9992cf3c11c2d5e0ea20bee98657d93902d5b174/proposals/XXXX-function-builders.md) (discussed in [this Swift Forums thread](https://forums.swift.org/t/function-builders/25167).)
[https://devblogs.microsoft.com/cppblog/vcpkg-2019-06-update/](https://devblogs.microsoft.com/cppblog/vcpkg-2019-06-update/) See the section on \`--overlay-ports\`
Then it shouldn't be surprising that users are being pushed to other languages, if the only influence they have on the committee is by writing formal papers for review.
What's wrong with a single static pointer within the function body? Whatever state it needs could be allocated on first call.
std::valarray was meant to be used for scientific computing and linear algebra as a replacement for fortran arrays, but it was forgotten and unfinished. std::vector name doesn't because it is not a vector in the sense of linear algebra, it is a dynamically allocated array or wrapper around the new operator: new T \[Number of Elements\] .
\&gt; No build system, make it a default one that hides all the complexity of the project but that allows some customization In this case, it seems that CMake fits the bill. I have tested many building systems and IDEs and CMake is the only one that has more adoption and is supported by many IDEs. In addition, it is scalable and can easily use any other library or subproject as a dependency wit add\_subdirectory or its command for donwloading libraries. But unfortunately, many projects and C libraries still use GNU autotools and other building systems. &amp;#x200B; \&gt; A good package manager, including a third party lib is painfull and slow and chances of success are not 100% Well, conan may not be a standard package manager, but it saves the day, it is pretty easy to use and saves lots of compile-time. &amp;#x200B; \&gt; i am going to buy a good book about Rust and give a real try, I've heard a lot about Rust, but it seems to have an even worst compile-time than C++. There are other alternatives to C++ such DLang D-language which has an amazing fast compile-time and ADA spark for embedded systems and safety-critical systems.
I've been wanting to do the same as my first project. How long have you been programming? It looks great for a first project.
There is also Conan package manager that it is easy to use with CMake and uses recipes to download packages from remote repositories. Conan also store the library object-code in its local cache which allows later reuse in other projects saving compile-time.
&gt;global variable Pass. And thread local is just another kind of local so pass on that too.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;I'm hoping that was supposed to be a joke…
Yeah. My rule of thumb is that if I haven’t tested it yet, it probably doesn’t work. I’m usually right too
pip was not in the python standard before python 3.4. It is convenience when it works. And often an SEP otherwise.
Those other languages accept Reddit comments as actionable input?
This article provides a good overview of the operator and how to use it in your code: https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/
No; my understanding is that libcxx-abi is like vcruntime: low-level compiler support tech, mostly EH/RTTI. Library bincompat is inherently impossible between different libraries. It takes all of our skill to keep VS 2015/2017/2019 bincompatible.
Wow! When was random_device fixed?
A lot of single player games also want reproducibility, e.g. so you can share seeds.
It is dangerous and people should be aware that you're doing a read and a store in this case, and that it may have issues if someone else touched the variable between the two operations. Too many people use `volatile` for multithreading and preventing the most common dangerous patterns is good. You should use CAS in those cases. Yes, sometimes there is hardware memory that you will both read and write, but it is probably not as common as people writing bad multithreaded code.
I can think of at least one prominent alternative to C++ that has a habit of doing so, yes. But then, it's not as if I don't see *good* discussion here on /r/cpp that seems to make its way into the C++ committee's own discussions. One notable example is on the 2-D graphics API discussions that have gone on, and it's an example where the Reddit discussion I think significantly improved the final result. I'm hoping that this example represents something we can build on, rather than just an exception to the rule.
That's right, I was thinking of things like AI behavior and randomized damage numbers where as long as the distribution stays the same there isn't a significantly different experience if the exact RNs are different.
What is the community? I want to learn how they do it.
It's not dangerous if you only do `x++` (`x` from the above) in one single interrupt service routine in a single thread, triggered by a hardware timer to keep track of milliseconds. But now that kind of ISR requires 3 lines of code. To me, "people use `volatile` for multithreading, so let's deprecate `volatile`" sounds like "people are using `std::string` for arithmetic, so let's deprecate strings with numbers in them". There will always be people who misuse language features and I believe that people should be educated instead.
They didn't remove it so you can still use it, and I expect by the time it is removed there's a proper template type that will handle your needs in the standard.
I've suggested something like [`std::volatile_value&lt;T&gt;`](https://old.reddit.com/r/cpp/comments/cfk9de/201907_cologne_iso_c_committee_trip_report_the/euahx0j/) in another place in this thread. It doesn't have `++` defined, but it was just a quick snippet to show the idea.
Thats one of the many rambling points I made. I've been waiting on the committee to deliver networking while using ASIO. I've now realised that committee probably shouldn't be tackling networking directly as it doesn't have the resources and maybe applies a level of rigour not required (extensibility hooks, not paying for not used, strict(ish) backwards compatibility. Instead I've suggested that the committee does help and encourage a repository of excellence, along the lines of boost but with less baggage and support for more modular inclusions. Essentially mimicing what the std lib vendors would do nowadays.
Yeah I saw that, I was thinking this could get standardized since it is simple and solves a real problem with volatile.
The STL doesn't specify algorithms for distributions.
Yeah, I didn't realize that post started this thread. I'd be fine with using something like that. It's more typing to declare `volatile int`, but as long as there's no boilerplate after the declaration, it's fine. I really hope C++ won't end up in a situation where a legitimate use case for `volatile` raises a warning without a viable alternative. A viable alternative would have to produce just as efficient assembly, because ISRs need to be as quick as possible.
I think the interesting thing with it is you can have a read-only variable (that you can do now with `const volatile`), but also a write-only variable (that you have no way of doing properly without wrapping). So it will make code more clear and prevent some mistakes. The assembly should be the same, but in the end it's all implementation-defined.
Well, if we want to accommodate read-only and write-only with the hypothetical `std::volatile_value`, there's more work to do, but there are registers/MMIO/stuff that are write-only and not too convenient right now.
Possibly. I'm not familiar enough with the metaclasses syntax to know if it could support this, or how. However, it's features like this that would make metaclasses so powerful, as it would be a library change instead of a core language feature. I can get behind that. And yet ... call me skeptical that metaclasses are ever going to happen. The proposal isn't dead (a new version was just published), but I just can't see this in C++23, and C++26 is pushing it.
Not a lot of work, you can have a template parameter for read/write option and SFINAE will take care of what function you are allowed to call.
That's what I was thinking too, but I don't see this kind of "policy" template parameters a lot in the standard library. Though there are `regex_options`, but that's a constructor argument.
Well that's that or different names, hopefully sanity prevails. Also it might end up being different names for the interface but those are actually aliases for the saner approach in the implementation.
&gt; The committee is practical, not "intellectual" Well, when I look at examples how std::variant is supposed to be used, I have to slightly disagree...
Ok, let me explain in more detail... The one building block I think we need is std::window. It provides a place to draw into, and a mechanism for obtaining window-related events, and it forms the basis for all graphical user interfaces (whether it is a desktop window with all sorts of window decoration, or a top-level, borderless window of the type you'd draw a menu into, or a full-screen window in which you are running a game, or a 'page' on a phone). Why did I add the other types? Because in MMI design there is invariably the ancient question: native, or non-native? Personally I'm perfectly happy with non-native. Thanks to years of web and mobile development, people no longer even recognize native controls, and applications that use them are rare now. Still, people might want to build an application that uses native controls as much as possible, and for those I would provide a mechanism for using them. This is what I intended with the various native controls I mentioned. Note that this is not what Java did; from the beginning, Java was drawing its own (non-native) controls. Java MMIs always feel wrong to me, and it's no wonder that users rejected them. C++ doesn't have to feel wrong; it can directly interface with the platform native controls. On top of that we need a drawing library as well, but to my mind this is actually less urgent to standardize. No matter what choices are made here, it must ultimately be possible to replace the drawing toolkit by something else. People use a multitude of drawing toolkits, for a wide variety of purposes, and they are likely to want to keep doing so. A basic drawing toolkit may be provided for educational purposes and in order to not leave a major gap in capabilities, but it will be with the understanding that for a large number of applications, it won't be used. In particular, I think C++ should not try to standardize 3D drawing (for which we already have OpenGL, Direct3D, Vulkan, and Metal, all of which have their own standards and all of which are developing at a pace that's incompatible with the 3-year updates of C++). It must be possible to use them in an std::window, nothing more.
Why Hunter over e.g. Conan?
[`is_sorted`](https://en.cppreference.com/w/cpp/algorithm/is_sorted) and [`is_partitioned`](https://en.cppreference.com/w/cpp/algorithm/is_partitioned) are both included in the standard library, you don't need Boost for them.
PCG is not particularly fast [notwithstanding the marketing talk], it is of very good quality, though. For gaming, AI, quality is less of an issue, while speed is, so I don't think PCG is particularly interesting for inclusion in the std. There are others, though ...
It seems to me that 'cryptographically secure' is achievable in a std, as the security depends in part on implementation [side-channels], which are linked to hardware.
That's what they intend to do.
That's what I would do, a small state RNG with thread_local Meyers' singletons.
Unless you make it extremely easy to solve 'the' problem by just sticking to the rule[s]. People can obviously do what they want, how can it be hard to explain?
&gt; That all said, if we can get traction for a set of project conventions like layout, getting tool vendors to adopt it organically is more likely. This. &gt; I personally think standardizing project descriptions in a way that makes integration and reuse easier will get us more bang. pkg-config only for build, not consume. I think both should be pursued.
&gt; We are interested in implicit builds of modules ... I see a parallel [but it's an ISO/vendor problem], but that's not what I [or others] was thinking of.
&gt; ... that anything we would recommend would be unlikely to work for some use cases ... This transpiles to: "... something we could recommend would work for the majority of cases ...". That would be a pretty good result! &gt; To paraphrase one participant, "I'm strongly opposed to this ... Was he called Donald? Coz, otherwise I don't see why one man should stop progress. Another option could have been what this magical lay-out entails, maybe it's even good and it would have killed his argument.
Hi Nice project. If its possible for you, can you tell me from where did you learn qt?
+1 :D
Thank you! I've been using python in small, personal projects for a few months now, and I started learning C++ this week.
Thanks, I used these tutorials: https://www.youtube.com/playlist?list=PLS1QulWo1RIZiBcTr5urECberTITj7gjA
It would be nice if posts that references old material is marked with ICMY (In Case You Missed) and/or the year of its publication (2011) in the title.
https://gcc.gnu.org/r271740 on trunk and the simpler https://gcc.gnu.org/r272748 on gcc-9-branch (post 9.1 release). There's no GPL code visible at those links unless you follow further links to the diffs.
Cool, thanks!
I guess I should say it's fixed for mingw-w64 in general, and for mingw.org only for processors with RDRAND. But I assume that covers most users.
&gt;it either should be available if machine and system allows it, or not available, fail to compile OK, I see what you mean. WG21 could add a feature test macro indicating the existence of a true random device. You can then use the presence of that macro to tell you it works properly. That doesn't help for old releases of GCC but nothing we do now can help them anyway, we can't change what they do now.
&gt; Other languages don't specify a standard, they write a patch for the reference compiler. I see this as one of biggest issues of C++. In most cases some feature is first designed and only then implemented. Even more, three major compilers have different sets of experimental features. Other languages tend to first ship feature as experimental for the whole community, test them thoroughly in the wild that way and only then stabilize.
&gt; - Lack of `std::is_trivially_relocatable` I don't think it was aimed at C++20. I believe, and might be wrong, that Arthur's plan was to push the paper with no specific standard version as the target.
`std::valarray` can be useful if you have to port NumPy Python code to C++. As it has a similar interface/functions as the NumPy array type.
&gt; To paraphrase one participant, "I'm strongly opposed to this, not because I don't think it would be useful for a lot of people, but because my organization already has a proscribed project layout, and I'm almost certain whatever the C++ committee comes up with would contradict that." I see that point, but I fail to see the problem when an existing system is not compatible with a certain default layout? I mean it's not like that would mean that all the other layouts would suddenly fail to compile... Are people afraid that they would not be able to use shiny new things? So rather not let have all the others have it?
It may be harder to implement in C++ but I think usability should be a priority over performance for string formatters. I'm not saying it should be slow but where you use string formatters you're usually okay to take a slight penalty hit anyways. In performance critical code you're already using something else than ostringstream or friends or not format strings at all. Anyways, I'm happy to see std::format as it's a big step forward however I'd be happier if it offered string interpolation. I think I'll be okay :) I'm looking forward to Vittorio's proposal going forward.
std::format has code inside string literals: position or formatting All string interpolation does compared to std::format is it takes out a level of indirection.
No need in vcpkg when we have Conan.
True, it's more work in case of a core language feature but all that kind of work has already gone in for raw literals, sprintf checks and so on. I don't think it'd be a real issue. Give string interpolation a try in C#, Python or other languages. It's not a game changer but it does make formatting easier.
&gt;bigcorps have deep pockets for maintenance vcpkg is in a not very well-maintained stage either, it looks like there's 1-2 people part-time working on it, and they're massively overwhelmed with keeping port files working and up-to-date (960 open issues). I hope this will improve for the better. Meanwhile it would be sad to see Hunter die, I've never used it but I've known it as a great option for managing dependendies. Probably, though, Conan is the way to go and the community will converge towards it?
The best programmers have more failed tries than the total tries of others.
It's because of all the warm beer they drink across the pond...
Metaclasses depend on reflection being standardized, so there's no way we'll get metaclasses before 26 and 26 means fulfilling the optimistic prediction for both proposals.
I've never heard of this André W. Sutton character, and I don't know why he has such a problem with bad ideas.
!removehelp
If you can't figure this out on your own, you're gonna have a hard time buddy.
He cannot and doesn't read either, so all is lost.
Please explain, what exactly the problem of having a global variable as an implementation detail would be in this case exactly (and please be specific to the use case at hand). If you want distinct random numbers across your program you need global state anyway. Be that a global (P)RNG, the clock, /dev/random... Again, if you have very specific requirements, such as reproducability, max RNG performance that scales perfectly with the number of cores or cryptographic security, you'll want to have full control over your RNG, but very often, an instance of `std::random_device` is good enough and so would a `get_random_number(2, 10)` function that is - in one way or another - backed by global state (but more efficient than std::random_device please).
I’d watch WG21.link for relevant papers. To play with my implementation I’d have to know you personally.
Better sent to r/cpp_questions
You already do in many ways, e.g. the tz db.
sorry but i just started programmin on c++, so i still cannot reconignize errors
&gt; float or double between 0 and 1. It's what I need most of the time Is it? Is it really? Nothing more? You're not going to perform any transformation on the number you get? I thought most of the time you'd need a number between 0 and N. Most would do `rand() % N` and that would be [incorrect](https://youtu.be/LDPMpc-ENqY?t=234). Or with a range of [0.0, 1.0], you would multiply by N and that may be of questionaly uniformity. Hence the better (but less straightforward) facilities in `&lt;random&gt;` protecting programmers from themselves. Just for fun I went to the JavaScript page you linked and here the demonstrated way to generate a number between [0, N[: function getRandomInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive } Suddenly, it's not so simple anymore even in JavaScript when you need anything other than [0.0, 1.0]. How many JavaScript programmers do you think will do the right thing as opposed to just `Math.random() * N`? Personally, I'm fine with the "simple" [0.0, 1.0] case being "complicated" in C++ given that, to me, it's actually extremely rare that that's exactly the range I need.
&gt; The reality is, none of the rest of your code needs to know about members() This is solvable using the attorney-client design pattern. &gt; templates are extremely slow to instantiate once you go recursive &gt; ... &gt;A better approach is to implement serialisation as free functions Templating isn't a problem per-se and your solution results in needing to write the free functions templated code can generate automatically. Besides, I don't see the need for recursive templates in this at all, so that's not really a good reason to dismiss templating here. I'm not a fan of your presented solution here, it has the disadvantage of a lot of code writing (resulting in larger surface area for bugs and more painful long term maintainability), [and your solution is based on a giant macro](https://github.com/20k/clientservernetworking/blob/0061a1db226b76572c7d83f560029f002c4234c2/serialisable.hpp) resulting in the same code as a template would, and your macro also feeds into a template later on (do_serialize is both a macro and a template from quickly inspecting your solution). I somehow doubt this solution is any faster than templating (with forward declaring, similarly to how you set up your macro), as it's doing the exact same thing, instantiating a huge block of code at every instance. With the disadvantages of not being able to collapse for the same type. You're actually duplicating more than templating would and leaking implementation details such as generic variables into global (like id_counter) in the process, though that one is easily solvable but seeing you made a point about leaking things earlier I figured it was appropriate to point out.
I very much prefer to code against a specific standard instead of littering my code with #ifdefs, but I have to admit, feature macros are useful when using long-tail features that get implemented very late by a specific toolchain (e.g. parallel algorithms)
&gt; I’m usually right too But your code is usually wrong at that point. Does that make you more right or wrong?
Seems to be? std::map doesn't use contiguous memory, at least unless you DIY the allocator.. https://onlinegdb.com/r1cSvZmzr Doesn't break with inserts at least.
"Tab2" &gt; Do math in your head!
Pure cmake implementation. This means you need no other external dependencies except cmake and a compiler. VERY handy when running a windows buld machine
You want num != 0, since you want the loop to run until to put in 0
I have the impression that Microsoft is notoriously niggard in their support for c++ OS projects. The quality of the GSL also left much to be desired (might have improved by now). With vcpkg, a lot of those issues are about adding new ports, but still, it is certainly not a showcase for how well big companies can maintain their package management systems.
I could tell it from [here](https://en.cppreference.com/w/cpp/container/map/insert) as well. "No iterators or references are invalidated". and end() does not obtain any element.
Ransom software was a great idea.
Alternatively take a look at SpeedCrunch ([Website](https://speedcrunch.org/), [Repository](https://bitbucket.org/heldercorreia/speedcrunch/src/master/)), my favorite calculator. Also built with Qt, so at least the GUI code should be familiar to OP.
I'm feelin retarded. Thanks bro
&gt;Seems to be? You can’t rely on trying this out on a single (or even a few) specific environment and test case. Either the library guarantees this or it doesn’t.
So GCC additionally serialises the state size after the state? That would seem unnecessary to me, and possibly against the standard. That said, the standard doesn't require the stored state to be in the same *order* between compilers (let alone completely compatible) as far as I know, so if you need that we either need a stricter standard or you should implement it yourself.
great job. especially on the algorithm for parsing the expression. this is definitely not the easiest shit. you can be proud of yourself.
 &gt; Suddenly, it's not so simple anymore even in JavaScript when you need anything other than [0.0, 1.0]. "random() * N" is perfectly fine to map [0, 1] to [0, N) and "min + random() * (max - min)" isn't even half as bad as whatever you have to do in C++ right now. Whenever you need fine grained control over and do the correct thing, then you can fallback to the more ellaborate methods. &gt; Or with a range of [0.0, 1.0], you would multiply by N and that may be of questionable uniformity as well. Perfectly fine for anything I ever had to do and I do a lot of stuff with random numbers in computer graphics. &gt; Hence the better (but less straightforward) facilities in &lt;random&gt; protecting programmers from themselves. That argument really doesn't work for C++. This isn't the language that does anything at all to protect developers from hurting themselves. It just inconveniences developers at the wrong moments. Also, if you insist in creating numbers in a range other than [0, 1), we might as well add a random(min, max) function. Problem solved. Thanks for this suggestion, I would like to have that too along with the [0, 1) one, please.
Do you want your loop to run while num is 0 or while it is not 0? Also I recommend asking such questions in r/learnprogramming or r/cpp_questions, etc.
Yeah, this is how you get these bugs that only happens occasionally and are fun to troubleshoot.
Similarly for other modifying operations (except swap), only iterators to removed elements are invalidated. So is safe modulo bugs.
Hmm, ok. So far I have not seen the Python dependency as a big obstacle. In fact, I'd rather see the whole build system being Python-based (lMeson?) rather than having its user learn yet another cryptic DSL.
Make sure you don't use presence of the header as 'the feature is here'. We always have &lt;execution&gt; but in C++14 mode it behaves as if it is empty.
I wasn't aware of the attribute! :o The type's role is to destroy the coroutine's frame after co_return. Actually the name is from `no_return_consideration`, and at this point indeed its name is misleading... I will change the name soon. Thanks!
MSVC++ additionally guarantees that end() is preserved. For now at least.
What's another good fast library? I assumed pcg was fast
It looks like a design review in 2017 liked it but asked for some changes to the `random_generator` constructors, so that a factory function would be used to get a properly seeded generator.
I couldn't find a good way to handle the case. :(
Oh... makes sense. Do you know if that's the same for gcc or clang?
As far as I know it is. That's what the blurb in the standard about &lt;optional&gt; is trying to say -- that you need to include the header and check the macro.
libstdc++ shipped with a stub `&lt;regex&gt;` for a long time.
Thanks! I found the algorithm on StackOverflow, but I had to modify it a lot (it didn't have brackets, it could only use integers etc)
That's the intention, and the libstdc++ behaviour is a bug: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60441 If you care about this, please consider helping to fix the bug! It's not necessary to sign a copyright assignment form and contribute code, just describing where the bug is and suggestion (in English) how to fix it would be very valuable. Otherwise it will continue to wait for somebody to have the bandwidth to look into it.
From the PCG blog [Some (More) C++ PRNG Implementations](http://www.pcg-random.org/posts/some-prng-implementations.html), jsf, sfc, splitmix or lehmer. There are std-compliant implementations posted by the author of PCG. Then there is a newcomer, [`wyhash`](https://github.com/wangyi-fudan/wyhash), you'll have to write you're own class, though [which is trivial with the examples/the above].
Yes. libstdc++: https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/execution#L30 libc++: https://github.com/llvm/llvm-project/blob/910323e6676f813b28d1320b0d08ece270ee977d/libcxx/include/execution#L15
&gt; ... it looks like there's 1-2 people part-time working on it ... There are certainly a few more, and due to the nature of 'having a job' implying a 40 hr working week or so, it might look to you that it's part-time [f.e. over the weekend not much is going on].
&gt;So GCC additionally serialises the state size after the state? That would seem unnecessary to me, and possibly against the standard. I thought so too but after looking a bit closer I found out it's actually a counter. GCC doesn't update the state each time a number is generated as described by the standard. Instead it increments a counter and when it reaches the size of the state it updates the whole state all at once. [If you generate a random number you'll see that GCC's state is totally different while Clang's state has just shifted one position and updated the last value.](https://godbolt.org/z/FpePSH) This is probably an optimization, it doesn't change what numbers are generated, but it means that there is no longer a straight forward way to serialize the state as it is described by the standard. &gt;That said, the standard doesn't require the stored state to be in the same *order* between compilers (let alone completely compatible) as far as I know, so if you need that we either need a stricter standard or you should implement it yourself. The standard describes a *transition algorithm* (how to go from one state to the next) and a *textual representation* (what the output of &lt;&lt; should be). [http://eel.is/c++draft/rand.eng.mers#5](http://eel.is/c++draft/rand.eng.mers#5) &gt;*"The textual representation of xᵢ consists of the values of Xᵢ₋ₙ , . . . , Xᵢ₋₁ , in that order."* When I thought the last number in GCC's output was simply the size of the state I was thinking that maybe "*consists"* is too weak and it was allowed to put additional values at the front or back of the sequence, but now I think it's pretty clear GCC's implementation is not conformant.
I wouldn't necessarily say this "improves" multi-platform code, but maybe say "allows for". Ideally we wouldn't need any preprocessor macros ~~to write multi-platform code ~~ at all.
&gt; ... it is certainly not a showcase for how well big companies can maintain their package management systems. I would not say it is 'in maintenance mode' just yet, there's still quite a bit of 1 baby-step forward and 2 back going on.
https://en.cppreference.com/w/cpp/container "The past-the-end iterator deserves particular mention. In general this iterator is invalidated as though it were a normal iterator to a non-erased element." Also demonstrated on this page: std::map never invalidates non-erased iterators due to insertions or erasures. Thus, map::end is in fact currently not invalidated. This is interesting, but I hope you're not intending to _use_ that information somehow (besides maybe to assure yourself that something works like you think). It feels very brittle to me.
As a beginner, I love this. Also, I regularly see C++ experts debating basic topics, so it might be useful for everyone.
Why not? end() is not constexpr, and I have many comparisons against it in a critical area in the code. Why do you think it is brittle?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/cgcdz5/currently_reading_c_primer_are_there_any_books/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; which is IMO a better bet than a number of 1-horse projects. Agreed. I also believe that vcpkg is more important to Micorsoft than the gsl (which I believe is only maintained the spare-time of the current maintainer).
&gt; #if defined __has_include &amp;&amp; __has_include(&lt;charconv&gt;) &gt; # define has_charconv 1 &gt; # include &lt;charconv&gt; &gt; #endif I guess the `defined __has_include` part is aimed to deal with old compilers that don't support `__has_include`, but this doesn't work, because the expression `defined __has_include &amp;&amp; __has_include(&lt;charconv&gt;)` is parsed as a whole, and for compilers that don't support `__has_include`, it is a syntactically invalid expression.
Have you measured it? std::map is not the fastest container per se, constructing end() can be negligible comparing to find().
Find a large open-source project written in C++ and have a pull-request accepted.
The alternative, as mentioned, is stateful allocators like the [std::pmr library](https://en.cppreference.com/w/cpp/memory/memory_resource) added to c++17. You'd have a class with your custom allocation strategy and inherit from std::pmr::memory_resource overriding the allocate()/deallocate() method pairs and pass that instance over to the constructor of your string class. Most std containers already have a pmr variant in the std::pmr namespace (eg. std::pmr::string, std::pmr::vector etc) This would've been *great* about 10-15 years earlier when we were looking for solutions for this and other shortcomings mentioned in this thread. In the meanwhile however, most companies I've worked with had built their own container library, with their own unique feature set tailored to their needs, tested and battle hardened over the years, so there's little reason to switch over now.
I wish Spack supported Windows. Instead I'm reimplementing it all in Conan. Same way you can't get Guix running on &lt;not Linux&gt;. Seriously! Cross-platform support is a feature, not a bug!
But will it blend
Isn't this related to default and move construction throwing? I have a vague memory there's a connection between these, and that msvc choose one and gcc/clang chose the other.
Hi, you wrote alot about making constexpr more powerful. I see possibilities for writing malicious code that will kick in while compiling. What means this for services like CompilerExplorer? Or do I miss something? My assumption is that currently I can safely compile somebodies code and only execute it in a sandbox. But I‘m a big fan of the progress of cpp and the community behind it! ;-)
Will the basics track be recorded? For beginners who cannot attend the conference?
A good example is anything that relies on scope (/u/beached mentioned std::lock_guard): { scope_based_thing(); // destroyed at end of expression ... } Where you actually want: { const auto scoped_thing = scope_based_thing(); ... } // destroyed here (at end of scope)
This is excellent trolling.
Doesn’t that require all elements are same type?
What's wrong with `std::lerp`? It's a common shorthand name for linear interpolation.
[ ] from scratch [ ] with Qt Choose one.
This isn't purely a serialization scheme, its a networking + rpc library that handles a bunch of other stuff, hence the giant macro The main advantage its that while the macro creates a lot of code, you rarely need to recompile the serialization file. The amount of code however isn't what makes compiling slow - its instantiating templates, which this avoids by keeping it all in one file The point here is about having a member function based serialization scheme vs a free function based scheme, the latter allows you to stuff everything into one file and hide it from the rest of your code, whereas with a member function scheme your implementation is always available to the rest of the code Things like id_counter are mostly irrelevant, its used for compressing keys because the format is json, so instead of using #variable, it uses an int. There's not much difference here in a free function scheme vs a member function scheme
The problem is including it in the standard. Lerp is a very simple function. I use it frequently and writing it take only 3 lines of code including the newlines after curly braces. What's the point of adding trivial functions in the standard. Next time someone will come up with std::ease, then std::bezier.
How do you feel about `std::min`/`std::max`/`std::abs`?
The problem with the GSL is AFAICS that some of it is good advice and then another part is targeted at CS-graduates that didn't pay much attention when pointers were discussed.
&gt; Please don't add this very useful and simple function that I find myself frequently rewriting in the Standard. Make life harder for me. vOv
It's actually not trivial to write correctly, because of floating point and overflow. The paper that added it, [\[P0811\]](https://wg21.link/p0811r3) talks about maintaining desirable mathematical properties. In short, it's tricky to get lerp right.
I want XorShifts in my standard. They're so simple, they could be even `constexpr`.
They are all garbage. Majority of STL is garbage. I write my min max using `#define` and `abs()` in 3 loc.
And if you follow standard libraries mailing lists, you might notice that standard implementers think that getting a correct implementation might be even more subtle than the one proposed in the original paper.
I've just updated the article, I hope its better. But... it looks like has\_include is not as reliable for feature testing as I initially expected ;/
Not sure what you mean, but you can obviously output graphviz or plantuml from your C++ and visualize it elsewhere.
Maybe I am just dumb (highly probable 😂) but I find VSCode so frustrating for C++. Not sure what I’m doing wrong but it seems every time I use it for C++ it has some random issue. What do you guys and girls do to make VSCode so nice for doing C++? Getting it to build is mostly fine but I never get debugging working for more than a day when it seems to stop working randomly. I’m sure it is my fault as others seem to have no issues but I’m not sure what I’m doing wrong. Is it because I’m on macOS? What extensions are you using? What is your setup? Do you have a complete example project folder you can share that I can try out? I’ve tried with the Xcode supplied clang. LLVM from Homebrew. GCC from Homebrew etc. I feel like an idiot but every other editor works fine but I seem to have some kind of personality clash with VSCode 😳
I agree with the "no-add-bloat" part but your comments make me fear you're too much of a purist. I'd like a stable and small CPP myself.
good point! the preprocessor won't reject the rest of the check when \_\_has\_include is not defined. Updated the article.
Do you like evaluating your arguments twice?
If writing 3 lines is making life hard for you, then use python and Javascript.
You need to be careful with that, you can accidentally evaluate arguments twice, can be expensive.
The post right after this one is complaining that a simple and useful function ISN'T in the standard lol
Amateur. I write my `min` and `max` in `asm` statements defined directly in the compiler command line invocation.
I would hope so. Not sure how many beginners can afford travel and admission.
https://vtk.org/
could you, by any chance, share the code of your lerp function ?
" What is C++ " &amp;#x200B; Can't wait for that
It's pretty much useful only for avoiding compiler errors for trying to include a nonexistent thing.
Reproducibility also makes testing easier.
Developers that don't want to pay for their tooling are the ones at fault here.
C++ &amp; Qt are very fun to work with, both at work and for hobby projects :) Good choice.
I really wouldn't try. Like there is no reason to not use Python or js if this is for typical data. That said I have liked Pangolin as an opengl wrapper, but as I grow my code I'm starting to regret not serializing all of the stuff I need to render and sending to a websocket three.js server
Probably this would be easier to answer: "What C++ is not."
&gt;Is web\_view required to appear as a separate application, or can it launch a tab in the user's preferred browser? &amp;#x200B; There's nothing in the current wording that aims to constrain this kind of aspect of the implementation. &amp;#x200B; &gt;The latter seems like it should be simpler, both to implement &amp;#x200B; Given that the current proposal supports registration of custom URI schemes and JS evaluation (to support both data push and pull), this is easy to support using the embedding APIs, but might be harder to implement in the context of an existing browser tab (e.g., it might require an actual browser plugin in addition to the client library). In short, it might not actually be easier to implement - but I've only tried using the embedding APIs, do I certainly don't know for sure. &amp;#x200B; &gt;and in terms of user expectation. It's also the approach taken by an increasing number of cross platform desktop applications. &amp;#x200B; As a user, I find this behavior quite annoying - although maybe just because I have too many open tabs ;) - I prefer that applications act like applications.
I suspect that the handling overflows and such will make it slower in the common case.
It doesn't need to require that.
Novices. I built my own coprocessor to handle `min`, `max`, and `abs`.
I haven't used it personally, but QtDataVisualization might be worth checking out. You still need to comply with the requirements of LGPL3 though.
Yes, but even in non-ancient history, if you `#include &lt;optional&gt;` without `-std=c++17` it compiles fine, but declares nothing. That means `__has_include(&lt;optional&gt;)` is true, but you can't use `std::optional` unless `__cpp_lib_optional` is defined.
It's not from scratch unless you write your own display driver to render the GUI directly to the screen. /s
Yes, you may have branches or other extra instructions. But a function in the standard library should always "do the right thing" even at the expense of speed (at least if its O(1) cost). Prefer users accidentally stumbling into the pit of correctness. Take the case of `midpoint` / `average`. The obvious way to write this is: `(a + b) / 2`. The correct way to write this (for positive integers) is `a + (b - a) / 2`. The latter avoids overflows at the [cost of a couple additional instructions](https://godbolt.org/z/dilE70). This is the cause of the famous Java binary search bug: for large collections, `(a + b) / 2` overflowed. The common case for collections is that they're small enough that the overflow won't happen. If you decide that you want a faster `lerp` without these mathematical properties, you can always write it. If this faster `lerp` was standardized and you wanted one with these mathematical properties, good luck getting the subtle behaviour correct.
Yes, exactly. We allocate *end(), they stash *end() in the container body itself. But people are angry about throwing moves and default construction, and the argument for absolute iterator stability is less for the associative containers than it is for list. But it's a scary change to make even in an ABI broken universe because we've provided that guarantee for so long.
Your updated example using `__cpp_lib_optional` is still wrong, because the `&lt;experimental/optional&gt;` header defines a different macro, so if you included that header then `__cpp_lib_experimental_optional` will be defined, **not** `__cpp_lib_optional`. The macro `__cpp_lib_optional` tells you that `std::optional` is available, and `std::experimental::optional` is not `std::optional`.
Where I'm hoping C++ 23 goes next is that `std::format` gains the ability to constexpr output gather buffer lists with holes in for where the formatted items get rendered into text at runtime. One then simply supplies the gather buffer lists to ASIO, LLFIO, Ranges i/o, or whatever modern i/o engine we end up choosing. (In case one thinks that buffering is needed here, `pwritev()` on Linux costs about 100 nanoseconds. We really need no buffering any more) This way we reuse most of `std::format`, yet also get ideal efficient i/o, no memory copying through user-side buffers.
Matplotlibcpp is really handy wrapper around matplotlib
* Boost libraries which are one of the most used C++ libraries and the source of many features of C++ news standard. C++ standard library alone is not helpful and pretty limited. * Use building systems - for any large project, manual compilation is not viable. So, the most used building systems are CMake and GNU autotools on Linux. But CMake is becoming the most used one. * Frameworks: they provide support and libraries for building full feature applications. The most used application frameworks are QT; WxWidgets; MFC - Microsoft Foundation Classes (Windows only) and so on. For servers there is the Boost ASIO framework. * Domain Knowledge which is industry specific: Game developers need to know about: computer graphics; opengl; game engines; game-sepecific design patterns such as data-driven design and entity component system ...; System programmers need to know about: operating systems C APIs; device driver development; POSIX API's; Win32 API ... Embedded Systems Developers need knowledge about: digital electronics; analog electronics; embedded systems; computer architecture; operating systems concepts; control systems; POSIX ... Servers developers: TCP/IP concepts; TCP/IP stack; BSD Sockets; Windows Sockets; Network frameworks such as Boost ASIO; concurrency, threads, deadlocks .... HPC - High Performance Computing: SIMD; GPU; OpenCL; OpenMP; MPI; computer architecture; algorithm; CPU caches; profiling tools ... What is used depends on the industry and field, however IMO, the following computer science subjects are very valuable no only for C++, but also for any other programming language. * Operating Systems Concepts * Unix/Posix system programming * TCP/IP BSD Sockets * Computer Architecture: Specially CPU caches as making them happy is essential for getting the maximum possible performance from the CPU.
that's why I'm gonna use either vcpkg or conan, and even ready to pay them. Supported\sold by big corps, not a couple of enthisuasts.
More importantly, why is there no function to find the executable's directory (useful), but instead a function to find the "current directory" (of very dubious value)?
You can also do: ``` #if !defined __has_include # define __has_include(x) 0 #endif ``` and then you can just use it without checking after that: ``` #if __has_include(&lt;foo&gt;) ... ```
Well, first you find a rock, and sharpen it by banging it with another rock. Then use the sharp rock to cut a branch on a tree and some bark and vines as well. Use the vines and bark to tie the sharp rock to the short branch. Call this an axe. It makes future cutting easier. Use the axe to help gather dry wood for burning. Find some mud and clay down by the river. Build a furnace. Find bits of ore down by the river. Turn it into iron. (https://www.youtube.com/channel/UCAL3JXZSzSm8AlZyD3nQdBA) ... Build a computer. ... Write a programming language. Call it C++. ... Write a calculator app.
Yeah I could do with a laugh.
Because `current_directory` exposes OS functionality, in the form of `getcwd` and whatever the Windows equivalent is. It's relevant to the filesystem library because it gives you the base that relative paths are relative to. If you want to know the executable's directory, that's trivial once you have its path (use `parent_path()`). Getting the path of the executable is not relevant to the filesystem library. See [P1275R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1275r0.html) for a proposal to make `argv[0]` available globally (in a modern C++ manner) which would then be usable with `path::parent_path()`.
Where do you find that information? I couldn't find anything with Google
&gt;More importantly, why is there no function to find the executable's directory (useful), but instead a function to find the "current directory" (of very dubious value)? If you're referring to current_path, then it's because reading paths relative to the working directory is standard in most systems. Running "foo/prog file.png" in /home/ usually means that you want to use /home/file.png and not /home/foo/file.png.
&gt;As a result, developers have to refactor their code to make them ‘testable’. Examples of code that needs to change include: &gt; &gt;Singleton classes &gt; &gt;Calls to static members &gt; &gt;Calls to non-virtual members &gt; &gt;Free C-Style functions &gt; &gt;Composite aggregation classes &gt; &gt;Objects that are instantiated in the code being tested &gt; &gt;Objects that are not passed to the method So any code that don't virtualize *everything* is not testable? Also, a mock is also quite special in a sense. If the mocked thing is not in the public API of the thing you are testing, then I think the mindset is wrong. Unit testing is about ensuring the a given component is behaving correctly. You don't ensure an implementation. Don't test implementation details. If the thing you're trying to mock is present in the public API but not virtualized, then maybe it's a tool problem, in the sense that you should be able to mock public non virtual functions, which there are frameworks to do that... ...or maybe you shouldn't mock it, and simply treat it as a value influencing the behaviour of your component. Then what you should test is the behaviour of your component according to that value. A separated test can be done to test behaviour of that value itself.
&gt;My main comment here is that we seem to have gotten in an uncomfortable situation where it seems like we are being forced to include std::web\_view in order to avoid P0267. I just wish we could evaluate the merits std::web\_view alone in isolation without considering the effects on/due to P0267. &amp;#x200B; I believe that I understand what you're saying, but I don't think that's the most-accurate way to look at what's going on. We don't have web\_view because P0267 is scary, we have web\_view (and P1062 before it) because there is a high-level desire to provide facilities for graphics (which I believe is more-accurately stated as a desire to provide facilities for modern user interaction), and many of us agree that a web\_view-like approach is, in the context of our technology ecosystem, fundamentally, the right way to address the underlying use cases. Web technology is an important slice of present user-interface development, and is a growing one. It's true that P0267 is large and web\_view is small, as measured by the size of the interface, and that contrast will be a part of people's thinking, but the proposal is being evaluated on its own merits as a way to address the underlying use cases. Work on P0267 is continuing, and the SG13 study group explicitly voted to consider these approaches as non-conflicting. &amp;#x200B; Another aspect of this, which I think is relevant, is that web technology is evolving. One way in which it is evolving is that we're seeing technologies like WebAssembly increasingly drive application development, and since you can compile C++ to WebAssembly, I can envision a future in which, although web technologies are leveraged, the overall web ecosystem will be more C++-driven than it may be today. Regardless, web content engines are provided as a system service on many platforms, and available from numerous open source and commercial projects, and providing a standardized interface across similar system APIs is a traditional role for standard libraries.
Sorry for the dumb question, but I'm not quite getting the overall flow of what to do with the cmake snippet you've provided. Is it being run separately from another cmake project's build?
All of these topics look awesome. I hope they record them!
https://wg21.link/p0347/issue
Google "C++ interview questions".
Yes, the code snippet you configure / compile separately. This would be equivalent to running \`vcpkg install...\` or \`conan install ...\`. [https://bugreports.qt.io/browse/QTBUG-75578](https://bugreports.qt.io/browse/QTBUG-75578) has more information about the use case.
The API comes from Boost.Filesystem, so it includes (most) things you can do with Boost and excludes (most) things you can't do with Boost. Most changes to the API that were suggested were evaluated by considering whether there had ever been requests to add it to Boost. Since the primary API designer opened the Trac ticket himself, and never followed it up, it might not be something that was asked for often.
VTK or Qt Chart or dearimgui?
So, some background: My coworker (Clark Nelson, former PL22.16 President) recently retired, and I inherited 2 large drawers full of old committee papers. I've only started going through them, but of the bound copies of the standard this appears to be the oldest! I'm attempting to scan as many of his files as I can, though it is likely going to be a LONG effort. This is the first that I've scanned, and thought it might be interested to the community!
What it would be better to think about on backend is how it is going to scale: how many concurrent requests your application can handle in a single thread, what would happen when you hit hardware limit, how it is going to scale across multiple cores, how it is going to synchronize across threads or can it avoid synchronization at all. Layer your backend according to your scaling plan and you will be good. There is also rarely a need to create another layer on top of a layer. If MySQL C++ connector is a layer already - just use it, if Pistache API is a layer already - just use it. You can always create another layer later, or look into another library that does a layer, but it has to have a purpose like database-agnostic layer. Sometimes people do layers to bridge C and C++, but you seem to use C++ libraries. If layer doesn't serve any purpose then, usually, it can be removed as overhead.
This is great. Thank you so much for doing this - maybe you could crowdfund the effort and give them to some company specialized in scanning? I would chime in.
&gt; you rarely need to recompile the serialization file Which would be the same situation with a forward declared template. My point isn't which approach is better, it's just a tad weird to hammer on the OP for using templates while using macros that expand and are instantiated like templates yourself. Using templates in the same way you use macros (forward declaring them, isolating them to TU's that actually need them) would result in the same code size in the binary. The "recursive template compile cost" argument was weird as well as I didn't see recursive templating in OP's article, unless I missed it when glancing over it.
Unfortunately, I have to check through all the files anyway to make sure there isn't anything that I'm not allowed to share anyway, so having a 3rd party do it is likely not permissible. I've got a nice big commercial scanner at the office, so the effort on a per-file basis isn't too much fortunately.
I really love that \`template\` was introduced for this, but I'd rather have \`for template\`, just to be more consistent with \`if constexpr\`
How is a library function bloat? Either use it or don't, it doesn't change things for you. I thought you were going to be complaining about concepts, coroutines or the (just pulled) contracts, or one of the myriad language features that are in C++20. I simply don't understand how you feel a library routine that you don't have to use is bloat.
As a programmer I just pick and choose. However, I fear that level of adoption will start to vary ludicrously between different compilers, making code in effect unportable. Which is a big problem in my world of scientific codes that have few intrinsic platform dependencies, so are expected to run on Intel, AMD, IBM, ARM processors, and Intel/gcc/clang/IBM/whatever compilers.
`argv[0]` is not obliged to contain the *full* path (and, strictly speaking, not obliged to contain any path at all).
So std::lerp is your example of moving too fast and adding too much bloat? I don't think one example is making a strong argument when you're talking about bloat in the language as a whole. Would you care to give a more comprehensive analysis on larger sample of changes and explain why you consider them bloat? Beyond that, I don't think any of this can be discussed without first establishing what exactly should go on the standard in the first place and why. I expect the committee has already established such guidelines so I would start there, but I don't know for sure. Again from my perspective you haven't provided any sort of constructive argument on language direction. You just don't like std::lerp and even then your arguments against std::lerp seem to be immediately disproven in the comments.
No, LWG didn't have time to see everything in its queue for C++20, so anything aimed at a TS is still in the backlog. I will publish another update based on feedback received from /u/jwakely
Interesting note, the draft N0485 (from May 1994) is significantly bigger in that the stack of papers was too large to go through my scanner tray in 1 pass!
That's right. It doesn't make it any more relevant to the filesystem library though.
Couldn't we just reuse constexpr/consteval keyword to force initializer to be compile time? E.g.: myclass obj = consteval(myclass{a, b}); &amp;#x200B; consteval here would be an operator forcing compile time evaluation of expression. This way it would be usable in more scenarios, not just to fix "static initialization order fiasco".
I don't know why vcpkg receives too much attention. It is way less capable than Conan. vcpkg cannot use private repositories on local Network; cannot specify the library version to use; cannot cache compilation intermediate files from libraries for reducing compile-time in other projects and for uploading a package, it is necessary to make a pull request of a vcpkg recipe. Conan can also deal with libraries packaged with Makefile; GNU autotools and other building systems. Conan usage could be made easier if the conan module: [https://github.com/conan-io/cmake-conan](https://github.com/conan-io/cmake-conan) was added to the official CMake distribution and conan was turned into a standalone tool by packing the dependencies with the Python interpreter.
&gt; I write my min max using #define and abs() in 3 loc. Now I'm even more doubting that this is a serious post but I'm gona keep assuming it's serious. Why would you ever use a macro if a function will do? So much extra shit you have to think/worry about with a macro. Is there even a single benefit to implementing abs as a macro instead of a function? I can't think of one.
The only problem of Conan is that it requires installing Python and pip, but it is easier with Miniconda Python distribution. Using conan with CMake is still not so straightforward, but with this CMake module: [cmake-conan](https://github.com/conan-io/cmake-conan), it can be made a lot more easier as the user only needs to maintain a single CMakeLists.txt file without caring about conanfile.txt and performing any step in the command line. So, it it makes the usage easier with IDEs.
So what happens when you call a method on a volatile instance? Normally you'd get an error about discarding the volatile qualifier on this if you don't have a volatile overload.
&gt;Which would be the same situation with a forward declared template. What happens is that if you call your serialise function from in a TU, it has to be instantiated, which also instantiates all the template functions within it. So if you call your serialisation from multiple different TU's, you end up with a bunch of duplicated instantiations. You can fix this with extern templates and explicitly instantiating them all once in a file, but then you might as well swap to a free function approach from the start and save yourself a lot of faff. Realistically you're going to end up with macro soup whatever you do to avoid boilerplate The main difference in approach is that instead of having a member function that exports the member variables with serialisation happening externally, you have a free function that directly serialises the variables. All the logic is nicely split up and hidden away, and none of your regular code needs to know anything about the implementation details - so no need to include any potentially heavy serialisation headers or whatever etc for when you inevitably need to extend your serialisation scheme to do more things &gt;it's just a tad weird to hammer on the OP for using templates while using macros that expand and are instantiated like templates yourself I didn't mean to hammer OP, just to suggest problems that I'd found when experimenting with exactly that approach! &gt;"recursive template compile cost" Yeah this is a more general point about serialisation, generally if you have a class with non trivial members, you need to recursively serialise them - which inevitably means recursive templates through this kind of approach - the cost of instantiating all of them gets high quickly
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cgcrw8/what_is_the_next_step_in_c_journey/euh13pm/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cgazer/problem_with_dowhile/euh164k/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt;by injecting and running javascript. &amp;#x200B; There is another trend that I think it worth mentioning in this context. If the web continues to move in the direction of supporting WebAssembly (or similar), then we could get to the point where the visibility of the javascript (mostly) disappears. In that case, the ecosystem could end up looking essentially like C++ (native) &lt;-&gt; web\_view &lt;-&gt; C++ (WebAssembly).
Apologies, I will do so in the future.
&gt;The one building block I think we need is std::window. It provides a place to draw into, and a mechanism for obtaining window-related events, and I certainly understand why it's natural to think this is the right starting place, but it's not obvious to me that it is really the right level of abstraction. The problem is not the idea of the window itself, but how to usefully abstract the operations that it supports. Having a std::window which essentially is useful only for its native\_handle() method is obviously not all that useful. I'm definitely open to suggestions. &amp;#x200B; &gt; A basic drawing toolkit may be provided for educational purposes &amp;#x200B; I don't believe that we should be standardizing facilities that require educational stand-ins for what the students will need to actually use once they graduate. The facility is either useful for a wide array of production use cases or we should be working on something else.
I wish there were a lot more talks at these things aimed for beginners. I know the majority of the people _at_ the conference are essentially all experts, but a lot of people watching from home are not.
I'd love to attend IRL. But too far away :/
&gt; `std::random_device` is not required to be non - deterministic We should have std::crypo_random_device when we care about security and performance is secondary. Deterministic pseudo random generation is another stuff that shouldn't be put in the same bag as cryptographically secure generators. &gt; no good way to initialize generators with big internal state This is a side effect of trying to use the same API for both performance focused code and security focused code. One size is not good for everyone, we need another API exclusively focused on security to reduce the number of ways the library can me misused.
Sure, let me rewrite a lot of utility functions that are always needed. The time it takes adds up you know. It's also more error prone. Why do you think there is a standard library?
&gt;Also if this really is for teaching or things like that, &amp;#x200B; No, it is intended to be useful for production applications. &amp;#x200B; &gt;Plus it still leaves open the question of what to do for platforms without a web browser; &amp;#x200B; All major platforms provide web content rendering with at least one underlying engines with a useful embedding API. How to deal with platforms that don't have this capability is an open question, but such platforms certainly need to be confirming. The standard could make the interface optional, it could exist but always "fail", etc. &amp;#x200B; &gt;so it would probably be optional, and if it is optional my wild guess is that it will be implemented by nobody. &amp;#x200B; I've already received feedback from some of the relevant vendors to the contrary. &amp;#x200B; &gt;And including the shitload external specs of the by reference in the C++ standard is utterly batshit crazy. 1/ The C++ standard is already way too large, no need to multiply its size by 100. 2/ The web is an ultra fast moving target, and using a browser just too old or too new will render the aggregated result non-conforming. &amp;#x200B; Exactly which external specs to reference is definitely a point on which feedback is sought. &amp;#x200B; &gt;I will probably never understand why people think it is a good idea to pursue that kind of thing in the context of the C++ international standard. IMO if they think this will favor teaching adoption or that kind of "soft" effects, they are extremely deluded -- I even wonder if they have talked to teachers about that subject. &amp;#x200B; I strongly believe that we should not standardize facilities primarily dedicated to teaching. We should standardize facilities useful for production applications. &amp;#x200B; &gt;Likewise for industrial applications: virtually nobody would use that class of API. &amp;#x200B; Can you elaborate on why you say that? I've received plenty of feedback to the contrary. The browser embedding APIs have been widely used for providing applications UIs on many platforms for many years. &amp;#x200B; &gt;Now I understand that the kind of 1st rev paper like the one linked is not really "serious" and more to make people react. Well I guess I'm reacting, so it's not a bad paper after all... :) &amp;#x200B; Exactly -- you're welcome :-) -- but it is evolving into a serious approval. Concrete feedback, both positive and negative, is important.
How is getting the path of the executable not relevant to the filesystem library?
Are there any news on the possibly different meaning of inline or an inline attribute in modules?
&gt;Something that ISO C++ is now trying to fix, but appears to have come too late, having let other eco-systems offer more mature tooling. &amp;#x200B; To some extent, this is certainly true. But if you look at the trends around technologies like WebAssembly, which are programmed in C++, the future might yet provide an opportunity for C++ to have a strong place within the overall ecosystem. In some sense, the question is how to integrate everything together.
Couldn't `midpoint` be implemented with the x86 `rcr` instruction (or your architecture's equivalent) as well?
I'm not certain I understand. Do you mean to use `rcr` to divide by 2 with the one extra bit from the overflow? I believe that would work: ``` add esi, edi rcr esi mov eax esi ``` This is similar to Java's fix: they use signed integers, so they wrote `(a + b) &gt;&gt;&gt; 2`; the overflow into the sign bit would be shifted over. Java could only do that because they're using 31 of the 32 bits, but with `rcr`, you're accessing a 33rd bit: the carry flag.
How do you test without reproducibility? How do you test with mutable global state that invisibly changes the output for identical inputs?
I'd argue that there should be more than one reference/tutorial. I'd say 2. 1. How to consume the std library provided coroutines primitives, and write your own using those primitives. 2. How to write your own coroutine primitive. There is [this stack overflow post](https://stackoverflow.com/questions/43503656/what-are-coroutines-in-c20/44244451#44244451) which talks about what coroutines are in an abstract fashion. But that is (1). (2) needs a different perspective. --- C++ has a few constructs in it. There are classes (introduced by `struct` and `class`), and there are functions. Data and code. A class declaration introduces a new type of data. It can have code embedded in it in the form of methods, including constructors and destructors that run whenever the type is instantiated or goes out of scope. A function is sort of like a class. Its argument list is a kind of constructor, its return value is a kind of destructor. The variables within it are sort of like the members of the class; they have more complex lifetime than a typical C++ class. When you call a function, you instantiate the function on the automatic storage stack, construct it by passing in its arguments, invoke its "constructor" which is its body. The body proceeds to allocate more data on the automatic storage stack (local variables). It possibly creates other function instances (maybe recursively!). When it is done, it returns; the return cleans up all of the local automatic storage data (and conceptually the arguments) and populates the return value (if any). This probably seems like a strange way to think about functions. It isn't very procedural. But it helps, because it is from this perspective that coroutines are like functions, but on steroids. See, once upon a type, functions didn't *do* all of that stuff. Primitive languages had functions, but they didn't shove local variables on the stack, they didn't have a standard means of passing arguments, returning was more like a goto, etc. Recursion would break things, because local variables would be reused! The C/C++ function is a fancy wrapper around that "lower level" goto and manual stack management "function" construct. Coroutines go a step further. Functions have 2 operations. Call (what I called "construct"), and Return (what I called "destroy"). Call is done from *outside*, and Return is done from *inside*. Coroutines have more operations. They have two "external" operations: "Call" and "Resume". They have two "internal" operations: "Return" and "Suspend". Oh, and they can be destroyed without Returning. Call is basically Construct (setup) and then Resume (start running). Suspend returns execution to the Call/Resume site and optionally passes it some data (depending on the signature involved). Resume returns execution at the last Suspend site. Under some proposals it can carry data with it. Return is basically a combination of Suspend and Destroy. Destroy cleans up the coroutine's state without actually returning a value. In C++ this works through a strange reflection operation. The body and arguments of your coroutine (which is a function that uses the coroutine keywords) is examined. Based on metaprogramming based rules (the "reflection" bit), a coroutine object is then created, and connected to the arguments and the return value if your function. The body of your coroutine is "rewritten" by the rules, and coroutine operations in it are connected to calling methods on your coroutine object. You are given some opportunity to run some code in your coroutine object. If you don't do anything fancy, then the intial return of the coroutine happens, which returns the return value immediately. At this point you (the designer of this coroutine primitive) are responsible to connect the return value and/or arguments of the function to your coroutine object, and provide an API to cause a resume to occur on your coroutine object. For `std::future`, that might be in the implementation of the `wait` or `get` method. --- Now, this means in order to call `co_await`, you must be in a coroutine. And what `co_await` means is determined by the person who wrote the coroutine primitive your function maps to. std::future&lt;int&gt; get_sum( std::future&lt;int&gt; a, std::future&lt;int&gt; b ) { return co_await a + co_await b; } This is a coroutine, because it contains `co_await`. In other versions, it was: std::future&lt;int&gt; get_sum( std::future&lt;int&gt; a, std::future&lt;int&gt; b ) coroutine { return await a + await b; } where `coroutine` makes it a coroutine and unlocks the `await` keyword. Same difference. the person who wrote `std::future&lt;int&gt;`'s coroutine "primitive" wrote rules for what awaiting means in it. Conceptually, it might be rewritten into something like this: std::future&lt;int&gt; get_sum( std::future&lt;int&gt; a, std::future&lt;int&gt; b ) { std::promise&lt;int&gt; retval; retval.get_value_from_blocking_call( a, b, []( int a, int b ) { return a+b; } ); return retval.get_future(); } where `blocking_call` connects the ready states of `a` and `b` to `retval`, and states that `retval` is ready if and only if `a` and `b` are ready, and waiting should pass on the wait, etc. Even in this simple case, the `await` version is much tighter. In real asynchronous code you'll be doing await-style operations all over the place as you tie together data from a bunch of stuff that may or may not be ready.
There's no loop to get the current dir, you call `getcwd`. The filesystem library is a portable abstraction over existing OS functionality, like POSIX `getcwd`, and there isn't such a function to get the executable's path.
Interesting. In 1994, I was still a child and has not started learning the programming.
The executable's directory is relevant because an executable may be bundled with files that it depends on. When any relative path such as `"."` can be expanded to absolute, as it can via the `absolute` function, a special function for the current directory path, like `current_path`, is * interface noise and * encourages programmers to Do Things Wrong&amp;trade;. It's part of the approach of this sub-library where doing things wrong is made easy and natural, and doing things correctly is made hard. I thing it's interesting that you're arguing as if it were opposite, that when such issues are pointed out, you effectively go into denial mode.
The implementation is in a loop that calls getcwd on Linux/_wgetcwd on Windows with a progressively larger buffer until it can fit the whole path. Getting the current exe path is a loop that calls readlink("/proc/self/exe", ...) on Linux/GetModuleFileNameW on Windows with a progressively larger buffer until it can fit the whole path. Logically getting the exe path clearly belongs to the filesystem library. It's true it's less standardized than getting the cwd but doesn't that make a portable abstraction over it all the more valuable?
1994: 454 pages June 2019: 1754 pages
&gt; Running "foo/prog file.png" in /home/ usually means that you want to use /home/file.png and not /home/foo/file.png. A function to find current directory is not needed for that. Moreover, if such a function were needed, then still `current_directory` would be redundant, given the `absolute` function.
(Wrong formatting.)[https://i.imgur.com/SdHY0Hr.png]
Yes, there was discussion of this and a paper. I can't remember the details as they were explained to me in a bar while I was exhausted.
Made a torrent for this file, magnet link: &gt; magnet:?xt=urn:btih:67a5342417f84dfdb0cd4b5d63316c5242733a2a&amp;dn=n0414-rotated.pdf
One of the issues in this conversation is that we haven't had hard (or soft) data to support either side. That would be helpful.
Not really. There are options but they are not as effortless as other options. Using them is good only for hobby-level code. You are better off writing easy-to-import IO code and use external libraries for visualizing the data.
The C++ is too big to use without documentation. Documentation comments in Java and Python improve their usability and reduce the cost of learning new libraries. Now, a lot of programmer, especially students and teacher in college, remain in C++98, though the compiler has supported the C++ latest draft. In other hand, different application libraries have their own document comment format, however, the IDE cannot leverage them to aid users, so the cost to learn a C++ library is greater than ones of other language. In addition, the modules of C++20 are binary. It is harder to read document comments, or the compiler cannot display these comments of function, class or template either. A standardized documentation can be packed in to the spare files and be delivered with binary files which can be used by IDE.
It's the first program i made which i would consider complete/usable (although arguably borderline useless). Took a while to get all the interaction with Windows's wallpaper and taskbar going.
My non answer https://cor3ntin.github.io/posts/what_is_cpp/
Without the code is hard to say anything... But seems good for a first project.
&gt;In addition, the modules of C++20 are binary. Compiled module interfaces are not somthing that can be distributed with other binary artefact, it's more like a compiler cache than anything. You must ship the module interface source code alongside compiled libraries.
WebAssembly is language agnostic, C++ compilers just got the head start due to WebAssembly MVP release. Most of my WebAssembly fun is via [Blazor](https://dotnet.microsoft.com/apps/aspnet/web-apps/client) and [AssemblyScript](https://docs.assemblyscript.org/).
Odd, it looked correct in desktop Firefox or desktop Chrome, and in the reddit Android app, but not in mobile Firefox or Chrome. Fixed now.
!remove
OP, A human moderator (u/STL) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cgitgf/my_first_complete_c_program_what_do_you_guys_think/euhmuz4/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
That screenshot was taken in desktop Firefox...
There are more than two operating systems, several of which don't use a `/proc` filesystem, and if you call `getcwd` in a loop on GNU/Linux you're doing it wrong (you should call it with a null pointer for the buffer instead, and the same for `_wgetcwd`).
The `absolute` function uses `current_path` though.
I don't quite get from the description if new language features are going to be used in standard library. There are modules, concepts, coroutines etc. Are they going to be used in standard library, so \`std::sort()\` checks for \`sortable\` concept and \`std\` is "modularized" or does that depend on implementation? Anything "coroutined"? Also that "v1" business is not very clear to me. This means there will v2 of specifications, right? Any information on how compatible it is going to be with v1?
On POSIX systems `absolute` uses `current_path` so it's not redundant. &gt; It's part of the approach of this sub-library where doing things wrong is made easy and natural, and doing things correctly is made hard. I'll agree with that. &gt; I think it's interesting that you're arguing as if it were opposite, that when such issues are pointed out, you effectively go into denial mode. I only see one issue pointed out, getting the executable's path, which I happen to disagree is an issue with the filesystem library.
What makes this post worthier than mine? :| [https://www.reddit.com/r/cpp/comments/cfyp2r/my\_first\_c\_project\_after\_a\_few\_failed\_tries\_a/](https://www.reddit.com/r/cpp/comments/cfyp2r/my_first_c_project_after_a_few_failed_tries_a/)
`¯\_(ツ)_/¯`
For instance platform-specific headers
It's rather late in my timezone so this is not going to be an in-depth list, but for std::window I would expect functions to query and change: visibility, size (internal and external), title, maximisation state, etc. For events I would expect to be able to receive: mouse events, keyboard events, paint events, move events, size events, touch events, etc. Both lists are quite incomplete, but the more interesting thing at this time would be how those events get delivered to the application. So far I don't think C++ has a wait() function that yields the CPU until an event comes in? The problem here is that you can really only have one wait() function; you cannot swap between two that wait for different set of events, so that single wait() function must cover everything it could possibly need to wait for: window events, socket events, timer events, etc. I can probably write down a more comprehensive list of window-related functionality, required events, and also drawing functions, if anyone thinks it would be helpful.
&gt; Getting the current exe path is a loop that calls readlink("/proc/self/exe", ...) Which works great until you realize you can unlink() a running executable from it's only path on the system leaving you an interesting dangling symlink in proc. There's also chroot(), which will give you the correct immediate path from inside the chroot, but there's no way to know what that's _actually_ relative to from inside the chroot. Outside of it, you'll get the full path when you ask. Also linux mount namespaces are a thing. Getting the current "executable path" is a pretty "vague" concept to begin with, but getting the correct information for the given context is impossible to figure out automatically and not really useful in the context of an "fs library" anyways.
There are more than two operating systems. [whereami](https://github.com/gpakosz/whereami) will give the implementation for a bunch more. Passing null is, of course, a glibc extension. It's also somewhat finicky since you need to `free` the buffer, and you might want to use a different deallocator for the memory (eg. to put it in a regular container that uses `delete`). Maybe bringing up how similar the implementations are was a bad idea because this thread seems to have gone off into the weeds. I was trying to ask why you don't think getting the path of the current executable is relevant to the filesystem library. There are existing OS functions to get it. Do you not think it's universal enough or...?
But then no &lt;network&gt;, no &lt;linear_algebra&gt;, or other generally useful parts of the library which would be very useful and a huge productivity boost long term in C++. For those of us in a domain where 3rd party software beyond the standard library is frowned upon and used only when absolutely needed, your suggestion kills C++'s long term advantage over other languages that will not stop adding those features.
&gt;I think that a lot of the motivation behind std::web\_view and the 2D graphics proposal is for teaching purposes. &amp;#x200B; This is definitely not true. The people actually working on these proposals intend for them to be usable in production settings. It is true that some members of the committee have stated that they believe that having graphics support will help teaching C++ to beginners, and that may be true, but there is not consensus to put facilities into the standard library primarily for teaching purposes. As far as that goes, a significant number of people agree with you.
I don't think it is obvious that all compilers would have the Coroutines TS implemented fully, if people were not confident that it was heading for the standard. We don't really have it implemented in GCC yet, even with that expectation.
Is that really a problem? Calling getcwd can also fail with ENOENT if the cwd has been unlinked. And I don't know what else you'd expect to happen for a chroot. I don't know what mount namespaces are though. It might be vague (an executable run with no corresponding file at all makes perfect sense, though I don't know if anyone actually does this) but practically every OS seems to offer this whether it satisfies some criterion of correctness or not. The fs library seems a logical place to put it.
In some sense, this statement could be made about any proposed addition to the standard library (which is not wrapping some compiler magic). What makes graphics different from hash tables or the file system?
Rust is the one I'm thinking of. If anything they may take it too far, what with the "Rust Evangelism Squad" problem they have, but they [actively encourage discussion on Reddit](https://www.reddit.com/r/rust/comments/4bd0sv/why_wasnt_automatic_lifetime_annotation_not/d1837mc/). They are [asking for discussion on a current issue (async/await) as well](https://www.reddit.com/r/rust/comments/biw1ic/asyncawait_syntax_status_update/). Aside from those examples, it's not exactly very hard to find their open "internals" discussion forum for [examples of discussion had on or influenced by Reddit](https://internals.rust-lang.org/search?q=reddit). You can do [likewise for their Github to find merged PRs mentioning Reddit](https://github.com/rust-lang/rust/pulls?utf8=%E2%9C%93&amp;q=is%3Apr+is%3Aclosed+is%3Amerged+reddit). Those searches led me to discussions like: * https://github.com/rust-lang/rust/pull/45267 (itself pointing to https://www.reddit.com/r/rust/comments/763o7r/blog_posts_introducing_lockfree_rust_comparing/dobcvbm/) * https://github.com/rust-lang/rust/pull/51656 (which mentions https://www.reddit.com/r/rust/comments/8o5rmz/why_envhome_dir_returns_optionpathbuf_instead/e01ft8z) * https://internals.rust-lang.org/t/add-foreach-method-to-iterators-for-side-effects/1312 * https://internals.rust-lang.org/t/why-rust-fails-hard-at-scientific-computing/6065 So Rust is hardly "Reddit-driven development" but then that wasn't my point. They *do* provide a way for people to contribute (even if it's just feedback or "hey I'm a noob and I can't figure this out") in ways that improve the language without just saying "Let me know where I can find your paper in the next committee meeting".
Both are useful for system/server programing while graphics library isn't?
Very sharp rocks are needed to accurately reproduce Rudolff down the line.
&gt;web\_view doesnt bring us any closer to that at all tho. it would just go unused and die because of how slow/inflexible updating anything in the std-lib is (keeping up is especially important for anything web-related; stnadarizing something thatll be outdated in a few years isn't what the stdlib was/should ever be about) &amp;#x200B; That's not how web\_view would be deployed. Web content rendering is provided as a system service on most relevant platforms, or at least as part of an installed browser that is updated by the OS. The C++ standard library wold just use the provided API.
Pfft. I got min/max tattooed on my skin, I use OCR hooked up to a kinect which snaps a picture of me and interprets the code every time I need min or max. Think of the job security!
Here's the proposal: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0811r3.html And I voted for it.
In 1994 I was 3.
With regards to "v1", which things are you referring to?
There are also installers in [https://conan.io/downloads](https://conan.io/downloads) , that install an executable with the python interpreter transparently bundled, so no necessary to install any python and/or pip in the system. If there is no installer for a platform, it is possible to create a bundle with pyinstaller, the script to create the excutable is in the repo too: [https://github.com/conan-io/conan/blob/develop/pyinstaller.py](https://github.com/conan-io/conan/blob/develop/pyinstaller.py)
You mean: you hadn’t even dropped out of kindergarten yet to start your programming career? ;)
The good reason is that you're right :-) -- That's really ugly. But, fixing that is an orthogonal issue. Libraries to deal with creating HTML (or any other XML-like markup), escaping parts of URLs, parsing or creating JSON, and so on are independently useful and would go into separate proposals. Also, it's not clear that you necessarily want to create HTML in-process that way as opposed to just having it in a separate file. The prototype implementation has at least one example in the repository that uses multiple files and avoids some of this mess.
I'm talking about very last table in post: "Changes since last meeting are in bold". It has "v1" near almost every entry: Concepts TS v1, Ranges TS v1, Coroutines TS v1 etc. I assume "v1" stands for "version 1", is it not? Links to cppreference don't mention anything related to versioning or compatibility between versions.
&gt;Passing null is, of course, a glibc extension Why do you think I said GNU/Linux? :) The same extension exists on Windows though. And using one `free` is still simpler and more efficient than (re)allocating in a loop. As I've said, I don't think the hard, non-portable part of getting the executable path is relevant to the filesystem lib. The fact you need to resolve a symlink on some platforms means you might use the filesystem lib to implement it, but that doesn't make it part of the filesystem lib IMO.
**Company:** Research Assitant and Master's student at Simon Fraser University, Canada **Type:** Full time **Description:** Pursuing my Master's in Computing Science. My field of expertise is automated software analysis using formal methods implemented with the Clang+LLVM framework. Currently, I'm building a novel static analysis which instruments a program to enforce access control policies automatically. In the event that the software is attacked, these policies restrict the capabilities of an attacker and thereby restrict the damage that they can do. **Location:** Vancouver, Canada or remote **Languages:** C++, Python **Contact:** PM, [LinkedIn](https://www.linkedin.com/in/shreeasish/)
vtk is probably the most mature / full featured. there may be stuff in ROOT as well.
wxWidgets while being an entire GUI framework provides a lot of data containers like trees or tables
I don't mean to split hairs, but while I can certainly be misinformed, everything I've read on the subject from the 2D graphics proposal has talked about how great it'll be for teaching purposes, and basically nothing else. I'd love to see different viewpoints on it, if you happen to have any readily available.
Simple: if you need the output to be reproducible, do things the "hard" way (aka the 3 LOC way we do now, with generator/distribution). The point is that for a lot of people they *don't* need it to be reproducible most of the time, and they're happy with a convenient random function that's initially seeded by the current time. Nobody is advocating *replacing* the current STD::random implementation with this suggested simpler one. They complement each other.
Do not slow down until contracts are in the language pls kthx bye
quick, someone write an article
C++, yes. Good, well.... I'll leave that to others to answer for themselves. https://root.cern.ch/
Yes, it will be recorded. The B2B track is part of CppCon's main program, and all main-program sessions are recorded. — And lightning talks, too. But not Open-Content or Birds-of-a-Feather sessions.
Nice job!
No, at that age he was probably still working his way through SICP like the rest of us mere mortals.
You're confused between the availability of popular places to talk about Rust, with Rust developers taking actionable feedback from Reddit users. Rust has a project wide discussion forum -- that's cool. They ask you to keep your commentary on that forum, as is clear from your own links. It seems some Rust developers will happily answer questions on reddit, but that's also what some individuals that work on C++ do. Most of the discussions you've linked to appear to lead to exactly no direct actionable feedback -- they're kind of wishes and hopes thrown in the air, and it's clear Rust has an "elite" internal team for the language or the compiler that do all the actual work. Were \*you\* invited to decide the async syntax? Was it \*voted\* on publicly? No, elites decided it and you had zero input. At least if you show up to committee with a paper you have a voice, without needing to be a programmer or invited into an elite circle. So in that sense C++ is much more open than Rust. If you'd like a place to chat more with people involved in C++ there's unofficial slack and discord servers. "Let me know where your paper is" isn't a reply to "noobs" who try contributing, it's to people who claim "the committee won't listen to me" or "everything's broken and the committee is dumb". There's plenty of community feedback in many places all over the internet. You're just as likely to get the attention of the C++ "elites" there as you would Rust "elites" on internals.
Also, C++ is not an open source project, but it definitely is not for profit. If you or anyone else like to create a "internals" like forum, I think that'd be awesome. We'd make the same promises at Rust developers do about taking direct action on feedback.
If you don't need it to be reproducible then again: How is it testable? If it isn't testable you can't/don't/won't test it, so how can it be said to actually work? Because it seems to work for some arbitrary ad hoc manual testing? What happens when you get a bug report, how are you going to formulate a reproduction? Without a reproduction how will you know you've fixed the bug at all? Begging for a global PRNG is begging for things to be easy and wrong. But easy and wrong is even easier than that: Don't write any code at all. Super easy, still wrong. Also: The current time is a terrible seed.
They grow up so fast...
...ok then. Not everything needs 100% coverage. Sometimes we just need to write a toy program, or a simple utility for personal use, and "I tried it a few times, it seems to work fine" is completely ok. Like I said before, if you intend to use "random" numbers in your program, and actually care that they are reproducible, then you can continue to do things the current way. Nobody is forcing you to change.
&gt;Consider a system where C++ source code lived in a form of database, instead of files. Each function, and variable, and so on, in this situation could be it's own record in the database. IBM's C++ Visual Age that acted just like Smalltalk. Although they were more successful (a relative measure) with the Java version.
Wait, this isn't a fucking joke?
How often they are likely to show up as vocabulary types. That said, I think \`web\_view\` makes somewhat more sense than a 2d graphics API that models, but is not the same as, any actual production API. "I have a dream. It's not a big dream, it's just a little dream. My dream - and I hope you don't find this too crazy - is that I would like the people of this community to feel that if, God forbid, there were a ~~fire~~ UI, calling the ~~fire department~~ Standard Library would actually be a wise thing to do. You can't have people, if their houses are burning down, saying, "Whatever you do, don't call the ~~fire department~~ Standard Library !" That would be bad."
This is not "critical" in the performance manner. It is something else - We provide a "database" key-value, that may be accessed from many threads. The database guarantees that once the value is yours, no one can access it too. It is yours, and only yours, once you gained it, until you leave it. We use a pointer like object (accessor), which implements RAII. The user code looks like this using Key = int; // the key using Value = Blob; // some type using DB = DB&lt;Key,Value&gt;; using Accessor = DBAccessor&lt;Key,Value&gt;; /*..*/ DB db; Accessor a( db, 5 ); // once a is constructed no one can get the element under key 5 Accessor b( db, 5 ); // dead lock: b waits to 5 to be released but a is constructed The key you are searching for may **not** be in the database. Therefore the `Accessor` should simulate `nullptr` Accessor c( db, 7 ); if ( c ) { c-&gt;doStuffWithBlob() }; The implementation of `Accessor` has an access to the internal data structure of DB, which is `std::map.` The Accessor holds an iterator to the "owned" element as a member variable. Throughout the code of `Accessor` we always check this iterator against the `end()` of the map before taking any action on it. Now, The critical part is that this code is tricky in the way it guarantees single access. There are many issues to consider. For example: before you gain an exclusive access to the element, you need to look for it. In the same time someone else may look for it too. Now you both found it, but the other one deletes it just after you found it and just before you gained exclusive access to it. The result is that you now have an invalid iterator representing a "found" element. This is just one example that should be taken into consideration when implementing the `Accessor`. Many other multi-threading issues may arise too. # Back to the issue The reason I want end() to be constant is for *maintenance*. If I can anchor this as a const value, problems would be looked at other areas of the code. imagine, what could be eliminated - "oh! but in this `if` `end()` may have changed by the other thread" or "I know! I know! we are doing !@$%@##@ and $#@!@! at the same time, this changes `end()`" etc. &amp;#x200B; Hope I was clear.
Pure guess, because I'm on the phone, but perhaps it's needed if you want to pass a FORTRAN multidimensional array to `std::mdspan`. I think `arr[x][y]` have different layouts in C and FORTRAN (think transposed matrices). At least I've found something like that in PyBind11 documentation. Or I'm way off, since I have not read the paper.
I was 69
I have no experience with opencv but it appears you're defining the array as a function local variable. When the function returns, the memory it refers to becomes invalid.
Without knowing the implementation of Mat, it seems like a case of dangling reference. Mat is constructed with intrinsic_vals, an array local to preProcess(). When it leaves that function, intrinsic_vals is destroyed and the reference within Mat is no longer valid.
thank you, i'll join the thread and ask future questions there!
Thank you! I'll look into dangling reference.
It's too confusing... Why not binary it is just like .jar or .wheel
I'm pretty certain they jet airplanes were invented to so that people could attend CppCon.
Come to CppCon and become one of the experts!
From the manual: "As noted in the introduction, the array assignment is an O(1) operation because it only copies the header and increases the reference counter." In other words, it's because the Mat class is more like a shared\_ptr than a real object: upon assignment it doesn't copy the object you are assigning but just takes a pointer to it and increases its reference count. The temporary you use to construct Mat in Preprocess is located on the stack, so it is clobbered when the function returns, and k keeps a copy to a pointer to an object that is no longer valid. What you need to do instead of assigning, is call the Clone() function. I consider this to be bad design: if you want shared\_ptr semantics, just use a shared\_ptr; it leads to far less surprise, as you have found. Of course OpenCV is older than C++11 so it isn't entirely fair, but then again, it is 2019 now...
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
thanks!
From 'P1099R4 Using Enum' §6.2 switch (my_channel) { using enum rgba_color_channel; The compiler knows what my\_channel is, in the spirit of auto I'd prefer not to specify 'rgba\_color\_channel' at all here. This is an improvement but still a step short of optimal. Maybe a 'switch enum ()' would help here.
It's the annoying old.reddit.com vs www.reddit.com - "old" doesn't support fenced blocks (it's pure markdown), but the "redesign" does :(commonmark extension). Please indent code blocks an additional indentation level (a tab or 4 spaces) so it looks right on old Reddit too.
This is great ! exactly the directions IDE should move in. Now we just need a build system server protocol
Very good idea! Sometimes it's good to take a step back and reflect on the basics. I hope these sessions will also be recorded and become available online.
Actually, a LSP server for CMake would already be great enough for me ;) It would fit in very well, given I assume a lot of people anyway manually edit their CMake stuff like normal code.
I think that's done through the `Mapper` concept. The paper includes a couple of different implementations, one for row major (C), one for column major (FORTRAN) and a one for strided views
This could be worky, it's a tiny interpreter. There are lots of techniques for [DSLs](https://en.wikipedia.org/wiki/Domain-specific_language), one idea I'd try would be a [recursive descent parser](https://en.wikipedia.org/wiki/Recursive_descent_parser). For the end nodes where you evaluate fields you could do with something such as map from strings to member pointers.
GCC will get the Coroutines TS sooner or later. At best GCC 10, if not you will be waiting for GCC 11 which is May 2021. Another year and compilers will have experimental support for C++23, so I don't see it as much of a problem.
Thanks, I will give it a try. Sounds challenging to me but I accept the challenge. It may be an overkill for the current project but, anyway, it is a good side project maybe
&gt; I do not understand why C++ committee always picks the most powerful options over the most needed options Because you can build the most needed from the most powerful. C++ has never been a battery included language. If you need a convenience random function, you can write it, put it in `utils/random.h` (or your equivalent) and never thing about it again.
Yes! I've been saying this for years now. Build system metadata should be obtainable in a uniform fashion for all build systems via a standard adapter.
Thanks for the non-advice. You can do that with virtually everything in std, so why not scrab the whole thing because people can just write their own?
Will you make the scanned papers available on http://www.open-std.org/jtc1/sc22/wg21/docs/papers/? The website is notably lacking when it comes to old papers, and N0414 is also among the missing papers.
After 17 years using C++ nonstop I can tell u that I still learn little details in these talks. Te basic mechanisms pf move semantics, lambdas or whatever are easy to understand but the devil is in the details (and corner cases).
co_await get_answer();
Yea. However my employer won't pay for that (at least this time). And flying from Germany to Colorado, and not working for a week is damn expensive. Maybe in 2020.
you are not alone https://www.scala-lang.org/blog/2018/06/15/bsp.html
This is just *my* opinion on the thing (Like my first answer, except for the first sentence). &gt;You can do that with virtually everything in std, so why not scrab the whole thing because people can just write their own? I think that there are two reasons why things should be in the STD: * There is only one implementation. `std::find` for example. You will probably never run into a situation where the supplied implementation doesn't do exactly what you want, so there is no downside to providing it. Plus it's like 5 lines. * It saves most programmers a substantial amount of time. `std::vector` and `std::unordered_map` are not perfect (no SBO, uses chaining), but writing your own is a two weeks job at the very least, so including them does make the language much much easier to use, even if you end up replacing them down the line. The provided implementation will also be fine for some peoples. A convenience random function "à la `rand()`" doesn't fit either of these two points. There are about a trillion ways you could implement it, and no matter the one you choose, people will complain. And including it saves the programmer 10 minutes. Here is an (shitty, but working) implementation if you really need one: template&lt;typename T&gt; T random() { static_assert(std::is_floating_point_v&lt;T&gt;); static bool init = false; if(!init) { std::srand(time(nullptr)); init = true; } return T(std::rand()) / T(RAND_MAX); }
QtDataVisualization is GPL, not LGPL, unlike the most of Qt. Or under commercial license.
Indeed. Thanks for a fix.
Just glossing over this draft: why wasn't the namespace design from page 199 followed through?
That is disappointing, to say the least.
Now that C++17 is being adopted more i hope people will request it enough for such a method to be added.
`constinit` makes it easier to see that you will get constant initialization without having to inspect the expression. It also shows the intent better. If a variable is marked `constinit` I know it is intentional, and I would be more confident relying on it, because I don't expect people to remove `constinit` without first considering what code might break. In your example it's not clear if you used `consteval` to get constant initialization or if you just used it because you can, to make the code run as fast as possible.
I love that drawing. Especially IOS lake.
I hate to break it to you: You always have some global state and never 100% reproducibility in non-trivial systems. You make network connections, interact with users, read/write files, have variations in timings due to other loads on the system (and as a result might or might not observe races), you register signal handlers etc. For some applications you even explicitly don't want reproducability of the random numbers (e.g. cryptography - although that would not be the goal here). Now w.r.t unit tests: There are two ways to get reproducability: 1) Treat it like any other IO and mock it 2) Log the used random numbers Now, more generally speaking: a) There are many more ways of testing correctness than just checking "Is the output of system A the exact same as it was last time?"? b) I doubt that your tests actually cover 100% of the input space anyway, so in the deterministic and non-deterministic case, you can't prove that your system works correctly via tests anyway (and no, even 100% Line and/or branch coverage isn't enough for that). It is just a kind of sampling where you hope it covers enough to be representative. The fact that - when using a non-deterministic RNG - the samples might vary a bit from run to run doesn't fundamentally change anything about the quality of the tests - long term it might even be better, because you are covering a bigger input space (which is exactly the idea behind fuzzing). Finally
This looks even better than what I thought, thanks!
Are there any plans to ship `fmt::print` as well? I've been enjoying fmt a lot.
There's a difference between recognizing that your system as a whole cannot have 100% perfectly reproducible runs and succumbing to the fallacy of division and concluding that if that's the case then reproducibility doesn't matter at any level of analysis. The point is to design in such a way that the irreproducibility is deferred as much as possible. This is reflected in the design of `&lt;random&gt;`. Often when actually running your program you don't want reproducibility (e.g. crypto) or you want the illusion that the run isn't reproducible (e.g. games). However during development this needn't be the case and if the interfaces/APIs you're using are well designed it needn't be. Also proving that your system works 100% of the time via 100% input space coverage beforehand is not the point of testing (unit testing or otherwise) since for most non-trivial programs this is either actually impossible (at worst) or completely impractical (at best). However what you do want is an avenue for: - Probing known edge cases - Locking in the correct output for buggy inputs discovered in the wild If you just throw up your hands, use a global random number generator buried deep in your program, and decide that it seems to work because you ran it a few times you throw all of this away and damn yourself to less effective development.
You can attend and abstain from voting in the straw polls.
Some sort of I/O integration yes. The API details are TBD.
Believe me, shipping code like we always did is easier than shipping binaries, and less confusing. Shipping binaries is brittle. Try making 4-5 compilers to agree on a stable format. The compiler cache is very very specific on how the compiler parse code and is sensible to flags and compiler version, and language version...
Very nice, sounds like the standardization process worked very well. Will definitely use https://github.com/fmtlib/fmt until std::format is there.
And I suppose sneaking just `std::print` into C++20 is out of the question? Because it would be *extremely* helpful from a teaching perspective to not have to introduce iostream
*Anything* getting into 20 apart from bugfixes is now out of the question.
If I'm not mistaken it has happened before. IIRC /u/STL has mentioned something that wasn't a bug fix being added last second once.
Congrats man, I saw your talk at cppcon a couple of years ago. This is a huge achievement and a big win for C++, you should be very proud!
I don't understand why people keep suggesting that the C++ committee should come down from the mountain with two stone tablets, describing a package manager and a code repository. That's batshit. Why do you think a hugely varied group with specialists in fields including programming language design, compiler front-end implementation, compiler back-end optimisation, numerical computing etc. are the right people to do that? &amp;#x200B; Every time this dumb idea is suggested I think that somebody should just go and build the damn thing, and if it's good people will use it. "If you build it, they will come". Asking for a top-down, design-by-committee solution for this problem is silly. You'd get something horrific like Clearcase. &amp;#x200B; Relevant: [https://twitter.com/TartanLlama/status/1137254531291594752](https://twitter.com/TartanLlama/status/1137254531291594752) &amp;#x200B; If the existing solutions don't meet all your needs, get involved and improve them! The alternative is to start again from scratch and get something inferior that still doesn't meet your needs. Insisting that the C++ committee should just solve the problem, as though just telling them to do that will make it a success, is hopelessly optimistic and naive.
&gt;Its written in an old-school style using next to no templating &amp;#x200B; This would be the iostreams that are written as a class template like \`basic\_ostream\` that uses a class template like \`basic\_streambuf\` that uses class templates like \`ctype\` and \`num\_put\` for every operation, right? ;-)
I'd be very uncomfortable with sneaking such things after the deadline.
Thanks!
Fair enough.
I personally like https://www.qcustomplot.com/
&gt;Maybe we should move on from the idea that you need to physically be in a certain place to communicate with others. &amp;#x200B; As somebody who works remotely 100% of the time and collaborates with colleagues all over the world, I'm well aware that communication is possible without being physically in the same place. Possible doesn't mean optimal for all cases. More and more WG21 work is done remotely, but that doesn't mean the face-to-face meetings are redundant or a waste of time. The problems with the C++ ecosystem are not because WG21 meets face-to-face. &amp;#x200B; Maybe it's time we should move on from the idea that the C++ committee needs to solve all problems in C++, and create new, useful things in other communities. Boost did a great job of that at one time, but is collapsing under its own weight. There are too many stakeholders who want Boost to provide a pre-C++11 crutch for old code, so it's probably not going to move on. Something else can, and should, replace it for modern code. And third-party code repos and package managers should be able to thrive without help from WG21 too. &amp;#x200B; There might be significant overlap between the people active in WG21 and \[INSERT OTHER THING HERE\], but WG21 doesn't need to create or maintain \[THING\].
&gt;Encouraging separate working group meetings whether face to face, virtual conferencing, short calls, emails etc. The point is that each group can adapt a little more and not require the full complement of 200+ interested parties in the building. &amp;#x200B; That already happens. Just because there are face-to-face meetings **as well,** doesn't mean there isn't other work going on all year round.
I wholeheartedly agree with this. &amp;#x200B; We (the standards committee) have invited people to make proposals, and people are doing so in larger numbers than ever before. Not all of it is really what we should be standardising IMO, and there should be more focus on what's essential. I wish the response to more proposals was "this is great, but it doesn't need to be in the standard - go away and make it successful on github".
Thanks, but Conan documentation should made it more visible and accessible to users. I guess that people become afraid from installing Conan due to the Python runtime dependency, specially if they are on Windows.
I would not recommend recursive descent for parsing expressions. You should use something like shunting yard, precedence climbing or Pratt parser. Of these, I find shunting yard the easiest to understand and implement. [Wikipedia](https://en.wikipedia.org/wiki/Shunting-yard_algorithm) has a decent intro to shunting yard algorithm. You will also need to enhance the algorithm with a state machine described [here](https://stackoverflow.com/questions/16380234/handling-extra-operators-in-shunting-yard/16392115#16392115). If you have any specific questions, do ask.
&gt; old.reddit.com vs www.reddit.com Or better, uncheck *preferences &gt; beta options &gt; Use the redesign as my default experience*
The paper outlines the roadmap which has led to this point, and some recent changes which were approved in the proposal. Apart from that it is a bit disconnected from anything and does not provide any pointers to where the wannabe user can get basic information (cppreference.com has no information, either). It is great to feel the vibe, however, and nice to know that the standards committee works in our favour!
I wonder how long it will take to get to libc++/libstdc++. I am not aware of them having to_char's yet for float/double/long double yet. And it looks like format is to use to_chars.
Maybe it's just me, but IMHO it doesn't mesh well with a language that went with `if constexpr` instead of `constexpr if` after countless bikeshedding...
I'm not sure how to get them up there, but I'm completely willing to share everything there that I have!
I'm not sure! If you can see, these mailings actually include all the issue comments in them! The one from the Sept 1994 mailing (N0545) seems to have lost any mention of namespaces!
Yes, COM is still used in WinRT API. You can [Author COM components](https://docs.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/author-coclasses) and [Consume COM components](https://docs.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/consume-com) via modern C++14 and up C++/WinRT (cppwinrt) library that now comes with Windows SDK. Some details [is here](https://github.com/microsoft/xlang/blob/master/design_notes/XDN05%20-%20xlang%20Binary%20Interface.md#com-interfaces) and [here](https://docs.microsoft.com/en-us/windows/win32/com/com-technical-overview).
I'v seen `Box 85` but I'm lacking context on why they wanted to drop nested namespaces - since we actually got nested namespaces in C++98 after all (`std::rel_ops`) and have gotten several new ones with C++11 and beyond (`std::filesystem`, `std::chrono`, ...)...
&gt; This would be the iostreams that are written as a class template like `basic_ostream` that uses a class template like `basic_streambuf` that uses class templates like `ctype` and `num_put` for every operation, right? ;-) Yup. You're right. I was imprecise. I was referring to the number of required template instantiations, but I think that was clear from the context. The points of reference here are `range-v3` and boost (namely metaprogramming or metaprogramming heavy or constexpr heavy libraries such as `hana`, `hof`, `spirit`, or `units` for example). So yeah, by comparison `iostream` requires very little in terms of template instantiation. A given instantiation of `basic_ostream` has a handful of instantiations based on it's character type and few function templates to be stamped out based on the `streambuf` iterator and `CharT*` types. This is 'next to nothing' relative to a typical workflow with the range library's views, which is now a part of the standard library and can be expected to see significant usage. Compounded with the ever expanding power of `constexpr`, I think it's to be expected to see more and more program logic pushed to the compile time. Modules don't help us here. I guess my criticism is that modules are being presented as (or interpretted as) the solution to C++'s problematic compile times. At least as far as reddit and the C++ commuity on twitter, I'm seeing gains from modules are being presented only for optimistic use cases which (I suspect) will become increasely less representative of real-world code as time goes on.
Can anyone provide input on what a good way to do initialization would be, today, without C compatibility? In C++20 we now have both brace and parens supported for aggregates, we have both brace and parens supported for class-types. Aggregates have special initialization semantics. Braces don't allow narrowing of primitives, and there's some weird corner cases for references. Braces have ambiguity with std::initializer_list (from the caller's perspective until the API is fully inspected). I just wonder what the "elegant" way would look like at this point.
Well, I've got a ton more papers to go through. If I see any that seem to hint as to the reasoning, I'll let you know!
According to the contact page (http://www.open-std.org/jtc1/sc22/wg21/docs/contacts), you can probably ask Herb Sutter :)
Check out [this map (png via google drive)](https://drive.google.com/file/d/0B3DUpmL8tTt8N2JIRklJeTIxYW8/view)
This is awesome. I think I've seen a previous version of this map somewhere.
The difference I see there is constexpr is being used to refer to the condition of the statement, while template is being used to refer to the body.
The function could return the random object. #include &lt;random&gt; std::tuple&lt;int, std::default_random_engine&gt; random(int from, int to) { std::random_device r; std::default_random_engine e1(r()); std::uniform_int_distribution&lt;&gt; dist(from, to); return { dist(e1), e1 }; } template &lt;class Engine&gt; int random(int from, int to, Engine&amp; e) { std::uniform_int_distribution&lt;&gt; dist(from, to); return dist(e); } int main() { auto [i, engine] = random(1, 5); auto j = random(3, 7, engine); auto k = random(5, 8, engine); } Or something. Probably want to template the function to use the correct distribution depending on whether it's a real or an int, but that general idea.
If you take a look at the last few minutes of the talk, you will see that the only differences in C++20 are: - `()` does not call `std::initializer_list` constructors; and - `{}` does not allow narrowing conversions. This means that you can use these forms everywhere: ``` auto w = Widget(2, 3); Widget w = Widget(2, 3); // e.g. data members ``` Personally, I don't find narrowing prevention very useful because you don't get it on non-constructor functions anyway.
&gt;format("{0:%Y-%m-%d}", t) Holy moly I'm excited. Maybe 20 years from now I'll actually be able to use it :/. we're still stuck with C++03 over here and I think it is beyond ridiculous
I personally use mix of all types. Equals sign for scalar types (including references) and lambdas. Parentheses for classes (no parentheses at all for default constructor to avoid most vexing parse). Braces are only for aggregates and constructors that take initializer\_list.
Can't you call intializer\_list constructor using (\{\})? Or it was changed in C++20?
Hmmm iirc the unofficial cpp guide recommended brace-initialization everywhere, but now it sounds like you and Timur are recommending parens-initialization?
So you're saying the "elegant" way is to have a distinct syntax for each "type" of initialization?
&gt;Prefer {}. The rules for {} initialization are simpler, more general, less ambiguous, and safer than for other forms of initialization. &gt;Avoid () initialization, which allows parsing ambiguities. If you use Almost Always Auto, the only thing that still holds true here is that `{}` is technically safer. Someone can correct me if I'm wrong, but I don't believe `{}` provides any safety you can't get with compiler warnings.
You can if you like.
On a side note, while I don't use AAA, I find the anti-AAA crowd reminds me of [Mr. Incredible](https://www.youtube.com/watch?v=3QtRK7Y2pPU&amp;t=12s)