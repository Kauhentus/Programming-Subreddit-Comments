I've been using vcpkg for a few months now and it's really awesome, apart from one or the other problems with OpenCV and some other computer vision libraries (dlib, Ceres). Also I unfortunately had things break quite a few times when packages got updated. But it looks like this is improving and overall it's a really fantastic tool, and I hope Microsoft continues investing into it. &gt; Using vcpkg to target Linux from Windows via WSL I'm really excited about this! That's actually a killer-feature. It's also nice that the vcpkg installation can be shared across Windows &amp; WSL. I'm excited to try this.
Got it thanks! Super helpful
Yeah vcpkg just installs by default the x86 versions. You can override it to install the exact version you want though. And I think you can set an environment variable to do that too (override the defaults).
I am not sure this really happens. It has been my experience that managers do not read hackernews or r/programming. Certainly, I do not know any. I do know a lot of managers that are familiar with TIOBE index and similar reports. I think it more likely that the desire to use fledgeling languages mostly comes from new developers in their first 5 years or so in the industry.
I do not personally have anything against Rust or Go. I can only tell you my experience. I know someone fought really hard to use Rust on a project on another group at my work and in our postmortem of that project it was considered to be a mistake. My company has significant C++ experience and it was decided that at minimum the benefits of Rust were marginal enough that it was not worth having to teach a large number of developers here the ins and outs. There may come a day when Rust reaches critical mass, but that has not happened yet and I am old enough that I do not really have any interest in it until it does.
[quasardb[(https://www.google.de/search?q=c%2B%2B++edouard+alligand)
C++ is old and one of the most used languages in the world. Rust is new and trying to gain adoption. It doesn't make sense to look for the same kinds of stories for both languages, they're in very different stages of life. &lt;Big Company&gt; switching to Rust is a news story. &lt;Big Company&gt; using C++ is... yawn.
https://github.com/QuantStack/xtensor have numpy similar functions semantics 
This appears to be closed source. Anything I can read about how C++14 helped ?
I am more interested in new companies using C++. Old companies having old C++ code moving to newer versions is quite natural and highly unlikely to be replaced.
&gt; You can override it to install the exact version you want though Thank you for the answer but I still feel default behavior should be changed for Windows(it offers you to install all, you can pick subset if you are sensitive about disk space). 
I had looked at it few years back. Seems like its doing pretty good.
Can you compare it to other package managers like Conan? I had a brief experience with Conan and evenhaving low expectations I find it kinda disappointing. 
Where do I find the transcripts so that I can actually see code into an editor?
Not a chance, no.
For me, this is great news!
I hope so
&gt; Well you CAN set the environment var in your profile settings once and for all. AFTER you told me to do it. That is my point. It is not that problem is hard to fix when you know what it is... But when you are sitting there like an idiot and adding and removing boost to your #include paths... it does not help that much :P 
If you are taking suggestions another thing that would help noobs is this: if intellisense detects header usage of some popular lib but the lib is missing it could offer the vcpkg installation of the package. I know this sounds trivial to you, but often college students just c/p examples and wonder why it does not work... 
Thank you for throughout explanation. To me, Pros #3 is a crucial requirement. My biggest complain with Conan was that I have to alter all CMakeLists.txt files to reflect the new way of obtaining the library dependencies. I hope vcpkg also have some support for Qt .pro files too. About Cons #1, is it possible to pin down to a specific version of a library just like what nuget does? It would be really annoying to have a single global version of library. I've always thought vcpkg is not mature enough to employed in enterprise and heterogeneous environments, but given their recent support of Linux and the features you have pointed out, I might give it a chance. It may suits our needs with less complication compared to Conan. 
Not very statistically significant, but: https://twitter.com/meetingcpp/status/974276661645635584 
Err... It's _very_ early to say if Conan or Build2 (this one is not considered ready for business yet) are successes or failures. I wouldn't bet on anything right now, considering the next 10 years, even if I have a preference.
`std::reverse_iterator` requires `BidirectionalIterator`, which might be harder to do than a `ForwardIterator` and doing `reverse_iterator` with additional knowledge. It probably is always possible to transform the two, but well, optimisation and flexibility, as always. 
Read the sidebar on r/cppquestions . This probably would do better there. All of your operators are 1 character, so I wouldn't bother using numbers. operation could simply be of type char. And you could use a switch instead of if statements. And that would make it easier to pull the cout statement out of the conditions `std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; operation &lt;&lt; ' ' &lt;&lt; y &lt;&lt; " = " &lt;&lt; answer &lt;&lt; '\n';`. I'd include a line ending on the end of the Thank you line.
 #define PRINT(x) cout &lt;&lt; #x &lt;&lt; ": " &lt;&lt; x &lt;&lt; endl ... int hello=1; string there="2"; char how='3'; PRINT(a); PRINT(b); PRINT(c); output... hello: 1 there: 2 how: 3
An unusual possibility, I guess.
This costs a thousand reais in Brasil. A thousand reais is the minimum wage. 
Not using it.
FYI, to fix the the huge bold text in the original post, you can escape the \# symbol by prefixing it with a \\, as in \\\#.
why ?
I generally like the convention of never using the word `get` in my accessors. Just the noun itself is sufficient, and I tend to group them in the header for visibility. Also, I strive to never have members with `set` in them. A raw setter has a code-smell for what should likely be part of a more specific verb (for example, `resize` and `reserve` over `set_size`).
I haven't tried Conan yet to be honest (I'd like to, because it looks nice too). But what I like most about vcpkg is that it is non-intrusive, and it plays very well with cmake's standard `find_package` mechanism. Now that vcpkg is cross-platform, I see less need to try Conan, but still might. The one thing that's a bit of a shame is that because vcpkg is source-based, it's not really too suitable for CI, as you don't want to build OpenCV, Boost, dlib, Ceres etc. on each commit (it takes ~20mins locally, probably well over a few hours on CI). I know that you can cache things on AppVeyor/travis but the free versions usually only have around 1 GB of cache, which is not nearly enough to cache an OpenCV, Boost etc. build. I saw recently that AppVeyor has vcpkg pre-installed, but I haven't had a closer look at it - but I doubt they are prebuilding all packages.
You can sort-of go back to a previous version or pin a specific version by pinning your vcpkg to a specific commit. But that often doesn't work of course, because it doesn't allow you to mix-and-match an older version of one package with the latest version of another package. In any case... "Live at Head"... ;-)
I would do everything I can to avoid the preprocessor in C++, but `#x` is great in pure C. I've (ab)used it to write macros (templates) for intrusive containers. Something like typedef struct{float r; float g; float b;} pixel_t; //defines a type and set of functions with suffix P DEFINE_LIST(pixel_t, P); list_P_t pixel_list = create_list_P(); push_back_list_P(pixel_list, {.r =1, .g=0.75f, .b=0.75f});
it would be nice to be able to get rid of at least many of the uses of integer_sequence, too Also, I see what you did with your title.
&gt; I am more interested in new companies using C++. Old companies having old C++ code moving to newer versions is quite natural and highly unlikely to be replaced. I see. Your reply to one of the comments would have helped if it were in the original post :) &gt; I am more interested in new companies using C++. Old companies having old C++ code moving to newer versions is quite natural and highly unlikely to be replaced.
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8enopm/basic_calculator_in_c/dxwrany/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Why only static linking on Linux? Will that be changed in future? 
Yes, I know about the problem. With our current payment provider we don't have the possibility to change this, e.g. define prices per country. And even if, we would have to make sure it won't get exploited. How do other software vendors deal with this?
&gt; Also, I see what you did with your title. Actually it was not intentional, but I typed a lot of T... in the past couple of days, so maybe it stuck in my brain. :)
I think for that kind of things we need packs outside of templates. I think there was a proposal for that.
Interesting, do you mind raising a GitHub issue with the minimal set of your project that is causing this issue? I would love to test this on your project \(if it is open source\) and fix the bug.
Oh cool, I personally don't have any experience with Obj-C/Obj-C++ or Swift at this stage. I suppose you just need to figure out how the `include` mechanism works in these languages to add support.
I was thinking about `std::initializer_list`. I think it should have been some kind of tuple, unpacking itself when constructing an object. Then, the brace initialization syntax would have been an equivalent to: SomeType{"abc", 3}; // Equivalent to SomeType(initialization&lt;char const*, int&gt;("abc", 3)); // Equivalent to that, unpacking itself SomeType("abc", 3); Why all that? Because then constructing a type with braces would be the equivalent of constructing a type using parenthesis. Also, it would allow braces to be deduced: struct A { std::vector&lt;int&gt; vec; float f; }; auto p = std::make_unique&lt;A&gt;({1, 2, 3}, 6.0f); auto args = {{1, 2, 3}, 3.f}; auto a = A{args}; // recursive self-unpacking Right now templates cannot deduce from braces only. Does that fix the `std::vector&lt;int&gt;{1, 2}` fiasco? Maybe yes, if such code end up an ambiguous call to constructor, but making it ambiguous would break a lot of existing code...
Wow! Yea I can imagine it would have taken a lot of work to optimise the tool to be performant on very large projects (like Chromium). The parser optimisation is neat, reading only up until the point you absolutely need to! Having written the tool in `Ruby` you are far removed from these types of low level optimisations (and also Ruby essentially being single-threaded because of the GIL). My first stab was always going to be in Ruby and I was thinking about porting it to C++ at a later stage. However I can instead bring the improvements to `cpp-dependencies` if that's okay with you. Since the view code is completely separate as you mentioned, how about as a first step I bring `d3.js` support to `cpp-dependencies`? The way I do it in my project, I have a `template` d3.js view, with a placeholder for the JSON data. Once I have the dependency graph info, I render it to JSON and replace the placeholder in the `html` file with the actual data. Quite simple really. I have some other plans on how `d3.js` can be used to render different types of visualisations (not just a node/connection graph).
Guauh, since release i wanted to use it, now i can, thanks MS, good work, keep pushing
Heh. To be fair you did come to a C++ forum and ask bunch of C++ enthusiasts a question that amounts to "Rust and Go are really good, do you guys think C++ is as good as Rust and Go?" I am not sure from your question if you did this because you were arguing with a bunch of Rust folks and wanted ammunition or if this was yet another attempt by the Rust/Go community to try to convince C++ developers that Rust/Go are better. If you are really interested in gaining some understanding then I apologize, but given the lack of effort you have given responding to the people that actually answered your question this seems unlikely. If this second is the real reason I am sorry to inform you that the reason we are not all using Rust/Go is neither because we do not know that they exist nor is it because we do not know what features those languages support. You are only the nine thousandth person to come here trying to stir up a discussion about Rust or Go. It never goes well. This community contains C++ standards committee members, C++ library and language implementers, people that travel on their own dime to C++ conferences... There are no easy converts here. No one here wants to seem close minded, so they will humor you to a point as long as you are respectful, but no one here is uninformed, if your goal is conversion you should try an easier to find an easier field.
Isn't that just for that particular library(sdl)? I don't think thats for everything (unless i misread something).
Will take a look. Will the available package list match the current windows ports list (where compatible)?
AppVeyor isn't prebuilding any packages yet, but have you taken a look at `vcpkg export`? We can produce a single, self-contained 7zip/zip/nuget file with all your dependencies that can be downloaded and unpacked during an appveyor build. You can host that deps archive anywhere you want, such as GitHub releases or NuGet.org
We only support static linking for now because dynamic linking has significant implications for distribution. On Windows, it's a simple story: copy all the DLLs into the EXE folder. On Linux, there's rpath/LD_LIBRARY_PATH/etc. Static linking avoids this problem because we don't know how to solve it well yet, but we would love to support dynamic linking in the future!
We do accept prebuilt binaries in limited circumstances, but we prefer building from source (for many reasons). Our recommended approach for prebuilt binaries is to use `vcpkg export` exactly as you have suggested!
We fully support side-by-side copies of Vcpkg, each of which has a completely independent graph of built libraries and versions. This makes it really easy to "lock" the dependencies of a project -- just keep using the same Vcpkg commit.
Having used neither of these options, what would make one better for novices or for production?
Cool thanks for the feedback. The markings would be useful. An option that could be added to the search command to display this additional info could help?
Yep, that's one of the contenders!
great! I really look forward to trying it out. 
I thought about this problem a little more. I think the best solution will be to offer a discount, something like "international equality discount", similar to the one's we already offer in the lower section of our store \([http://sourcetrail.com/buy\-license](http://sourcetrail.com/buy-license)\). But this discount wouldn't be a fixed percentage, but depend on the residence of the applicant. However, I have to discuss this internally first.
is is worth doing something like homebrew where it creates sym links in /usr/local/* or even edit the rpath in the executable?
Those are interesting ideas, but there's still a lot more to think through: what about conflicts with brew? What if the user wants to put the results on another machine? If you think you have a solid story, I'd love to see a fleshed-out issue posted on our GitHub!
`grep -r myfunction /usr/include` 
&gt; somewhere buried on the page It's the first thing listed after the name? That's not really what I would call buried...
Because aside from `#include`, there's almost always better options in C++.
Oh wow, how could I have missed that! That's so awesome. Particularly this: &gt; Alice gives to Bob: a) The links to her project and b) The zip file "vcpkg-export-20170428-155351.zip". Bob clones the project, extracts the zip file and uses the provided (in the zip) CMake toolchain file to make the dependencies available to CMake. (from https://github.com/Microsoft/vcpkg/blob/master/docs/specifications/export-command.md). No more manual building, zipping, uploading &amp; managing in AppVeyor. Nice, thank you!
Allow me a question: So if I build a package, let's say in a local WSL (Ubuntu 16.04) or on travis (14.04), with the vcpkg linux-64 toolchain. On what Linux distributions can I expect the resulting binary to run? Only on other machines with the same distribution (e.g. 16.04), or on others as well, if everything is statically linked? (In particular I suspect running on newer distros than the one it's built on should be fine, but what about building e.g. on WSL 16.04 and running on 12.04, old Fedora, CentOS, etc.?
That's not a good idea. The file where a function happens to be implemented in the current version of your current toolset isn't necessarily the header that the Standard says you should include.
As it stands now, I hope not. There seems to be no way to do proper dependency management with it (If there is please enlighten me!). 1. You have your ports tree and everything is installed into it using the latest available version. 2. There's no easy way to revert to an old version. You have to potentially checkout the old build scripts separately. 3. Having multiple versions of the same library is only possible by using separate trees which duplicates compilation effort required for other dependencies. 4. There's no way to specify in your project what dependencies at which version you actually want to use. Vcpkg magically integrates with the build system and makes installed libraries available. Great for fooling around, but not for proper development IMO. For MSBuild there's a way to manually "export" a tree which creates a file one can include in their own project. But this file cannot easily be shared since it hardcodes the paths to the tree. For cmake one can at least still use the ugly find_package macro to list dependencies.
In my experience, Vcpkg tries to be as straightforward as possible. It's very easy to install a package and start working with it via CMake or Visual Studio. Where it starts to break down is mixing and matching settings (e.g. I want google test linked as a shared library, but fmt as a static one.). Microsoft also maintains the package repo, which means that the libraries there are high quality ones (good for novices), but it's harder to build a custom set of packages for internal production use. Conan has a few features that make it have more of a learning curve up front, but make it more scalable and flexible. It supports linking (and other settings) on a per-dependency basis. It's build-platform agnostic, which allows companies to keep what they already use--and also makes it easier to package pre-built binaries. And it is much more amenable to setting up an in-house server of packages (e.g. with jfrog's Artifactory server). 
&gt; To add a method that inserts an element at the end of your container class, call it push_back. Not pushBack nor add nor even append. But... but... My camelCase!
https://www.cs.vu.nl/~herbertb/download/papers/delta-pointers_eurosys18.pdf
Unfortunately, Linux is a really diverse platform so it's hard to give a concrete answer here. We expect to provide most libraries above the CRT, so as long as you're using the same glibc version and same c++ runtime, it should be possible. 
I save a copy of the Standard (actually the current Working Paper) so I can just search through it. The Library Standardese is very readable if all you want to know is "what header should I include for `std::meow`".
Does it have signed packages and how does the public-key-infrastructure work? If it doesn't, that means it's just another completely useless package-manager that's broken by design. 
/u/raevnos may be (rightly) advising against using object-like macros that are resistant scoping, function-like macros that can display some funny behavior with expressions if you don’t know what you’re doing, and so on. Using macros for text replacement is a [dangerous](https://gcc.gnu.org/onlinedocs/cpp/Macro-Pitfalls.html#Macro-Pitfalls) practice that should be avoided where possible. 
IIRC you are supposed to do something like: ```cpp using std::begin; using std::end; auto b = begin(container); auto e = end(container); ``` So that ADL will trigger if appropriate. Can anyone more knowledgeable comment on that?
Good news. I love vcpkg, thanks. 
In generic code, yes, but if you _know_ the type of `container` then it's just noise. N.b. if you use range-v3, `range::begin` and `range::end` use ADL internally so it Just Works™.
Can you give hints to cpp-dependencies to resolve ambiguous paths? 
If you're on a UNIX-like system `man &lt;function&gt;` will show the header needed in the first few lines, typically under the heading `Synopsis`. You can also use `man 3 &lt;function&gt;` to specifically look up library functions only (and ignore syscall documentation) 
Unfortunately it's not as up to date as it could be https://repology.org/metapackages/?inrepo=vcpkg&amp;outdated=on
If you use vim, then shift+k brings up the man page for it
How does it compare to Conan? There is support for cross compilation? It supports or can be easily integrated with Meson. I left CMake some time ago for my own projects. Meson kicks its ass out except for XCode/Visual Studio code generation.
not T&amp;&amp;...?
FYI, this: vcpkg export opencv boost dlib ceres --triplet x64-windows --7zip results in an 175MB file which includes debug and release for 64-bit. 
This issue has been fixed in latest master. Thanks!
\#include. I don't use anything else unless someone really pulls one of my teeth. Which doesn't happen often. So no preprocessor for me other than that one.
my bad, it was "annotations" not "attributes".. https://github.com/xaxxon/v8toolkit/blob/master/class_parser/annotations.cpp#L53
Can we just appreciate the effort that Microsoft is doing recently to include Linux developers. VSCode is becoming one of the most popular IDEs right now and arguable the best cross-language IDE on Linux. 
C++17 fold expression make redundant ugly use of std::initializer_list. You could use (func(T), ...) instead.
TLDR; The technique uses a part of the pointer to make its representation invalid if pointer arithmetic overflows, thus crashing the program on dereference. It uses the requirement of x64 architecture that all pointers are in a canonical format, which will not be the case if a pointer goes out of bounds. It offers a trade-off between available virtual address space and size of the objects. If you want to fully use the 48-bit VA space on x64, your buffers are limited to 32k (15 bits + 1 bit for overflow detection). In the default configuration, the split is 32 bits for tags and 32 bits for address (= 4GB of available address space + 2GB max allocation size). This also negatively impacts address space randomization. The technique is also problematic to use when calling non-instrumented libraries and the kernel; there's a brief discussion about this in section 5.3, but no concrete solution is offered. Runtime overhead is ~35% with zero memory overhead which compares favorably against other techniques. Interestingly, Intel MPX (hardware-based solution) has 139% runtime overhead and 90% space overhead (bound tables). The MPX numbers are based on another set of benchmarks. 
Try http://devdocs.io/cpp/. It's en.cppreference.com in a different form. I'm also using http://devdocs.io/cmake/, which is way faster than the official CMake documentation.
&gt; On Linux, there's rpath/LD_LIBRARY_PATH/etc. Why bother solving this? One would think that Linux/OSX developers are accustomed to setting their env properly. vcpkg is a package manager, not a deployment tool. 
Where do they recommend east const? All examples in the guide lines are using west cost const. 
That sounds like an awesome proposal! Do you know, what its current state is or where I could look that up?
Actually I made one assumption. It is based on the fact that about once a month (it used to be more common) someone comes on this forum looking talk/argue with people here about Rust and or Go. As someone that has been a member of this community you should have known that. If you wanted to talk about C++14 success stories the natural thing to ask would have been, "what are some C++14 success stories." There was no reason to bring up Rust or Go (which as a member of this forum for 2 years you should have known were touchy subjects) other than to stir up controversy. The manner in which you replied to my post has not convinced me that my assumption was wrong. In fact quite the opposite. Good luck.
Yeah, it depends on which implementation and/or version of libc and/or cc you have. Compiler headers are in a totally different place. And they even redefine things like `size_t`. Trust only documentation.
Right now you can blacklist files and folders to ensure those are not taken into account for the dependency graph, but that's not solving just the ambiguity. As a developer, I'd rather fix the code to not have ambiguous includes. An include is ambiguous if your compiler will find a different file to include depending solely on which include paths you have and the order of your include paths. I'd be as confused as my compiler if I see an include that matches two files; I'm not one to read compiler flags when reading code.
Sounds good to me to bring those improvements. My first stab was a shell script that took 2 hours to run - and because it was useful a colleague ported it to Python that ran in 5 minutes. As a C++ guy I figured "I can beat that..." and tried it in C++, to get a 20 second runtime on the first attempt; later brought down to 1.9 seconds. The d3 code can be added as a separate unit; for example, there's already Output.cpp doing the Graphviz output, and CmakeRegen.cpp doing the CMake output. You can add a D3.cpp file there that does D3 output &amp; hook it into main as another output. I'd love to learn from you how the D3/JS stuff works.
http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-const This rule is wrong because it _strictly_ tells you to use const west notation because it can confuse beginners otherwise. You can check out an interesting blog post regarding that topic called "A Foolish Consistency" from Mr. Kalb. 
This.
That.
Nice ! Though I fail to compile several packages on mac. e.g. 1) ./vcpkg install mongo-c-driver file RENAME failed to rename /opt/vcpkg/packages/libbson_x64-osx/lib/bson-static-1.0.lib to /opt/vcpkg/packages/libbson_x64-osx/lib/bson-1.0.lib 2) ./vcpkg install libuv Error: Building package libuv:x64-osx failed with: BUILD_FAILED (portfile trying to find Windows.h) 3) ./vcpkg install folly CMake Error at scripts/cmake/vcpkg_fixup_cmake_targets.cmake:42 (message): '/opt/vcpkg/packages/libevent_x64-osx/debug/cmake' does not exist. etc
&gt; Sadly I don't think c++ will ever get any form of build packages. There is a new WG21 study group dedicated to making a standard build and packaging system. See http://www.open-std.org/pipermail/tooling/
Is VS a requirement on windows platforms or can one use a gcc based compiler like mingw? 
Yes, brace initializations is one of the modern C++ feature that I strongly not recommend, in my own conventions I allow them only when it has a really usecase, e.g: std::vector&lt;int&gt; v{1, 2, 3}; f({ abc, def }); // function that takes pair/tuple return { ghi, jkl }; // same as return
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8es6nh/armadillo_update_element/dxxni2n/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
So, what header *should* I include for `std::meow`?
I've used this kind of pattern (but in UE4 - I've translated it to standard C++): template &lt;typename...Args&gt; void game_log_internal( const std::string&amp; filename, const int line_number, const std::string&amp; function_name, Args...args) { std::cout &lt;&lt; filename &lt;&lt; ':' &lt;&lt; line_number &lt;&lt; " - " &lt;&lt; function_name &lt;&lt; ... &lt;&lt; args; } // This bit is non-portable, because the macros aren't standardised. #define LOG(...) game_log_internal(_FILE_, _LINE_, _PRETTY_FUNCTION_,__VA_ARGS__)
Cool! I'll definitely be switching my AppVeyor build over to this.
Oh, sorry for my skepticism, but they have too many groups without any real progress. A 2D graphics one had an epic failure, for example. Networking is going to be the next, perhaps. 
Okay! That's sort of what I expected :-) But great! Probably more or less the best that one can achieve, without horrendous effort. Thank you!
eel.is/c++draft
Sounds like new `&lt;animal_traits&gt;` header. I'm wondering whether they will add `std::cat_traits&lt;Animal&gt;::follows_red_dot`.
What about IDEA or even Sublime?
Who did told you to use camelCase? Beside's it's u n p y t h o n i c it's in conflict with standard library naming. Also, `find_first_not_of` is much easier to read than `findFirstNotOf`. I heard there were some controversies regarding `System.IO` in C#. Microsoft stated that for 2-letter names they should be full caps. Best exericse: try to make `std::student_t_distribution` camelCase. 
It's almost like not everything is guaranteed to be a success.
This sounds as bad of an idea as using the top bit of a 32-bit pointer for shenanigans was. Now Windows has to have a flag in 32-bit executables to say whether they can safely use the entire 32-bit address space or only the lower 2 GB or not. It may work now, but it could cause all sorts of interesting crashes in future.
IWillNeedToFindBackSomeStudiesWhereItWasStatedThatSpacedTextIsEasierToRead.
What sense does it make for Vcpkg to support Linux? Sure it comes handy on operating systems where no native package manager exists. But this is Linux. Package managers are fundamental to every distribution as they have been literally built around them. We know our shit. Aside from the obvious waste of man-hours on your side, these efforts may even make novice programmers fall for the idea that they can develop software under (and for) Linux without actually learning, understanding and adopting the approach your distro of choice takes on the development. *May contain traces of syscalls, hyperboles and nuts*
Graphics is not dead. It's being rebooted. I've seen the reboot proposal myself, and I have offered some advice on its structure. My main advice was to reduce its scope severely, and target its featureset at one single purpose: a browser based IDE and debugger suitable for teaching C++. It would of course have a non-browser implementation which runs much quicker, but the featureset would be HTML5 canvas, and not a shred more. Obviously that's my opinion only, what is chosen will probably not be that exactly. I may be wrong on this, but I believe that overwhelmingly Study Groups have been to date successful. Indeed, two (?) have been closed due to having succeeded in their remit. I am very sure Networking will succeed as well, though probably not in the form people think means success. Success @ ISO does not correlate well with success in the userbase's eyes. For example, any standardised solution to build + packaging almost certainly will be at the meta level, not at the implementation level.
&gt; And the biggest one is that Conan lets you specify which version of a library you want, while with vcpkg you are always on the tip. That’s a complete dealbreaker for me at least. I like to keep up to date, but sometimes new versions have bugs, or you’re a week away from shipping and you don’t want to spend a day patching a new API until after launch, or you have a new developer who comes on board and ends up using a different library version to you, with new features?
It would be nice if Microsoft as a whole made a concerted effort to move completely to 64-bit. The current situation is silly. Most people today care much more about 64-bit than 32-bit. Many of us already dropped 32-bit, or are about to drop it. It should be the default, and Visual Studio itself should be 64-bit.
We are also looking for an [Innovations Software Engineer](https://www.hawkeyeinnovations.com/news/437446) \(C\+\+, QT, Boost, CUDA, OpenCV\).
&gt; Runtime overhead is ~35% No thanks...
My favorite pattern: don't use macros.
- Google Test's automatic registration of unit tests. - Debug messages containing filename and line number. - Folly's scope exit: `SCOPE_EXIT { do_something(); };` 
First of all, I said *arguably*, second, is a Sublime a full fledge IDE or an amazing Text editor that could be used as an IDE? 
VSCode isn't an IDE either.
Fair enough, however it does offer IDE-like features out-of-the-box such as debugger or version control support where as far as I know a Sublime or Atom don't. I don't want to start arguing what is best. I will edit my original comment to reflect that this is my opinion. 
you might want to throw some periods and new lines in there. that's just one giant run-on sentence and is quite hard to read
300 hundred is a lot of libraries.
I think it was written out of passion &amp; love, hence the style. I'm also glad that vcpkg exists :)
I wouldn't hold my hopes up, since I didn't update of it. However, I think it would be really nice to have something like this in the language. Maybe it has the potential to fix \`std::initializer\_list\` by replacing it with \`\&lt;T...\&gt;\`? 
You can't imagine the joy that you can now meaningfully use STL algorithms 
The only major issue I can point to now to is the build time
Yeah, I'm sad to see this. For my own projects I tend to stay at the bleeding edge, but I'm mostly a solo coder so I only have myself to worry about. Being able to pin dependencies to a specific version would seem to be an absolute must these days?
Cmake made it possible so don't forget to thank cmake. I think modern cmake is the greatest thing that's happened to c++. Now let's just hope autoconf, boost build and custom build systems (qt, OpenSSL, icu) goes and diaf and are never remembered or heard from again. 
Customizability (is this a word?) with packages. Once the extensions and customization settings in VSCode are on par with Atom, then I will switch immediately. I have a beefy laptop so I do not have the slowness that others experience, but Atom's instability drives me crazy. I did a personal Atom v VSCode v IntelliJ v Sublime and I think VSCode is the way to go in the near future.
 &gt; a browser based IDE and debugger suitable for teaching C++ So...... we're going to include Firefox in the C++ standard? I'm failing to see how that's a good idea.
Thank you for that comprehensive answer! Honestly being tied to the latest version at all times is quite awful. I wonder why they went with that decision instead of being able to pin a fixed library version. So yeah I guess I agree and Conan would be way better simply because of that point 
And let's hope the CMake language gets a gradual overhaul. As much as I love CMake, the "language" could really use improvements. 
How comparable is the feature set to Gentoo's Portage standard, and the three different implementations : Emerge / Paludis / Pkgcore ?
&gt; vcpkg is a package manager, not a deployment tool. What's the difference? One installs a dependency graph to a directory hierarchy, the other installs a dependency graph to a directory hierarchy.
Embrace... Extend... ... That's the reason.
I think it makes sense from a cross platform perspective. If I'm trying to make software for both windows and Linux, it helps to have on way to get dependencies between the platforms
Then what's the solution here?
Note that this is the average; there are better and worst cases. I look at it as a possible improvement to sanitizers, personally. Not something I'd run in production, but nice tool for the contiguous integration.
Thanks for the explanation. 
Granted it's a bit awkward to get started with, but once you've written enough of them it all kind of falls together.
 Is the Commercial License for 1 year of use or for an infinite amount of time + 1 year of updates?
&gt; What's the difference? Deployment tool should be able to relocate the files. Or flatten the directory hierarchy so that the deployed application is in a single, self-contained directory. However, libraries that come and need their data files are often compiled with a hard-coded install prefix so you can't deploy them to a different location without recompiling them. 
I used to do that as well, but got bitten once when it was wrong. These days I'm very happy with cppreference.com ...
I think the issue is one of documentation coupled with the usual cruft that happens over time. Mathieu Ropert did a talk titled [https://www.youtube.com/watch?v=eC9-iRN2b04](Using Modern CMake Patterns to Enforce a Good Modular Design") and it does a great job of describing how you're expected to use modern CMake. And in general CMake seems to be pretty sane in terms of what it expects and how it expects you to express it, it's just finding it while there's so much documentation about the older stuff. imo, the thing CMake lacks the most is good tooling around it. I should be able to add C++ files to an existing project consistently using CLI tool, for example, instead of having to do it manually, or rely on globs or 3rd part IDE's which ultimately do the bare minimum and eventually force me to take over doing it manually anyway. We as a community really need to come up with a set of guidelines on how CMake files should be done in various situations so that such a tool can reasonably be built and used.
By the way, was there anything that has been merged from groups to the standard? I remember TR1, but was it from a dedicated group or just a collection of standard extensions within the WG21?
I don't really see those as meaningful distinctions. I mean, I think we agree in principal that there's no reason to solve the rpath/LD_LIBRARY_PATH issue for vcpkg, but probably not for the same reasons. &gt; Deployment tool should be able to relocate the files. I think both any package manager, deployment tool, or dependency installer, in the general sense should be able to install to a prefix path. &gt; Or flatten the directory hierarchy so that the deployed application is in a single, self-contained directory. This would require that the application in question is able to accommodate having the directory hierarchy flattened in this way. I disagree that doing this has any advantages when installing a program / package, and actually think this would be a harmful misfeature that's only useful on broken platforms like Windows where DLL injection is as trivial as dropping a file into a directory. Even there, the application would still need to know that it's installation directory was flattened. Or am I misunderstanding what you mean? &gt; However, libraries that come and need their data files are often compiled with a hard-coded install prefix so you can't deploy them to a different location without recompiling them. Well that's stupid. Why would they have a hard coded installation prefix? Seems like a bug in the library.
No problem. I believe that their logic was so that they can test how the libraries interact, and ensure that for each vcpkg commit everything works together nicely. Which is good for novices or experimentation, but not so good for production codebases which require more control. 
isn't cplusplus.com suppsed to be full of misinformation?
I personally have never had an issue with their documentation or heard of anyone having an issue. I also didn't say I don't use cppreference. I just said I tend to prefer cplusplus.
Solution to which problem?
To make it short, some time ago I was working on a generic function to compare strings under a certain logic that is not important to know. 
Install vcpkg on Linux or Mac and try it in your cross-platform projects and let us know how we can make it better and what is your cross-platform usage scenario.
Because teachers that got in at 27 years old stay until 60 years old and don't update their courses in the meantime. Also see indian students where they still learn using borland turbo c++ in dosbox. 
Lots of stuff. Filesystem, Concurrency, Parallelism come to mind. Never mind Feature Test, the SG producing such valuable work that all the compilers implemented them without even WG21 approving them first, and then the compilers had to remove a ton of them when WG21 killed lots of the macros off. SGs do lots of valuable work, and will continue to do so as WG21 continues expanding in membership.
I've similar seen examples too. Local university switched to straight c where previously they were teaching c++. I wonder if the language landscape is now so large now that c++ is being forgone as too complicated and takes too much time to get started. Instead schools use simpler languages like javascript, C#, Java, Ruby, Go... as a means to teach data structures and other comp sci essentials. I hope not though.
i hate cmake with a passion but I have to use it. it seems like a company like Jetbrains or Microsoft should be in charge of it instead of whoever it is that is in charge now.
std::size != std::string::size
This, and the same trend in books about programming. The first time I tried to learn C++, it was from a "C++" book published a long time ago that was basically a C book with some chapters about classes tacked on at the end. I didn't know enough to know that I was learning the wrong thing. It takes a long time for new material to supplant all the old material. See also Kate Gregory's talk "Stop Teaching C".
For what it's worth, *good teachers* keep up to date with current developments and update their course material constantly. But that's a lot of work. And many teachers in tech have other obligations that demand their time. I confess I've been guilty of this myself in the past (though not with programming).
Why not setting prices depending on where the buyer's credit card is from? Most people only have cards issued in the country they live in? (Regarding your payment processor I suggest finding something less restrictive) On a side note, I tried indexing Mozilla's Gecko today with Sourcetrail and it gobbled up almost 20gb of ram - which I of course do not have, meaning 12gb of swap. It was also very slow..
My slight worry is that using C++ without understanding the underlying concepts is pretty hard. For instance std::array&lt;T, N&gt; is specified in terms of having a C array. A string's .data() is specified in terms of the null-terminated C-string it points to. A std::vector's error messages will whine on about its allocator and using operator new in some way (say if your type does not have a default ctor). I guess as a mental model for 70% of the code I write, thinking in terms of "Modern C++" is great. But it's just too often that it breaks down and you really do need to get in there with a wrench and fix the gnarly, C-like innards. To me, something like std::unique_ptr is useful, but only because I know exactly what it's doing, and it saves me both typing and eases my worries about resource management. I don't know if my worries could be eased if I did not know how it worked in terms of allocators and deleters. I won't write new and delete, but I need to understand them. So pedagogically, it seems weird to introduce straight up std::string without knowiedge of char, or char*, or null termination, or memory. In other languages where this stuff is *truly* hidden away, this isn't a problem. But in C++ the abstractions leak too easily.
&gt; the standard is correct This statement seems funny to me xD Otherwise, I agree that `std::size()` should be consistent on arrays of all types, so it's important to know that `std::string::size()` and the size of a `char` array will be different. Maybe we could get / make a specialization along the lines of `string_size()` that uses `strlen` or `wcslen` for char arrays and falls back on `std::size` for everything else (Non-pointer)? Ideally, I'd like to have a 3rd case for arrays of anything with a `char_traits` specialization, but can't imagine any way to determine valid specializations, currently...
I'm not understanding how Vcpkg allows you to use STL algorithms meaningfully, whereas prior to using Vcpkg, you weren't able to? Could you elaborate?
I agree, it just seems like an inefficient way to teach the language, in my mind it makes more sense to teach the abstractions first and the implementations later. If you are at the level where you are just learning how to write hello world, something tells me you aren't going to be debugging shared_ptr or vector.
Sure - it's very usable - but it stays ugly.
Well, a lot of kids these days are using Macs and Xcode and Xcode 9.3’s c++17 support is pretty abysmal. I doubt that’s really the reason, but could be an issue. 
Yea, totally agree. The tooling is slowly getting there. It took a decade or more to get something rolling, but the cmake server mode is really picking up - and in the last years the tools are making leaps. Very nice :-)
I think that would be KitWare. They're very known for ITK and VTK. Both great pieces of software but the C++ is about as ugly as it can get.
That seems to be what is happening at the university I graduated from (though they never really taught C++ directly -- OP's experience matched mine)
#include &lt;iostream&gt; int main() { std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl; } Oh cool, that worked! Let me see if I can make it write my name. #include &lt;iostream&gt; int main() { std::cout &lt;&lt; "Hello, "Peter"!" &lt;&lt; std::endl; } prog.cpp:4:30: error: unable to find string literal operator ‘operator""Peter’ with ‘const char [9]’, ‘long unsigned int’ arguments ... Wait what? operator"Peter"? What's a const char[9]? There's a long there?????
Teachers that care about modern language development generally don't get stuck teaching intro courses You want to learn modern c++ you gotta hope your Games or AI teacher is up to date.
Yes I'm an Indian student and we use dosbox and it's hell pls help. I self studied c++11 not to a very good extent, but I don't understand why can't we do the same C for 11th and C++ for 12th for c++11 because we can still access most c header files.
To keep vcpkg's ports up to date. Or how other package managers do cope with that.
Some schools use C++ to teach raw memory access and other C concepts, to students already familiar with a higher level language e.g. Python, Java. The goal is not directly to train C++ programmers.
I teach a class called Scientific Computing where I teach a small amount of C\+\+. The students come from different backgrounds so I have to teach *some* language anyway. I teach a subset of C\+\+14, so at least take some comfort that it is being taught in at least some places. However, there were students in my class who had taken the introduction to computer programming class at my university which teaches C\+\+ and they didn't know *anything* about special member functions. I personally cannot understand how after a semester of C\+\+ they weren'*t at lea*st taught about copy constructor and copy assignment. So... it's a mixed bag even here.
http://reddit.com/r/cpp_questions
Also, it is a better pedagogical principle to teach the basics first. And then, build upon it. It is much easier to teach smart pointers to someone who understand raw pointers, than the other way around. The same can be said about using the string class or the vector class. They are great, but programmers should still know how to work with arrays. 
I agree with most of your points, but there are a few things I would correct. You don't need to know the underlying C model to understand modern C++ (esp C++17 with Ts's), you can easily write code that abstracts all of that away for you. &gt; A string's .data() is specified in terms of the null-terminated C-string it points to. With C++17 there really is no need to ever call std::basic_string::data unless you are implementing low-level objects, which most wouldn't do (esp. if you're learning). &gt; A std::vector's error messages will whine on about its allocator and using operator new in some way (say if your type does not have a default ctor). This has nothing to do with the C model, just someone making a mistake. You can make the argument that in order to understand how ctors operate you should know the C Model, but it can be completely ignored. Although, it is true that in order to properly understand C++ error messages, you better be a wizard. &gt; I guess as a mental model for 70% of the code I write, thinking in terms of "Modern C++" is great. But it's just too often that it breaks down and you really do need to get in there with a wrench and fix the gnarly, C-like innards. This is probably the main point why most don't really teach "Modern C++". It's really hard to truly write modern code without ever tapping into C. Yes, it's possible but you have to completely abstract your way of thinking to be in sync with the C++ memory model. And guess what that memory model is based on? C. So, in order for a programmer to explain in abstract terms how idiomatic modern C++ works, they *fundamentally* have to understand C. Stacks, function calls, pointers et al. all stem from C. C++ references are simply pointers with a few rules attached to them. Great example of this are range-for loops and 'classic' for loops. What's the difference? Well, to an average person the range-for loops *look* simpler, and in every conference you will hear how you should be using them and how they can be more efficient than classic loops. But why? Under the hood the compiler will basically replace the range-for loop with a specialized for loop, but that isn't very clear, and in order to explain it properly to someone learning C++ you have to get down to the C for loops section after all. The same thinking applies to all *modern* C++ code. There is no way to explain it without digging into C. &gt; I won't write new and delete, but I need to understand them. Precisely. std::make_shared&lt;T&gt;() is sweet, but without understanding what it's doing there's no way it's going to help you out at all.. This isn't to say that most C++ features are insanely obfuscated and written by folks who are quite masochistic. Likewise, understanding the entire C++ standard is near impossible, and most programmers haven't read it, and most programmers haven't read the STL implementation (which is chaotic and will make you go insane), and there are so many little pitfalls that an average programmer cannot cope with when learning modern c++. std::vector&lt;std::unique_ptr&lt;T&gt;&gt; will cause you headaches completely arbitrarily depending on what you T is (also if you didn't learn how and why to use that combination) See this Haskell snippet: `[n | n&lt;-[2..], all ((&gt; 0).rem n) [2..n-1]]` Prints primes, pretty simple isn't it? You don't have to understand threads, memory, variables, the heap, the stack, nothing. Written in 'idiomatic Haskell'. Now look at the "modern C++ way" https://gist.github.com/rfgplk/e5b3bb683ac7ac900d09ee74f47b4827 Alright, this is probably a *horrible* example to show off modern C++, especially since I tried to cram in as many new features as possible, but ultimately this is what most conferences, lectures, guides should tell students to use. Yet, in order to understand **even a few lines** of the mess above, you have to fundamentally understand C concepts, and why the compiler/STL is doing what they're doing. Also, in order to really, truly understand modern C++, you have to have people who know how to use the language, and pass this knowledge onto younger students. There are very few of such people out there. Thus, most people resort to teaching glorified C. Furthermore, many people are saying 'don't teach C, teach C++', but my point is that it's impossible (at least in the way C++ has been been designed). Starting with C, or at least looking at C sometimes, is necessary to help the programmer being to understand the concepts behind *why C++ is the way is it*. Because once you start thinking about why something works, you hop down to C land. Specifically escaping as many C-isms as possible is an art, and in no way doable on a grand scale, and even worse for teaching purposes. 
That's just like, your opinion, man.
This article is just a PSA that #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::cout &lt;&lt; std::size("abc") &lt;&lt; "\n"; std::cout &lt;&lt; std::size(std::string("abc")) &lt;&lt; "\n"; } outputs 4 3 because `std::string::size()` doesn't include the null terminator, whereas the specialization for `const T[N]` just returns `N`, which includes it.
I don't know, where I'm from names usually don't contain quotation marks. 
I remember learning c++ back at uni, and it was separated from the C, and done after, so by the time we were being introduced to classes and RAII we were already OK at handling pointers, SIGSEGV, and the compilation workflow. And when we covered C++, our course introduced C++98 then upgraded to C++11, I don't really remember asking why, but my take on this approach is that there is still plenty of old c++ to maintain across the industry : knowing the old ways is quite useful when you're thrown into the madness of legacy code. As for why there is so much C(+) question instead of C++ questions, I would point out that there is a bias in your sample : bad courses will produce much more online questions than good ones :)
"Modern C++" means C++11 or higher.
It is. If a university teaches C++, generally they're doing C with a few fancy C++ idioms, mainly because C-like languages easily expose pointers &amp; co necessary for implementing more complex data structures. Most general programming is done in other languages though. 
I guess that’s kind of what I meant - what extensions do you think are missing? I have pretty much everything I want in VSCode now, including rainbow parentheses!
&gt; in my mind it makes more sense to teach the abstractions first and the implementations later Almost everyone using modern C++ learned it the old way: from C or C++03/C++98. Maybe it's still a better way.
As a uni student here is my experience 1. Professors do not like the ocean C++ has become, so restrict what they teach to a subset of C++, which is basically C w/ some nice stuff as function overloading and namespaces 2. Most courses do not really focus on a language as it’s main topic. Most classes are titled “concepts of OS, intro to data management, compiler construction, etc” the programming language is just a tool and not the focus of the class. So if you know about smart pointers, that is great. If you don’t, the professor isn’t really gonna take the time to tell you about them. 3. A lot of university’s are using python in their programming courses now, so most people at my uni either use python for their high-level needs or C / C w/ Classes for their low level needs. C++ is skipped over as a high-level language since it’s not as convenient to use as Python or Java. 4. There is a small subset of professors and students who dislike object oriented languages, and thus stay away from C++. This might be a thing only at my school though. 
In such a generic function then you are operating on arrays, not some strings. So std::size would give an expected result. Null char is still part of the array. The problems is because his `compare` function was unnecessary generic for his task: ``` template&lt;typename T1, typename T2&gt; bool compare(const T1&amp; str1, const T2&amp; str2); ``` What this signature has to do with strings? He should've used something like ``` bool compare(string_view str1, string_view str2); ``` from the get-go.
There have been some really interesting talks lately that challenge that. This one is pretty good: https://www.youtube.com/watch?v=YnWhqhNdYyk
One of the major problem I face with c++ is that I was not able to build any database client api library easily, what is the point of great algorithms when I can't use them on huge data I collected from a remote dB, but now I have many options to pick from, I can get my data from the dB and use STL algorithms on them
Teaching the language is not the goal of most uni's though, its teaching the fundamental programming concepts. C exposes the most programming concepts, so abstractions that C++ gives are "opt in" depending on what they are trying to show, rather than just trying to teach effective modern C++. This is why people in uni's are using some C++ things, but most things are closer to C. Its often intentional, and the higher level stuff comes later. Despite what you may think about teaching abstractions first, I think it depends on the abstraction. Which goes to the OP's comment about seeing some, but not much.
I think one of the main reasons for this is how COMPLICATED c++ has become, template metaprogramming could be a class on its own, and many simply don't have the time to learn it and teach it. C++ also has changed fast, and many of the extra additions (e.g. some STL additions) are very rarely used even in the real world. For instance, c++14 according to wikipedia has https://en.wikipedia.org/wiki/C%2B%2B14#Variable_templates this which seems like something rarely if ever used, and only useful for constants such as Pi or E that you're attempting to cast to. A lot of features are really out there and have almost no point in most code, for example, the VAST majority of people would not use an attribute unless some sort of reflection could be performed on them, and if there was runtime reflection would have to standardize some form of name mangaling to allow for runtime reflection by adding the attribute values to the function/class, this would be a MASSIVE BREAKING change. In essence: A lot of features in modern c++ would never be used in a real world situation anyways, and complicate c++ in a situation where you're not just trying to focus on one part of it. Sure, a lot of it helps with those REALLY out there cases, but those cases are RARE.
It's a source code package manager. It downloads source tarballs and builds them. There's nothing really to "sign" here. 
Trust me, I understand what you're saying, and I agree. My original post may have been a little befuddling, but the point still stands. Of course those two aren't the same, which is even more confusing for novices! The first one would do lea/mov/call std::operator==&lt;char&gt;(std::basic_string.. (rest of C++ template hell)) while the second is a cmp (if the compiler doesn't optimize it away [it might]). The error messages produced are even worse. A novice cannot understand half of them if they don't get how something is implemented. A simple type mismatch will throw an entire novel worth of text at you, which is actually super simple to cause! Just take any STL container with an allocator, std::map or std::vector are nice examples, and insert a custom struct with a malformed copy/move constructor. Sprinkle in a few std::atomic, std::mutex, and Boom!, 5000 lines for you to parse, fun isn't it? Ultimately, the reason why C++ is always taught in conjunction with C (or at least *should be*) is because it's impossible to know C++ without C. It's fundamentally a component of the language with too many of it's constructs directly borrowing from it. If the C++ committee wants to create a superset of the C++ language, which *doesn't* require you to stare at C code every 10 minutes, they should try and implement that, because as is, you have to know C to understand C++. Truly, any course which teaches C++ without C is incomplete. 
Well in all of the classes ive been in for programming theyve been C++ to start the learning process and then they backtrack to C code to show you how it actually works so we understand rather than just copy paste code.
And let's not forget the poor soul that decided to fill the vector by pushing back hundreds of megabytes of data, then not understanding why it was slow as hell...
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8ewc0o/multi_label_regression_in_c/dxyqvah/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I think that is a weak idea that beginners should learn the most modern and advanced ways of doing things. One reason CS students have so much trouble with Java is that the amount of history between them and the machine is stupendous and it's impossible for them to see the reasons for things and build a durable scaffolding upon which to build their programming knowledge. Personally, I think students should be taught C. After learning C they will understand the appeal of std::vector and std::sort. This will also convey to them an important fact: we still have a long way to go. I can also understand the argument that students should learn form the 'top down' - and that javascript or python is more appropriate. I see no reasonable case for saying 'you should learn C++17 first'. Why not D? Why not Rust? Why not Haskell? A case could be made for all of them, but IMHO the case for C is strongest.
Yes that is what I meant I can now build database client libraries 
The problem is that all this new stuff doesn't really replace the old things. To really understand what's going on, you have to learn all those basics sooner or later. I agree with Kate that the first encounter with c++ can be made much more pleasant by using e.g. string &amp; vector instead of c_string and array, but you can't really teach smart pointers before you explained new and delete and it is similar with other things.
I'm taking some introductory grad courses right now, and they are also doing a lot of what I call "C plus std::cout = C++" type of faux C++ training. However, I think the idea is that they mostly want to get us familiar with what's going on under the hood and assume that we're smart enough to use libraries and lookup good conventions ourselves after we're out of school. Like, yeah, we're not taught smart pointers, but that's because they want us to understand what a raw pointer is and does, so we have that conceptual knowledge moving forward. But maybe I'm giving to charitable an interpretation. I am annoyed that all our threading on assignments has to use pthreads and not std::thread. Oh well. But again, the ideas transfer over.
I agree with smart pointers but not necessarily with strings. You can learn how to use std:: string perfectly well without knowing anything about dynamic memory allocation or null-terminatiion. The trouble begins when you encounter one of the edge cases, where the behavior is not intuitive and you really have to know how else.g. std::string and c-strings work in order to understand what's going on.
The Commercial License is 1 year of updates and use as long as you want.
I'm currently in a university program that teaches programming strictly through C++98. I'm not sure these points have been touched upon yet, but from what I've gathered (and learned) over 2+ terms so far, there seems to be two parts to the equation. The first part seems to be that teaching C++ in this manner makes students and future programmers aware of the implications of working in memory. Rather than sort of blindly code until a problem is solved, it's meant to provide a stronger understanding of what programming is actually accomplishing in regards to memory. This is especially helpful when working with data, notably large sets of data, as knowing what you're actually doing with the memory will help find the most efficient solutions to the problem. The second part of equation seems to be an attempt to teach students how to solve problems critically and creatively, without having to rely on prefabricated solutions. The point is to avoid using all-in-one code that might not truly fit the solution, even if it seems convenient, as there might be more efficient ways to get to the end you're aiming for. From my perspective, I appreciate learning this way. I feel like I'm gaining a really solid foundation in programming by getting a strong understanding of the basics. That said, prior to this program, I'd already had a bit of experience working with modern languages, so I was already familiar with many of the concepts we're learning. After just the first 2 terms, I feel like I have a better understanding of what those concepts are actually doing when put together in a program.
Old stuff cannot be abruptly replaced, which is part of the problem.
It was a sarcastic greeting.
[Here’s a link. I love that talk, too.](https://youtu.be/YnWhqhNdYyk)
I'm a university instructor for C++ courses that cover both an introduction to object oriented programming and data structures. I have been transitioning to C++11 and C++14 tools, but only where it makes the instruction easier, not because I need to force it in. Most students at this level are still trying to do basics of programming, and much of the new standards are heavily focused on tricks for experienced developers trying to do complicated generalized tasks. Some other thoughts: * I love the *new* keyword because CS students need experience knowing the computer is a nuts and bolts machine, and at some level *somebody* has to maintain a record of memory allocations. Even when I hammer *new* endlessly for 15 weeks, some of the weaker students still can't grasp all the syntax of *new* and its associated *delete*. * I've transitioned almost fully to shared_ptr and weak_ptr. Students love it, for whatever reason it just clicks in their brain better. * Students love auto. * C++11's chrono and thread libraries are fantastic. * I've had some success covering move semantics and R-values. A couple of homework assignments are a nightmare without them, and students start to understand why. * I heavily encourage students to use const on everything they can, and to not avoid const correctness issues in compilers by removing const but rather understanding what the const problem is. It helps them understand data types as they are coding instead of just letting it be fluff they do because they mimic. * It's hard to find good textbooks that also cover C++11 and C++14. In my data structures course, I've abandoned textbooks entirely. But In the introductory C++ course, students still need that textbook crutch, and we haven't yet found a good freshman level book that also uses C++11. * Students have only recently started transitioning to compilers that support c++11 by default. I always get two or three oddball students that insist on Visual Studio 11, or using Dev C++ (ugh!), or C-Lion but not knowing how to configure it, or some weird cygwin + Eclipse setup. (Despite my efforts on demanding certain compiler/IDE requirements, some students always ignore it for stubborn reasons.) With C++11 finally becoming more the default, I find myself not getting hung up with these few stubborn students like I used to. * I've tried to cover function pointers, functors, and lambda expressions to elegantly solve problems using the STL, and it's just too much for most students at this level. I don't want to give up, lambdas are awesome, but these are still just freshmen and sophomores, they can only be pushed so hard. 
As strange as it sounds, I don't think you can teach modern C++ in the context of a university class. At least I don't know how you could teach it without first teaching "C with classes". Modern C++ is like an airplane cockpit where half the buttons have features such as "land", "intercom", "fly to next destination". The other half immediately turn off auto-pilot, put thrusters to 110% and trust you to be able to fly fully manually. If you've never learned how to fly in manual mode and avoid crashes, I don't think you can use the cockpit. Similarly I don't think you can understand what's going on in modern C++ and avoid pitfalls without first learning "C with classes", understanding manual memory management, pointers, function pointers, etc.
I, for one, am thankful of our C-teaching overlords. &gt;!There's nothing wrong with C arrays.!&lt; Getting closer to the bone will make you aware of what the hell it is you're *actually* doing. Instead of throwing around Python objects willy-nilly or, fucking forbid, constructing 1,000 JS node lists (those things don't just pop out of fucking no where!), you can use some raw pointers. You're playing with fire, but atleast you're not killing my RAM. And as long as the damage is only self-inflicted, I'm alright with that. What I'm not alright with is "C++ Programmers." Or "Javascript Programmers." Or whatever other language "programmer." In my opinion, it's good to know C before C++. It's good to atleast know some of the low-level details before you start building castles of garbage in a higher-level language. Too often you get people that only know how to use one language to do something, instead of cultivating a mindset on how to program. With this, you're stuck with a very narrow view of the road, and you're probably already letting monsters creep up on your blindspots. But no sir ~~ree~~ *C.* If you know that std::strings aren't free as in *please take my ~~money~~ memory, I don't need it,* you're a better person for it. Too much *magic* (**coughing fit** Ruby and JS "Programmers") and no sanity, makes me like Sean Hannity. &gt;!Liable to condone enhanced interrogation!&lt;
&gt;The error messages produced are even worse. The error messages of C\+\+ templates \(and thus most of modern C\+\+ and standard library components\) are absolutely **horrible**. I attempted to learn C\+\+ multiple times and one of those times I got an error message that was longer than the terminal backbuffer just because I forgot a symbol or something like that. Was utterly shocked, put the C\+\+ book on the shelf and went back to C.
I am completing my first C++ course in just about a week when the semester ends. We used C++11 and C++14 (still not exactly sure what the differences are). I've been curious as to exactly how much different it is than just "C" code... I really enjoyed learning this language after learning Python last semester and want to continue to learn. I have seen mixed opinions on how useful the language of C++ still is, but it seems to me that it's pretty commonly integrated into a lot of technology...
See also: Why is C++ so hated? https://www.reddit.com/r/cpp/comments/8bouu7/why_is_c_so_hated/
You just ignore those parts. Classes do students a disservice when they try to teach everything they can think of. Restricting topics to just the essentials results in better retention, deeper understanding, and thus better programmers at the end of the day.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8exnqn/i_have_just_completed_my_first_c_course_how_do_i/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I was taught in Borland C++ when I started programming in high school. That was in 2007.
&gt; How do you know that the package that you download and install comes from the right source? We commit SHA512 hashes of all downloads, to ensure completely reproducible builds (even in the face of accidents, not malice)
I'd be happy to accept a PR!
We definitely don't tie you to the latest version at all times! When installing libraries, we use exactly the SHA512-checked sources encoded in the recipe. As long as you don't `git pull` new definitions down, we will never update things out from underneath you :). Using other versions is as simple as changing the file to point to the desired source version, and updating everything at once is as simple as `git pull`. 
We definitely understand the need for stability! To enable the rock-solid reproducibility needed for companies, every commit of vcpkg corresponds to _exactly one_ set of concrete versions. This makes sharing and locking extremely easy; just tag the commit and check that out on all systems. When the time comes to absorb updates, you simply move the tag forward with comfort knowing that we've tested the entire package graph at every commit :)
"great"?
Why do you think it is superior to the alternatives?
And how do you know that those were not changed as well? Either the hash receives authentication at some point (preferably via signatures), or it really only serves as a protection against accidential bit-flips and alike. In the later case you should really replace SHA256 with CRC-32 as it is faster and communicates the purpose more clearly. For purely internal stuff not using signatures is not the end of the world (though signatures would still be extremely usefull), but for anything that you pull from public sources, this really is executing random stuff from the internet. If that's what you want, you might as well start executing stuff that came per email from unknown sources.
I would also say it depends on the course. A lot of universities teach Computer Science, not Software Development. You don't need the "new hottest" to teach basic algorithms or data structures or discreet math or computer architecture, etc. Yea, it might be nicer, but there focus is typically on the topic as language is just secondary tools to explain it. But if it's a Software Engineer course or higher level programming course, hopefully they wold teach something relatively modern. 
Because D, Rust and Go all exist.
But you're still programming for windows... so there's that.
How do you get from thinking: &gt; I can now build database client libraries to saying: &gt; You can't imagine the joy that you can now meaningfully use STL algorithms 
I think in some ways cmake is similar to C++ in that there are lots of ways to do stuff and if you don't know the best practices, you're going to be doing a lot of bad stuff.
That's utterly untrue - if you're using new and delete in code you're writing now, you are doing it wrong. Even if you're writing container code, you should be using allocators; the only new one should be using is placement new. RAII types absolutely, completely replace C-style memory management, and does it as fast and more correct. Teaching beginning C++ programmers these outdated, unnecessary, and confusing practices is unhelpful. There are places for non-standard memory management; i.e., with bump allocators and the like; but C style memory management is not that.
&gt; Most courses do not really focus on a language as it’s main topic. Most classes are titled “concepts of OS, intro to data management, compiler construction, etc” the programming language is just a tool and not the focus of the class. - u/Qkb I think Qkb hit the metaphorical nail on the head. C++ is complicated and could be a course unto itself. In a lot of CS courses, 1) the programming language is irrelevent and 2) the instructors need to accommodate students of a variety of backgrounds (not all necessarily took the school's C++ class if there even was one), so they use an easier language so as not to distract from the specific course's topic.
Where can one learn modern C++?
yes and how is it a bad thing?
Well that's one problem yes. But what I meant is that even if you do know all the best practices, the cmake language is still not very good - like how things like lists, concatenation, variables etc. are handled. If you do anything more than using the standard `target_*` commands, e.g. you need some scripting &amp; stuff, things get ugly.
&gt; Also, it is a better pedagogical principle to teach the basics first. And then, build upon it. Yes, but not if that causes huge dropout rates. Many people find computer science unapproachable, go to a programming class, get presented with C pointers in the second week, and they just give up, thinking that this is what programming is. These are often people who haven't had CS in their school, or only very little, but people who might still be interested in CS - until they decide to drop out so soon because they get taught way too complicated stuff at first, instead of learning first how cool and amazing programming can be, and then, much later, maybe, learn about things like pointers.
I believe pthreads can do stuff that std::thread cannot.
I try to teach a modern-ish C++ in my courses (strings and vectors, standard algorithms, minimizing manual memory management), but there are a few things that stand in the way: * As far as I can tell, *no* textbook takes a modern approach to C++. A few mention things like smart pointers or `auto`, but just offhand. I wrote my own notes, over 1000 pages, from scratch, simply because none of the textbooks I looked at were even remotely up-to-date. * Some parts of modern C++ are the result of long debates about the best ways to do things; students weren't privy to those discussions, and thus don't understand why the seemingly-more-complicated way is actually "better". * Whatever I teach has to mesh with the courses taught by other instructors, both at my school, and at other places to which students might transfer. I can't *not* show them pointers and dynamic allocation, because odds are very good they'll end up needing them. (And, of course, there's only so much time, so talking about `new` and `delete` means I don't get to talk about `auto`.) * Sometimes the non-modern way is more straightforward. If students want to know how to get random numbers, I tell them to use `rand()`. 
...until we're far enough down the road and C++11 is legacy crud that modern C++35 is built atop. It's a pet peeve of mine when people denote versions using such transient adjectives.
Variable templates are awesome for simplifying type traits that have values. Instead of writing std::is_same&lt;T1,T2&gt;::value you write std::is_same_v&lt;T1,T2&gt; It's a small change but so much easier to do the right thing by default.
I agree with you. In fact, I believe that Python should be the language used in Introduction to Programming classes, not C or C++. It is a very simple language, that allow students to do a lot without having to worry about many pesky details that exist in C. It is great to teach about variables, loops, functions, recursion, different types of arrays, etc. In short, I’d rather teach a simple language to beginners, than to teach a complex one and try to hide the tricky parts.
While not in C++, the ultimate in testing in an open source project is SQLite From https://www.sqlite.org/testing.html &gt; As of version 3.23.0 (2018-04-02), the SQLite library consists of approximately 128.9 KSLOC of C code. (KSLOC means thousands of "Source Lines Of Code" or, in other words, lines of code excluding blank lines and comments.) By comparison, the project has 711 times as much test code and test scripts - 91772.0 KSLOC.
It seems to me that most C++ programming courses are not teach C++, but are teaching "computer programming". They tend to focus on understanding how a computer represents data, and how we can build the more useful abstractions on this very simple model. They use C++, because it is one of the languages that gives the most exposure to these low level programming concepts. There is of course a huge question of whether they ought to be doing that, but currently it's what they do.
I was at a job interview the other day, the person grilled me on the difference between delete and delete[], down to every last detail, I was surprised how many questions someone could ask about the two. But then when I wrote a class with a move constructor he was confused and had never seen a move constructor before. He even asked if I was trying to make the copy constructor when I started writing it
One of the libraries suggested for one of my uni assignments is so old that the website says it was tested with g++ 2.7 and reassures the reader that template support isn't required. It doesn't actually compile with a modern compiler (at least not without extra work). 
&gt; C for 11th and C++ for 12th for c++11 Huh? 
I TA'd a computer graphics course. One of my responsibilities was to create the template code for the assignments in C++. What was nice was that the lecturer actually asked me for tips about getting back up to speed on C++ since he hadn't used for years. Not all teachers are that self-aware. 
&gt; Why is modern C++ seemingly not being taught? An excellent question. I've wondered that myself. I suspect it is a combination of (1) "this is how I learned it", and (2) as /u/flebron suggested, it can be just a bit problematic to teach high-level abstractions before the lower-level ones that they are based on. (OTOH, does anyone teach machine language before a HLL? Or require experience designing logic circuits before any of that?) In any case, modern C++ *is* being taught. I'm a CS professor, and we teach it in our intro class for people who have already done a little programming. We cover `std::vector`, `std::string`, and `auto` pretty early, with range-based for-loops following shortly, we muck about with `std::map` and STL algorithms, and we write a few classes. Near the end of the semester, pointers and built-in arrays are covered in a short "Internals" unit. C-strings are a footnote, and `strcat` is not even mentioned. &gt; I guess my real question is, how much of C should a C++ course really be teaching nowadays. A little, I think. But the low-level-first approach is, IMHO, misguided. Students tend to stick with the first solution to a problem that they encounter. So covering built-in arrays before `vector` is a very bad idea. Instead, let's say, "Here is a good solution to a problem," and then later, "By the way, here is what is happening, under the hood."
There's a lack of learning materials. Seems like there is a niche available for a modern version of "Accelerated C++".
They should go one way or the other. (Lets be honest, is C++ really a good language for teaching?). Plain C is just fine, but your right, they do this awful mix of classes and C.
True! I also think Python is a really good language for that. The one thing is that there isn't a standard GUI framework for Python, and none that's really easy to use. Like something that makes it easy to visualize something, to plot some data maybe, or even to make a simple 2D game. Maybe kivy, but unfortunately its last release was in May 2017, so not sure how active it is any more. But it's not like C++ looks any better on that front - Qt is far from beginner-friendly. SFML is awesome though for 2D games, but not for more general GUIs/data visualization.
There is analytics on stack overflow that show what languages are asked about most often... java tends to get a boost in popularity after summer is over... beginner programming classes tend to favor java because it is a simpler language, as the things you get from a language like c++ specifically aren't needed for teaching beginner concepts. As for what I've seen about C being used a lot of is for data structures and algorithms... because most of the time in c++, you can skip needing to know how to do these things with things in the standard.
Open YouTube, search for CppCon or ACCU conferences, there are good talks for every difficulty levels, starting from writing modern C++. Of course, if you prefer plain text tutorials, there are a bunch of them on internet.
Not only C++, but https://github.com/Valloric/ycmd has quite good test coverage, though most tests are integration or e2e.
The way my program taught intro to C++ was by introducing the basic building blocks you mentioned, arrays, chars, etc. Then moving into the more modern features that you would see today. For me, it really helped give intuition into what the computer was doing when calling the advanced features, which I believe is necessary when learning C++. 
It could be a biased sample: maybe all the schools that teach modern C++ don't have a bunch of really confused students jumping on Reddit/stack overflow...
That'be closer to Java (still faster on avg.).
Relevant: at my school, C++ used to be taught. Now, Java is exclusively used for everything here. I personally learned C++ first, but it seems that for educational purposes (in high school at least - colleges aside), Java is taking over, possible because of modern C++ getting more and more complicated.
I assume grades. Like grade 11, grade 12, etc...
Well cplusplus.com does not have information for C++14/17 features, and for older features it does not incorporate defect reports. E. g. it says the return type of [`std::async`](http://www.cplusplus.com/reference/future/async/) is `future&lt;typename result_of&lt;Fn(Args...)&gt;::type&gt;`, but actually `Fn` and `Args` need to be decayed.
[https://github.com/dreamworksanimation/openvdb](https://github.com/dreamworksanimation/openvdb) OpenVDB is an open source library for the storage and manipulation of volumetric and particle data. It is primarily used in the visual effects industry. Super fast. Super Cool.
We do c++ but with c concepts in 11th grade (no classes) and rest in 12th (like c++ pointers and mem allocation, c++ style file handling and ofc oop)
It's on a specific benchmark that has a lot of pointer access, depending on the program the effect would not be as big. Plus you could selectively use it on some specific allocations, you don't have to hijack every allocation.
Use parallel builds, such as what `ninja` gives you. If you are also careful with how you structure your project, it's possible to get fast incremental builds. Whenever I make an edit, the build time is roughly 5 to 10 seconds, which is really not that bad. I also have it set up to build whenever I save, so the perceived length of time is less.
And they are supported by the Luddites who pretend that rejecting new languages/tools/libraries/standards is somehow them being mature developers, rather than them becoming dinosaurs.
&gt; Local university switched to straight c where previously they were teaching c++. From what ive seen interviewing, teaching students practical programming skills is not the primary goal of most local universities.
I think that sounds like a nice intro. Iterators and their relationship to the various parts of the STL would also be a nice addition if you dont already do that.
Yes, most of those teachers were not prepared to teach C++98 either.
Ehhh. If they are going to write programs utilizing the STL, they are going to want to understand the different reference types, copy/move semantics, and some of the basic type deduction rules for templates etc. Those things are a bit of a moving target as the STL evolves. 
The developers I work with still don't get RAII. If they haven't picked that up, I doubt lambdas, move semantics, and unique pointers are going to sink in anytime soon.
It’s gotten a lot better with clang. Not amazing, but better.
The other half is there's not much young blood in C++ writing fresh articles on new C++ stuff, compared to a more popular language like JS or whatever else. People aren't putting articles out there that are easily digestible and so you're not able to find good resources on modern C++ without reading the spec.
&gt;It is much easier to teach smart pointers to someone who understand raw pointers, than the other way around. Maybe unique_ptr, but shared_ptr is easier to learn than raw pointers. We think raw pointers are easier, because we learned them first. Teaching teens shows that modern C++ is easier to learn than C. This seems so utterly backwards, even for me, because I learned C first too, but apparently modern day C++ should be the 101 and C should be the 102. Much like assember was the 102 for C.
I would advise never to go without cppreference. cppreference tells you what's 11, 14, 17 and 20. ie, after compiler errors. You will also need to get comfortable with the idea that the compiler errors are going to teach you about what is and is not possible. You may think languages like C# is easy, but how much do you actually know, compared to how much you rely on tools to fill in the details?
Ive used Dev C++ with mingw for large projects and dont get what the hate is about. Just have to set c++11/c99 flags and good to go. 
There's nothing wrong with compile-time sized C arrays. But dynamic arrays? Everything is wrong with it. C throws away the compile time type information at the very first step of allocating memory. There's nothing wrong with `std::vector`, especially considering how many home-grown resizeable C-array implementations there are. Swallow your misplaced pride. There's nothing smart about manually rewriting basic things that have already been solved.
That is not what was said at _all_.
In some circles (mine), C++11 is already legacy. It's great, but it's missing many features for usability that C++14 fills in.
I think auto should be left for people who fully understand types and casting. Auto makes things too easy, and of the data type is not easily discernable then it can add some difficulty to working with the variable. 
Possibly because of the preponderance of OSS C projects out there, and of course all the low level stuff is still in C. It's still a very powerful language, after all. I mean, getting real here, if the measure by which one should use a language is 'ohh, shiny!' Then we really shouldn't be using C\+\+, either. All the 'new hotness' is elsewhere.
That's a pretty small error message for unescaped quotation marks. The question is how do other languages report this simple error?
Python and Haskell point you at the syntax error it is. There's no way in the language to torture that sequence of characters into a valid expression, like there is in C++ :)
&gt; Even if you're writing container code, you should be using allocators How does that help? Allocators is still about raw memory allocation. Allocators are just there for genericity. If you're using an allocator, you still need to manually deallocate things, which is the problem with new and delete.
&gt; you can't really teach smart pointers before you explained new and delete Of course you can. Java and C# have been doing it for years.
&gt; You don't need the "new hottest" to teach basic algorithms or data structures or discreet math or computer architecture, etc. I think that's even more reason to use more modern C++. It removes distractions about the language nitty-gritty and gives you a much nicer syntax for the basics. And what better language to teach about basic algorithms, than modern C++, which is instructive about analyzing the core concepts of basic algorithms.
Because C++ is complicated as shit, and confusing as fuck? Not everyone thinks like bjarn strapstrap.
The `printf` isn't all that bad, conceptually speaking. Make it type-safe and you're golden. Thus: modern C++ formatting does not use iostreams. They were a sad mistake. I hate the damn things.
Your teachers should be ashamed. "C" is the lowest level of C++. To learn C++ concepts, you don't need to know any of that. Heck, it's a distraction.
PyQt is not beginner-friendly? You can draw your own widget in like 20 lines. You can implement a rudimentary graphing package that loads a simple csv file and plots it out in around 100 lines. What on Earth are you going on about it not being "beginner friendly". Out of everything out there, Qt is very beginner-friendly.
&gt; I've had some success covering move semantics and R-values. A couple of homework assignments are a nightmare without them, and students start to understand why. You are a good professor. &gt;I heavily encourage students to use const on everything they can, and to not avoid const correctness issues in compilers by removing const but rather understanding what the const problem is. It helps them understand data types as they are coding instead of just letting it be fluff they do because they mimic. There is some subtly here I've learned on the job that wasn't taught in classes, as it might just be a C++11ism. I'm curious if you've bumped into it or teach it. I think the following thought process originates from Google, but I am unsure. The CPP standards committee seems to be advocating it: Const correctness is important, but also functions should not modify any variables passed into them. So const correctness becomes an automatic default, with pass-by-value for native types. Also, the types in the the function signature should be explicit. eg, is null possible? std::optional then. It turns out we read code based on types more than variable names in function signatures. This is a large step towards solving the most difficult problem in cs, naming things. If the above rules are followed, then oddly there is no reason to be strict about const for variables declared within the function. Instead, const correctness is replaced with making sure the variable declaration is as close to it's initial usage as possible. (No more declaring all of your variables at the top of the function like in the 90s.) The reason const correctness stops mattering within function scope is because that variable is not going to get modified outside of that scope. That is, no function call will modify the variables you give it, so const correctness within function scope becomes a non-issue for the first time. Then what if a function needs to modify multiple variables? Return a pair, tuple, struct, whatever.. This is a very C++17 way to do things, but it makes reading code a whole lot easier, and reduces being overwhelmed by too many choices when writing a function, making it easier to write code. &gt;It's hard to find good textbooks that also cover C++11 and C++14. In my data structures course, I've abandoned textbooks entirely. But in the introductory C++ course, students still need that textbook crutch, and we haven't yet found a good freshman level book that also uses C++11. I don't know of any either, unfortunately. The problem is recursion is a must to understand how to make a linked list of unique_ptrs or you can get a stack overflow on destruction. That's a bit of a high bar I would think. Hopefully one day there is a version of C++ that addresses this making it easier for newcomers. How are you handling this? &gt;Students have only recently started transitioning to compilers that support C++11 by default. I always get two or three oddball students that insist on Visual Studio 11, or using Dev C++ (ugh!), or C-Lion but not knowing how to configure it, or some weird cygwin + Eclipse setup. (Despite my efforts on demanding certain compiler/IDE requirements, some students always ignore it for stubborn reasons.) With C++11 finally becoming more the default, I find myself not getting hung up with these few stubborn students like I used to. I would think if you advertised the pros and the cons of the top modern day IDEs and let them choose, you'd get a Visual Studio Clion split, which might simplify the process. &gt;I've tried to cover function pointers, functors, and lambda expressions to elegantly solve problems using the STL, and it's just too much for most students at this level. I don't want to give up, lambdas are awesome, but these are still just freshmen and sophomores, they can only be pushed so hard. I it a junior (or senior) level concept, like eg for writing abstract symbol trees or similar. Got a compilers class?
Amen, I'm actually writing a printf like function in C with Unicode support, and I've been wracking my brain about type safety. I even thought about using C++11's variadic template for it, but decided against it.
Explaining that is rather easy: `"something"` is a literal that is not a string, but can be stored in a string. Comparison of these literals compares their memory storage locations. That's all there's to it. The concept of a memory address is quite basic and has nothing to do with C, for crying out loud. In e.g. Python it's called "the identity of an object". It takes some insane mental gymnastics to somehow see "C" everywhere, where there really isn't any (except for the same stuff being present in C -- but we're not talking of C!).
Exactly. The notion that `std::array` is somehow a "C" array is silly. It's there precisely so that we don't have to deal with C arrays!
oh poor young child
`printf
Variable templates are a shorthand for type traits that carry data. Instead of declaring a class with a constexpr static member, you can store the data in a variable template specialized on the type you're describing.
Huh? I'd much rather use `make_unique` instead of `std::unique_ptr&lt;T&gt; u = new T`, `enable_if_t&lt;...&gt;` instead of `enable_if&lt;...&gt;::type`, `is_same_v&lt;...&gt;` instead of `is_same&lt;...&gt;::value`, `explicit operator bool` vs. the safe bool idiom (yuck!), etc. C++17 saves on aggravation. It's all essential: it saves on boilerplate that undergrads don't have time to deal with.
&gt; still not exactly sure what the differences are The newer the version, the less boilerplate and repetition there is when you write your code.
The rule of thumb is: the newer the standard, the less boilerplate is needed. You can literally write progressively shorter programs by using progressively higher language versions.
Not when you write your own friendo.
I wouldn't say that. Our teachers simply follow what's sylabus is prescribed by the Indian board. My teacher agrees with me about this, but she can't do anything about it. The entire Indian education is in shambles literally
"%d" makes sense to you as a beginner as opposed to "&lt;&lt; 1"? Really?
That board has educators in it, too...
Yeah, classes in C++ do not teach good practice at _all_, unfortunately :/
How exactly are they teaching smart b pointers (I assume you mean references?) Without new? (obviously they don't have a delete)? Are they starting with factory functions right away? I'm any case: the abstractions in c++ tend to be much more leaky than in other languages.
No one said you should use new and delete, but you have to be know them to understand what smart pointers do and e.g. what the difference between them is.
I don't think that's true, honestly. Do I need to understand how the ABI of x64 works to understand RVO? I mean, sure if I want to know more, it's a fun romp through assembler land, but it's not necessary to understand it to be able to return values.
&gt; if you're using new and delete in code you're writing now, you are doing it wrong. Yes, but to understand why you need RAII you need to understand why manual resource management is bad. And for this you need to know how manual management work.
&gt; How exactly are they teaching smart b pointers (I assume you mean references?) Without new? "new" in Java is not the same as "new" in C++. So I'm talking about the semantic, rather syntactic. Java and C# don't teach memory allocation to teach smart pointers. Java/C# references are smart pointers. They're garbage collected, and they're nullable. Likewise, you absolutely don't need to teach memory allocation to teach people to use smart pointers. `make_unique` and `make_shared` are the equivalent of `new` in Java/C#. &gt; the abstractions in c++ tend to be much more leaky than in other languages. Inheritance is the leakiest abstraction, and I've worked on Java programs that basically leaked everything through inheritance. At least C++ provides a reasonable alternative to inheritance.
You are correct!
There is never a reason to return an unmodified const from function scope. (With one rare exception.) If it is const, you can just return it then and there.
According to your summary, we are willing to try it in our next game server project, where 35% runtime overhead is almost nothing and programs are coded by many fresh-level engineer
It does if you want to print a double. 
&gt; Thoroughly fuck C++. &gt;. &gt;. &gt;. &gt; Now I'm lowkey trying to get something together with macros. Yeah, you don't sound insane at all
I'm Indian and this was how we were taught. It's like some sort of standard. The syllabus is also very C like at the beginning + classes later on
If teaching a unit on that language is part of their job, then yes, they should be learning the new features of that language. Otherwise, they have no business teaching that unit. If they were teaching another unit, then the very least they should not be allowed penalize students for using the new features that they're unwilling to learn.
As an experiment I am teaching our c++ course from abstractions on, modern c++ first. I was inspired by this [video](https://youtu.be/YnWhqhNdYyk) by Kate Gregory and decided I would give it a go. I can confirm a lot of what the others have said in this thread. The beginners are easily scared and c++ errors really need you to understand what is going on under the hood. Even though it is really tempting to start teaching strings and vectors as first class citizens of the language, and conceptually I do believe this is the way, whenever something breaks the students must understand really quickly a whole lot of details that, when teaching modern things first, have not yet been taught to them. For now I see a lot of confusion in my students. And while some of it might come from my teaching abilities I believe that at least some part comes from the fact that c++ is just a complex language. Mostly this is seen in errors where the compiler tells you exactly what went wrong but expects you to know exactly what is happening under the hood of your high level constructs. As of now I really don't know if it's actually a good idea to try to tell the students that c++ is a simpler language than it is, which is essentially what we are trying to achieve when teaching modern c++. I will have more data by end of the year, but my enthusiasm has reduced substantially seeing what people struggle with. Another issue is that I don't really see a good alternative to this. I still feel that teaching something complex from old c++ world just to say that they should never ever use it in the end it's counterproductive. Does anybody have positive experience teaching modern c++ at the University?
Both languages use automatic memory management as default. They dont start with a use java without the GC intro.
I don't see how anyone can make the argument that remembering format specifiers is easier than not remembering format specifiers.
&gt; While abstracting away many of the things you might be trying to teach. But then: &gt; but there are so many quirks and historical baggage that a simple idea can quickly become cluttered and obscure. You complain that the newer things hide too much, and yet you also complain that the language doesn't hide anything?
C++ is complicated, but lack of simple things like struct methods, RAII or even some basic standard library makes c code way more complicated. C itself is simple to the point that you must handhold it so much until code turns into mess maintainable only by author. And full of bugs too because humans just can not be trusted on getting every single detail right manually.
&gt; You complain that the newer things hide too much, and yet you also complain that the language doesn't hide anything? No. It hides too much and then introduces too many c++ specific things you have to use to compensate for other features in the language.
Unless you give an example, then I can only keep seeing that what you're saying is what I'm pointing out. You can't hide too much and not hide enough at the same time.
Check Stroustrup’s Principles and Practice Using C++ for an excellent textbook on modern C++. There are a couple of odd chapters early on, but in general it’s a great book. Exercises are also very fun to do and provide a good challenge. 
yes.
Well, I saw a modern C++ book where pointers are taught long after classes. And I think there were some people around going through similar learning course. And boy, they were struggling trying to actually do something. Imagine their frustration, when they already kind of know good piece of language, but cannot do anything just a bit more complex. Someone experienced can do a lot without pointers, knowing all the workarounds and things in standard library, but they are novices. Smartpointers just cannot be really learned without learning raw pointers. Because they have all the pointers have, with a bunch of not so beginner friendly additions. You will, eventually, need to learn the underlying C-style stuff too. But I just cannot imagine, what mental model will be in your head before that. Learning from C-with-classes to modern C++ is learning from the bottom to top, from simple to complex, having some ground for all new things taught. Jumping into modern C++ means having huge gaps and ungrounded knowledge. Probably you don't need to learn C++ 99 before modern C++, but please, have some C-stuff ground first.
I can confirm that my education board in India, CBSE, still has C++ taught as part of the curriculum using ancient tools and resources. IMO, they would be better off teaching something like Python or just pure C. All they're doing at the moment is turn away lots of people away from C++.
I'm inclined to say that this is because `string::size()` is fundamentally broken. Consider: - it's not the number of characters in the string. It can contain one UTF8 character that is three bytes long, for example. - it's not the amount of storage used for the string object. It doesn't count any size fields, null terminators, SSO buffers, etc. - it's not the amount of memory you should allocate if you want to copy the string (let's say, for passing to a C API that is going to call `free()` on it). So what is it, really? 
Aur contraire, I didn't say anything about OP's arguments. I think they're right, except that C arrays are not wrong, and a statically allocated are better than their C++ counterparts. In fact, I agree with everything you said, except for the snide pride comment.
&gt; she talks about huge drop out rates early on from people not understanding C This is the opposite of my experience. I struggled to really "get" what classes meant, in a variety of languages, and map the abstractions I was using to the capabilities and operations of the computer. Once I learned pure C, it felt like a revelation that demystified programming and made it approachable.
&gt;In fact, I believe that Python should be the language used in Introduction to Programming classes, not C or C++. Perhaps if you're starting from nothing, but my experience with Python as my first "real" programming language was one of frustration -- more than any other language, I felt I was just copying text from the book to the screen without understanding it, not knowing how flow, state, and data were represented in the computer. By contrast, watching a C programmer walk through the very basics of what a 'struct' was, and what a pointer did, and how these minimal tools allowed computers to manage complex state and structure, I started to feel grounded and confident in a way I never had before using a computer.
I’m glad you liked it. 
CPP11 was a refresher course for me, it was nicer, but I have a feeling CPP17 will be even better. The thing is how many people worldwide are using CPP for their job in 2018?
&gt; it is a better pedagogical principle to teach the basics first That's a myth, and it's utterly untrue. For most things, programming emphatically included, top down teaching is a lot more effective than bottom up, and there are studies on this (I unfortunately only have German sources; for the curious, look up the work by professors Maria Knobelsdorf and Carsten Schulte).
That's awesome! How far along are you?
`std::distance (s.begin (), s.end ())`?
Because as soon as one starts to write code over the beginner level, one realizes that C++ is very intricate and can break down over the minutest detail. C is WYSIWYG (https://en.wikipedia.org/wiki/WYSIWYG), which is at the same time the good and the bad. If you know what your doing in C (which is much easier to achieve than knowing what you're doing in C++, particularly "modern" C++), C proves to be extremely elegant, terse and powerful and highly portable (or not at all).
`std::make_unique` doesn't cover placement operator new, which also includes custom overloaded ones or the `std::nothrow` ones.
Ah yes, that's _much_ more meaningful! (/sarcasm)
Right, now I want to print a real, with pre-pended +/-, a width of 8 and 3 decimals behind the comma. Good luck with that in C++.
There are some actually but the cost -&gt; benefit ratio isn't good enough. You can get proficient in cmake in a few days if motivated.
5 to 10 seconds on a single file edit is absolutely terrible by 2018 standards (ie instant live editing and reloading)
Except passing a double for %d is UB.
But you are seeing implementation details. You are not looking at characters; your string contains a mapping of characters to storage units, and you are looking at those storage units directly. 
Using `new` to provide a facet to an IO stream is an appropriate use, but I haven't seen anyone who's too fond of that API anyway. 
I might be the only one, but usually buffers are the places where special allocators are most important, and performance impacts is not desired at all.
You can find a whole bunch of examples on StackOverflow.
I think the current WG21 rules for `noexcept` are a reasonable balance for functions whose implementation is entirely under the control of the person able to set `noexcept`. That is, of course, the case with most of the standard library. However functions which call system calls the picture gets more muddled. In some cases, you want throwing (i.e. abort) behaviour. In others, you definitely do not, failure is not an abort situation.
I don't see how that fits into "good luck with that in C++", but okay.
&gt; SHA1 is better than nothing. As is CRC32. It protects against accidental bitflips, not against targeted attacks. &gt; Maven/Gradle/Ivy/NPM/etc You can add a lot of shitty package-managers to that list. But just because most people do it wrong, doesn't mean that there is a legit reason not to do it right. As apt/pacman/... do for example. &gt; Aren't most of these packages Open source? Qt is quasi open-source, some are definitely dual licensed, for sure... So what? Just because something is free software doesn't mean that I wouldn't prefer to get real stuff instead of a version that some man in the middle changed to include a ransomware module. 
And that this is because an array is not a string, so the size of an array is not the size of the string. The article then advocate to define soemthing like: namespace mylib { using std::size; // "publish" ordinary std::size // on char arrays template&lt;size_t N&gt; constexpr auto size(const char(&amp;)[N]) noexcept { return N-1; } } which just kicks the ball further by reducing size of char arrays by one. I expect a future article when the guy will discover that ``mylib::size( "A\0B" )`` doesn't return what he expects, because he is trying hard to put square pegs into round holes. 
%d isn't "double", it's "decimal", and it means integers.
I agree with your distinction, but there's one important point you left out: "Programming" as a whole, as a concept. Not "Programming in language X", but understanding the concept of how to program - how a program usually "flows" from top to bottom, often has a main(), what loops do, what functions do, etc. These may all seem completely trivial to you and me. But believe me, there's lots of beginners (who come to Uni without ever having programmed before) that just can't get these concepts into their minds easily, and even after weeks of teaching can't write a "hello world" or "function that adds two numbers" on their own. And this in my opinion would go under the "CS" category, as this is about a concept, how it works, and not about a specific programming language X.
Sounds like a plan, I'll make a start on it this weekend! Trust me, I am learning d3/JS stuff myself but I can share some of the things I have done so far. I am keen to pick up on what you have done on `cpp-dependencies` too.
Yea multi-language support IMHO is at this stage a nice-to-have. I reckon make the C/C++ visualisations really good first, then start to look at other languages. Definitely can be investigated later on.
I've think I've got a fix for your bug, will push out a new release tonight.
So, how does cross-compiling or using a non-system toolchain work? It looks like they require usage of `-DCMAKE_TOOLCHAIN_FILE=` just for hooking up `find_package` ?
The purpose of Computer Science degrees is to make Computer Scientists. The purpose is not to make programmers.
Borland? Someone should at least tell them about DJGPP.
 std::cout &lt;&lt; std::fixed &lt;&lt; std::showpos &lt;&lt; std::setw(8) &lt;&lt; std::setprecision(3) &lt;&lt; 3.14159265359; It's overly verbose and inconsistent (`std::fixed` and `std::showpos` are objects, `std::setw(8)` and `std::setprecision(3)` are functions returning objects instead, and why "setw" instead of "setwidth"?), but it works and isn't that hard to understand compared to printf("%+8.3f", 3.14159265359); Personally I prefer the [fmt](https://github.com/fmtlib/fmt) library to both - it combines the terseness of C printf with the safety and extensibility of C++ ostreams, and adds a few features of its own (like positional arguments, a feature required for localization)
Why not practice some interview questions and evaluate yourself with quizzes and track your progress accordingly : https://play.google.com/store/apps/details?id=com.skillbox.vst.cplusplus We can use some app one example is above.
What is missing for VSCode to be an Integrated Development Environment ?
At my Uni we did some C in Systems Programming class, used Z (specification) for Formal Specification, were taught Object Oriented programming with Eiffel and most of the rest of our education was Modula 2 (Data Structures, etc.). Not a single class was taught using C++. Yet here I am, a C++ dev working at a business that makes C++ apps, C-based firmware apps and other such trinkets. The truth is that most developers teach themselves all of the useful stuff needed in industry. University just teaches you enough to be able to ask some good questions, to find out what it actually is you need to know to be productive.
And the alternative is hard to remember unless you've been unnecessarily using that a lot. One being not-the-best does not make the alternative better. You think C++ programmers would have mastered logical reasoning.
This a million times. Universities don't teach "modern C++ good practices", they teach algorithms, data-structures, systems, programming languages, etc. One of these courses can teach low-level systems programming, the stack and the heap, manual memory management, virtual memory, threads, synchronization primitives, etc. C++ can be used to teach that, but if your point is to teach somebody manual memory management, best practices like "use `make_shared` to create `shared_ptr`" are just things that get in the way. Why are they using C++ instead of C? I don't know, maybe because they can use C++ to teach OO as well, although schools typically use Java for that. In any case, the point of these courses is not to make students become expert C++ programmers following all best practice, but to teach them the low level concepts required so that they can quickly learn whatever language they need afterwards. Some students do learn C++, and some move to other things.
What counts as "break down"? Compiler errors, or the run time errors that stronger compiler checking would have prevented? How much time and money has been wasted due to buffer bugs? "Elegant" and "terse" are overrated, and there's nothing elegant or terse about having to manually type cleanup code everywhere and using gotos as a makeshift stack unwind.
Sometimes you love the Lakos rules, sometimes you hate it. I'm usuallt considered to be in the anti-exceptions camp. But I think we can all agree, as guidelines go, it's a good one - because it's based on solid principles. This is definitely one of John's biggest contributions to C++.
Yes, because `std::string` equates the concept of character to that of the storage unit. It's not `utf8_string`.
I believe that using std::string to store utf8 is not what it is intended to and that you are more or less on your own if you do so. If you want a string of unicode characters, you should probably have different sizes: storage_size, grapheme_size and char_size. So I do not find size for strings confusing.
Yes, congratulations, you can write functions that do different things than other functions. You've cracked the case wide open!
Sorry but I do not agree with you, not even a bit. First thing first, why the heck one would like to explain everything to beginner on the very first lesson? You have newbies which are in front of you, and they just want to get some inside about programming, they would like to understand how to create applications - basic ones. The easier approach is the better one, in my opinion all they care is how to put some text on the screen and how to interact with the computer -&gt; lets say "tell the computer" their name or such. it's totally unimportant to explain them what is happening down there under the hood, they have plenty of time to discover that. Teach them the concepts/Technics to achieve their needs, and not the in and outs. Why shall they understand what namespace is? They need to know (for now) what cout does, and how to use it in the very begging. Then when they understand how to use it teach them how it works. It's the same as it is in school, let's say math. First you teach kids what numbers are, then how u can add them, how u can multiply and you go to more complex issues, then you tell them how to measure the area, and you don't start that it can be either done by simple A^2 or by using integral -&gt; they don't care about it (for now)! I see that a lot especially with people who have been doing a lot of C, they need to create everything by they own, all the things at the same time - in my opinion this is plain wrong. 
&gt; there's nothing elegant or terse... Also in C one can write horrible code, but not necessarily... One can write perfectly good OOP-code in C, f.e... There might be more buffer over-runs in existing C-code, but it's no more than programmer-error (or -laziness)... Yes, you need to write more code, but it gives more flexibility and once "it works" there is no way this will not work in the future... 
Any language thats part of the class is almost always a proxy for teaching something more theoretical. CS courses are not supposed to prepare you for a career in software development, theyre supposes to groom students for a path as an academic in CS. Unless the class is some electuve specifically about good software design or modern use of the language, then it's unnecessary for them to slend time learning more of the language. Penalizing new students for using language features is of course nonsense and I personally have never heard of this.
With thing like unique and shared pointer I would say that C code is far more likely to have errors not caught by the compiler. The new array class makes it easier to do bounds checking etc. And c is not terse vs cpp. 
C is simpler. We can agree on that at least. 
It's missing template template parameters :)
How you can "love C" if its not even self-sufficient?
How the hell is Python a higher level language? I understand Java [being higher level] and I'm currently learning it - but Python shouldn't be considered higher level.
I think in the case of SQLite it was the US Department of Defence who paid for most of the test suite. That's from memory, so I may be wrong. It was definitely somebody big, wealthy, and needed absolute guarantees of correctness to the formally specified model. Fair deuce to the SQLite authors for pitching it though, and getting the funding to actually do it. However, beyond that, what I really like about the SQLite testing is its *design*. Anybody can bang out 711x times of test code. Writing test code which actually tests the product, which SQLite's testing actually does, is a lovely piece of design architecture in itself. Now, it's still not perfect. It doesn't test for bugs in the kernel, and it ought to as that's been the biggest source of data source bugs in SQLite in recent years. One could, for example, configure a Monte Carlo suite of VMs which kill the VM at random times mid-commit, and just leave those iterating forever, finding all sorts of interesting corner case bugs in the filing system and kernel. That would be very expensive, though, mainly for the man hours to triage each failure.
C++ was not taught in my school, I learned it all by self so I'm like modern C++ inside out, courses were taught in Python, even for operating system and Java was considered obsolete, everybody seems pretty happy with our courses taught in a dynamically typed language that there's no stupid type declaration, no verbose interfaces, a one for all list container that is simultaneously also an array, a tuple and a hash map, new functions and stuff could be dynamically injected into any type at run time, basically u just do whatever the hell u want and it always works as long as the coding logic is correct, it's all fairly simple that we all just focus on the mathematically stuff cuz coding is just trivial, always.
Python is a scripting language. Those typically get put into the higher level languages category because they are not able to interface directly with memory/hardware unlike low-level languages like C.
Python is higher level than Java
Hmmm... I see the point of being conservative with noexcept, but I would rather that the `unsafe` trashes the caller in a `PARANOID` case. If the caller causes an UB, then he who is paranoid really wants to terminate him if possible. Why? Because if the caller causes UB there, chances are, he does it elsewhere. If so, they need to fix it, and throwing an exception distinctively goes against fixing, by making the problem smaller (because exceptions *can* be dealt with by code). IOW... the `PARANOID` case effectively uses exceptions for bug hiding. Don't do that...
Python is a very high level scripting language. There is nothing that could be considered low level, no memory management, garbage collection, really about as high level as it gets.
This. Still had Pascal at UNI
I totally agree with you. I think that most people first learned inheritance (single, multiple, virtual), and member functions (virtual or not) before trying to implement it in C for fun (it's something I did years ago). And I'm sure nobody would argue that understanding the implementation of a vtable and all that stuff is required to understand virtual function and inheritance. Smart pointers and strings are probably the same beast even if the low level stuff is much simpler.
modern c++ is becoming quite complex and hard to read/maintain, I wish there is a subset of modern c++ that combines simplicity and ood together well.
Wow, that looks pretty nifty. Even has dark theme! I love it
Pedantic note: Only use std::forward&lt;T&gt; if the function is a template and T is a parameter of that template (not e.g. a class template parameter).
The "You’re writing a function…" rule is missing an important use case - accepting a *forwarding reference* and **not** calling `std::forward` on it. This happens often when defining higher-order functions. E.g. template &lt;typename F&gt; void call_twice(F&amp;&amp; f) { f(); f(); } call_twice([]{ cout &lt;&lt; "hi!\n"; }); * Following your rule here would mean that we forward twice, potentially moving twice, which can be bad. * Arguably, the second call to `f` could be perfectly-forwarded, however this is probably unnecessary and annoying when `f` is called in a loop. * It makes sense to take `F&amp;&amp;` here as we want: reference semantics, support for temporary objects, support for `mutable` lambdas.
Hello, I've worked your remarks into the article. Again, thanks for the throrough review!!
I disagree with that: There **are** libraries that deserve to be called modern C++ that are written in C++98. pqxx and cppcms are good examples: Both limit themselves to C++98 (or at least used to, they may have changed that) but are more modern than at least 95% of the C++11/14/17 libraries out there. It's not the standard that's important, it's how you use it. That being said, I of course don't deny that C++11 was the first version that made many of those things a lot easier. But there are many brand-new libraries that make use of very new standards that are still terrible.
From my first comment: the only new one should be using is placement new.
C++ parsing is already insanely difficult. To prevent it from getting worse, we need to be able to distinguish between kinds of things. using MyPack = this introduces a type. using namespace MyPack = this introduces a namespace. We don't want to make the same introduction sequence be context dependent. We could do using... MyPack = following the rule that introducing a pack has *leading* `...`, while using a pack has *tailing* `...`. Now, `head_t` is just a type. template&lt;class...Ts&gt; struct tail {}; template&lt;class...Ts&gt; using... tail_t = typename tail&lt;Ts...&gt;::pack...; template&lt;class T0, class...Ts&gt; struct tail&lt;T0, Ts...&gt; { using... pack=Ts...; }; that *might* work syntax wise, and it lines up with the new `[...args=args...]` syntax for lambdas. 
I don't follow how it can it be both "overly verbose" and "magic pixie dust" at the same time.
See also: http://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared
It's in no way ideal, but it's not absolutely terrible. It's fast enough that, with the auto-build, the build usually finishes before I need it to. Also, this 5-10 seconds is on a not-that-powerful laptop and a hard disk drive. A solid state drive and more powerful computer would probably produce faster builds
Currently learning C++ in my free time after work, at least an hour a day, i have a bachelor in electrical engineering, did a course on C in uni but it was a joke, some rather bored professor came in, wrote a program on the whiteboard, vaguely explain it then proceed to bugger off, also did some Matlab. Got any recomandations, books, courses, best practices or whatever you deem usefull ? Many thanks. 
You were talking about Python and lamenting the lack of a “standard” GUI. PyQt fills this niche well. The basics of C++ Qt can be explained in steps, going from examples that keep every object directly in local variables (‘main()’ and no classes) and then transforming it into classes and methods to keep the code manageable. I have taught absolute beginners the basics of Qt, and all it requires is a disciplined constructivist approach where nothing is left to imagination. I admit that the way I teach it is nothing like any other materials I saw online — maybe I’ve found something that others didn’t, who knows. I’m pedagogically inclined, I’d say. 
&gt; as it might allocate memory No. It can't. It's not marked `noexcept` because the underlying constructor just might throw. It *could* be marked conditionally `noexcept` but the library tends not to do that. So yes, you could safely mark `std::optional&lt;int&gt; safe(int) noexcept` since nothing in there could throw.
While it is possible, I don't recommend it. You can code in C++ perfectly fine on any desktop/OS, and it will probably be a lot less painful. 
My computer broke recently and Its being fixed and i have No time on when Its done so i have No other choice atm. So would you reccomend to just do it or start with a different language if i only have a pi?
If this is your first programming language, don't start with C++. It's a relatively hard language the learn, and it has a lot of little quirks. I'd recommend you to start with python, get familiar with the basics of programming, then move on to Java or C#, once you've got a good feeling for either of those two languages, take a stab at C or C++. 
If you want to be close to hardware though there is no beating C. And for general purpose programming I'd argue that a simpler language like python or C# would be better because its easier to make something reliable faster.
Thanks for the tip :)
Thank you! You’re doing those students a huge service by teaching them modern c++ to the extent that you can at their level, and you sound like a great instructor.
RPi3 is one of the targets that we ship our product to, but we cross compile the binary in a normal x64 machine to ARM. It works fine in all aspects.
`std::optional` is guaranteed by C++ specification to not allocate memory. Are you by any chance thinking of `boost::variant`?
You are of course completely right. Double is quite intuively just a long float and as such represented by %lf, thereby cleanly mirroring scanf. /s 
Probably hard for them
And also, floats are expanded to doubles when calling variadic functions like printf, so in older C standards there was no %lf for printf, you used %f for both floats and doubles. In recent C standards both exist to mirror scanf but either work for either because they both really print doubles.
What does this program output? #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; int main( int argc, char * argv[] ) { int a = strlen("abc"); bool equal = strlen("abc") == strlen(std::string("abc").c_str()); std::cout &lt;&lt; "Length of \"abc\": " &lt;&lt; a &lt;&lt; "\tEqual? " &lt;&lt; (equal ? "Yes" : "No") &lt;&lt; std::endl; }
IOW, in order to comply with implementations that throw logic exceptions, we give up on potential better performances -- but I guess the compiler takes over by analyzing inline code in cases like vector::operator[] ? Isn't one of the advantages of UB to give the compiler other opportunities for optimizations? It would be nice to have a "&lt;&lt;undefined&gt;&gt; if preconditions aren't met, but in all cases never an exception"
I disagree, it's perfectly fine, and there's nothing remotely painful about it except that they're slow. Given the OP is new to C++, I don't think the speed of compiling large projects will be a problem.
I was mainly thinking about thing outside of programming itself, finding the right libraries, using a browser in general,... RPi's aren't that fast, and finding libraries for an ARM Processor can be difficult (I think, I've never tried).
Well in math you learn how to construct real numbers from quotients a hell of a lot later than doing integrals. :V So in a way C resembles how math is taught, not too low level.. but not too high either. A sane middle ground. :]
`std::function::operator()` is not a template and uses `std::forward`.
I very strongly agree. By `throw`ing in the `PARANOID` case you are effectively creating a wide contract. Hyrum's Law dictates that people will now assume you `throw` is the behavior. Instead of fixing bugs they'll just always define `PARANOID` and `catch` `std::out_of_range`. `std::terminate()` or `assert()` is the best option if you want debug assertions. I love Lakos's work, but if this is really a reason to avoid `noexcept`, I'll have to take a pass on this rule.
I'm afraid I don't... This can be used as a reference for Debian and GCC (https://wiki.debian.org/CrossToolchains), however I think you can install Clang directly into the PI and program in there, if you want.
&gt; Are you by any chance thinking of `boost::variant` which actually allocates memory? I probably was. At any rate, thanks for the correction. It shouldn’t detract from the message of my comment, hopefully.
All rules have exceptions. However, if you're at a point where you need a diagram to decide when to use move/forward, you don't need to worry about those.
"perfectly good" and "OOP code". Two phrases that should not go together. C programmers think C++ is an OO language. C++ programmers who have been stagnant for the last twelve years think C++ is an OO language. People who use modern C++ to get stuff done don't suffer from that misapprehension. Modern C++ is a funny multi-paradigm mix. Generic, generative, functional, and data oriented all come into play in different contexts. Asynchronous flows are starting to become more relevant. Sure, it has a lot of legacy cruft, and some modern languages are starting to emerge that bring new potentials to the table - I'm actually working in Rust professionally at the moment - but C++ was where zero cost abstraction was invented, and while it might suffer ergonomically because of design decisions that predate those inventions, rather than being informed by them, things like expanded constexpr are changing that for the better. There will come a time where generalized abstraction can be expressed clearly, concisely, and without runtime overhead in modern C++, without needing to understand the legacy complexity of ground-up template metaprogramming. This will be both a good thing and a bad thing. It will be good to not need to wrestle the language into submission when doing very hard things. It will be bad to no longer have a filter to identify those who can or cannot conceptualize complexity. In either case, OOP C is a sad, sad thing. It takes the least desirable, and frequently least optimal (in allocation and data layout, more than in call thunks) aspect of C++ and replicates it without the benefit of compiler optimizations, and it frequently shows up in the place no C++ programmer wants to see it: single, short run operations with high frequency. Rule of thumb: if you need runtime polymorphism, do it on collections, batch operations, or primary entry points of your flow, not individual elements, if at all possible.
Not sure why this is downvoted. It is a solid advice - I would just skip Java/C# unless you are looking to get a job developing "enterprise" software.
std::begin/std::end allows you to do the same with C-Arrays...
Eh, C# is a great language to write small tools in. Especially if you need a GUI.
You might consider using Gentoo's portage system, which can work on any Linux-like OS, and has some support for Windows and Mac. It has support for specifying exact package versions, upgrading and downgrading arbitrarily, and has built in knowledge of arbitrary configuration and version dependencies between packages in an installation. In my opinion, it's more feature complete and versatile than Vcpkg or Conan.
Well I rarely allow class template parameter of reference type, and when I need that, I use specialization. So there's no need to use `std::forward`. But if there's a need to treat reference and npn-reference alike (as in the case of `std::function` or `std::unique_ptr` for the deleter), then chances are `std::forward` actually makes sense.
You might be interested in Gentoo's portage system. It has proper signatures. Also allows arbitrary dependency graphs to be installed in arbitrary locations (with multiple such locations supported), and since it's a source based package manager it supports arbitrary compilation options.
&gt; I was mainly thinking about thing outside of programming itself, finding the right libraries, using a browser in general,... RPi's aren't that fast, and finding libraries for an ARM Processor can be difficult (I think, I've never tried). Yeah I guess it depends. For what I was doing apt-get install and the odd source compile was fine. Building was slow because I hadn't figured out how to get a working cross toolchain. I wouldn't want to use a browser! I think the 1G RAM limit would be worse than the slow CPU.
That's brilliant, thanks!!
&gt; … feels like dirty cheating … at compile time and then short-circuit any problem… Seems like you answered your own question.
I should probably remove thread-ring, chameneos-redux and meteor-contest.
Since python 3.5 there is the matrix multiplication operator, so it's just A = B @ C in numpy nowadays
std::array has .at() for random access and it's type checked -- you dont want to use C style arrays if you dont have to.
I use [VisualGDB](https://visualgdb.com/). It just works.
Because C++ interfaces leak across boundaries. You need to recompile _everything_ above a package when that package changes, at least absent strong guarantees. The system package manager won't generally upgrade versions of packages, and you will have to use essentially the same flags as the system does when compiling your C++. For example --std=c++17 is not binary compatible with --std=c++14. Noexcept is now in the signature. Packages may use feature test macros, and have different code or layout, so now you've got ODR violations. C++ is fragile. But a lot of the performance of C++ is tied up in that fragility. It's not "There isn't a standard ABI", since there is, it's just not from ISO, it's that every class contributes to that ABI. 
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8f3j44/c_on_rpi3/dy0k98r/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; It makes sense to take F&amp;&amp; here as we want: reference semantics, support for temporary objects, support for mutable lambdas. `F&amp;&amp;` is the wrong type here; `F` is the correct one. If you invoke `call_twice` with an lvalue argument, it *will* modify your object outside the function because `F` is deduced as `object&amp;`. What's more, if the argument is a const lvalue, `F` will be deduced as `object const&amp;` so you can't call a non-const `operator()` (think of `mutable` lambdas). This can be rather suprising and hence it's better to go with `F` and put the onus on the caller to make it clear that they want to pass by reference (by using `std::ref`). The alternative is to offer two overloads: one with a parameter of type `F const&amp;` and one with `F&amp;&amp;`. However, if there's only one overload, I'd always go with `F`.
Finally I can create an application qml, qt script and qt css, right in the browser!
&gt; In recent C standards both exist to mirror scanf but either work for either because they both really print doubles. So float a = 1.0f; printf("%lf",a); works and is mirrored by scanf("%lf",&amp;a); 
This is mostly beyond my expertise, but if there was a function called `call_twice` and I passed it a mutable lambda, I would expect it to call my lambda twice, not a copy of it. Sure, I code `move` it in, but that wouldn't work if I still needed the lambda later. Of course for a different high-level function making copies might be acceptable. Oh, the joys of C++/
&gt; It could be marked conditionally noexcept but the library tends not to do that. What is the rationale?
None of those indicate 'brokenness'. `std::string::size()` gives the number of code units and indicates the appropriate range for indexing into the string: `myString[i]`. (Though technically you can also do `myString[myString.size()]`). When working with strings there are a number of different 'sizes', and different contexts in which they matter: 1. Number of bytes (of actual string content). Useful when allocating or copying string content using byte oriented functions like `malloc()` and `memcpy()`. This shouldn't include things like a null terminator since that depends purely on conventions that only apply in some cases and isn't part of the actual string content. 1. Number of code units. Useful when you want to iterate over code units such as copying, printing, or working at the encoding level. 1. Number of code points. Useful almost never. Close enough to make people think broken things are working when they aren't. 1. Number of user perceived characters (e.g. 'grapheme clusters'). Useful when dealing with user facing text manipulation such as displaying a user controlled cursor moving through the text, splitting strings in places that look sensible to users, etc. With `char`, `std::string::size()` works as both 1\. and 2\., and for Unicode 4\. requires a regularly updated database and special algorithms. It might be nice to have that as part of the standard but it's understandable that it isn't. But 4\. certainly should not replace 1\. or 2\.
The lack of threading support is a big problem, but otherwise this is super cool. Ill have to create a project to play around with it when 5.11 and more documentation is actually out 
Really laggy from the demos I tried, but an interesting showcase of Qt with WebAssembly.
One thing to keep in mind is a contracts language feature. It would be ideal if there's enough freedom to selectively replace UB with contracts as desired. For example, `unsafe` could have a precondition that `i` is within bounds. However, such a contracts system will almost certainly support throwing on failure, either directly or within a contract violation handler. This interacts with `noexcept` rather poorly. As far as writing tests goes, preconditions are code, so being testable makes sense. Either the tests make contract violations throw and then test by catching it or they set a handler that captures the failure and causes the test to succeed. The second is likely to be awkward in comparison. Just some things to consider. It bugs me that I don't have a perfect solution.
Thank you for the grammar info. I know C++ has crap grammar, but I have no "feeling" what new syntax is good and which is bad. 
&gt; make_unique and make_shared are the equivalent of new in Java/C# This isn't actually correct for C#. Not sure about Java. Structs in C# are value types.
I actually think this is a bug in standard. They should not have allowed std::size to work on arrays. Since std::size of C array is actually nonexisting std::capacity. std::empty is especially ridiculous. `template &lt;class T, std::size_t N&gt; ` `constexpr bool empty(const T (&amp;array)[N]) noexcept` `{` ` return false;` `}` *barf*
Sorry, but pulling numbers out of thin air does not make a valid argument. Writing horrible code in C is easier. You mentioned it, writing OOP in C. How many homebrew OO systems in C are there now? All of them are horrible and inefficient.
&gt; Penalizing new students for using language features is of course nonsense and I personally have never heard of this. Just the other reddit thread about why people hate C+ so much had an example. One university apparently bans the use of using any C++11 feature.
Jetbrains had some really cool blog articles about this a few years ago. It's not this one, but this one might be a good starting point nonetheless (I can't find the older ones): https://blog.jetbrains.com/idea/2015/08/experimental-zero-latency-typing-in-intellij-idea-15-eap/ Oh I think it was actually this one: https://pavelfatin.com/typing-with-pleasure/
Does not seem C++ related
Yep, removed.
&gt; The lack of threading support is a big problem Thanks to Meltdown and Spectre fiasco.
It's the number of elements in the container, the same as `size()` on all the other standard containers. 
Yeah, `std::forward` is for when you want to preserve the value category of your argument. There's no reason to swindle a function into thinking that you gave it an rvalue when you don't want it to be treated as an rvalue.
`T x[3];` means that `x` has 3 elements at all times. It is never empty. There are no "null objects" in C++. If you find this definition of "empty" ridiculous I think it indicates a lack of understanding of C++ objects. And if you want a container that can be either empty or non-empty at runtime, then there are plenty to choose from, e.g. `vector`. 
`std::size(s)` and `s.size()` are identical if `s` is `std::string`. This article is about how `std::size` applied to a C string literal is different to `std::size` applied to a `std::string` initialized from that literal.
https://www.reddit.com/r/cpp/comments/8bouu7/why_is_c_so_hated/dx8zzj3/?st=jgh7qrku&amp;sh=4ea595ed
Having multiple versions of the same library is nearly impossible in C and C++. The reason being the one-definition rule prevents the same symbol from being defined twice. Unlike other languages, C++ won't lookup symbols based on the version you are using or the directory you are in.
You're just wrong. The objects in the array always exist. If `T` has a constructor that prints a message then you will see that message printed 3 times by `T x[3];`. You are describing storing another integer or key to indicate whether certain of the array's elements are significant to the program or not. Perhaps, *simulating* a resizeable container. But an array is not actually a resizeable container. Usually this means you chose the wrong container in the first place, you should have used a resizeable container. 
&gt; If you want to be close to hardware though there is no beating C. There is. C++ actually beats C as well. Dan Saks writes about embedded C++. CppCast has one or two podcasts with an embedded C++ dev talking about C++'s advantages in the embedded space.
This is what I was thinking too. I'm not sure it's super beneficial to know about these abstractions without first understanding what they are abstracting over.
Then why not just teach malloc and free? New and delete hide calling the constructor and destructor. 
Because must of the students that come to me already know malloc and free, but yes, I usually have to quickly explain the difference between malloc/free and new/delete.
How about &gt; Only use std::forward when your intent is just to thinly wrap a function call ?
Fair enough. I should have phrased my explanation better: y'all don't allow mixing and matching of arbitrary library versions. I stand by my analysis though--that's nice for independent and novice users, but it's a deal breaker for me in commercial/production use. 
&gt; Interestingly, Intel MPX (hardware-based solution) has 139% runtime overhead and 90% space overhead (bound tables). I wonder if that's why gcc 8 removed support for it.
&gt; All of them are horrible and inefficient. This claim is un-substantiated (i.e. thin air as you call it). There are many, widely used, well-written C-libraries around, like SDL, curl, GMP, MPFR, just to mention a few.
&gt; std::array has .at() for random access and it's type checked... A C-array is type-checked as well... .at() is bounds-checked, maybe that's what you mean... In VS, []-operator and the iterators are bounds-checked in debug as well by the way... &gt; you dont want to use C style arrays if you dont have to. Depends, you might want/need to interface with other languages, C is the default for doing that. What would be a nice addition to the C++std-lib, though, is to have array_view (like string_view), which would give the best of both worlds...
Perhaps you were being tongue in cheek, but that's a very disingenuous thing to say. Testing *SAVES* money.
Problem is, std::string isn't really a string either, it's just a vector of narrow integers with some extra stuff tacked on. Also, `size()` is a bad name and it's a shame we're stuck with it.
major projects with lots of very smart people disagree with you on a very consistent basis.
I read that as "only write toy programs".
Do you really believe that? Let's have a simple example: my office has eight programmers. Each year we make a steady but not spectacular profit. Sure, some of our time goes to testing, but the fraction is not anywhere near 711 to 1, and we certainly don't write 711 times more code for testing than we do for actual business purposes. Do you think we could somehow afford to hire another 5688 people so that we could have this level of testing? Do you think our customers would pay us 711 times more than they do today, just to have a somewhat reduced chance of bugs? Testing, on this level, does not save money, it would bankrupt us within a month! And don't think we are unique in this; it's true for _any_ company, in _any_ line of business. 
Not all lines of code have the same cost. Your assumptions are laughably bad.
Please don't tell people to copy-paste implementations from cppreference. What we have under "possible implementation" is generally written for illustration purposes, not production use. It's only minimally tested, if at all, and is generally not optimized for things like different iterator strengths or trivially copyable types etc., as you'd expect to see in a production quality implementation; the complications introduced by such optimizations will detract from the primary purpose of these examples. Besides, their license (CC-BY-SA/GFDL dual license) aren't really designed for code. If you must copy paste, find a permissively licensed standard library implementation instead.
Absolutely. This is a big part of what I am teaching. I am always telling them that the compiler is their friend and I am explaining how to decipher the errors it gives. Personally, that is why I love compiled languages as opposed to scripting ones. I completely agree that every compiler error is a test. :) However, what I see a lot is that students get kinda lost in abstract concepts, e.g. in const correctness or even in more basic things like what is a reference. As we are learning from references to pointers as suggested by Kate in her video, they don't really understand the concept of memory at this point very well, so it's easy to get confused.
Not multiple versions in the same application, but multiple versions in the same package manager. So that application A can use library L 1.0, and application B can use library L 1.2. This is also one reason why many system package managers can be disadvantageous for development because they do not support this out of the box.
Everything in Java is a reference type, except for primitive types and the references themselves. The parallel holds for C# classes.
Just ban "memory management" from your vocabulary and talk about "objects", "resources", "lifetimes" and "ownership". RAII manages more than memory in a consistent manner, and you do not need to trudge through the implementation details of the specific case of global heap memory to understand it. Qt's new is pretty much syntactic sugar through clever overloading of operator new. It does not look like any vanilla use of new and behaves differently -- and while it works just fine, it is not modern C++. Note that you *can* also use Qt widgets with RAII, atomatic destructors and modern smart pointers.
Opening the hood and applying voltage manually is *not* the proper way to start your car every morning. I don't think you'll demand that I deploy an extensive engine construction course to back that up. That was today's Terrible Car Analogy, thanks for coming in!
Do you know that Bjarne Stroustrup wrote a textbook?
"C" is another language, which is partially written like something resembling very poor C++. This can be exploited by library writers to create polyglot headers, and has exactly zero interest in teaching C++.
No, https://github.com/WebAssembly/threads has been in the works since 2015
Yes, inefficient, because dropping type information means less efficiency. No homebrew OO can benefit from de-virtualization. Generic programming also isn't possible. &gt; You're shiny STL lib might be implemented using void pointers, static casting But users of the STL are not exposed to the void pointers and casting, whereas virtually all homebrew OO requires it of the users of the library. They may hide it behind typedefs, but typedefs are a poor-man's type system. &gt; And I think that the resource management problem is over-rated. Forgetting to unlock mutexes or close sockets is still common. &gt; but gives me more control at the same time How can it give you more control, when you have exactly the same capabilities in C++? You have less control because you lose type information very easily.
Having you stare at me while I try to read your blog is a little unnerving.
Almost. It's an exception, not a segfault. &gt;terminate called after throwing an instance of 'std::logic_error' what(): basic_string::_M_construct null not valid
Yeah I also got to say a pretty good overview talk about stl algorithms. It would be great if the map was available for download / browsing through somewhere.
This is [CWG 1941](https://wg21.link/cwg1941).
It's a very old mistake in the C standard that arguments get promoted when calling variadic functions. They essentially only pass int, double, and void*. Scanf has no trouble because it only takes pointers, which all go through the void* path, but that has no effect on the type of data the pointer is actually pointing at. Printf has to deal with the nonsense because it expects _values_. These int/double promotion rules also apply to functions with no prototype - in C, a function declaration with no arguments _doesn't_ mean that the function takes no arguments, it means they are unspecified, and follow similar calling rules to variadic functions. It's entirely possible this odd behaviour is inherited from B, which _only_ had an int type. Much of C's craziness comes from B compatibility, such as implicitly giving things the int type if it's not specified, and character constants being able to contain four characters (`'abcd'`) and having int type.
I am not convinced. --- &gt; If you invoke `call_twice` with an lvalue argument, it will modify your object outside the function because `F` is deduced as `object&amp;`. This is exactly what I want. I want to call that particular thing twice, not a copy/move of it. --- &gt; if the argument is a const lvalue, `F` will be deduced as `object const&amp;` so you can't call a non-const `operator()` (think of `mutable` lambdas) Good? I would be surprised if there was a way to invoke a non-const `operator()` on a const object. The user can always make a copy on his/her own if he/she wants. --- &gt; put the onus on the caller to make it clear that they want to pass by reference OK, this is where we disagree. I'd rather put the onus on the user to make a copy - I find it more intuitive to have reference semantics here. The user can always make a copy with a function like: ``` template &lt;typename T&gt; auto copy(T&amp;&amp; x) { return T{std::forward&lt;T&gt;(x)}; } ``` Which, unlike `std::ref`, doesn't have to wrap the original type...
Fairly sure it's 1,3,1,0. And this would be why uniform initialization is still broken for types with both initializer list constructors and constructors with other arguments. It should be consistently calling one or the other...
exactly.
Yeah, I have already encountered few errors from VS which were not obvious and not pinted to the case of the problem. Eg implicitly removed default constructor because one of class members does not have such. In this case, GCC outputs understandable error pointing that SFINAE removed the ctor: main.cpp: In function 'int main()': main.cpp:20:17: error: no matching function for call to 'myNum::myNum(float)' myNum x(4.0f); ^ main.cpp:6:5: note: candidate: template&lt;class T&gt; myInt::myInt(const T&amp;, typename std::enable_if&lt;std::is_integral&lt;_Tp&gt;::value&gt;::type*) myInt(const T&amp;t, ^~~~~ main.cpp:15:18: note: inherited here using myInt::myInt; ^~~~~ main.cpp:15:18: note: template argument deduction/substitution failed: main.cpp: In substitution of 'template&lt;class T&gt; myInt::myInt(const T&amp;, typename std::enable_if&lt;std::is_integral&lt;_Tp&gt;::value&gt;::type*) [with T = float]': main.cpp:20:17: required from here main.cpp:6:5: error: no type named 'type' in 'struct std::enable_if&lt;false, void&gt;' myInt(const T&amp;t, ^~~~~ main.cpp:2:8: note: candidate: constexpr myInt::myInt(const myInt&amp;) struct myInt ^~~~~ main.cpp:15:18: note: inherited here using myInt::myInt; ^~~~~ main.cpp:15:18: note: an inherited constructor is not a candidate for initialization from an expression of the same or derived type main.cpp:2:8: note: candidate: constexpr myInt::myInt(myInt&amp;&amp;) struct myInt ^~~~~ main.cpp:15:18: note: inherited here using myInt::myInt; ^~~~~ main.cpp:15:18: note: an inherited constructor is not a candidate for initialization from an expression of the same or derived type main.cpp:14:5: note: candidate: myNum::myNum() myNum(){} ^~~~~ main.cpp:14:5: note: candidate expects 0 arguments, 1 provided main.cpp:12:8: note: candidate: constexpr myNum::myNum(const myNum&amp;) struct myNum : myInt ^~~~~ main.cpp:12:8: note: no known conversion for argument 1 from 'float' to 'const myNum&amp;' main.cpp:12:8: note: candidate: constexpr myNum::myNum(myNum&amp;&amp;) main.cpp:12:8: note: no known conversion for argument 1 from 'float' to 'myNum&amp;&amp;' 
Ok,before this goes further: have you actually tried to teach c++ to students?
Oh god that's horrible.
&gt; where they still learn using borland turbo c++ in dosbox. It's very common to still use the old Borland bcc32 compiler for teaching. It's a free download which helps. We at Embarcadero, who own C++Builder, updated the [compiler download](https://www.embarcadero.com/free-tools/ccompiler) to a modern C++ compiler specifically since this specific download is so widely used and we want to make sure if you're using it, you can use current C++. And you don't need DOSBox ;)
&gt; It's very common to still use the old Borland bcc32 compiler for teaching Even "updated" there's 0 advantage over using GCC or Clang directly. 
Apart from that being a meaningless platitude: an untested line of code has a _potential_ massive hidden cost, but a tested line of code has a _certain_ massive visible cost. Not that I'm arguing against testing; just that there is a limit to how much testing makes economical sense. The stated figure of 711 lines of code in the testing harness vs. one line of code in the application makes no sense for pretty much anyone out there, and as I stated originally, if anyone knows of real, practical examples where similar amounts of effort are spent, do let us know. 
# [Here's the wallpaper, if anyone's interested ? ](https://www.reddit.com/r/cpp/comments/8faq2p/wallpaper_the_world_of_c_stl_algorithms_1800_x/)
[Here you go \(:](https://www.reddit.com/r/cpp/comments/8faq2p/wallpaper_the_world_of_c_stl_algorithms_1800_x/)
And to think, there's no overhead to constructing an empty vector, followed by calling `resize()`... So all this misery is basically to allow for a 'convenient' shorthand that we didn't really need to begin with. 
I did mean at() is bounds checked, and the class itself is type checked for storage type; the element count is part of the type at least until compile time. So if my interface requires an array of three elements the compiler can enforce that for me. And you can call .data() if you need the raw ptr. It's just better. 
It doesn't matter if you're for or against it, even thinking that the cost per line of code scales linearly regardless of the code is laughable.
Tell that to the guys who wrote clang.
What is the connection with my post ? I just don't get it.
Let's not go initializer lists again. 'tis a silly place.
Not formally, but as a senior fellow student in the context of a gamedev club.
Yes. And it relies on `SharedArrayBuffer` which was turned off in all major browsers since it was exploitable by the M&amp;S exploits.
&gt; So when you use enable_if in a constructor that might be pulled into a child class with using, try to avoid using it as a default parameter. As a template parameter it works fine. Seriously though, who does sfinae using a default parameter? There's rare cases where return type sfinae is ok, but if you are using an enable_if form just always do it in the template parameter. It's ugly no matter where you put it, but at least you aren't hurting the readability of the signature.
Default to brace constructors they said. It's "uniform" they said. I'll stick to parens unless I'm default constructing, or I actually *want* initialize_list semantics.
May be this is silly, but I prefer to use old syntax for constructors. Initializer lists is a very useful feature but uniform syntax? No.
Nice but C++ map is more interesting by its details and irony.
This one http://goldns.ru/cppmap-2012.png
May be because of this? https://stackoverflow.com/a/11056319
There's not even any nullptr. .. part of the problem is implicit conversion from integer 0 to a pointer.
That's trivially fixed by using a default template parameter slightly differently in the answer you linked though...
Dear committee, please fuck backward compatibility and fix our beloved language for not yet born projects.
This guy has exactly the same voice and intonation as comedian James Acaster https://www.youtube.com/watch?v=i_xVAqJ-NY0
Yes, moving the enable_if into the template parameters works better here. But I've blogged about this, because I did meet this problem in the wild, not my own code base, some one asked a question, and this was the source of the problem.
My school teaches software development and I hate it. I wish they taught computer science, all we learn is to write Java crapware
This is pretty ridiculous and comes out of nowhere. It's not even consistent because every non\-static member functions has a narrow contract in multiple aspects: this must point to an object of the class type, there must not be any data races on the object, there must not be undefined behavior anywhere else in the program really. If you apply this rule consistently everywhere, nothing can be noexcept.
To be honest it's the main reason I don't read the articles from this blog anymore ^^'
He just wants to make sure you're paying attention.
According to this summary, the more likely reason is that there are troubles maintaining it: https://phoronix.com/scan.php?page=news_item&amp;px=GCC-Patch-To-Drop-MPX
Oh god... This is why I had strange error doing something like this. I never understood what was going on. I hope this will be fixed.
Why don't you just ignore the parameters you don't support? Then the macros would be source compatible with Catch.
AAA + parenthesis will save us! Narrowing is a lie!
I never claimed otherwise. Is it even guaranteed to be there, or just very likely to be there in order to fit the requirements of c_str?
Interestingly, this seems to be related to return type deduction. If you remove the deduction, GCC compiles it: https://godbolt.org/g/6dmWXi
Ah, I thought your comment was a rebuttal, but it was just a grievance with the std::string API. Since C++11 the null terminator is effectively required due to the requirement that .c_str() be constant time.
But... This is why I hate JavaScript...
&gt; this must point to an object of the class type To be fair that's not part of the function's contract, that's part of the language's contract.
Not accessing an array out of bounds is also part of the language's contract.
`IWillNeedToFindBackSomeStudiesWhereItWasStatedThatSpacedTextIsEasierToRead` In monospaced fonts the difference in readability is much less pronounced. 
What's your point?
They could also still be provided, just as named static members. std::vector&lt;int&gt;::repeat(n); // n default-constructed elements std::vector&lt;int&gt;::repeat(n, x); // n copies of x I like overloading but the standard library takes it way too far.
Give C++ a serious try and you will change your mind about many things. C++ is not perfect and has gotchas, but if you get a few good habits there is no contest: C++ wins hands down. Not in a subjective way, but objectively: you have stronger typing to begin with. You also have better zero-overhead abstractions and memory management. You have code as fast as C. You have safer interfaces such as std::copy, std::equal and std::fill. I do not mean C is a bad language. But C++ is quite superior even if it takes some time to use properly.
Yes, but this one has a great talk (and a really shitty attempt at a GoT-style flying intro that we don’t talk about) to go with it
&gt; You don't even have to use them What I'd tell you? **What is the title of this post?!?**
GCC is wrong, see http://eel.is/c++draft/temp#inst-4.sentence-1 The existence of a definition affects the semantics of the program, so the compiler is required to attempt to implicitly instantiate one.
Also known as the "named constructor" idiom, which I feel is sorely under-utilized and much more useful than tagged constructors (Although tags still have a valid use). It also lets you return types other than the direct type you are constructing, like a `std::optional&lt;T&gt;`, `future&lt;T&gt;`, or `expected&lt;T&gt;`. Very useful if you want "failing" constructors without exceptions, but still the type safety without two-phase initialization.
&gt; there's no overhead to constructing an empty vector, followed by calling `resize()` How so? As far as I'm aware it would be perfectly conforming for `std::vector` to start life with a `capacity` of `5`. Therefore there could be overhead (one allocation) to not using this constructor. 
Well done, you've covered the most important use case of std::forward, which is when an object whose type is deduced is received by an rvalue reference. This is done in order to preserve the value category of the original expression that the function was called with. There are however more esoteric yet legitimate use cases for std::forward. For example, imagine the specialization of std::function, that receives the return type and the argument types of the internal callable object, whose operator() is not a function template. This `ReturnType operator()(Arguments... arguments)` should forward all arguments to the user provided callable object. Let us examine which forwarding technique to use. Firstly, using `callable(arguments...);` is suboptimal due to the fact that `std::function&lt;void(std::unique_ptr&lt;Type&gt;)&gt;` will fail to compile, because the unique ptr is wrongly forwarded as an lvalue. Secondly, using `callable(std::move(arguments)...)` is again wrong as `std::function&lt;void(std::string &amp;)&gt;`will cause the string to be moved prematurely from lvalue expressions. It turns out that we want to forward as rvalue on all cases except when receiving an lvalue reference, in which case we want to forward as lvalue. Apparently `std::forward` does this exactly, so finally `std::function&lt;Return(Arguments...)&gt;::operator()(Arguments... arguments)` should forward like so: `callable(std::forward&lt;Arguments&gt;(arguments)...)` even though none of the arguments are deduced at the function call. There is at least one more example I can think of where `std::forward` is useful, so it is maybe worth mentioning in the article that only the widely common case is covered. Overall, great job. 
Respond and politely disagree with the stated reasons? 
Yeah, that I did. Thing is that I feel super down at a job where I'm not growing at all! Stuff like this just takes me down.
You're upset someone is telling you to return values instead of modifying an argument?
I often am this guy, telling people how package managers are good / throw specifications are bad / thou shalt use move semantics instead of returning shared_ptrs / boost versions on different platforms should be equal / gcc 7.3 is more powerful than 4.4 / we really have to stop to freak out that this **** gonna break and break it ourselves and take time to rebuild it and cover it with tests, intead of doing the job. Trust me, us guys sometimes get tired and want to quit no less than you guys.
Nop, I do that by default. If you read well you can see this a guy thinks that RVO is a C++11 thing, when it is not. This is what I call a Stack Overflow guy, he just read about RVO and without any understanding of it... well. I consider this a big mistake, a deep misunderstanding about C++, the standard, optimizations, etc. As I said, this guy once tried to iterate over a queue. My problem is having to deal all day with people of which I can learn anything!! 
Dude, I love to hear about all that stuff, but at least get your facts right. "Since C++11 we now have RVO", I was like, seriously?? What else you don't understand!
Job satisfaction questions aside... Why not both? void CommonData::encodeToJSON(string&amp; msg) { msg.insert(...); } string CommonData::encodeToJSON() { string msg; return this-&gt;encodeToJSON(msg); } _[Aside: why aren't these const?]_ It might be a good thing for someone to point out this (somewhat minor) simplification -- it depends on the sophistication of the audience. If many people would learn from this, then you could look at it as a public service. If it's just a lame attempt to show off to management, then well... 
It is the later :( Happens over and over again here!
Well, for_each still has some uses and is sometimes even shorter than a for_each loop.
May i ask why are you using string.insert ? 
This was an email sent company wide, I modified it a little. That's not the good part :)
RVO is a C++**17** thing. Before that it was optional. NRVO still is. Anyways, you seem to be getting worked up over something trivial. That's not healthy. Relax a bit.
Hm... Can you give me an example? Even without range based for, with autos, just normal for loops seem so much better.
so...when should I use enums and when should I use tag dispatching?
Actually this was my response to the email. He got angry with me for this response. I think you meant that in C++11 we now have move semantics that will guarantee move(d) value even if RVO is not possible. RVO exists since C++98 and it was significant back there. RVO is an optimization the compiller is allowed to apply (in C++17 it is actually guarantee in certain cases), however, even in C++17 it is not allways guarantee! Consider: Obj create(bool condition) { Obj a, b; If (condition) { return a; } else { Return b; } } No (N)RVO optimization here, the compiler don’t know from within the function which instance should be returned. I'm talking about a pattern here, something like this happens everyday. People talk and talk where there is a lot of work to do! 
I meant, it’s not *because* of those that we don’t have threading now, it wasn’t ready before and still isn’t now (apparently), regardless of the rest (but true, it probably makes things worse...)
Are you implying that "stuff like this" is impeding your growth? Or do you mean that you're not growing and stuff like that makes the situation worse?
My point is that when we think of the "size" (or length) of a string, even a char array, historically we haven't included the null terminator. I mean, the current state of the proposal means `strlen("abc") != std::size("abc")`, which is just ass-backwards. Why do we even come up with these new generic functions intended to unify semantics if they don't behave as expected? 
Are there any places in the codebase where `encodeToJSON` is called multiple times on a single object? If so, passing the string by ref can (possibly) eliminate reallocation. For example, CommonData cd; // fill cd with data std::string json; cd.encodeToJSON(json); // do something with json json.clear(); // see note // do something with cd cd.encodeToJSON(json); // may or may not reallocate --- NOTE: The standard doesn't guarantee that `std::basic_string::clear` won't deallocate the underlying memory, but most implementations don't unless you call `shrink_to_fit`.
Hi, author here. The library is not a direct port, but has a similar interface to work with TVars (transaction variables). I started this project to prove there is a simple way to implement STM with composable transactions in C++. It is built on top of several concepts from advanced functional programming, but it doesn't require a user to be proficient in FP. I presented it on "C++ Russia 2018" past weekend, you can find my slides [here (Eng)](https://www.slideshare.net/alexandrgranin/software-transactional-memory-pure-functional-approach). The library is a PoC. I'm currently working on the optimizations and code quality. Then I'll switch to adding more useful features to it. I've implemented a demo project: Dining Philosophers task. You can find it [here](https://github.com/graninas/cpp_philosophers_stm). I'll be happy to answer you questions!
I do not remember all the details to be honest, but that {2, 3} array looks pretty static, like something that will reside somewhere in RAM even after the pointer *a* has gone out of scope. So you are essentially returning a pointer to those two constant ints that sit somewhere waiting to be assigned to *a* again next time someone calls *function*
it's undefined behavior. a[] is taken off the stack, but of course in reality only the stack pointer is changed to point to the next item below a[]. call another function between function() and cout&lt;&lt; and that portion of the stack will get overwritten. 
When returning from the function, the data in the stack is not forcefully erased (that would be wasting time). Only the stack pointer is updated, meaning that if you were to call another function, the memory area which was used for the array a would be overwritten then.
wrong. they live on the stack. and they will get overwritten pretty quickly.
I like it, it's a bit like how Rust generally does constructors as static methods :)
Pong game i mentioned: https://imgur.com/O8DJdq7
But it also changes construction into a copy or move construction for something that previously could be a simple placement new. 
Oh I see... Thank you
I came back to say that after looking at what the code actually compiled to. Shame on me! At least with that particular compiler and flags the array was just created by movs of constants to the stack, so definitely not in any memory that would remain. But is the compiler not allowed to allocate (large enough) arrays somewhere in data memory and just use a pointer to that? Sounds like a more obvious way to implement array constants than to generate code to generate them on the stack. Not that it would make it any less undefined behavior (I never doubted that it was). EDIT: Funnier is that gcc with some optimizations actually just return a 0 pointer instead of bothering with creating the array at all. Undefined behavior indeed, it literally compiles the function down to the single instruction xor eax,eax, then ret.
Ah okay, thank you!
That one is a lot less useful, though.
i am not a language lawyer. if you declare the array const and don't return it, the compiler will probably optimize.
It works because you got "lucky". And by "lucky" I mean unlucky because you'd rather your broken code failed early and obviously, but yours didn't.
Yeah... I ran another function before my cout statement and it gave me back a bunch of garbage
As far as I know a vector, to be standards compliant, may not have the short vector optimisation. Thus the allocation is always required anyway, and there's no additional cost for making it in a separate function call. Besides, how would you actually manage to dynamically change the vector object size to allow the stated size to be included in the object body? 
Compiling `a+b` where both are unsigned integers as a single instruction is optional. Compilers are free to compile it as `for (auto x = b; x!= 0; --x){++a;}`. The ability for compilers to be insanely inefficient does not mean that you cannot and should not rely on compilers being reasonable. 
If your compiler didn't give you a warning about this code, it's time to get a better compiler. https://godbolt.org/g/ECVdYn #1 with x86-64 clang (trunk) &lt;source&gt;:4:13: warning: address of stack memory associated with local variable 'a' returned [-Wreturn-stack-address] return &amp;a[0]; 
Please don't make titles with chatspeak.
 We're Lists of th'initial Table We match braces whene'er able We break routines And template things With types un-deduce-able!
I definitely will. Stroustrup always has such a down-to-earth approach to things. I like the guy.
Dev C++ is an absolute nightmare for new students trying to figure things out. For experienced devs it's probably fine. Then again vi and gdb is fine too for experienced devs.
I cover iterators and STL heavily. :) I also cover regular pointers, shared pointers, weak pointers, unique pointers, and iterators all in the same lectures. Surprisingly it helps students understand all of them when you batch them together. 
doesn't such content belong to /r/cpp_questions?
It returns the unary function which you pass as a parameter. The cppreference page even has an example of usage: https://en.cppreference.com/w/cpp/algorithm/for_each
Because programming is generally taught by people who are incompetent, to people who haven't bothered thinking/learning for themselves. This combination leads to all sorts of ridiculousness, and should be called out for the fraud that it is. 
If you want a parallel for loop, for_each is the cleanest way to do it.
That's not going to be very useful for nontrivial things: the specification may evolve substantially after the proposal is voted into the WP, and the reference implementation in the paper would not be up to date. Besides, such implementations have some of the same problems as ours, because they are still meant to illustrate and support the proposed specification rather than for production use.
When the loop body gets so long, that you refactor it into its own function, let's call it `f`, taking only the current element as a parameter, I'd say for_each(begin(vec), end(vec), f); is clearer and more concise than: for(auto&amp; e : vec) f(e); You don't have to name the loop variable with `for_each` and you can usually be sure, that `f` has side effects, but doesn't directly modify other variables in your current function. So usually, when you can refactor the loop body into a free standing function, `for_each` may be worth your time, to make the side effects of larger loop bodies more apparent. 
I learned from twitter today that arguing about cppreference with you means I will loose :) I do wonder if there is a way to fullfill this though. one is visiting cppreference to get info on the current/future cpp language and sometimes finding the implementations or even the constraints on the implementations isn't trivial. I have borrowed a few of the cppreference as starting points when the standard didn't have constexpr implementations available. Those are easy though as it is almost always random access in constexpr
Sounds like a nice course. Keep fighting the good fight.
Enums and tag dispatch isn't a competition; in fact you can get some of the cleanest code by combining them: enum class Way { THIS, THAT }; class MyClass { public: template &lt;Way W&gt; using Construct = std::integral_constant&lt;Way, W&gt;; explicit MyClass(Construct&lt;Way::THIS&gt;); explicit MyClass(Construct&lt;Way::THAT&gt;); }; Here there are only two levels so the verbosity is pretty much the same, but clearly if you really have a bunch of different paths this is going to be a lot more compact, and it's nicer to have a bunch of enum values rather than so many classes.
Oh cool.. I'm using visual studio right now. I thought that it would be really top of the line. Maybe there's some settings that I've left unchecked
Sorry I'll ask there next time
Thank you for this! It was a very in depth explanation and it makes a lot of sense. So from what I understand, when you reach the end of a scope, the variables created don't get their data deleted, but the compiler basically registers those memory locations as "empty"locations and doesn't protect them from being overwritten. Is that correct?
This is actually quite a good example. In my experience if I ever need to create `f` then it's because it needs to be called with other code in the loop. If I only ever need to do the `for_each` with `f`, I will just write that entire loop as a function. Still, I can see how this is better in some styles.
Basically, and it does so using the stack pointer. What we think of as the "stack" is just a bunch of memory cells one after another with addresses assigned to them. The stack usually starts at the top or bottom of the system memory pool and the stack pointer is just the location of the "top" of the stack. When we declare local variables, the compiler generates code that pushes our variable onto the stack. This is accomplished by: * Increases the stack pointer by 1 * Places value of the variable in the memory cell pointed to by the stack pointer (the new top) When a variable goes out of scope, the compiler generates that pops it from the stack. Popping from the stack only does one thing: decreases the stack pointer by 1. No memory is overwritten. We could still access our "destroyed" variable if we know it's location. If we know the top of the stack, we could just add one, or like you did, directly take it's address. As long as nothing changes that memory cell, the value will be accessible by it's address. Of course, we know that pushing a variable would increase the pointer, and then that overwrite our location. If you want to really understand this stuff, you'll want to learn x86 assembly language. Your compiler generates it whenever you compiler a program, and that's where all this complicated stack business takes place. But if you learn how to read assembly, all the mystery is revealed. Since each instruction performs one specific action, if you know can read the assembly generated by the compiler, you'll always know exactly what your program is doing. It's pretty neat!
Brilliant!
the MSVC compiler is the worst commonly used compiler.
&gt; You: I think that's even more reason to use more modern C++. It removes distractions about the language nitty-gritty and gives you a much nicer syntax for the basics. Me: I disagree. I does not remove distractions about the language, so most teachers avoid it, so here we are full circle _again_. 
Are you paying attention now? How about NOW?
Not in C++17 with new prvalues.
tl;dr Hammers suck. Because they're no good for clipping toe nails.
This _is_ exactly as expected; if I ask for the size of an array and get the size minus one because the array type happens to be `char`, _then_ things wouldn't be as expected. If I want the length of a C-string, I'll use the function meant for that.
This is a really fun graphic! Honestly, I rarely program for fun anymore like I used to. This graphic made me try out some of these algos that I didn't know already and made me remember why I started in the first place. Thanks man!!
Yes, this allows `for_each` to pair very nicely with mutable FSMs. (Immutable FSMs naturally pair better with `accumulate`.)
it just makes your life harder by not giving you as good of information when you do something wrong. It also doesn't give you as good of tools to find out when you did something wrong at runtime. Clang is by far the best compiler, but the shiny visual studio IDE is tempting to many and it can be difficult to understand what you're giving up by going towards the shiny.
lol I fucking love this subreddit. Some sengineer with 20+ years of programming and everyone shits on him. 
If you don't have `reverse` adapter for a range at hand, you can use `for_each` for iterating backwards. Though to be honest break often happens to be useful exactly in such cases.
https://www.fluentcpp.com/2018/03/30/is-stdfor_each-obsolete/
No, you said that the abstractions removed too much. Remember you own argument. You have yet to come up with an example where the abstractions removed so much that they got in the way of teaching the algorithm.
Ofc not. Kernel is great. It does not mean it was easy to write. And even kernel gets bugs that said c++ would simply prevented and code would look cleaner.
Came here to say exactly this. CS curricula typically focuses on the theoretical foundations of computing, algorithms, and techniques for the various fields (operating systems, hardware, informatics, languages, etc). The goal isn't to churn out code monkeys, but to produce engineers that can design and innovate from computing principles.
I'm not arguing, that this is horrible, but why would you write std::vector&lt;std::string&gt; v{0}; ?
While we are at it, can we allow for moving objects out of initializer_list? Currently trying to `initialize vector&lt;unique_ptr&lt;Blah&gt;&gt;` is a huge pain.
Not sure if it is, or isn't missing an operation\*, but the article misrepresents the paper kinda badly. The point of the paper is that the "elegant" way of writing sieve in _haskell_, a functional, lazy evaluated language, is wrong and worse than trial division. Somehow the blog post generalizes this into "most people write sieve wrong", which is hard to relate to when reading it on a C++ sub, where the naively written sieve will have various fun deficiencies, but will have proper runtime. \* in practice, there are many useful operations on priority queue that the std one is missing
This operation came up in my algorithms and data structures course at university. Pushing and popping a min/max-heap priority queue is O(log n). Many priority queue use cases, such as the one in this article, involve popping the queue and then immediately pushing, often without observing the top of the queue in between. In this case, your runtime is O(2 log n). The replace-top operation cuts this essentially in half by making the pop operation O(1) and offloading the real work to the push, so the runtime is O(log n). That's why the performance of the sieve doubled when this trick was used. I've found this operation useful in some event-based discrete simulations, where a priority queue stores the events in sorted order where the next event to occur is at the top. When an event is removed and processed, it generally pushes one or more events in response. Simulations with a large number of events can see some measurable improvement from this trick. I can't imagine this is a rare need, it can offer a signficiant performance boost, and it's pretty low-hanging fruit in terms of implementation difficulty. I'd certainly like to see it included in the standard. As a side note, typically when I find myself with a problem that benefits from this sort of optimization I turn to a lazy_priority_queue type that achieves the same effect without changing the type interface. In these cases it can serve as a sort of drop-in replacement that doubles performance for some operations. When popped, the lazy queue just makes a hole at the top of the queue, which is left there until a push comes along, filling the hole and updating the heap, or the top of the queue is observed or popped again, forcing the removal to be completed as in the usual, eager priority queue. This can have some undesirable performance characteristics if your code doesn't follow this pattern, as is common with lazy algorithms, otherwise I would recommend it as a way to implement std::priority_queue.
... You know `std::endl` inserts a flush() operation right? It's hardly reasonable to blame "iostreams" for lack of speed when you're manually flushing the stream after every printed number.
Interesting, thanks for sharing! I believe `std::priority_queue`(which is by default a max-heap) could happily support both increasing and decreasing an arbitrary value's key in O(log n) time, not just decreasing the root's key, using the `sift_up` and `sift_down` methods you describe. (Note that `sift_down` is usually called Hᴇᴀᴘɪꜰʏ in computer science literature.) This could be encapsulated in a safe API - how about: queue.update_element(it, [](auto&amp; element) { // modify the queue element however you like here... }); `update_element` could then decide whether to sift down or up.
Well usually printing "\n" does the same and comparing iostreams to e.g. libfmt shows that it is indeed iostreams who is to blame...
&gt; O(log n). Many priority queue use cases, such as the one in this article, involve popping the queue and then immediately pushing, often without observing the top of the queue in between. In this case, your runtime is O(2 log n) [...] That's why the performance of the sieve doubled when this trick was used. That's not how `O()` notation works. `O(log n)` is exactly the same as `O(2 log n)`. The idea behind your argument is I believe sound, but `O()` is the wrong notation for it. I think you can explicitly count the exact number of stack operations as `ceiling(log n)` in the first case and `ceiling(2 log n)` in the second, so given that you have an exact count on the number of operations, you don't need the much-less-specific `O()` concept. 
It could be part of template `std::vector&lt;T&gt; v{N};`
Made a program to draw a triangle over half of the tree https://imgur.com/a/bGPOQpV
It's certainly a historical wart. I'd love for it to be fixed to use a managed pointer as an overload. All of these facets could be shared pointers to allow use in any number of streams.
In Python's [`heapq`](https://docs.python.org/3/library/heapq.html) standard library module, this operation is called [`heapreplace`](https://docs.python.org/3/library/heapq.html#heapq.heapreplace). There's also [Boost.Heap](https://www.boost.org/doc/libs/1_67_0/doc/html/heap.html), which would support this use case, I guess, with calling [`decrease`](https://www.boost.org/doc/libs/1_67_0/doc/html/heap/concepts.html#heap.concepts.mutability) on the top element.
Regarding constructors I am on fluentccp's side here. But that's mostly since I consider Boost.DI (or similar DI libs) to be a great tool in larger frameworks. Static named "constructors" are simply useless in this context - in fact I personally would like all of you to stop writing them :)
I assume a conference talk? Any link then?
[removed]
Pretty much true in my case. But only the one who teaches C++. My math teacher encourages everyone to use C++14/17 and our graphics programming teachers tell everyone to ignore what the C++ teacher says and will fail you if you use his practices. He is the kind of person who insist arrays start at 1, use global variables everywhere, and want you to write all your programs in a single file. So he's interesting to deal with. At least he recently accepted that `nullptr` is more convenient than NULL. After months of arguingm.
I keep forgetting: Does the special dispensation for `0` only apply to the litteral 0 or also for compile time constants that have the value 0?
I agree with you: the naive sieve in C++ does not have the complexity problem the paper describes, and on top of that the implementation using the priority queue is "somewhat insane". It is even trivial to extend the "naive" implementation to be able to grow to dynamically arbitrary high primes without loosing efficiency if we stop at a small number (I'll pass on the IO consideration for the benchmark in the codereview stackexchange page which is *also completely insane* because we shall not benchmark IO instead of the algorithm itself): #include &lt;cstdio&gt; #include &lt;cstdint&gt; #include &lt;vector&gt; #include &lt;chrono&gt; class SieveOfEratosthenes { static constexpr int chunksize = 100'000; public: SieveOfEratosthenes() : m_compo(chunksize, false), m_next(2) { for (std::int64_t i = 2; i &lt; chunksize; i++) if (!m_compo[i]) for (std::int64_t c = i * i; c &lt; chunksize; c += i) m_compo[c] = true; } std::int64_t next() { const auto result = m_next; do { for (++m_next; m_next &lt; m_compo.size() &amp;&amp; m_compo[m_next]; ++m_next); } while (m_next &gt;= m_compo.size() &amp;&amp; extend()); return result; } private: bool extend() { const auto start = m_compo.size(); const auto end = start + chunksize; m_compo.resize(end); for (std::int64_t i = 2; i * i &lt; end; i++) if (!m_compo[i]) for (std::int64_t c = start - (start % i); c &lt; end; c += i) m_compo[c] = true; return true; } std::vector&lt;bool&gt; m_compo; std::int64_t m_next; }; int main() { const auto t1 = std::chrono::steady_clock::now(); std::int64_t count = 0; SieveOfEratosthenes sieve; while (++count &lt; 20'000'000) sieve.next(); const auto t2 = std::chrono::steady_clock::now(); std::printf("%lli\n", count); std::printf("%d\n", (int)std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(t2 - t1).count()); } Results on a i7-7700: 10'000 primes: &lt; 1 ms 100'000 primes: 5 ms 1'000'000 primes: 80ms 10'000'000 primes: 1s 20'000'000 primes: 2s If we take roughly .3 s per 1M of line IO on the author's computer, we can see that his algorithm is ridiculously slow, with not a lot of advantages... So yeah, using a priority queue to implement the sieve of Eratosthenes seems to be a really really bad idea, regardless of whether it miss some operations or not. 
My only complaint with `priority_queue` is that it has a different interface than `queue`, which means unless you write some free functions, you can't parameterize, say, a scheduling algorithm based on the queue type. I ended up writing my own simple `queue_X` free functions so that I could change the behavior of my simulation just by tweaking a template type.
I believe there's notation `~`, which means what they want `O` notation to mean; `~2 log n` is okay, for example.
Thanks. That explains, why I seem to always forget which way it is.
&gt; So yeah, using a priority queue to implement the sieve of Eratosthenes seems to be a really really bad idea, regardless of whether it misses some operations or not. That's exactly what I was thinking. Before assuming that the container is missing an operation, I would exhaustively search for a more suitable container for the given problem.
That operation could also make Dijkstra's algorithm and A\* faster. Normally an iteration of each of those algorithms goes like, 1. Pop the highest priority element, 2. Push some more elements based on that element's neighbours (maybe some `decrease_key` if you're feeling fancy.) In the case when there *are* some neighbours to add in step 2, this operation would be helpful. It also kinda feels in the spirit of C++ to say "The priority queue's abstraction forces us to do twice as much work as we have to, so maybe we should add that operation." Not sure, though, it isn't clear it would get a whole lot of use. And if you really care about running time you probably won't be using a binary heap anyway...
These exploits have nothing to do with threads.
Don't stop there. How about must requiring that every pure function be constexpr by default. That is any function which has no side effects and depends only on it's arguments should be invocable at compile time. the constexpr key word would be repurposed to provoke a compile time error if the function isn't pure. Think bigger!
Does anyone know what the rationale is for placement new not being `constexpr`? that's the biggest barrier here AFAIK. Is there already a proposal for C++20 for that?
With threads as a concept - no. With the primitives and other implementation details required for efficient multi-threading - they pretty much do, see https://github.com/tc39/security/issues/3.
new is not a pure function - it has side effects. So it goes beyond the constexpr idea. implementing this idea would require that a dynamic memory allocation system be implemented at compile time. Doable, but a whole new thing. But it seems that people want this so it might happen.
OOC, why are you referencing P0784R0 specifically, not allowing for the current [R1](https://wg21.link/p0784)?
I was not aware of this later proposal, thanks.
maybe you should just say what you want to do. people have been doing crazy workarounds in c++ for a long time. there may be one for your problem too.
Basically I want the ability to build lexers and parsers from strings at compile time. See [http://www.benhanson.net](http://www.benhanson.net) for how I do this currently with runtime construction of the state machines. I explicitly don't want to go the route of classic TMP etc.
The problem with placement new is that it has to deal with just bytes. I probably can't explain this properly, but the issue is the compiler would have to track the full state of user memory in order to do this properly (because also UB is ill-formed in constexpr). It's the same underlying problem as to why you can't make `memcpy` constexpr either. It's just bytes - rather that objects in the memory model. 
The usual obvious question: what's wrong with [Boost](https://www.boost.org/libs/metaparse/)?
Will "Down with the typename!" paper remove the need for typename in this case? Because it doesn't give the compiler or the reader any additional information that they would need.
&gt; And often the "elements" between size and capacity are random junk data. If I write `char c;` then `c` is a random piece of junk too. Where's the difference between that and one of the elements in the array?
Oh really? That's embarrassing.
I don't think it is. It's like complaining that `vector::capacity` and `vector::size` return two different values. They measure different things. It's just natural. How many characters does a string have? Use `strlen`. How many bytes do I need to represent the string? Use `sizeof`. If I *had* to pick a side I would say `strlen` is wrong because the null terminator is a definite part of any cstring. Strictly speaking "abc" *has* four characters, even if the 4th is not visible.
See http://eel.is/c++draft/ios::Init -- that's there to initialize cout/cerr/cin/etc.
But this example code does not work with ios_base. So is it useless for this example, no?
Used "Init" vs "init" is also interesting 
?? It's not the blog post that generalises your claim into "most people write the Sieve of Eratosthenes wrong". It's right there in the paper. From the paper: &gt; Despite widespread assertion to the contrary, this algorithm is not the Sieve of Eratosthenes! And the first claim in the paper is: &gt; This paper shows why this widely-seen implementation is not the Sieve of Eratosthenes If anything, your comment is the one misrepresenting the paper badly.
&gt; A good quality implementation wouldn't randomly allocate some memory in its default constructor Wasn't the reason for move_if_noexcept nonsense due to some implementation of stdlib using allocation in std::list for a sentinel?
Thanks.
The compiler can’t tell that the internal global variable is unused. 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Sorry, I was partly also replying to context from earlier on in this thread, I think…maybe? (_Shrugs._) 
Nope. The paper is a classic and is about FUNCTIONAL PROGAMS, and in particular Haskell. It complains about the fact that the naive approach gives a bad *functional* program.
There's a whole other side to this issue. Algorithms like Dijkstra's require decreasing arbitrary elements in priority queues to be really efficient. The standard container delivers nothing close to this. Moreover, it's not even trivial to do oneself since you also need to find the decreasable element from the heap in the first place. 
Of course it's a classic. I quoted from the paper contradicting GP. What did you do?
This. Especially in light of the fact that the author provides a link to his CodeReview (on CodeReview, the code review site, not StackOverflow) in which Jerry Coffin actually demonstrates a simple, proper C++ sieve implementation which is roughly two orders of magnitude faster than the author's. But hey, "surprisingly negative" comments and stuff. 
I read the paper several time since 2009. Apart from selective quoting and down voting me, what-the did YOU do? As you like quotes, let’s play the game: « Under consideration for publication in J. **Functional Programming** » The Absract of the paper: « A much beloved and widely used example showing the elegance and simplicity of *$lazy functional programming** represents itself as “The Sieve of Eratosthenes”. This paper shows that this example is not the sieve, and presents an implementation that actually is. » The you should look at the fcking algorithm: primes = sieve [2..] sieve (p : xs) = p : sieve [x | x &lt;− xs, x ‘mod‘ p &gt; 0] And compare it with the naive C++ algorithm, to discover THAT THEY ARE NOT THE SAME. Because when the author says: “this widely-seen implementation is not the Sieve of Eratosthenes”, he is talking about implementations in **LAZY FUNCTIONAL LANGUAGES**. So, &gt; Of course it's a classic. Yes, it is a classic. &gt; I quoted from the paper contradicting GP. [Yes you quoted, but the quote does not contradict the guy you were replying to. I suspect you haven’t understood the paper.](https://en.wikipedia.org/wiki/Dunning–Kruger_effect) &gt; What did you do? Told you you were wrong. Twice now. Beside asserting wrong opinion, down voting and being agressive, I am not sure what you did, though.
But then how will managers parrot it back to their engineers like it's some magic word that will save everyone from themselves?
Good point, I'm not sure what I was thinking.
I would prefer `ntd`, so it doesn't move code around when you decide to change it to std in the future.
I didn't actually read the article fully.... but `priority_queue` has also been completely useless to me in the past because of the lack of being able to re-prioritize or remove an iterator from the non-beginning. Primary example of this in my line of work is the "open list" in the A* algorithm. However, there is a very easy workaround to this in stl. Use something like `std::multimap&lt;float, T&gt;`. Then you can use `.begin()` to get the min-priority element, but iterators are not invalidated by other iterators being removed, so you can also store iterators into the middle of the list, erase those, and re-insert them with a different priority. You also don't have to use float, you can use anything with an `operator&lt;` or provide your own comparator to do the sorting
The compiler isn't allowed to make those kinds of determinations. The only one that can discard unused global variables (or functions) is the linker.
I think that the cons of factory functions are not mentioned. Namely, prior to 17, they are a no go for any type that is not movable. This automatically makes them a no-go for many generic types like pair, tuple, etc which are movable iff all of their types are movable. In addition, factory functions do not play nicely with things like make_unique, emplace_back, etc. I still think in practical terms for a user defined, application logic class, a factory function is better, yes. &gt; Second, using these type tags on the client code side, to declare the functionalities supported by their types. Not sure why you say this here; the tag doesn't need to be known at all by the client. A very common way to write generic code that needs several different implementations based on type traits is a generic interface function that takes the user type, and builds the tag, and then dispatches it. Overall though I clearly agree with the sentiment; tag dispatch is not something to use to make application code nice, it's largely just a weird implementation detail that will be gone with if constexpr.
boost.org
its a c++ library collection.
Whoa! That's a lot...could you provide a little more direction as to where to start \- especially with some that look redundant, like Effective C\+\+ and Effective Modern C\+\+ ?
Yes, exactly, I understand what it is, which is why I don't quite follow why you recommend it based on what I asked..
Effective C++ is a collection of some of the best principles to use when developing with C++. Effective Modern C++ is basically the same thing but for *modern* C++. It is not a replacement for the first book. 
Ah so modern C\+\+ being 11\+ ? We use 14 at work, are working on transitioning to 17.
It is a popular/widely used library for C++ that adds a lot of nice-to-have functionality. The code quality is overall very good and it is used by some some of the biggest companies in the world. Knowing boost will without question be helpful at some point in the near future. 
Correct, it covers 11/14 and some draft 17. 
Never heard it called STL, was always referred to as "the standard library" and a quick google search after I saw your post didn't yield that as a top result \(STL cad files was the top result, which I'm quite familiar with\). Admittedly, since we use Qt, we pretty much don't touch the STL, so my knowledge of it is marginal.
Ok thanks, that sounds like a great place to start. Also sounds like i should familiarize myself with STL just so that I'm not limited to being able to use only Qt.
Ok, valid
Indeed. Qt is a nice framework, there is no question about that, but it isn't for everyone. Boost is *nicer* in my *personal* opinion for a lot of things. I would say at least a passing knowledge of the STL is a must if just to have an idea of what is in it and how some common problems are solved.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8fni62/in_depth_c_resources/dy4yol8/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Incidentally, I find the following typedef useful template &lt;class T&gt; using cspan = span&lt;const T&gt;; It mirrors the `zstring`/`czstring` pattern.
That's precisely what this paper does, no?
Hmmmm - something like this: https://www.boost.org/doc/libs/1_65_0/doc/html/metaparse.html 
Nope. That paper only allows omitting typename in contexts where the thing *has* to be a type. Arguments in a call expression is not one of those cases. T::v() could be constructing or calling. You'd have to look ahead and use the `{}`s to back into that this must be a type. Maybe that's doable too, maybe not. Haven't thought about it too long.
Take out the include of iostream to avoid this. Also you call undeclared functions alloca and atoi. 
Er, uh, what's a span? A sub-range? I scanned the github page, honest. 
While `new` has side-effects, *placement* `new` meaning like new (ptr) T(a, b, c); seemingly should be okay if the invoked ctor of `T` is `constexpr`. Today, even if the corresponding constructor of `T` is `constexpr`, placement new of `T` at a `constexpr` memory address is not allowed, even though, seemingly, the only thing that placement new does at that case is invoke the `constexpr` function at that particular address. The point of making a function `constexpr` is so that it can be invoked in a `constexpr` context, so the restriction seems wierd. (I can sort of see the idea behind sphere991's explanation though)
I agree with this post completely especially the part to avoid complicating business code by employing techniques of generic programming when proven patterns already exist which are easier to understand and get correct (arguably). Sometimes we might have to usr these techniques but not most of the time. Correctness and readability is more important than number of angle brackets. And they are inversely proportional 😜
I'm partial to `ranges::v3::span` because of the surrounding infrastructure, but it's not exactly lightweight, obviously.
no. it's more like a generic string_view.
A span is a range of objects that are in *contiguous* memory. It essentially wraps a `{ T* begin; size_t size; }` up together in a convenient and safe manner. You're partially right - it could be used as an iterator pair over `std::vector` elements, `std::string` elements, and `std::array` elements. But it couldn't be used over `std::list` elements or `std::set` elements, for example.
Again, they can't modify constexpr state (if by that you mean constexpr variables) as those are const. They can however modify any state when involved during runtime.
&gt; T::v() could be constructing or calling What do you mean? Constructing is calling a constructor, so both sides of your options would be "calling".
A fun little trick to speed-up naive sieve without much thinking: check if the number is already crossed out before crossing it out, and don't bother if it already is. This way you won't invalidate cache line pointlessly, so it can be retired for free. Blew my mind when I tried it couple years back and got ~20% speed-up. 
This comment is now exactly 4 months old, so this is your reminder. :)
&gt;nonstd:: Wew! I'm NOT alone
U're NOT alone mate.
So why /span/, over /range/? Because /range/ doesn't exist yet, I guess? 
`v` could be a type name, so this constructs a `v` with `()` as the initializer. Or `v` could be a static member function that you're invoking (or a static data member with a call operator). That's why you need `typename` here, even after that paper.
A span _is_ a minimalistic range, and the range-v3 library comes with a `ranges::v3::span&lt;&gt;` class template, so .. what are you asking? N.b. 'range' is an overarching concept while `span&lt;&gt;` is a concrete implementation of a range (ContiguousRange specifically).
You're right that `std::range` doesn't exist, but 'range' does exist as a specific term in the C++ community. It just means an iterator pair (where the end iterator is reachable from the beginning iterator). It's believed by many that iterator pairs, ie. ranges, are a better primitive for specifying algorithms and working generically with data structures than iterators are. See: * [the ranges proposal for C++](https://ericniebler.github.io/std/wg21/D4128.html) * [`std::equal_range`](http://en.cppreference.com/w/cpp/algorithm/equal_range) (which returns an iterator pair - so the term 'range' is even used in the STL) * [https://accu.org/content/conf2009/AndreiAlexandrescu_iterators-must-go.pdf](Iterators Must Go by Andrei Alexandrescu) * [Boost.Range](https://www.boost.org/doc/libs/1_67_0/libs/range/doc/html/index.html) So, a `std::span` is a type of range, but not all ranges are representable by `std::span`.
Thanks, your answer and [this one on StackOverflow](https://stackoverflow.com/a/613132) made me realize that for a given type parameter in the template, the syntax resolution has to be the same for all substitutions of that type. So for instance the compiler has to know if `T::x * f` is a multiplication or a pointer declaration - and that interpretation of syntax applies to all instantiations.
I was thinking more along the lines of [https://github.com/hanickadot/compile\-time\-regular\-expressions](https://github.com/hanickadot/compile-time-regular-expressions) The point is to construct the state machines at compile time, rather than compile time parsing.
`constexpr` doesn't imply const for member functions. Something like [this](https://godbolt.org/g/b4pjZ7) is perfectly fine and is done at compile time, but I wouldn't call `foo` here pure.
Who would decide what goes if there are conflicts? It's a clean name but unaffiliated people sharing namespaces just sounds bad.
Oh, I see. I suppose that was clear if I had read the question thoroughly enough.
Sounds like he's describing bazel.
 namespace ntd = nonstd; I think with just ntd it isn't really clear, what it is an abbreviation for, but a namespace alias should be good enough.
How is it possible to still record with potato in 2018? Not to mention the camera [fundraiser](http://nwcpp.org/camera-donations.html) from 6 y ago.
The best way is to get in contact with the group through their Slack/mailing list...etc. Picking up some of the technical debt that has been lying around can be an extremely helpful and safe way to contribute to a existing project and the members will know where this is most needed and provide any tribal knowledge that the documentation is sure to leave out.
This is pretty great, and I see some really nice stuff in the author's other repositories but some rather obvious questions pop up: 1. Why is this code provided under the inferior MIT license instead of the robust Boost license, and 2. Why haven't some or all of these libraries been proposed for Boost? Beast has an inferior implementation of `span` (since Beast only reuqires C++11), and would greatly benefit if there was a full featured `boost::span`: https://github.com/boostorg/beast/blob/5abac8b380ffcd914126c5019c980366c5a53f68/include/boost/beast/core/span.hpp
You are right. You need constexpr for that. Not strictly but yes to keep your sanity and avoid template metaprogramming.
Threading was de-prioritized because we knew nobody would ship it even if it were ready. By and large the spec for threads has been ready for a while (we’re just missing a formal model, based on the JS one), and so has LLVM support.
Yeah that's too bad/sad, I for one was pretty excited about it (having some multithreaded asm.js apps waiting to be "updated" to WASM...)
To me it felt like QBS, but with less polish.
I don't think C++ officially knows about floating point flags.
By the way, do modules change anything about requirement to ODR-use static variables to force initialization (http://eel.is/c++draft/basic.start.dynamic#5)?
It does – they're covered in [\[cfenv.syn\]](http://eel.is/c++draft/cfenv.syn).
Two thoughts. Optional compilation: its much easier to just to compile guards in source and have the build system pass everything through the compiler. Second, YAML allergies are on the rise everywhere, just use TOML :)
There are usually two flavours of a build configuration you can find out there: scripted or declarative.
The factory is templated on the base class that it is both injecting interface into, and that it produces unique pointers to.
It does not happen if you don't include iostream.
This is the old version
That's what I was thinking. The QBS repo has some examples for anybody that is curious but hasn't played with it yet. https://github.com/qbs/qbs/blob/master/examples/helloworld-complex/hello.qbs Also, http://wiki.qt.io/Qbs_Quick_Reference The syntax is slightly odd, but it looks a lot like JSON with less quotation marks and commas. Personally, I find it more readable than CMake despite not particularly liking QML syntax for writing GUI code. I know some people have a knee-jerk distaste for anything in the Qt ecosystem, but there's nothing that ties QBS to building things that use the Qt libraries. It's perfectly happy to just build ordinary Qt-less C++. It does everything suggested in the linked blog, plus a bunch of other stuff that has turned out to be useful like setting arbitrary preprocessor defines. 
To add to this, where is a good place to find open source projects? I have been wanting to get into something lately, but don't really know where to look. I will be honest, I havent tried looking yet, but saw this post and thought it might be an appropriate place to ask on a whim.
Github
Or maybe some hybrid between the two, for instance make. You declare build targets, but the recipe to build it is a script.
&gt; I think in the case of SQLite it was the US Department of Defence who paid for most of the test suite. That's from memory, so I may be wrong. I think it was the aeronautics companies. They wanted to use SQLite in their airplane components and the software had to have a certain certification level.
Here's an example usage: InfInt factorial(unsigned n) { if (n == 0) { return InfInt("1"); } InfInt product("1"); for (InfInt i = 1; i &lt; n + 1; ++i) { product *= i; } return product; } int main() { std::cout &lt;&lt; factorial(1000); system("pause"); return 0; }
[https://whatcanidoformozilla.org](https://whatcanidoformozilla.org)
It's not great, but it does the job. Then, you can make yourself some functions that allow declarative usage of your build system. Not too bad honestly.
What's its license?
Especially considering that a LOT of information of conveyed by the preprocessor: platform, current architecture compiled \(which works even in multi\-arch builds on Apple platforms\), it's easy to do exactly that. The problem though is that preprocessor defines are not standardized, so you end up needing a header to normalize them. After that, it's quite easy to build cross platform build files. Unless you are need assembly, then NASM doesn't run the preprocessor, but gcc and clang will preprocess .S files just fine.
That's a great example where constexpr would be unimplementable; the address of b isn't known until runtime. Even if b were a global, its address wouldn't be known until link time.
Mozilla public license 2.0, according to the include file...
In this particular case, no. C++ says that members of class templates that aren't used, aren't instantiated. This doesn't have anything to do with linking/modules etc or even the sections you quoted. We just have to use it so it doesn't get eliminated completely (and once we use it, it should satisfy any other requires on static variables, though maybe my trivial usage would need to be modified slightly to count as ODR usage). When you use macros to do registration, not templates, then this becomes relevant, because usually templates are not involved. And indeed, I've seen such variables that were not ODR used get completely eliminated by a static linker; this was a source of major bugs for a library I used to work on that added support for static linking. The variables getting eliminated meant that their init never ran, so classes never got registered. In dynamic linking in practical terms even the linker never knows enough relative to when code is produced to eliminate static variables or defer their initialization, in static linking of course that's not the case. I'm not sure how modules affects this (and I assume it wouldn't be 100% finalized yet?).
I definitely miss a decrease_key operation whenever I try to use a std priority queue. It's pretty necessary for something like dijkstra's algorithm where the vast majority of your time ends up in shuffling around unnecessary duplicate entries. Every time, I end up switching to a 3rd party priority queue and cut 80% off the search time because decrease_key vs inserting a duplicate and letting it "fall out" is skewed so heavily towards decrease_key
I'm curious: What makes the MIT license inferior over the Boost license? Last time I checked a lot more projects used the former instead of the latter (e.g. on GitHub).
https://godbolt.org/g/fqtB8U
It gets optimized out because the result was discarded. But things in constexpr contexts have to produce a result even if the optimizer ultimately throws them away -- information about what you do with the answer doesn't flow backwards. For example you could pass the result into std::integral_constant and it'd be in a type. Making something like new work in a constexpr context is probably implementable. Making reinterpretations like that memcpy, work, no.
Please avoid unnecessary hostility.
There is no `abi::__cxa_demangle` on MSVC. You can use https://stackoverflow.com/a/20170989/5610137 to get the type as a string.
 While very convenient, I think it's important to recognize that `span` and `string_view` are kind of dangerous. It's easy to end up with a `span` or `string_view` that refers to a container that no longer exists: https://github.com/isocpp/CppCoreGuidelines/issues/1038 And with `ranges` the same issue would apply. For those concerned about (or maybe obsessed with) code safety, there are memory-safe versions of [string_view](https://github.com/duneroadrunner/SaferCPlusPlus/blob/master/README.md#nrp_string_view) and [span](https://github.com/duneroadrunner/SaferCPlusPlus/blob/master/README.md#txscopeanyrandomaccesssection-txscopeanyrandomaccessconstsection-tanyrandomaccesssection-tanyrandomaccessconstsection). (Shameless plug.) They're also not as "lightweight" (code-wise, and maybe concept-wise), but memory safety can be kind of a complex issue. And their documentation is still lacking, but there are code examples, and they generally behave like their standard (unsafe) counterparts. 
Many of the functions are just copy-pasted for many types. Why not make them a template functions? Why do you define custom division functions and not use existing ones?
it checks whether there is a vtable, so it should be true in case of virtual inheritance.
Idk. I didn't write it.
&gt; myint1 *= --myint2 - 3; Isn't this undefined behaviour?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8fupia/anyone_here_trying_to_learn_functional/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Fair question: https://web.archive.org/web/20150106221458/http://ideas.opensource.org/ticket/45
I shy away from libraries that aren't Boost licensed, even if it means rolling my own or using a less than ideal interface. The BSL is unambiguous, permissive, and less of a hassle when distributing standalone binaries.
Clang and GCC on [Wandbox](https://wandbox.org/) accept this: #include &lt;type_traits&gt; struct Base { }; struct Derived : virtual Base { }; static_assert(!std::is_polymorphic_v&lt;Base&gt;); static_assert(!std::is_polymorphic_v&lt;Derived&gt;); int main() { }
No, it means that some project will do that and other projects will adopt those. Not everyone is an expert willing to maintain it all. But then, how different can those be? Most don't need anything special at all. 
OP, A human moderator (u/blelbach) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8ftam4/macros_and_how_to_define_macro_functions_and/dy6rsdu/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Right, thanks for the info. I looked into it a bit but I can't recall why I didn't mention my findings about msvc. I'll try to add a parenthetical note. If I understand correctly, the demangle call is just unnecessary because you get the demangled name immediately, right?
I could be missing the point but I think it is harder to argue it is cleaner when looking at in use: MyClass m1(MyClass::Construct&lt;Way::THIS&gt;{}); MyClass m2(MyClass::Construct&lt;Way::That&gt;{}); Perhaps there is an extra step that would clean this up (like an extra enum in the class or pushing the `template &lt;Way W&gt; using Construct...` outside of the class maybe?
&gt; off topic. So what? It's interesting and closely tangentially related.
Yeah it's a shame there's no way of checking for a pointer member, it's useful for serialization too.
It's like good old references, no?
The only link between the two is the word constexpr. One is a done deal the other is an hypothetical proposal that doesn't exist, would be quite unlikely to garner an unanimous vote if it did and relies on non-C++ language (pure functions aren't part of C++). This thread is a simple question and the comment of robert completely misses the point and is, on top of that, condescending. A: "Hey do you know when I can expect the next release ?" B: "Don't stop there. How about curing cancer? Think bigger"
&gt; How about curing cancer? You still don't see how you're being intellectually dishonest even after someone points it out to you? 
Why use this instead of GMP?
A. you didn't point anything out. Your only argumentation so for as been "so what". B. "Intellectual dishonesty is a failure to apply standards of rational evaluation that one is aware of, usually in a self-serving fashion. If one judges others more critically than oneself, that is intellectually dishonest." I've done no such thing. C. Hyperboles aren't arguments and I didn't use it as such. If anything I used one to illustrate how I perceived the comment I responded to and why I responded to it the way I did.
Um, I don't think so. The documentation isn't that great yet so I'll try to explain. `std::string_view` and the various `span`s essentially store a (raw) pointer iterator and a length/count. Raw pointers are inherently unsafe and are even more so when hidden inside an object (because it (currently) makes it harder for compilers and static checkers to recognize and warn you when you are using them unsafely). The [SaferCPlusPlus](https://github.com/duneroadrunner/SaferCPlusPlus#overview) library provides generalized versions of `string_view` and `span` (called "string sections" and "random access sections") that can store any type of iterator, not just raw pointer iterators. Specifically, they can store memory-safe iterators. Where would one find memory-safe iterators? The library provides those too. The library provides containers such as `mstd::string`, `mstd::vector` and `mstd::array` that can act as drop-in replacements for their standard counterparts and whose iterators are memory-safe. As you might expect, this safety comes with a little run-time overhead. For scenarios when you want to minimize run-time overhead, the library also provides "scope" iterators that achieve their safety through compile-time restrictions rather than run-time mechanics. These restrictions make them more of a pain to use, but well, everything's a trade-off, right? 
you did not touch biggest problems for c\+\+ projects in all 3 articles: making builds faster by using a combination of precompiled headers \(/reusing precompiled headers\) and/or ccache and/or unity builds. this makes me question the level of your c\+\+ knowledge, also the value of the articles in general.
I am using Meson in one project and giving up in favor to cmake for other one. My biggest problems are: \- trouble maintaining meson files in every single damn directory of project \( some peoples like that, I don't\) \- trouble getting precompiled headers to work or reuse them for test cases \( ended writing a mess for every single test case\) \- glob scenario is .. weird \( I've expected something else really\) I still think can become a nice build system but right now is not there yet.
What does it mean for a library to be "for beginners". GMP was the very first C library I used (other than std library), what's "for intermediate users" about GMP?
I prefer to report the user that a feature is not available with a build error to being 100% source compatible with Catch.
Further investigation, which you could have done yourself but chose not to, is that it's a header only library. For some people, including beginners, that would be a very good thing. It also has a very small API surface area*, which means it could be easier for a beginner to get started with it. * Finding this out took three clicks, which is a lot of work.
According to linked part of the standard, implementation is allowed to defer initialization of `registered` to any point before its use (static variables of templates are treated the same way as inline variables). So without explicit `Registrar()` call for every registered class, it's still implementation-defined whether they will be registered before using factory. And I thought that maybe with modules there will be something like http://eel.is/c++draft/basic.start.dynamic#4 where you need to only reference one entity in the module, or only import it.
Wouldn't static asserts in combination with is_base_of offer the same protection while also giving better error messages?
Thanks! As far as I can see that makes it a bit less potentially ambiguous, which is fair, but I don't see where that makes the MIT license truly problematic. Almost half of GitHub projects (including mine) use it without issue, it seems. Do you (or [ricejasonf](/u/ricejasonf), who posted below) know of any legal matter that arose because something was MIT licensed, but that wouldn't have come up if it had been Boost licensed? Is the MIT license an issue at your work, respectively?
They're responding to aggression with aggression; odd that you're not saying this to ksharanam... &gt;_&gt;
&gt; trouble maintaining meson files in every single damn directory of project You can keep single meson.build in project root directory(I do it for small projects) and it works as intended.
 Yeah, I can understand the skepticism and of course there's no magic going on here. But the library does perhaps go to lengths not prevously undertaken. At least not in the era of modern C++. So the strategy for achieving memory safety is simply this: Avoid/prohibit the use of any potentially (memory) unsafe C++ element. That means no raw pointers or native arrays. It also includes elements of the standard library like `std::vector`, `std::array`, etc., and even the smart pointers, `std::shared_ptr` and `std::unique_ptr`. Technically it also means no (raw) references, but the programmer can choose how strictly he/she wants to adhere to the rule. Now the only way this restriction is going to be practical is if there are safe, compatible substitutes for all these prohibited elements. And that's what the SaferCPlusPlus library is intended to provide. (It's not complete yet, but most of the commonly used elements and features are there.) For parts of your code that are not performance critical (which is most of it, right?), making it memory-safe is generally pretty straightforward. You can basically just search-and-replace the unsafe elements with compatible safe ones from the library. One caveat is that the `this` pointer is actually a raw pointer and so is also prohibited. Even when it's implicit. This means that technically, you have to change your (non-static) member functions to free functions, or static member functions. This can be tedious, but it's straightforward. And in practice, you may decide that many of the (small) member functions are obviously safe and can be left as is. For parts of the code that are performance critical, some extra effort may be needed to preserve performance. In these cases, as I mentioned, the library uses the notion of "scope" lifetimes to achieve safety through compile-time restrictions rather than run-time mechanisms. Sort of akin to the Rust language if you're familiar with it. But with less draconian restrictions. Currently, as a library-only solution, the restrictions on scope elements are mostly, but not fully enforced at compile-time. So they can be abused in ways to circumvent the safety restrictions. You can have a look at [implementations](https://github.com/duneroadrunner/SaferCPlusPlus-BenchmarksGame) of some of the benchmarks from "The Computer Language Benchmarks Game" to see what high performance SaferCPlusPlus code looks like. &gt; Memory safety in C++ is wishful thinking This may be the case, but perhaps more due to the degree to which C++ programmers value memory safety more than due to technical or practical limitations of modern C++. &gt; And how is this not like dangling references..? If you post some (short) representative examples of potentially unsafe C++ code that you'd like to see made safe, I could show how the library would be used with them. Here's a simple example: /* Common string_view bug. */ { std::string s = "Hellooooooooooooooo "; //std::string_view sv = s + "World\n"; //std::cout &lt;&lt; sv; } { /* Memory safe substitutes for std::string and std::string_view eliminate the danger. */ mse::mstd::string s = "Hellooooooooooooooo "; mse::nrp_string_view sv = s + "World\n"; /* This is safe because the lifespan of the temporary string data is extended (via reference counting) to match that of sv. */ std::cout &lt;&lt; sv; } 
Meson is a pleasure to use. Thanks for the hard work.
Just a quick observation on naively replacing tag dispatching with if constexpr. Suppose we have the following structure (similar to std::advance's): struct tag_1{}; struct tag_2{}; void dispatch_impl(tagged t, tag_1) { // use t cout &lt;&lt; "tag_1\n"; } void dispatch_impl(tagged t, tag_2) { // use t cout &lt;&lt; "tag_2\n"; } template&lt;typename Tagged&gt; void vintage_dispatcher(Tagged t) { dispatch_impl(t, traits&lt;Tagged&gt;::get_tag()); // e.g. iterator_traits } Rewriting `vintage_dispatcher` in terms of if constexpr is simple: template&lt;typename Tagged&gt; void if_constexpr_dispatcher(Tagged t) { using Tag = traits&lt;Tagged&gt;::get_tag(); if constexpr (is_same_v&lt;Tag, tag_1&gt;) { // use t cout &lt;&lt; "tag_1\n"; } else if constexpr (is_same_v&lt;Tag, tag_2&gt;) { // use t cout &lt;&lt; "tag_2\n"; } } Are our clients (or we) supposed to add new tags? Suppose we add `tag_3`: struct tag_3{}; vintage_dispatcher(tagged&lt;tag_3&gt;{}); if_constexpr_dispatcher(tagged&lt;tag_3&gt;{}); `vintage_dispatcher`luckily does not compile, whereas `if_constexpr_dispatcher` does (very likely, the compiler will emit a warning because `t` is not used anymore). We can easily work around this issue by adding an extra catch-all `else`: template&lt;class T&gt; struct dependent_false : std::false_type {}; template&lt;typename T&gt; void if_constexpr_dispatcher(tagged&lt;T&gt;) { if constexpr (is_same_v&lt;T, tag_1&gt;) { cout &lt;&lt; "tag_1\n"; } else if constexpr (is_same_v&lt;T, tag_2&gt;) { cout &lt;&lt; "tag_2\n"; } else { static_assert(dependent_false&lt;T&gt;::value, "tag type is not supported"); } } Fixing `vintage_dispatcher` consists in adding a new `dispatch_impl` taking `tag_3`. We do not need to change `vintage_dispatcher` itself, we can even pack such function into a library. Instead, accommodating `if_constexpr_dispatcher` requires putting our hands on the internal implementation. This does not enhance the [Open/Closed Principle](https://en.wikipedia.org/wiki/Open/closed_principle). Clearly, maybe we do not need to support such openness (as for standard iterator categories), but in case we do, just be aware.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8fy0xg/booksresourcestips_for_java_and_c_programmers/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt;OK, then how do you want something only the linker knows to get into a type? Im not sure what are you getting at. This can be handled in a number of ways, one of which would be to reject the code that requires inspection of stuff outside translation unit. Handling of global variables is quite uninteresting though. &gt; Your example is still trying to read 4 chars out of a char and thus still triggers UB. Yup. Originally i was getting at requirement of compiler to detect such UB. But it seems it wouldn't be all that big of a strain, if we were to require handling of the correct case in the first place (it would need to track back the pointer to the original data and prove it points to correct amount of space anyways). Inspection of pointer bits of arbitrary variable would likely have to be forbidden, as you note (though its probably not very useful anyways).
license?
&gt; YAML allergies are on the rise everywhere I haven't read about that yet. I'd be curious - where, and why? Obviously, one huge drawback of YAML is that there isn't a header-only YAML parsing library for C++ - a huge bummer. TOML is much easier to parse. But TOML also has quite a number of limitations, and YAML is much more widespread. I'd love to see a header-only modern C++ YAML parser library.
So let's change the example, since that's what's being picked on instead of answering the actual question: Why use this instead of Boost.MultiPrecision?
&gt; So let's change the example Basically just moving the goalposts, then. &gt; instead of answering the actual question What do you mean instead of? The question was why this library over GMP. The "question" wasn't "why reinvent the wheel". The question was specifically about GMP and nothing else.
Is there a chance to get the resources of your courses? I also am a university instructor and took over from a former coworker (who in turn took over from one before him) and I keep trying to improve the content from year to year, but I feel like I have hit my ceiling on how to improve it in the little time I have to invest into the lecture. Also we want to start exercises for our "advanced" course this year, as it did not have any before (*shrug*). But then again building curated exercises that fit into the scope of the course and hopefully teach a nice story and follow the stuff that is introduced week by week takes ages, so some good resources might help me achieve that.
There still might be some hope though... https://bugs.chromium.org/p/chromium/issues/detail?id=821270
Those are interesting. Though I do believe we should aim to remove anything that requires a script or check through standard features (although maybe not always the C++ standard). The feedback so far tells me that conditional requires may be unavoidable for now, but I'm still doubtful about options. To me they're usually a sign that the project should be split. It may have been impossible at some point, but the goal here is to make that easy.
I'm not saying it's not *your* biggest issue today but the feedback from the industry is not leaning that way. Once you have a clean description of each module you need to build and their dependency graph, then it's only a matter of implementation to make it fast. That's why Bazel/Blaze can build Google's codeline incrementaly in a matter of seconds or minutes while projects with custom scripting and no clear dependency graph can take hours.
I never claimed that I had a final solution to present. The point of my articles is to start a discussion and gather feedbacks, which I do by summarizing the situation so far and my thoughts about a potential direction to solve the issue.
The definitive reason for having options is something like video codecs in GStreamer. There needs to be a way to disable _all_ patented codecs even if all dependencies are available. Relying on "just don't have the deps installed" is _not_ acceptable.
`system("pause")` is not portable.
Not everybody afford Google build servers, stop here please. Going from 100 mins to 10 mins build time does matter. As far as I know there is NO C\+\+ dev who want to wait for build system to see his changes, some times test cases help you, but some times is just a pain to have an not optimized build system. There is a lot of lost time just waiting for compilation. All pro's I know try all possible ways to reduce the build time, which is obvious why. Also, downvoting this really proves me what "industry" guys cares.
&gt; Since it’s a program by itself, it’s very hard to analyze for correctness and can’t easily be modified by a machine to handle something the author didn’t expect This is wrong. https://teapot.nz/welcome/index implements a script based build system, but it generates a declarative build graph. There are limits to what you can do in a build rule, but essentially you write a script. The build system executes it to generate a build graph, and then executes the parts of the build graph that are out of date in order to complete the build.
 OK, but just to clarify for other readers, I would (perhaps mistakenly) disagree with a characterization that the library's elements must be used "correctly" in order to be (memory) safe. If we set aside the "scope" elements for the moment (they don't add any functionality, they just duplicate a subset of the library's existing functionality with better performance), then the library's elements do not introduce any possibility for invalid memory access no matter how they are used. They can be used to access invalid memory, but only in conjunction with other unsafe C++ elements. And the point of the library is to make it practical to avoid using any potentially (memory) unsafe C++ element. Specifically, you cannot induce unchecked use-after-free, use-after-scope, or out-of-bounds invalid memory accesses without leveraging some other unsafe C++ element, like a raw reference or an implicit `this` pointer. One might suggest that, without enforcement, programmers will inevitably end up accidentally using unsafe C++ elements on occasion. Yes, it's not safe in that sense. A "lint" type tool would be required to prevent that. And currently, the library does not prevent non-memory-access UB, like division by zero or integer overflow (but there's no reason that it couldn't in the future). But to be clear, I'm suggesting that the level of (memory) safety provided by modern C++ coding practices (and the [Core Guidelines in particular](https://github.com/duneroadrunner/SaferCPlusPlus#safercplusplus-versus-the-core-guidelines-checkers)) is not comparable to the level of safety provided by this library. 
Broken link.
He's talking about a description format to describe what source files belong to a project, what dependencies, etc. This has nothing to do with what technique is going to be used to compile all those source files and dependencies.
Yes and no. The standard says the flags may exist but doesn't say they ever have to be set. In fact, the standard is even vague about constexpr evaluation, a function only "may" be evaluated in a constexpr context at compile time. In practice this means you can detect the difference between clang and gcc. GCC is eager and evaluates at compile time unless it can't, clang doesn't unless it has to (sets e.g. a compile time size from the result). If you make that function affect an FPU flag, then it won't get set at runtime by gcc and will by clang. Both are compliant.
You don't need Google's infra to have a tool doing unity builds or integrating distributed caching of build artifacts over the current proposed scheme. Caching is an implementation detail. Unity builds should be an optional optimization of the implementation of the build tool. And precompiled headers are hacks. They don't need a formal definition in a build system. They should be replaced by C\+\+ modules in the future anyway.
Would you have concrete use cases to share ? Because I mentionned code generation, I just wonder if there are others. 
I believe the rationale from Google was that "affording" servers is actually much cheaper than costly man hours of engineers waiting for the build to finish or making the build process extremely arcane and error prone to cut down on build time. I don't about your particular case but I think the question needs to be asked. Is the complexity of maintaining a build system with complex heuristics really cheaper than buying a couple servers?
Sorry about the Topic i don't know how I can edit it, I was having headache when I type it, it is Webassembly possible use cases and c++
std::expected is cool, but it can’t be used in constructor. (Without involving some „builder“ pattern). I’d say use exceptions unless you have good reasons not to (executable size, existing exception-unsafe/legacy code base).
for me I am very much comfortable writing typed languages like c++ than JavaScript, so if I have any reason to do any of these it might be in c++
I thought of something like this: https://pastebin.com/v5kWF97K But it doesn't protect against using another already counted class as template parameter. struct a_struct : countable&lt;a_struct&gt;{} struct another_struct : countable&lt;a_struct&gt;{} // No error So making ctor &amp; dtor private and make the derived class a friend is indeed the best solution
I never got around to moving this post, but I wanted to post the resolution regardless: The fix was reverting to an older version of Visual Studio - 15.4 worked for me. I then had to retarget the solution to work with the newest Windows 10 SDK. Additional Notes: This retarget fix did NOT work on the newest version of Visual Studio, it only worked once I had done the revert to VS 15.4. I am not entirely sure why this is. I think it has something to do with the latest version of visual studio automatically adding " /permissive" to their builds - however even in turning conformance off the issue stills persisted in the latest version. I can't seem to find the conformance switch at all in the 15.4 version of Visual Studio, and so I'm thinking the build failure could have been coming from an inability to process this configuration property for the project (regardless of whether /permissive was set on or off). Just an idea? 
From https://web.archive.org/web/20150106221458/http://ideas.opensource.org/ticket/45 The Boost Software License is based upon the MIT license, but differs from the MIT license in that it: (i) makes clear that licenses can be granted to organizations as well as individuals; (ii) does not require that the license appear with executables or other binary uses of the library; (iii) expressly disclaims -- on behalf of the author and copyright holders of the software only -- the warranty of title (a warranty that, under the Uniform Commercial Code, is separate from the warranty of non-infringement) (iv) does not extend the disclaimer of warranties to licensees, so that they may, if they choose, undertake such warranties (e.g., in exchange for payment). 
Unless I'm reading the paper incorrectly, it's disappointing to see that the Networking TS will continue with the Boost.Asio socket timer fudge (having to create a deadline_timer instead of being able to set the timeout on the socket itself).
You could just use Java.
Was [P0645R2](http://fmtlib.net/Text%20Formatting.html) discussed?
JSON vs YAML comes down to the general readability and bug prevention, especially wrt scope. YAML can become a pain when you get the indentation level wrong as it's not an error, it's just silently ignored. It's a lot more difficult to make that mistake with JSON and we're already trained as C/C++ developers to keep { } straight. I've lost count of the number of times I've copied and pasted a config section using YAML and have it become a nop because the indentation level is wrong. This get's compounded by general config management practices (media format independent) that doesn't emit errors when you insert a block/object in a scope where it has no place. If you put the effort in to the make the config file's schema validation bulletproof then it shouldn't matter which one you use and we'll all spend less time debugging config problems.
It doesn't ship with anything that checks for a header being present, but it would be simple enough to build that as a probe item.
It might help if you linked the uniform container erasure paper.
Works for me at the moment.
Some one needs to write a paper proposing moving something from a TS into the IS. It should include a synopsis of what we were hoping to learn from the TS, and what we did learn.
There is generally few reasons to pause them too...
He knows.
json is not really a configuration file language/format though. For once, it doesn't allow comments, which makes it sort-of useless for configuration files for a number of scenarios. I think what we need for YAML is 1) better/more libraries (i.e. header-only) and 2) better tooling that catches some of the problems that you've mentioned.
You should run your program from a terminal, built-in within your IDE or from a dedicated application.
As a C++ application developer, the most important feature I can think of is Modules. I would more than glad if the committee just tacked Modules in the next standard. And apparently, the "correct" approach is make compiler work as a build tool. But I don't get why the implementers refuse this solution. Can someone elaborate on this? 
[I guess this is the latest version but I'm not sure](https://isocpp.org/files/papers/n4273.txt) pinging /u/STL since he is the author.
+1. I'll use WhackWhack for VS 2017.
Because it is a recurring problem with asio. Most operating systems allow the setting of read and write timeout on most forms of "network´" hardware including serial ports. For asio it would easy to add an error\_code for timeout and return it to the async calls. For robustness it really should be the OS handling it and asio offering it through its interface. I have had to do some pretty nasty stuff to ensure that asio read calls timed out correctly when dealing with serial ports across platforms in the past.
This became my favorite argument against „C++ is not meant for embedded systems“ folks 
How can the asio implementation detect a time out of the endpoint isn't also asio?
&gt; But then, how different can those be? I have seen things no mortal man should have to.
The "make your config file keys descriptive, then you won't need documentation" is hackish. However, many YAML parsers won't preserve comments either. The needs you (and the bugs I) mentioned for YAML are still outstanding issues in every major language. I'm merely making the observation that the class of problems I described has gotten worse with the proliferation of "syntax-less" configuration formats. Which may be contributing to the increasing "YAML allergy" the OP referred to. Seeing that YAML is the primary interface for your user experience, it's in your best interest to address these problems. I know I would be more than a little peeved to find that a build failed at the end because my key indentation was off by a character.
I don't speak for Martin, but I suspect the library is MIT licensed because it was derived from the GSL implementation which is MIT licensed.
Thanks. Good to know. It just a very nice usability improvement and I'm occasionally reminded about this when I have to do some erasing. And it's been like 4 years since it's been proposed. Wasn't sure whether it's waiting for something or was just forgotten.
+1 for Qt Creator. Alt+Return brings up the quick refactor menu. If I write a header method in a class and press that, I get a neat menu with options Add definition in class.cpp Add definition Outside class Add definition Inside class Press enter or key up down a selection or click and it will do as requested and move you to where the function was created.
&gt; Feature: Added new build types to default settings.yml: RelWithDebInfo This is nice. And looks like other nice stuff in there... I definitely should check out what their travis/appveyor integration is about. Only slightly related: I think the date for 1.2.3 should be 2018, not 2017. :-) What happened to 1.2.2 btw? Always weird to see mysterious gaps in release notes.
If you are interested in testing your C++ code on travis, https://teapot.nz has a generator for it: https://github.com/kurocha/generate-travis All of the kurocha packages get tested on travis using teapot, across a wide range of compilers. e.g. https://travis-ci.org/kurocha/async
I agree. I am writing JSON-RPC service over HTTP(S) / WebSocket with ASIO and BEAST. It gets very complicated when I start handling timeout situation. This sort of thing is often more complex than you thought and easy to get it wrong and if you get it wrong, it becomes a security risk instantly. I start to think that I should have written an extra high level networking abstruction before writing an application. I hope future standard library will provide similar thing additional to flexible low level APIs.
&gt; &gt; Feature: Added new build types to default settings.yml: RelWithDebInfo &gt; &gt; This is nice. And looks like other nice stuff in there... I see many build systems supporting 'build types' that are effectively a concatenation of largely independent flags. eg, I assume RelWithDebInfo is 'Release' and 'DebugInfo', and 'MinSizeRel' is 'MinSize' and 'Release'. Is there a good reason these aren't exposed as independent flag flags? What if I want MinSizeRelWithDebInfo (or something with even more flags). It feels like this approach would lead to combinatorial explosions of type names.
&gt; Was P0645R2 discussed? No, but P0645R1 was. :) R2 is the follow-up integrating the feedback from LEWG. You can see the changes [here](http://fmtlib.net/Text%20Formatting.html#gensection-0).
`is_polymorphic` won't tell you if any of your members have vtables which would be necessary for this purpose. I think this would need to be a magical fully recursive type trait like `is_standard_layout`. For better or worse, I think you currently need to require `is_standard_layout` anyway (which conveniently also ensures `!is_polymorphic` and has-no-references) for anything shared between processes since otherwise you don't have any guarantee that the object storage is contiguous and that the compiler didn't insert magical internal pointers (unless you read the ABI docs I guess). Unfortunately `is_standard_layout` is true with pointers, so it is necessary, but not sufficient for what you want.
I understand the test case is simply used for exposition and performance evaluation. But in a real program wouldn't it be better to prevent this error type using a contract? The error only occurs when a precondition is violated, not when an exceptional condition arises. The program is at fault, not the context in which it's running. 
The deal with avoiding the overhead of exceptions being thrown isn't so much not to throw them often, but not to throw them in places where there isn't much processing time compared to said overhead. The article catches the exception at the first stack frame, which is not the usual case I would think. Finally, I would suspect that any data needed for exception processing is pretty hot in the cache. tl;dr no idea whether this is any useful for my, or any other, use case.
Can meson be used with vcpkg?
Asio uses various IO interfaces such as IOCP (Windows), epoll (Linux) and so on behind the scenes all of those should have timeouts built-in and so would get it from the OS interface. What I am talking about here for my part is not application/protocol timeouts, but rather low-level interface timeouts which for example in IoT devices maybe very important to notice if a "package" has been lost due to noise or the like on a serial line. Some protocols at the serial level resolve errors by ignoring packages so a write-read cycle must be able to timeout. This can be done by a deadline_timer, but the OS offers an internal timeout mechanism which will also allow for the freeing of hardware resources. And someone may even have to use synchronous read-write calls and there timeouts are even more needed to be error robust.
1.2.2 was released on the same day as 1.2.3, but I guess someone forgot to add it to the docs - https://github.com/conan-io/conan/releases/tag/1.2.2
I'm not really understanding what's so complicated about building c++ code? Have you ever worked with things like Maven? *shudder*. C++ builds are relatively straight forward compared to the few projects where I had to interact with Maven's POM system. Building a C++ project can be literally as simple as for each cpp file .cpp -&gt; .o for all .o files .o -&gt; executable What's complicated?
The build types exist only as a convenience for the most reasonable and popular combinations so you don't need to specify them manually for each compiler. See for instance /usr/share/cmake-3.11/Modules/Compiler/GNU.cmake for the flags in GCC: string(APPEND CMAKE_${lang}_FLAGS_DEBUG_INIT " -g") string(APPEND CMAKE_${lang}_FLAGS_MINSIZEREL_INIT " -Os -DNDEBUG") string(APPEND CMAKE_${lang}_FLAGS_RELEASE_INIT " -O3 -DNDEBUG") string(APPEND CMAKE_${lang}_FLAGS_RELWITHDEBINFO_INIT " -O2 -g -DNDEBUG") Notice how there is no set for speed optimized debug build - because it would defeat the purpose. If you want MinSizeRelWithDebInfo build type (which wouldn't be that minimal in size), just pass to the compiler `-Os -g -DNDEBUG`.
But then, would those users try anyway to write sane build files? I don't think so at all. They aren't a target for a sane build system.
I don't have a problem constructing the required command line arguments. My concern is more that the push to use the 'build type' feature of modern build systems isn't a convenient way of setting a series of orthogonal features, but rather has become a set of curated flags for specific scenarios on well known compilers. ie, why isn't MINSIZEREL directly equivalent to something like: myexe.disable(debug) myexe.disable(assertions) myexe.optimise(size) Simple things seem easier these days, but complex things seem just as hard as they ever were.
Broken for me too.
Broken for me too: &gt; Not Found &gt; The requested URL /2018/03/18/exceptional-exploration-1/ was not found on this server. &gt; Additionally, a 404 Not Found error was encountered while trying to use an ErrorDocument to handle the request.
- creating package manager stuff - for instance in some cases I want to build a docker image, in some cases a .deb, in some cases a .tar.xz, in some cases a NSIS installer - wrestling with compatible and incompatible compiler options, and handling compiler-versoin specific bugs ; I had the case recently where I tried to migrate to LLVM's lld linker and thus used a simple detection flag to check if `-fuse-ld=lld` was an available flag... except ubuntu 17.10 shipped a buggy version of lld which did segfault with my app so had to check the OS version. Also using precompiled headers is sometimes hit-or-miss, eg I had a lot of trouble with PCH + -fsanitize=address or PCH + debug info compression - parsing code, sometimes some libs need particular action to be taken by the build system if a particular macro is present in the source. - enabling specific optimizations, eg -march=native if the user requests it - generating unity sources (eg aggregating all the .cpp files in a single "master" cpp file) etc etc 
Timeout are provided by the OS (usually). ASIO goes out of its way to not provide this functionality. You cannot write a networked app without timeouts.
Nice. So it can still go in C++20 at the next ISO meeting?
That sounds entirely reasonable ;)
It does because you are launching your program using the debugger (F5). Launch it without it (Ctrl+F5).
Well at least for me personally I'd say that RelWithDebInfo is one of the most common use cases (and everyone that isn't using it, should know it's there and awesome in certain scenarios). It's debugging with the run time speed of release mode (necessary if you're debugging a slow algorithm on high-dimensional data and you can't reduce the dimensionality for debugging), but with still enough debug information that you can step through it and see what's going on. It's good to have this by default.
This might work if you are not planning to distribute your source code/binary to outside and all of the dependencies are already installed in your search path with no way to customize to build process. Things get a little complicated when you want to distribute/integrate/customize
* Spinning up a docker container before an integration test, stopping it after the tests have run * Anything in doom_Oo7's list What you're trying to build looks a lot like Maven, the de-facto Java build tool. Perhaps it's a good idea to take a look at how that works and grabbing some ideas from there?
Shamelessly showcasing my own project....
Great library! Pozdrav :)
Really nice and clean code. Would love having you as a coworker ;)
Thanks! I will need to put it in my benchmark suite and see how well it performs. 
Thanks. It's my first open source project. Kinda nervous what the pepole will think xD (Hvala)
You're welcome. Please report any bugs you find. The library is small so it's more or less tested. By you never know...
Sure, but that's true for most programming languages. Dependency resolution isn't a simple problem, nor is configuration management. Those two problems being hard don't mean that C++ is hard, just that C++ exposes the power of dependency resolution and configuration management to the user, instead of forcing pre-determined solutions.
Hey thanks man. I'm very much a follower of Alexander Stepanov(desgined of c++ STL). If you're intrested you can look him up on youtube https://www.youtube.com/watch?v=k-meLQaYP5Y He's got great lectures on how to write great and clean code.
&gt; Sure, but that's true for most programming languages. Dependency resolution isn't a simple problem, nor is configuration management. Technically, yes, but C++ makes it extra hard. You get a random python project, with a requirements.txt file, and just go: virtualenv venv source venv/bin/activate pip install -r requirements.txt and you are *done*. The python file may have required numpy, the full tensorflow implementation, an web crawler and an image manipulation library, but you just don't care. (It is ironic that, in many case those hard-to-install dependencies are written in C++). (Of course, it can get more complicated than that, and downloading code from the interwebs is not something good in all contextes, but, in many many cases, this is so superior to anything C++ has to offer that it isn't funny). You are gonna argue that virtualenv and pip are not part of python. I'd argue that C++ makes it extremely difficult to have such tools happening.
You might want to clarify in the readme the differences with the slot_map being [proposed to the standard][1]. It look similar in principle, except the key is exposed as an argument type that must be 2 numbers agregated together (the index and a generation number, to make sure you don't access another object that happen to have been constructed in the same slot than the previous one). [1] http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0661r0.pdf
PEGTL is an excellent library. [I used it to build a parser for an Elixir-like scripting language](https://github.com/vector-of-bool/lix/blob/develop/source/lix/parser/parse.cpp) and found it more than capable. It was my first usage, so I'm sure there are ways I can improve my grammar. I manually did my own AST thing with a hacked together push-down automata, and I'm curious if the AST support could work for my use case? While Boost.Spirit might be exceptionally clever, I think PEGTL wins for being simple, easy to use, and extensible. It also doesn't balloon compile times as quickly, and the error messages are much more scrutable. Highly recommended. /u/ColinPP, is there any work towards memoization/packrat parsing? I also saw some discussion about custom token types, which I realize is somewhat against the idea of PEG but might offer huge performance gains. Any intention of adding custom tokens?
Why the aren't the classes STL enough supposed they are made for best performance. 
&gt; You are gonna argue that virtualenv and pip are not part of python. I'd argue that C++ makes it extremely difficult to have such tools happening. I don't really care that virtualenv and pip aren't part of python. I don't think C++ should have it's own package manager, so I certainly wouldn't accuse Python of needing one. &gt; Technically, yes, but C++ makes it extra hard. The difference here isn't that Python has easy package installation, the difference is that Python has less choice in how a package is compiled/installed, and has a community that offloads the dependency and configuration management to a collectively agreed to set of programs. Python can, as a generalized and highly amorphous classification of shit being done, more easily install a package specifically because Python doesn't give the end user as much flexibility in how things are accomplished, nor does it Frankly, I think it's not that C++ makes it hard, I think it's Python that makes it brain-dead and nearly useless. Python gives me no control, and renders itself unsuitable for a lot of tasks because of that. &gt; You get a random python project, with a requirements.txt file, and just go: &gt; &gt; virtualenv venv &gt; source venv/bin/activate &gt; pip install -r requirements.txt &gt; &gt; and you are done. Your requirements.txt file describes a list of packages that need to be installed for a given python package to work. My Gentoo Portage "ebuild" file does the same, with less typing. "Emerge name-of-package" or "ebuild /path/to/ebuild/file.ebuild merge", depending on if the ebuild file is part of a repository, or just some random file. Gentoo: One command, done. Pip: 3 commands. &gt; The python file may have required numpy, the full tensorflow implementation, an web crawler and an image manipulation library, but you just don't care. (It is ironic that, in many case those hard-to-install dependencies are written in C++). Well, maybe you don't care. I do. What if I'd rather use a different implementation of the numpy interface? What if I'd rather have tensorflow compiled with certain options that make the operation I'm interested faster at the expense of other operations that I don't care about inaccurate? &gt; (Of course, it can get more complicated than that, and downloading code from the interwebs is not something good in all contextes, but, in many many cases, this is so superior to anything C++ has to offer that it isn't funny). You say superior, I say useless? I mean, how does anyone get anything done with Python if you have no options on proper dependency, configuration management? That just sounds very broken. ------- ------- ------- A big difference between C++ and Python is that Python has no "build step" that's *required*. It's an interpreted language (with, of course, optional ahead-of-time "compilation"). So installation of a python package can be literally as easy as copying the files to the destination folder. C++, on the other hand, is not typically treated as an interpreted language (Though, projects for that do exist). So there's no real choice but to compile ahead of time. This involves a *lot* of options on how to do so. Exceptions or no exceptions? That's a choice that has ramifications for runtime speed / behavior. RTTI or no? O2 or O3? Fast floating point math or precise? Link time optimization or not? Debug symbols or not? A language that offers nearly no choices what-so-ever is a language that has nearly trivial requirements for effective dependency and configuration management. If you're already willing to pay the price (whatever that happens to be, slower computation, less or more accuracy, what have you) of nearly no dependency and configuration management choices, for your target application, then sure it's possible, even practical, to take advantage of the drastically reduced complexity of dependency and configuration management to adopt a single way of doing things for the entire community and have a "our way or the highway" mindset. But C++ is THE language with the most options for dependency and configuration management that I'm aware of. I'd be interested to know if I'm wrong, but I'm fairly certain that C++ is the most configurable programming language out there. * The compiler has hundreds of compilation flags that can be set, each changing behavior in complex and hard to analyze ways, and most of them can be used independently of each other. * The linker has it's own options, each of which changing it's own behavior or the runtime behavior of what's being linked. * Theres link time optimization * You can compile each CPP file with different compilation options, and then link the resulting .o files together. * You can even use a different compiler on each cpp file. * You can link each .so file with a different linker, with a final "program" consisting of all of these differently compiled .o files linked into .so files (each with a different linker) * Your C++ program could, in fact, be pure C11 code. * Or it could be entirely inline assembly wrapped by a single C++ main function. * Or it could be C++ code that links against a Fortran binary. * Your C++ program might be built with custom C++ attributes that only work if you load a compiler plugin. Effectively making your program C+++, instead of C++. * Your C++ program might be linked as an elf binary, or a PE binary, or a Mac whatever, or a custom format that only your organization uses, or anything else. * Skys the limit. And that's just what I came up with in about 5 minutes. So sure, you can use Python's Pip. And yea, it installs things "correctly" without a lot of fuss. But you're paying a price for that simplicity. Is it worth the price? Up to you. Not worth it for me, but I have different goals than you do.
Thank you for your feedback, greatly appreciated! We are currently not planning to implement memoization because our impression was that it would add a lot of complexity with questionable benefit. That is, while the packrat approach is faster in theory, in practice it uses a lot of memory and often isn't actually faster. We are of course open to look at any research or benchmark that might convince us otherwise, even though we generally prefer the "small and simple" approach. The subject of custom tokens is something that we see as a long-term project; at this point we only have a rather vague idea of somehow generalising the input to sequences of arbitrary objects, and allowing hierarchical parsing where a first grammar translates the input to tokens, and the next grammar up reads tokens rather than bytes. Version 3.0.0 might include a large rework of the input layer where we will look very closely at this kind of generalisation beyond byte sequences, but we haven't even started working on this yet, and probably won't for a while. Any input, examples, or requirements and possible use cases, in short: anything that could help drive the design in the future, are highly welcome.
&gt; make options available but only to a "root" (or "final") project that cannot be used by another one (can't be a dependency) This only works if dependency projects do not have options. Real world experience seems to indicate that this is not the case. &gt; we don't get clogged into diamond inheritance of hell If you mean diamond dependency of hell then this is only a problem if you have the same dependency with different configurations. In Meson this is not the case, any dependency can be there only once with the exact same settings. This is how package management works in Linux distributions.
How do you achieve constant time lookup when backing storage is std::deque? 
In the documentation it's stated that SlotMap should be avoided for iteration because slots over which you iterate might not be in contiguous memory. Dense map however store all values in contiguous memory(std::vector). There is no faster iteration the iterating over a contiguous densilly packed memory.
I'm not sure what exactly do you mean. std::deques []operator is constant time. Exactly how it knows where to look, well for that you can read the implementation section of the readme.
They perform well within the constraints the STL puts on them. 
&gt; How do you achieve constant time lookup # &gt; I'm not sure what exactly do you mean. From your title: &gt; constant time ... lookup
Well as I said, SlotMap id is just an index into the std::deque. So I simply use std::deque&lt;int&gt; d; d[id] = 5; For example.
they are too general to give best performance
Removed. Work with Bryce to follow the "one top-level post per employer" rule in https://www.reddit.com/r/cpp/comments/88nlpv/whos_hiring_c_devs_q2_2018/ .
I gotta say, until you mentioned this I had never bothered to think that `deque` had constant-time lookup. That is actually kind of magical.
You should spell check your readme.md
This a pretty cool method that could be extended in a number of useful ways. If you're after something a little more straight forward, but much less flexible, have a look at the `skip` command in `gdb`. eg, one could add something like `skip -gfi /usr/lib/gcc/*/*/include/*` to one's ".gdbinit".
It's not as fast as direct array indexing, which would be the case for a vector. For deque there probably needs to be a modulus operation done, to get the memory chunk in which the object resides. However it's still constant time, no matter the size of the deque. 
http://en.cppreference.com/w/cpp/container/vector Yes, you're right. The impact is the same, though, which is that you can't have small-size-optimized vectors.
Benchmarks?
I'm the author of [the slot_map proposal](https://github.com/Masstronaut/slot_array/blob/master/P0661r2.md) which includes links to both [my implementation](https://github.com/Masstronaut/slot_array) and [Arthur O'Dwyers on the SG14 repo](https://github.com/WG21-SG14/SG14/blob/master/SG14/slot_map.h). I love seeing people start to adopt the container and implement their own variations, but I think you are doing a disservice to potential users by using existing names (dense map and slot map) for concepts which are fundamentally different from the ones those names are already associated with. I encourage you to consider changing the names of your containers. 
&gt;it's stated that SlotMap should be avoided for iteration This is the exact opposite of what users should do with the currently proposed slot_map, which is one example of why I encourage you to consider changing the names of your containers.
They are made for broad, generic usability in almost all cases. They are not made for the best performance, and this is a common topic of conference talks by performance gurus.
Well, like I said, it's more for usability so they're not really important (or advanced). They're just easier ways to do things that are possible in C++11, but cumbersome to write: So a short list: 1) make_unique 2) generic lambdas, so that you don't have to repeat yourself when using `&lt;algorithm&gt;` 3) loosening the restrictions on `constexpr` functions I would say they're actually less advanced than C++11, especially `2` and `3` because they're much easier to use.
&gt;&gt; Unlike Spirit, the grammar is implemented with compile-time template instantiations rather than run-time operator calls. This leads to slightly increased compile times as the C++ compiler is given the task of optimising PEGTL grammars. I thought boost.spirit is far slower on compile time.
Hey u/t0rakka. I liked your comments in r/simd and creeped your comment history. I've written many mesh builders over the years that faced exactly this problem. My solution is to just insert all of the verts into a vector and lexicographically sort them. Duplicates will then be adjacent in the vector and can be removed in a linear scan. Then comes the problem of mapping triangles that index removed verts to the remaining verts. The solution to that is to have the vector contain verts each wrapped in a struct that tacks on an int that records the original, unsorted index of the verts. After sorting the vector, you can use that to linearly build an table mapping the original ordering to the sorted ordering. And, when removing verts, you can map the original indices of removed verts to the indices of their final representative verts.
_Was_, definitely, but not Spirit.X3.
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8gf7i4/how_do_i_print_out_a_certain_part_of_a_string/dyb8k7m/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Might be able to do the encryption using varadic templating instead of recursion.
This really screwed with me last night.. &gt; In the C and C++ programming languages, the comma operator (represented by the token ,) is a binary operator that evaluates its first operand and discards the result, and then evaluates the second operand and returns this value (and type).
Somehow uglier than Spirit and likely not as battle-hardened.
Indeed; there is more to it than that. The order which the indices are consumed is also critical to the GPUs vertex caching; the vertex program is cache for N last indices (N is typically quite small value, much smaller than 128). This means it is beneficial to reorder the triangles so that the multiple instances of indices are not too far from each other. I picked up this trivial while working on a GPU driver's command processor microcode. That one particular architecture had an instruction to tell cache index of vertex index if the result was cached; then the CProc could make a decision if the program should be executed or result looked up. This sounds terribly inefficient since that approach suggests that the execution is single-threaded but it wasn't; there were multiple transformation instances running simultaneously the the cache lookup was coherent between the instances so it was all working really nicely. ;) Back to the vertex ordering; there are two ways to achieve it. One is to re-order triangles, which is effectively same thing as if three indices were re-ordered. The other way is to "rotate" the indices. You can rotate the indices clockwise or counter-clockwise as long as their internal order remains same. This only works for triangles. Triangle strips of course are completely different beast but can be effectively ignored as from GPUs point of view it is just a storage scheme for the indices ; the GPU simply sees three vertices (or indices in this case). The upside of strips is that the indices take less storage but when you start using "restart" index (typically -1, all-bits-one in 2s complement) the savings are reduced. Long story short: not worth it. Using non-indexed strips is usually worst idea because the hardware is often optimized for indexed triangle lists so I won't go there in any amount of detail. My first exposure (getting bit by) to the algorithm scaling (O) was indeed building a mesh. We wrote this 3DSMAX exporter for version 2 or something really ancient like that. It worked OK but then one day we exporter something a bit larger, 30K vertex mesh or so and it took 35 minutes to export. When I added a simple hash to look up the vertex indices the time was reduced to 2.7 seconds which was good enough. This was in 199x with 3Dfx Voodoo's and software rasterizers. I am NOT looking back with nostalgia as the graphics cards back then were pretty crappy. ;) Fast forward a couple of years and I started using std::map where the vertex is the key and it's index is the value; that is super trivial and just works. There is no point improving it anymore after that since it's in tooling and doesn't bottleneck or cause any user waiting anymore. That said, I am not really working on graphics at this time but been doing network programming for a couple of years now. A bit of wheel reinvention maybe but at the right time; streaming GPU command stream over cellular/mobile network for game streaming service (a bit like netflix-for-games kind of thing going on with this) except with very low latency as the rendering starts immediately opposed to streaming video recording of the game content as that approach is mostly synchronous: the game frame has to be fully rendered in server before it can be encoded and sent to the client so that introduces latency. This approach starts rendering "at the same time" (minus the connection latency) and it works quite well. So maybe I am still working with graphics after all? Thanks for writing up, cool! :) 
The comparison of compile-times is likely outdated, we will remove it from the documentation. Both Spirit and the PEGTL put a big burden on the compiler, even though both are improving over time. At this point we don't really know which compiles faster; it might greatly depend on the use case and, as with all benchmarking, might. not be so easy to quantify well.
This. C is a bad language. The subset of C that compilers with `-Wall -Wextra -Werror` is a far superior language.
The only place I've seen comma operator overloading used is [Boost.Assign](https://www.boost.org/doc/libs/1_67_0/libs/assign/doc/index.html#intro), which allows list initialization-like behavior prior to C++11. vector&lt;int&gt; v; v += 1,2,3,4,5,6,7,8,9; Has anybody else seen any other uses?
It's potentially useful for creating EDSLs, but other than these two, all I'd have to say is in unit tests for the standard library implementations :)
not in msvc it seems :\(
I'm cross-posting this for discussion, not because I agree with it!
May 10th, 2012 - it isn't worse discussing in 2018.
Hm? [It's there](https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-1-c4548).
Unfortunately, this example doesn't warn in MSVC 19 until /Wall: https://godbolt.org/g/sVzqYV I hope there's a way to do better than /Wall considering it's way too verbose in general, but I'm not as familiar with MSVC.
&gt; Has anybody else seen any other uses? [You do not want to know](https://twitter.com/ericniebler/status/559119062895431680)... (note this is old, there are less ugly ways now)
http://idownvotedbecau.se/imageofcode
This isn't a use for comma overloading, just the regular comma operator.
yikes, without #pragma warning \(default : 4548\) its isn't detected, and its supposed to show with W1 or am I reading it the doc wrong...
I'll change them. If anyone has any proposals for the name of the slot _map, please share them. 
[compiler explorer](https://godbolt.org/g/WnV1ex) if I remove the pragma there is no warning .... what I don't understand is what am I missing from my commandline :|
It's nice to use SQL in C++, see [SOCI](http://soci.sourceforge.net/).
Yes it is very much different. Accessing is done via an index. Not a key which hashes to an index. If an index tells your object is not stored there, there is no need to look anywhere else, it wont be there. This data structure is used for completely different things, than what a has table is used for.
It’s always depressing to see somebody who’s clearly resourceful (ZeroMQ and nanomsg are indisputably amazing pieces of software) miss the mark so completely. Martin Sústrik is committing a very simple, fundamental fallacy. His whole argument hinges on the misconception that you must use certain features in C++, otherwise it isn’t C++ (exceptions in part I, and `std::list` in part II). To a (somewhat informed) bystander the flaw in the logic is glaringly obvious, and shows fundamental gaps in knowledge. It’s worth reminding ourselves that we *all* have these gaps of knowledge. This doesn’t excuse Martin’s lapse, of course. And the consequence — nanomsg being implemented in C — shows that such fallacies can have far-reaching negative consequences.
`/w14548` or `/we4548`; see [the docs](https://docs.microsoft.com/en-us/cpp/build/reference/compiler-option-warning-level).
I guess I'll add them.
Do it.
Yeah - you are correct, i missed somehow that random access iterators guarantee that. I always assumed that deque would give insert constant time by being implemented as list of vectors (and thus have linear indexing), but it seems insert time is only amortized constant instead. So this span_map is the same - amortized constant inserts, correct?
yeah. gogogo!
banana
I'm interested what will happen in the future with `constexpr` and optimzations. It might do similar things.
&gt;return x == 1.3f; This can sure be surprising, but if you have real life code where something compares floats with equality operator, then problems are rooted much more deeply. Also, plugging this (revised version, original is lost to time probably): https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
DenseMap is now called SlotMap and SlotMap is now called SlotList to reflect an already existing name SlotMap and its meaning. 
You are using the debugger launch (F5) instead of run (CTRL + F5) from visual studio. The reason a debug run is not keeping your window active is because debug sessions are so you can watch your program (in visual studio), not it's console output.
Yes yes. Only I've changed the names of the containers. dense_map is now slot_map and slot_map is slot_list. Al containers have amortized constant time insertion. Unless you know in advance how much space you need, then you can simply do a reserve and insertion will be const ant time.
std::list has constant time insertion.
My suggestion: - Create a tic tac toe program using a library such as Boost or SFML, so not a console program. - Create an interface where a user can choose to play against another user or the computer - Allow the user(s) to enter his/her/their name(s) and store win/loss/draw statistics for each user - Optionally: store these statistics to disk so they can be used again when the software is restarted - Display the statistics on the screen when playing the game. E.g.: top left: gotinpich /n 5 wins 6 draws 1 loss - Allow multiple computer opponent difficulty settings: -- Easy: the computer will always choose a random spot -- Medium: the computer will choose a random spot, but block the player when possible -- Hard: the computer will play a mathematically perfect game
Yeap. Sorry for the misconception.
&gt; That also lets you union each node with an emtpy state to store a linked list of unused slots. Store the head ptr in the slot map control structure and push front whenever a slot is erased. This is how it's done in the library.
Can someone explain the generated assembly/optimisation here? https://godbolt.org/g/foyYhV I do not understand why clang can optimize it for doubles and long doubles, but not for floats 
&gt; Create a tic tac toe program using a library such as Boost or SFML, so not a console program. Tbh graphic development is the last thing I'd suggest to a new C++ programmer. 
ah, you are right, I thought people asked for real use case of comma operator... :) 
&gt; Clang correctly determined that the image buffer is not actually being used, despite the memset(), so it eliminated the allocation altogether and then simulated a successful allocation despite it being absurdly large. Allocating memory is not an observable side effect as far as the language specification is concerned, so it’s allowed to do this. My thinking was wrong, and the compiler outsmarted me. How does the compiler know that the functions *malloc()* and *memset()* don't have side effects? Is that just some hardcoded rule in the compiler? I find it a bit strange that it optimizes away an entire call to a library function.
First of all I am 99% sure that "bug" you filed against clang is not a bug. Beside that example with 1.3 is not a compiler biting, but the fact that some FP numbers can not be represented precisely( I am sure you could write asm code that tells you that 0.1+0.1 !=0.2). Also AI analogy is less than ideal. Most serious AI use machine *learning*, while compilers rely on complicated rules encoded by compiler programmers. 
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8ggw90/best_resource_for_experienced_programmer_to_learn/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Not sure if this is also true for C, but here is a document about C++ style allocation http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html
Well, strike one for not reading library and only documentation.
Ah, I thought it was type erasure of containers not uniformly erasing elements from containers. :) Makes sense.
Probably because doubles and long doubles can represent all int's (on that platform), while floats can not. Also looks like gcc does not recognize that multiplication by 0.0 in those cases will yield zero. 
Because the compiler provides the implementation for them, and knows there are no side effects. You can stop this behaviour in gcc with -fno-builtin. See https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html
&gt; if you have real life code where something compares floats with equality operator, then problems are rooted much more deeply. * unless you know how FP math works and account for that in your code. Actually I have fixed a surprising amount of bugs that were introduced by comparing FP values using tolerances/epsilons mindlessly.
First, thanks for the full reply. It is always appreciated when some atual thoughts are put into a rebuttal, even if it sortof raise the stakes of what would consitute an appropriate answer :-) To put some context, I am not just a random C++ basher, I am actually a fan, and my experience in languages up to C++ goes roughly goes as follow : 1983: assembly, 1987: C, 1989: C++. I was working for a company that sold C++ multi-platform *binaries* libraries in the late 90's, so I've been throught the hell of releasing different version for different compilers, and runtimes (threaded on non-threaded, etc). That said, being an old fart doesn't make me right, of course. [...] &gt; Frankly, I think it's not that C++ makes it hard, I think it's Python that makes it brain-dead and nearly useless. Python gives me no control, and renders itself unsuitable for a lot of tasks because of that. That's I would disagree with. There is actual control with python. I am not saying that python and C++ fullfill the same role, but, today, **if I have to do number crunching, I will use python instead of C++**, something I would not have thought of a few years ago. &gt; Your requirements.txt file describes a list of packages that need to be installed for a given python package to work. My Gentoo Portage "ebuild" file does the same, with less typing. "Emerge name-of-package" or "ebuild /path/to/ebuild/file.ebuild merge", depending on if the ebuild file is part of a repository, or just some random file. Gentoo: One command, done. Pip: 3 commands. This is facetious, and you know it. Emerge doesn't work on Windows. It doesn't work on OSX. It doesn't work on Ubuntu. It is the distribution package manager. It is the equivalent of apt-get (or maybe brew), not the equivalent of virtualenv + pip. [...] &gt; What if I'd rather use a different implementation of the numpy interface? What if I'd rather have tensorflow compiled with certain options that make the operation I'm interested faster at the expense of other operations that I don't care about inaccurate? To be honest, in that particular example, I found the things was not using the GPU, so I actually had to do [```pip install tensorflow-gpu``` to get the GPU enabled version](https://pypi.org/project/tensorflow-gpu/). So, it is not a problem to use a different version **if you want to**. &gt; &gt; The python file may have required numpy, the full tensorflow implementation, an web crawler and an image manipulation library, but you just don't care. (It is ironic that, in many case those hard-to-install dependencies are written in C++). &gt; Well, maybe you don't care. I do. Do always you ? When you use a locally installed dependency (Ie: libXXX), do you really care about its sub dependencies ? Do you care if it uses opencl or cuda ? Do you care if it uses libcurl or something else to download stuff ? What zlib version it uses for compression ? &gt; A big difference between C++ and Python is that Python has no "build step" that's required. It's an interpreted language (with, of course, optional ahead-of-time "compilation"). So installation of a python package can be literally as easy as copying the files to the destination folder. Numpy is native. Tensorflow is native. Many python libraries are in fact wrappers around C++, so I don't think this ia valid argument. In your argument: &gt; C++, on the other hand, is not typically treated as an interpreted language (Though, projects for that do exist). So there's no real choice but to compile ahead of time. Go is a native language, and have no problem with package management. Being compiled to native code makes it harder to get package management, but not impossible. What makes it hard for C++ is IMO the lack of standardisation. &gt; This involves a lot of options on how to do so. Exceptions or no exceptions? That's a choice that has ramifications for runtime speed / behavior. RTTI or no? O2 or O3? Fast floating point math or precise? Link time optimization or not? Debug symbols or not? IMO, you are mixing things, here. O2 vs O3 should not be my problem as a user of the library on a specific system (I should be able to get a custom version, if I need it, but level of optimisation of my dependencies should not be a core focus for me). Floating point behavior of my dependencies is also something I shouldn't care about too much in a perfect world, but would agree is an issue. Debug symbols ? I should probably have both. Exceptions, RTTI, instruction set (avx,bmi2,etc), are a PITA. &gt; [...] then sure it's possible, even practical, to take advantage of the drastically reduced complexity of dependency and configuration management to adopt a single way of doing things for the entire community and have a "our way or the highway" mindset. Why should that be ? Is it too much to ask that I can use someone's C++ code without having to delve into his build system and understand all its variables ? And making sure it is not installed system wide to not break anything else ? And unserstanding how to distribute it, so my code can work on some other machine ? I feel it should not be difficult to get something working from source (when you have access to the source of your dependencies), but today it is. &gt; But C++ is THE language with the most options for dependency and configuration management that I'm aware of. I'd be interested to know if I'm wrong, but I'm fairly certain that C++ is the most configurable programming language out there. My very light exposure to verilog/vhdl make me thing that those may be worse, but as far as general purpose langage goes, I would agree with you. &gt; The compiler has hundreds of compilation flags that can be set, each changing behavior in complex and hard to analyze ways, and most of them can be used independently of each other. But at the end, I should not care that much about how the libs I use are configured. [... removed many ways by which a C++ program can be compilcated ...] This is the core of the issue, I think. The fact that one CAN do all that should NOT mean that **I** HAVE to do it, nor that **I have to understand it for the libraries I use**. Your lib may be extra complex, but if I want to use it, I should be able to say "give me" (mostly) and have something "reasonable" (ie: usable). [...] &gt; But you're paying a price for that simplicity. Is it worth the price? Up to you. Not worth it for me, but I have different goals than you do. The price we are paying is that developers will move away from C++, which is already considered legacy by many. What pains me is the fact that this huge necessary complexity is pushed all over the place, instead of being constrained to where it is needed. It should not be complicated by default. I don't know how it should be adressed (more specifically all the ways I can think of have major trade-offs), but I do know that there is a big C++ usability problem here (that even impacts me, so I can't even imagine how alien it is to newcomers), and that the first step to fix a problem is to admit that it exists. Anyay, thanks for the reply, and have a nice day !
Yeah. I should have made that clear in the documentation.
```-Wreturn-type is enabled by default``` very helpful for catching dumb bugs on projects where ```-Wall``` isn't a practical option.
Hey this is great! As someone stuck in the corporate world I need versioned releases so we can track our dependencies easier
&gt; *unless you know how FP math works and account for that in your code. Can you give a non-contrived example? Im really curious to see how that would look.
It just knows. Compilers can (do) have special knowledge about certain functions. Fun story. I was moving a bunch of software (effectively a custom linux distribution) to newer gcc. In one of the software packages we were getting stack overflows, which didnt happen before. It turned out, that: a) there was some ancient package, which provided its own implementation of calloc (with implementation as one may expect) b) gcc started performing an optimization, that if it saw malloc &amp; memset in sequence, it would replace them with a call to calloc
I'd suggest to solve some probleps from TopCoder/HackerRank on C++ to learn stl containers, algorithms and their compexity. STL can be very powerful tool and you have to learn how to use it properly. Also it's good chance to learn about different data types size, integer overflows and so on
`constexpr` should be safe, you can easily forbid any kind of undefined or implementation-defined behaviour because the compiler is running it and can take the time to make checks.
Its an issue with ancient package. You are not supposed to provide definitions of standard functions.
There is also an [issue](https://github.com/abseil/abseil-cpp/issues/87) for Abseil requesting releases or tags, but Google has not decided on it yet. 
Make the UI web based Wrap the backend behind a REST api
&gt; projects where -Wall isn't a practical option *shudder*
Do you really believe that a 1.5 month novice would manage to make that work in a reasonable amount of time? And for what purpose? To have a ui for the sake of having a ui?
Does gcc not do X.0 releases or did I just miss 8.0?
To test his/her C++ skill and learn something new. I'm not saying that this can be done in a reasonable amount of time and he/she did not say anything about that either
X.0 are in-development branches; the first release of said branch makes it X.1. The versioning change started with GCC 5.
First the korean peace treaty and now we got a new cpp talk by alexandrescu? The world is in a good place right now
Here I was thinking Andrei switched to dlang. Glad I was wrong.
Have you done anything with a library yet? If not, perhaps write a program that uses a JSON parsing library to read and output a JSON file. Do you have experience with SQL? If so, perhaps write a program that allows the user to write a blog post and it outputs the SQL query to run. It outputs something like INSERT INTO posts (id, date, title, content) VALUES (null, CURRENT_TIMESTAMP, 'My first post!', 'Hey everyone - \'this\' is a test.'); Then, if you're still having fun, combine the two and make your blog post program actually store the data via an SQL library, not just output the INSERT string.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
My take: D is (still) the hobby, C++ (still) pays the bills.
No modules just yet.
Filesystem is pretty awesome, as are designated initializers in 2a.
They still haven't properly exported the cmake targets, not even pkg-config.
Looks like https://godbolt.org was just updated with 8.1 as well!
What kind of projects would that be? Disclaimer: Is a C++ student/newbie.
I'm torn on &lt;filesystem&gt;, it's a great cross platform solution but from my testing it tends to be significantly slower than native options in a lot of cases.
It is rather simple to build a self-contained project that no other developer is going to depend on, but as a project dependencies increases and/or number of its users grows, you need a package management. Building from the can alleviate some issues like binary compatibility, but you still need a "tool" to handle dependencies. Javascript got npm, C# got nuget, Python got pip. C++ doesn't have a comprehensive tool for that yet.
Post title should be "Expect the Expected". (I had the topic of the talk on my mind...)
The start of the release notes sounds like the start of an infomercial ;) "Are you tired of your existing compilers? Want fresh new language features and better optimizations? Make your day with the new GCC 8.1!"
Where could I get the slides?
There was another c++ talk by Alexandrescu recently: http://cppconf.ru/talks/andrei-alexandrescu -- I wonder if it is a repeat of the old ones or some new treasure (which is, as we know, everywhere)
Projects that didn't use -Wall from the beginning and weren't written very carefully and as a result have countless warnings with -Wall enabled making it impractical.
This was raised several times, but MS GSL authors refused to address it. See github issue [#466](https://github.com/Microsoft/GSL/issues/466) and earlier issue [#31](https://github.com/Microsoft/GSL/issues/31) 
Hopefully the best word to describe those projects is "legacy" or "plan for retirement".
That's certainly the most common. You can also get into situations where you depend on third party libraries that are header-only and they produce ridiculous amount of warnings at -Wall.
Thanks, I had missed those discussions. It's disappointing to see how much those veer off into arguing about the mechanics of namespaces in C++, and claims that 'since it's impossible to avoid all name collisions in general, we should take no action in this specific instance'. So much energy to defend a name that isn't even good in the first place. 
that's just laziness. I once joined a project with &gt; 25k warnings on the first compile with -Wall -Wextra, it only took a day or two to fix.
Which unfortunately includes most project that uses a few libraries, since most libraries generate lots of warnings. 
Any news on the OpenMP 4(.5) implementation and off loading to Nvidia gpus? Apparently it was supported since GCC 7.1 but I have not been able to get it to work. Hopefully this release will have a more streamlined/user friendly experience. In any case, seems like a good release. Any improvement on error messages is something that makes me happy.
Dpkg / Apt-get / Aptitude / Apt, Chocolaty, Emerge / Paludis / PkgCore , RPM / Yum / DNF, Homebrew, Ports (BSD, Mac, so on). There's no need to solve an incredibly tiny part of the problem space that these existing solutions solve already. My money is on Emerge. It literally does everything Vcpkg and Conan can do, as far as I can tell, but better, as it's an existing solution that's already been used for &gt; decade. 
I still like having normalized file paths/directory traversal even. File I/O has always been slower compared to native options and you still don't have an abstraction around ReadDirectoryChanges on Windows or inotify for linux.
I imagine a project you could work on for several weeks and while you're working on it, you learn what you need to know.
It's not as easy if you want to keep legit warnings from your code using said lib. See https://blogs.msdn.microsoft.com/vcblog/2017/12/13/broken-warnings-theory/