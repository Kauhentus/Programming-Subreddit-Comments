You could probably get a lot of (free) mileage out of picking up the easy challenges in /r/dailyprogrammer/ and asking for feedback on your solutions there and in any of the online c++ communities. The place most would-be developers fall down is in not having concrete short-term goals. The simple challenges address that.
I have been using this lib for a while now...great stuff! I've noticed that when consuming php arrays encoded to JSON, I end up having to recast those on the php side as objects, else the square brackets confuse the parser. I may be an idiot and doing something wrong on one end or the other, but don't think I am? Also, it is difficult to fetch data using templates as maps...I have to loop through currently: if (!responseData.empty() &amp;&amp; !slot.empty() &amp;&amp; responseData.count(slot) &amp;&amp; !responseData[slot].is_null()) { json j = responseData[slot]; for (json::iterator it = j.begin(); it != j.end(); ++it) { int k = std::stoi(it.key()); std::string val = it.value(); ret.insert({k, val}); } }
I have seen plenty of bugs caused by overwriting error status when they were checked. Nodiscard doesn't really do that much to solve the "ignored error code" problem.
&gt; The gamedev industry does a lot of other stupid things, too. Some of the worst code I ever saw came from game developers. For example?
You're simply constructing a new object of type `TermDbData` and then assign it to the old one. You don't call the constructor on an existing object, you just make it equal to the new one.
I feel that pain. But when you can upgrade, go for 2017 instead of 2015. 
Why not go one step further and say all errors should extend from class Object? I am not advocating this, I am saying that is how I interpret your class of reasoning.
Funct that. If everybody in a group uses a word to mean the same thing, that's what it means. The fact that it means something else in another context to another group is irrelevant.
Hmm, I wasn't familiar with this type of code before, does that mean previous copy is destructed safely at that very moment? And won't it redo some allocations again since `clear()` won't actually clear the `capacity()` saving some allocations..
&gt; Are these two ideas not in conflict with each other? I have a feeling they are. Outcome's refinements `result&lt;T&gt;` and `outcome&lt;T&gt;` already use an extended std::error_code, which is called the unsurprising name "error_code_extended". That's safe and good practice. std::error_code incompatible custom error codes I don't think is safe.
&gt; Why does p0323r1 prefer error_condition? Personally I think it's a defect. error_condition is the type sugar to say "this is an error_code which has been converted away from its original form and it has lost information". error_condition is almost always going to be a temporary used only for comparison and thrown away immediately after. Also, try `std::cout &lt;&lt; error_condition` on any STL. You should find it won't compile. error_code prints to cout no problem. Again, that reflects the fleeting lifetime which was originally intended for error_condition.
&gt; I don't understand their relationship with the compiler's obligation to maintain backward compat. So, at the most basic level, you're right in that the compatibility guarantees between a static analysis tool and a compiler/language standard are different. However, in order to gain the same guarantees as Rust, you have to make sure that everyone is using the tool. And since the tool will reject some programs that are valid as per the spec, you've effectively changed the language in a backwards incompatible way. That is, there's not much difference between saying "everyone must be clang-tidy clean before committing to the tree" and saying "I've made a new programming language called clang-tidy". Alternatively, you don't require that everyone uses the tool, but then you don't get the absolute guarantee. This is also very baseline; we haven't even gotten into a "is it even possible for a C++ tool to perform the same analyses that Rust can", which is a whole different issue. The above is assuming that this is possible. Given that the languages have different semantics (though many are closer to each other than other languages) it's possible that this is impossible. Talking about that in a definitive way is above my language-laywering abilities ;)
[removed]
Of course! I'm glad it's sorted. Thanks :-)
Disclaimer: possibility of poorly understood code ahead. `out_of_memory` is out of place in `file_error`, isn't it? It rather looks like any given custom `error_type` will need that. That's a local solution for a global problem. A catch of `bad_alloc` left and right is detrimental to readability IMO. But not having it would bring the worse result: a function that looks like it does not throw, but in fact does. Similar to the use of the value(). One missing check for the result, and one is facing a thrown `error_result`, which is rather unexpected, I would think. There is tooling in C to warn about not using the return value, but here it's different: the result is used, but possibly incorrectly. In the file examples, say that there's an actual parsing error information beyond `parse_error` - what is the outcome supposed to be? (Point being: in any given codebase, failure modes are numerous, how to combine them using outcome&lt;&gt;?). Finally, Rust has a macro try!, IIRC, it's not a statement, no?
- I have no experience with PHP. Can you provide an example? - For your second example, i need more context - what is the input and what is your goal? It would be best if you would open an issue at https://github.com/nlohmann/json/issues/new for this.
Actually in finance you very much want your application to crash rather than keep chugging along entering bad orders.
It really pisses me off that Apple won't support Vulkan. We were so close to a standardized graphics API for everything.
The only unholy part is V8's API. Dear god, it is awful.
&gt; However, in order to gain the same guarantees as Rust, you have to make sure that everyone is using the tool. This issue is orthogonal to the existence and capability of the tool. &gt; And since the tool will reject some programs that are valid as per the spec, you've effectively changed the language in a backwards incompatible way. Again, this is a social issue, not a technical issue. If the tool is in your CI pipeline then developers can be mostly indifferent as to whether the errors are caught at compile time, or during the next CI step. &gt; Alternatively, you don't require that everyone uses the tool, but then you don't get the absolute guarantee. Likewise, Rust's guarantees can be easily eschewed via `unsafe`, which lands you squarely into the realm of social issues you've brought up above. The compiler allows the code, but there's value in having separate program *validate convention*. Think automated code review. &gt; we haven't even gotten into a "is it even possible for a C++ tool to perform the same analyses that Rust can" I agree completely with you here. I'm not trying to argue that static analyzers can do everything Rust's compiler can, I'm just trying to say that the limitations of said analyzers are unrelated to the burden of backward compat. As always Steve, I really appreciate your time and your responses. Please keep up the great work!
Yes, we're on the same page here. (And thanks! &lt;3)
I've been working through Stroustrup's Programming: Principles and Practice Using C++, alongside the Lean C++ by making games course by Ben Tristem that's available on Udemy (and which you can probably still get for only $20 if you hunt for a promo code). The exercises in the book are a bit dry, so the Unreal course has been a good way to get some experience with real code with a more interesting purpose. I've found Learncpp.com to be a great reference as well and is totally free. I've also started reading Game Programming Patterns and Effective C++ as these were highly recommended to me when I started.
&gt; Qualify size_t with std. But it isn't from std -- it's from the C standard library `&lt;stddef.h&gt;`.
This is awesome, thanks! I actually just got book 1 in the mail today. Excited to get started 
Thanks! :D Wish I could give you some gold haha :D EDIT: Question. Am i able to do the tasks given in these books on Dev-C++.Because i am not in a situation to buy one :D
Regarding the lambdas, I would suggest to never use a this-capturing lambda as a quick replacement of a slot. Today I had to help a coworker who got a segfault in one our unit tests after a timer fired during the test teardown. The issue? The timer was a QTimer::singleShot() with a lambda capturing this, so when the timer fired this was no longer valid (the object had been already destroyed). This would never happen with a slot connection since the connection will be killed whenever one of the endpoints die. I'm sure QObject::singleShot () has an overload taking a callee, but the real issue is that situations like this can be very common if you follow your inner irrational "ohhh C++11 is so cool put lambdas everywhere" feelings :)
&gt; Much of your code is commented out or has comments with code copied from other classes. I see this a lot in code that doesn't use source control. A coder wants to remember an idea, or an old implementation, so they comment it out or even keep a whole unused file. Better is to use source control and delete commented out code. It'll be there in the history if you want it. If you're wise, the commit message will even explain exactly what it was and you'll be able to find the commit with a simple search. (I know you're on github, but when I looked at the commit history, the initial commit was 13 days ago for a project you've been developing for two months. It might have been hosted on private source control, so this is only a guess, but I'd guess there wasn't a SC system from the beginning. For my personal projects, I use source control and a bug/feature tracker right from the beginning. To me, those 'this implementation was interesting but I deleted it' things belong in source control from when I deleted it, and those 'what about this idea' comments or coding ideas belong in a task tracker.)
Don't forget to code. You actually learn the theory in books but not how to use it and put everything together. C++ is very powerful but also very complex and you can fuckup very easily. Yes, read the books, but practice. CodingGame is a good website for practice. 
&gt; This part of the tutorial is a bit unusual as it's a sort of polemic against what most consider to be one of the best parts of expected&lt;T, E&gt;: that you can and should choose any arbitrary type E on a case by case basis as is conventional in other languages such as Rust or Swift. This is not conventional in Swift. The standard library and most third-party code uses `NSError` exclusively.
Good catch on the missing, you are totally right. I haven't slept in like 48 hours. Like 36 hours when that was posted. When a programmer does leave out the exception that tends to be the kind of mistake that can only be made once and is easy to find, because the software comes down, exceptions are super easy to instrument (because they are classes that can capture any kind of data trivially) and some even capture their throw location by default (and in some languages even capture a call stack, but we don't get that in C++). When a programmer misses a return code it tends to the the kind of mistake that is repeated because it is very hard to find, rarely logged correctly and generally doesn't lend itself to be instrumented (because they tend to be bools or ints because if they were a meaningful class it would obliterate any perceived performance advantage (it would probably perform fine, but the same people that want return codes also tend to be the people that deny compiler optimization matter). This is very simply and I think I am done after: Mistakes with exceptions are either easy to notice or made by active decisions while Mistakes with return codes are hard to notice and are mistakes of omission. It seems super simple to me as long as there is no overriding performance concern always choose exceptions, and even then it should be measured. Exceptions are often faster (not always, but often) at least when I have measured, so even then when preferring performance often exception are correct.
Pretty much every industry uses C++. Even for webdev which is mostly JS/Node.js/Python/Java/etc there is still C++ is used in places. I think a better question would be what industries **don't** use C++ :) As for the games industry yeah it can be a pretty hardcore environment (my wife happens to be a video game producer). 
QtCreator can be used for just plain C++ programs that don't use Qt.
The example on cppreference (http://en.cppreference.com/w/cpp/utility/variant/visit) is pretty ugly though due to std::remove_reference and std::is_same
FYI, Dev-Cpp became Code::Blocks. C::B is what I use, and it's in most repositories.
The game industry has been getting generally better regarding hours and benefits over the last decade. Experiences vary across companies, so you should definitely bring up crunch in interviews. And ask specific questions, like "How many weeks last year were you in crunch time, and what did that entail?" If you don't ask specific questions, it's easier for them to misrepresent what crunch time looks like. And yeah, it's about 75% C++, 20% Java, 5% Python and Lua from my experiences. Java is mostly service development, python scripts, and lua UI.
carefully
I'm still learning myself, if you want to go heavy on the language aspects, read C++ Primer, it can be a bit of a drag(by this I mean boring) but what you learn from it is invaluable. You can also use it as a great reference book when you're unsure of stuff. Another great book which I feel I'm learning a lot from because of how practical it is, is Programming Principles and Practice Using C++. I'm still working my way through it and I actually feel excited to cover the next chapter after I finish one. It's written by someone who isn't trying to over complicate the subject for no good reason so it's very easy to read.
I have some bad news for you: if you really wanted to start learning C++ you would already be learning about it, not posting on forums about what you are going to do in the future. 
The core philosophy behind C++ is zero overhead abstraction - the language and compiler architects aim to provide tools which map as closely as possible 1:1 with the underlying hardware. For this reason, C++ provides not necessarily the best performance, but the best means to control performance of your applications.
I mostly work in large scale scientific simulations. These simulations can take hundreds of thousand of CPU-hours. When you care about performance, and you care about maintainable code, C++ is the way to go.
Something that was not addressed in other comments: Things like : m_tileLayers() in constructors are not required. This is the default member constructor behavior. I assume you do not care if this is portable to other compilers or systems. I wouldn't worry about this to begin with. Remember: shipping is a feature. Ship on your chosen platform first. After that you can add the feature of shipping on other platforms. It is important from a practical standpoint to understand what choices you have made that make this code non-portable so you can avoid these mistakes in the future but I do not see a need to refactor your current product.
Has anybody heard anyone make these particular arguments? I guess the appropriate response would be to quote [wikipedia](https://en.m.wikipedia.org/wiki/Straw_man) &gt; A straw man is a common form of argument and is an informal fallacy based on giving the impression of refuting an opponent's argument, while actually refuting an argument that was not advanced by that opponent
Non-Mobile link: https://en.wikipedia.org/wiki/Straw_man *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^25382
Yes, please don't break the build. "-But... but... It's just my code in my branch in my project! -Only until the day it isn't."
I'd bring the entire function into question. It doesn't appear to add value to the codebase. Using `std::unique_ptr&lt;&gt;` may sound beneficial but then you have this code: TextureManager texture_manager; std::unique_ptr&lt;sf::Texture&gt; t = texture_manager.loadFromFile("..."); if(!t) { // Handle the situation. } If you were to call SFML directly you have this code: std::unique_ptr&lt;sf::Texture&gt; t = std::make_unique&lt;sf::Texture&gt;(); if(!t-&gt;loadFromFile("...")) { // Handle the situation. } And then you reduce the size of the codebase by one whole file!
I completely agree. It is also a big problem for organizations that wonder why their codes quickly become completely unmaintainable. I fail to have a lot of sympathy. I've had fellow scientists tell me they're scientists not programmers. I reply that they're scientists not mathematicians, but they'd be pretty piss poor scientists if they didn't learn and apply some math. Sorry if I sound bitter. It's because I am. Learn to use the tools your job relies on our you're going to do a shitty job.
I should qualify, i stopped using VS IDE in the 2003 days, because it was buggy and crashed often (often out of mem errors). Never really looked back, so it may be better now 
Hey, you are exaggerating quite a lot there. We try our best to make the code maintainable but the goal is to progress in understanding the world, not to waste time where it is not needed. The tenure-track is quite a narrow path and only by publishing can you walk it. Besides, the published record gives you the maintenance information that is needed. Otherwise the publication is shit and we are on a different level of bad scientists. Also, scientists are often shit at math from fields they are not used to working with. Talk to a space physics researcher and they have little to no idea (by published record) how areal correlation works. This is necessary in atmospheric science. Talk to an atmospheric physicist and they have no idea about quantum physics (leading to a weird lack of understanding the upper atmosphere and space interactions that space physicist are better at). People do their best to answer their own questions. This is why you have 20+ authors on some more complicated works.
Thank you so much for your constructive criticism! I have updated the article to reference some of the sources I have used while constructing the argument for C++ within my enterprise that contain the arguments I am refuting. I have also attempted to clarify that I am not attempting to refute all arguments in support of C++, only these select three that I find issue with.
Yes, I knew this stuff and all about the assignment operator too, but somehow noob brain refused to put this together in this context. Now its crystal clear, thanks for the explanation :D
Dev-c++ is a terrible option. The last release ( a beta ) was from 2005.
High frequency trading is big in London and it's all C++.
&gt; First most std::string implementations are now copy-on-write.. To my knowledge, cow was prevented from being used during c++11 modernization - https://gcc.gnu.org/bugzilla/show_bug.cgi?id=21334#c51, and from other StackOverflow threads the outcome remains same.. &gt; Second const&amp; means the compiler cannot pass an rvalue reference and optimize this operation into a move. std::string&amp;&amp; can degrade into std::string&amp; by calling the move constructor std::string(std::string&amp;&amp;). However the compiler will not degrade a std::string&amp;&amp; into a const std::string&amp;. Thank you, I've ordered the book and will definitely read it and make the required changes if they justify their inclusion. 
&gt; "How many weeks last year were you in crunch time, and what did that entail?" If you don't ask specific questions, it's easier for them to misrepresent what crunch time looks like Asking is not sufficient to the point of being a bad idea: on one hand, one is being antagonistic with the prospective employer, on the other, it's **really** easy to misinterpret these things. 
Wow... calls on logic fallacies, ends up deconstructing a strawman...
This is exactly why I wrote the article and posted it to reddit: for review and feedback. It is certainly helping me construct a better argument.
Dont forget Clion
Software engineer in tools and infrastructure at Google. C++ is one of the primary language I use on a day-to-day basis (the other being mainly Python). Generally we use C++ for code where performance really matters, and Python as scripting "glue" to put the pieces together, as it tends to be much more readable. That being said, it's less the language that matters for this job, and more the principles and how the software is designed. General principles will take you much further than knowledge of just one language. 
Animation - back when I was at Pixar it was probably 90% C++ and 10% Python.
Web Browsers are written almost entirely in C++ (except for whatever language is used for UI and system integration). Check the Firefox, Chromium and WebKit code bases.
OH OKK. I don't know much about CGI, but i ll look into it thanks.
It's not clear whether C/C++ runtime were linked statically or dynamically, that really should further change things. It makes little sense to compile error-return code with exceptions turned on, so only the yellow bar is really interesting. Getting some 10% bigger code with exceptions turned on sounds a bit much to me. However, utils.cpp shows that `create_error`uses operator new, which throws `bad_alloc`, and that means that the use of `-fno_exceptions` is flawed: the error-return code is **not functionally equivalent** to the one with exceptions. (BTW, `create_error` does not satisfy the so-called basic exception safety guarantee, for the love of God, please don't do that!). It looks like getting this right requires re-doing all of the error-handling code. An easy cop-out would be a thread-local Error object, but that, again, is not functionally equivalent to exceptions, because there is either only one, of one type, or heap should be used. Edit: same file shows why error-return code with exceptions turned on is not smaller: the compiler sees code that can throw, so it must generate cleanup code to be exception-safe. So less of a hoped for benefit can be achieved. Also, since the error-return code uses the heap to produce error information, it is likely to be slower than the code with exceptions, which should not do it (but I don't know the library in question, maybe it does?). Dear author, can you fix that and build again? I am yet to see an actual comparison, on real-world code, between two approaches, where the code is indeed functionally equivalent. I have seen heaps of **idiots** who just recompiled with `-fno_exceptions` and claimed that exceptions bring code bloat. Hel-looo!?
Yup. You chose well.
&gt;“C++ has changed a lot since 2011” I think that's a simplification that hides the fact that the changes made to c++ simplify it and allow one to write more compact expressive code. I'm thinking of things like "auto:" and easier itereration over containers like.. for( item : container) i.e. it's not merely "change for change sake" we're talking about. We're talking about quantifiable improvements to compactness and readability.
Im not in a situation where i can spend money.. But thanks for your advice :)
[removed]
This is the opposite. Copy on write was explicitly banned in modern C++
I still think most of the scientific code nowadays is still written in Fortran (it has its pros and cons vs C/C++). However, most of the non-mathematic libraries are written in C/C++, so there is plenty of people (myself included) working on this kind of projects that uses C++.
And fortran. URGHh....
&gt; I would like to start researching companies in the UK but not sure where to start. [...] What is a good place to look for jobs? I find recruitment agencies here in London are one step above con artists, but unless you are lucky enough to have connections already, or you are only looking at large organizations with internal recruitment teams, unfortunately they are a necessary evil. Just be sceptical of everything they say. Depending on precisely what you are seeking, indeed.co.uk and Dice are pretty generic places you can have a browse through to get some idea of what sort of jobs are on offer. efinancialcareers is nice as well. Be aware that most recruiters like to do a bait-and-switch where they will push whatever rubbish job they are having trouble offloading rather than the one that caught your eye. Also, many of them have difficulty understanding basic geography and think that places like Slough are "in London". Once you are looking at a company, Glassdoor is useful for salary estimation for larger businesses; Company House records can be informative when you are looking at smaller employers.
I work at the defence industry. C++ is a must.
I've worked in embedded development for energy management systems, slot machine game development, regular game development and insurance quote engine development. I work in the UK. There's lots of jobs out there - it's finding one that suits your skill set and living near a major city. 
What is the arguing you seek to construct? That C++ is a language to be avoided? That those who pick C++ do so for the wrong reasons? That programmers really choose tools based on their own established preference and that their justifications are not based in logic? 
Does this apply to C as well? 
The problem with the modernization argument is that the C++ detractors do not criticize C++11 but usually "C with classes" and ignore the following 20 years of development. I do not understand the popularity argument - Does that make C++ bad somehow? I would say if a language is popular, then it is easier to find somebody to replace the developer who left, which can be a big issue in a small company. The performance argument ignores that every software developer will tell you to use the right tool for the job. Some things are better written in Python, for example when performance is less critical. 
This is a set of native libraries that can be used for this. https://github.com/KayEss/fost-android-ndk This is a sample Eclipse project. https://github.com/KayEss/fost-android
No. Pure C is rarely used now.
Yes.
Haha touché
Most of them use an "orthodox" style of C++, like a C with classes.
You could write a "C with classes" program in C++ today and ignore the features that you don't need. I agree with your comment about excessively clever metaprogramming - we should write code that the next person in the job has a chance to understand and maintain. 
What do you mean by that? A lot of pointers and dynamic memory allocation?
https://gist.github.com/bkaradzic/2e39896bc7d8c34e042b
&gt; Hey, you are exaggerating quite a lot there. Hardly. I've seen generations of grad students waste *years* because they've had to deal with absolute pisspoor code. And in so many cases, the older academics don't even know there's a better way to develop code than how they did it. Maybe you gotta get this publication out, but over the years code bloat and unmaintability bite you in the ass, hard. It's common practice in the simulation world to simply freeze development once something "works" and then if you want to implement a new feature, you basically rewrite the whole code. That's what happens when you have no exposure to automated testing or version control. And it really really holds back the field. I'm not exaggerating when I say I've seen people awarded PhDs where the bulk of their work over the course of *years* was implementing a new method that would have taken days or weeks if they weren't trying to shoehorn it into some horrific code base. 
3D graphics and modeling. I wrote a simple Maya plugin back in school, dabbled with a lot d3d11 and currently work on the rendering engine for CAD-like software, all exclusively c++.
IME you will find that 90% of people who call themselves "C++ programmers" actually know very little C++, and probably only make use of 10% of its features - typically they write "C with classes" rather than what I would call properly idiomatic C++. You can sort of understand why, since C++ has grown into a behemoth of a language, and many of the people who use it are not programmers by trade - they typically come from scientific/engineering disciplines and have picked up just enough C++ to be dangerous, without really understanding a lot of programming fundamentals. 
I don't think the arguments are used in isolation like you make out though. It's more like: * Argument that C++ is bad that might have been true in 1994 * You know, C++ has changed a lot in the last few decades... It's not saying that C++ is necessarily good because it's changed, it's saying the argument that C++ is bad is invalid because it's based on incredibly out of date information. 
It's a myth that there are features of C++ you should always avoid. Like with any programming problem you should try to use good taste and not use every single feature in all places. Use features when appropriate.
I do not disagree, programming needs to be taught in more details. I might live in a bubble, since all our code is out in the web in seconds from committing it. I experienced the same visiting other labs though, so it must be a thing of my field.
&gt; the primary language I use on a day-to-day basis (the other being mainly Python). Generally we use C++ for code where performance really matters, and Python as scripting "glue" to put the pieces together, as it tends to be much more readable. &gt; That being said, it's less the language that matters for this job, and more the principles and how the software is designed. General principles will take you much further than knowledge of just one languag Interesting this is if Servo becomes stable and complete it *might* replace Gecko later on which is complete Rust. 
Last I checked a lot of embedded "C" work actually uses a C++ compiler, they just restrict themselves to the C subset of C++ for outdated reasons. But yes, a lot of embedded programming is C. I suppose "rarely" was a bit harsh.
The matlab horror shows I've seen -- I don't get how formal training comes into it. People just do really stupid things that are obviously a problem and assume this is just the way things are, not that they've written a horrible system. This guy wrote a fairly simple analysis thingy in matlab that operated on a few hundred megabytes of text data. It takes a couple days to run. I look at it and it's reparsing dozens of csv largish files every time through inner loops. The people using this thing were convinced they needed to buy more computers and figure out how to do parallel computing on a cluster. To me this stuff is on the level of looking at a simple mechanism and understanding what it's doing. Formal training or even expensive expertise doesn't come into it. Some people just can't think a problem through. I doubt they could fix a car either.
&gt; I use [...] a bug/feature tracker right from the beginning. What do you use as a personal bug/feature tracker for your projects, if I may ask?
The linux kernel is, but not many people work on the kernel itself. Most linux software is C++.
I'm not saying you should always avoid some features, merely illustrating the (IMO justified) thought process that goes on in peoples' minds when they decide to use "C with classes". C++ is too complex for **anyone** to fully understand and too complex for most people to understand even most parts. Thus for a multi person project you need to decide on a subset that everyone can be assumed to understand and this often converges to "C with classes and some additions". This goes especially for systems where the developers are more interested in the domain specific problems than language features.
Since the cost of embedded Linux systems have become comparable to 8-bit micro-controllers, and the size is great, the embedded world has open the flood gate to many possibilities, including C++. We use C++ with Qt to have a unified cross platform code base that is reusable for ARM embedded Linux, Windows/Linux server services, desktop GUI, and mobile Android / iOS apps. Everything in one language sharing the same code base makes things quite nice.
Currently I use [Assembla](https://www.assembla.com/home), with a small monthly subscription, but these days it's too large for small individual developer needs. My subscription is grandfathered in. I've looked at moving to bitbucket or similar; it's just a matter of the time required to migrate projects and bug reports.
If OT is a negative aspect mentioned on GlassDoor company reviews, I think it's okay: I've had good luck bringing up that website by name and any concerns for the company to counter. 
&gt; Erm, no! That's not how it works, I'm all with /u/Gotebe/ here. When you are making extraordinary claims about the efficiency of your proposed library, you need to back this up with extraordinary evidence. No I don't. You can take me at my word out of respect and gratitude for making high quality free software available to you. I have zero obligation to anybody who hasn't paid me money. Zero. &gt; If you claim you have no obligation to back up your claims, then you should not be believed at face value. If you believe anything on the internet at face value, well ... &gt; I bet this will be the same attitude that you will get from the Boost reviewers. It's different for the Boost review. There's a ton of stuff Outcome does that I can't say it does in the docs or mention because that's subject to the peer review. So I can't mention anything about performance, the monadic programming extensions, or anything I'm not willing to get into. &gt; Brushing potential users off by shifting the burden of proof back to them, won't be a good sales strategy. I've been supplying open source libraries since the 1990s. I can **guarantee** you that nobody takes any claim by any open source project as meaning anything at all, and if they do they need their head examined. Open source is 100% caveat emptor, and any major deployments I've ever seen of my open source into large orgs was done after the user invested a **lot** of effort in deciding if my code was good or not (and sometimes contracting me to improve it if needed). Now what is much more trustworthy is looking into what others say about some open source project. My most popular open source historically had people saying good things about it in various places on the internet. That counts far, far more than anything I say about my open source, and the user numbers more than match that.
I disagree. Firstly I don't think C++ is anything like as bad as made out. It's got some warts, sure. And trying to make sense of a program that's a rats nest of pointers and ownership is not easy. But that's more people doing bad things with the language, not the language itself. But outside of that, you don't actually need to know the features to use them. For example r-value references and move semantics are very much hidden. They're there underneath, but unless you're a library developer, you'll rarely if ever see them. But now if you use the clear, obvious and safe constructs, they're now efficient. Likewise with SFINAE: the rules are not that simple. If you're actually trying to *use* it then, in Stroustrup's words, "you know too much :(". Mostly it's a hidden feature which magically ensures that unrelated overloads don't break your program. It's 99% (or more) hidden. 
I've worked at companies that could not accept new customers or develop new products based on the data they worked with because their software was so bad. The CEOs would go on about how their company needed to grow in the frequent company all-hands meetings, but was apparently unaware that their software made it essentially impossible to do so.
Hey there! I have gone over these books over the past year: Book1: C++ through game programming. Book2. C++ Primer Book3: SFML game development by example. Book4: Effective C++. Really good set of books! 
Stroustrup is working for Morgan Stanley at the moment, IIRC.
It's really interesting (scary) to look back over code you wrote in the past. Once I go back more than a couple years, the stuff I wrote is just shameful garbage :(
He's probably talking about this: [CppCon 2014: Mike Acton "Data-Oriented Design and C++"](https://www.youtube.com/watch?v=rX0ItVEVjHc) Or early days of this: [Scott Wardle “Memory and C++ debugging at Electronic Arts”](https://www.youtube.com/watch?v=8KIvWJUYbDA) This approach exists, but not everywhere. Personally, I admire different kind of code: the one that was in the Id Software. It's so direct and clear. But I don't write like that because don't know how to maintain or test it without additional abstractions.
Super nice one thanks for the info. Didn't know about dice and indeed.
What about Ada?
Pretty big in EE as well. I'd say it's a requirement for most semiconductor and hardware development jobs.
&gt; Over time we learned it's unnecesary to use some language features just because they are there, or features we used proved to be bad (like RTTI... Then they go on to talk about how everyone eventually hates modern C++. I have to say, I'm about 4 years in and I love it, I never want to go back. 
Software for pro music producers and studios is primarily C++.
Tell me about it! It might be the biggest reason my next machine isn't a mac.
&gt; I've had fellow scientists tell me they're scientists not programmers. I've seen scientists refuse to clean up their code because they don't value code quality, but then spend days tracking down some bookkeeping error that would have been readily debuggable in better-written code. During those days of debugging bookkeeping errors, frankly they're not being scientists at all - during that time they're just being bad programmers. Frustration with this attitude/approach is exactly why our company doesn't make a distinction between scientists and programmers - we're all called "scientific software developers" and strong knowledge of C++ and software engineering is required of everyone. 
To a lesser extent.
I've thought about this and think people who spent all that time to get comfortable in c++ are the winners. Would I rather be googling some Python or php apis to get shit done, or would I rather be reading up on and trying to understand how varadic templates work because the devs. wrote their app in c++? I'm not familiar with matlab, but it's not so bad getting shit done in other languages without a deep understanding. Jumping into a c++ project without much experience I'd imagine would be a nightmare.
It's amazing to me to still find people who don't see the value in version control. I use version control even if I'm just writing code by myself, since I want to be able to undo recent changes, see what I've changed, etc. Without version control and at least some simple unit tests, I'd feel like I was walking a tightrope without a safety net. Matlab has a lot of power but I don't think I've ever seen any examples of good, clean, well-organized Matlab code to tell people to follow. Python at least provides the ability to reasonably encapsulate and write clean code, but without the right direction or training it's also all too easy to just get all scripty with it. At some point you just have to flee places that don't value good C++ or software engineering and find one of the places that does. 
this better be satire
It isn't.
I think they can be good for take home / phone screening stuff. Basically a fizzbuzz test before having to waste anytime interacting with a candidate that can't code. That said, I've no experience using it for any sort of complicated evaluation. I suppose if a candidate had an account and I could see their solutions that would help me gauge their programming ability, but most people won't have time for a review like that. I suspect it would mostly be leveraged by slower growing / smaller companies that have the time to be picky about their candidates?
Indeed he is. John Lakos works for Bloomberg, too!
Basically anywhere that touches embedded computing seems to require c++ (unless it requires C). Personally, over the last 3 years I've been working on radio's, VR (the expensive kind, not the consumer grade), a number of embedded devices, and some data processing applications (using data gathered from embedded devices). I used c++ for all of that except for some of the radio stuff, where I have had to use C. When I was last looking for a job, I found stackoverflow jobs to be very useful in giving me a fairly wide range that I could use my skills in. I would recommend starting there and seeing if there is anything interesting if you are looking for a job.
Well, it's a way to filter some of the programmers automatically. Those 60-120 minute ones can be mild RNG - disconnects, crashes, power outages, etc. But if someone has trouble implementing string split and pasting result into browser in 24 hours, then that's telling. I got burned by Hacker Rank once. Multi-question test, written in time, submit, no tests showed up - strange. Week later - 10 pages of compiler errors - I used C++14 features. Now I remember to hit "Test" before "Submit" - unlike CodeWars. Speaking of CodeWars, if you're having trouble with those short challenges, you might want to check out this site, it's a great way to prepare for this nonsense.
Yes I completely agree with you, to top it off none of the tests prevent you from googling the answers. I don't want to name names, but I notice a strong correlation with negative glassdoor reviews and firms that use these online coding challenges. 
&gt; they're not being scientists at all - during that time they're just being bad programmers. Absolutely. It sounds like your company has a good idea how to handle that position. I'm honestly pretty jealous. 
So you think someone that can google how to write fizzbuzz in C++ is screened for the next steps? That's what your telling me. 
Although there are so many high quality discussions and posts in this thread, this comment kind of wins it all.
No, make up another problem that isn't exactly fizzbuzz but is roughly just as complex. 
JSON RPC over Websocket for embebbed software.
The best kind of correct
I did way worse then i expected on cppquiz and mycppquiz, have not look at the others yet.
This is why they need to be removed. There's no longer a good reason why this should do what it does.
They are being removed.
I suppose I haven't really gotten that far enough into matlab to see its particularly handy uses. I have to admit that being able to differentiate between vectors and matrices could be handy in many cases (in particular with matrix math), but you could probably rig up a class in C++ without *too* much effort. For that matter, I'd be rather surprised if nobody's taken a stab at making a C++ library that does at least most of the relatively basic matlab functions. EDIT: Kudos to /u/spinicist for finding [this](http://eigen.tuxfamily.org). It's the aforementioned library for linear algebra.
Thanks for this comment. I never did finish going through the book I started learning from, so if I find the time I'll probably try to pick that back up. Those features you mentioned sound useful for some projects I have in mind...
Looks like a better way of learning than through straight "how to program" books
Thanks mate. I am planning to build android app and iOS app with React Native. So I thought of isolating the certain business logic to a REST API. First thought of going with kotlin, but since JVM needs like a minimum 4GB + 2vCPU on production server(budget problems) thought of going with non jvm languages. My options were C++ or RUST. What's your take on this?
Well on the other hand it's a pretty good test - if you there and you support this, than other people shouldn't probably merge your C++ pull requests. Ever. Also you can't argue when "source" is someone personal experience. 
Embedded code primarily uses C because it's typically unhosted; C++ is almost never used in an unhosted environment because you'd need to implement the whole standard library. Also, "actually uses a C++ compiler" is uninformed bullshit.
I'm not quite sure, but is it to do with the comments including a trigraph perhaps?
Linux is not "pure C". There's ASM in the kernel.
But that trigraph is turned into \\ why would that be an issue? 
\ is a line continuation, which I think would turn the "x=1;" line into part of the comment, so the output would be zero.
Based on my (maybe biased) experience, C++ is more widely used. That does not mean, obviously, that Ada is neglected. In my company we have systems coded in Ada, but more modern combat systems are coded in C++. I work at the naval branch, but I think Ada may be more used in the aereal one.
Thanks. I'm not sure why the language would accept line continuations in a comment. That sounds really stupid to me. 
Got ya, thanks for answering!
Some outdated advice there, e.g. returning `const` values to prevent assignment to rvalues. Since C++11 it is possible to require `*this` to be an lvalue by adding a ref-qualifier to the assignment operators.
Already have been in most compilers.
Line continuations are processed before analysis gets so far as deciding what is or isn't a comment.
Eventually you get to the point where you don't even recognise code that that you wrote in the past - you can be looking at something and think "that's cool", or more likely "that's terrible!", and then you realise you wrote it. ;-)
In "mycppquiz" there is a lot of questions where a local variable name is masking a global variable with the same name and you have to guess which one is used. If I found code like that, I would rewrite it.
If you have a member += operator, it's probably best to have a non-member + operator, because that also allows you to have the expression: "convertible-to-order + order". And you can get the compiler to do the copy for you: (Edited) // Note: lhs is a *copy* Order operator+(Order lhs, Order const &amp;rhs) { lhs += rhs; return lhs; }
so do committee members Alisdair Meredith and Dietmar Kuhl.
Agreed, Another thing to keep in mind is that the STL has to be strictly standard compliant, when in the video games industry we do know what platform we are targeting, and how the code will get compiled. For this reason, you'll often see custom vector implementations that assumes it can just memcpy/memmov its content around, which is not valid according to the standard, but works in practice for objects that dont have pointers into themselves. Imagine you are push_back'ing into an array of ref_ptr (usually not shared_ptr, as we would tend towards intrusive ref counting). In the STL, if you need to reallocate, you'll be moving all the ref_ptrs into a new place, each move constructor would have to set the original pointer to null so that it wont decrement the ref count when it'll get destructed. Thats the correct behaviour according to the language, but we can get away in practice with just a memcpy and freeing the previous data, never calling nor the move constructors, neither the destructors. In the video games industry, the choice is usually easy, performance over language correctness. That said, when starting a new project, there is no need to first reimplement std::vector, just use the STL and if (and only if), profiling shows at some point that you can gain significant performances by reimplementing your own vector, then it might make sense to do it.
The whole of C++ is too mindbogglingly complex to fully understand (see "Most vexing parse" for just one example or read STL source code if you want nightmares). Of course nobody uses all of it which is exactly my point - in real world projects you end up agreeing on some common "sane" subset of features you're allowed to use. "C with classes" (typically "with misc other stuff" added) then tends to emerge as the lowest common denominator that everyone can at least agree on.
Depending on your requirements (native looking or not, couldn't find what nana does on this topic), there is also [imgui](https://github.com/ocornut/imgui) which is having some success, and [nuklear](https://github.com/vurtun/nuklear) which is similar but in C. But as far as I'm concerned, introducing a GUI library in the C++ standard would be a big mistake.
Think again. The preprocessor is phase 3 or 4, can't remember. Trigraphs are phase 1. Not even string literals are safe. 
&gt; a way C is more reusable since it has, you know, stable and well defined ABI. Except it does not. C does not have standardized ABI neither. It is platform dependent.
Just my oppinion or should GUI actually not be part of the standard? I doubt you can create one library to generally suit everyones needs.
&gt; Sure, and then you get long compile times, cryptic error messages This has never come remotely close to being a problem for me, but maybe it still is for some. I try to strike a balance between 'unified' builds and lots of fragmented compilation units by having a couple of large compilation units. Then each one can happen efficiently on its own core. Even so, it is only a couple of seconds for debug builds. If a program is so monolithic that compilation times are still a problem, I switch to using shared libraries. &gt; no tools to "debug metaprogramming" This is true as far as I know, though it isn't a problem for simple templated data structures which comprise 80-85% of typical uses for templates from what I've seen. &gt; in a way C is more reusable since it has, you know, stable and well defined ABI. Does extern "C" not have the same effect?
photoshop uses custom qt, if you want a standard you should do the same
&gt; I doubt you can create one library to generally suit everyones needs. Isn't that true of many libraries in the standard though?
What's wrong with 20-years-old tools? If they're still there, still maintained and still used for new projects, it only proves they're mature and have passed the test of time. 
&gt; This has never come remotely close to being a problem for me, but maybe it still is for some. I try to strike a balance between 'unified' builds and lots of fragmented compilation units by having a couple of large compilation units. Then each one can happen efficiently on its own core. &gt; Even so, it is only a couple of seconds for debug builds. If a program is so monolithic that compilation times are still a problem, I switch to using shared libraries. Yeah, that's what I meant by "it depends on what kind of projects". If you project is small then it does not matter, but there are projects which compiles much longer. And templates are quite often the cause. E.g. with Boost it is possible to create a program with a few lines and it will take minutes to compile. And it does not matter if you switch to shared libraries if using templates. &gt; This is true as far as I know, though it isn't a problem for simple templated data structures which comprise 80-85% of typical uses for templates from what I've seen. I use templates in a "clever way" only in one place in my engine, however every time there is an issue, it takes several times longer to debug than it would take if it is non-templated code. Unfortunately I do not know about any better way to solve my problem in C++. &gt; Does extern "C" not have the same effect? Yes it does.
&gt; The year (2017) and the VC version (15) are as expected. But look at the runtime – it's still 14.0! Or is it? What's that 14.10 earlier in the path? &gt; cl.exe &gt; Microsoft (R) C/C++ Optimizing Compiler Version 19.10.24629 for x64 &gt; Another deviation from the established scheme I don't really get your problem or surprise. VS2017 is binary compatible to VS2015, which is something quite new for MS, it hasn't happened in the last handful of VS releases (or maybe never, not sure about pre-2010). This is indicated by increasing the compiler and runtime versions from 14 and 19 only to 14.1 and 19.1, respectively. No big surprise there. Kind-of like semver. No issues with that, not surprising.
&gt; In C++ the Header file only holds the Definitions of variables and functions right? and the CPP file carries their implementations? So each class would thus have 2 files each right? Sorta. &gt; Pointers and Addresses, how important are they and do I really need to understand them early on or is it something to master when lets say I start being my engine In the future? Very important. &gt; Any good software design/engineering books you experienced programmers use? Something that maybe explains the design choices behind algorithms chosen or design patterns implemented? https://isocpp.org/get-started Honestly though, I always recommend people with Java or other high level language experience start with C, and then move up to where the two worlds (sort of) meet in C++.
&gt; But as far as I'm concerned, introducing a GUI library in the C++ standard would be a big mistake. We can't even have proper file system support, so GUI is definitely never going to happen (fortunately) 
I think Qt is great. Old doesn't mean bad. 
Excellent, OK feel like im heading in the write direction. This definitely feels like learning a spoken language. (side note, ironically the link you gave me suggests its not worth bothering with C. haha I will still explore though, listened to why the create of C++ designed it and it would be nice to see how C works. )
Brill, I bought a book once for my Visual Basics adventure and felt like a lost a bit of money as I learnt nothing (This was a top recommended book) I will be watching the videos! What im learning is, to be a programmer and think like one, you need to mingle with other programmers and talk to them. 
For the pedantic such as myself that should be `return std::move(lhs += rhs);` for maximum performance. Edit: Prevents NRVO. See this: https://www.reddit.com/r/cpp/comments/5rdv0z/overloading_one_operator_in_terms_of_other/dd6usl5/ Edit2: Apparently NRVO doesn't apply to this anyway because it is a function parameter so I was technically correct but for the wrong reasons.
have to say Qt is still the best c++ GUI framework out there.
Qt is probably the best you are gonna get. It has its share of glitches, but it is at the same time of quite good quality and made by very smart people, a lot of them full time. You could argue that Qt's widgets get little love these days but that because they are keeping up with the times and with the mobile ecosystem which is different on many level. What that should tell you is that writing a gui framework is *really* hard. And it hardly can be standardized, because of the way it's tied to the underlying system and very, very quickly changing. A gui framework is really far remove from the goals/work/capabilities of the c++ comitte. But then again, use Qt :D
Hopefully we've learned something new in 20 years.
I much prefer rolling my own UI. I use both 3d assets and SDF ui in my current project and I found it works great.
Yes, and that's the approach that my company took to support with the same code 5 different platforms, including iOS and Android.
Today you have only 2 good choices for building modern crossplatform GUI with C++ - Qt and Sciter. I prefer to use Sciter honestly, because its not a framework(like Qt), but pure gui library and integrates great for existing projects. In addition to that its free, light, has hw acceleration, based on well known html-css-jsalike trio. An amazing but little known gem.
&gt;That implicit conversion might not be desirable in all situations, also non-member operators have to be declared friend if they access private members of class. Can you name any? Generally if you don't want an implicit conversion you would use an explicit constructor. I am not trying to be condescending, I love weird edge cases and I am genuinely curious. &gt;Also, your implementation is modifying the lhs, that is not the expected behavior of Addition + operator. The addition operator should not modify its operands. Doesn't matter from an outsider perspective since it is copied, and from an insider perspective the function is correct by inspection so it doesn't matter here as well.
Usualy you don't have to worry about memory managment for GUI objects with Qt. I was using lambda for some cases when I needed to delete objects explicitly.
&gt; There are none Qt imposes to use raw pointers on your code
`lhs += rhs; return lhs;` is also what [cppreference recommends](http://en.cppreference.com/w/cpp/language/operators#Binary_arithmetic_operators) Keep in mind returning a function argument makes elision impossible.
I don't buy into the idea though that a big project is hurt by compile times so much that it negate the enormous increase in practical safety, structure and productivity of modern C++. Boost is a bad example because in my experience it is an extreme double edged sword, but this is not a fault of C++, this is a fault of problematic boost libraries not adding more than they detract. Conflating the two is more zealotry than reality. 
Is there any official statement regarding this binary compatibility? 
Usualy you don't need to care about them at all. 
Given that they're keeping compatibility, is there any other way of setting the version number? Just bumping the minor digit seems correct.
Because of the following pattern: QWidget* widget = new QWidget(parent); ? Well, you just have to accept that you are not responsible for memory management here.
Why you need something new? I vote for Qt. It has a new version (released like a week ago?), good portability, and a lot of features (like db support, window compositor, own web engine based on chromium, even Qt 3d 2.0 which is a 3d engine). And qml is really great, so you can write logic in c++ and gui in well-integrated javascript-like engine/language. Qml has also nice controls 2.0 for 'modern/mobile' look. Oh, but you need to make sure Qt's licence(s) suits your needs.
It's also really easy to statically link Wx, which in my opinion is an important point. You can make little tools and not need an installer at all, just a single file. If there's a way to easily use Qt without dragging around 20MB of extraneous crap I never figured it out.
The problem with **"**modern c++**"** apologists is spreading [false promises](https://www.reddit.com/r/cpp/comments/5qu8fr/a_guide_to_porting_c_and_c_code_to_rust/dd40vau/?context=3).
I may not use it correctly but a big part of its API rely on raw pointers, making them hard to avoid. [here](http://doc.qt.io/qt-5/qwidget.html) you can see that half of the methods either return raw pointers or take raw pointers as arguments. edit: link format
They didn't really have a choice in the DLLs since the version is embedded in the name. This is the problem Linux/UNIX linkers solve with the trailing SO version numbers (e.g., `libfoo.so.1.2.3`).
How is it misleading to call it old? Releasing new versions doesn't make something "not old", and nobody implied that it was unmaintained. I mean, I wouldn't want to use a 20 years-old game engine today, but for a UI toolkit it might be acceptable, since the landscape hasn't changed as much.
But what's a good free mature alternative that uses native UI widgets and which you don't have to pay for to use commercially?
The few times I saw it mentioned (I think once by STL), it was followed by "but we strongly recommend that you don't mix versions". I guess it's left up to the user to decide how adventurous they want their life to be...
Correct, but usualy you provide "parent" in QObject successors constructor, and it will take care about memory: &gt;The destructor of a parent object destroys all child objects. You don't need to care about memory of those objects. 
Doesn't Qt fit those criteria? You can use Qt under the LGPL, which allows you to keep your application proprietary. You just have to provide a means to the user to link your application to another version of Qt, which can be done by simply dynamically linking to Qt. https://stackoverflow.com/questions/11994053/can-i-use-qt-lgpl-license-and-sell-my-application-without-any-kind-of-restrictio
Indeed Qt will hopefully manage it's memory correctly, but my point was about my distaste for mixing old school code style with my sweet modern c++ style.
Not native widgets if you care about that (probably shouldn't at this point).
Having to deal with pointers in your UI is the antithesis of modern. Declarative UI which deals only with presentation and business logic glueing lower level components together is the bees knees after using QML for 2-3 years now.
But we can have it.
I ran this code on Visual Studio 2015 Community Edition and the result was 1. Hm...
Don't know about osx and there is no "native" widget on linux, but I'm pretty sure it doesn't use win32 under the hood on windows. And you can definitely tell Qt applications by their general look.
Isn't Unreal Engine a nearly 20 years-old game engine ?
Have you ever worked with projects with 20 minutes compile time? That hits productivity pretty bad. 
I wont believe until I see it on every platform I use :)
I did some research ([1](https://forum.qt.io/topic/31871/are-qt-widgets-really-native-controls-on-windows/5), [2](https://stackoverflow.com/questions/7298441/do-qt-apps-look-and-feel-native-under-windows)) and it looks like you're right. It "reimplements" Windows' look and doesn't really use Win32 under the hood to draw the widgets, like I initially thought. However, I think they succeeded in this and I generally can't tell Qt apps apart. Also, Qt uses native dialogs where possible (such as the file chooser dialog). Compare this with GTK or Swing which do not even try to replicate the native look, The GIMP being the prime example of the former of course. It looks so out of place in a Windows environment.
&gt; I mean, I wouldn't want to use a 20 years-old game engine today How about 11 years old? Because that's how old Unity is, and it *might* just be the most popular engine today. But guess what? The code isn't 11 or 20 years old... It's refactored, rewritten, adapted to current technologies, with new code and classes and functionality added regularly. If you are using Qt 1.x, then sure, you are using a 20 year old library. If you are using Qt 5.7, you are using a new library.
/u/Som1Lse covered the questions well, but I thought I would elaborate... 1. One of the most common cases for having implementation in a header file is with template metaprogramming. More details [here](https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl) 2. A lot of programmers tend to overuse pointers, though *references* (and the concept of passing by const reference vs by reference vs by value) is very important to know from early on. With pointers, memory is stored in the heap and access is slower, plus memory allocation and deallocation has to be done manually. The other pointer (excuse the pun) is that you should really only be using C++11 style smart pointers, prioritizing use of std::unique_ptr, then std::shared_ptr, and finally std::weak_ptr. 3. The classic book for design patterns is of course Design Patterns by the Gang of Four, though I find Head First Design Patterns (which is Java based, but is an easy read and has some good content) and [Game Programming Patterns](http://gameprogrammingpatterns.com/contents.html) are also good. As far as I'm concerned though, there is only one *must read* C++ book I am aware of, which is Effective Modern C++ by Scott Meyers. Easy to read, loads of content.
If you're dealing with QObjects (widgets, Qt classes with slots/signals, etc.), there is already memory management built-in: http://doc.qt.io/qt-5/objecttrees.html For everything else, you should be using shared pointers.
Most of these new GUI libraries implode as projects because it's a gargantuan idea. You want a GUI library that's going to outlive the lifespan of your application. Qt is a great choice because it's extremely well maintained, will be around for decades to come, and has some of the best docs around.
Well, I confess, the moment I saw the title posted in /r/cpp, I pinned you for a troll. But after seeing the friendly and positive manner you've handled criticism in the comments, I'm actually looking forward to seeing where you go with this.
So how would you change this [function](http://doc.qt.io/qt-5/qwidget.html#graphicsEffect) for instance ? Make it return an optional ?
I think VS has implemented trigraph removal. The difference is GCC and Clang hide it behind a compilation flag. 
what would you change to this code to make it fit your taste for instance ? https://github.com/eugenkiss/7guis/blob/master/Qt5/OnlyCPP/counter/counter.cpp
I doubt we'll ever see it on microcontrollers that don't even have &lt;type_traits&gt;...
&gt; It's also really easy to statically link Wx, which in my opinion is an important point. Totally agree. wx plays well with the std libraries and boost. the library compiles in minutes, has native look also less restrictive license compared to QT.
sometimes the crashlogs give references to QString or QObject : photoshop elements: https://forums.adobe.com/thread/899269 bridge: https://forums.adobe.com/thread/729128 speedgrade: https://forums.creativecow.net/thread/366/152 etc.. 
trigraphs are removed in the C++17.
When your *compiler vendor* uses terms like "strongly recommend", that's a sign
An easy example: a std::string is allocated on the heap. Not all platforms even have heaps. Even if you have a heap, sometimes you can't afford the possibility of an exception when creating a `std::string` (for example: maybe the code is in an exception handler already...). Or if you want the storage to be inside a `struct` to support network I/O or something, your only standardized option is a C string. See also: Andrei Alexandrescu's recent talk at CppCon 2016, where I believe he talked about how `std::string` didn't fit Facebook's needs for a string. Or see a few other other string implementations out there that address these sorts of issues. LLVM's `SmallString` comes to mind. In the end, `std::string` does a very good job at handling *almost* everybody's needs. But there are still occasions where it's not quite good enough for some particular application.
(Note: I work for the company that makes this.) [FireMonkey](http://docwiki.embarcadero.com/RADStudio/Berlin/en/FireMonkey). It is: * Cross-platform: Windows, iOS, Android, macOS * But has native controls (place a multi-line text box and toggle a property; it will be a real (say) Windows edit when instantiated) * Runs on the GPU * Vectorised (think WPF), scaleable, skinnable, compositable, etc etc * Can be bound to databases or other data sources with a runtime language, LiveBindings * Other cool stuff, like a multi-device designer (don't build a UI separately for phone/tablet; build once and create descendant changes, like class inheritance in concept, which are applied for a specific platform.) Comes with [C++Builder](https://www.embarcadero.com/products/cbuilder). We're quite proud of it. It is not free: it can't be adopted in the standard. As far as *using* something, though, it's great.
&gt; I am not denying that there are situations where you want to have global + operator in order to support lhs operands of different type than the class itself. But your comment is implying that in all situations the + operator should be defined as global function. Whether a binary + operator should be a member or non-member depends on if you really want to support left side operand to be of different type than the class itself. There could be a situation where you don't want to, like in this case Order class does not have any implicit conversion. Yes it is implying that `operator+` should be global/`friend` in all cases. The reason I am implying that is because I have yet to see a case where you don't want the implicit conversion for implicitly convertible types, which is exactly why I EXPLICITLY asked for a counter example. As in a piece of code where it is actually beneficial to disallow the implicit conversion on the left side but not the right side (if you want to disallow it on both sides make the conversion `explicit`). Again I am open to the fact that it might exist, I have yet to see it though. (I remember once using `std::move` specifically to disallow RVO because the move-constructor had a side effect I relied on, though that code has since been retired) &gt; Not to mention that the global operator might have to be declared friend. 1. What is the problem with making it a `friend`? 2. Not if it is implemented in terms of `operator+=` (assuming of course that `operator+=` is `public`). &gt; As for the second point let's take this example: &gt; &gt; Order lhs; Order rhs; &gt; &gt; Order added = lhs + rhs; &gt; &gt; your implementation modifying lhs. It should not. But if you take the original code and make your modification you end up with infinite recursion: Order operator+(Order lhs, Order const &amp;rhs) { Order added = lhs + rhs;//oh noez return added; } Or if you mean the following Order operator+(Order lhs, Order const &amp;rhs) { return lhs += rhs; } Order a; Order b; Order added = a + b; //`a` is still the same value as before the addition then no, `a` is still the exact same value as before since it is COPIED into `operator+`.
It seems to me that your discussion of the popularity argument is abbreviated to the point that it's badly misleading, even at very best. On one hand, it's true that from a purely abstract viewpoint, being popular does not imply being "good" (whatever exactly you take that to mean), nor suited to a specific purpose. At the same time, popularity (especially in the long term) can imply some things that really are meaningful and important. For an obvious example, popularity (or lack thereof) tells you quite a bit about the availability of people who know that language. From the viewpoint of somebody who is (for example) starting a software project, the quality of the language itself may easily matter a great deal less than the ability to hire people qualified to write and (in the longer term) maintain the code base. A language that was better suited to the specific tasks involved in that project (at least as currently envisioned) might still be nearly worthless if it's so obscure that hiring people to write and maintain it is next to impossible. Especially for large, long-term projects, this can be extremely important--quite possibly one of the most important factors in choosing a language. To summarize: I've never seen the argument made as you've stated it, and the only argument I've seen that was reasonably similar actually has a great deal of merit. From a practical viewpoint, they're right and you're wrong.
I'll bet it does. I'm not sure why it is a given that compile times can't be optimized or changed however. The same C++ programmers that won't accept poor runtime performance seem to lay down and accept whatever compile times they happen to wind up with. 
Well, we need to draw a distinction between "useful for most applications" and "useful for all applications" then, or we need to remove virtually every function in the standard library because we can come with a single application that doesn't need it
Qt expert here. Qt is very, very good. I cannot praise it highly enough.
&gt; Boost is a bad example because in my experience it is an extreme double edged sword, but this is not a fault of C++, this is a fault of problematic boost libraries not adding more than they detract. People rarely discuss languages these days without also discussing the language community. Boost is widely considered to be "good C++" and as a result a fair amount of things from Boost have found their way into `std`. Ironically, it seems everyone but Bjarne condones stuffing insurmountable complexity into libraries with "good client APIs". Abstractions in C++ are usually leaky... you have to understand not only library internals, but *compiler internals* if you want to be truly effective. To this end, even the most idiomatic C++ libraries are practically nightmares the instant something goes wrong. We're talking pages of incomprehensible compiler errors, strange runtime behaviour, and unreadable code that looks like a truck full of `::` and `&lt;&gt;` crashed into your text editor. Glacial compile times are only the tip of this iceberg.
[C++14/17 Features and STL Fixes in VS "15" Preview 4](https://blogs.msdn.microsoft.com/vcblog/2016/08/24/c1417-features-and-stl-fixes-in-vs-15-preview-4/) was my official statement, including: &gt; And the STL binary compatibility means that third-party libraries can be built once and used with both VS 2015 and VS “15”. (However, it is still best for everything to be compiled consistently with the latest available version, as that will give you the most correctness and performance.) That is, mixing-and-matching should work, in that stuff shouldn't crash. However, due to how the linker works, you might get the correctness and performance of the oldest version involved. Compiling everything consistently with the latest version will give you all of our bugfixes. **Note:** as far as compatibility is concerned, mixing 2015 Update 2 with 2015 Update 3 is just like mixing it with 2017 RTM. They're literally the same branch (WCFB01) and we've been continuously following the same rules. The compiler changed its version number to help identification, but didn't actually change anything regarding compatibility.
I doubt we will see it on systems that don't have file systems. (although it could be implemented as always returning errors, throwing, etc)
Meh, I get to play with big magnets (MRI scanners) in my job. It has its plus sides.
That's actually a good point. Looking at some of my most used apps (Discord, Telegram, Steam, even Firefox nowadays), they all have non-native UI. As long as your UI is cohesive and has good UX you can probably get away with it.
Clearly my ~~crappy~~ *superior* header-only, ASCII-WYSIWY^more_or_less G GUI library: [IUPA2](http://i.imgur.com/PiYe7V7.png) It's the result of a two hours coding session to win a bet. Windows-only. Not opensource (too ashamed of the entire project :) Anyone who'd like to pick the idea up is welcome to do so.
The project where your goal is to exemplify a project where you couldn't use *any* container would be a good example.
Note that Qt has two totally different GUI approaches: QWidgets and QML/QtQuick.
&gt; shortly before puppies are banned and kittens are mandated. You're a monster!
&gt; An easy example: a std::string is allocated on the heap. Not all platforms even have heaps. That's not just a std::string issue though. If you can't use heap allocations, must standard containers aren't usable. I can see a good argument being made for some sort of std::array equivalent for strings. &gt; See also: Andrei Alexandrescu's recent talk at CppCon 2016, where I believe he talked about how std::string didn't fit Facebook's needs for a string. Or see a few other other string implementations out there that address these sorts of issues. LLVM's SmallString comes to mind. Facebook went to all the trouble of making their own custom string and the result was [a 1% performance gain.](https://youtu.be/kPR8h4-qZdk?t=17m27s) That developement time, performance tradeoff makes sense for Facebook but it probably won't for most projects. 
There is no shortage of reimplemented std functions that optimize for their use case rather than the generalized one provided in the stdlib. Many game dev companies do this due to allocation requirements (see easl) as well as large, performant codelines like LLVM. i.e. http://llvm.org/docs/doxygen/html/classllvm_1_1SmallString.html and http://llvm.org/docs/doxygen/html/classllvm_1_1SmallVector.html
&gt; Has anyone used QT to make a GUI in c++? I'm pretty sure it's been used a few time. ;-) /s
Of course compile time can be optimized, one way to do that is using less templates :) I am not saying you should not use templates for containers or some other useful stuff, but there are people out there who use templates to implement crc32. Author of the orthodox c++ is not saying that either, he uses tinystl iirc.
I don't have much experience with microcontrollers, but is missing filesystem library an issue? Is filesystem a common thing you use with microcontrollers?
&gt; The C++ style exposed by Qt, while effective, is not modern (raw pointers, heavy inheritance) by any means and I don't have a problem calling it old. Sorry but Qt5.7 is NOT a new library. Totally agree on that one. Qt somewhat modernize their codebase, but really only a bit, the general style is still very old and there's so much cruft in this library. So it's definitely not "new" even though Qt5.7 (or 5.8 even) just got released. This is an old elephant.
Except on mobile, or any platform that doesn't allow dynamic linking. (Hi Apple)
VC++ has it behind [a compilation flag](https://docs.microsoft.com/en-us/cpp/build/reference/zc-trigraphs-trigraphs-substitution), too, it's just that the defaults are different.
Compiler support for game consoles tends to be terrible, although the latest generation seems to be much nicer. I am afraid about the latest Nintendo though. Also the last time I tried Clang in Visual Studio, I was not able to compile any bigger project.
Why bewildering? It's straightforward, really :-] &amp;ndash; the name of a variable alone gives you the _declared_ type of the _variable_; anything in parenthesis, including the name of a variable, gives you the type of the _expression_. Here, the actual declared type of the variable `j` is `int&amp;`; and the type of the _expression_ `j`, from inside the lambda in which it has been captured by value, is `int const&amp;` (because non-mutable lambdas have a const `operator()`).
&gt; Sounds like bad practice. Agreed, it compiled after being explicit and saying template &lt;typename T&gt; void f1(int a, foo::s b, T c) { }
We have managed to reduce the issue and PR backlog by significant amount (issues from &gt;260 to 190, PRs from &gt;60 to 29), since the start of the year, and new ones should get response in reasonable time.
Nice work. I have been using catch, and it's imho the best unit testing framework for C++: simple, header only, readable, does exactly what you want. Thanks for working on this.
QML and the JS engine it runs on in Qt were completely rewritten for Qt5 as well. If you don't touch QtWidgets, you are probably only running code from this decade.
Netbeans is my favorite, because it gives you the advance interface of JAVA IDE
As an aside, I would encourage the following convention: template &lt;typename A, typename M&gt; auto fmap(M map, expression_r&lt;A&gt; const&amp; e) { using B = decltype(map(std::declval&lt;A&gt;())); using Out = expression_r&lt;B&gt;; return match(e, [](int i) -&gt; Out { return {i}; }, [](id v) -&gt; Out { return {v}; }, [](const add_op&lt;A&gt;&amp; x) -&gt; Out { return {add_op&lt;B&gt;(o-&gt;rands() | transformed(map))}; }, [](const mul_op&lt;A&gt;&amp; x) -&gt; Out { return {mul_op&lt;B&gt;(o-&gt;rands() | transformed(map))}; }, [](auto) -&gt; Out { throw_missing_pattern_matching_clause(); } ); } This relies on `Out`'s constructor being non-explicit, but gives the same effects as C++17's guaranteed copy-elision in C++11 and 14 (it constructs directly into the return value).
I am normally not this blunt, but uh.. Do you even know what a compiler is?
My guess is that most projects would be better served directing effort elsewhere. Facebooks code is, I think, particularly std::string heavy. Other projects might not even see a noticeable performance change. IIRC, most std::string implementations now use optimizations similar to Facebook's anyways. 
Thank you for you feed back! I completely agree that the availability of qualified engineers and training material is a very important factor when considering a technology for adoption. In fact it is one of our formal criteria at work. The sources I cite that use the popularity argument do so without this explicit context. I think the most important thing I have learned from the community feedback on this article is that articulating why a particular argument was not compelling only confuses the conversation.
I'm not sure this is a good idea. You'll have to deal with things like http/https proxies yourself. Better to use something like casablanca where it's already been implemented.
It's differences between semantics of list-initialization vs copy-initialization. I can cite the sources if you need, but I assume you know where to look. ;-]
That's the real mystery, I played with it for a while trying to find a difference but couldn't.
A smart pointer would do the trick in a more modern way :) If you really want to avoid pointers, returning reference if available and throwing if not. But it would be cumbersome for a mere getter.
Ditto. I'd add that you can just drop a _single_ header into your project and it all works. I use it for all my C++ testing needs these days...
No; referring to C++11, I mean the distinction between [dcl.init]/16b6.2 and [dcl.init.list]/3b4. In the former, the constructor call explicitly "initializes a temporary of the cv-unqualified version of the destination type" which is then "used to direct-initialize, according to the rules above, the object that is the destination of the copy-initialization". In the latter, construction is direct and no temporary is involved. The paragraph/bullet numbers change in C++14 but the meaning doesn't. Again, this allows for non-copyable/non-movable types, which cannot be used with `T{...}` syntax pre-C++17.
It would be really interesting to see these sorts of benchmarks on ARM, in particular the Cortex-M family. Testing this stuff on x86 is neat but that's only one architecture where C and C++ are used.
Just cal it "Visual Studio roughly 14 through 19, depending on how you count it." Perfectly clear.
Catch is great, I recommend it to everyone looking for a unit testing framework unless you really need something you can't find in catch.
Cool. Was following along nicely until "...now we add deduction guides.." This probably belongs in /r/whoadude!
[removed]
Actually, linux support is coming in March. As a C++ Builder user (one of the few apparently), I do quite like the environment. Expensive, but I've never regretted the choice.
Nice. I've been using catch for a while now, and it is truly great. Every other unit test framework I've used has little nits and annoying corners. The only thing that has ever bothered me about catch is how long it takes to compile my test suite, and even that isn't horrible, because I use GitLab's CI to do my tests, so it still runs on my machine (on a GitLab runner), but at least I don't have to wait for it. I just need greens to merge.
What's this with the strong typedefs being convertible to double? Can anyone explain?
This problem can be averted by precompiling the catch header, maby not the best solution for a buildserver but its possible! 
This class Volatility { double underlying_; public: explicit Volatility(double u) : underlying_(u) {} explicit operator double() const { return underlying_; } } is a strong typedef for double. Its convertible back to double, but only with explicit cast and Catch's `Approx` now supports using Approx to compare `Volatility` to a desired value: auto v = Volatility(0.3); REQUIRE(v == Approx(0.3)); 
Can u provide some more information?
[doctest](https://github.com/onqtam/doctest) is a reimplementation of Catch with a focus on compile times - see differences [here](https://github.com/onqtam/doctest/blob/master/doc/markdown/faq.md#how-is-doctest-different-from-catch)
Ok so it's the same problem as if you tried to do struct a { }; int a; a obj; I guess gcc and clang accept the original code as &gt; No diagnostic is required for a violation of this rule.
Inboxing you :)
I'd go with Cmake &amp; Clion. The premises of scons ( and waf, which is a more modern scons ) seems great. Write some python, it's simple, everybody knows python... except, you spent at least as much time, if not more reading the docs and trying to understand the internal architecture of the build system that is leaking left and right. You get a lot of power, which you feel compelled to make the most of, and before you know it, the year is over and you haven't done anything beside writing some python. Plus, you will need to write build file for every dependency you use. On the other hand, cmake has a crappy dsl but its design and well fitted for the job. the cognitive load is about the same since for scons you still have to remember how the api is designed anyway. Also, a lot of open source project ship CMake files that you just have to include. I will quickly mention QBS that is developed as part of the Qt project. It has a really lean DSL based and qml and has script capabilities using JS. The QML syntax really works well for a build system. However, I'm not sure I can advise to use it because its lack of popularity ( meaning that you will have to write qbs files for every 3rd party you use). One other thing to consider is that most IDE support cmake and... cmake. so yet again an argument if favor of bitting the bullet and using cmake. 
Thanks!
I usually come up with following rule-of-thumb results: GCC is better at ALU stuff and clang better with vector intrinsics. Both used to be really bad at the vector instruction handling but lately clang has been a real wizard with them. GCC always pulls some magic ALU trick out of it's a** somehow. YMMV.
Just the other day I was doing some random De Morgan related stuff ( https://github.com/t0rakka/mango/commit/782dcb367cf0b49f770289348b80877cf135156d ) and clang really outdid itself this time. Intel simd instructions only do greater-than and equal-to comparisons for integers (&gt; and ==). I wanted symmetric API so implemented the other compare operators in terms of those two, which is kind of trivial as you only need to swap the compare parameters or complement the result to invert the "boolean" result. Let's say you want to do &lt;= operator. It's inverse of &gt;, which the hardware can do, so: &lt;= is same as !&gt;, so far so good. There is no "bitwise-not" for x86 simd once again, so it must be implemented.. one simple way is to do xor(value, all_bits_set). One way to generate all-bits-set is to do compare_equal(value, value) which is true for all values that aren't NaN. The commit I linked above shows the generic bitwise-not implemented in this fashion. The "other" operators are implemented.. then.. when you compile the code, what happens? GCC and ICC generate two extra instructions, pretty much verbatim what is requested by the source code. That's decent and acceptable. When you compile the code with clang, it actually seems to evaluate the boolean ("De Morgan") logic and comes out with two instructions short: it actually INVERTS THE LOGICAL EXPRESSION using the information at hand at compile time; kickass! It's just matter of time until GCC folks catch up in this regard, they are already magicians on the ALU code handling. It still does matter what idioms are used, for some the compilers aren't yet so great at.. but this is the part where compiling code day in and day out comes in handy (it's called experience, I think.. but experience requires constant re-training and refreshing to keep up with the ever-changing parameters).
I was looking at using FakeIt for a while, but it seems to no longer be maintained
A little note why the commit was named as it were: it is not necessary to invert the result - one can simply interpret it differently: result = select(a &lt;= b, value0, value1); Can be implemented with &gt; like this: result = select(a &gt; b, value1, value0); Notice that the values are swapped; this reflects the fact that the result is now inverted. This has the downside that it increases the cognitive load, so I implemented the "more expensive" functions to make the API symmetric and easier to use (expecting the cost of those operations to be more expensive). clang to the rescue, etc.. 
thanks a lot for the clarification
I tried to use to make a gui and i failed bad, it is to complex and the doc, well, has lots of words but even the examples doesnt work I am triyng awesomiun rigth now, it is much easier and i like it more
Yes. It's kind of annoying that it's split into "hosted" which has everything and "non hosted" which has nothing at all. I think the split ought to be moved somewhat, since there's no need for things like &lt;utility&gt;, &lt;priority_queue&gt;, &lt;array&gt; and a bunch of others to be missing on any platform.
Why did you have to write `T` instead of `B` in the constructor?
It wasn't puzzling. Apple didn't want a GPL3 compiler.
One of the things I really like about [bandit](https://github.com/banditcpp/bandit) (and its related matching library snowhouse) is that it allowed me to write assertions to check if a vector contained a specific set of elements. Or maybe a specific set, but the order doesn't matter, etc. I see that Catch has some preliminary support for matchers, but I was wondering how people are testing these things in Catch right now?
We are. We've written some custom matchers and it's working pretty well for us. Like most things, documentation on how to write them is pretty poor to none existent but once you've go right basics down it gets easier.
Currently using gmock with catch. Obviously not a nice as some of the C# stuff, you'll have to think more about how to write and structure your code to allow it to be mockable.
I'm curious, why is std::string (or wstring) not useful outside class assignments (at least assuming you're not doing heavy duty text processing)?
&gt; It can give you a simple project setup that just works with only a few lines What is the real reason you're recommending it though, you can define your project with a single line in CMake `add_executable(main main.cpp)`
Haven't you moved to Drover* yet? *Drover is a cross-platform toolkit (internal to Adobe) that many of the products use. I helped work on it.
I would say Scons is pretty much dead, at least in the open-source world, or in most communities. I've last seen it on a project 10 years ago, and oh boy, am I glad I didn't have to use it since. Go with CMake, it's a no-brainer.
The indexer is based on clang, so it parses everything I have been able to throw at it up to C++14. Haven't tried C++17 yet.
[GENie](https://github.com/bkaradzic/GENie) is a project generator tool. It automagically generates project from Lua script, making applying the same settings for multiple projects easy. Initial version of GENie is fork of Premake 4.4 beta 5, and there is no intention to keep it compatible with it. It was made as Premake became an almost dead project.
For a build system I would personally recommend meson. It is basically cmake with a sane syntax and doing the right things by default. For an IDE my favorite is KDevelop. Perfect C++ support and and million different useful features. Integrates with cmake as well if you end up going for that.
Certainly string manipulation functionality shouldn't be in std::string
It would be much better to have compiler time reflection support in C++ now or at lest in near future. This would allow elegant solutions for such problems. 
Cool, I'll definitely give it a try then!
Catch and release?
[Trompeloeil](https://github.com/rollbear/trompeloeil) is nice, modern, maintained and works well together with Catch.
Only downside is that you need *a lot* of RAM to work on a large project, but it is definitely worth it.
FYI, [ReSharper C++](https://www.jetbrains.com/resharper-cpp/) supports running Catch tests since the 2016.3 release, as will CLion starting with 2017.1 (planned for March).
We haven't yet, though believe me, it's not for lack of trying.
Well that indeed sounds like fun. Hopefully they at least accept your "improvements" to the Matlab code, and will let you put it under source control for them. 
Hijacking top comment, because I messed up the release tag and when I fixed it, the link got orphaned (and can't be edited apparently). The proper link is https://github.com/philsquared/Catch/releases/tag/v1.7.0
For Xbox that's a problem, but windows for desktop shouldn't have issues running clang or GCC with something like mingw or cygwin.
Modern CMake. Have a look at these slides : https://docs.google.com/presentation/d/18fY0zDtJCMUW5WdY2ZOfKtvb7lXEbBPFe_I6MNJC0Qw/edit#slide=id.g15c79ae86d_0_55
I must really give KDevelop and Meson a try some day. My current favorite right now is QtCreator + CMake. QtCreator has decent CMake support, but most importantly it's quite light weight &amp; snappy, and comes with loads of neat features out-of-the-box (e.g. clang-based code model, compiler warnings as-you-type, super-fast &amp; intuitive code navigation, clang-format selected code, decent git integration, handy refactoring tools, etc).
Here is a minimal C++ gui with Qt : https://github.com/eugenkiss/7guis/tree/master/Qt5/OnlyCPP/counter
Why is there a white bar at the top of the website?
nice work.
&gt; (And if you meant decltype(j) in a function object rather than decltype((j)) then it certainly would not be '01'.) [Correct. I should've said '00'.](http://coliru.stacked-crooked.com/a/29df78ab8c758054) In any case, it is not the same as the lambda case which was my point from the beginning (the 'magic' comment might've been better phrased "as if by magic"). I understand what it is doing but I would not call it intuitive. My intuition says "treat it as a function object" but that intuition leads to the wrong answer. 
Optimization as non-dead code elimination, not only in strict aliasing but many other kinds of UB based optimizations. I'll coin a term now, take notice: compiler footsweep. There are many ways for it to get applied, it's better when they come silent, with no warnings. - https://www.youtube.com/watch?v=ezvFUW4gONA - https://www.youtube.com/watch?v=O6QXyqJHFag
Your sample code is different to `-0xFFFFFFF == 1`. x86-64 typically has 32-bit ints. Try outputting `sizeof(int)`, see if you get `8`. 
&gt; 0xffffffff is an int literal No, it is an *unsigned* int literal (assuming 32 bit int). That's what creates the surprising behavior.
Why not use Premake 5 ? What are advantage of GENie over Premake 5 ?
Every time you combine hashes like this a kitten dies.
This. I kind of hate how sucky you need to make your code to make mocking possible
https://godbolt.org/g/i7kETB Wow! Some GCC regression; 5.4 does O.K. but after that a complete disaster - what's going on? 
Yes, I meant it to be xor, was a brain fart. Thanks for the link I'll take a look.
https://godbolt.org/g/cdWwBe If change the parameters into const-ref, it's clang's turn to blow up. I thought using typedef to declare parameter-to-function days were over for low-level utility libraries. :(
It's common to not use exceptions in embedded systems when using C++. If you access a container that throws exceptions (like out_of_range for std::vector) it will throw an exception and will not be handled. For this reason, many embedded C++ projects will not use any standard containers.
Hotfix? Meaning it's even less tested than U3? I hope Microsoft tests it fully and releases it on Microsoft Update.
https://godbolt.org/g/iVK9pG Manual unrolling; the GCC does better but still a bit more complicated solution than what the clang uses. If you add -mavx compiler switch it looks like GCC is trying to vectorize the code. When the switch is omitted the vectorized representation is blown into small fragments. Using uint32 and count of 4, same result. Looks like vectorize -&gt; no simd -&gt; blow up. This is really weird that usually GCC is really good with ALU code. I think the vectorization attempt is throwing it off tracks. Anyone knows what's going on?
Last time I looked, it could do basic stuff like "hello world" examples, but appeared quite lacking for anything even slightly demanding.
My problem with **scons** has been that it was a lot slower than even a bad make script. But yeah **Cmake** syntax is about as readable as make and really no better. I have been experimenting with **qbs** a javascript based solution from the Qt guys, but it still feels a bit unready or at least under-documented. I think I will have to look into **Premake 5**.
I don't believe stuff like this will get sent to MU unless they are "recall class bugs" and I don't believe these are. (But I'm not familiar with the particulars of any of these hotfixes or how this servicing is being done, so take this as "Bill's random suppositions" rather than "Bill as a representative of the VC++ team")
&gt; it has one big disadvantage: it requires a Python runtime to work Honestly, you have to install *something* for any build system.
&gt; It was made as Premake became an almost dead project. Why do you keep spamming this lie here? Premake is not dead at all.
Well yea, but there's a difference between having to install *one* thing, vs having to install *multiple* things. Because to build a project with Scons you need both the Scons files and a working Python installation. That's two entirely different and separate set of packages that have to be installed - whereas both Premake and CMake can be just unzipped, added to the path and they just work™. And actually, since Premake is just a single executable, it can easily be redistributed with your software. I've seen it done a few times - and while I don't particularly like the idea, it definitely gets the job done. You just invoke a platform-specific shell script, which in turn selects from the pre-packaged set of platform-specific binaries.
Oh yea, I've seen benchmarks of some of the build systems out there in the wild, and on those graphs the Scons column was like a freakin lighthouse :D It's insane for sure. I'm not too big of a fan of CMake, because I don't really like that I have to manually remember all the compiler-specific switches. That's just too much for me - I'm just not too used to it, and I'm not the type of guy who likes to memorize these kinds of stuff. I've only just heard of qbs from the comments on this post, but to be honest, it doesn't sound that promising to me. I like the features of the Qt libraries and all, but not too fond of their exotic build environments. Premake is cool, though it has one big disadvantage: it's developed, *very, very* slowly. But on the bright side, from the projects that I've seen it still seems more adopted than scons, bazel, waf, or the likes, and it also has some support from Blizzard. I'm still kinda hezitant about it though, because even with all of its amazing features, all the support that CMake's got is crazy, and not to be ignored.
I feel you. Together with attitude "let's test if 2+2 is still 4 in this universe" code base quickly goes downhill. Now you need a lot of mental effort to reason about code with has interfaces and virtual functions for everything. 
&gt; Anyway I qualified my solution as very quick, and qualified it again in my last comment, the main point of the code was to show how few lines it is to actually do this in C++. Sure! I'm not intending to take away from that. I'm more saying that we (the standard library) need to do better at solving this problem.
You can use dynamic linking on iOS since iOS8 and even then, you can statically link to LGPL libraries as long as you provide the proprietary '.o' so that someone can relink.
This subreddit is for discussions about the C++ language itself. If you're looking for a code review, could I suggest trying /r/cpp_questions or https://codereview.stackexchange.com/ ? 
Please stop spamming this subreddit with terrible examples.
I was able to install this hotfix on a VS2015 Update2 install. Now does that mean if I apply Update3, I'll need to apply this fix again?
CMake was spawned by the foulest of movements deep in satan's own bum. Unfortunately, the same is true for every single other build tool that ever was or ever will be, so there's no escape. :) CMake has the advantage of being the community's favorite build generator right now. Multiple IDEs support it natively (including the newest version of Visual Studio), many third-party libraries rely on it, packaging tools like vcpkg/conan/etc. are integrated with it, and so on. It's the wisest choice to start with due to its wide support and mindshare and so that you can familiarize yourself for future projects where it'll undoubtedly be inflicted upon you. If you don't care about compatibility or popularity or preparation for the coming dystopian future of the cmakian witch-kings, though, I personally really like [meson](http://mesonbuild.com/) conceptually, [premake5](https://premake.github.io/download.html) practically, and [build2](https://build2.org/) culturally.
The un-hotfixed compiler built many millions of lines of code correctly. The tests passed and the software worked. When you're on the compiler optimizer team you get those 1 in a million cases.
ah damn. back to reinstall. 
Okay, will there be a U4 for 2015 then?
CMake
Does this work with CUDA 8?
This hurts me to read.
Which compiler do you think is used to compile Windows?
&gt; All compilers have silent bad code generation bugs. Having attended a single course on static program analysis and having an idea about what implementing an optimizer entails, I have always wondered about one thing: how do you test the damn thing?
You can report a bug through the IDE's Report A Problem. Although you already have a fairly small test case, it is ideal if you can eliminate all library machinery (like, do you actually need to call my implementation of std::invoke).
You will find this interesting: https://blogs.msdn.microsoft.com/vcblog/2016/05/04/new-code-optimizer/ Also search for [csmith](https://embed.cs.utah.edu/csmith/), [opt-fuzz](https://github.com/regehr/opt-fuzz) and ["equivalence modulo input" paper](http://vuminhle.com/pdf/pldi14-emi.pdf). There's also recent work on that last one with [glsl compilers on medium.com](https://medium.com/@afd_icl/crashes-hangs-and-crazy-images-by-adding-zero-689d15ce922b#.3dj2huxc1). EDIT: added links, fixed typo.
I spent some time trying, but I'm not super familiar with the traits machinery. I'm still relatively new to such template magic. I managed to replace the invoke with something naive, but it ended up removing about 15 or so lines from the code gen, so wasn't sure if it was worth removing as obviously it'd be nice to have the whole thing compare well against GCC and clang. So I submitted it as is, with a link to a gist with my minor change. Link to the report: https://developercommunity.visualstudio.com/content/problem/16882/excessive-codegen-on-function-view.html Sorry for any hassle!
Fair enough.
Gotcha, I hadn't realized that was happening. I hadn't looked at the account until now so didn't see that was their only post. Until then I just assumed they were just a user who had migrated, not knowing premake had "come back". (Albeit still having been developed all that time, just not making releases.) I understand the annoyance, although I think it's somewhat fair to keep a fork going, although at this point I doubt I'd use it (More of a CMake person if I'm using a prebuild system nowadays). They're doing some interesting stuff like working on a FASTBuild generator, so that's cool to see.
move to mingw, and never went back, feels good
Hopefully, none of them. The C++ standard is not the place for any kind of GUI library. I'm just going to repeat the words of Wim ten Brink, and then add my own: "The problem with graphic libraries is that graphics are very complex and often hardware-dependent. Furthermore, not all hardware supports the use of graphics and C++ is meant to write hardware-independent code. Basically, your C++ code should be able to compile and run on any system if you only use the standard libraries! So, if you want to support graphics then how should it do so? There's DirectX from Microsoft but that's platform-dependent. You don't want that. So the alternative is OpenGL which is supported by most hardware that support graphics, including the more modern mobile devices. But OpenGL is a huge and complex standard that's better suited to be developed outside the C++ standard. Especially since the OpenGL standard needs to be supported by all producers of graphic cards. The book about OpenGL is bigger than the book about C++. Also, the OpenGL standard is a C library, not a C++ library, but there are plenty of wrappers around it. So, when you would consider the functionality that you would like in a standard graphics library, what would those be? Output of text, of course. Drawing lines and circles. Displaying bitmaps and icons. Animations, sprites and buttons. Maybe even the more complex 3D graphics? When you start thinking about the required minimum functions for such standard graphic library, you will soon discover how much it would actually add to the standard. It would make the whole C++ standard way more complex. Creating a graphic library is also complex because you depend on the hardware manufacturers to support the library you create. Performance is the most important part here and it would be bad if the graphic library would e.g. do a floodfill through the standard function in 2,000 clock ticks while the hardware could do it in 10 clock ticks if you call the proper function. Which is why you don't want a standard library as part of the C++ standard. not as part of any other programming language, to be honest. What you might want is a library to create forms, buttons, textboxes and other window controls. Here too, you would end up with a lot of extra functions, classes and other stuff and basically the same problems as with a graphical library. But here you would also need a special designer to create the layout of those forms so a designer can place buttons and labels at the right spot while the developer writes the background code. This too would become too big for the scope of standard libraries. Besides, you would have to define a format or script language for the form designs, like XAML or HTML to put controls in the proper location. Such a script needs to be customizable so new controls can be added easily and whatever IDE you use would need to be able to process these scripts and display them visually to the designer. Basically, adding a graphic library or even a simpler forms library would make the standard way more complex than it already is. Yet, what is included is just better suited as a third-party library so developers can choose between various options and pick the libraries that provide the best performance for their price. Such libraries would be way too big to include in the standard." - Wim ten Brink I see graphics libraries adapt and change in an ongoing arms race with each other, in a very busy graphics hardware scene (both display hardware and GPU hardware); anything that went into the standard would have to be specific enough to be useful, but so general as to be applicable everywhere, and once it was in the standard it'd be almost impossible to get it out. In 2040 we'd be stuck supporting outdated ideas and concepts that everyone wished would just die. Long story short; C++ is not the kind of language in which to put something so specific and heavy as graphics libraries, and I sincerely hope it never gets one. There is a rich, vibrant eco-system of graphics libraries targeted at a range of hardware and needs; trying to devise a single library for a programming language such as C++, which deliberately doesn't specify anything at all about hardware (excepting the C++11 memory model, which was necessary for threading) to be standardised for all time would create something so broad as to be useless for anything other than toy demonstrations. C++ as a language lends itself to third party libraries for this sort of thing, and that's exactly what we've got. Work with the language; not against it.
qtcreator + qmake/cmake
I just find them equally ugly to be honest. For years now I have contemplated creating a software library for defining build architecture. To build it you'd write and compile it in a native language and produce an executable which builds your project. I know it is a weird idea, but I have been really curious for a while now how such a thing would perform compared to the declarative DSL based solutions such as Make, Ninja and so on. Maybe one day I will get around to making it just to see if it is a horror show to work with or not.
huge fan of the hash append idiom proposed by /u/HowardHinnant
Happy that someone else is blogging about idioms and effective usages of STL algorithms! I'm doing something similar, although I mostly use examples from programming puzzles and competitive programming. [Here is my series](https://marcoarena.wordpress.com/category/competitive-programming/) - recently my effort is lower because I'm involved in many other "community" things. Also, every month I set up a 2h coding dojo where I propose some puzzles. Each puzzle generally hides some trait that should lead people to find clever/effective usages of STL algorihtms and containers, or of their own favourite language standard library/constructs. I'll be very keen on exchanging ideas and pointing to your articles if I blog on something similar.
The STL is a many-decade old library which was plundered and variations where incorporated into the `std` library. I am uncertain why you'd want to make new lessons on using it. For the most part, it is obsolete, superceded by simply using the standard C++ library. But to each her own.
He probably _means_ the standard C++ library. Many of us, including me when I'm tired ;-), tend to use the terms interchangeably, particularly since not so long ago they were one and the same.
Keep spamming? My first post ever! :) I was just reporting what other coders say. I'm honestly using Premake 5 myself for a project and I think it has its own issues and I found in GENie a big step forward (more platforms for instance and so I'm going to adopt it. Ok maybe the word dead was a bit too much...pardon me. 
&gt; My first post ever! OK, I'm sorry if I mixed you up with that guy, although I can't ignore the possibility of this being a throwaway account. 
Right! I meant the part of the standard C++ library that uses templates - in particular containers and algorithms. So the STL as in 'Effective STL' from Scott Meyers. Hope this makes more sense
Some standard library developers call it STL. Some are even called STL.
Honestly - just give me cmake generation in premake and I will never, ever, look back. 
Guau, i will try rigth now, it looks awesome and i trust and like kde products
&gt; CMake was spawned by the foulest of movements deep in satan's own bum. Nice one. I should add it to your ["What's wrong with CMake?"](https://build2.org/faq.xhtml#cmake) FAQ entry. &amp;nbsp; &gt; Unfortunately, the same is true for every single other build tool that ever was or ever will be, so there's no escape. I will have to disagree here. It is not easy for a language like C++, I will give you that (in essence, too much variability). But it's not impossible. Rust guys seems to have managed so I don't see why can't we. &amp;nbsp; &gt; I personally really like meson conceptually, premake5 practically, and build2 culturally. Could you elaborate on that? 
It's only Jan and I've already exceeded my annual quota for the word *craft*... Seriously, though, very light in the documentations/examples department. In particular, it's not clear what they mean by *meta build system*? Is it like CMake meaning it has its own buildfiles that are translated to some underlying build system? My feeling is that it is just a package manager that you can use with various build systems. Perhaps with some kind of a build system abstraction layer? Funny: requires Direct X on Windows (via dependency on QtBase).
&gt; I meant the part of the standard C++ library that uses templates - in particular containers and algorithms iostreams use templates too, and so do the type traits, and atomics, and complex numbers, and valarrays... and pretty much everything.
It will allow you to build your package along with building of all of your dependencies. If you know Emerge on Gentoo it is something like that, this will allow projects to ship current and patched dependencies rather than relying on internal copies. It also will make it easier for others to build and update your project even if it has a tone of dependencies. 
Thanks for your work. :) I appreciate that matchers aren't technically supported yet, but half look forward to when they are. Only half because I'm going to have to go in and fix our stuff if/when we finally get round to upgrading ( still on 1.2.1 for this reason ). But that's par for the course when using undocumented internal features ;)
*source-based* package manager 
Yes, not only instantiations but one could more easily find all references/overloads of `S` and provide content assist with members found. To make it easier for a user, member functions and member methods could be grouped separately.
This is a build / package manager meant to handle complex projects and to be used internally with devs and testers rather than end users. It is already used in KDE building and creating KDE's many packages such as on Windows. Having tracked down dependencies and having to compile several projects from source for a single app to compile I see the value in this project. Having a consistent and cross platform system on Windows, Linux, MacOS and FreeBSD makes this a compelling tool for projects with complex dependencies or cross platform apps.
[removed]
QML/QtQuick. Specialized language is better for making the skin of the GUI (application logic is still in C++). Also, QtQuick uses GPU-accelerated vector graphics where possible.
Can confirm. [Metonymy](https://en.wikipedia.org/wiki/Metonymy) is valid, and STL maintainers have the sovereign right to name what they work on.
They went out of business, and their repository is pretty clearly inactive.
My suggestion is to bite the bullet, and use [Catch](https://github.com/philsquared/Catch/releases/tag/v.1.7.0), regardless of how much it may differ from your existing notions of how limited testing tools might be. 
So if you need a hash map, a dynamic array or a string you just write [your own](https://en.wikipedia.org/wiki/Standard_Template_Library)? 
STL always stand for ["Standard Template Library"](http://www.sgi.com/tech/stl/) and it was the part of the language based of three pillars: iterators, containers and algorithms (+ functional now), I don't see how it can be confused with standard library (which is the general term for all C++ headers).
I was referring to which industry/scope, no problem
Most, but [not all](https://build2.org).
Because in the early days there wasn't anything like *standard library* for C++, it was basically libc plus whatever the respective C++ vendor decided to ship along, e.g. Borland shipped Turbo Vision and BCL (or whatever it was called). It was a rite of passage to write our own string, vector and smart pointer classes. So for many of us all those nice additions from STL into the standard library, made us keep referring to everything beyond libc as STL, even if it isn't correct any longer.
It's 2017. It's time to stop nitpicking about that distinction.
Biicode is not active anymore. Use Conan instead, it's way better and very active
Ignoring it is a punishable offense on stackoverflow :)
&gt; &gt; I personally really like meson conceptually, premake5 practically, and build2 culturally. &gt; Could you elaborate on that? Meson and its high-level design resonates with my particular engineering sensibilities so I like it conceptually. It's a loose facsimile of what I'd build if writing build systems was something I was passionate about. It's not up to the place where I can use it yet, and I don't like the we-know-better-than-you attitude that it carries. Premake actually works _right now_ for large and interesting projects similar to the kinds of things I work on so I like it practically. Its code and architecture are a gross pile of hacks and Lua scripts that terrify me as an engineer, but at the very least its more hackable, debuggable, and extensible than the pile of wretched mistakes that is CMake. build2 has a great developer :) whose decision-making and architectural policies I can respect so I like it culturally. I don't necessarily agree with the specific decisions or architecture themselves so conceptually build2 doesn't sit well with my sensibilities, and it still needs a little more work before I could try to use it practically (mostly on Windows support and pulling out all the stops on getting the absolute fastest edit-build-test cycle that Microsoft's toolchain supports) before I could use it practically
He's probably looking for g++ for the UNIX one. Windows side depends on what they installed in the educational environment, whatever one comes with visual studio or g++/clang on whatever third party IDE they happen to like there.
The developer :) but I get where you're coming from. As I said it is a loose idea.
There's MinGW-GCC for windows, but it's not the same. You could use WINE on linux with visual studio to create a binary you could also run with WINE, but I wouldn't call that a linux binary
I'd personally say LLVM (clang, clang++), but it isn't really that smooth to get working on windows. If you are asking what the windows compiler is, it's CL.
My point is, there is a need for better education within the scientific programming community. It is hard to have sympathy when software engineers get called in after the fact to fix up code, and even trying to educate scientists how do to better next time is met with hostile resistance. 
CL.EXE is not a part of Windows, it's a part of Microsoft Visual Studio (since at least 2005). And it's not the compiler, it's just a front-end that calls the compiler for you when you use it from a console/shell/script. 
Technically it is just an escape character, right? You're simply escaping the newline.
Clang is also the name of the whole thing - see e.g. [the web site](http://clang.llvm.org/). Not the case for CL, and in particular what you said is suggestive of a common I've-only-used-the-compiler-on-machines-that-were-set-up-for-me confusion. If you're particularly poking a finger at one particular component of the thousands that from Visual Studio and calling it the compiler, maybe it should actually be the compiler? **EDIT** - Just thought - maybe you're thinking of a different (compiler-specific) meaning of "front end". Yes, Clang is the "front end" whereas LLVM is the "back end". LLVM converts from an intermediate representation to target code. Clang converts C++ to intermediate code and asks LLVM to do the rest. In this sense, a "front end" is the bit that parses and understands particular source languages. CL.EXE isn't the front end of Visual C++ in that sense. It literally has no compilation-specific logic at all, last I checked - it interprets some command-line options and farms out the work to the *real* compiler (including front end). Confession - it's a long time since I used Visual Studio in any version (the last version I used regularly was 2008) so I could be mis-remembering. 
Catch is nice, but yes Google Test is much broader. Thanks!
&gt; and I don't like the we-know-better-than-you attitude that it carries. As the main developer of Meson let me point out that yes, sometimes we have to make decisions that may seem like that. Often this is because people want to do the weirdest of things that would be very difficult to implement or would destabilise other parts that people rely on. That being said if you have any specific issues you feel are not being properly catered to, please file issues or talk to us on IRC or the mailing list.
google "ILP64"
Anybody remember way back when the KDE group used to work on kind of a neat desktop environment?
Plasma 5.9 was just released this week and they have the Frameworks 5 libraries as well as apps. This came out of the KDE windows project when they had to deal with an OS without basic package management.
You can roll your own with a bit of work. Write a smart hash. It does an adl augmented call to the free function `hash`. This first does an adl invoke of `as_tuple`, and `hash`es the result. If that fails, it directly does a `std::hash` on it. The free function `hash` is overloaded for `std` containers and on other types with begin/end available via adl, and on `std::tuple` and the like in the correct namespace. It does a good hash combine. The free function `as_tuple` is overloaded on `std::pair`. Now... Anyone who overloads `as_tuple` to hashable types is hashable. Anyone who iterates over hashable types is hashable. Next, sum types. 
This post would be true in any non-C subreddit, but only in r/cpp does it evoke feelings of heartbreak
&gt;In my opinion it's better than Qt. Why?
Is that an endorsement or a highlight of unstable build results?
Using Visual Studio 2015/2017, I use clang to build for Windows, Linux, iOS and Android. All use the same codebase, with the exception of the window class, that basically gives hooks to different parts of the os. I like ICC too, I'd like it more if it compiled for ARM (does it?)
MinGW directly uses the Win32 API. I'm not sure where the comparison with WINE is coming from. There is no POSIX emulation like there is with Cygwin.
It might not be the best but I often end up using boost unit test framework because I'm already using boost and it saves me bringing in another dependency.
He's sounds like either a philosopher or a troll
&gt; PDP-11 The PDP-11 is a series of 16-bit minicomputers... How is this related to 64 bit integers ? 
Places where one needs SEH are **exceedingly** rare (MS RPC only, I think). I would rather that, for any other SE, the compiler just lets it through and the system picks it up (sends a crash to WER). 
'The' win/unix compiler? That's either supposed to be answered with an essay, or he's an idiot.
That's a shame, though.
&gt; rather rude and condescending towards those who require huge amounts of domain specific knowledge I suspect that this might be borne out of the huge amounts of domain specific knowledge required to use C++ as well as possible. Really I think /u/3ba7b1347bfb8f304c0e is talking about people who use C++ as a C superset without using all of the language features that lessen the amount of code. I see a lot of engineers who are otherwise very competent who don't want to learn the new features that would make it easier for them in C++, so really when you know C reasonably well, like they do, every problem is solved in the way you would do so for C, even if you're supposedly working in C++. I also see a lot of criticism levied at software developers who use C++ in this way too. I've seen this happen in the python community as well, but because the language is nearly magic, this sort of non-idiomatic coding isn't *quite* so much of an issue. I've not seen so much of the rudeness you're talking about myself, at least not on this sub, when I've seen code posted for review, I most often see very concrete advice about what needs to be done to improve the code... Though, to be honest, the most that I ask for from the libraries I use is that the classes follow RAII and have template functions instead of the sort of old C stuff like `sinf` `sinl`.
Is that an industry? Or is it a single shared project? Not that it isn't also true for the BSD kernels, afaik.
Most people seem to use recursion when the are trying to implement similar functionality. But recursion is inefficient, template instantiations must be memoized by the compiler and when it includes run-time code, I have often seen that the resulting code was much slower. Some of the alternatives are also not easy to remember and quite tricky to get correct. Order of evaluation, the short-circuit property of logical operators as well as defaults are something to pay attention to. That said, recursion can be avoided *most* of the time, but this is even more tricky. If you want to emulate the compile-time sum of several values, which is easy with a fold-expression, how would you do that without? I found solutions to this and several other problems in the past and I have a library where I collected the results: https://github.com/taocpp/sequences I also gave a talk in the C++ User Group in Aachen about it, you can download the slides here: https://github.com/taocpp/tuple/blob/master/Variadic%20Templates.pdf (slides 20ff show some versions of an `is_all` template)
It's not a big loss, you just need to add the default *you* want explicitly, e.g., `( 0 + ... + args )`.
Those are some amazing examples! Thank you for showing me the true power of fold expressions in C++.
Yes, that one, though I've no idea why you would link to MKL docs. As shown [here](https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models), the notable point is that `int` and `long` are 64-bit types.
how good it is on windows?
It was originally designed for windows so it is good. 
&gt;The PDP-11 is a series of 16-bit minicomputers... Ah, you're right. The PDP-10 is the bizarre 36 bit thing. &gt;How is this related to 64 bit integers ? Not 64 bit integers, 36 bit ones :). (They'd give the same answer in this example)
Catch doesn't support value or type parameterized tests.
Wow, lots of confusion on this thread. Let me see if I can help a little bit. First, I didn't work on this particular hotfix. But I used to work on the optimizer team and I know how these things go. This update contains fixes that were made to the compiler optimizer (the "back end", c2.dll) after VS 2015 Update 3 was shipped. The fixes were automatically included in VS 2017 compiler drops, but they were deemed to be sufficiently important to individually back-port to VS 2015 U3. "Sufficiently important" can mean a lot of things, ranging from "wow, that's a bad bug" to "Super HugeCo, Inc. needs this fix now." The hotfix should only be installed over VS 2015 U3, but as Billy mentions, there are technical limitations to what we can do here. If you want to install this over Update 2 it will probably install fine. And then your product is in an untested state. I would guess that installing U3 then re-applying the hotfix would be enough to get you in a good state, but that's just an educated guess. It all depends on what binaries are in the hotfix. All compilers have bugs. If you want to pretend your compiler of choice doesn't, then good for you. But trust me--there are bugs. These fixes are present in the compiler that we're shipping in VS 2017 RCs, so they are tested just as heavily as the rest of our code. This means building Windows, as mentioned, but also building tons of other code from Microsoft and other sources. We have a real-world code test suite that builds a ton of OSS projects. And as a former optimizer tester, I can tell you it's the best job in the business. Writing bad code for a living is a ton of fun. If you are using VS 2015, you should upgrade to VS 2017. It has the same major revision of the compiler toolset so it's effectively the same as "VS 2015 Update 4". (Note: a VS 2015 Update 4 might happen but I know no plans for one.) If you can't upgrade to VS 2017, make sure you're using Update 3 and this hotfix. The VC++ 2015 Build Tools were not republished with this set of fixes, nor with the last set of fixes. I'll take the blame for that personally. Sorry. The VC++ 2015 Build Tools were kind of a one-off hack that allowed you to install just the compiler tools. They required a ton of special, one-off engineering work. With VS 2017 you can install just the compiler tools from the normal setup. This means the technology that let us build the 2015 Build Tools is orphaned, and orphaned stuff is hard to maintain. We're working on fixing it. (One possible solution would be to let you install the 2015 Build Tools using the 2017 installer but we haven't figured everything out quite yet.) I know of no problems with CUDA and VS 2017 compilers. We've been sharing early drops of VS 2017 with NVidia before each release because we don't want to break CUDA. And yes, Windows 10 builds with the current compilers. There is some latency between the bits that we build on the VC++ team and the bits that Windows uses, but the latency is on the order of weeks. Office also builds with current compilers. Most of Microsoft's code builds with current compilers, though there are those teams that insist on using VS 2013 because they're insane and hate using modern compilers. 
I just checked it, and it does. Casting the result to void seems to fix it though.
Maybe i don't understand enough about the Qt memory management, but doesn't that leak memory ever so slightly ? Nice minimal example in any case !
ILP64 means that `int` is a 64-bit type 
Compiler enforcement of proper usage via type safety is incredibly valuable. 
constructor is expecting only two arguments: HighInterestChecking(string name, double initialBalance); and you are passing 3: HighInterestSavings("Susan", 10210, 2000)
indeed, QMainWindow should have been allocated on the stack or have the QApplication as a parent to have zero leaks
Yeah. `std::variant` may not be as elegant as pattern matching on a value of some variant type in Scala, Haskell, ML, Rust, etc. but they're **so** helpful for writing day to day code, especially state machines. We should want the compiler to help us!
A compile error is better than a linker error, is better than a crash, is better than strange behaviour. And a union bug will be strange behaviour. 
I wrote a very simple state machine using variant for a tokenizer: https://github.com/amaiorano/TinyCompiler/blob/master/src/main.cpp#L17 It makes use of a match function I wrote because I don't really like the 'constexpr if' way of matching on variants: https://github.com/amaiorano/TinyCompiler/blob/master/src/variant_match.h 
I have a bit of a knee-jerk reaction to C-with-classes because I made that exact same mistake on my own. :) Bad C++ actually drove me away from the language for years and it wasn't until I was tackling a non-trivial project in C and had implemented a fairly complete object system in it that I realized that C++ had all this stuff built-in, making it far cleaner. I can support learning *some* C first because going total by-the-book OOP with C++ *also* results in some pretty horrendous code. The phrase "hell is other people's code" is especially true in C++. I don't know where I'm going with this. I cut my teeth on C and it will always have a fond place in my heart.
"We should stop conflating function objects and functors because ideas from category theory are actually useful for manipulating types in C++" https://www.youtube.com/watch?v=FopyRHHlt3M
While the name is arguably imprecise the history attached to the terminology is not. Changing it will fragment the discussion by dividing posterity.
I would really love to hear more about other stuff than debating on how to call or not Functors. I think important themes for 2017 are secure coding, design patterns with C++17 facilities, more on techniques than on 'grammatical' themes. That's what we need.
Absolutely not! We totally need to discuss the meaning behind a label! I have that thing making difficult to map labels to concepts. Enjoy the collision. :P
Clang with libc++ optimizes the entire test away: https://godbolt.org/g/kQuNlv EDIT: Clang trunk doesn't accept that test case when using libstdc++ trunk and GCC trunk doesn't accept it w/ libc++, so I can't compare libc++ vs libstdc++ :-S. 
I see catch supports fixtures, but can it also support parameterised and templated tests using fixtures? As a current `gtest` user, I make extensive use of parameterised tests (`TEST_P`) and templated tests (`TEST_F`), and so I'd need both of them to work to switch to Catch. And the icing on the cake would be templated and parameterised tests together, which `gtest` doesn't do. Is any of this supported? I had a look over the reference, but didn't see any examples.
Just enter your e-mail address here: http://cpplang.diegostamigni.com/
oh sorry I thought you meant the same answer as 32 bit integers, not as 64 integers, nevermind =__=
Ship the required dlls with your application (copy them to the same directory as your .exe). To have a program run in the background, use WinMain and don't create a window.
https://media.giphy.com/media/dQpqNUOM3cDcI/giphy.gif
And that as_tuple could also be used to create comparison operators.
[Here](http://blog.regehr.org/archives/1450) is a good overview of LLVM testing by John Regehr (and I recommend his blog in general). 
You can statically link the c and C++ libraries making them part of your executable. You can also use a program called dependency walker to see what .DLL files your .exe depends on.
Your post has been automatically removed because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/5s8gqf/help_with_queues/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
If you truly dislike ASIO, you'd rather have a GC, and you cannot get over a name convention (co_... -- introduced due to backwards compatibility), I don't want to be rude but it looks like C++ is the wrong language for your preferences at this point in time. There is a lot of options out there that give you a reasonable performance and are stylistic more homogenous. I understand you find those things stylistic bad but I assure you they look bad for a good reason (performance, compatibility and the like). I'm also not saying there is not room for improvements in legibility in C++. Certainly there is, and a lot of work is being done in that direction (lambda, structured binding, concepts...). If your project allows you having some time to learn, I invite you to try C++ and either ASIO or POCO. Over time you're going to see the benefits of the GC-free (deterministic) programming and how much control it gives to you instead of a black box runtime (or VM). Otherwise, the alternatives can give you a head start in getting things done, but you may need to revisit C++ when performance becomes an issue. Best of luck in your search!
Thanks for this i'll definitly take a look. (Why people are hating Qt ?)
At this moment it does not and future plans at this moment are very hazy, so I can't say if it will.
Shifting away from the term functor replaces that void with category theory. This is a good thing as it promotes a shift in the way we think about and write C++. 
I second that ! We can approve. I think the reason for the lack of documentation is that c++ has been around since a time when the documentation standards were much lower. Documentation was nearly always read through books lack of internet ;). I think it is improving though, some new libraries have very good documentation. 
Qt kinda makes using modern C++ a bit difficult. It has a memory model which isn't compatible AFAIK with the STL smart pointers. I used to advocate for it, but then I tried using it again. I like the apps that come out, but I don't like the feeling I have while writing code for Qt. You could try [Nana](http://nanapro.org/en-us/), which looks nice to me, and I haven't seen any OSX users complaining about it's cross platform gui yet.
`shared_ptr` has a converting constructor from `unique_ptr`, so it's too bad libraries are returning `shared_ptr` when a `unique_ptr` would suffice. And don't get me wrong, I very rarely use `shared_ptr`. It is usually the wrong choice for a problem, but it's overused because it's easier to understand than `unique_ptr`. I'd also point out that Asio in no way mandates the use of `shared_ptr`. It's entirely possible to write code using Asio that doesn't use them at all. Admittedly, it would be easier if Handlers didn't have to be copy constructible and just needed to be moveable, but I'm sure the library will get there.
&gt; I also gave a talk in the C++ User Group in Aachen First time I found somebody mentioning this user group. Are people (students) welcome to join and just listen to talks? I don't think I have much to contribute but I like reading/hearing from people doing cool things with the language.
Note that constructing `shared_ptr` from `unique_ptr` is less efficient than getting something constructed with `make_shared`. A library returning smart pointers should have both forms if it wants maximum efficiency.
To be sure i know all the possibilities before starting something is Java GUI an option too ?
it's not too hard to set up a local socket between a java frontend and a c++ backend - then you can just use the socket stream to tell the gui what to render instead of dealing with JNI
The reason that you need the dlls is because of the linkage. I'll try to keep this brief, but really you should read up on static/dynamic linkage and how it works. Basically, static linkage means that the code that your code is reliant on is packaged directly into the .exe, and dynamic linkage means that the dll's that have the code your application needs should be packaged alongside your application. Your application is built using Visual Studio 2013. Unless you change some of the linker options, you are going to be using dynamic linkage to Microsofts C++ runtimes. Microsoft has created a set of runtime libraries that are specific to that particular compiler. For you, they have been installed when you installed your compiler, but the reason it doesn't work on other computers is because they don't have those dlls installed. Thankfully, Microsoft provides VC++ runtimes for every version so even if another computer doesn't have the compiler, they can just install the relevant runtime package and applications built using them should run. The link to the 2013 runtimes are here: https://www.microsoft.com/en-au/download/details.aspx?id=40784 You can either supply this link directly to whoever needs your application, or you can grab the existing copy of the runtime installer which should be in your program files where Visual Studio is installed with the name vcredist_x86 or something similar.
The boost.asynchronous library is already here... the fact that it is not standardized doesn't mean you can't use it. By the way, I believe that it's boost.asio that has been proposed (it's actually a TS).
&gt; t I would be happier using some lib that enables me to avoid shared_ptr (by using coroutines) How would coroutines help in avoiding shared_ptr more than asio ? and why do you use shared_ptr with asio ?
If you can go with c++14 the needs of shared_ptr are greatly reduced because you can use a unique_ptr instead and move it in a lambda. But I suggest you to try boost.asio + boost.fiber, the resulting code is very beautiful; usually you can forget about unique/shared pointers and keep your buffers on the stack of the user thread.
get a book.
Uh... seriously, don't do this.
rvalue reference to what? If it's an object that can be passed by value (i.e. copied or moved), it should be returned by value. If it can't be passed by value, then you're talking about dynamically allocating an object, returning a reference to it, and expecting a user to take its address and give ownership of that to a smart pointer (!). Which is still less efficient than make_shared. You cannot return an rvalue reference to a local variable.
Absolutely, it's interesting though, and helps understand vtables ;)
&gt; mocking libraries For test code it's *ok* - not in production.
Let me rephrase my question: Assuming that the value in question is stored directly in a local variable (instead of inside a smart pointer), why would someone want to return a unique_ptr instead of the value itself?
Is not nginx's http2 library written with asio?
&gt; What really annoys me about Rust ist that the language is built on great concepts but they had to invent new names for existing constructs or use names that mean completely different things in other, more common languages I suggest you never watch Jon Blow's videos then :D
Returning the value would be ideal in that case. Smart pointers are needed when working with polymorphic or otherwise noncopyable objects.
This will also result in segfault on MSVC x86 target (not amd64) because of the __thiscall calling convention (this pointer will be transferred using ecx). Nice work tho! Dangerous, but nice. 
This is a very good question - but let me ask you first - do you want step by step guide of language features or documentation that covers language in depth but not every angle, or full blown encyclopedia? If it's the latter then there is C++11/14 almost final drafts are available online for free, and final drafts are available for a reasonable price. If former than I agree with you, but creation of such tutorial would be incredibly hard because C++ has so many "languages inside". It definitely doable, but than comes the question - who will support it and how? Keep in mind that we have several compilers with different feature support and their own extensions. And than we need to talk about build process and build systems. IMHO C++ need this kind of tutorial. But before that, we should agree on "C++ that can be taught in reasonable time using online manual and still give insides of why, after all complexity, is worth learning")
I mean that it's easier to use sockets than jni, and I've seen a lot of companies that write c++ backends with java swing or javafx frontends. Not to say that it's better than using c++ natively but it can be done
thx! I'll look into various compilers when I have more spare time :)
Do you have an example of this? I recently wrote some ASIO code and also didn't like all the callbacks. 
Do you think that libraries grow on trees? They're made by people with varying motivations and skill levels (at programming and documenting, separately). (Trees grow in libraries, though.)
Yes, but given *how* the poster asked I thought that would have been too much for them. People who said "link statically" probably gave an even better reply :-)
Some of these libraries, like GPK and GMP (both GNU libraries) are documented very differently. One has a nice PDF guide online and explains how you are supposed to use it and the other just gives you a bunch of flags (see the AES section). You would think that something so similar (a big number and an encryption library) from the same organization would be similar in documentation styles. And both of the libs are great, but the documentation just isn't there.
On x64 there is a single calling convention on windows (and an extension called vectorcall that uses more FP and SIMD registers). Iirc there are no special rules for the 'this' pointer so I assume it should be handled as a hidden first argument, which would mean it is passed through the RCX register.
Is that really surprising? Finding a good documentation is like trying to catch Mew.
seems to me its very similar to the impossibly fast delegates article https://www.codeproject.com/articles/11015/the-impossibly-fast-c-delegates 
https://github.com/libuv/libuv
libuv is nice, but lacks SSL support and wiring in C++ member functions is a pain.
And still, finding a good documentation is nothing on having to write one.
Your post has been automatically removed because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/5sdmd2/need_some_help_on_a_very_basic_task/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; The Child class is overloading the print() method. The Child class is overriding the print() member function.
Everybody is welcomed, student, professional, hobby, or just curious. Last time we've been almost 50 people with varying backgrounds and personally, I'm always happy I made the trip from Bonn to Aachen for it! If you are interested, more information (in German) is usually at Detlef's page: http://www.wilkening-online.de/programmieren/c++-treffen-aachen.html
A welcome addition to cmake! I wonder how hard it would be to integrate this with gdb or lldb?
This is especially good advice IMO if you want to read something like (and I recommend you do read these) Scott Meyers' books Effective C++ and Effective Modern C++. They're worth a read-through just to know what's there. If I'm not _practicing_ what I'm reading about, I'm never going to remember it exactly. It won't really stick. But when I get around to needing it I _will_ remember (in the back of my head) that it's there for me to go reference.
I hope we'll get more pragmatic Modern C++ books. Or maybe you know some recent ones?
The top google search for "Add employee Delete Employee Search Employee c++" is what you're looking for. When you want people to do your homework for you, you're better off in https://www.reddit.com/r/cpp_questions/
I don't know any recent ones, but the Meyers books (at least those two) are still very good. It sucks Meyers retired. [Jason Turner's C++ Weekly videos](https://www.youtube.com/user/lefticus1/featured) have been great, though I'm pretty far behind on them. I think they usually get posted to this subreddit.
2017's IDE works just about as well as the bug tracker (i.e completely falls apart as soon as you try to use it). For a quick informal bug report: try pressing "Show All Files" in the solution explorer and the entire UI will catch fire (unless this was fixed in the latest update, I can't check right now), and then you have to restart it all which can take forever. That's basically how the entire IDE feels, but at least it doesn't lock up in insane fashions like 2015 would.
Same could be said about most languages. Perl syntax, Haskell paradigms, general PHP/JavaScript mess, etc. So I guess it's sanity/programming: pick one
I think there are two reasons: 1) It takes time. 2) There is no good way of writing it. The first problem is pretty straight forward: Writing *good* documentation takes time. We are not speaking about running Doxygen and adding some bullsh*t descriptions like documenting a parameter `const std::string&amp; name`as something brilliant as "A string representing the name" (I've seen this kind of documentation too often). We are talking about real documentation which explains concepts, good examples, a reference section, ... From my experience with our PEGTL, it took about 1/3rd of the time just to write the documentation. I/we have other libraries in the pipeline, but some are not tagged as a release or announced officially since there is no documentation yet. Now for the *second* problem: How do you write documentation? Some people want online documentation. Which makes sense *iff* is contains links. It is therefore *not* just a collection of text and formatting. Others want to print the documentation, so you'd like to generate a PDF from it. I've tried several different systems in the past, including MarkDown (GitHub), Sphinx (ReStructured Text), TeX/LaTeX (and pdflatex) or simply a text document (OpenOffice, Pages). Nothing ever convinced me. I'd like to have the source of the documentation somewhat readable and part of my repository. I'd like to generate an online HTML-version which can be viewed and searched offline (like with Sphinx). I'd like to generate a PDF version of the documentation. So far, Sphinx worked OK but there are several pain points still: * Tables. Tables suck and looking at the PDF, they are often simply cut off. I need way more control over tables. * Where are other diagrams, message sequence charts, ...? * Formatting text is too limited. Look at `cppreference.com` (Wiki-based) and see what would be necessary to document an API properly. (And then look at all the machinery behind it.) * When I commit something to the source, it should be visible directly (one of the major advantages of having MarkDown-files on GitHub). I guess when the second problem could be solved, it might even help that more people would actually write good documentation but as it stands now, writing good documentation is hard even if you know what you want to write and how you'd like to show/explain it to your users.
In my limited experience with c++ (like 30k lines max in my project), having the smart pointers really cuts out a chunk of what used to cause problems. Combined with dynamic casting, a lot of the stuff I was initially hit with improved quite a bit. There's not as many libraries out there as like Python or something, but it's pretty straightforward.
There's a lot safer way to do this. If your callback takes a void* "context" parameter, you can pass a pointer to your object of interest there. Your callback function can then cast the void* to an appropriate type and make the call there. struct Base { virtual void do_it(); }; struct Derived : public Base { void do_it() override; }; void Base_doit_callback(void *context) { static_cast&lt;Base*&gt;(context)-&gt;do_it(); } void (*callback)(void*) = &amp;Base_doit_callback; You can also use a lambda... void (*callback2)(void*) = [](void *context) { static_cast&lt;Base*&gt;(context)-&gt;do_it(); };
 Fucking pop-up 
Can you link a few?
How can an author typo the title and not notice?
Slides (PDF): http://yowconference.com.au/slides/yow2016/Montgomery-CPlusPlusOldDogNewTricks.pdf
The reason we are using Slack is not for Slack but for the C++ community that is there. We'd consider something else if there was an existing C++ community to tap into.
Its unfortunate there isnt a fixed size version of valarray or it would be good to implement things like Vector3f with
Yes, a chunk of Boost has got into the standard.
&gt; If your callback takes a void* "context" parameter And any **good** C API that takes callbacks should support this otherwise they're encouraging the use of global state.
FWIW, Rust enums existed before C++ std::variant did. And when you think about it, they're just a generalization of C or C++ style enums (any C or C++ enum or enum class can be implemented as a Rust enum, but not vice versa). I don't see anything wrong with the name; most other mainstream languages with similar concepts had previously just called them something like "data" or "datatype" (Haskell, ML). Having separate `enum` and `variant` kinds of types would be quite un-orthogonal. What other examples do you have?
Templates and macros are very different. Macros work on a textual level and know absolutely nothing about the type system (they can barely match parentheses). Templates fully respect the type system. The issue is that in C++98-17, there is no meta-type-system (i.e. concepts) to detect template errors before instantiation. The Concepts TS will permit usage to be checked before instantiation (although definition checking is currently out of scope; not a terrible loss as library writers already need to be highly skilled). &gt; after a bunch of template and macro expansion Templates don't trigger any macro expansion. &gt; You can already see that even for this primitive type we have a nested template, since for a container type T there's a default allocator type called std::allocator&lt;T&gt; which is itself a template. Calling this a "nested template" is not really accurate. &gt; Most of the types have the exact same implementation, but the compiler has to regenerate the code each time anyway. No, they aren't the "exact same". This is the key insight - in general, different vector instantiations result in completely different machine code. A vector&lt;int&gt; will say "copy these chunks of 4 bytes over here, with memmove". A vector&lt;long long&gt; will say "copy these chunks of 8 bytes over here, with memmove". A vector&lt;unique_ptr&gt; will say "call move constructors to move these elements over here", and so forth. Radically different machine code is emitted depending on the types in question. (There are a few things that will result in identical machine code, e.g. vector&lt;int&gt; and vector&lt;long&gt; on LLP64 systems, vector&lt;X *&gt;, etc.) &gt; Short, common methods like front() may be declared "inline". In this case the compiler not only has to not only expand the template hundreds of times for all of the different container types used, the compiler also has to expand and optimize the inline method definitions at every call site! No, this is completely incorrect. In C++, the `inline` keyword (whether explicitly written, or implicitly written by defining a member function within a class definition) activates the partial ODR exemption (which templates also activate, so no difference there) and serves as a **hint** to the compiler, "you might want to actually-inline this". It is an advisory, non-binding hint. Compilers can and will ignore it (most obviously, in non-optimized compilations, no inlining will be performed, but they also consider the call graph, profile-guided optimization, etc.). Compilers can also actually-inline stuff that hasn't been marked `inline`, even (with LTCG/LTO) functions in different translation units that aren't header-only.
When i see posts like this I imagine the speaker is Spock talking to McCoy on the original StarTrek. Good information, but there was likely a friendlier and less verbose version of this material.
Hi, not sarcasm. What is this for? What problem is it solving?
OK, thanks for the info. So if not self-building tip-of-trunk for the time being, could MS at least provide latest release versions (3.9 now, 4.0 soon) in the form of updates? (bit like how you track gcc releases in your Nuwen distro). 
I found Peter Gottschling's [*Discovering Modern C++*](https://www.amazon.com/Discovering-Modern-Scientists-Programmers-Depth/dp/0134383583/ref=sr_1_12?s=books&amp;ie=UTF8&amp;qid=1486413045&amp;sr=1-12&amp;keywords=C%2B%2B) to be a very pragmatic introduction to C++11/14 features.
boost::variant probably existed before Rust enums and I think the term is not only used in C++. Regardless I just think that enum is not the most intuitive choice. But you're right that wrapping the functionality up makes sense from the type theory standpoint. To be honest I didn't dig that deep when reading about Rust but two other examples are Box and Crate.
Thanks! I'll stop by next semester when I'm back in Aachen.
Its a fair question. For the great majority of CMake users, and people just using cmake packages maintained by someone else, it doesn't solve a problem. But if you are the one creating a CMake package, and in particular if you are dealing with custom dependencies trying to make it work on a wide variety of platforms, you end up with a decently complicated CMake script. Traditionally you debug this via MESSAGE -- the cmake equivalent of printf debugging. That is sort of a kludge though and not always clear. The idea isn't that you'd have to go out of your way to install the debug tools like you do with this prototype, but instead that they'd be integrated into whichever IDE you are in already. A variety of IDEs (CLion, QT, KDev) already have integrated cmake support, so ideally it would be as easy as throwing a breakpoint where you wanted in your cmake file and it would pop up in the debug interface you are familiar with. 
Careful, you speak not to a mere mortal but to Stephan T. Lavavej! :o
I've been working with Asio for several years now. I'm familiar with the examples, my own library, and also a few other open source libraries built on Asio. Nowhere have I seen any signs of a "garbage collector." Perhaps I'm not looking in the right place, do you know of any projects on GitHub that use Asio and have garbage collectors that I might inspect to become better informed?
Such things are always better off when done properly than quickly. :D
Hopefully Qt Widgets will be one of these native backends. Because the embedded controls were implemented as Qt Quick Controls 2 rather than Qt Quick Controls for Embedded, the earlier, native-looking Qt Quick Controls seem to be neglected.
Dumb question: are any of these STL fixes being backported to VS 2015?
"Coming soon" is the most I can say at this time. The release date hasn't been publicly announced yet, so I can't give hints.
Ah that's cool, I thought I had missed it is all :) 
No, we're done with 2015. However, we're guaranteeing that 2017 is binary-compatible (we're working in the same branch, following the same rules, as we did for 2015 Updates). At some point we will break bincompat again (possibly with a distinct toolset that can be selected), but 2017 RTM/Updates will preserve it.
The arm GCC toolchain supports both filesystems and &lt;type_traits&gt;, at least for the microcontrollers I work and have worked with (ARM Cortex M4 ATM). Are you programming Z80 or something?
I heard about the lack of expertise on WG21 from more than 1 source... :( But then again you may just be bitter since Boost rejected you: https://www.reddit.com/r/cpp/comments/3i3buq/afio_library_formal_review_in_boost/ Anyway thank you for your opinion. As for sync like I said I know I can use that, I was looking for similar perf code that is easier to write.
well shared_ptr is poor man's GC. :) // waiting for somebody who will in caps lock write: shared_ptr is DETERMINIIIIISTIC UNLIKE GC!!!!!
&gt; Are you programming Z80 or something? not far, AVR with avr-gcc :p
I'm using CMake to generate some [boilerplate code](https://github.com/OSSIA/i-score/blob/master/CMake/IScoreFunctions.cmake#L61) in my project, I remember praying the gods for any kind of debugging feature when writing this.
Alright so, basically its pretty simple. I use instancing of meshes for most of the gui, for everything else including text, I use sdf. Similiar to this https://www.shadertoy.com/view/4dfXDn
So Qt controls are not native? I always suspected they weren't from seeing how they look but I was never sure because clearly I have seen statements claiming that Qt uses native controls. It seems now they want to do what [wxWidgtes] (http://www.wxwidgets.org/) has always been doing.
can somebody translate this to mere mortal? "* basic_string move construction, move assignment, and swap performance was tripled by making them branchless in the common case that Traits is std::char_traits and the allocator pointer type is not a fancy pointer. We move/swap the representation rather than the individual basic_string data members." Sounds like memcopy, but you can not do that (for example because of SSO). Also idk what fancy pointer means in this context. :D
We can memcpy bits around because we know how we've implemented the SSO. Fancy pointers are class types pretending to be pointers. Allocators can return fancy pointers when allocating memory. However, fancy pointers are extremely obscure and 99.99% of C++ programmers don't need to worry about them.
I don't get the downvotes. Lame jokes are always welcome, imo.
not too much, the only thing interested me is constexpr-if.
&gt; a wrapper around sockets and select/kqueue/epoll IOCP too iirc.
ah, this is that thing that folly vector fixes by giving types a type trait folly::IsRelocatable? 
It's not native for the good. You have full control of what's going on, nothing is hidden behind a OS layer. This being said, it is still possible to embed native controls, if one needs. But this is a control by control approach, to be used for specific controls.
&gt; We can memcpy bits around because we know how we've implemented the SSO. http://www.gotfuturama.com/Multimedia/EpisodeSounds/3ACV18/17.mp3 :)
Live long and prosper!
"Fancy pointers" are things that "behave" like pointers (i.e, provide `operator-&gt;()`) but "aren't pointers", in the sense that they don't store an underlying raw pointer. An example would be `offset_ptr` from Boost.Interprocess: it doesn't store an address, but an offset from its own (so you can't trivially move / copy it, because its value depends on its location in memory).
&gt; Ack! If your library calls std::terminate out from under me, I will come after you with a pitchfork. Throw an exception here. Just a nitpick -- throwing exception from destructor [is not a recommended practice.](https://isocpp.org/wiki/faq/exceptions#dtors-shouldnt-throw) 
thanks for your work !
I am a bit worried about the vector noexcept move changes. Suppose we have a large code base with move, but without noexcept marking up of move (as it was not supported/did nothing useful for a long time). How would you recommend we move forward? Any ideas on how to detect a move assign/construct that should be marked noexcept but isn't? Falling back on copy could break the application, instead of a weak exception guarantee move. We don't need the strong exception guarantee (wouldn't mind it; but don't want it at the cost of terminate on any exception). 
&gt; MPI_RAII [ES.9: Avoid ALL_CAPS names](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es9-avoid-all_caps-names) &gt; std::terminate Even better is to add error handler that can be selected by the user, so it can call terminate or throw exception or log and then terminator or something else. 
Lambdas are basically just function objects but in practice allow to do more, much easier. 
because now I also have to tell my users to install python when they want to compile my program, and on windows they also have to set the path, etc, which is a damn pain in the ass &amp; much bigger than just telling them to install cmake (which they will need anyway). On linux I would have to take care of distros for which /usr/bin/python means python2 or python3 I just don't want to add another point of failure.
SVG is not very lightweight, by nature. Have you thought about pre-rasterizing your resources into pngs? What made you eschew from Qt? What's your limit on size?
As for the ps, look for 'awesome * curated list', for instance http://fffaraz.github.io/awesome-cpp/
I can't, because i want the glyphs to dynamically adapt to widget/screen size. I'm caching them rasterized, in memory, so it's not that expensive. Qt is too big and i won't use all of it. So it doesn't make sense for me to increase the complexity of my build script, increase my build time and reduce platform compatibility just because i want to use 20% of a GUI library.
It's http://gcc.godbolt.org, a really cool website. 
I think you're right that it still requires classes implementing Handler to be Copy Constructible. Here's the documentation for handler for the current [stable release](http://think-async.com/Asio/asio-1.10.6/doc/asio/reference/Handler.html) and [development release](http://think-async.com/Asio/asio-1.11.0/doc/asio/reference/Handler.html).
If the graphics are monocoloured, look into signed-distance fields. That'll be way faster than SVG and will render sharply at any resolution.
You'll need to inspect all of your types with move constructors. I don't know of a more automated way (we don't have a compiler warning for this). We did encounter a case (in the IDE) where copying instead of moving changed behavior at runtime - the user had vector&lt;X&gt; where X owned Y remotely. Moving Xes around preserved the locations of Ys in memory, but copying them would invalidate the Ys. This is the sort of thing that's a headache because what we were doing before was wrong according to the Standard, but code could accidentally rely on that behavior. (I, for one, am not a fan of the proliferation of strong EH guarantees.)
Is [this](http://llvm.org/docs/doxygen/html/classllvm_1_1Twine.html) what you are looking for?
And it is being actively developed too. https://www.patreon.com/mattgodbolt/posts
Boost uses SGI's implementation of rope which is available for download here: http://www.sgi.com/tech/stl/download.html Documention here: http://www.sgi.com/tech/stl/Rope.html
Yes, pack expansion in a using declaration is &gt;= C++17
I'm pretty sure in the case of types where you can `memmove`/`memcpy` (primitives for one) an optimizing compiler does exactly the same thing due to the as-if rule. It also seems incorrect to do a `memcpy` for every type in Rust, but I don't know enough about the language. Can you elaborate more how backwards compatibility holds back performance?
[Fatal rope.h](https://github.com/facebook/fatal/blob/master/fatal/string/rope.h) A class used to represent a rope, that is, a sequence of string pieces that together represent a string. Provides an interface very similar to that of `std::string`. ~~[librope for C](https://github.com/josephg/librope)~~
&gt; Can I take a second to just say I always enjoy seeing your comments? Was about to post the same thing. The only thing that would made me enjoy those comments more is the expansion of acronyms. Thanks for the shared knowledge.
&gt; Qt is too big and i won't use all of it. it's split in multiple libraries, you should only need qtcore, qtgui, qtsvg. For the build script, if you're using CMake it's a matter of find_package(Qt5 COMPONENTS Svg) target_link_libraries(myapp Qt5::Svg)
No. The conformant behavior is unconditionally enabled. It's unfortunate that the Standard imposes this cost/headache regardless of whether the user actually wants the (nearly useless) strong EH guarantee, but that's the Standard we've got.
Hmm... I test `string_view` with Clang/C2. Do you have a repro?
&gt; &gt; error : cannot mangle this dependent name type yet Do you have a repro for this? I support range-v3 on Clang/C2, and I'm aware of no such bug(s).
Thanks! It's nice to hear that.
What new things make C++17 cool? I'll list some of the most notable changes: [Destructuring Assignment](https://skebanga.github.io/structured-bindings/) This is a big one, you can now easily break apart data into multiple variables auto tuple = std::make_tuple(1, 'a', 2.3); // unpack the tuple into separate variables in one go auto [ i, c, d ] = tuple; New C++17 Destructure way: auto [Username, UserAddress] = nameAndAddress(); Traditional way: auto somevalue = nameAndAddress(); auto Username = somevalue.value1; auto UserAddress = somevalue.value2; [Guaranteed Copy Elision](https://jonasdevlieghere.com/guaranteed-copy-elision/) In C++, the compiler was unofficially allowed to omit the copy constructor when passing objects, this technique has been around since C++98 and it let the compiler improve code performance since unneeded temporaries could be omitted. Now with C++17, this technique is being promoted to an official standard. [Initialization in conditional statements](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0305r1.html) A common but lesser discussed feature of C++ is declaring a variable in an if statement: if (auto value = data()) { } This would declare `value` and if `value` resolved to true, the body of the `if` would execute. This technique also had the benefit of putting the scope of `value` inside the if body, **so you'd declare, check, and run the destructor of some data all in one go**. The only downside was, **if the data couldn't be converted to boolean, then you couldn't use this technique**. But now *C++17 lets you put another expression in there to check the condition*: if (auto val = GetValue(); condition(val)) // when condition(val) is true else // when condition(val) is false This is useful because now it's easier to make the scope of variables limited to where they are actually needed; and *you don't have to make multiple temporary names in the same scope*: if (auto it = m.find(10); it != m.end()) { return it-&gt;size(); } if (auto it = m.find(8); it != m.end()) { return it-&gt;size(); } vs the old way: auto it = m.find(10); if (it != m.end()) { return it-&gt;size(); } auto it2 = m.find(8); if (it2 != m.end()) { return it2-&gt;size(); } 
SGI's rope is also [included](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/ext/rope) into libstdc++ as an extension #include &lt;ext/rope&gt;
 destructuring assignment looks like the python equivalent
I've usually used a fast per-thread pool instead of a map. The object would allocate a handle (index) in the pool, using a thread-safe global free list of indices. The pool itself is thread-local and can just be a `vector`. The accessor function will resize if the requested index is OOB. The thread-safe freelist is global (_not_ thread-local). Total space will be `number_of_thread * max_number_of_objects * sizeof(T)`. You can make the handle easy to use by making it act like a smart pointer. Accessing the `T` becomes easy and safe, and the handle can automatically acquire and return its index from/to the free list upon construction/destruction. With C++17, you can even make the pool and freelist template variables (before then, they either need to be constructor parameters or globals or static data members).
You are quite right. I didn't even think about it being a destructor. /u/remotion4d's error handler is a better idea.
After a second look (and having it pointed out that I missed the fact it's a destructor and so shouldn't be throwing...), errors from `MPI_Finalize` can be ignored because there is nothing the user can do about it. The MPI standard doesn't provide any way of recovering from this error.
Uncontested locks are actually pretty fast, can be as low as single-digit nanoseconds depending on your platform. Provided you don't have a lot of contention, locking can be just fine. For something like this consider using [readers-writer lock](https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock), e.g. [std::shared_mutex](http://en.cppreference.com/w/cpp/thread/shared_mutex). This means you have no lock contention on multiple readers, only briefly on writes, which (it sounds like) should be relatively rare. What's reasonable depends on many factors, like platform, how much churn you have, the actual number of readers vs writers, the update frequency, so like always profile it and be sure. See also: http://preshing.com/20111118/locks-arent-slow-lock-contention-is/ Of course there are always going to be more complex solutions, but you need to trade off dev time, code complexity, possible bugs, etc., so consider the most straightforward solution first, and only move on if it profiles poorly.
Couldn't you already do the assign and check in `if` using the `,` operator? 
Clutter is a semi-popular library for stuff like this, but it's C and the C++ bindings seem to lag behind the main project quite a bit.
So before upgrading, we have to sweep 100s of move constructors. Is there a practical hack we can do to get a weak exception guarantee? Ie, have the throw escape the vector code without forcing wastedul copies, and have the vectors be in an imperfect state? Noexcept move operations mean we risk sudden process termination, or (if try catch ignore) losing errors. Using copy means possibly crippling performance issues. 
Real world test case: https://twitter.com/MalwareMinigun/status/814196564507799552
With appropriate includes, VS2017 RC (today's update), using ericniebler/range-v3 (not Microsoft/Range-V3-VS2015), debug build: ranges::accumulate(ranges::view::take_exactly(ranges::view::iota(1), 3), int{}); yields &gt; range\v3\utility\counted_iterator.hpp(95,17): error : cannot mangle this template specialization type yet &gt; friend void advance(counted_iterator&lt;I, D&gt; &amp;it, iterator_difference_t&lt;I&gt; n) &gt; ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &gt; range\v3\utility\counted_iterator.hpp(95,17): error : cannot mangle this dependent name type yet &gt; friend void advance(counted_iterator&lt;I, D&gt; &amp;it, iterator_difference_t&lt;I&gt; n) &gt; ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Loads more from utility/basic_iterator.hpp in my actual code, but same errors, same workarounds: Making each friend a template itself (adding the same parameters as the class template) and modifying each return/parameter type to specify said template arguments works around the issue, but obviously is not a real solution, esp. when it comes to standard library headers.
With appropriate includes, VS2017 RC (today's update), debug build: for (auto ch : std::string_view{"foo", 3}) { } yields &gt; xstring(341,2): error : cannot mangle this dependent name type yet &gt; friend _CONSTEXPR14 _String_view_iterator&amp; _Rechecked( &gt; ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ In my actual code there are also errors for `_Unchecked` immediately below, as well as instances of the 'template specialization' error shown in [my reply to Casey](https://www.reddit.com/r/cpp/comments/5sfvfe/stl_fixes_in_vs_2017_rtm/ddgxib0/).
&gt;First a comment to explain some choices I made in the naming scheme. Naming things is the hardest part of writing code, so it usually takes a while to settle into something that makes most folks happy. &gt;About MPI_RAII, any idea for a better name? You could do what Boost does and separate into into an environment and a communicator. The problem I have with that is you have a variable hanging around that only serves as an RAII wrapper to initialize/teardown the MPI runtime. #include &lt;boost/mpi/environment.hpp&gt; #include &lt;boost/mpi/communicator.hpp&gt; #include &lt;iostream&gt; namespace mpi = boost::mpi; int main(int argc, char* argv[]) { mpi::environment env(argc, argv); // Just an RAII wrapper mpi::communicator world; std::cout &lt;&lt; "I am process " &lt;&lt; world.rank() &lt;&lt; " of " &lt;&lt; world.size() &lt;&lt; "." &lt;&lt; std::endl; } &gt;Btw, you do not need to pass argc and argv to every communicator. Creating a communicator is as simple as Communicator c. In this case, the communicator is a duplicate of MPI_COMM_WORLD, and you can split it as you want into some other communicators. That's why I suggested using tag dispatch to set the type of communicator. It would be interesting to think about how to integrate the improved communicator geometries from MPI3. &gt;About that std::terminate in the destructor. I'm very interested in knowing what to do if an error occurs in the destructor. Of course the best thing is to handle it like remotion4d suggested, or maybe in some cases ignore it as you suggested. But what if it can't be handled or ignored? All I've read is, for instance on isocpp, to do anything but to throw an exception. When I first commented, I didn't notice that was a destructor. I just saw library code calling `std::terminate` and was blinded by it. For MPI_Finalize, I would just ignore it. The general case of errors in destructors is an open problem in C++. I don't know of anyone who has a sufficient answer for all possible uses. Boost.MPI checks for `std::uncaught_exception` and calls MPI_Abort in the case the exceptions creep into the destruction of the environment object. 
No hacks are possible. Copies aren't the end of the world - code will never be slower than C++03. Just upgrade and profile, and look for new hotspots.
Try using the debugger to step through/over the open, and if you don't know how to do that just google I guess. Probably googling exactly what you posted here would get you pretty far.
X-Post referenced from [/r/matlab](http://np.reddit.com/r/matlab) by /u/Slayj [splinter - Fast multithreaded C++ library for linear, bilinear, and trilinear interpolation with MEX interface](http://np.reddit.com/r/matlab/comments/5sqgfh/splinter_fast_multithreaded_c_library_for_linear/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
You can try crazy, crazy stuff like convert the SVG to a font and display that. This would be pre-build step under "asset preparation".
Fair enough. ASIO has been used in production that I believe are quite performant. And the memory management or the lifetime of handlers, its allocation, its calling context is all customisable in ASIO. One can make use of those features to yield better performance. Between, the understanding of "high perf nw program" could vary in between two people working on different domain. So, its better to state explicitly about your performance requirements. &gt; I know that 1000 threads can handle 1000 connections This is the most absurd way to handle 1000 connections. It can be done in single-thread/single io-service without breaking a sweat.
Fairly certain you need -Wall (or the another warning flag) to actually see them though. 
I haven't used the debugger in years, so I can't really tell how good it is (however I believe that [Code::Blocks](http://codeblocks.org/features) has decent GCC+gdb support). As for the runtime (vc6), it's mostly an interface to the OS - all of the C/C++ standard libraries are implemented on top of it, so it doesn't really matter. Agree that clang is moving fast, and has some support from MS, so it's likely a good alternative.
That is very nice! But please add the LICENSE file and remove the `.DS_Store` folder and add it to `.gitignore`. The `.DS_Store` is is a OS X thing that doesn't need to be saved in the repository.
&gt; There are a lot of things I wouldn't use C++ for. Frequently, it really is too low-level. You can make a basic HTTP request in one line of Python or Go, but doing the same in C++ is not easy. The language gives you a lot of rope to hang yourself with. This is particularly problematic when you have to work on a big code base with many programmers, a lot of whom may not be language experts. It wouldn't be easy in Go or Python if they didn't have the relevant libraries as well. Let's not confuse the libraries with the language. C++ does not have an http api in its basic library, but if you use a third party api, i am sure it can also be just as easy. 
I wonder why the standard library doesn't provide something like this out-of-the-box?
Thanks for the comment. I have added an image and additional explanation the README. As for the second part, if you are talking about 3D then you are talking about trilinear interpolation. This means that you have a 3D matrix of data points with evenly spaced x,y, and z coordinates. Trilinear interpolation is a way of filling in the value of a point anywhere based upon the values of the nearest grid points (there are 8 bounding grid points total).
gcc -std=c99 -E? 
Thanks, it's much clearer! To be entirely clear, let's suppose I have a heightmap, which is terrain height for evenly spaced X,Y coordinates. If I consider "height" to be the quantity I sampled, with bilinear interpolation in splinter I could get (interpolated) terrain height for any X,Y?
Did you see an [unifdef](http://dotat.at/prog/unifdef/) tool? It seems to serve similar purpose. Update: after closer look I see that unifdef does not process `#include` directives and thus isn't suitable for your needs.
And, did you consider Boost.Wave and why you've decided against it?
There is a proposal for that: [P0051R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0051r2.pdf).
I've deployed Boost.Spirit before into projects. And it's a good tool for complex grammars and big parsers. But it also has big deficiencies, the biggest is just how painful it makes the build-debug-build cycle. It's also very steep barriers to entry for the uninitiated, sufficiently so I know a good few very able engineers who think it never worth deploying ever into any codebase because of the problems of maintenance it introduces. Finally, regarding Wave specifically, it seems to be designed as an all or nothing implementation, so I'd have to parse the inputs into an AST and serialise them back into a form very closely matching the original, but with some, but not all, the preprocessing commands passed through. That's quite a bit of extra work, in fact from past experience I know I could write a full C99 preprocessor in Python in half the time needed for me to get Wave to implement conditional pass through.
Just for you to tell me what the difference is.. I don't know too much about licenses other than recognizing some of the names. My intention was for this to be as completely open source and freely useable as possible. Is the GPL license more restrictive?
My experience with Boost.Wave: It's *slow*, like really *slow*. It also can't, for example, preprocess standard library files.
this guy gets it.
I'm not saying C++ "s***s", I'm saying that it's not strictly driven by performance considerations. `std::string` is a rather fundamental type, and the optimization you talk about cannot be applied to it, which is rather annoying. Actually, it cannot apply to `std::unique_ptr` either, even though the type leaves nothing behind (but a null-ptr), so you get N calls to the move constructor (a bitwise copy + zeroing of source) followed by N calls to the destructor (do-nothing) instead of a single `memcpy`. It cannot be optimized at the library level, and it's quite unclear whether an optimizer manages to pick it up. --- There are other examples in the design of the standard-library as well; for example the fact that an item must be stable in memory in `std::[unordered_]{map|set}` places a severe constraint on implementers, and more memory efficient (and cache-friendly) structures (B-Trees, open-addressed hash maps) cannot be immediately used to implement these collections because of it. Or the current design of hash algorithms which is sub-optimal (especially with users struggling to implement good hash functions for their types) and [could be done better](https://isocpp.org/files/papers/n3980.html).
The library maintainer should use `memmove`/`memcpy` for any type which `is_trivially_constructible` I think, so not only primitive types, but also so-called "PODs". Although that may be impossible in the presence of uninitialized padding between members. Note that in theory a compiler *could* using `memcpy` for reallocating a vector of `std::string` and "forget" to invoke the destructors on the moved-from strings, under the as-if rule. In practice, I don't see that happen. --- Regarding Rust, it hinges on two properties: - Moving is defined as a bitwise copy, cannot be overloaded/specialized, and cannot be prevented (no opt-out) - The compiler tracks move, and ensures that a moved-from value cannot be accessed (and thus will not be destructed) This results in the possibility to use `memmove` and `memcpy` extensively, but makes implementing the `Observer` pattern as shown in the GOF impossible (as the observer should notify the observed when it moves, and vice-versa). It also means that types like `pthread_mutex_t` cannot be used directly, they must instead be wrapped in a `Box` (equivalent of `std::unique_ptr`) since they should not be moved in memory after their initialization. It's a trade-off: lesser flexibility and having to box "unmoveable" types, but in exchange the vast majority of the code is more easily optimized.
Isn't Apache 2 fairly open (in the spirit of MIT/BSD)?
&gt; Well we are talking about tool for C++ developers so the best way to do it is to use C++. That's a very unusual rationale. Also, this is a *build* tool. Unless you need performance, it would be unusual to write a build tool in C++. I even considered writing this in cmake, then I slapped myself hard on the hand and put such bad thoughts into a deep hole ... &gt; Probably the best way to write compiler or preprocessor tool is to use LLVM and Clang. I also looked into this, and indeed found the page at https://mashandmish.wordpress.com/2011/06/29/building-a-standalone-preprocessor-library-with-clang-tools/ very useful. It's doable with LLVM and easier than with Wave as the AST preserves the original so it can be more easily reconstituted without having to write a full blown serialiser. It's my fallback choice if the Python approach doesn't work out. &gt; By the way ReShaper C++ has ability to preprocess single macro, this is already useful in many cases. Object macro expansion is pretty easy. Function macro expansion is a lot harder if you want C99 perfect expansion. I think I'll have to use a proper lexer for that solution, [Python's lex-yacc implemention](http://www.dabeaz.com/ply/) is very slow but lovely to program with. &gt; &gt; Is 1000x slower fast enough? &gt; No it is too slow. I invested a few hours today in speeding it up, got a 6x improvement. I very much doubt I'll ever get it better than 50x slower but as it's supposed to be part of a CI job, it's probably not a showstopper.
Nice overview, thanks ! Minor nitpick, for the last example, my old way would have been to use explicit block : {auto it = m.find(10); if (it != m.end()) { return it-&gt;size(); }} {auto it = m.find(8); if (it != m.end()) { return it-&gt;size(); }} 
Why is it considered unusual to write a build tool in C++? This makes no sense to me. C++ comes with built in regex these days, so I don't see why you would consider python any easier. Seeing as you explicitly mentioned Python's lex-yacc implementation, I will (yet again) plug my own lexer and parser generator template libraries for C++: github.com/BenHanson
&gt; Such a Python implementation will inevitably be very slow. &gt; Unless you need performance, it would be unusual to write a build tool in C++. You have contradicted yourself.
I was asking because in the Rust community it's fairly common to dual license MIT + Apache 2, and now I know why people go to the trouble of adding what I thought was a quite redundant license. Thanks!
How many times did you have to restart the IDE today?
This is /r/cpp &amp;ndash; people _here_ vote purely in accordance with their opinions, etiquette and facts be damned.
We're unable to reproduce this bug *or* the `string_view` bug above with VS2017 RC.4 and a fresh range-v3 checkout. I can't even reproduce the range-v3 bug with the "ancient" Clang/C2 version in VS2015U3. I suspect a toolchain problem.
I came here to say this, and you beat me to it! Take your upvote, you filthy bastard!
I am always fascinated by how the cpp subreddit does not seem to care about any cpp at all.
&gt; Why is it considered unusual to write a build tool in C++? This makes no sense to me. C++ comes with built in regex these days, so I don't see why you would consider python any easier. Python is **much** quicker to write in than C++. I'm surprised that's even a contentious claim round here.
i've always been of the opinion that preprocessing should be moved out of the compiler into the build system. perhaps scons or waf have need for this effort.
I thought the QtWebkit module had been deprecated? 
&gt; here's the clang.exe invocation from my msbuild logs With a bit of massaging for environmental differences - differing range-v3 path, and my VM is running VS2017RC.4 Community instead of Enterprise - [that command line](https://gist.github.com/CaseyCarter/cbb27a1cc9c7b716a171dbbed8c3cb6b) from a VS2017 X64 Native Tools prompt compiles this program: #include &lt;range/v3/numeric/accumulate.hpp&gt; #include &lt;range/v3/view/iota.hpp&gt; #include &lt;range/v3/view/take_exactly.hpp&gt; #include &lt;iostream&gt; int main() { std::cout &lt;&lt; ranges::accumulate(ranges::view::take_exactly(ranges::view::iota(1), 3), int{}) &lt;&lt; '\n'; } without diagnostics, which outputs 6 as expected. If you could devise a self-contained reproducer for this and email it to cacarter at microsoft dot com, I would really appreciate it. 
Will do, thanks Casey. :-]
The performance on mobile platforms, specially mobile, is pretty poor. :(
Know them feels bro :'(
&gt; Amalgamation into a single distributable file can easily be achieved with any kind of scripting, not necessarily a complete (and probably huge) software stack like python. For sure. And I've seen C++ libraries use all sorts of preprocessing tooling to achieve the same, everything from shell scripting to custom C++ applications written just for that library. I, personally speaking, have always wanted something which lets you switch easily between dev and release seamlessly. And I'm currently out of contract, so I have the time for once. &gt; Out of curiosity, may I ask which boost library you write/maintain? Currently none, I resigned from all my maintainerships when I had children. I am still trying to get my first library wholly written by me into Boost. I started in 2012, I am hoping later this year to succeed finally, but if not it's okay. Current expected order of submission is Outcome and BLOBStore with the latter containing internal Boost libraries AFIO v2 and KernelTest. I may, or may not, then bring AFIO v2 into Boost as its own thing, I haven't seen much user demand.
&gt; I'm not seeing how Python is much quicker to write in when you have to jump through ridiculous hoops because of inefficiencies in the runtime and bastardise your algorithms in the process. There's no hoop jumping here. Understanding how CPython works underneath, you simply write high performing code first time. Very quick. It's not dissimilar with the C++ STL, if you understand it you write high performing code first time. Many outside C++ would say, correctly, that writing in C++ involves a lot of jumping through ridiculous hoops because of inefficiencies in the runtime, bastardising your algorithms in the process. Eric's STL v2 proposal looks to be a big improvement there, but we could still do a lot more with the STL containers which are far too keen on calling malloc and traversing linked lists, and better designed containers wouldn't be so inefficient.
Why would you use the C preprocessor on C++ code? 
Post-modern C++ is where it is at. Search #PostModernCpp on twitter. :-)
You sweet summer child. 10 million+ loc, 10s of thousands of underprofiled code paths, a dozen developers. A compiler upgrade that makes code unboundedly slower anywhere vector is used... We won't be in a rush to upgrade. Oh well. Maybe we can hack the old vector into 2017. Thanks anyhow. But this is gonna be a pain.
I ran into Delphi just over the weekend. I was looking for a library to unpack the old Unreal games data format so I could turn them into something a bit more modern more easily. [The only library I found was written in Delphi](http://www.acordero.org/projects/unreal-tournament-package-delphi-library/) :(
Do you have any links to any papers discussing this?
right, didn't think of using a counter instead of the class pointer - that actually makes it a lot simpler. It doesn't really reclaim the memory of a type T but it does prevent the storage from ever using more than it needs at peak load (where peak load is the number of instances of the class) and that's actually pretty close to good enough. I'm still going to stick with a map since it still makes the memory load a bit easier (only the classes that are accessed are inserted into a thread-local map, as opposed to a vector which has cardinality of the highest index acquired by a class that used it). Here's what I came up with: template &lt;typename OWNER, typename T&gt; class tlcl{ public: tlcl(){ std::lock_guard&lt;std::mutex&gt; lock(_m); if (!_available.empty()){ _mycounter = _available.front(); _available.pop(); } else{ _mycounter = _counter.fetch_add(1); } } virtual ~tlcl(){ std::lock_guard&lt;std::mutex&gt; lock(_m); _available.push(_mycounter); } T&amp; get_tlcl(){ thread_local std::map&lt;size_t, T&gt; map; return map[_mycounter]; } private: size_t _mycounter; static std::atomic&lt;size_t&gt; _counter; static std::queue&lt;size_t&gt; _available; static std::mutex _m; }; template &lt;typename OWNER, typename T&gt; std::atomic&lt;size_t&gt; tlcl&lt;OWNER, T&gt;::_counter = 0; template &lt;typename OWNER, typename T&gt; std::queue&lt;size_t&gt; tlcl&lt;OWNER, T&gt;::_available; template &lt;typename OWNER, typename T&gt; std::mutex tlcl&lt;OWNER, T&gt;::_m;
Speak for yourself. I want to learn all about the one true Variable in the wonderful language of CPlusPlus.
Jesus, just stop it with these garbage posts. You're not doing yourself any good.
[Did you even try](https://wiki.libsdl.org/FrontPage)?
Hasn't heard of SDL, can't use Google, but has been developing on game engines for 5 or 6 years. 
Boost Hana for one
Indeed. One of the nice things about it is that it also documents (eg its travis.yaml and CMakeList.txt config) how to set up a modern toolchain and build environment using the latest compilers.
As we would say in French: Au bûcher !
wow.. welcome to the echo chamber.
You could take a look at [`build2`](https://git.build2.org). It is a C++ build toolchain written in C++14 (GCC 4.9+, CLang 3.5+, VC14U3+). &amp;nbsp; One nice property of this project, from the "modern C++" perspective, is that it is not "C++ for C++" (i.e., libraries that do something fancy in modern C++). Rather it is a bunch of program that do something useful (build/test/package software) outside of the language itself. 
There is a linux command line tool called "highlight" which generates HTML or other output formats of syntax-highlighted source code of various programming languages. Another alternative would be "pygments", hope that helps :-)
Let's simply say that this individual (whose real name is subtly hinted at in the comment by /u/jguegant) has multiple accounts (that they keep on deleting and recreating) and keeps on posting the same ~~nonsensical drivel~~ unpopular opinion on this subreddit and their website / LinkedIn profile. The writing style and wording employed are a dead giveaway.
Cool! Well in the end the license is your choice, but GPL is invasive (if I use your tool/library or any code from it, I have to release my code under GPL as well). This makes it useless for a lot of people. On the other hand, with GPL, you make sure that contributions will go back into your project or will at least have to be open-sourced elsewhere.
If you use Jekyll or some other static site generator then they generally support a few highlighters. Rouge and pygments are a couple of examples. For best results, you'd use a tool which actually parses your code, like [Clang highlight](https://github.com/kapf/clang-highlight). Of course, for that to work properly, you'd need to run it on the entire TU and then integrate the highlighted snippets into your blog.
Shameless self-plug: I'm developing a [3D face model and fitting (computer vision) library](https://github.com/patrikhuber/eos/tree/devel) in modern C++. It doesn't use any fancy TMP but it's pretty straightforward modern C++ (or so I hope). It's also a cool example in my opinion of how easy one can generate Python bindings (and even Matlab bindings) for a C++ library with the modern tools/libraries nowadays (CMake, pybind11, ...). It works on gcc-4.9+, clang-3.5+ and VS2015U3+. (I recommend looking at the [devel branch](https://github.com/patrikhuber/eos/tree/devel), which has lots of CMake modernisation in it as well as improved bindings code.)
their naming scheme is so bad edit: it also says towards the bottom that they intend for Qt Widgets to be one of the backends, for KDE compatibility
OK I see, I started publishing some code only recently and to be honest I did not take the time to look at that in details. My intention was not to have such a protection level , I will change that in all my projects, thx a lot for your time and remarks, that's what I wanted to get from advertising my projects on reddit but unfortunately very few people take the time to give a feedback.
I obviously don't have enough knowledge to claim you are wrong or right wrt sync vs async speed... But if you are really confident in this myth about async being faster you could make a cppcon or cppnow talk about it. (assuming you will not loose a lot of consulting money if the secret is out :P )
Reminds me of a guy I haven't seen post in a while who liked to mock anything that wasn't directly aimed at letting him shave off a few nanoseconds from the run time of programs written for his specific use case and couldn't understand that other people had different priorities. Can't remember his username though. 
PEGTL is really good, although it may be a bit smaller than what you mean. It's a header-only compile-time parser generator, which I'm using for a project. It is a bit 'magic' at times because of its compile-time, though.
&gt; But if you are really confident in this myth about async being faster you could make a cppcon or cppnow talk about it. (assuming you will not loose a lot of consulting money if the secret is out :P ) You'll find such talks already exist. I try to present at two C++ conferences a year. In terms of benchmarks, it is true &gt; 15 years ago that async was much faster than synchronous. Lots of people began banging drums on "the 10k problem" and that drew attention to this, so kernel devs fixed the inefficiencies. It therefore became untrue in every major OS from about 7 years ago onwards. You can now easily achieve **100k** TCP connections on a standard PC with a 10 Gbps NIC AND with a fair bit of HTML lexing without trying too hard. And if you look at what say haproxy did, you'll find they don't bother with async or even threads and still peg a 10 Gbps NIC from a single kernel thread (http://www.haproxy.org/10g.html). So, there's no "secret" here, this is all very well established fact now.
yea, but it's not really a good example of "modern C++"...
I am using stack edit - https://stackedit.io/editor and it supports code blocks. Then I'll just export it as a html page and the nice syntax colouring is there. I also have https://github.com/google/code-prettify - but that's mostly JS, so not what you want.
I use "Copy to Html" feature in Productivity Tools for Visual Studio. I wrote [the article](https://eliasdaler.github.io/better-highlighting) about how it looks and works.
That guy was HFTrader. Update: At first I thought that this is the same guy, but I am not sure any more.
It's retained. It can utilize lighting and shadows, but at the moment I've disabled it as I turned my attention to my Android port (of my engine). I may end up writing a blog about it in the near future if people are interested.
All the libraries [waiting for Boost peer review](http://www.boost.org/community/review_schedule.html) are by definition "new" C++ libraries. I'm not sure what qualifies as "big" though. Also the reason C++ projects look "unpopular" on github is due to a very different history with C++ open source. Most C++ open source is consumed by downloading a release archive, often via an OS package manager. In other languages you'd use the github directly. [Work is ongoing](https://www.reddit.com/r/cpp/comments/5ss6cv/any_interest_in_a_python_c99_preprocessor/) to make downloading C++ open source libraries just like downloading jQuery. But it's going to be a while yet, there is a lot of userbase resistance to using a git repo over an "official release".
That actually came from work done by Antony Polukhkin to standardise modernised build scripting for new era Boost libraries. Louis borrowed and extended from that, but it was Antony's baby.
Do you know if those explicit blocks are generally considered fine or frowned upon? I'm legitimately curious. I like them but I don't know whether someone would complain if I used them.
I don't doubt that Antony was first in the game with Boost.DLL (which came before Hana), but FWIW I wasn't even aware that he used a modern build environment. Hana's build system and (especially) Travis setup are the result of hundred of hours of frustrating experimentation on my own. Too bad if Antony and I did the same in isolation, we could have saved each other a lot of pain.
Interesting, I'll take a look. I'm not too familiar with a lot of boost. I don't get to use it that often.
Pretty much every modern video game engine
Okay, so if you have knowledge of the internals of the type, you can do clever things (let's assume it's not UB). I'll grant that it's nice, but it's also awfully specific. How do I, as a user, specify that you can apply this to my type? Better yet, could the compiler automatically detect it for my type?
You just named C++ and C projects :)
3ba7b1347bfb8f304c0e is indeed talking about HFTPro (which sounds slightly better than HFTrader)
Yes, by disallow I meant exactly that: disallow heterogeneous lookup if the map uses `std::hash&lt;T&gt;`. The user must provide their own hash that takes both types to allow heterogeneous lookup. This is kind of inconvenient, because it goes against the current default way of doing it: providing a `std::hash` specialization for your own type and then using unordered containers with default hash. Or maybe make `find` take a hash object as well?
I stand corrected. And I am sorry you duplicated the work on that, I had done the initial work, Antony then professionalised and made much more universal my stuff into canonical boilerplate editions. During the review of your library your stuff looked awfully like Antony's. I guess same problems lead to same solutions.
It's totally not C++11
Our project did something similar in the past where we built the PCH first, then copied the PCH to each subproject's directory. We abandoned that when we migrated from makefiles to MSVC project files, since it was hokey and we were trying to do things by the book. I would definitely be interested to see official support for something like this.
What you are looking for are C++ modules. VC has preliminary support though last time I checked (VC14U2), they were not ready for prime time.
Better have a bit of patience and get it right. Otherwise you will end up with another PCH ;-)
It's specific to basic_string because the thing that causes the badness is the small string optimization. The other containers are unaffected because they don't do that -- they can just swap/move memberwise. We the library know that the two string structures are layout compatible due to invariants of the data structure, but there's no way for the compiler to know that.
well... it has been done (in very hacky ways), and the MSVC devs are hinting that official support is coming... Also modules don't help with templated code (as far as I know - correct me if I'm wrong), and all the third party libraries won't suddenly be rewritten to support modules.
Your python preprocessor work looks interesting. I'm coming from a less educated standpoint, but are you suggesting that it would download libraries similar to how a javascript package manager might?
&gt; there is no fundamental limitation to reusing them between "projects" You can't reuse a MSVC PCH across targets, the PDB generator prevents it. 
I think again that [HFTrader](https://github.com/HFTrader) is the same person.
I wasn't aware of that limitation, thanks. However, PDBs aren't the only way to get debug info: C:\Temp&gt;type meow.hpp #pragma once #include &lt;iostream&gt; C:\Temp&gt;cl /EHsc /nologo /W4 /Yc /TP /c /Z7 meow.hpp meow.hpp C:\Temp&gt;type purr.cpp #include "meow.hpp" int main() { std::cout &lt;&lt; "Purr\n"; } C:\Temp&gt;cl /EHsc /nologo /W4 /Yumeow.hpp /Z7 purr.cpp meow.obj purr.cpp C:\Temp&gt;type woof.cpp #include "meow.hpp" int main() { std::cout &lt;&lt; "Woof\n"; } C:\Temp&gt;cl /EHsc /nologo /W4 /Yumeow.hpp /Z7 woof.cpp meow.obj woof.cpp C:\Temp&gt; 
Check https://msdn.microsoft.com/en-us/library/office/ff965871(v=office.14).aspx OR https://msdn.microsoft.com/en-us/library/cc811599.aspx 
clang-format: free, great, and extremely customizable.
Well Qt includes that with QML and their own animation/transition system. Otherwise, good luck.
True. But the problem for us library makers is that we can't enforce that sort of decision on end users, so my libraries make use of precompiled headers when the compiler is GCC or clang, including clang-in-msvc-mode. But it has to turn them off for MSVC. But no worries, my build system is MSVC C++ Modules ready, once your colleagues fix all the ICEs I keep sending in :)
Fold expressions can be quite handy. Here's an example from our library (aka, real-world code), the [PEGTL](https://github.com/ColinH/PEGTL). Without fold-expressions: bool result = false; using swallow = bool[]; (void)swallow{ result = result || Control&lt; Rules &gt;::template match&lt; A, rewind_mode::REQUIRED, Action, Control &gt;( in, st ... ) ... }; return result; The same with fold-expressions: return ( Control&lt; Rules &gt;::template match&lt; A, rewind_mode::REQUIRED, Action, Control &gt;( in, st ... ) || ... ); This is in *the* core rule (`sor`) defining what a PEG is all about: https://github.com/ColinH/PEGTL/blob/master/pegtl/internal/sor.hh
I did something similar for my linear probing hash map: https://github.com/rigtorp/HashMap You could enable overload resolution if: std::is_callable&lt;hash&lt;&gt;(key_type, related_key_type)&gt;::value and std::is_callable&lt;equal&lt;&gt;(key_type, related_key_type)&gt;::value I don't check this now, but that is what the code requires (and a hashes_equal&lt;K1, K2&gt; trait or similar)
Definitely clang-format. Won't help real-time while you're editing, but very easy to script for a commit hook or en masse on a large code base.
&gt; Also the reason C++ projects look "unpopular" on github is due to a very different history with C++ open source. Most C++ open source is consumed by downloading a release archive, often via an OS package manager. In other languages you'd use the github directly. Not really I think. Most Python projects would be installed via pip. Node/Javascript stuff via npm, etc.
I think a lot of them wouldn't really be written in modern C++, would they?
It seems to me like Eigen ticks most of the boxes and even most of your dream wishlist. And it would probably be quite feasible to improve the few missing bits in Eigen. Do you not agree with that?
The author said at the bottom they'll compare a few libraries (including) eigen to their ideal in their head. I'm interested to see what they think is missing a bit more concretely.
Qt provides animation, both using [C++ with QWidgets](http://doc.qt.io/qt-5/animation-overview.html) and [QML (JavaScript-like language) with QtQuick](http://doc.qt.io/qt-5/qtquick-statesanimations-animations.html). You don't have to use native-looking UI buttons Qt provides, you can draw them yourself and use the animation framework to animate whatever you draw. The way you would integrate the UI drawn by Qt into your SFML game is by making SFML draw the actual game on screen first, and then taking the OpenGL context from SFML and giving it to Qt to draw the UI on top of the game. You will also need to pass the mouse, key, etc. events SFML receives to Qt, so that user could interact with the Qt UI using mouse, keyboard, etc. In this case SFML owns the OpenGL context and Qt borrows it. You could also do it other way around, i.e. let Qt own the OpenGL context and let SFML borrow it, passing mouse and key events from Qt to SFML. If I were you, I'd try to go the QML-way, as describing UI with it seems to be a lot easier that with C++ and QWidgets, it's more CSS- and JavaScript- like, moreover QML is more suitable for custom (non-native looking) UI like the one you would expect to see in video games. With QWidgets you'd need to go out of your way a bit too much for my comfort level to do such custom looking UI.
Yep I read that, I'm curious as well!
Forgive me but I don't exactly understand how it is off topic. It is a question on where to find resources for interacting with databases in C++.. 
RAII is a great thing; controlling your scope is thus highly encouraged. Formatting aside (possibly), no frowning here.
clang-format can be hooked to a editor of choice. I use it through a Vim plugin, can format on save, on command, whole buffer or just a selection: https://github.com/rhysd/vim-clang-format/#screenshot
&gt; Encoder encoder; &gt; // fill encoder with data... &gt; std::ostringstream ostr; &gt; encoder.encode(ostr); &gt; std::string buf_str; &gt; ostr.str(buf_str); &gt; device_write_callback(buf_str.c_str(), buf_str.size()); &gt; &gt; Had I used: `std::string buf_str = ostr.str();` I would have incurred an additional copy of that giant buffer! The unary `std::basic_ostringstream&lt;&gt;::str()` overload [takes a `const&amp;` argument](http://en.cppreference.com/w/cpp/io/basic_ostringstream/str) &amp;ndash; how could it be populating `buf_str`, and how could `device_write_callback` be receiving anything other than an empty string? Also, /s/parity/arity/
&gt; Personally, I'd avoid this though. First of all, you don't really want to keep that reference around any longer than needed. Second, just calling `.str()` might actually be copying data from the stringstream itself into a string object. That would still be better than calling `.str()` twice, which returns by value.
I like seeing you guys around these parts.
Hmm...good point.
The issue is likely to be the signature of the arguments you're passing to the variadic function. You're probably unpacking by value, i.e. like this: Args... . If you want to unpack to references, use Args&amp;..., if you want to unpack to rvalues use Args&amp;&amp;... and so on.
I like nothing better than a C++ article about concepts that starts a long introduction to Haskell type classes and then proceeds to explain practically nothing about C++.
Sorry, I assumed you meant variadic template functions.
Yes, but its still an extremely important concern. For many people lack of CUDA support is a show-stopper. Another point is that the latest version of LLVM can actually build CUDA, independent of NVIDIA's official support, perhaps something like this might work. http://llvm.org/docs/CompileCudaWithLLVM.html
I hope they will fix "invalid cast" errors because now it's impossible to compile anything, be it old vc2010 project using that tool chain or new cmake project. No, it is not error is n code. There is no file/line info, just lots of plain "invalid cast" messages and a build failure.
&gt; (Actually, I don't think I said "meow" even once.) 48:18.
see /u/STL's response but below, but just to amplify. We know this is a critical dependence. But their dates are theirs to announce :)
Ha-ha, and I wondered why no one from Microsoft posted it already. :D
 Will it be easy to upgrade from the RC to the Final, or is typical VS installation where nothing works correctly still..?
I use clang-format in QtCreator (I usually format a selected piece of code with a keyboard shortcut). There are plugins for most editors/IDEs (I've used it in Eclipse, Visual Studio and SublimeText). Recently I ran clang-format on the complete history of a Git repository using [git-filter-blobs](https://github.com/mbitsnbites/git-tools).
If it doesn't use data to compare then how does it guarantee that to parrays with the same content access the same map element for example?
&gt; (Actually, I don't think I said "meow" even once.) 55:01
I'm coming to the party a little late, but since you are linking to the middle of my talk I should probably respond. The most standard Asio design for a server is that an object will represent a client connection. The object managing the state and whatnot of the client has a lifetime that is tied solely to the object having more work to do (generally reads and/or writes). When there is no more work to do, the object can be destroyed. The point of the `shared_ptr` is to control lifetime via reference counting bound to the queued completion handlers. More specifically, the pattern uses `shared_from_this`. This is not the same usage pattern that is objected to by Sean Parent and others (including myself). This is just one way to deal with Asio and lifetime of completion handlers. Be careful not to convolve lifetime concerns and mechanisms to deal with asynchronous handling. Lifetime must be dealt with. Different people like different solution spaces for handling the asynchronicity. I prefer something like Boost.MSM (Meta State Machine) paired with Asio. Gor Nishanov has given many presentations about using coroutines. You can see Chris Kohlhoff (author of Boost.Asio) has examples utilizing stackless coroutines. Some people think they like futures with continuations … but it is a mess for anything beyond trivial. You must ensure that the completion handler lifetime extends long enough … beyond that, pick some other mechanism. I am curious though if your distaste is more about the chained completion handlers and hand-crafted-uglyish state-machine thing or is it about the lifetime mechanism using `shared_from_this`? 
Can they please cut its install size down below 2GB and make actually fast enough to use on a decent (3 year old machine) in a virtual machine with 8 to 16 gb ram? Definitely don't want to be running Windows but wouldn't mind using it if it wasn't so god awful resource heavy. 
&gt;But perhaps this is an indicator of something deeper: one should not be passing stored blobs around. Instead of writing a function that wants to take a std::vector&lt;T, myalloc&gt;, perhaps it should take an iterator pair or a range. Sure, this may require a template shunt on the front end, but that way it doesn't impose storage requirements upon the caller. Yes, I briefly mentioned that under type erasure (as it is a form of type erasure). 
Oh, you mean the note on array_ref. I didn't catch that first time. Nice.
My libraries which are based on boost-lite (a common modern build system and utility library for C++ 14) solve this problem by either enforcing a guaranteed API and ABI version which is checked per commit by the abi-compliance-checker, or else an inline namespace is permuted to the git SHA of the commit. Boost-lite uses git submodules to indicate dependencies. Library A can be dependent on a different SHA in library C to library B's dependency on library C. My design and approach works, but there's no doubt it's clumsy and a lot of folk don't like it. In daily use however, the cmake build tooling takes care of keeping the submodule SHAs correct and so on. It's seamless to use and develop against.
As I mentioned in the blog post and CppCast, push_back handled aliasing through a pointer check, which is slightly incorrect but works for almost all scenarios. It was emplace_back that totally failed to handle aliasing, and it has now been thoroughly fixed.
And even if you did have the hardware, the gains from AVX2 =&gt; AVX512 are small (about 5%) unless you custom write the code to take advantage of it. I say this coming out of a contract where I implemented AVX512 support and was singularly unwowed by the performance improvement, unless you have really large runs of big arrays to do math on, it's not much of a gain. And the 64 byte alignment everywhere is much more annoying and wasteful than 32 byte alignment everywhere too.
I understand that Knights Landing has AVX512 support.
Hi Billy, * AVX512 will be available on Xeons released this year. * Xeon Phi already supports it, although I don't think it support windows :( * Cannonlake will support avx512, this is intels next CPU release Since VS release cycle is two years or so, lots of CPU's will be AVX512 capable within vs2017 time frame.
 I saw similar claims with SSE-&gt;AVX, and yet when I implemented AVX support gains were &gt; 2x over SSE. If you algorithm is memory bound, sure AVX512 won't do much, but personally I am not memory bound, and AVX512 would scale just fine. Also what do you mean by "write custom code"? Of course you must write custom code to use AVX512... If you are referring to simply toggling some AVX512 flag and hoping for performance gains, that will not do much of anything, auto vectorizors are terrible. The purpose of the avx512 flag is to tell the compiler to use the extra registers when performing scheduling of intrinsics. 
All of your points are valid but I do not agree with the first one - I feel like avoiding to use the current standard because compilers/companies haven't caught up is not a good reason. On the other hand, producing high-quality desirable C++14 libraries would drive those companies to upgrade to more modern compilers.
If that's the case it doesn't still sound too convincing to me either. The possible benefits are extremely dependent on the data and its comparisons and optimizing it in this certain way would only benefit some use cases while penalizing others. For this length first comparison to be beneficial you need to mostly be doing comparisons which don't equal. In the equal case it adds an extra check. This is an extremely fine trade-off which I'd only choose after benchmarking my software either way. 
&gt; I feel like avoiding to use the current standard because compilers/companies haven't caught up is not a good reason. In your own work? Sure. In a library that you want other people to use? Sorry, it's a bad idea. For example, I write Python extensions that work cross-platform. Due to toolchain issues, I cannot get past C++11 yet, and I don't expect to for at least two years. In particular, I see only one C++14-only feature used here. It would be nearly trivial to get rid of it.
I've used imgui (together with GLFW), and it's great for simple UI needs (e.g. tools etc), but AFAIK it does not have much animation support (you would probably have to do your own animations - e.g. moving/fading windows/panels). One really great thing with imgui is that it's nonintrusive (i.e. you can use whatever application framework and gfx API you want). Qt with QML is great for animated UIs, if you can live with the dependency on Qt, and if you are OK with using Qt as the main application &amp; windowing framework.
[[expr.call]§9](http://eel.is/c++draft/expr.call#9) says that passing class types with non-trivial copy ctor, move ctor or dtor is only conditionally supported in an implementation-defined manner. Apart from that, I don't think the standard says anything about how they're passed, except that you can pass it and then obtain the value of the argument in the function via `va_arg`.
HI. Do you know the lgpl v3 license ? I don't understand, there are to much restrictions, so if i just dinamically linking to qml libraries then can i sell my game ?
Thanks, that puts my paranoia at ease.
QML is a language. You use it to write graphical user interface in Qt. There is another completely different approach to writing graphical user interface in Qt - it's QWidgets thar do not use QML at all. LGPL is ok. Just don't link statically (but even if you do link statically, you can send the *.o files to people who would complain).
Ok thanks. But what about this: "Free Speech" Overview - Open Source Licensing Obligations -Using parts of Qt that are only available under GPL requires open sourcing of your application when distributing -Must provide a relinking mechanism for Qt libraries -Must provide a license copy &amp; explicitly acknowledge Qt usage -Must make a Qt source code copy available for customers -Qt source code modifications aren’t proprietary -Must make “open” consumer devices -For Digital Rights Management see (L)GPL FAQ -Special consideration should be taken when attempting to enforce software patents " Just dynamically linkig and all will be fine ? nothing more ?
Thanks for the useful comments. 1) I see, I'll look into it. 2) Right. In this particular case I tried to provide the implem that required the least knowledge about TMP, because this part isn't core in the article. 3) I thought we couldn't check 'first' if it wasn't a pair, no?
&gt; Qt showed how nice c++ UI libraries can be. Turbo Vision, Object Windows Library and Visual Components Library did it first, I would say. &gt; It is the library writers that need to get up to speed to create those APIs. That is the biggest problem, many are lazy and we just get C headers. For example, it was already possible to write safe C++ with C++ARM even if each compiler had its own incompatible library, yet we had to wait until C++11 for the *modern C++* wave. 
Such as? Unreal Engine is an example of how _not_ to do modern C++. 
There is some work to do on distribution if you want to distribute binaries (there is good documentation though.) You will likely have calls to new/delete in you GUI code, but these aren't a problem other than being a bit ugly. Honestly, Qt is as good as it looks and there is a reason it is so widely used. It is super well supported and the APIs tend to do everything you would want.
Android GUI work is still fine ... I just use Qt for it.
The downsides are few and tend to be overstated. I don't do development anymore, but the main issues I would encounter came when trying to create custom UI elements. Had a similar problem testing with Qt Quick or whatever it's called now. But if you stick to the standard Qt stuff, it's great and sure as shit beats the torture of using the awful Windows API directly.
&gt; &gt; It seems to me that every usage of `friend` you have is wrong, because all of your classes are structs. &gt; I don't understand what you mean. The keyword `friend` is used entirely to allow access to protected and private members - but a `struct` has no protected or private members. I believe you could replace all instances of the string `"friend "` with nothing at all and the program would still compile. &gt; It's an anonymous non-type template parameter pack, similar to something like `template &lt;int... Is&gt;`. Aha, very good explanation. OK, that's why it compiles :-D but I think you agree you could just remove the ellipses and keep the same meaning...? 
Really my only objections to QT are about Moc. Moc is not a standard part of the build chain and is not always trivial to configure. CMake and Moc don't get along very well either. Other than that it's a rather large dependency that can get a little annoying for small projects but given that any decent size project will have dozens of dependencies that objection isn't huge.
The VS update cycle has been every 3-4 months over the VS 2015 timeframe. Major compiler and optimizer improvements were shipped in these updates. The VS release cycle of two years isn't the limiting factor here. 
Do you have a code sample that demonstrates the issue you're referring to?
You have the option of using either Qt or STL containers. Qt for convenience, STL for speed. http://doc.qt.io/qt-5/containers.html
The video was uploaded to YouTube by someone with almost the exact same username as you. That's an interesting coincidence.
&gt; CMake and Moc don't get along very well either. They don't? I've been using CMake with a ~500k LOC Qt project for the last few years without any problems. CMake even has specific features to handle it such as [AUTOMOC](https://cmake.org/cmake/help/v3.5/variable/CMAKE_AUTOMOC.html). I'd be interested to know what issues you've had (it's perfectly possible that I've just got lucky because of my usage).
Fair enough. I know we did a tidy-up of our CMake files around a year ago to take advantage of some newer ways of doing things, and they've not really needed touching since.
Can you mention him 
There is one downside I have to fight with the most: Almost every architectural design flaw can be "solved" by adding a few signals and slots here and there. Two components were never supposed to communicate now need to for some reason? Add signals and slots and let some class that uses both establish the communication, maybe even the dependency injector. So if the pressure is high to get a feature out fast, this is what some team willingly resort to, instead of redesigning the flawed architecture. Of course you could argue that this is not the fault of Qt, but I say it is: In this regard, Qt makes it way to easy to do the wrong thing. As Scott Meyer put it: It should be easy to use correctly and hard to use incorrectly. Here it is both easy to use correctly and incorrectly. In my opinion it should only be possible to connect signals from other classes to a signal/slot in the class calling `QObject::connect`. And there is no reason to ever connect a signal in the class calling `QObject::connect` to a slot in another class, you can just call the function directly. So Qt shouldn't allow it. *TL;DR*: `QObject::connect` should only allow to connect components that "know" about each other, and signal -&gt; slot connection should only be possible in the class that has the slot.
All Qt classes take Qt's containers in and return Qt's containers so using only stl containers is not really possible. Usual pattern is to use Qt containers in UI code and stl containers in other parts of the program. That requires some transformation between containers when showing data, but usually some kind of transformation is required anyway so it's not a huge issue.
Ah, quite right about `friend` - I corrected the original. Not sure what I was thinking TBH. &gt; Without the ellipsis, you'd have to pass another template argument for it. Yes, even clearer - I meant, "Replace the ellipsis by a single argument" but didn't express myself well.
Most of the "meow"s were pre-show. But I think one may have slipped in during the show :-P
I assume he's talking about the "specified cast is not valid" error, which I've also been experiencing quite a bit. Basically when attempting to compile a project the build instantly fails with "the specified cast is not valid" and no other information. For me this only occurs when using generated projects (from gyp as well as premake5 in my case) and it starts happening at some random point in time, but once it happened once, it will always happen on subsequent build attempts. It does not occur on the initial first build when generating VS2015 projects and upgrading them to use the v141 toolset. However patching gyp to generate the exactly same vcxproj files as the upgraded ones also didn't appear to fix the issue. I sadly didn't get time to fiddle around with it a bit more to isolate the issue yet. Going to have a look again over the weekend if I can construct a small reproduction case.
You can in theory install the build tools which is just the compiler and associated tools. No visual studio IDE. In practice, I found the VS2015 releases broken (something to do with the wrong Windows SDK being required), and the last VS2017 was also broken (missing `VS150COMNTOOLS`/`VS141COMNTOOLS`(?) made it unusable with existing CI infrastructure). From the bug reports I read this was removed intentionally. If so, it's not clear what the replacement is.
Completely agree about web.
Is there a release date for an RTM release prior to the actual release date, for final testing and updating of third-party stuff ahead of the actual release?
It's not very often that you have to pass a container to a Qt class. You are usually responsible of, for example, iterating through your containers.
* You are not using/typing ISO standard C++ (see moc) * It's a memory hog * Rendering is not native, it's doesn't feel native either * You end up with a big applicaton -- exe and required DLLs * It's not free, it's a commercial product * It's a HUGE framework * All Qt applications look and feel the same (shit) * Way too boring 
&gt;you can just call the function directly. So Qt shouldn't allow it. In your own event loop? &gt;*TL;DR*: `QObject::connect` should only allow to connect components that "know" about each other, and signal -&gt; slot connection should only be possible in the class that has the slot. What about connection to lamba? 
&gt; Qt implements its own containers News to me! I'm used to reading that XYZ gaming library implements their own containers for obvious reasons, but I wouldn't have expected a UI framework to need to as well, but then again having utilized Qt for a project, I can see the need. EDIT: cut me some slack guys, I was watching Power Rangers when Qt came out. 
Qt is good if you want to write Applications in C++, especially if these have a UI. But you can and should combine it with the STL, prefer Standard C++ over the easy Qt Solution, learn the new standards. Qt is very conservative, and not written from a standpoint of pioneering work in C++. Its good and mature to write production code in. Also with over 20 years of age, Qt ofc has some technical dept of its own, even when the newer versions got rid of some with introducing QML, QWebEngine and other things Qt still brings new and exiting possibilities.
Qt is great. It's by far the best cross-platform GUI library available for C++, and arguably for any language. The main complaint you'll hear about it is that it's very different from "standard C++" i.e. the interface style used by the standard library and Boost, etc. For example: * Qt uses its own container classes like `QString` and `QVector` rather than `std::string` and `std::vector`. Qt's container classes also use copy-on-write internally, whereas STL containers do not. Qt containers have their own Java-style iterators (as well as STL-style iterators), and so on. * In fact, generally speaking, Qt prefers to reinvent STL facilities in their own API style rather than just using using the standard library. `QSharedPointer` vs `std::shared_ptr` for example. * Qt makes heavy use of inheritance, whereas STL/Boost-style code tends to use templates and/or type erasure for polymorphism * Memory management in Qt is... unusual. You call `new` on a type and then pass the pointer to a parent object with is responsible for deleting it. Modern C++ would most likely have you create an object on the stack and then `std::move()` it into the parent, with no pointers involved (or an `emplace()` method on the parent which perfectly-forwards the constructor params). The modern C++ advice to "never call `operator new`" is useless with Qt. * It's a minor point, but Qt code doesn't *look* anything like standard C++ code; method names are `javaStyleCamelCase()` not `snake_case()`, and Qt still hasn't learned about namespaces even 25-odd years after they were invented. * Qt adds extra "keywords" into C++, such as `slots`. A preprocessor called Moc turns these into real C++ code which is then passed to the compiler. In practise this isn't a big deal and the build system will take care of it, but it still adds to the feeling of Qt code being "foreign". So in summary, Qt is fantastic for GUI purposes, but it almost feels like writing a different, more Java-esque programming language.
I believe Qt has been around before STL was standard. 
Gosh I'm in the middle of update-everything-and-rewrite-loads-of-code at work thanks to the QtWebkit/QWebEngine/QWebView joys as we speak. I want to cry. Still - it's a great framework.
I'm curious, do you mean nanogui with "nano", and why did you not like it?
I liked it just fine but found Qt to be more robust and more RAD.
&gt; I saw similar claims with SSE-&gt;AVX, and yet when I implemented AVX support gains were &gt; 2x over SSE. That's unusually good though. And you're totally right it depends on the application. In the thing I'm referring to, SSE was 3.8x faster than scalar, AVX 7.2x faster but AVX2 only added a further 10% despite the doubled width. AVX512 barely added anything at all as I mentioned. We were doing runs of maths on 1024 float buffers, and that's the big limitation. Bigger arrays lets AVX2 and AVX512 shine, 1024 elements is too small.
And /arch:avx2 has also been shipped in a VS 2013 update.
Sadly.
'native': Most of the applications that people love utorrent, winamp, etc. If you buy a particular platform win/mac people expect to run 'native' applications and not cross-platform shit. But I get your comment, you're right. What I am saying about boring is that most people spend two decades studying, and for some people would be far more interesting to create things from scratch rather than using other people work. There is a difference between creating something new VS using other peoples work -- and Qt doesn't give much freedom for innovation, etc.
Maybe you're right, I have never used Qt in a product. I tried it once at around 4.x and then gave it a last try at 5.0.x, it was horrible. If you go with GPLv3 you are doing fine legally, financially it's a different story. But if you go with LGPLv3 it's questionable and I am not a lawyer, someone with more experience on the topic should clarify the following. LGPLv3 states that in header functions should be maximum 10 lines, and in the case of the Qt containers ALL the implementation is inlined in headers, which means that you violate the license. It's not a clear ground and most people I know just pick the commercial license just to be sure, etc.
I don't agree it's a nice post. Apart from the language problem (Candy Crush Sega, author didn't even try), the article has no real substance and is IMHO click-bait to sell adds. Just two examples: &gt; JAVA is designed as a Portable Language so that, It can run on any Device. No, Java as a language is like any other language, the compiler was designed to translate it to byte code which runs on a JVM - but nowadays several other languages can run on a JVM as well. &gt; You can have a job of Game Developer, Graphic Developer and Animation Programmer with C++ Not to mention all the other industries: Finance, Telco, ... - author doesn't really research anything, the article seems to come from some quick googling.
well depending on the platform you will only produce shit GUIs, otherwise it's probably ok
&gt; Turbo Vision, Object Windows Library and Visual Components Library did it first, I would say. Certainly. Although they were not as popular as Qt, so most developers got to see for the first time how nice C++ can be with Qt. &gt; That is the biggest problem, many are lazy and we just get C headers. Exactly. It's not the language, that's what I am saying. 
&gt; If you buy a particular platform win/mac people expect to run 'native' applications and not cross-platform shit. But I get your comment, you're right. I don't know if you've been paying attention lately, but a lot of apps are shunning the old UI style guides. I don't like it, personally, but whatever - sometimes the UI guidelines just make things more difficult. &gt; Qt doesn't give much freedom for innovation That's like saying .Net doesn't give much freedom for innovation. It's just a toolkit. And when this particular toolkit falls short, it lets you break out of the sandbox and use native APIs. 
&gt; I gave up and just use the idioms that QT dictates and sob quietly to myself. I would love to see a potential Qt 6 apply some of the more modern best practices, like moving away from bare pointers to shared_ptr or unique_ptr. STL support, strings, etc. But that said, it's not that hard to segregate UI from core code - I've done it, and rewriting Qt is a big-ass job... 
That's for PODs. With a `std::string` the destructor matters, so you need some kind of new trait that says "and don't worry about running the destructor after moving".
http://download.qt.io/community_releases/5.8/5.8.0-final/
&gt; Is Base a git submodule in both Foo’s and Bar’s repos? Why not, if you all use git. &gt; Does Base publish static libraries, or do we rebuild it twice every time we need to build Foo and Bar? Yes for static libs. Also so-s. Also debug/ndebug build of all. Also 64/32 bit builds . And Unicode (Utf-16) build for Windows, and it must speak utf8 there as well. The final build system should be smart enough not to build it twice (*if* the client decides not to use prebuilt stuff). :-) &gt; What happens when Base introduces a breaking change (revs the major version) and Foo switches over to use it but Bar doesn’t? Foo is broken until Bar is upgraded or until it downgrades Base. Do not expect magic :-)
I don't think it suggests otherwise. Qt uses the native APIs to take the mentioned pixmaps. The point about animations is valid though.
Qml makes HTML and CSS feel like the dark ages.
Eclipse NetBeans SKY IDE Dev C++ AREN'T COMPILERS, they are IDEs
Table views require that you implement a model. Implementing a model doesn't really require any containers.
Interesting. And it includes QWebElement and friends. Too late to help me, but it's going to make quite a few useful apps and [use cases](https://github.com/annulen/webkit/wiki/Use-cases-of-QtWebKit) maintainable.
Does this scale to a large tree / graph of dependencies? How do you build? Do you build the entire tree once (sync the top project and throughout all submodules)? Do you have continuous integration set up for libraries that are in the middle of the graph (and do you produce binaries, or just use CI for validation)? Thanks!
In a distributed world (let's say github), Foo may be owned by someone and Bar by someone else. It makes perfect sense for Foo's owners to switch to the brand new Base 2.0 because it's new and cool, but Bar's owners don't have the time (or don't think Base 2.0 is worth it). Now the poor App developer that chose to depend on both Foo and Bar has to stick to the older version of Foo until Bar also decides to move forward (lowest common denominator). Now as I re-read what I wrote, I realize there is no magic way to solve this. It works for npm (node.js) because they literally include the dependent's source in the package (which means that if in a huge graph you have some base library included 100 times, you actually have 100 separate copies of that in your final source). That doesn't work in the c++ world unless you mangle the symbols to somehow include the version (or stick everything in a namespace that includes the version), which leaves you with potentially many versions of the same library in your executable (that may have conflicting and incompatible states which wreaks havoc at runtime - think globals and stuff). What build system do you use?
In addition when using LGPLv3 you give permission to anybody to reverse engineer your application, ouch.
One library I learned a lot from was boostache, its been written by a couple of C++Now attendees, and currently maintained by Michael Caisse: https://github.com/cierelabs/boostache
Yeah, unique_ptrs would go far in documenting (and enforcing) the interfaces, as some methods take ownership and some don't..
The value is read correctly but after that the program has finished and the window closes. Try using something like "system("pause");"(insert after cin &gt;&gt;min) to keep the window open. 
Qt exists since 1993, before the containers were standardised
I think the "reference to any contiguous memory block" bit is just a special case of SCARY iterators, which themselves are just a special case of the general rule of template programming "Don't over-parametrize". If something doesn't use the policy, it doesn't need it as part of its type.
That is the main focus of the QtQuick effort ( but you can also use the standard widgets if you want. ) Qt also has a bunch of extra Android libraries for stuff like sensors.
It's still available, you just have to build it yourself
See %VCINSTALLDIR%\Tools\MSVC\14.10.[version]\include\zmmintrin.h. Line 109 in my copy shows AVX-512 instruction support. I believe the support is partial at this point but it does exist.
API has many overloads for many different use cases, much more than the stl. E.g. The vector class has removeOne(value), removeAll(value), yoi can iterate the associative containers on the keys or the values and get the list of all keys, etc
&gt;Xeon Phi already supports it, although I don't think it support windows :( You don't want a compiler with a switch the compiler team can't test :)
Great news, thanks! I'll give it a try soon.
I didn't say it was the same thing at all, merely that it has the same name. Consider two classes `a::foo` and `b::foo` as `a/foo.h` and `b/foo.h`. Previously it required bodging by calling them `a::afoo` and `b::bfoo` as `a/afoo.h` and `b/bfoo.h`. Really annoying. For the specific case I had, I had different sets of classes for different OpenGL/GLSL versions.
C++ library? I don't think so! To me feels like a huge outdated framework that uses C++ with extensions. Qt has more similarities with C++/CX, it's something different from standard C++. And if you use QML I think you are closer than you think to browser based model you mentioned, a javascript framework. Qt is everything but the kitchen sink, and this from an engineering perspective is ugly. 
Calling him an idiot is pretty uncalled for. He's obviously just starting out with programming. When you first started out did you instantly know about things like pastebin?
Can we suggest people to just put a breakpoint at the `return` line instead? The program "ending" is only due to the idiosyncrasy of it being launched through a new self-contained DOS process and window. If the program is launched at the command line, the `system("pause")` is extraneous.
I knew of things like screenshots.
True as that may be, they've had 6 years to make progress on using the standard library. 
Why do you assume that STL containers are faster than Qt's? 
How is it bad that they also provide networking, file io, or threading? In what way does having more libraries make the product worse?
As you know, when your program reaches `cin &gt;&gt; min` it pauses waiting for user input, once you hit enter the program them continues executing. The next line after the `cin &gt;&gt; min` is `return 0;`. `return` exits the current function which is `main` and when the `main` function is exited the program terminates. So to stop the program from exiting we need to not let the program reach the `return` statement until we want to exit. So how do we do this? Well, you already know! You've already paused the program twice waiting for input. The only issue is you need somewhere to store the input. In this case we don't particularly care about the input, we just want to pause until there is input. The way to do this is using the `cin.get();` method. This, as the name suggests, gets the next key that's pressed. This is better than `system("pause")` as `system` sends a command to the system. So it's entirely reliant on the system understanding that command. `std::cin.get()` is well defined and the behaviour is required to be the same regardless of the system. Whilst this may not be immediately relevant to you it is worth knowing. Also, for future reference you can post code directly to reddit by preceding it with four spaces. For example: #include &lt;iostream&gt; int main() { return 0; } 
&gt; thread-safe event management (publishers need the pointer to subscribers, which may be re-assigned). How was this different from what Qt signals solves?
&gt; How should this be designed? Normally, you install the library Base. From source, if the library uses cmake, then you would do: mkdir build cd build cmake .. cmake --build . cmake --build . --target install Of course similiar steps can be followed with other build systems like autotools. Now, when you build Foo and Bar, you can find Base by using the standard cmake find commands. Well the above will install Base in the system directories and perhaps you would like to install them in a local directory that doesn't affect the system. In this case, you can set where its installed with `CMAKE_INSTALL_PREFIX`: mkdir build cd build cmake .. -DCMAKE_INSTALL_PREFIX=/some/dir cmake --build . cmake --build . --target install Then when you build Foo and Bar, you can set `CMAKE_PREFIX_PATH`, which will set additional directories to search for dependecies: mkdir build cd build cmake .. -DCMAKE_PREFIX_PATH=/some/dir cmake --build . &gt; Is Base a git submodule in both Foo’s and Bar’s repos? Submodules is not a dependency management tool among other problems it has(like problems with shallow cloning and lack of support on github). &gt; Does Base publish static libraries, or do we rebuild it twice every time we need to build Foo and Bar? So, Base would publish either its source code and/or binaries in a tar file for users to download. For example, this is what clang does. Of course, this is a manual process, and whether it installs twice is up to the user. Tools like [cget](https://github.com/pfultz2/cget) can automate this process, and can even install binaries. Just list the dependencies in a requirements.txt file and it will read it and then download and install them if it hasn't been installed already. A packager manager which is more powerful than git submodules and cget can also help with this as well, and there are a lot of them, but most require adding support for them before being able to use a package. So Base will require support for the package manager before Foo and Bar can utilize the Base package. &gt; What happens when Base introduces a breaking change (revs the major version) and Foo switches over to use it but Bar doesn’t? And this a good reason for libraries to support dependency configuration tools. There are only two mainly used, that is pkgconfig and cmake `find_package`. This way you can install two versions of Base in different locations. Then when building both Foo and Bar, set the cmake prefix path to both paths: mkdir build cd build cmake .. -DCMAKE_PREFIX_PATH="/path/to/base1;/path/to/base2" cmake --build . Then cmake will find and link against the compatible version. Some package managers can handle installing two different yet incompatible for you(if packages are made available for it), although some would just prevent you from installing both incompatible versions. 
In practice the pre-processor can be a huge deal if you need to get it to play nice with something else that does weird fancy stuff, such as OpenGL, MPI or similar. They provide wrappers and libraries for compatibility with a lot of these but it's fairly limiting and can be a big mess to deal with.
OP is not just "running a program", they are debugging a program from an IDE. I believe what I suggest is a better fit for their situation.
Hehe, same here man. Happy programming!
One thread needs a pointer to a QObject receiver. If an event is generated, by the time it makes it over to the subscriber's thread, the receiver could have been deallocated and its memory may be occupied by a different object. That's why I try to use object IDs (GUIDs) instead of pointers to map subscribers to publishers.
Oh good. Then I stand corrected and I need to go digging into that to figure out how they interact properly.
&gt; fast insert and append operations. Those two things will really limit you container capabilities. The "fast insert requirement" will prevent large chunks of contiguous memory. Otherwise an insert near the front of your memory chunk will require a copy of the data following it. The "fast append requirement" might require a realloc (which will be slow) if you desire contiguous memory. 
&gt; The inline keywords there are redundant, true Then why don't you try removing them -- see if it works ;-)
This class is plain struct {T* p; size_t len;} -- you can't get faster than this. Performance claims come mostly from not using lexicographical comparisons. If GSL::span/string_span don't do the same thing -- they'll be slower.
&gt; Also modules don't help with templated code (as far as I know - correct me if I'm wrong) Modules do export templates, and that does mean a pre-compiled representation of templates can be stored in the module's compiled form and shared among other translation units that import the module.
It did few months ago.
&gt; In the equal case it adds an extra check. Actually, two. But in my experience it is unnoticeable on modern hardware. CPU quite often sits idle waiting for memory controller anyway.
Do you have javascript disabled? Nobody else has this issue...
I tried (with `operator!=`), it works. Why wouldn't it? When a function is defined with a friend-declaration, it is already inline regardless of the use of the inline keyword: [[class.friend]p7](http://eel.is/c++draft/class.friend#7)
Sometimes you do need the inline keyword to avoid ODR violations. See http://en.cppreference.com/w/cpp/language/inline
Huh... I was so sure about special handling of "friend inline". Used it for like 20 years. Turned out "inline" is implicit and unnecessary. My bad. Thank you.
Ugh. So Qt doesn't encourage modern use of C++, and apparently tries to shove its own solutions in your face. All the points you mention are *massive* downsides, in my opinion.
Hu, interesting, disabling uBlock helps indeed as it had blocked Google Analytics, though not with at least one of the code examples. For me, the main one looks like this: int main(int argc, char **argv) { if (argc &lt; 2) return 1; std::vector&lt;dynamic_lib&gt; libs; try { std::cout &lt;&lt; "Opening: " &lt;&lt; argv[1] &lt;&lt; std::endl; std::ifstream fs(argv[1]); std::string tmp; // read from the file. while(std::getline(fs, tmp)) libs.push_back(dynamic_lib(tmp)); } catch (std::exception&amp; e) { std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; return 2; } // load up all the libs for (auto&amp; l : libs) { l.handle = load_lib(l.path); } Note the indentation level of the final for loop which should still be part of the main function? Edit: I spoke too soon, this paragraph is still a single block (without the markup for the inline code, that’s done by reddit): again but we will remove the `extern "C"` part: 00000000004004d6 T _Z12do_somethingv See the difference? --- ## The Problem with `extern "C"` `extern "C"` will not work with things that are specific to C++ I am talking specifically about the `## The Problem`. Later, there’s a `--- ## The Main Program` snippet as well.
thank you for the suggestion, I will certainly check that out since I have many flex lexer already made and would prefer to changing them to another language.
alas, not in this case -- these definitions are implicitly inline, as it turned out.
Too bad if you want to write GUI applications quickly, you are limited to Qt or paying for Embarcardero C++ Builder. I wish Microsoft would add a form builder for unmanaged C++. However, I think they want us all to move to .net applications. Microsoft, we all don't write internet applications where I need to be protected from hackers! I write code that runs on a closed network and can fix any bugs very quickly when my 5+ users complain!
You can make application that can be compiled to Lin/Win/Mac and also Android/iOS/WinPhone without much effort.
I just remembered an alternative to using a `QTimer` when calling a function across thread boundaries: `QMetaObject::invokeMethod`. The function that is to be called just has to be a `Q_INVOKABLE`. Even though the syntax is weird, it still is so much cleaner than connecting a signal to a slot just to call downwards in the component hierarchy.
They did. std usage increased greatly inside of Qt implementation. They can't however use most of STL in their API because Qt has very strong ABI and SC guarantees, while STL containers/strings/other classes may be incompatible not only between different compilers/libs (clang libc/ gcc libstd for example) but even between compiler versions. Sometimes even minor ones (recent example might be transition of std::string to use SSO).
`inline` is implicit for function templates; it has nothing to do with `friend`.
Web devs keep telling me that writing a native application is so hard. It'll be soooo much simpler if I just learn a minimum of HTML, JavaScript, CSS, Less, Sass, Ruby, the Rails API, Bootstrap, and JQuery, and test in at least four different browser runtimes on every single platform. *(list of absolutely required crap to learn is subject to change/grow every three months. Any reference from three months ago will be completely useless.) Obviously, learning C++ and the Qt API is way more complicated than that.
`std::basic_string_view&lt;&gt;` is neither of those; it is effectively `struct {CharT*; size_t len;};`. Look familiar? ;-]
I can't argue with that!
Can you elaborate on that? 
I believe with LGPL you have to permit users to relink your program with whatever version of the library of their choice. I don't know if there are any commercial users of the kit who actually fo this route.
Er... you can see from the snapshot he's using Dev-C++, an IDE. Also, the behavior described is typical of using the IDE's debugger. It's the same behavior one gets with Visual Studio. If you "Start Without Debugging", the window remains. If you "Debug", the window" closes as soon as the program is done running. Either way, I'd much rather anyone, brand new or not, use the tools they have at their disposal than litter their program with useless code.
Defining any function inline implicitly makes it an `inline` definition; that's not somehow unique to `friend` functions, it's just explicit.
Yeah, it tries to do everything.
It's different from "standard" style, but there is hardly anything non-standard (maybe few convenient macro shortcuts). Moc just generates standard C++ code boilerplate for the programmer. It's not impossible to do that using just slightly less pretty macros (see verdigris).
To me, the biggest disadvantage is lack of simple data binding, and any kind of support for models. The MVC design is a bit outdated and very simplistic. Qt is, in the end, a collection of widgets, a good "standard library" and some gimmicks (qml etc) to syntax sugar the boring stuff, but that's it.
Kind of. You need to use QML, C++ Widgets won't do it. Also Qt still doesn't cover everything from Android, so you might need to have some JNI "fun".
cmake was born of collaboration with KDE project, if I remember correctly.
Unfortunatley not. See https://marcmutz.wordpress.com/2016/03/01/effective-qt-meeting-c-2015-talk-is-now-online/ Using C++-11 for range might result in an unwanted deep copy ...
I am curious about the downvote? 
Not a good reason to not modernize the library properly. Customers with old compilers can simply stick with an old, "stable" version.
That may be, but so what? Are you saying that Qt is not allowed to progress, because it was started in the '90s?
/u/yuehuang suspects he knows the issue but doesn't have a project that can repro it. Can someone help provide a repro project for this? You're welcome to PM him or send me mail at visualcpp@microsoft.com.
One source code can be compiled to every popular platform. Let's say you are coding some application, music player or whatever. You can then compile the same source code to any platform. No matter if it's desktop or mobile, linux or windows. On every platform your application will work in the same way (to some extend ofc, file dialogs and such are platform specific or you have to implement your own for mobile devices). I'm talking here about GUI applications and based on QML (part of Qt).
There's also [CopperSpice](http://www.copperspice.com/), which is forked from Qt and uses modern C++ such that it doesn't need `moc`.
Bingo. That's a winner. I changed the copy constructor to =default (because that's what it was doing already), and the struct is now being passed by value instead of reference.
I'm not sure what 'SC' means in this context? :-) Anyway, I don't think many people would complain if Qt used, say, `qt::vector&lt;T, A&gt;` which was simply an implementation of `std::vector` with ABI guarantees. The same with `qt::u16string`, `qt::map`, `qt::shared_ptr`, etc etc. That way people could keep using the standard interfaces they're familiar with, and the world would be a better place. Instead it's been nearly two decades since C++ was standardised, and it's deeply frustrating that Qt keeps insisting on doing things its own way.
Qt containers have STL API available too. You can use std::algorithm with them and such just fine. So? What's the problem? Not to mention that Qt Classes usually predate STL ones (as well as Qt predating STL existence).
&gt; How does this scale when your graph includes thousands of libraries? What scale? Manually installing libraries? I mean people build linux from scratch this way. But its definitely helpful to have a package manager to automate this and help pick the correct dependencies. &gt; Is there a package manager the industry is standardizing on? Not really. There is a lot of package managers for C++, but they are not really converging. Either way, a build system should be orthogonal to a package manager. I think many package managers make this mistake which limits adoption. Any serious package manager should be able to install a cmake library out-of-the-box without any extra configuration or files. &gt; Why would I install something like a dependent library? Why wouldn't you install it? You obviously need to install it if its a dependency. I don't understand why you find that strange. &gt; Ideally, the package manager would just fetch what I need Yes a package manager can automate the install including its dependency, but the install step needs to be there first. Following the standard cmake install flow, makes the job of automating it even easier. Furthermore, a package manager is not perfect, so there can be times a package needs to be installed manually. Perhaps the package is not available, or the user wants to install a patched version of the package, or maybe a package manager doesn't exist for the platform. This is why the build system(including installation) should be orthogonal to a package manager. &gt; If I'm also building a binary (say, I'm the app, or I'm building my test targets and actually need to link), then the package manager also fetches the static libraries (assuming their build with a matching compiler / sdk / flags is cached) Why static libraries? It should grab any binaries(including executables and shared libraries), and/or data files(like man pages, package configuration, etc) that were built with the package. If a binary doesn't exist for that platform it would build and install it. &gt; or just rebuilds as needed. Rebuild? It would build it, there is no binaries that exist for the platform configuration, so I don't why it would rebuild.
Maybe if libraries were modernised, a demand would be created to bring these embedded platforms up to date so everyone could be running on stabler, bin-legacy code
Compatibility has been a big thing for them, and I guess that throwing away their design would have deep consequences in how people understand the library. Despite being outdated, it is internally consistent and easy to learn.
By the way, standard library uses lexicographic comparison only for '&lt;', not for '=='. So, there should not be much performance difference for parsing use case that you showed.
Last time I checked (few years ago) GCC wasn't doing this. In fact doing this will break compatibility with interface provided by CRT (strcmp/etc). But, since you mentioned it, I checked MSVC 2015 and it looks like you are wrong: template&lt;class _Elem, class _Traits, class _Alloc&gt; inline bool operator==( const basic_string&lt;_Elem, _Traits, _Alloc&gt;&amp; _Left, const basic_string&lt;_Elem, _Traits, _Alloc&gt;&amp; _Right) _NOEXCEPT { // test for string equality return (_Left.compare(_Right) == 0); } int compare(const _Myt&amp; _Right) const _NOEXCEPT { // compare [0, _Mysize()) with _Right return (_Traits_compare(this-&gt;_Myptr(), this-&gt;_Mysize(), _Right._Myptr(), _Right._Mysize())); } static int _Traits_compare(const _Elem * const _Left, const size_type _Left_size, const _Elem * const _Right, const size_type _Right_size) { // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits const size_type _Min_size = _Left_size &lt; _Right_size ? _Left_size : _Right_size; const int _Ans = _Traits::compare(_Left, _Right, _Min_size); if (_Ans != 0) return (_Ans); if (_Left_size &lt; _Right_size) return (-1); if (_Left_size &gt; _Right_size) return (1); return (0); } if you check README.md -- it explains why std::basic_string has to do it slow way. 
2017 fixes this issue in relation to the == operator: https://www.reddit.com/r/cpp_questions/comments/59naz7/why_doesnt_stdstring_operator_short_circuit_on/
If this is true they'll finally decided to ditch compatibility with strcmp. Interesting... I find it hard to believe, tbh -- it should also affect operator&lt;, because otherwise I'll be able to construct string a and b that both a == b and a &lt; b.
You didn't look at the link did you? It's not changing operator == to only check size. It's checking if lhs.size != rhs.size then lhs != rhs. If lhs.size == rhs.size then it has to check the contents of the string. So no you can't construct a string where a == b and a &lt; b with the change.
I just checked libstdc++, and both [`std::string`](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/basic_string.h#L5810-L5817) and [`string_view`](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/string_view#L447-L463) are comparing size first. Update: and the same for libc++ [here](https://github.com/llvm-mirror/libcxx/blob/master/include/string_view#L577-L602) and [here](https://github.com/llvm-mirror/libcxx/blob/master/include/string#L3506-L3535)
No, it does not give up any compatibility. And no, you can't construct such strings.
How natural do the mobile versions look, though? Can you post an example?
I did, it was a pretty big tree of comments with quite a few links. I gleaned what I could. Yes, you are correct -- they short-circuited a bit of logic. But by doing so they broke compatibility with strcmp(): char a[] = "a\0c"; char b[] = "a\0cd"; assert( std::string(a, sizeof(a)-1) != std::string(b, sizeof(b)-1) ); assert( strcmp(a, b) == 0 ); Didn't think they'll be brave enough to do it. I don't even know when that happened...
Qt is old and it supports compilers and platform you've never heard of and you can see that in their code. But, once you get used to it is not that bad, really.
Thats only if you manually specify length. If you use one-argument constructor, then no compatibility is broken.
This really depends on the chip. It's possible that the instruction on current hardware is supported, but is microcoded, so you see small gains now, but on a future chip, the gains could be large. It's also possible you were just memory bound. 
If I understand correctly, because the Qt containers are copy-on-write, a deep copy is triggered when getting an iterator for the range for loop ... just in case you modify the container (which you can't). I wonder if `std::cref` would solve that problem.
https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md
Herb Sutter recommends A Tour of C++ by Bjarne Stroustrup. It's only 180+ pages and covers modern c++ as well. That's a good language overview book. 
Yes
learncpp.com is pretty extensive and useful as a place to get your feet wet.
Signals and slots can grow into an uncontrolled untraceable monster if you aren't careful. Large projects figure this out after a while. My biggest roblem with Qt was its lack of orthogonality on how to handle events. I wa working mostly with CAD style interactive applications and had ery serious performance problems with Qt, not to mention at some point I wrote interfaces 3 different ways (sig/slot, virtual override, event handler install, I think there might have been a 4th way to do it...). I got mad during the qt4 days when releases started pushing bugs around from one functionality we were using to another. Considering we were paying for licenses that got old very quickly. While not very pretty fltk2 gave me very, very predictable behavior, dramatic speedups and has been very usable, especially after I cooked up a clever automatic layout system that doesn't use absolute coordinates for anything...(engineering type apps don't need to be pretty).
&gt; Qt uses its own container classes like QString and QVector rather than std::string and std::vector. Qt's container classes also use copy-on-write internally, whereas STL containers do not. Qt containers have their own Java-style iterators (as well as STL-style iterators), and so on. It's not required that you use QT classes. You can write a completely standard c++ application and only hook into widgets for the GUI, if you want. &gt; Memory management in Qt is... unusual. You call new on a type and then pass the pointer to a parent object with is responsible for deleting it. Modern C++ would most likely have you create an object on the stack and then std::move() it into the parent, with no pointers involved (or an emplace() method on the parent which perfectly-forwards the constructor params). The modern C++ advice to "never call operator new" is useless with Qt. I believe the memory management only works to clean up allocated objects if there's a parent child relationship of the container type, like an object that is contained in a window. And you have to declare the object that you want to be automatically cleaned up after, with a parent argument in the constructor and then use that optional argument when creating the instance. Otherwise, you have to manage memory as usual, I think. &gt; Qt adds extra "keywords" into C++, such as slots. A preprocessor called Moc turns these into real C++ code which is then passed to the compiler. In practise this isn't a big deal and the build system will take care of it, but it still adds to the feeling of Qt code being "foreign". These aren't actually extra keywords, they represent features that are associated with the gui library. You can write completely standard c++ code and just use/cast stuff to the QT classes when and if you want to use them. It's your decision whether to use the QT classes at all. You can have a completely standard C++ application and just hook into QT widgets for the GUI. 
I understand there hard problems to solve, no worries there... &gt; That doesn't work in the c++ world unless you mangle the symbols to somehow include the version Agreed (situation is different between Windows and the typical Unix world, Windows dlls offer a bit more flexibility, but not much). Same (similar) thing in .net and Java, and I would guess many others. By the way, these things do not necessarily work in dynamic languages (JavaScript) either! Say that you use an object 'o' from a library 'l', version x, and say that you also have an incompatible version y of 'l' somewhere. If you pass 'o' to the y version of 'l', it's boom! By the way, a similar failure can be achieved with C, as well as with C++. But there, the way it fails is... wow... "mysterious " :-). &gt; What build system do you use? Where I work, we build for one unix flavor and for Linux. Also Windows. For Unices, make, for Windows, msbuild. We build our dependencies by ourselves (that's tangential). We just give the directories to headers/libraries to the build chain[1]. So it's a "manual/homegrown" build (well, for Windows it's the bog standard visual studio build). [1] I do not understand why people fret so much about having modules, build system and whatnot. We have a dozen 3rd party dependencies, some of which we update a couple times a year (well, we update openssl more often :-)). Wanna use a 3rd party lib? Give header and lib directories and lib names, that's all it takes. How is that hard?!
You could experiment with something like segmented deques. For every insert, split into two deques making one an append instead and every now and then perform de-segmenting. On second thought, keeping a list for insertion is probably better. You could coalesce the lists back to contiguous deque, but it'll incur reallocs.
does it support heterogeneous computing? Or we have to compile source code for each different target machine?
The first release of Qt5 was in 2012, well before c++11 support was reliable. They don't break things in minor versions, so anything dropped because the standard dictates a better way be available will have to wait for Qt6. Also, the widget stuff doesn't really make sense without inheritance and most other things in Qt have pretty shallow inheritance. Having inheritance isn't inherently bad. Also, why is a complete framework bad? It keeps the APIs consistent and reduces the time developers need to spend hunting down and integrating small third party libraries to handle stuff.
**Wow!** This is so awesome I first add it to my github stars, I'll check them later. I'll hopefully be able to check it soon. I have been approaching a similar issue very recently. It never went beyond prototyping (~3h spent so far) but the idea was .... Ok, here's the need. We need to verify compatibility of heterogeneous systems with our internal protocol. We have: the legacy server, the next-gen server, the various devices running on microchip pics, the technical tools, the existing client, the next-gen client and the official documentation. Plus we need unit tests for all of those. We have C, (very little) C++, C#, Plain js, Typescript-angular, *a certain microsoft language*, (some, but growing) PHP, plenty of SQL (don't ask). The problem: the documentation was already incoherent with basically all implementations. So the idea was: let's find a way so in theory I can produce the docs by just traversing the code. So I wrote a prototype app which traverses the 'protocol' library and inspects the various packet types with reflection. As for the parsing itself I just go with puppers. I think those are different problems but I'm inclined to believe they are related. I hope to be able to give you feedback on your work by next week.
It does, and qt also has qAsConst() for this
No, it is a culture thing. Compiler vendors for those platforms have more pressure to provide good C toolchains than C++ ones. [CppCast, Embedded Development with Dan Saks](http://cppcast.com/2016/10/dan-saks/) [CppCon 2016: Dan Saks “extern c: Talking to C Programmers about C++”](https://www.youtube.com/watch?v=D7Sd8A6_fYU) 
When I get home I will try to share something.
I'd suspect that a lot more people would pay for a truly modern, lightweight, standards-conforming Qt...
SC = source compatibility. 
With GTK you are basically doing inheritance by hand whenever you have a pointer to a gobject in your class
I wonder how one even manages to use 1000 C/C++ libraries for any project, without descending into a shitshow? Now I am curious how hypothetical this is :-) But I agree that the dependency graph complexity grows easily with the number of nodes. In 1000-space, best experience are probably the likes of linux distro maintenance. Enter gmake, autotools galore :-). As mentioned else-thread, for C and C++, one needs to guarantee binary compatibility. That is **way** over any build or repository system, I would guess, hence it needs a concerted effort of all involved parties. I am dealing, first hand, with much more packages and a package system (nuget, .net codebase, corporate-wide). It's in hundreds (not thousands) packages space, and even though .net ecosystem is **way** more mature on the packaging, one still needs that concerted effort for the projects using the repository. Probably something related to the natural laws of entropy, a cohesive control force must be applied from the outside :-). 
&gt; LGPLv3 states that in header functions should be maximum 10 lines That is not at all what it says. It says if you only use "numerical parameters, data structure layouts and accessors, or small macros, inline functions and templates (ten or fewer lines in length)" from an LGPL work, then you don't have to follow the two requirements listed afterwards.
Insertion into a vector can be fast if you don't need your elements ordered.
Cheers man, will give that a go on Monday!
Huh, definitely checking this out when I get to the office on Monday. What license is this published under? Sounds really fantastic! 
It is true that using std::function would allow type checking the callback signature. But std::function is a heavy hammer to wield for this application. The type erasure also makes calling the function more expensive. The usage profile here is often of lots of calls, so std::function is most likely not the right tool for the job. The Slack discussion mentioned in the acknowledgements included more details about it. 
There is a pretty cool json C++11 library: https://github.com/nlohmann/json
Do you erase elements often? If not, maybe something like 1 vector for front and 1 vector for back would work. So when you need to push front something, you'd push it back to the designated second vector and when you need to read the data you just read from the end to the beginning of that vector first, before reading the "tail" vector. UPD: I see that something similar is already suggested in the comments to the linked article.
In large open source projects, the majority converge onto a flat list of checked in dependencies. These dependencies are then patched so that they build against each other, at the versions chosen. Often, those versions will be out of date to maintain compatibility! Sometimes they'll have a prebuilt binary drop available to help you start quickly, sometimes they just build everything in one go. Either way, it acts very similarly to a "portable" form of the system-wide managers on Linux/BSD/OSX (apt, pacman, emerge, homebrew, macports, etc). Using DLLs/shared libraries allows you a little bit of fudge room (you can static link a completely-encapsulated dependency and hide it), but if you ever want to debug into that process you now have to deal with many subtly different sources for each symbol depending on what particular binary you're inside of. This, of course, doesn't work at all if you want to actually use that library to help you write a rich API (e.g. boost). A few mature libraries do offer the ability to mangle their symbols, supporting side-by-side versions, but this is unfortunately too sparsely supported to rely on it as your primary scheme of dependency resolution (off the top of my head... iconv does this?). In [Vcpkg](https://github.com/Microsoft/vcpkg), we're building a system that looks like apt/brew/pacman/checked-in-sources from your build's perspective but is designed to transition from a prototyping quick-start (system-wide) into a shrinkwrapped bundle (checked-in) once you need that level of control. We focus on providing total consistency throughout your build and ensure that every binary in the process agrees on a single version for each library. Edit: needed even more words 
They have their own QSharedPointer, etc, if you want to use them, but the problem is that it would break *all* the existing code. I ported some apps from qt4 to qt5 and had to change at most a couple hundred lines everyone. Here the whole paradigm would break apart.
You're missing https://google.github.io/flatbuffers/ While it doesn't address all of your points, it is more suitable for embedded development than any of the ones you mention. Most importantly, it is most memory efficient, since you can read the serialized data without unpacking it into C++ objects (zero copy, zero memory allocation). You can read all data without every instantiating a std::string/vector/whatever. Its code (header only) is also an order of magnitude smaller than e.g. protobuf. And while deriving the schema directly from C++ may seem convenient, wait till you have a need to process this data in something other than C++, and you wish you had used a schema-based library instead.
If you are not typing ISO standard C++ how come C++ compilers are able to compile your code ? You know what is signal / slots under the hood ? `#define signals public`
You caaaaan statically link to LGPL code. Source : https://www.gnu.org/licenses/gpl-faq.en.html#LGPLStaticVsDynamic When will this myth die ?
Can't wait to try it out!
What exactly do you mean by "accelerated"? And why do you say that Eigen is not accelerated?
Protobuf makes me sad because I can't make it allocate on a custom heap. :(
I hope this means that SFGUI will work again. The OpenGL context changes in 2.4.1 broke it, and I think they were waiting for a fix in SFML.
You might want to have a look at [Simple Binary Encoding](https://github.com/real-logic/simple-binary-encoding). The format is constrained, but in exchange it's extremely efficient (on x86_64 you just `reinterpret_cast` the Block and then each Repetition in turn).
Good to hear, maybe it's time to check it out again.
By "accelerated" I mean any technique providing faster than regular CPU-bound compiled sequential code, so multithreading, GPU, the use of special SSE hints, and so forth would all qualify to me. Eigen is able to do that for many of its dense operations but not in the sparse case, which is of greatest interest to me. It does provide bindings to other libraries (CHOLMOD, SuperLU, SPQR), but as I noted the API there is somewhat less mature.
How about Elemental? http://libelemental.org
Um...this is best practices not a learning guide.
Page down? Can't get it to load for me.
repl.it is good and does many languages
Uploaded to [CPPAN](https://cppan.org/projects/pvt.cppan.demo.sfml). E.g. [SFML.graphics-2.4.2](https://cppan.org/pvt.cppan.demo.sfml.graphics).
It looks quite promising! Very impressive functionality. I can't tell which of the algorithms are compatible with sparse matrices, though. Are they truly generic?
**From author of the original post** Yes, I may have missed a few of the existing tools, which just emphasises my point. There are so many of the tools available, but everyone has its shortcomings and do not provide **fit all needs** solution. None has became de-facto standard so far. Some tools focus mostly on RPC, others on data serialisation or binary encoding. The ones that do focus on communication protocols, still don't allow picking up **any** of the existing binary protocols and provide a schema for it. There are so many extravagant protocols with weird data formatting that none of the existing tools can be used to implement them. Many tools may allow implementation of 99% of the protocol specification, but there can be one small detail that cannot be implemented without providing extra hand written code. Many of the provided tools don't allow insertion of custom logic. I'm **NOT** saying that the provided tools are useless, far from it. The can be very useful in some particular niche or for specific product types. Many still can be used to generate code for embedded systems when the protocol itself is developed from scratch. The protocol can be defined to be friendly to at least one of these tools. However, the old and existing protocols are a bit different. Take [MQTT](http://mqtt.org/) for example. The flags in the wrapping "transport" data may define existence of the optional fields in the message payload (see **PUBLISH** message definition). Not many of the listed tools are capable of handling this case. The "C++ library" and "code generation" approaches are **not** mutually exclusive. Once any of the existing tools becomes popular and its schema allows full implementation of the required protocol, it is possible to write a "compiler", that generates the code to use the provided library, which in turn provide all the usage flexibility required for embedded systems. The bottom line is that there is a need for extra flexibility in terms of protocol schema definition and generation of the code itself. It is much easier to achieve when manually assembling the protocol definition out of various existing building blocks (out of provided generic library) and inserting small chunks of extra custom ones (read **types** and **classes**) and coding logic if needed.
Now that VS is side-by-side--that is, you can have N installs of VS 2017 on the same machine--the VS150COMNTOOLS environment variable doesn't make quite as much sense. There is no single instance to point to. This blog post explains how to programmatically locate all VS instances on a machine: https://blogs.msdn.microsoft.com/heaths/2016/09/15/changes-to-visual-studio-15-setup/
There are other implementations that allow it. I use nanopb and it does well in embedded. 
Although I like the idea of a library letting me specify how the protocol should be implemented without having to write it whole (basically a Boost.Spirit but for messaging protocols), I'm not sure if your library is the best solution for that. I took a quick look at the documentation and tests but it's not very convincing to me so far (not much simplification allowed by C++11, why even use inheritance here? etc.) Anyway, if you look for C++ experts experimentations, you might want to drop an email in the Boost mailing list. Even if not to propose this library for review, it's a good place to get feedback about general solutions like this one.
Well erases at the end (front/back) would work just fine (pop_back). Erases in the middle would be a bit trickier to handle and would have worse complexity.
Yay! I'm taking a CUDA course at Uni right now and when the Professor said we *had* to install VS2013 I died a little inside. I'd gotten too used to VS2017 at work, and was having too much fun with the newer compiler and C++14 :c I have to use 2015 still, but its good to know that 2017 support is at least somewhere in the pipeline at Nvidia
There'll be issues when the erases make it to the middle from one end. Although the cost of rebalancing the vectors probably isn't that extreme assuming erases from each end are *generally* balanced.
What if you used a basic_string and a stack based allocator? https://howardhinnant.github.io/short_alloc.h
I'm not sure if by `realloc` you mean a call to the `stdlib` function, but if so, it's worth pointing out that `realloc` is only valid for trivially copyable types.
&gt; Most importantly, it is most memory efficient, since you can read the serialized data without unpacking it into C++ objects (zero copy, zero memory allocation). Actually this is true for Cap'n Proto, which he did mention and at least builds on ARM.
It does optional fields with 0 sized vectors, or with a union of a type and void. It just lacks explicit syntax, and the FAQ explains why they're a misfeature. Other than that not sure what you mean by same level of forwards/backwards compatibility, AFAIK the guarantees are the same.
I used this site for a while a few years back off and on, but my attention span wasn't very good back then. Nevertheless, what I made it through (which wasn't even much compared to how much is on there) turned out to be everything I would later learn in a first year university course on C++, and it explained it better than the prof did. I think that goes to show the effectiveness of the site, it really is awesome.
If you have a lot of unused fields in Cap'n Proto, you end up with a lot of zeroes on the wire (a bloated representation) or an optional compaction step (lack of zero copy / read only). FlatBuffers doesn't have this problem.
By "generic" I mean this: can a sparse matrix be used in every algorithm that a dense matrix can? Without being first converted to dense and then used? It often turns out that you code algorithms for sparse matrices quite differently to the dense versions.
You might want to mention what OS you are running on the D21 - if any, and assuming the SAM+bluetooth module are on some kind of evaluation board, which one. Else, I don't think anyone will be able to help you. As the SAM D21 is a Cortex-M0, I doubt you will run an OS that has support for Qt. There are some, like INTEGRITY RTOS, but only few, so I guess Qt won't help you. If you are using Atmel Studio with the Atmel Software Framework, you can check for a driver here http://asf.atmel.com/docs/latest/index.html
As mentioned before, there are overloads for sparse and dense matrix types, and distributed matrices (with mpi). Matrix types are template classes which template over the coefficient type of the matrix, and in the distributed setting how you distributed the entries of the matrix across a cluster. There are then overloaded algorithms for each matrix type, for most things. So in that sense yes. However, there may be some missing functionality. (edit: PR's accepted)
This is awesome. Now if only someone could figure out an ergonomic way to get data into C++...
Thanks, I've read through this now, but I'm afraid it's not helpful for my use case. I simply want to run `cl` and `cmake` from a `cmd` shell, and so being able to find the installation programatically isn't helpful for this case. I just want the equivalent to calling `vcvarsall x64` to set things up, nothing more than that.
I second that! The lecture on how to do tag-dispatch was brilliant, and I totally... appropriated it. How about something about how to use modern C++ to find out if a function with a specific signature exists and how to invoke it? Stroustrup's 4th edition has something on that but it's ooooooold...
That's the definition of a mathematical functor. Functors in c++ are something completely unrelated to [ML](https://en.wikipedia.org/wiki/ML_(programming_language\)) stuff (which is what the OP is referring to).
&gt; How does build2 deal with diamond dependencies? &gt; &gt; App 1.0 -&gt; Foo 1.* &gt; &gt; App 1.0 -&gt; Bar 1.* &gt; &gt; Foo 1.0 -&gt; Base 1.0 &gt; &gt; Bar 1.1 -&gt; Base 2.0 &gt; &gt; Where Base 1.0 and Base 2.0 are incompatible. There is no magic here, `bpkg` (`build2` package manager) will simply not able to satisfy the dependencies. There are several way to make it work, however: 1. If Base 1.0 and Base 2.0 are incompatible, then it may make sense to call Base 2.0 Base2 or use versioned namespaces (together with inline namespaces) so that the two can co-exist. 2. Foo and Bar may choose to *embed* Base as their implementation details. This is an idea we've been think about for some time. Note that there is still no magic ;-). Imagine if Foo and Bar use Base in their interface. Say Foo has `base::data foo::f()` and Bar has `void bar::f(base::data)` and App wants to "pipeline" the two: `bar::f(foo::f())`. If Base used by Foo and Bar are incompatible, there is nothing you can do to make this work short of manual translation. &gt; Also, with build2, what is actually in the package? Just source code? Yep. &gt; Do you need to recompile everything every time? If you get a new version, then yes, you build it from scratch (with the exact version of the C++ compiler, libraries, compile options, etc., that you use). &gt; Does it do binary caching (produce static libs for a small set of common options - latest version of compilers and sdks for that platform). Nope. I am still surprised people want to do that. We used to say this worked in the non-Windows world, but not anymore, after the GCC dual ABI fiasco. 
That the C++ community sometimes refers to function objects as functors is as confusing as if we used "functions" for classes. EDIT: compare how future/promise is swapped in JavaScript, these small obfuscations are unnecessary and just makes it more difficult as a beginner. 
You need to create a dedicated VS project - "Visual C++ -&gt; Cross Platform -&gt; Linux". If it's not there, there should be an option to install it. If not, just google for it and download it. The rest is just basically configuring your project correctly, and starting your build. A popup like this: http://i.imgur.com/HLsjqYp.png will popup, you enter the details of the remote server, and it works. Keep in mind, it's quite slow so far, as it basically copies over all the source files needed to build to the remote server and builds there. Debugging is also very slow. But other than that, it seems to work. There are some small things you will probably need to change/fix on the server side, but other than that, it's fairly straightforward.
I might be overlooking some functionality, but I'm looking for a C++ matrix (well, multi-dimensional array) library and I've still not found one which matches my needs well. The examples here and those mentioned in the comments don't seem to meet all the criteria: - arbitrary numeric data types (templated) - arbitrary number of dimensions at run-time (compile-time also desirable but optional) - can be chunked in n-dimensions, with optional sparseness for the chunks (i.e. tiling in 2D, generalised to nD) - allows subsetting of the dimensions at runtime, either of all the range in any dimension or removing dimensions entirely - c++11/14 style preferred - doesn't drag in some monster framework along with it I'm currently using Boost.MultiArray, but it's compile-time only which is nice for some cases, but I need run-time flexibility as well. Ideally I also want the indexing calculations decoupled from the storage so I can use them independently. Boost.MultiArray doesn't decouple it. I've started writing my own library for this purpose, but if there's anything out there I could use directly that would be a massive time saver, and likely better performing.
Regarding UB and why optimizers take advantage of it: it all boils down to the Halting Problem. C and C++ have been crafted to let the developer squeeze the last ounce of performance out of the system (1). The optimizer therefore takes the hands-off approach that the developer knows best, and considers that if something triggers UB, what it really means is that at run time it will never be executed. The optimizer does not TRY to prove that the situation cannot ever occur (2), it *assumes* the developer took the necessary steps so it would never occur. This sometimes result in very surprising optimizations. *(1) There are some cases where I think it failed, but it's always easy to criticize in hindsight.* *(2) Proving that the situation never occurs could be very complicated, expensive, and ultimately is fruitless because of the Halting Problem.*
It's confusing to c++ beginners who come from a mathematical background in category theory. Arguing that an experienced C++ programmer finds this terminology confusing because they know of a similar concept in math is plain wrong. I know both concepts and I am very well able to distinguish between the two depending on a context. Hell, there are different areas of math that share the same words with different meaning. Do you think researchers in these areas are confused by that?
&gt; , because technically it wouldn't be the same app Where does the LGPL states that it "has" to be the same app ? It says in the GPLv3 text : &gt; “Installation Information” for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of **the modified object code** is in no case prevented or interfered with solely because modification has been made. The modified object code, ie. only the LGPL part, will keep running in your software without problems. And in the LGPLv3 text, to comply, one of the possibilities is to do the following : &gt; 0) Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version **to produce a modified Combined Work**, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source. In your example "for example if an intent was sent to the app, the original would receive it, and not the newly compiled version", this would be handled in the proprietary part of the code on which the LGPL has absolutely nothing to say. Maybe the proprietary code does a `rand()` every time you launch it and won't work when it's equal to 9.
I think this is a good article, especially the "out of bounds access" example. Note that with optimization turned off, the compiler will likely not replace that "i&lt;8" condition by "true", which means that this UB might only appear in release mode. Cases like this make C/C++ UB even more scary. 
The comparing pointers thing is ugly. Many standard C++ algorithms/containers only work with pointers since std::less for pointers does not have this limitation. Edit: As pointed out it is unspecified in C++ not undefined. You still have to use std::less either way. 
I'd say it's the other way around, as a C++ programmer it can be confusing when you come across the use of functors in other languages. It's just like how promise/future are swapped in JavaScript compared to other languages. Sure once you know about it, it's fine, but as a beginner it can sure be confusing.
I was not sure about this point. But to be honest. I don't like the term concepts lite. Because they are not lite. But I also don't like the term concepts because we have to distinguish them from the classical concepts.
The problem is not in taking advantage alone, it's in taking advantage without notice. By the same reasoning there shouldn't be warnings of any kind, because the developer knows best.
Have you looked at [Eigen Tensor Module](http://eigen.tuxfamily.org/dox-devel/unsupported/group__CXX11__Tensor__Module.html)? Edit: more readable documentation [here](https://bitbucket.org/eigen/eigen/src/9b065de03d016d802a25366ff5f0055df6318121/unsupported/Eigen/CXX11/src/Tensor/README.md?at=default&amp;fileviewer=file-view-default)
That would simply be too many warnings. Every signed int addition may overflow and trigger UB.
Rather than repeated myself, I'll just link to my previous comment: https://www.reddit.com/r/cpp/comments/5tlnkr/undefined_behavior_in_c_and_c_programs/ddni0a6/ Regarding UBSan and co, note that those are not compile time warnings, but run time instrumentations. The instrumentations occur *before* optimization and will inhibit a number of potential optimizations (for example, addition will be checked instead of assuming it cannot overflow). UBSan is probably the least costly sanitizer, memory and performance wise, and yet the degradation is important.
So it's not possible to have 1 vcxproj that can switch between Win and Linux using the dropdowns for config+platform?
Essentially, every signed integer arithmetic operation takes advantage of UB. Do you really want a warning about that?
You can avoid it like so: https://google.github.io/flatbuffers/flatbuffers_internals.html It keeps offsets like you say, but they're small, and shared between similar objects, so their total overhead trends towards zero. Having to go through a compressor means making a copy. That precludes zero-copy use cases (where something comes in over the network and you read it directly in the buffer it arrives in) or read-only use cases (where you have a large amount of data in ROM or mmap()-ed in, and you only want to access part of it). The OP clearly cares for embedded use cases where this may matter.
While not really feasible - I wish compilers were default -Wall (and I mean **all** not just Wall). And address sanitizer - and ubsan as well.
It looks interesting, thanks. Unfortunately, it has the same limitation as Boost.MultiArray in that the number of dimensions (indexes) is a template parameter, meaning it can't dynamically vary the number of dimensions at runtime. I'll certainly take a closer look though; at a minimum it might be a nicer replacement for our existing Boost.MultiArray usage if it has a nicer API and better performance.
Functors in programming are a generalization of the [map](https://en.wikipedia.org/wiki/Map_(higher-order_function\)#Generalization) higher-order function. This article [here](https://bartoszmilewski.com/2015/01/20/functors/) by Bartoz Milewski explains the mathematical background and their uses in programming. The answer in SO focuses on functor's uses in C++, which is what the question was asking for. The rest of the answers focused on how to create function objects, which is useful for higher-order functions, however, none of the other answers explained what a functor is, and how it can be used in C++.
I realize some are, but do you think [these](https://www.reddit.com/r/cpp/comments/5tlnkr/undefined_behavior_in_c_and_c_programs/ddni49l/) are in the same category? Like [this for example](https://www.reddit.com/r/cpp/comments/5nbfep/emi_testing_finding_1000_bugs_in_gcc_and_llvm_in/dcge999/?context=1).
Same point long long int has on systems that make both it and long 64 bits wide, the standard requires that both types exist. 
Binary compatibility. Once upon a time, Windows 3.1 ran in a mixed 16/32-bit mode where int was 16 bits and long was 32 bits.
As far as I am aware, no, but I could be wrong.
This is off topic for /r/cpp.
Oh, I don't mean to say that compilers could not do better. My understanding of what Chris says is that the optimizer is the wrong place to emit such warnings; because by the time the code reaches the particular optimization pass it's been mangled beyond repair already... and what you see as potential UB might actually be an artifact of the transformation. I think instead that UB should be detected, as much as possible, by static analysis tools. The other advantage of using separate tools is that it does not slow down compilation further. C++ compilation is already slow enough as it is.
Thanks! I had that one starred on GitHub, but I haven't taken a closer look yet.
I think one way to avoid some of these problems is to expect the program to crash whenever there is an UB, rather than anticipating what usually happens as a result of an UB (e.g. integer overflow). This way you wouldn't write code such as int a = x + 1; if (a &lt; x) { // error ... } 
In the UB talk by Chandler Carruth, he mentions how the compiler can emit better instructions when signed integers are used. How should a warning like that look like? In fact, shouldn't there be warning, when the compiler fails to invoke an optimization?! Think of the possibilities, if we had the latter.
I don't think we do, as classical concepts were never released. You can always refer to them as "classical" if needed. The only concepts now are the ones formerly known as "lite".
Agreed, but [as I was saying](https://www.reddit.com/r/cpp/comments/5tlnkr/undefined_behavior_in_c_and_c_programs/ddnnl7m/), independent static analysis may not match the level of analysis the compiler applies on performing such optimizations, despite yep, at that phase it may be far from the original code format. Still, this area can possibly be improved.
I have these two links: https://github.com/ben-strasser/fast-cpp-csv-parser https://www.codeproject.com/articles/741183/cplusplus-minimalistic-csv-streams
"captcha farm". If you're not imagining it already, google it. It's spam. 
It seems to me that vectorizing general sparse matrices would be a very difficult issue because you wouldn't have any structure to exploit.
Thanks so much !
yeah but what I am studying and what I plan to study in the future does not have anything to do with it. Don't feel like there is anything wrong with it, someone gets payed a decent amount of money for little work and I get to avoid taking a very difficult and class that has nothing to do with what I'm studying and I have zero interest in.
I will name my son after you and you will have a statue right above my house.
Expecting a crash is bad; e.g. the null pointer dereference example. Some programmers think that a segfault is guaranteed in that situation and are then surprized when the optimizer removes half their code. 