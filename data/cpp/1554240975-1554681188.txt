Again, we are talking about an actual library intended for all clients, not just C++. All those features are meaningless in this context. But even if you just targeted C++ clients, we are talking about an actual compiled library here; not just header-only/inlined C++. `template` and `constexpr` are compile-time features, so that is non-sense. Throwing exceptions through library boundaries is also a nightmare. Keeping a C++ stable ABI is way harder than a C one, too. And if the library is not open-source, all this becomes even worse. There is a reason why header-only C++ libraries are a thing.
Not a criticism of your blog article (which was incredibly helpful and information), but this explanation of modules makes them seem overly complicated without describing the benefit of this complication. As someone whose job involves dealing with a lot of corner cases in C++ code, as I read each successive section, I couldn't help but ask myself: "but, why?" Why do we allow for such craziness as exporting part of a namespace, or exporting a type but not its members? These definitely seem like interesting ideas, but added onto a language like C++ where there's already so much going on, I feel like they will end up misunderstood and misused, or not used at all.
In my experience, disabling the source control plugin provides a noticeable improvement. 
Is there any sample on how to interface with xcb?
could do something like struct Vector { float v[3]; float&amp; x = v[0]; float&amp; y = v[1]; 
We're still working on getting all of the release notes updated, but here are the highlights for the STL: * C++20 [P0550R2](https://wg21.link/P0550R2) `remove_cvref` is complete. * C++17 `&lt;charconv&gt;` floating-point `to_chars()` has been improved: shortest `chars_format::fixed` is 60-80% faster, and shortest/precision `chars_format::hex` is complete. * More algorithms have parallelized implementations: `is_sorted()`, `is_sorted_until()`, `is_partitioned()`, `set_difference()`, `set_intersection()`, `is_heap()`, `is_heap_until()`. * Improvements to `std::variant` to make it more optimizer-friendly, resulting in better generated code. Notably `std::visit()` and the inliner have now become good friends. * We've applied clang-format to the STL's headers for improved readability. * Improved throughput compiling several standard library features using `if constexpr`. * Optimized the standard library physical design to avoid compiling parts of the standard library not `#include`'d, cutting in half the build time of an empty file that includes only `&lt;vector&gt;`. * `allocator&lt;void&gt;`, `allocator::size_type`, and `allocator::difference_type` have been un-deprecated to reflect the current Working Paper. * A `static_cast` in `basic_string`'s implementation has been removed; this was suppressing [C4244](https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-levels-3-and-4-c4244?view=vs-2019) truncation warnings. Emitting these warnings is now by design; various workarounds are possible to avoid/suppress such warnings. * Various C++17 `&lt;filesystem&gt;` fixes.
VS is so inextricably tied to the windows platform, it’s hard to imagine that it’ll happen. But never say “never”
&gt;Notably std::visit() and the inliner have now become good friends. So happy to see this!
It automatically figures out the files involved for a given project through header dependency analysis. It understands how to compile loadable text and resources for projects that have them, and how to invoke the IDL compiler to generate content for projects that define such. It typically takes only maybe 10 to 20 lines to configure a given project to build. &amp;#x200B;
I was doing that when I was using older versions of VS, but I stopped starting with VS2015 because it wasn't worth the impact on global performance AND intellisense went to become bearable (after a lot of updates). 
I'm looking for preferably full time work in the Seattle/Eastside area. I'm a Linux/Unix guy, mostly focused on systems and server programming, but I pick up stuff fast and I'm flexible. Strongly prefer a C++11 or better ecosystem, and smaller to midsize companies.
So I can just keep calling push\_back on an image? How does it expand, width or height? What aspect ratio does it hold? What do "empty" pixels get initialized to when a new row/column gets added?
**Company:** [Esri](https://www.esri.com) **Type:** Full time **Description:** Our passion for improving quality of life through geography is at the heart of everything we do. Esri’s geographic information system (GIS) technology inspires and enables governments, universities, and businesses worldwide to save money, lives, and our environment through a deeper understanding of the changing world around them. Bring your passion for C++ to help us develop a cross platform GIS API that runs on the latest mobile devices using the latest compilers and C++ standards. This is a great opportunity to design and develop next-gen Esri technology. This posting is for recent or soon to be college graduates and those just starting out in their career. **General Requirements:** * Experience with C++, C#, Java, or another object oriented language * Willingness and enthusiasm to learn modern C++, the standard library, and multi-paradigm software development * Willingness and enthusiasm to write high performance and high quality software * Understanding of algorithms * Ability to work closely with small teams * Effective time management and organizational skills * Excellent written and verbal communication skills * Bachelor's in computer science, engineering, mathematics, GIS, or related field **Bonus points for experience with:** * 1 or more years on a commercial or open source software project * Bash or Python * GIS * Graphics programming * Generic programming * Concurrent or parallel programming **Location:** Portland, OR, Edinburgh, UK, Redlands, CA **Remote:** No **Visa Sponsorship:** Yes **Technologies:** * C++14 (moving to C++17 soon), Boost, Qt * LLVM/Clang, Xcode, VisualStudio * Git, Github * Jenkins * Bash, Python3 * OpenGL, OpenGLES, DirectX11, Metal * Both Esri and open source GIS technologies and standards **Contact:** [www.esri.com/careers](https://www.esri.com/careers) is the best route. Some questions can be answered in the thread.
What are the chances of pulling a Google and discontinuing support for it?
You don't. One person has to, and everyone else gets it for free. 
I'm actually thankful for Berium to have bashed the uneducated because that's a chore i can't stand anymore since last september.
**Company:** [Esri](https://www.esri.com/) **Type:** Full time **Description:** Our passion for improving quality of life through geography is at the heart of everything we do. Esri’s geographic information system (GIS) technology inspires and enables governments, universities, and businesses worldwide to save money, lives, and our environment through a deeper understanding of the changing world around them. Bring your passion for C++ to help us develop a cross platform GIS API that runs on the latest mobile devices using the latest compilers and C++ standards. This is a great opportunity to design and develop next-gen Esri technology. This posting is for experienced developers. **General requirements:** * Demonstrable knowledge of modern C++ and the standard library * 5+ years of commercial or open source software development experience in C++ or another unmanaged language, preferably in multi-paradigm codebases * Experience with object-oriented, data-oriented, and generic design * Willingness and enthusiasm to write high performance and high quality software * Experience with design and implementation of algorithms * Experience with concurrent and parallel programming * Experience with development and debugging on macOS, Linux, or Windows * Ability to work closely with small teams to build quality software * Effective time management and organizational skills * Excellent written and verbal communication skills * Bachelor's in computer science, engineering, mathematics, GIS, or related field, depending on position level (master's preferred) **Bonus points for experience with:** * Bash or Python * DevOps, continuous delivery and integration with automated testing * GIS * 3D graphics programming with OpenGL, DirectX, Vulkan, or Metal * Software architecture and design **Location:** Portland, OR, Edinburgh, UK, Redlands, CA **Remote:** No **Visa Sponsorship:** Yes **Technologies:** * C++14 (moving to C++17 soon), Boost, Qt * LLVM/Clang, Xcode, VisualStudio * Git, Github * Jenkins * Bash, Python3 * OpenGL, OpenGLES, DirectX11, Metal * Both Esri and open source GIS technologies and standards **Contact:** [www.esri.com/careers](https://www.esri.com/careers) is the best route. Some questions can be answered in the thread.
I don't know. It should be noted that it's never been really "supported".
Great, now tell me how to contact the clang and gcc maintainers so we can get the improved mpark variant implementation that does the same into the standard libraries :-(.
If I am not mistaken, I believe mpark is also the author of the std::variant in libc++?
Hey, /u/DizzyCustard ! Recent CS grad from the Portland area. I cannot find this position on your site (filtered by Portland, OR). Do you have the title available?
**Type:** Either full or part time. I'm just eager to break in to the industry. **Description:** Recent CS grad who focused on C/C++. Plenty of projects under my belt and am currently working on some more in my spare time. **Location:** Portland, OR at the moment. I'm interested in staying in the Pacific Northwest, but I'm open to other locations if the job sounds interesting. **Remote:** I've worked remotely before and am willing to do it again. **Technologies:** C/C++/C# Linux/Windows primarily. I'm comfortable with a number of the Boost libraries. Additionally, I have experience with Javascript (Node, Express, and Angular primarily) and have tinkered with just about everything else. **Contact:** DM me and we can talk. 
Here's the [vod](https://www.youtube.com/watch?v=PVYdHDm0q6Y) of the talk.
That is impressive.
*/rant
Do you guys contract with Sandia?
Is it finally ISO-conformant now without needing special compiler switches? Does this work: int main() { return not true; }
Interesting, it was up when I looked at the end of last week. I'd suggested following up with the posting at [https://www.esri.com/en-us/about/careers/job-detail?req=9984&amp;title=C++%20Software%20Engineer%20-%20ArcGIS%20Runtime](https://www.esri.com/en-us/about/careers/job-detail?req=9984&amp;title=C++%20Software%20Engineer%20-%20ArcGIS%20Runtime) and I will let our recruiting team know why the discrepancy exists on an incoming application. In the meantime I will also check with the recruiting teams to also figure out why the college grad posting disappeared. &amp;#x200B; Disclaimer: I work in engineering, so the inner workings of recruiting are a black box for me.
WDK support?
The standard doesn't define the compiler interface, so it's entirely standards-compliant to require those flags to enable ISO646 operators.
This still requires the compiler option for strictness, `/permissive-`. We're working towards enabling `/permissive-` by default. Both our own SDKs and third-party code have needed conformance changes. I recommend compiling with `/std:c++17 /permissive-` even if you aren't using C++17 features, as C++17 mode activates additional strictness in the Standard Library (including but not limited to feature deprecations and removals).
I tend to agree with you. But unfortunately many algorithms in C++ require Regular types, at least on paper. Without this, it'll be tedious to difficult with preexisting code. Arthur goes into examples where DefaultConstructibility is merely a soft requirement: https://quuxplusone.github.io/blog/2018/05/10/regular-should-not-imply-default-constructible/
If you are not giving specific values to your enums, an extra "Count" value can do the trick
I will point out that they say they have improved performance with 2019.
https://en.cppreference.com/w/cpp/header/ciso646
I think your problem will be that the desktop usage for Linux is small and there are many distros that complicates distribution. That said I am pretty sure Monodevelop supported linux and VS for Mac is monodevelop reskinned and given some love. 
There are several VS versions that run with Wine, at least the compiler does. Some people use that to cross compile to Windows from a Linux server.
I’ve never seen it refer to either of those things before in a general context. Physics libraries are physics libraries (you might see “dynamic particles” or “dynamic cloth” though) and the second thing you mentioned is a JIT although one popular specific instance of a JIT support library is called DynASM from Mike Pall. 
``` #define ENUM(id, ...) enum class id : size_t { VAR_ARGS, size } ENUM(colors, red, green, blue); constexpr size_t enum_size = colors::size;
It is a good read if you're actually interested, but IMO you don't need to know the majority of this stuff. The important things to know about memory are pre-fetchers, cache sizes, cache lines and cache invalidation. And perhaps the memory allocation strategy of the various OSes that can surprise you (memory allocation always succeeds, but fails at the point of usage.)
That's just how I was referring to those keywords, I wasn't trying to imply it was a library feature. Apologies if I wasn't clear. My point was that needing additional flags doesn't mean a compiler isn't compliant https://stackoverflow.com/a/42131209
Of course not!!
They always say that. It’s still a lot slower than 2008.
Unless you're also using a computer from 2008 then no, it isn't. WPF relies on having a competent GPU, and everything non-rendering related has improved significantly since 2008.
Also colors::size would have to be casted to size_t.
C# isn’t too bad, but VS seems to get slower and slower with C++. I will try with all Extensions disabled to find out whether VS itself is responsible.
&gt; I've never seen that. That may be, but if you google [dynamic library](https://www.google.com/search?q=dynamic+library&amp;rlz=1C1GCEV_enKR826KR826&amp;oq=dynamic+library&amp;aqs=chrome..69i57j69i60j0l4.2822j0j7&amp;sourceid=chrome&amp;ie=UTF-8) the entire first page is talking about shared libraries. It is clearly the dominant meaning for that term.
He is, just having trouble getting the improved (read: more inlinable) version of visit in. Oh well, I'll get them eventually.
Unscoped enum would work. If scoped enum is necessary than explicit conversion comes with the territory, as scoped enums were partly created to address strong typing concerns (name clashes or unintended implicit conversions).
And included in every switch statement if you want the incredibly helpful "enum not handled in switch case" warning.
works great until you want one with the name 'size' in it.
in some cases you can do \`inline static\` initialization and you won't have this problem. Depends on the structure of you project and how your interface and implementation are split.
definitely has it's issues, I probably wouldn't use this personally. BTW, you spelled bad wrong. :p
I tried running the benchmarks myself, and I think I am pretty close, but when I run the ruby script I just get errors: ERROR 1: bench_boost_unordered_map__IdentityHash CtorDtorEmptyMap ERROR 1: bench_tessil_sparse_map__absl_Hash CtorDtorEmptyMap ERROR 1: bench_abseil_flat_hash_map__folly_hasher CtorDtorEmptyMap ERROR 1: bench_ktprime__robin_hood_hash CtorDtorEmptyMap ERROR 1: bench_tessil_hopscotch_map__FNV1a CtorDtorEmptyMap ERROR 1: bench_eastl_hash_map__absl_Hash CtorDtorEmptyMap ERROR 1: bench_folly_F14ValueMap__folly_hasher CtorDtorEmptyMap ERROR 1: bench_greg7mdp_phmap_parallel_flat_hash_map__IdentityHash CtorDtorEmptyMap ERROR 1: bench_abseil_node_hash_map__IdentityHash CtorDtorEmptyMap ERROR 1: bench_greg7mdp_phmap_parallel_flat_hash_map__robin_hood_hash CtorDtorEmptyMap ERROR 1: bench_std_unordered_map__folly_hasher CtorDtorEmptyMap ERROR 1: bench_std_unordered_map__robin_hood_hash CtorDtorEmptyMap ERROR 1: bench_boost_unordered_map__absl_Hash CtorDtorEmptyMap ERROR 1: bench_boost_unordered_map__folly_hasher CtorDtorEmptyMap ERROR 1: bench_boost_multiindex__folly_hasher CtorDtorEmptyMap ERROR 1: bench_eastl_hash_map__FNV1a CtorDtorEmptyMap ERROR 1: bench_tessil_robin_map__folly_hasher CtorDtorEmptyMap ...
Yeah, I've used something similar with templates that have a static member. You can declare them in the header and the linker throws away the duplicates just fine. But in this case I needed them in a single .cpp file so I could guarantee the order.
I've dealt with this in the past and at least for enums that are 0-(N-1), you can set up a "size" variable and do a static assertion that it is correct. It's not great, but at least it's guaranteed to be correct at compile time.
**Company:** (SpotX!)[https://www.spotx.tv/] **Type:** Full time **Description:**SpotX runs billions of video advertising auctions everyday requiring low latency and high throughput using C++17 as its backbone. SpotX is currently in the process of migrating from a PHP 7 marketplace to a fully C++ marketplace, development is about half in new C++ applications/code and the other half migrating PHP code to C++. We are looking for a talented team lead engineer to start building a remote development team in Belfast as well as junior to senior level C++ engineers in Denver CO at our main HQ. **Location:** Denver CO or Belfast UK **Remote:** No **Visa Sponsorship:** No **Technologies:** C++17 (will move to 20 when generally available), PHP 7, Linux (Fedora/CentOS), Cassandra, Kafka. Some devs use Macs if that is preferred. **Contact:** https://www.spotx.tv/careers/ or Reddit PM.
I don't love it, but you could do something like this: class MyEnum { public: enum { A, B, C, last // last can be anything }; using type = decltype(A); static constexpr int size=3; static_assert(last == size); // as long as it matches here }; int main() { MyEnum::type e=MyEnum::C; } It stops you from having to have an entry with a specific name in your actual enumeration, and while it requires having a parallel integer variable, it does guarantee it to be correct.
I suggest a constexpr integer with the size and then a static_assert that the value of that int matches a placeholder last entry in the enum. It sucks you have to make a change in two places, but the compiler will tell you if you forget, so it's just annoying, not dangerous.
so we can't talk about c++ in /r/cpp now?
Nice necro, bud
Any improvement on intellisense? Would it handle unreal source? Would it crash less?
I managed to run the benchmarks locally. How do you generate the graphs for them?
just check the source code. It's other way around.
Here is a (still bad) solution to the desire to have a `size` enum name. #include &lt;boost/preprocessor/variadic/size.hpp&gt; #define ENUM(id, ...) enum class id : std::size_t { __VA_ARGS__};\ constexpr std::size_t id##_size = static_cast&lt;std::size_t&gt;(BOOST_PP_VARIADIC_SIZE(__VA_ARGS__)) ENUM(colors, red, green, blue);
Why do I need a competent GPU to run an IDE? What's next, enable RTX to have readable fonts? An SLI setup to have smooth scrolling?
Here's something along those lines that doesn't add an extra variant: https://ideone.com/EAiYVw #include &lt;iostream&gt; using namespace std; template&lt;typename T&gt; constexpr size_t variant_count() { return 0; // or throw, or abort } // https://stackoverflow.com/questions/12024304/c11-number-of-variadic-template-function-parameters #define PP_NARG(...) \ PP_NARG_(__VA_ARGS__,PP_RSEQ_N()) #define PP_NARG_(...) \ PP_ARG_N(__VA_ARGS__) #define PP_ARG_N( \ _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \ _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \ _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \ _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \ _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \ _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \ _61,_62,_63,N,...) N #define PP_RSEQ_N() \ 63,62,61,60, \ 59,58,57,56,55,54,53,52,51,50, \ 49,48,47,46,45,44,43,42,41,40, \ 39,38,37,36,35,34,33,32,31,30, \ 29,28,27,26,25,24,23,22,21,20, \ 19,18,17,16,15,14,13,12,11,10, \ 9,8,7,6,5,4,3,2,1,0 #define ENUM(id, ...) enum class id : size_t { __VA_ARGS__ }; \ template&lt;&gt; \ constexpr size_t variant_count&lt;id&gt;() { \ return PP_NARG(__VA_ARGS__); \ } ENUM(colors, red, green, blue); constexpr size_t enum_size = variant_count&lt;colors&gt;(); int main() { cout &lt;&lt; enum_size &lt;&lt; '\n'; return 0; }
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/b8t4kl/learning_c_help/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Elaborate. 
Congrats! Just curious, my company bought my license (VS2017 Pro just from the MS Store) just 1.5 weeks ago - is there a free upgrade I can get?
Why do you need to downvote me for making an empirically-correct observation regarding the renderer? I didn't write the code, so you're directing both your questions and your animosity in the wrong direction.
Reflection. One day.
Why would they do that? The release date of VS2019 was announced months ago
And here is a simpler alternative: ``` template&lt;auto... Es&gt; constexpr size_t enum_size_impl() { return sizeof...(Es); } #define ENUM(id, ...) enum id : size_t { __VA_ARGS__ }; \ constexpr size_t enum_size(id){ \ enum local_e { __VA_ARGS__ }; \ return enum_size_impl&lt;__VA_ARGS__&gt;(); \ } ```
It isn't even remotely correct. Visual studio 2017 is split up in to all sorts of services and servers written in JavaScript. Things that used to be fine now have significant lag on the same computer. It has nothing to do with GPUs.
Fuck no
I tried that but couldn't figure out a way to get it to accept the undefined variables. Using an unscoped enum to define them all is a good trick.
&gt;The installer still shows only the preview version for me The way VS installations work is they tie you to a specific update channel. The two main ones are preview and release. If you were running a preview VS build, it will still keep you on the preview channel, meaning you will get more frequent updates that include things that are still not 100% polished. If you run the release channel, you will only get the final build of each update. I think right now we updated the release channel to the final v16.0 of VS, but the preview channel should still basically have the same stuff until we have a 16.1 preview available. Also VS 2019 is a different installation as far as I know from VS 2017 as well, so if you were using VS 2017 before you will need to choose to download VS 2019 from [visualstudio.microsoft.com](https://visualstudio.microsoft.com). 
&gt;Disabling IntelliSense entirely and getting VisualAssist is also a great way to make the whole thing faster I would love to follow up to learn more about the IntelliSense performance issues you're experiencing. We're trying to collect some data from VS users so we can improve that going forward. Do you have a particularly large codebase? 
&gt;C# isn’t too bad, but VS seems to get slower and slower with C++. I will try with all Extensions disabled to find out whether VS itself is responsible. We automatically detect slow extensions now in VS and issue a warning via a gold bar at the top of the editor. That's a good way to tell if the extension is the problem or if it's something in the native product. If it is a VS issue though, please file a bug report on: [https://developercommunity.visualstudio.com/spaces/8/index.html](https://developercommunity.visualstudio.com/spaces/8/index.html). We spend a lot of engineering cycles improving performance and we know this is important to our users. Would love to hear your feedback there so we can make a better product for you! :) 
&gt;Any improvement on intellisense? Would it handle unreal source? Would it crash less? We have IntelliCode and C++ template IntelliSense improvements in VS 2019 and we work on bug fixes/performance/stability with each update (major and minor). Regarding Unreal, what are the issues you are encountering currently? Unreal Engine should be supported in the product. 
&gt;Is it finally ISO-conformant now without needing special compiler switches? You still need to opt into the permissive- switch to get the most complete and standards conformant compiler implementation. We do want to make that on my default at some point in the future though (not sure on an ETA yet). 
 enum Foobar {foo, bar, baz, quz, FOOBAR_NR_ITEMS}; Foobar foob[FOOBAR_NR_ITEMS]; 
Only the renderer has to do with the GPU; that was rather my point, thanks. In addition to "splitting things up in to all sorts of services and servers written in JavaScript" they've also done things like change the Intellisense engine to use an entirely different compiler front-end and change myriad things to be asynchronous rather than block. I didn't use the word 'empirically' at random.
I don't know the answer, but perhaps /u/TartanLlama does. We try to make it really clear when a new major version is on the horizon, with Previews and Release Candidates, plus announcing the release date in advance when it's known for certain, but we don't stop companies from buying the old product at the end of its cycle.
wrong place. you're looking for /r/cpp_questions/
Necessity
Code generation. Today. 
It's like twice as fast this time try it
I remember being so impressed at the simplicity of this solution in the PintOS codebase in college. Been using it ever since.
You're fully right of course, but I feel it defeats the whole purpose a bit ... [if you have to start casting the enum values to their underlying type the whole f'in time]. I tend to just put an unscoped enum in a struct and be done with it.
I'd argue this is a more robust solution conceptually as it allows you to specify values while still automatically computing a size. I don't know what you'd use it for in that case, but it's interesting.
Too big ego guys. Should be titled CMake support for Abseil, not the other way around 😆
“Worth it is relative.” For $1000 you can go to CPP Con. Also, if you can get s job/pay increase using C++ paying more than $1000 then it’s probably worth it. I find the value of most education is that it’s structured, forcing you to learn. As in exercise, anyone can do push ups or get a pair of shoes and start running but paying for a personal trainer gives external motivation and hopefully provides food form. The syllabus seems a bit iffy to me. I’m a python programmer interested in CPP. I work at the high level so much I’m curious about the low level. I’d like to see more topics like memory management — smart pointers are listed but not much else so it seems shallow. Also template programming and the STL are powerful but not mentioned. 
Compile time introspection is badly needed in C++. There are millions of lines of code written annually because C++ lacks this feature. 
It's something I rant about fairly often as well. So much time and effort has been put into a massively over-engineered collection scheme but some very fundamental stuff is still missing. Here is how I deal with the enum issue, and make them very powerful (this was made before I did a massive binge to convert the whole code base over to the new 'enum class' type enums.) [https://www.reddit.com/r/programming/comments/a33i7n/making\_c\_enums\_first\_class\_citizens/](https://www.reddit.com/r/programming/comments/a33i7n/making_c_enums_first_class_citizens/) &amp;#x200B;
Meta class. Someday.
And*
how so ? most toolchains I have in my computer are in custom folders in my home, I fail to see how distributing those as packages would help anyone more than e.g. the toolchains provided by [polly](https://github.com/ruslo/polly) in the cmake world
With VS2017 I could have installed preview and release side by side. And both VS2017 as well as VS2019 preview can be installed via the same installer. Why is VS2019 rtm suddenly different?
Hi, CMake 3.14 support is coming in Update 1 of Visual Studio, I know Dev16 just went out, but Previews of Update 1 should be out for not too long, we have a way in CMakeSettings.json of configuring the path to your own CMake, but due to a bug where we always append Win64, that workaround, as you find out, wouldn't work, sorry about that. I will check to see if another workaround is possible and I will let you know.
You occasionally have to add a bit of information regarding generated files in your build before ninja will be happy.
You can have the 2019 preview and release side by side. You just need to run both installers once, then the installer will show both channels.
You have to pipe all the results into a file, I use e.g. ../tools/bench.rb |tee ../data/all_new.txt Then there is the script `analyze_bench_log.rb`: ../tools/analyze_bench_log.rb &lt;../data/all_new.txt Which generates a HTML site for each of the benchmark. I've updated this just recently and am still working a bit on it, so you might want to update again
Well, the missing include was an easy fix. My main problem is that I am doing a bit of `.vcxproj` juggling inside my CMake scripts to tweak the build to my liking, which obviously do not work with ninja. So regretfully I am a bit dependent on generating Visual Studio solutions.
The next version of C++ will solve all problems
Because the function `foo` takes its argument by reference. No moving actually occurs. If you modify the function`foo` to `foo(Moo moo)`, then moving will happen as a new `Moo` will be constructed for `foo`.
I have been begging for reflection/introspection for decades. The optimization opportunities alone should be the golden ticket to standardaization, not just the serialization opportunities (which would also push c++ past "modern" languages). It is sha!eful that this is not even on the horizon. Does anyone have some links to arguments against reflection/introspection?
Thanks for the reply and congratulations on a very nice release. Looking forward to updating our team soon, but I guess we have to wait until the first updates have landed. 
Not OP but do you mind if I contact you directly? 
**Company:** [Zivid](https://www.zivid.com) \-- 3D machine vision **Type:** Full time **Description:** Zivid creates a high speed high accuracy 3D video camera for use with robots in industrial automation. We have two open positions and are looking of a total of two or three candidates. The positions span from library development to 3D and GUI development. Detailed job descriptions can be found at our web page, see link below. **Location:** Oslo, Norway **Remote:** No **Visa Sponsorship:** Yes **Technologies:** Cross platform C++17, OpenCL, OpenGL and Qt/QML (and git, python, clang-tidy, clang-format, Jenkins, cmake, catch2, docker, vagrant, kvm, C++/CLI) **Contact:** PM or [mathias.nedrebo@zivid.com](mailto:mathias.nedrebo@zivid.com) **Applications:** Online form: [zivid.com/jobs](http://zivid.com/jobs)
Because std::move is a bad name.std::move() does not move, it casts. you may think of **std::move&lt;T&gt;()** as **rvalue\_cast&lt;T&gt;()**. It does not perform any action of its own on the value passed to it, only changing what methods you can pass it to. So you have a foo func, that just received an rvalue ref to Moo. Try this: `Moo m;` `Moo copy = m;` `Moo move = std::move(m);`
**Company**: [Loki](https://loki.network/) **Type**: Full Time **Description**: Loki is an open source, fully funded project aiming to develop a censorship resistant mixnet with an end-to-end encrypted messaging service built on top of a privacy centric cryptocurrency. We are mostly comprised of C++ developers who work on the core of our product. We are looking for a Senior C++ developer with experience in project architecture aswell as a strong understanding of Blockchain, a research or Mathematics background is also a plus. The right candidate for this position is experienced, creative, and is passionate about privacy preservation. Particular proficiency in any of the following areas is desirable, but not a requirement: • Strong Mathematical or Computer Science background • Large project experience (especially in architecture) • Experience with Distributed Networks • High level of working C++ experience (5+ years) • High level understanding of Ring signatures, RingCT, NIZKPs, SIDH • Interest in Onion routing networks • Open Source Projects/git **Location**: We have our office in Melbourne, Australia and have a strong preference for relocation of any candidate to our Melbourne office, we also have the ability to sponsor or relocate the right candidate as part of their employment contract. **Remote**: No **Visa Sponsorship**: Yes **Technologies**: We have a wide breadth of technology, mostly we use C++ and work on the Cryptonote code base, projects outside of Cryptonote are still C++ and networking heavy like Lokinet our internet overlay protocol. **Contact**: PM me on reddit 
[http://bajamircea.github.io/coding/cpp/2016/04/07/move-forward.html](http://bajamircea.github.io/coding/cpp/2016/04/07/move-forward.html) Nice article about this.
C++20 Reflections TS: enum some_enum { a, b, c }; using namespace std::reflect; int enum_size = get_size_v&lt;some_enum&gt;();
What I use is: ``` enum class color { red, green, blue }; constexpr auto num_colors = 3; ``` Reflection would be ideal, but I think this is better than ad-hoc enum elements and macro solutions.
&amp;#x200B; enum class color { red, green, blue, color_size };
Yeah, by reference. But it's RV-reference, so I thought the object would be moved. Apparently I was wrong, but couldn't get where exactly.
And the war will be over by Christmas.
Well, that is sort of my point. I've been using Qt since almost the beginning of my C++, and it has QMetaObject and QMetaEnum. Those work with code generation, and have many limitations, but I've found them good enough for a pretty large amount of use cases. A proper standard solution is obviously preferred, but meanwhile... Oh, and, more on topic of the subject: [https://github.com/quicknir/wise\_enum](https://github.com/quicknir/wise_enum) I've just found it in another thread. Some nice macro trickery to study.
It's definitely on the horizon, the committee approved a technical specification for c++20
Oh really? you are simply lying. Any interface with N methods and M different implementations will require to implement N*M function calls. On the other hand, with inheritance, M different implementations will not require writing anything. 
&gt;but I think this is better than ad-hoc enum elements `color::num_colors` does not behave like a number and you have to cast it.
This is a bit of a frankenstein solution, and I'm not convinced by it (I've done this before). A C++ library in a DLL wrapped by a C interface - sure, but exposing the internal C++ interface is a bad idea, and defeats the purpose of having the C interface. &gt; You can’t have STL containers as members of the C++ class. Sure you can, but you just can't expose the C++ class directly (as you have done) &gt; if you need an STL container just make a small wrapper class around it and put that as a member instead. This... this is a terrible idea. &gt; The C functions can obviously only take very basic types. You can receive strings though, which is good news. No, you can't. 1) that's not a C interface, it's a frankenstein C++ interface, and 2) string isn't a special C++ type, it's subject to all the issues that other C++ classes are - unless you're compiling the shared library with the same compiler flags as the caller, you're going to have a bad time. If you _are_ compiling the shared lib with the same flags, then it doesn't matter and you don't need the C interface.
 enum class color { red, green, blue, color_size }; constexpr auto num_colors = (int)color::color_size;
`A&amp;&amp; ref = std::move(a);` is almost equivalent to `A&amp; ref = a;`, except for `decltype(ref)`.
An rvalue reference is also just a reference. It doesn't magically move anything. You just have a single object and a single reference pointing to it. `std::move` doesn't move anything. But it's a cast yielding an rvalue expression. This expression still refers to the same object but the "rvalueness" of this expression makes overload resolution prefer functions or constructors that take an rvalue reference. Any actual moving might happen *in* those functions or constructors. Think of `std::move` as a declaration of disinterest. By using it you say "I don't care about this object anymore" which allows it to be the source of a move construction. But in your function you don't create a new object.
The only difference between lvalue and rvalue references is how they can be initialized and how overload resolution treats them differently: void foo(const int&amp;); //1 void foo(int&amp;&amp;); //2 int main(){ int i = 99; foo(i); // -&gt; 1 foo(6); // -&gt; 2 foo(std::move(I)); // -&gt; 2 } That's all. No other magic is happening here. Now, if you create a new object based on an lvalue, overload resolution will pick the copy ctor. If you create a new object based on an rvalue, overload resolution will pick the move ctor (if it exists, otherwise it falls back on the copy ctor).
Is that actually valid code according to the TS? That would be great. &amp;#x200B;
I hope this is joke.
 // 21.11.4.3 ObjectSequence operations template &lt;ObjectSequence S&gt; struct get_size; template &lt;ObjectSequence T&gt; constexpr auto get_size_v = get_size&lt;T&gt;::value; 21.11.3.2 Concept ObjectSequence template &lt;class T&gt; concept ObjectSequence = see below; ObjectSequence&lt;T&gt; is satisfied if and only if T is a sequence of "Object"s, generated by a meta-object operation. 21.11.3.1 Concept Object template &lt;class T&gt; concept Object = see below; Object&lt;T&gt; is satisfied if and only if T is a meta-object type, as generated by the reflexpr operator or any of the meta-object operations that in turn generate meta-object types. So that means that my `get_size_v&lt;some_enum&gt;()` would need to be changed slightly. enum some_enum { a, b, c }; using some_enum_reflex = reflexpr(some_enum); using namespace std::reflect; constexpr int enum_size = get_size_v&lt;some_enum_reflex&gt;(); I'm going to edit my post above to fix it as well.
r/cpp_questions
I use UE4 professionally and use Intellisense with VS2017. It's improved hugely from VS2015 and before - it's fast, and it routinely manages to find things (particularly overloaded operators) that Visual Assist (the previous workaround for UE4 developers) cannot.
Ctrl+, is actually really old, but I agree it's fantastic.
I'm also a game developer and Intellisense works better than VAX for me since VS 2017 - \`Ctrl+,\` is your friend. It can also find overloaded operators via F12, where VAX really doesn't understand how to find them at all.
I thought this was basically standard practice. Apparently not.
 enum class Rainbow : unsigned int { Red = 0xFF0000, Yellow = 0xFFFF00, Pink = 0xFFC0CB, Green = 0x00FF00, size }; Oh, wait.
I see. Thank you very much. For the record: when I went to the download page yesterday morning, I only got links to download of 2017 or 2019 preview. In any case: Is there a special reason, why the existing installer doesn't automatically show me all available products?
For some reason this link for buying professional version does not work [https://www.microsoft.com/en-us/p/visual-studio-professional-2019/](https://www.microsoft.com/en-us/p/visual-studio-professional-2019/) found here (after pressing standalone license) [https://visualstudio.microsoft.com/vs/pricing-details/](https://visualstudio.microsoft.com/vs/pricing-details/) I also wonder if there is any upgrade discount if you have VS2017 purchased.
Shows what you know.
I have always liked https://www.learncpp.com/
ISO C++ has some suggestions : https://isocpp.org/wiki/faq/how-to-learn-cpp
I've heard good things about Bjarne Stroustrup Programming: Principles and Practice Using C++ (2nd Edition) https://www.amazon.com/Programming-Principles-Practice-Using-2nd/dp/0321992784 Haven't read it, but I do have Stroustrup's more advanced "The C++ Programming Language" book and can tell you he's a great author.
 But the default associated value for the first item is zero, so adding a count at the will get the value size - 1 assigned or? maybe you can do somethign like enum {a = 1, b, c, d, count}
What are your thoughts on the Reflections TS? I'm interested, because I know you are not really fond of the standard library, but the TS allows [this](https://old.reddit.com/r/cpp/comments/b8qtcx/its_2019_we_have_the_power_of_constexpr_and/ek0bcwc/)
 Sorry what exactly do you mean with "serialization opportunities" vs "optimization opportunities"? I'm pretty sure it is in the horizon however there is a very advanced proposal out there.
count will hold the value size excluding the count itself.
Usually count isn't considered as part of the enum, so it should be 4
Ahh off course count is not part of the enum itself. Oops
Yes off course! My bad thank you
I wouldn't mix \*enums\* with actual \[constant\] values enum class color { red, green, blue, size }; std::array&lt;int, static_cast&lt;int&gt;(color::size)&gt; colors { 0xFF0000, // red 0x00FF00, // green 0xFFFF00, // whatever }; auto red_color = colors[static_cast&lt;size_t&gt;(color::red)]; or std::vector&lt;int&gt; colors2(static_cast&lt;int&gt;(color::size)); colors2[static_cast&lt;int&gt;(color::red)] = 0xFF0000; .... &amp;#x200B; &amp;#x200B;
I thought the OP was wanting to count the number of elements in rand();
I wonder how many thousands of development hours is wasted on writing replacements for that.
Runtime reflection is a pretty different beast in C++ than in a lot of other languages, which is probably why. A function might not necessarily have an entry point due to inlining, it might stripped entirely due to dead code removal etc. Both static &amp; runtime reflection also have a lot of non-trivial issues with how it would interact with templates. Given template&lt; typename T &gt; T* Create(), the instantiations of this template is not known until link time.
This isn't helpful at all. Why not?I'm starting a job soon where I will be coding c++ and I want to go from 0 to productive as fast as possible. I know how to program, but not in C++. What would you recommend instead? 
Start with learning how computers work. In JavaScript you don’t have to care about hardware and the OS, in C++ you do.
So write non optimal code that is harder to read? This is a big enough change that it can't just be optimized away in many cases, and introducing a chance for copy paste errors so that you can keep the enum "pure" dosn't sound like a win.
If a function is referenced (say for reflection) then this can be detected before runtime. Same for templates.
It's not a generic solution, because - it gives wrong results when you change values assigned to enum entries, - you usually can't control all enums in your system
no hard feelings, but you can start by reading the sidebar 
It won't work in `enum class` cases:(
**Company:** [BHS Technologies](http://www.bhs-technologies.com) **Type:** Full time **Description:** We are a young, solid, fully funded, company that develops a medical device. You will be responsible for designing and developing a software for surgical navigation as part of this device. The task is to map 3D body scans into a video feed. It is like augmented reality but more precise and for the purpose of guiding a surgeon where he needs to be with his tools. Therefore, you should be able to know your way around in the 3D space, work with external devices and have a strong understanding for performance in real-time applications. A sense of high-quality is a must when developing software for the medical space. As previously said this is part of a bigger application so you do not need to start from scratch and you will be part of a very talented team. **Location:** Innsbruck, Tirol, Austria **Remote:** No **Visa Sponsorship:** Possible **Technologies:** * C++17 * CUDA * OpenGL/Vulkan * Linux * Git * Jira + Bitbucket **Contact:** [Eva Stöckl](mailto:talents@bhs-technologies.com)
Just one suggestion: Stop doing so much in the GUI thread. The GUI is very slow to respond whenever the IDE does something in the background, especially when you open or reload a C++ solution.
I upvoted you, but your "million of lines" number is hard to validate one way or the other... :-)
I hope you'll quickly update CMake to 3.14 because the current 3.13 version doesn't support the new v142 toolset, I basically have to still use the older v141 toolset which is pretty pointless...
Sandia is part of our customer base, yes. &amp;#x200B;
Savior with broken precompiled header support
Even if you do give specific values to your enums, as long as they start at 0 and there are no gaps, the `count` trick works: enum class Foo { bar = 0, bing = 1, baz = 2, count }; 
And still has no usable text editor? Couldn't they just embed Emacs as default text editor. Typing code in VS is horrible experience.
Different language. Today.
I've currently got it disabled, but last time I checked my issue was that parsing took _forever_, ctrl + , was flaky at best, and F12 would regularly (1 in 3/4 attempts) cause an indefinite hang. I'm installing VS2019 to give it a shot now with intellisense (as I did for 2017).
Thanks. 
Like a lot of hacks, this falls down when there are a lot of enums and they get edited a lot. In particular, if two developers add different enums in parallel branches, the second developer to commit will merge automatically and not see that `num_colors` has suddenly become wrong. 
We've always been at war with Eurasia.
Which one on this 8MHz, 8bit CPU I'm holding in my hand?
That's better but has the issue that you get warnings on `switch` statements for a missing case - `color::color_size`. enum class Color { red, green, blue, last = blue }; and if you do the above for all your enums, you can add this: template typename &lt;E&gt; size_t enum_size() { static_assert(std::is_enum_v&lt;E&gt;); return 1 + static_cast&lt;size_t&gt;(E::last); } which is really handy.
The following works in all modern C++ compilers, and doesn't produce any warnings for missing case statements: enum class Color { red, green, blue, last = blue }; template typename &lt;E&gt; size_t enum_size() { static_assert(std::is_enum_v&lt;E&gt;); return 1 + static_cast&lt;size_t&gt;(E::last); } static_assert(enum_size&lt;Color&gt;(), 3); 
The text editor is fine with some configuration
Why, C, of course! /s
It is usabel with some configurations, but long from fine. I have done lots of consulting work in VS, since it seems to be standard in industry at least in my part of the world, but I wanna cry when I have to type code from scratch in VS. Typing in Emacs is VS is like flying jet vs propeller plane.
billions
Exactly my point.
42
I've only glanced at it briefly, but how does it solve these problems (I should add examples for these to the sandbox repo): - generated source files - `import MACRO;` - Building two modules of the same name that are not part of the same dependency tree (e.g., static and shared builds at the same time) - modules from other directories (AFAIK, you need module maps to be generated for this) I'm willing to host other build systems in that repo, so if you'd like to add the plain Makefiles to the repo, I'd welcome an MR.
\*\*Company:\*\* [Applied Research Associates](https://www.ara.com/projects/arc4-heads-up-situational-awareness) \*\*Type:\*\* Full time \*\*Description:\*\* ARA is an international research and engineering company recognized for providing technically superior solutions to complex and challenging problems. We are looking for developers with C++ experience (entry- to expert-level) to join our multi-disciplinary team and contribute to the development of ARA’s augmented reality product line. \*\*Location:\*\* Raleigh, NC, USA \*\*Remote:\*\* not offered \*\*Visa Sponsorship:\*\* not offered (position may require security clearance) \*\*Technologies:\*\* C++14/C++17 cross-platform applications written for Windows, Linux (x86 &amp; ARM), and Android. Heavy usage of USB, OpenGL/GLES, Android NDK \*\*Contact:\*\* [apronschinske@gmail.com](mailto:apronschinske@gmail.com) (Lead Software Engineer) or [apply online](https://recruiting.ultipro.com/APP1010ARAI/JobBoard/07442cec-d18e-4589-ab15-8342edc29af7/?q=ARC4&amp;o=relevance&amp;w=Raleigh%2C+North+Carolina%2C+USA&amp;wc=-78.64266779997195%2C35.78551352863906&amp;we=-78.74266899999999%2C35.885514%7C-78.542669%2C35.685514&amp;wpst=2)
Work in progress, but basically like premake, but in python with proper scoping, easier management of dependencies, easy pypi install, but a lot of stuff still missing. Small [example](https://pastebin.com/9my5Eprm) . Everything pretty much up in the air &amp; ever changing, but it produces working MSVC project files for now. 
&gt; you may think of std::move&lt;T&gt;() as rvalue_cast&lt;T&gt;() The name I like to think of it as is `make_movable`, or maybe `enable_move`; something like that. It loses the implication of `move` that it actually *does* the move itself, but still retains the high-level meaning and why you're doing it.
I’m not sure what _your_ horizon is, but the standardization committee has been exploring it for years. See e.g. https://wg21.link/p1240 
Note that the (first) reflection TS is not at all related to C++20. It’s also a bit of a dead end: The committee decided a couple of years ago to move away from using types as reflection values and instead base future reflection work on constant evaluation. 
200 hours of study will get you almost nowhere in C++ unless you are already an experienced programmer in another systems language. 2000 hours of study *might* do it for someone very skilled in web programming, and with a natural aptitude for systems programming. I've read C++ written by experienced Javascript devs and found it very solid. I've also read plenty which was not. The problem with a lot of these courses is that self directed practice is the actual thing worth money, and money cannot buy it. The feedback any course gives you won't be worth much compared to direct experience reading, writing, and testing C++. Coming from an numerate undergraduate degree, I just don't believe that for 99% of people, anything less than 5,000 hours of study will produce a competent C++ junior dev. That said, I have met the **very occasional** person who went from zero programming experience to getting a library into Boost within three years. But those kinds of people are not like you or me or anyone normal.
&gt; but couldn't get where exactly. Another that might help, even though that I'll caution this is *very* much an oversimplification, is to think of the `&amp;&amp;` as being associated with the *source* of the move, not the destination. For something to be moved *from*, it needs to be a `&amp;&amp;`; and the purpose of `std::move` is to turn something that isn't an rvalue reference into one so that it *can* be. So `std::move` doesn't produce a move because it's a somewhat-misleading name (as discussed in another comment and glossed over above in this one), and assigning to the `&amp;&amp;` parameter of the function doesn't produce a move because that's the *destination* rather than the source.
Are you sure about that? The TS was even published in Kona according to [this trip report](https://old.reddit.com/r/cpp/comments/au0c4x/201902_kona_iso_c_committee_trip_report_c20/).
Rule number one, don't argue over voting.
Nice! CSV files are near and dear to my heart. Will check out your work. I've been using a combo of boost.tokenizer and std::getline for years.
&gt;That's better but has the issue that you get warnings on switch statements Isn't the whole point of knowing the size of the *enum* is to switch from the *switch* statement to something like *std::array*?
No, such mode is not supported now. We do local code resolve so we need a code to be located locally. The mode with the remote code resolve will be supported later.
Yes, this one is probably even more useful http://docs.platformio.org/en/latest/ide/clion.html
VCS operations can be indeed unfriendly to CLion. We are working on several issues in that area and hope to improve the responsiveness soon.
That's mostly because that was an IntelliJ-platform action not really adopted to C++ properly. In 2019.2 we plan a massive rework for it, so should be much better after that
It depends on the project's requirements. Probably for 80%+90% of projects simply knowing what a printer is is sufficient.
Yes. The TS was well under way when the course change was agreed upon (mid-2017, if I recall correctly). So we let it proceed with the hope that even though it's not the computational model we want it might perhaps reveal whether the capabilities it provides are what we want.
That's great to know. Thanks for the responses and good luck!
What kind of tweaking are you doing?
Quoting from your link: "While we expect a major update to improve the compile time programming model used (by moving towards a constexpr model instead of type-based metaprogramming), this TS will help encourage early implementation and usage experiments to verify and improve the underlying technology and designs."
Thanks for doing this! Interesting how this time there are zero remote jobs here - a first, I think. Also interesting that all the jobs require only C++ as a language. I'm noticing that for other languages, you see more combos like Python + Javascript, Python + R, Java or Kotlin + JS. Makes intuitive sense to me, though I can't quite formulate the exact reason... 
That mirrors my experience from early Visual Studio versions as well, but VS 2017 has been fine for me even with a massive codebase.
Lmao just install WIndows with JVM on that thing
I'm glad I read your post earlier. Tried adding 2019 support to some code I work on, and it turns out that thread no longer includes functional, which broke compilation. Thanks for making this post otherwise I'd not have know that we need to directly #include &lt;functional&gt; .
For toy projects maybe. If there’s any parallelism or strict performance requirements, it becomes incomparable to js development. There’s a reason why C++ engineers have a higher salary.
What I do: ```cpp namespace Foo { enum Enum { Bar = 0, Baz, Bing }; constexpr auto First = Bar Last = Bing, Size = Last + 1; } ``` - No switch warning - No issue with enum class
I dont think so, for that amount of money you should buy the Bjarne book for the C++ part and the Meyers later for good tips about coding to get you a pro level. When you has the book you only has to let it flow, you will search for yourself the stuff you need, things that may not be in the book but it is ok The problem is that if you who should evaluate yourself, you will read and say, ok, i get it when in reallity you didnt, it is harder but sooner or later you will face it, the course will not do a miracle A tip is start choosing a good IDE to develop, i will suggest CLion which in my opinion is the best of all but it has the drawback of CMake which is another layer of complexity and if you are new it may not be the best, Visual Studio doesnt has as direct as CMake as it hides from you much of the stuff so it will easier but the IDE is worse, try until you really like one because you are going to spend hours and hours so better be the one you like and trust
&gt; That would be great. No, that would suck. This is what we want: some_enum::size(); or get_size&lt;some_enum&gt;(); If that syntax is the best we can come up with, it is not a good sign for C++ as a language...
Have you tried to open a recursive git clone of boost with open-folder? That becomes quite slow and unstable on my system, but I've no Idea if a 3rd party engine works any better.
My answer was to the original post, which read essentially exactly like your second version.
On a second thought, I think: enum class color { red, green, blue }; constexpr auto num_colors = static_cast&lt;int&gt;(color::blue) + 1; The enum remains normal, and your size is adapting to changes.
``` using YourAuto = SomeTemplatedType&lt;ThatIOnlyWantToTypeOnce&gt;; YourAuto SomeClass::s_static; ``` I really don't think too much syntax sugar is good. 
Also, when will we get string representations of enum values? Would it not be trivial for a compiler to automatically generate these two functions, for every declared enum? int get_enum_size&lt;enum foo&gt;(); std::string enum_value_as_string(enum foo value); I mean, it is possible to write c-macros that does a half decent job of declaring enums with that capability. What prevents the compiler from doing this? Other than the fact that the standard is missing the half page, or so, of text mandating it.
Okay, that makes more sense :-)
I use intellisense at home for smaller projects, but I work on a UE4 game, and it's been unusable every time I've tried it.
I use it with UE4 (\*shrug\*). They honestly fixed it in VS 2017.
Stupid sexy D/C#.
I went with a macro: #define Generate_Enum_Info( e_type, e_first, e_last ) static constexpr e_type e_type ## _First = e_type::e_first; \ static constexpr e_type e_type ## _Last = e_type::e_last; \ static constexpr int e_type ## _Count = Enum::Count( e_type ## _First, e_type ## _Last ) Used thusly: enum class MyEnum { This, That, The_Other_Thing } Generate_Enum_Info( MyEnum, This, That_Other_Thing ); This generates `MyEnum_Count`, `MyEnum_First`, and `MyEnum_Last`. A bit more work in that you have to remember to update the call to the macro if you change the first/last elements, but otherwise quite handy.
If you're defining a macro, you could use a manually scopped enum: `#define ENUM(id, ...) struct id { enum T { __VA_ARGS__, size }; };` ENUM(Color, Black, Red, Green); Color::T c = Color::Red;
Thank you so much /u/martinus
**Company:** [Lumicks](https://www.lumicks.com/) **Type:** Full time **Description:** Lumicks is bringing novel tools for single-molecule biophysics to market, enabling scientific researchers across biology and medicine to unlock new types of experiments. Our primary technology, C-Trap, can be used to "grab" a single molecule, and apply precise mechanical forces to it. At the same time, one can visualize the molecule using highly-sensitive fluorescence microscopy. Our customers use it to watch DNA being copied by the molecular machinery of the cell, or observe molecular "engines" walking across the scaffolding structures of a human cell. Lumicks systems are currently in use in opinion-leading labs across the globe, including Rockefeller University, ShanghaiTech, Max-Planck, and Pasteur Institute. We're an academic spin-off from a research group at VU University Amsterdam. We care deeply about providing our users with easy-to-use, reliable software that actively supports Open Data and Reproducible Science. To make this happen, we're looking for: * C++ developers: [https://lumicks.com/vacancies/c-software-developer/](https://lumicks.com/vacancies/c-software-developer/) * Qt developers: [https://lumicks.com/vacancies/ui-developer/](https://lumicks.com/vacancies/ui-developer/) * DevOps engineer: [https://lumicks.com/vacancies/devops-engineer/](https://lumicks.com/vacancies/devops-engineer/) **Location:** Amsterdam, NL **Remote:** No **Visa Sponsorship:** Yes **Technologies:** We use the following technologies. When applying, it's fine to be familiar with a subset of these. We use C++17 for the core libraries, Qt5 for the graphical interface and Python 3 for the scripting interface. CMake builds everything. The core libraries make use of abseil, asio, caf (c++ actor framework), catch2, cereal, fmt, hdf5/highfive, opencv, ranges-v3, spdlog. The GUI is a mix of Qt widgets and QML. The Python bindings are implemented using pybind11. On the hardware side, we have lasers. Lots and lots of lasers. **Contact:** Apply directly at: [https://lumicks.com/careers/](https://lumicks.com/careers/)
Highly recommend this book: https://www.amazon.com/Effective-Specific-Improve-Programs-Designs/dp/0321334876 Once Scott meyers has you hooked, checkout his modern effective c++ book. He's a great writer and teacher
**Company:** [OxFORD Asset Management](https://www.oxam.com/careers/) **Type:** Full time **Description:** We are an investment manager based in central Oxford, UK. We are seeking outstanding software engineers to develop and maintain system-critical software. You will be responsible for all aspects of software development on a diverse range of projects, such as automating trading strategies, integrating third party data into our system and the development of data analysis tools. You will work as part of a highly skilled and motivated team who care deeply about software quality, efficiency and robustness. A background within finance is not necessary for this role. The ideal candidate will have several years of experience of commercial C++, a thorough understanding of the STL and be comfortable with good software engineering practices such as unit testing and code review. We also welcome enthusiastic graduates and postgraduates in mathematics, statistics, computer science and the natural sciences with experience in C++. **Location:** Oxford, UK. Central offices located close to local amenities, parks, restaurants, shops and bars. **Remote:** We do not offer remote working. **Visa Sponsorship:** Yes **Technologies:** C++17 on Linux. Python used for internal scripting and research. **Contact:** [recruitment@oxam.com](mailto:recruitment@oxam.com)
That would be so perfect for this. 
*At least* one. 
What are you capturing with goo() in lamda captures?
Report it here: https://developercommunity.visualstudio.com/content/problem/post.html?space=62 I can repro it too.
I've already started, just planning next steps
&gt;But unfortunately many algorithms in C++ require Regular types, at least on paper. Actually according to the article you linked, virtually^((?)) *no* standard library algorithm requires `Regular` types. — Luckily. The only real (entirely justified) gripe of the article is that the `Regular` concept, with its nice name, includes a useless requirement in practice, which might cause somebody to “accidentally” use it as a requirement for an algorithm.
This is made even better by the `/rand` typo, because the new random library is still pretty hard to use correctly, as I recall.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/b8zst1/im_fairly_efficient_in_c_but_all_my_work_has_been/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
well, yea, I've fucked this one up
I guess I'll keep my new vocabulary type, `mandatory&lt;T&gt;`, to myself. (It's designed to be the opposite of `optional&lt;T&gt;`, and it's really convenient to implement to boot! `template&lt;class T&gt; using mandatory = T;`)
That just means you need more cores than translation units and you're okay. *Billy hugs his 7980XE*
Nah, I probably just to switch my system language to Japanese for Ninja to work
If you have new guy coming, there is little choice...
I am also interested. Should this code compile at all?
mmm... With preview 3.14rc was installed by VS installer
Personally, I just wish there was some universal package manager for C++, like there is for other languages like Rust, Python, JS, etc. It would save so much development time to just be able to do something like `#include package XXXXX`. Sure, people would end up abusing it to some degree, but there's got to be some good compromise between [the ultra-spaghetti that is JS dependency](https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/) and having manually include external sources or libraries in a project every time.
A compiler should never so it's a valid bug report, but it's not valid C++ you need to assign goo() to something to fix this .
I **hate** this trick, because it pollutes every single `switch` statement on a value of the enum. Fortunately, since I generally want printing (and maybe parsing), I've come to use X-macros to declare enums anyway, so it's just one more functionality added to the macro...
I've started using this: namespace enum_conversions { template&lt;class E, class = std::enable_if_t&lt;std::is_enum_v&lt;E&gt;&gt;&gt; inline constexpr auto operator+(E e) noexcept { return +static_cast&lt;std::underlying_type_t&lt;E&gt;&gt;(e); } } Essentially, this creates a unary `operator+` for all enumeration types. This operator is rarely used, as its only purpose is to do integer promotion. But that's exactly what we want here, to promote the `Count` enumerator to an integer value. It's wrapped in a namespace so the operator is only seen if you opt-in. Like how `namespace string_literals` works. Usage is simple: enum class Color { Red, Green, Blue, Count }; void foo() { using namespace enum_conversions; std::cout &lt;&lt; +Color::Count &lt;&lt; '\n'; }
**Type** Full time, middle level+ &amp;#x200B; **Description** 2.5y c/c++ in games, proprietary engine and tools 9m c#,js. CS and Applied Inf. degs. &amp;#x200B; **Location** From Slovakia, willing to relocate west, north Europe. For other must sponsor visa. &amp;#x200B; **Technologies** Custom performance c/c++ (11 mainly) multithreaded and networked, winapi, opengl. &amp;#x200B; **Contact** DM me email and lets talk. Can respond with CV and yt channel w/ portfolio &amp;#x200B; **Interested** Interesting c/c++ ex. low latency, high throughput, system prog, graphics. Mid to big sized company. &amp;#x200B;
I pretty much reject all of these libraries due to the ugly syntax and the fact that there's no way they optimize as well as a regular enum. Until it's built into C++ I'm perfectly fine manually writing this stuff. it sucks, but better than using some random library.
that implies reflection can't be done generically.
because of the potential lifetime issues with string_view, you should make the API such that it's clear you're grabbing a string_view. have get&lt;&gt; return a string and get_view&lt;&gt; or get_sv&lt;&gt; (or similar) return a string view. otherwise what will happen is that someone will grab a code snippet and accidentally keep that view around too long and cause code crashes. Or they'll update the code after the fact and forget that it's a view.
Well, manually writing this seems pretty terrible. You either want something automated, or you don't really need it and can live with something ad hoc. The syntax required for QMetaEnum is `Q_ENUM(Enum)`, and that's it. If I remember correctly, it's a macro expanding to nothing; just the flag to tell the code generator that should inspect this. Obviously you are not going to pull Qt into a project for features like this, but in projects using it, it's a nice to have feature, if you know of it. But from the comment I guess that the project or projects that you have in mind are not like mine. As an example, we removed the usage of Xerces recently. Without it, there are **still** 3 more XML libraries available to use and linked against, because of how the project uses a lot of legacy from here and there, and the company develops its products.
Recently I heard Ben Shapiro say he has been writing for 18 years, but only in the last 3 years has he been making money on it. He was often frustrated during the first 15 years that he wasn't able to make money from it, but today he has the top non-fiction book on NY Times, Amazon, etc. I've also been working for years on [something](https://github.com/Ebenezer-group/onwards) without much income from it. Maybe this is my big break. 
* + JS is likely to be a backend+frontend pair for a web-based thing of some sort, and C++ isn't particularly popular for that, as far as I know.
I don't consider writing a to_string function that throws when the input is unrecognized as being overly horrible. certainly suboptimal, but not terrible.
Knowledge of algorithmic complexity is much more important than low-level micro-optimizations, many of which are performed by the compiler anyway. Knowledge of algorithms is applicable to any language. In some cases understanding the cache characteristics of the target machine can be useful and paying attention to data layout can be important, but the #1 priority of any project is getting something out the door.
&gt; A compiler should never so it's a valid bug report Did you run out of memory while typing your comment? ;-)
&gt; the instantiations of this template are not known until like time Uh, no? Specializations are instantiated at compile time.
It's a chore, and error prone. Add to it the same problem for the count, and the one with the function with the reverse of the to_string one.
It *is* standard practice, but it sucks.
throwing on unrecognized input insures not updating that function gets found and fixed immediately. and I don't really know what you would use the count of an enum for except looping and I would argue THAT is itself problematic due to the assumptions built into it. If that's really what you're trying to do I would instead write functionality to do the enumeration, which would be something as simple as returning an array from a function. 
That lib generates actual enums not classes masquerading as enums, so it should play well with optimization.
that makes it better than any other of these solutions I've seen, although I still find the syntax to be a sticking point.
What does this have to do with lack of introspection in C++ and everyone reimplementing their own version of it?
Your Vector is a lot larger than the author Vector3 struct, sizeof(Vector) = 40, while sizeof(Vector3) = 12.
Surely a race condition
I have just commited data/all.txt with all my results, including your phmaps. Pipe it into the script to get all results
enum bits { zero = 0b0, one = 0b1, two = 0b10, three = 0b100, };
Ah, true.
There are some visual studio project settings which are not available from CMake, but settings that I want to apply to every build. So I have a template vxproj file which I copy into the build directory and do some text-processing on using CMake. 
You're welcome! We know that changing your source code is a minor headache, but we felt that improving build throughput (an eternal top customer request) was worth it in this case.
get&lt;&gt; accepts either string_view or string as template arguments. I had a hard time deciding which one should be the default for the same reasons you mentioned, so I'll consider as a vote for making std::string the default.
if you're writing to keep the syntax short, I would still argue that get vs get_view or similar is a better tradeoff than get&lt;std::string&gt;() and get&lt;std::string_view&gt;(); The default should be std::string because it's the safer approach, it can't be misused, only mis-optimized.
Obviously an out of heap space error
Ah, you want to do stuff on your things. Can you be more specific? 
I use the free VsVim plugin [https://marketplace.visualstudio.com/items?itemName=JaredParMSFT.VsVim](https://marketplace.visualstudio.com/items?itemName=JaredParMSFT.VsVim) which works great.
I usually just do something like \`\`\` struct AA { using ShortName = Whatever::Ridiculous::Long::Type:Thing::Is; static ShortName TheThing; }; &amp;#x200B; AA::ShortName AA::TheThing; \`\`\` &amp;#x200B; It's a little more typing than being able to use auto tho...
If you only care about C++, but want to an ABI that will be the same on all compilers, take a look at [https://github.com/jbandela/cppcomponents](https://github.com/jbandela/cppcomponents) A presentation talking about that is here [https://www.youtube.com/watch?v=a4iFJuNBx7U](https://www.youtube.com/watch?v=a4iFJuNBx7U) &amp;#x200B; It uses template metaprogramming to remove a lot of the boiler plate and basically gives you a COM component that supports constructors, static functions, std::string, std::vector, std::pair, std::tuple, and cppcomponents::function (replacement for std::function) as function parameters and return values. &amp;#x200B; &amp;#x200B; &amp;#x200B;
For interacting with iOS/macOS via UIKit/AppKit, you'll likely need to use some Objective-C (assuming you don't want to use Swift). Other than that though, C++ works just fine. The compiler is Clang and IIRC, supports C++17. If you want to use Objective-C and C++ in the same file, you can use [Objective-C++](https://stackoverflow.com/questions/3684112/what-is-objective-c) (\`.mm\` extension).
Yeah, the less typing the better! In one case I just defined a macro to do it: `#define STATIC(Name) decltype(Name) Name` `STATIC(AA::TheThing);` `STATIC(AA::TheThing){parameters...};` This way I could still pass parameters to it's constructor if I needed to. But macros are best avoided if possible.
Interfacing with UIKit from C++ is a hassle, you’d have to jump thru many hoops to get that working. Otherwise use Qt or sfml to create the gui for your ios app, this can be done also on xcode. Check the sfml guide. https://github.com/SFML/SFML/wiki/Tutorial:-SFML-for-iOS
I agree, but this case just felt like the natural usage of auto and nothing new. I couldn't think of any other useful way to interpret 'auto' in this context. I've done the using idea too, but I also hate how that requires coming up with an additional name.
Xcode is a great C++ IDE, no clue about an iOS C++ UI tho.
 \*\*Susquehanna International Group:\*\* Proprietary Quantitative Trading \*\*Type:\*\* Full time \*\*Description:\*\* SIG is hiring a high-performance software engineer to work on building our next generation options trading system, which is the successor to the best options trading system in the world. \*\*Location:\*\* Philadelphia (relocation provided) \*\*Remote:\*\* No \*\*Visa Sponsorship:\*\* Yes \*\*Technologies:\*\* C++11, C++14, C++17, C#, Python, Linux, Windows \*\*Contact:\*\* Email - Alex.patton@sig.com
I think exporting everything by default would be a bad idea. Modules enable you to limit what you are exporting. Today you can already use -fvisibility=hidden for similar effect, but that is compiler specific. You can alway opt out by putting all contents of your module in a single `export {}` block, which is minimally more to type in most cases. Also nothing forces you to have implementation units with modules. You can afaiu just put everything in the interface unit (with modules, this wasn't possible with headers). For libraries it can however pay off to only put exported parts in the interface unit. That way users just have to scan this unit and not check for every symbol, if it is exported and ignore any implementation details. If you have a library, it is also pretty important to keep implementation details hidden, otherwise they become part of your API and you can't change them, which is why you don't want to export everything by default. Module partitions can help, if you module interface becomes to big to become hard to maintain. That way you could provide something like boost as a module, which could just be imported via `import boost` and you would have to put all of boost in a single file. While that is probably still a bad idea, I can understand why some companies like Google want partitions. In my mind it is easier, if you then just have one main interface unit, which has to state alle partitions explicitly, because it makes it easier for me to find all exported symbols. I just have to find all files, that specify, that their one of those partitions. Without that, I would have to scan every source file in the import path to be sure, that I didn't miss one exported symbol. While the current module proposal is complicated, I still think that a most parts are well thought out. 
I *think* Salrony meant that you don't know the list of all instantiations until link time. If you imagine some dispatcher that takes a dynamic string and dispatches to the function it names, and you want it to be able to go to any instantiation, that probably implies some link-time magic is necessary for a decent implementation. (But I know linkers can already generate lists of functions, e.g. `.init_array`, so for all I know such magic might already be present.)
unrelated, but \`constexpr\` in a function declaration implies \`inline\` making it somewhat redundant.
The closest you get is cmake + conan [CppCon 2018: Mateusz Pusz “Git, CMake, Conan - How to ship and reuse our C++ projects”](https://www.youtube.com/watch?v=S4QSKLXdTtA) 
Until you have to much cores for Windows to handle (looks at Epycs)...
Use cotire!
yea, the one colleague writing HTML and CSS... email this to him/her in scare quotes. Do it now.
The next big thing. "Another language".
It's enough for almost everything if you just know about cache locality (array is faster than list), abstract parallelism and a good profiler.
I second this. It would be nice if the "channel" was selectable in the installer, or/and if the installer just showed all channels. It's a bit of a hassle to download a new installer from visualstudio.microsoft.com every few months just to make the appropriate channel appear.
If you open the properties for a Visual Studio project in a solution, not all these options in can be controlled via CMake; neither via passing flags nor via specific CMake commands. One example can be the project properties relating to debugging inside Visual Studio, like the answer to this StackOverflow question: [https://stackoverflow.com/questions/1005901/how-to-set-path-environment-variable-using-cmake-and-visual-studio-to-run-test](https://stackoverflow.com/questions/1005901/how-to-set-path-environment-variable-using-cmake-and-visual-studio-to-run-test)
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/b91oph/xcode_c/ek1vbiu/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Yes, please. The C++ subreddit is not a bug reporting channel for any toolset.
Haha that's exactly my experience as well. VAX is instant, while Intellisense F12 hangs sooo often (10% or more of the cases) and I don't even have large code bases, and no UE4. Also when Intellisense does work, it has like 200ms or so lag, which is too much to make it useful - VAX is instant, as mentioned, like &lt;50ms. What's CTRL+, btw? I don't have US keyboard layout and in my VS, it doesn't do anything. What's it supposed to be/do?
Don't wait, try the Previews :-)
&gt; Now pi looks like the following as represented in the floating point model: This depicts “[32-bit float] = 3.14 ~= pi” but that’s incorrect. Unlike 3.125, 3.14 isn’t exactly representable in binary floating-point. (Just like 0.3.) So that float’s mathematical value is the closest possible to 3.14, and 3.14 is the shortest round-trip string conversion for it, but it is not exactly equal to 3.14.
So what's the plan on updating CMake to 3.14.1?
Awesome, thank you a lot for this reply and the information!
You aren't going to get direct framebuffer access for bitblt drawing on modern PCs. (Although you can on something like a Raspberry Pi.) I recommend a hardware-accelerated 2D graphics library like SDL or Allegro. With only a few lines of code you can stand up a window or full screen display and start drawing onto it directly.
It absolutely does optimize as well as a regular enum, because it *is* a regular enum. All the reflective stuff is implemented "alongside" the plain, vanilla enum that the macro declares. Source: I wrote it.
Porting real mode is a pain if it accesses the hardware directly. Take something like SDL and work from there, rewriting stuff when necessary. I hope you didn't use a lot of assembler :)
NEVA!
I think that starting in 17, you'll simply be able to add `inline` to the in-class declaration and that will make it count as a definition. So defining static variables in that way is probably just going to go away completely (unless you're incredibly intense about link times, for which there will be some small overhead, maybe).
Amusingly, my actual case was inside of a templated class so it would have worked being defined in the header file. But.. I'd have no control over construction order, which was why I had to define them in a .cpp file.
How does defining in a .cpp file give you more control over construction order than a header file? Also, to be clear when you are talking about templates you just have no control over class static initialization order, at all.
The header file is included in multiple places and the linker decides which one to keep and initializes it in whatever order it decides (not sure if it's even defined). But within a single .cpp file the variables are initialized in the order they are declared (templated or not).
If you have global A defined in A.h and global B defined in B.h, then if A.h includes B.h, then it guarantees that B will be initialized before A since B is defined before A in every single TU. This usually makes sense anyway because if you need B initialized before A then A depends on B anyway. But yes, there are some cases where you might not want A.h to include B.h, but still want to guarantee ordering... but such cases should honestly be pretty rare as it's just all more trouble than its worth. For the templated class, I repeat: you have no control over the initialization of class statics, regardless of what you do (unless you have explicitly specialized it). https://en.cppreference.com/w/cpp/language/initialization. See "unordered dynamic initialization".
Whoops, I was explicitly specializing the template statics in my case. You're totally right for the case of it not being specialized.
Yes, porting can be a pain. However, most of my code is rely on a header file that deals with the lower level interrrupts. Most probably rewriting that should work. Also I've to remove some of the old stuffs like \_\_attribute\_packed etc.
I've mustly given up on enums (especially enum classes) due to how irritating they are to code around in practice. 
I was thinking of the same route. Although I've not checked Allegro (used to be very good 20 years back). But, I was thinking SDL vs SFML. Can you please suggest which will be better in this case?
What's wrong with it?
Ctrl comma is a combination of alt shitf S and alt shift O in visual assist. 
We have a new C++ user group in Santa Barbara now! We'll be meeting for the second time on April 18th. Can we join the list? https://www.meetup.com/Santa-Barbara-C-Meetup/
I prefer SDL over SFML. I just think it has a simpler interface. I just never took well to SFML.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/b954t0/help_appending_to_detected_removable_device/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Not only do you not get to play with the framebuffer anymore, you don't access bitmaps directly either. Everything is done with handles. I quite like SDL. Although it's comprehensive, it can used in lightweight way, no fuss, portable and with very few lines of code. The work horse of a 2D SDL2 app is https://wiki.libsdl.org/SDL_BlitSurface
Thanks for the explanation! It does make some of the design decisions clearer to me. &gt;I think exporting everything by default would be a bad idea. Modules enable you to limit what you are exporting. I agree that exporting everything is a bad idea, but to me it doesn't make sense to have non-exported items in a interface file meant for exporting stuff out. If you don't want them exported, they shouldn't be in the file in the first place. &gt;For libraries it can however pay off to only put exported parts in the interface unit. Do you know how distributing libraries will work under the new module system? With the current system, we distribute headers and compiled library files. With modules, do we distribute the module interface file and the compiled library files? Or can we just distribute the bmi and the compiled library files?
Did you use BGI with Turbo C (Borland Graphics Interface) for any of your code. If you did, there are some ports to modern operating systems. An example is [http://libxbgi.sourceforge.net/](http://libxbgi.sourceforge.net/) &amp;#x200B; I believe there is a putimage in bgi that might be able to do what you want.
&gt; I agree that exporting everything is a bad idea, but to me it doesn't make sense to have non-exported items in a interface file meant for exporting stuff out. If you don't want them exported, they shouldn't be in the file in the first place. Sometimes it can be hard to spell out some exported declarations, without having the definition of some unexported types available, i.e. now it should be possible to implement PIMPL, while declaring the internal type at the same place. That way it is easier to keep both classes in sync. It also enables you to return unnameable types, which are one fewer symbol you have to worry about colliding with user defined symbols. It's probably especially good for templates, but I haven't really thought about that further. The ability to select which items are being exported also enables having just one translation unit per module, which may be interesting for smaller projects/non library code. The current solution is definitely very flexible, which can be good and bad. &gt; Do you know how distributing libraries will work under the new module system? With the current system, we distribute headers and compiled library files. With modules, do we distribute the module interface file and the compiled library files? Or can we just distribute the bmi and the compiled library files? I don't really know, how modules will change how libraries are distibuted. I read that BMIs probably won't be distributable, as those may be tied to specific compiler versions, but there was also an effort to make a compatible BMI format for gcc and clang. I guess, we will just have to wait and see. Tooling is the other big question mark for me. My guess is that you'd distibute the interface units and the library binary, but I really have no idea.
Nice. Looking into it. Is there a cmake version that can compile on all platform?
Very few of them uses that. But mostly rely on VESA/SVGA using interrupts. I remember using mouse handling and ems/xms memory access using interrupts.
Super, great for you!
I'm not that familiar with cmake. Though I do know SDL2 supports and includes cmake makefiles in its source.
!remove
OP, A human moderator (u/STL) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/b958qx/the_simplest_way_to_print_a_pyramid_in_c/ek2etk4/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Yes, that's why I qualified the requirement with "at least on paper".
One typo: The machine epsilon is not the upper bound of the rounding error; it is the distance between one and the next representable greater than 1. The upper bound of the rounding error is the unit roundoff, which is half the machine epsilon.
PackageId:Microsoft.Net.4.7.2.FullRedist;PackageAction:Install;ReturnCode:87; on windows 8.1 and zero solutions to this problem lol 
Why do you get warnings? Doesn't using a default case resolve any problem there could be?
Why does it suck? I've seen a few people express explicit concerns with it in this thread so far, but I'm not sure I agree with some of their reasoning.
What do you mean by polluting switch statements? Can't you just catch it with the default case?
I'd say it would be a good change, because in this situation the type is obvious, and less typing is good. There is no other sensible use you can assign to `auto` here, no tricky parsing involved. The only issue is how useful it is to be convincing enough for the committee.
The compiler will complain pointlessly about some enums being unhandled in switch statements, if you don't handle the 'Count' value. Once, at least, Count enums were forbidden in the Google coding standard for this reason. 
Indeed. Like many things in C++, it's "standard practice", but so is the naked savage waiting in the bushes to murder you at an inopportune moment when you need to rely on it.
But then that ruins the compiler's ability to tell you when you've missed one of the main enums. 
I suppose so, but when I write a switch statement on an enum, I don't think I've ever had trouble with missing enum cases, possibly for the sole reason that if you treat your default case like an error state, it's trivial to find the problem when you're missing a case. Not to mention that you can just copy paste the whole enum list into the switch statement and write the case syntax around it to ensure no missing cases assuming the enum is in a finished state. That just doesn't seem like a big problem to me.
I find the enums I use this trick for are rarely the enums I would use in a switch statment. It's usually used in cases I want to replace indices with friendier names and have the rest of the system adapt well to addition/removal of elements.
In addition to what people have been saying about switch statements, it requires you to use 0 index enums with sequential values. While this is often a best practice, it can be inconvenient when not. For example, consider a binary protocol with a byte sized message and a client which only implements a subset of the message types. enum MessageType : byte { StartConnection_Version1 = 0x01, EndConnection_Version1 = 0x02, Datagram_Version7 = 0x17, Datagram_Version8 = 0x18, // remove when we deprecate v7 FlowControl_Version2 = 0x26, }; void SendMessage(MessageType msgType, void* data, size_t dataLen); Sure, the count hack works 98% of the time, but why can't we have real language features that work correctly 100% of the time instead of hacks that work 98% of the time?
Super stoked for the Toronto meetup! 
What /u/last_useful_man and everyone else has already said. Also, if you do any header parsing and codegen (or when we finally do get reflection) now you have all these useless COUNT members to ignore in your metaprograms. I see your other comment: &gt; What do you mean by polluting switch statements? Can't you just catch it with the default case? Using the default case for this purpose sucks because you can't rely on the compiler to tell you when you've missed something somewhere. Knowing that I can just add an enum member, then go through all the places where the compiler reports a missing case statement brings me great peace of mind. The problem with `default` is that it's doing double duty. It's acting as both a catch-all case indicating that you have a meaningful default path and likely won't need to update this particular switch statement, as well as acting as a means of inhibiting the -Wswitch-enum warning. The most robust thing to do is this: enum class SomeEnum { A, B, C }; switch (some_enum_val) { case SomeEnum::A: do_A_things(); goto SwitchBreak; case SomeEnum::B: do_B_things(); goto SwitchBreak; case SomeEnum::C: do_C_things(); goto SwitchBreak; } // default case { log_error("invalid enum value"); return; } SwitchBreak: carry_on(); Ideally we'd have an attribute to put on switch statements that enable exhaustiveness checking regardless of whether or not there's a default case.
&gt; I recommend compiling with /std:c++17 /permissive- even if you aren't using C++17 features, There could be a problem, though, if you accidentally start using 2017 features that you aren't supposed to use yet. &amp;#x200B; &amp;#x200B;
Thanks for finding 
Yes I was a wäre of this. I should have written ~
Is this similar to creduce and delta?
I've twice run into an issue with "Find All" taking an abnormal amount of time. Other than that, two 40K LOC C++17 projects built without any issues, so the upgrade was smooth.
It could have been even easier: public: //exported module symbols here private: //Things internal to file here module: //Things public to the module friend foo: //Private symbols, and also public only to foo Each file should have been a module. The import declaration should have been affected by the above shown visibility keywords. Importing a module with children should import the children as well. The above design is 99% simpler than the proposed one while providing the same functionality. 
Not used at all will be the preferred choice by most individuals or groups. Time is limited, people want to add features, not write boilerplate code, if a language feature doesn't cut development time it will not be used.
Yes; use [vcpkg](https://github.com/Microsoft/vcpkg).
What is the status of the Modules in the latest compiler? 
I didn't even know about the concept of mutation testing, very interesting approach.
Looks sweet! I have pretty much the same but used BOOST_PP, MSVC runs out memory compiling once you go beyond ~32 members and it's rather slow though so I'm sure your version would be preferable anyway.
Slightly confused by this. I have been running the previews and installed an update the other day and now it shows “Visual Studio Professional 2019 RC” Version 16.0 on the About dlg. Am I on the preview channel or not? I did download the release installer and it seems to not install an other instance just offer to change this one which to me implies I am on the release not preview channel. 
Note: the Visual Studio Installer dlg just shows “Visual Studio Professional 2017” and “Visual Studio Professional 2019” no mention of Preview or RC.
Hi! Apologies for slightly hijacking this comment, but it's related. When is VS 2019 coming to "Microsoft Azure Dev Tools for Teaching" (or Imagine, Dreamspark, OnTheHub, as it was previously called)? On Imagine, it used to be there on the day it was released, but I can't see it on the new (and worse) "Microsoft Azure Dev Tools for Teaching" portal.
Hmm sorry, still not clear. So it's a VAX shortcut or a plain VS shortcut? And what does it actually do (i.e. what's the shortcut name)?
It's a visual studio shortcut that functions similarly to those two VAX shortcuts. Shortcut is Edit.NavigateTo or Edit.GoToAll in later versions
Hi Jens, Unfortunately I had to skip Meeting C++ 2018 due to the birth of my daughter, so I am really looking forward to joining in 2019. I think you miscounted the ticket categories :) 
Disclaimer: Not an author (relevant post by the author: &lt;https://lowlevelbits.org/draft/mull-it-over/&gt;)--but I will try offer some background. Mutation testing boils down to answering the following question: _How good is my test suite?_ Historically, the answers have usually relied on traditional coverage criteria, like statement coverage or branch coverage. Mutation testing can be thought of as "testing the test suite", by deliberately introducing defects--with the idea that a good test suite should not have passing tests after the bugs have been introduced in this way. Empirically, it turns out that not-so-good test suites often still have erroneously passing tests--and mutation coverage may be more informative about test suite quality (in terms of practical gains--catching software bugs); cf. "An Empirical Study on Mutation, Statement and Branch Coverage Fault Revelation that Avoids the Unreliable Clean Program Assumption", https://sites.google.com/site/mikepapadakis/ICSE17.pdf Related to mutation analysis in a broader sense, this is a very good read: "How Verified (or Tested) is My Code? Falsification-Driven Verification and Testing": https://agroce.github.io/asej18.pdf More background: + https://mutationtesting.uni.lu/ + https://github.com/theofidry/awesome-mutation-testing + https://lowlevelbits.org/llvm-based-mutation-testing-system.-request-for-comments/ + Mutation Testing Leaving the Stone Age - Alex Denisov, FOSDEM 2017 - https://www.youtube.com/watch?v=pVMupHK1BVY + Mull it over: mutation testing based on LLVM - Mutation 2018; Alex Denisov, Stanislav Pankevich - https://lowlevelbits.org/pdfs/Mull_Mutation_2018.pdf 
I recommend trying meson. Wraptool is fantastic -- it's like cargo, but for more than just one language!
**Company:** [Gritworld](https://www.gritworld.com/) **Type:** Full time **Description:** Gritworld pushes the boundaries of real-time graphics and computer vision and develops key technologies in graphic visualisation applications for the industry. Our focus is to improve the productivity of our clients in real-time Film and TV production, as much as real-time industry data simulation and visualization. We strongly believe in creating a work environment where people, ideas and results are more important than regulations and time sheets. Every human ticks a bit different, but we still share our laughs together. If you want to learn, create and grow with us, join us today. As a growing start-up Gritworld offers excellent opportunities for personal career development. *What you need for this position:* * You have 4 or more years of experience as developer in at least one professional environment * You finished a degree in computer science, programming or similar * You have a passion for clean coding and creative thinking * You have solid English language skills, both verbal and written *Required skills:* * Strong programming skills in C++ and modern standards 11/14/17 * Data-driven design and software architecture * Excellent debugging and optimization skills * Knowledge about common game engine systems, such as asset pipelines, entity component systems * Good understanding of multithreaded software architecture * Ability to work with an existing codebase, and eager to further improve it **Location:** Frankfurt am Main, Germany **Remote:** No **Visa Sponsorship:** Yes **Technologies:** Modern C++ (11/14/17) **Contact:** Apply [here](https://gritworldhr.bamboohr.co.uk/jobs/view.php?id=48)
Why do you have both `declspec(dllexport)` and `CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS`?
Great blog domain name. I'm awaiting an article called "Tom's psychedelic breakfast".
If you're happy with run-time reflection instead, for selected plain old data structures (including enums), the protobuf library can be a good solution, even if you never use the serialisation capabilities which are its original purpose. If you just want it for a single enum it would be huge overkill though. For the projects I've worked on, I've found this is sufficient that I would never need reflection baked into the language. A count of items in an enum wouldn't hurt though!
$999 is too much for learning c++. I suggest you look youtube free courses first and then try one of few udemy course(search for some coupons) like mastering c++ etc. Practicing c++ will help you a lot or try hackerrank for problem statements.
You are in my list, but if groups don't publish the meetings by the beginning of the month I don't include them later.
thanks for noticing :) Hope to see you in November then :)
Targeting C++23 !
hey there! of all the csv libraries out there yours is the most user friendly. I'm the one who reported the double value parsing bug a couple of weeks back. would also be nice to parse scientific notation like "2.4925E+02". Additionally, it would be nice to check before redefining things: /lib/csv-parser/include/csv.hpp:33: warning: "NDEBUG" redefined #define NDEBUG 
Uh oh, where did you the draft link? :-D &amp;#x200B; I tried to shortly describe our paper in the form of a blog post, here is the full (preprint) version: [https://lowlevelbits.org/pdfs/Mull\_Mutation\_2018.pdf](https://lowlevelbits.org/pdfs/Mull_Mutation_2018.pdf)
This should get you started - [LearnOpenGL](https://learnopengl.com/). It uses C++. It also shays away from GLUT and GLEW in favor of more modern approach with GLFW and GLAD. Lastly - check out [r/GraphicsProgarmming](reddit.com/r/GraphicsProgramming).
Agreed. Nice work. 
OpenGL is just a library for drawing stuff, but it doesn't do anything else. To be able to use it you need something else to create OpenGL context (either fullscreen or in a window). I recommed using SDL for that purpose. It's simple and portable, so one program will run the same on Linux, Windows and Mac. &amp;#x200B; Once you have OpenGL context you can start using OpenGL functions. OpenGL has very basic set of functions that you can use to draw points, lines and fill them with textures. GLU and GLUT are utility libraries that provide some more high level functions to make using OpenGL a little easier (there is a function that draws the teapot that you can use it to test various things, like the Hello World in graphics :) ) &amp;#x200B;
Thanks, i will check that out!
C is very portable and a foundational skill. I worked recently with the Azure IoT SDK for C. That is C 98 for platform portability reasons. I’ve worked on multi platform projects that because of compiler availability couldn’t use any features newer than C++ 11. 
That’s what I want to know as well. All I could find was a free trial download for professional, where is the pricing??
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/b9b653/opengl_in_c/ek3dmp1/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
We do something very similar based on conan.
FYI, I've moved the repo to Github at the request of others for ease of contributing. https://github.com/mathstuf/cxx-modules-sandbox/
Bookmarks, as far as I can tell :-) Nice work, by the way!
Unfortunately not, sorry. As STL says, we try to be clear about when new releases are coming so people don't get surprised, and we have the Visual Studio Subcriptions for a more rolling model.
That makefile is by no mean a full-featured one so it doesn't handle generated source files or building shared+static libraries. I would tend to think these are orthogonal problems to the module compilation support. That trimmed down makefile is however still generic when in comes to tackle the narrow problem of modules: it takes a bunch of source files, preprocesses them, extract dependency information (including module info), and generate dynamic extra ordering makefile rules (in .d files) so that they are built in the right order. Compared to the traditional generation of .d files as side effect of preprocessing/compilation, there are some subtleties that needs quite some attention to implement right, but don't seem to become overly complex (thanks to some features that only GNU Make has). It tries to implement nothing else but the basis of the process that you and/or you fellows have very well described in the ISO paper you kindly posted above. It's rough an all edges.
**Company:** [Mixlr](https://www.careers.mixlr.com/) **Type:** Full-Time **Description:** Mixlr is the simplest way to broadcast live audio. Our cross-platform tools enable audio creators, anyone from radio stations, podcasters or professional sports teams to easily manage and distribute live content to millions of unique listeners each month. We're looking for a talented C++/Qt engineer to drive our development process forward, while also contributing a positive impact to the team and culture at Mixlr. The team's a tight-knit bunch: social, hard-working, family-friendly and heavily inclined towards coffee, snacks and absurd sound effects. To find out more check out careers.mixlr.com. *Key Responsibilities* *Ensure code quality and maintainability of an existing Qt/QML codebase with best practice in mind *Design and implement new features on new versions of our broadcasting client *Develop automated tests and custom tools to optimise our CI/CD pipeline *Contribute to every step of the product development: sprint planning, requirements definition, retrospective *Contribute to code reviews and positively influence the team’s development process *Core Skills* *Deep knowledge of modern C++ and best practice in Object Oriented programming *Inherent and instinctive understanding of requirements, from testing to shipping *Communicative skills to share learnings and best practice with ease and clarity *Ownership, especially when writing code *Sense of curiosity to properly assess and positively influence the entire product delivery cycle **Location:** We're hiring for London, UK. **Remote:** For the right candidate, we'd consider applicants *only* within GMT±1. **Visa Sponsorship:** No **Tech Stack:** *Application: Qt, C++, QML *Network: HTTP, Websocket, Icecast streaming *Integration: Cross-platform builds using CMake, Vagrant, Jenkins **Contact:** Please apply [HERE](https://mixlr.workable.com/j/E1F050525A?viewed=true) or contact erika@mixlr.com (hope to hear from you!)
 [https://github.com/Neargye/magic\_enum](https://github.com/Neargye/magic_enum) 
I started with boost pp, seemed like there was a limit of 64 for a pp sequence so I stopped using it.
Enums often grow over time. This is an especially big problem when an enum grows in one branch and a new switch statement over that enum is added in another. Even if both developers were diligent and did the right thing, things are still going to (often silently) break when the branches are merged.
OK. Well, feel free to submit a PR to the project to add build examples for situations which are supported.
You may want to check out https://github.com/AnimatorPro/Animator-Pro It's an old DOS app being ported to modern systems with CMake and SDL.
All right. I have about a month to reduce my material to the allotted time ;-) Tough choices ahead...
Best of luck, cant wait to watch it online! 
Please note that SDL is a C library, while SFML is a C++. They both can do similar things, so you could choose here depending on whether you like working more with C++ than C or the other way around.
This is why we can't have nice things.
Hey /u/Puripnon, sorry for the delay. Finally got an answer for you. The post you were looking for is now up. [https://www.esri.com/en-us/about/careers/job-detail?req=10670&amp;title=Jr.%20C++%20Software%20Developer](https://www.esri.com/en-us/about/careers/job-detail?req=10670&amp;title=Jr.%20C++%20Software%20Developer)
\*\*Company:\*\* [L3 Unmanned Marine Systems @ Lafayette](https://www.asvglobal.com/usa-careers/) \*\*Type:\*\* Full time \*\*Description:\*\* We build autonomous and unmanned boats that are refining the way the world works at sea. We see a future where there is no job at sea that an autonomous vessel cannot do. Our passion for what we do comes from a firm belief that ASVs can save time, save money and ultimately save lives. Our company is growing and will continue to grow exponentially so long as there is water on our planet. We look for people at all experience levels including recent graduates, interns and experienced professionals. \*\*Location:\*\* Lafayette, Louisiana \*\*Remote:\*\* Not at this time. \*\*Visa Sponsorship:\*\* No. \*\*Technologies:\*\* C++11, Linux (Centos 7/RHEL), Qt, QML \*\*Contact:\*\* Apply [here](https://careers.l3tjobs.com/search-results?qcity=Lafayette&amp;qstate=Louisiana&amp;qcountry=USA)
would be more useful to #define html(...) construct_html_str&lt;##__va_args&gt;{} then template &lt;string&gt; struct construct_html_str where this struct can do some checks for balance (maybe at compile time, perhaps depending on the macro e.g. maybe an `html_runtime`), and the struct can translate it into classes e.g. `html_body(html_p("hello world"))` and then this could be used to send to a browser. it's nice bc no ugly macro hacks other than turning the input into a string. and you have access to classes like html_p(std::string) if you want to paste in variables etc.
Excellent! Thank you. I will definitely apply. 
People who hyper focus on tools and keeping their tools shiny and neat are like the guitar players who are very technical and are great at playing little technically challenging solos but they never compose music people actually want to listen to. They think they're being Mozart but they're not even Britney.
Fair point. Maybe there needs to be a new subreddit to showcase cool C++ software, where the pedantic language lawyer types are discouraged to join.
&gt;For all I know they are very sensible but I have to admit that I can’t imagine a use-case. Well, it's nice to see you admitting there is something you don't know. I was mistakenly under the impression that you're some kind of expert on C++ and 2D libraries.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/b9gp3o/cant_run_code_that_the_ta_gave_us_to_learn_from/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt;To be honest I don't understand your point here. The point is to show that you're a dummy and this supposed self-claimed expert can show you the proper way to write C++ code.
\*\*Company:\*\* [Unity Technologies](https://unity3d.com) \*\*Type:\*\* Full time \*\*Description:\*\* We are looking for a determined software developer to help deliver a world class scripting experience for Unity users. You will be part of a focused team delivering high quality, critical components to power scripting within Unity across all platforms. Hard problems and in-depth debugging sessions will be daily occurrences as part of delivering stable, portable, and performant technology for our users to build upon. A desire to learn and improve as part of a collaborative team is necessary. **Responsibilities** * Development and maintenance of all scripting runtimes: .NET, Mono, and IL2CPP * Integration, debugging, and upgrading open source software like the Roslyn C# compiler, the Mono runtime, and the .NET Core GC * Optimization of generated code size, memory usage, and execution speed * Research and development of Unity focused optimizations, extensions, and functionality within the .NET ecosystem * Communication of solutions and feedback to users via documentation, forums, and bug reports **Requirements** * Excellent C, C++, and C# programming skills * Excellent debugging skills * Experience developing across multiple platforms * Optimization and profiling skills * Proficient English speaker * Focus on quality/test driven development **Bonus Points** * Experience working with compilers, virtual machines, or garbage collectors * Experience contributing to open source software * Experience working with Mono, .NET Core, or Xamarin * Experience using Unity \*\*Location:\*\* Pittsburgh, PA, USA \*\*Remote:\*\* No \*\*Visa Sponsorship:\*\* Yes \*\*Technologies:\*\* C++, C, C# \*\*Contact:\*\* Apply [here](https://careers.unity.com/position/virtual-machine-runtime-developer/1600052)
It should just return a vector after you use get. \[index\] to access and push\_back to add. [http://www.cplusplus.com/reference/vector/vector/](http://www.cplusplus.com/reference/vector/vector/) 
auto [line, lno, path, fn] = call_your_function();
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/b9gzrq/i_need_help_with_my_c_project/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Thanks again for reporting that bug. I think I could probably add scientific notation parsing pretty easily, so keep your eyes peeled for updates.
r/cpp_questions Like you would any other vector, you can use iterators directly, or indirectly via a ranged for loop; or using the index with subscript, or the `at` member function. 
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/b9ge85/accessing_information_in_vectors_that_are_in/ek4jieu/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Thank you for the reply. &amp;#x200B; :(
Aside from using VS Code for C++ directly on Linux, you can also target Linux from within VS on Windows. After setting up an ssh connection, the build occurs on the Linux environment, and you'll get IntelliSense from your headers on the Linux machine. This was demoed for a bit during the Launch event, but hopefully this [Linux Development in VS](https://devblogs.microsoft.com/cppblog/linux-development-with-c-in-visual-studio/) blog helps.
Nice one. Didn't know about that. I only know that autodesk's 3ds max is from DOS era :)
As of Visual Studio 2019 Preview 2, we added a feature "add missing #include" which should address this nicely. If you haven't included &lt;functional&gt;, the offending std::function call is underlined with a red squiggle. Hovering the squiggle will open a Quick Fix (lightbulb) menu which offers to add "#include &lt;functional&gt;" for you. You can read our [blog post on the Add Missing #include Quick Fix](https://devblogs.microsoft.com/cppblog/c-productivity-improvements-in-visual-studio-2019-preview-2/#AddMissingInclude). If you don't see the red squiggle / quick fix, let me know!
Vcpkg is the best I've encountered. Hundreds of packages, curated, for Windows Linux and OSX. 
Okay thank you, `Edit.GotoAll` is `CTRL+T` on my system, with the default "Visual C++ 6" keybindings scheme in Visual Studio. Yes CTRL+T ("Go to all") is amazing indeed! An awesome "search/goto on steroids".
&gt; Additionally, it would be nice to check before redefining things Libraries should never define `NDEBUG` in any circumstance – that's practically guaranteed to cause ODR violations when people create debug builds involving multiple translation units. Users that don't want assertions will define `NDEBUG` themselves.
There is a very good C++ wrapper around SDL2, [libSDL2pp](https://github.com/libSDL2pp/libSDL2pp)
I downloaded and installed 2019 today, and tried on my project. Find all References took approximately 3 minutes to complete (at least it doesn't block) and using F12 regularly caused 25-30 second blocking stalls... 
As a guitar player I agree. Technique is just a tool to express yourself, it serves no purpose if you have nothing to say (musically). Some peoplecan express very much with very little while some nerd themselves down into technical details and practice until technique and practice becomes goal in itself. A lot music is written for other musicians, and lots of guitarists are creating music just for other guitarists. I guess programming like any other creative human activity is no exception. Some people forgett that tools are just help to get things done and let the tools control their work instead of their work controll the choice of tools they use. I am of course not saying against proper use of tools, and certainly not advocacing against good practices and habits, it all has it's place, but some comments in this threads were way superficial and tells more about slentrian nature of human beings who eat all the cookies served in front of them without proper reflection of what and why they eat. And yes, some composers farts sounds better than other composers entire symphonies, regardless of which techniques they use :-).
So you mean like this one? [https://cmake.org/cmake/help/v3.14/prop\_tgt/VS\_DEBUGGER\_ENVIRONMENT.html](https://cmake.org/cmake/help/v3.14/prop_tgt/VS_DEBUGGER_ENVIRONMENT.html) Or this one? [https://cmake.org/cmake/help/v3.14/prop\_tgt/VS\_DEBUGGER\_COMMAND\_ARGUMENTS.html](https://cmake.org/cmake/help/v3.14/prop_tgt/VS_DEBUGGER_COMMAND_ARGUMENTS.html) Which ones exactly are you depending on? &amp;#x200B; You have a lot more control from CMake than most people know about actually.
Well said. We're in violent agreement on this :) 
If it makes you feel any better, my variant changes \*just missed\* the deadline for VS2017 15.8 in (IIRC) June of 2018. 15.9 was "servicing and bugfixes only", of course, so changes I made \*ten months ago\* finally shipped in VS2019.
**Company:** [a.i. solutions, Inc.](https://ai-solutions.com/) ([Careers Page](https://ai-solutions.com/about-us/careers/)) **Type:** Full-Time **Description:** **FreeFlyer Software Engineer** Our company is hiring for a large number of software positions, all of which you can find listed in the sub-link [here](https://ai-solutions.com/about-us/careers/), but this posting is specific to the **[FreeFlyer Software Engineer](https://rew12.ultipro.com/AIS1000/JobBoard/JobDetails.aspx?__ID=*5EA76D5DB6A664BB)** position. I won't copy and paste the posting itself (though I encourage you to read it!), but FreeFlyer is a flight dynamics tool used by NASA, the US Air Force, the international space community, and commercial companies worldwide to manage their spacecraft within flight ground systems. The **ISS** team uses our software to keep orbital debris from blowing station out of the sky, which I think is _majorly cool_. Our tool of over 20 years of flight heritage has an engine written entirely in C++ with a front-end currently written in C#, and we're looking to add a developer to our team with 2-5 years of experience to jump in and get started helping architect the myriad solutions and features we plan to implement for our customer base in the years to come. We're not looking for someone totally freshly graduated, we want someone to have a little bit of experience in industry ideally working on large scale development efforts. You would be supporting our existing team through the complete design and development phase of the tool's many features, fixing bugs that are present in the code as reported by customers, working to grow an understanding of aerospace topics as they relate to our software development efforts, and hopefully stoking the fires of excitement about all the cool activities we support including the future of human spaceflight. **Location:** Just East of Washington, D.C. in sunny **Lanham, MD**. **Remote:** For the right candidate we would consider remote work from our **Houston, TX** or **Colorado Springs, CO** offices, though we have a strong preference for working on-site at our headquarters to be working alongside the rest of our team. We are extremely flexible in allowing our employees to work from home as needed assuming they have a track record of being able to be productive in such circumstances. **Visa Sponsorship:** No. We may only hire U.S. citizens. **Technologies:** FreeFlyer's astrodynamics engine is written in C++17 as I noted above and the front-end is written in C#. Additionally, there is value in having some Java, Python, Mean Stack, and Fortran experience for assorted tasks across the division and company, though they're not required for the role. We utilize many third party libraries in our tool including Boost and our visualizations are rendered via OpenGL. Our ticketing system is based in the Atlassian suite using Jira and our code is stored in Git with BitBucket. Security clearances are fantastic, but are not required for this position. We are a mature CMMI Maturity Level 3 company and group with full process documentation for all tasks, and we're all very excited about what we do and creating the best tool on the market! **Contact:** First and foremost I recommend applying to the position above, but then feel free to message me here with questions. Once we've had a chance to talk I'll give you my work email address and we can continue the conversation there.
why do you think someone with web programming experience will have an easier time getting proficient in C++? 
\&gt; To simplify the build and debug experience with the C/C++ extension, we added a command to help you generate build and debug tasks for single code files. &amp;#x200B; So happy about this. Sometimes, I just want to write a quick example to play around with a std library feature (or a header only library). This will greatly reduce the pain of doing that in VS Code.
&gt; 15.9 was "servicing and bugfixes only" Except for Ryu-powered `to_chars()` :-)
Correction: I checked in the PR on 2018-08-07, so it's been a mere 8 months.
As sort of a side-discussion, what was the reasoning behind `is_palindrome`'s inclusion in the Boost Library? Is there some application for palindrome's I am unaware of? This feels like something I'd only pull out in an interview question to be a smart ass and show off my knowledge of obscure boost-corners.
Things such as: banks, safes, messaging apps etc, that allow users to have two passwords, one normal and the "The I'm being forced to give up my password" where the latter will disable the account completely - will need an is_palindrome function to save the user from themselves. Having such a function standardised, means the company can claim they only use ISO accredited technologies in their security stack - which can be a big selling point. 
That's actually super interesting. Something I hadn't thought of. I probably came off as offering a backhanded criticism, but I was genuinely curious. Thank you for the answer.
thanks
I don't blame him it's hard to imagine adding features without cost and with c++ the rule is always "only pay for what you use" with the caveat being that you don't know if what you think you use is what you actually use and you start assuming there is always a hidden cost.
`std::clamp` exists since C++17: https://en.cppreference.com/w/cpp/algorithm/clamp
To use is_palindrome on a password would require storing the password in plain text. 
Glad to see they changed their minds!
Agreed. It was a ballache to have to copy over my pre-configured tasks and launch json files when all I wanted to do was test something quickly. This was one of the things I kept using Sublime Text for as it "just worked".
Not sure what is_palindrome has to do with that and what boost::is_palindrome has to do with iso. 
Oh I do like the "get_sv" form
Not sure if Trump.
This extremely useful for someone migrate from another IDEs. Moving to VScode helps me digging into debugger and compiler flags. And most importantly, saving time. 
Do I understand correctly that it only supports 8bpc images with no color profiles? Are blend operations gamma-aware or not?
Extremely too late.
Protobuf sucks in many ways. Thanks for the tip though.
Here is a cleaner implementation of `is_palindrome`: return equal(begin(c), end(c), rbegin(c));
It was an exaggeration, but every project that needs introspection has the developers writing visitation functions manually, so we are talking about a lot of code that its writing could be automated.
Well, you can always counter the fact you were presented with other facts; if you want a rational debate, that is.
I find Visual Studio Code weirdly positioned in the Microsoft eco-system. Visual Studio proper itself has been a major platform lock-in for a lot of C++ development, it kind of feels like Microsoft is trying to compete with its own paid product. With proper debugging in Visual Studio Code, llvm quite frankly being close to making the MSVC compiler obsolete, what really is the upside to using Visual Studio proper at all?
The C++ modules system has more rules than the entire language we have now. 
Not sure why that would be - admittedly our PCs are pretty powerful but F12 takes 2s max for me. Find all references took about a minute for a random symbol, and ctrl+, takes about 10s to fully populate (although it's normally found what you want before that)
Sweet.
As are ours - ive got dual xeons and 196GB ram. I've got visual assist installed on 2017, and after the indexing, find all References tales about 10-15 seconds and alt shift s/alt shift O (equivalent of Ctrl comma) are pretty much instant. 
If you're looking for BitBlit I think [PixelToaster](https://github.com/thedmd/pixeltoaster) should fit your needs, successor of TinyPTC. I found it suitable for reviving old DOS projects. Library provide frame buffer for user to fill in, timer, basic mouse and keyboard input. It is written in simple C++. Most basic example you can find there: [ExampleTrueColor.cpp](https://github.com/thedmd/pixeltoaster/blob/master/ExampleTrueColor.cpp) Also, [TinyPTC](https://sourceforge.net/projects/tinyptc/) is also an option if you need only frame buffer. It is C, and more 90'. &amp;#x200B; &amp;#x200B;
That's a crazy spec! Maybe it's disk related? We liberally use SSDs in our development machines. Also, in my experience, VAX often returned a lot of "references" with question marks because it managed a text match but not a proper symbol match - and it was frequently wrong with a good chunk of its matches if it was a common variable name.
That was the implementation in the initial PR; it was changed to avoid dependencies on `algorithm` and `iterator`. That it was deemed useful enough to include at all still amazes me.
&gt; ... it was changed to avoid dependencies on &lt;algorithm&gt; and &lt;iterator&gt;. Right, if one avoids `&lt;algorithm&gt;` and `&lt;iterator&gt;`, one must be writing great code.
Seems promising. Setup seems to require directX SDK in windows.
Only feature i need in VSCode now is possibility to use custom project files for compile and debugging.
The reference is marked as deleted after delete is called, but until something else needs that memory it may not be changed. 
1) Please post text, not screenshots 2) Please post your expected results, and the actual results 3) Please post these *types* of questions to r/cpp_questions (specific to your code and less general discussion) 4) Pointers and references are distinct types in C++. In this case you have a pointer, not a reference. 5) In your last `cout` line, you're accessing deallocated memory. That's undefined behavior. Anything could happen, which is bad in programming. You want to be certain what will happen. In this case, maybe anything could happen means the program didn't crash. In other case, it might give you a segfault. Don't rely on undefined behavior.
Because it would be wasteful to overwrite the memory. The memory taken by MyPointer will be reused at some point if the program kept running and allocating other memory. The same goes for MyPointer itself. C++ does not overwrite the pointer (e.g. with nullptr) when you delete it. 
`delete`, by default, does not: * Change the value of the designated pointer * Change the contents of the memory referenced by the pointer All `delete` does is tell the dynamic memory allocator that the memory zone is no longer allocated, so it can be reused later by `new`
So you mean that, the memory is not used (it's free) but in case i still need to use it i can still use it?
No, you definitely shouldn’t use it again if you’ve deleted it. There’s no guarantee that the memory will remain as is. 
And you are also dereferencing it, which you should never do on memory that has been deleted. 
&gt; Maybe it's disk related? You know the answer to this already :p I've got an NVM SSD and my "backup" drive is a Samsung Evo SSD. &gt; VAX often returned a lot of "references" with question marks because it managed a text match but not a proper symbol match You're not wrong here. I just checked and I do see a good few text matches rather than symbol matches. It can also sometimes give up and find a forward declaration of a symbol that's defined in the same file, rather than looking for the actual definition of the symbol. Agreed about the crashes too, although I'd still argue that until F12 and find references are consistently &lt;10 seconds it's unusable to me, unfortunately. I've followed up with MS and an willing to provide ETW traces for my use cases so hopefully everyone benefits from it! 
&gt;deallocated mem Thank you for your insights on point 1,2 and 3 (I will see to it that i comply). Regarding to point 4, i thought that pointers point to a memory address, and if i delete the pointer i will not be able to access the memory address.Please correct me if i am wrong.
&gt; i thought that pointers point to a memory address, and if i delete the pointer i will not be able to access the memory address It's the difference between *may* and *can* (but who knows what will happen). The memory will, as you observed, likely remain accessible. However, it's not guaranteed to. It could be overwritten at any point. Accessing it could screw with compiler assumptions that affect seemingly-unrelated program behavior. The formal term for this in C and C++ (as mentioned by someone else) is "undefined behavior", commonly abbreviated UB. If a program invokes UB, it is allowed to do *anything*, and unpredictable and undesirable outcomes are common. (Writing (or reading) past the end of an array is also UB, and that's why it's possible for that to lead to security vulnerabilities.)
You are (probably) able to access the memory address, but the data might have changed, and your program might crash.
&gt;Change the contents of the memory referenced by the pointer Oh okay, thank you so much. Now i totally got it.
Hmmm my point 4 is about references vs pointers, but I'll also respond to your question. Pointers are values, just like an `int` is a value. What's the value of an `int`? A number. What's the value of a pointer, `int*`? An address. So it's inaccurate to say "pointers point to a memory address". A pointer IS a memory address. A pointer that points to a memory address would be a pointer to a pointer, like `int**`. ---- Now the second part: "if i delete the pointer i will not be able to access the memory address". If you delete a pointer, then it calls the destructor and frees the underlying object. In terms of accessing the memory afterwards, as I said, it's *undefined* what will happen if you to try to access that memory afterwards. The compiler will still generate the machine code to access the memory, if you try to access it, but the program might crash or it might not. ---- About references vs pointers: `T*` &lt;- pointer `T&amp;` &lt;- reference Where T is any possible type you could think of. easy peasy
I haven't used the VSCode in anger, but is the debugging as good and fully featured as VSStudio proper? Also are there are any issues with MLOC+ projects?
You can't refactor properly in VSC. You can't auto generate declarations, overrides, structs etc. You can't profile nearly as well... VSC is really VS-light for Cpp. If you're doing some toy project or if you're one of those people who think writing Cpp on Nano is fine, then yes, your question might make sense. But if you want a proper IDE, VSC is simply not there yet 
Visual Studio has far better C++ debugging tools and features. For example, debugging a leak on VSCode can be absolute nightmare, while on VS proper I can just take 2-3 heap snapshots, generate a diff and check who is allocating memory without releasing it.
I phrased that wrong, because I don't actually know what the situation is for VSCode when it comes to C++ development, I get the impression that it's getting there though. I use VSCode for python development and all text editing needs, and it's definitively growing on me.
Oh okay got it. Thanks.
I would love to find myself a remote job. I live in Denmark where I guess most of these employers do not live. 
Novadays DirectX headers are in Windows SDK. Inclusion of d3d9x.h can be commented out and code should work. In fact I just pushed an update to repo removing this dependency. This should make it easier to use.
Ah, makes sense. I don't actually do C++ development in VSCode yet, but I do feel it's getting there. As an editor there's a lot of advantages for VSCode. It's way snappier, multi platform, way more extendable, and naturally way better at editing source in a wider variety of languages. I could definitively give up some features in MSVC if we could get VSCode + llvm going across OSX/Linux/Windows. For source editing I find 90% of the relevant stuff in MSVC right now comes from visual assist anyway, so if the tomato people could get it going on VSCode would go a long way.
It sounds like a really nice feature. How exactly do you take these snapshots of who is allocating memory?
The implementation is fine as an optimized version, but not necessarily useful for the reader of the blog post.
Thanks a lot for this, i did not know things like `-fsanitize=address` and undefined behavior i will surely try `-fsanitize=address` out and learn more on undefined behavior.
While debugging, open the "Diagnostic Tools" window from Debug-&gt;Windows. From there, look in the "Memory Usage" tab.
Thank you.
Aren't you dividing by 0 here: `float xREM = (startY / (endX - endY)) / 2;` at the second call to this method? endX and endY are both 200, so it's (100/0)/2
https://cmake.org/cmake/help/v3.8/command/add_definitions.html Or for the more modern target based approach: https://cmake.org/cmake/help/v3.12/command/target_compile_definitions.html 
Use pre-compiled headers, you should get your compile times back (atleast after the first compilation).
Maybe a stupid thoughts, but not worth to not delete the pointer at all? I mean, when an object reach the destructor, then it will delete it anyway. So, not better - *in some case* \- to not handle this kind of things sometime and let the compiler take care of? 
This was more clear and elaborate. I appreciate your efforts to explaining this to me in detail.
thank you.
I know we really like jumping to UB as the reason for things... but it is also useful to describe *what is actually happening and why*. The compiler is putting out an actual binary, after all. "Here be dragons" is only useful so far.
It's worth mentioning that Visual Studio 2019 runs static analysis in the background and highlights these kinds of issues in the editor.
It's like you've never even heard of Poe's law :-)
I beg to dis-agree, showing that one can write one-liners, most likely correct code (by design, standing on the shoulders of giants), is what a blog should show. That was also the [my] intended message regarding the remark in respect of avoiding `&lt;algorithm&gt;` (and to a lesser extent `&lt;iterator&gt;`).
That "remark" was not an opinion on the merits of avoiding those headers; it was a factual statement on why the code in Boost is not said one-liner, as read on the Boost-dev ML when the algorithm was submitted a couple years ago.
&gt; I mean, when an object reach the destructor, then it will delete it anyway. Raw pointers have no destructor; without an explicit `delete`, the deallocation would not occur and there would be a memory leak. In this case it would be a benign one because the program is about to exit anyway, but it's a bad habit to get into anyway.
Just remember... the first one is global, the second one is just for a target. If you're working on a large project, use the second one as much as you can.
DLL are completely unknown by the standard. It's behavior is defined by your platform. If there's unwanted behavior, report it to your implementation.
Sorry for not being clear, I meant my own remark. Boost suffers from NIHS (and that will ultimately be its downfall).
I don't know how far this metaphor can be stretched, but as far as it goes it's brilliant. There are older and fouler things than cmake in the build systems of the world.
The only one MS product I want to use nowadays is VSCode :)
Btw, constinit made it into C++23? I do not know rven what that does. I thought constexpr covered all those cases already...
While I agree with you, I don’t want to speculate on `delete`’s implementation if I don’t know the environment, especially because describing what’s happening in a simple example won’t be representative for a more complex example involving class types and memory with different alignments. 
There’s constinit, which specifies that something should *not* by dynamically initialized (*shrugs*)
Why not just use a graph-library like [lemon](https://lemon.cs.elte.hu/trac/lemon)?
\*\*Company:\*\* \[ Stevens Capital Management LP!\] ([https://www.scm-lp.com](https://www.scm-lp.com)) &amp;#x200B; \*\*Type:\*\* \[Full-time\] &amp;#x200B; \*\*Description:\*\* \[ Stevens Capital Management LP (“SCM”) is a registered investment adviser that manages a multi-billion dollar hedge fund that has been in business for 30 years. SCM specializes in the rigorous development and disciplined implementation of empirically based quantitative trading strategies. Our highly productive team works in a fast-paced collegial environment, utilizing extensive data sets, technology and the scientific method to devise and employ trading strategies throughout the world’s most liquid financial markets. &amp;#x200B; \*\***C++ Developer\*\*** \*\***Primary Responsibilities:\*\*** * Develop new software and enhance existing systems in C++ on a linux platform. * Create tools to process, store and analyze quote, order and financial data. * Work closely with our quantitative research analysts, engineers and other groups to provide software solutions. &amp;#x200B; \*\***Requirements of the Candidate include:\*\*** * Undergraduate or graduate level degree in Computer Science or Mathematics. * C++ programming experience in a Linux environment. * Excellent academic record. * Strong problem solving skills. * Knowledge of shell scripts and other languages including Perl, Bash or CSH is a plus. * Knowledge of relational databases including Sybase, SQL Server and Oracle is a plus. &amp;#x200B; \*\*Locations:\*\* Philadelphia, USA &amp;#x200B; \*\*Remote:\*\* On-site &amp;#x200B; \*\*Visa Sponsorship:\*\* Yes &amp;#x200B; \*\*Technologies:\*\* C++, Linux &amp;#x200B; \*\*Contact:\*\* Please apply directly to \[SCM!\] ( [https://www.scm-lp.com/careers](https://www.scm-lp.com/careers) ) &amp;#x200B; 
Is Visual Studio Professional 2019 Standalone backward compatible with all Visual Studio Professional 2010 projects on? Why Microsoft offers Earlier versions for Standard Licence and not offer for Standalone? What is the catch?
I must be hallucinating: &gt; Book signing at the ACCU conference &gt; &gt; If you're going to the ACCU conference next week, pop by and say hi and my stand for The Legacy Code Programmer's Toolbox! &gt; &gt; The stand will be up on Thursday, April 11. See you there! &gt; &gt; Cheers, &gt; Jonathan Book-signing?
I once heard somebody saying something like: "CMake is terrible, but better that anything else we have... So, it seems like a perfect match for C++", or Samwise, for that matter :)
Undocumented, gigantic Makefiles with weird assumptions about the environment are clearly better than CMake. No one dares to touch the Makefile, so nothing can ever break!
**Company:** [Optiver Europe](https://www.optiver.com/) **Type:** Full time, Summer Internships **Description:** Optiver is a leading trading firm driven by technology with over 1000 employees world-wide. We pioneer our own trading strategies and systems using clean code and the most advanced technology, running a global network with thousands of high-performance low-latency applications. Our engineers take ownership for the full stack of applications and the entire development life cycle. Working in collaboration with our Traders and Researchers, they develop proprietary software that is often deployed into production the same day, with immediate results and a direct impact. If you enjoy working in a fast-paced environment with a short feedback loop and are interested in joining our technology team of over 150 people from 40 countries, check-out our career opportunities. ***Jobs @ Optiver:*** We have opportunities at any level in your career! From graduate to years of experience. We are looking for exceptional engineers, who favour simple solutions for complex problems and have a passion for clean code and good architecture. Knowledge of financial systems or trading is not required. * [Software Developer](https://www.optiver.com/eu/en/job-opportunities/eu-1243339)/ [Graduate Software Developer](https://www.optiver.com/eu/en/job-opportunities/eu-510831?gh_jid=510831&amp;gh_src=6c0pe11) * [Application Engineer](https://www.optiver.com/eu/en/job-opportunities/eu-1207954)/ [Graduate Application Engineer](https://www.optiver.com/eu/en/job-opportunities/eu-652166) * [Network Engineer](https://www.optiver.com/eu/en/job-opportunities/eu-1615230) * [FPGA Engineer](https://www.optiver.com/eu/en/job-opportunities/eu-510906) * [And more](https://www.optiver.com/eu/en/job-opportunities/all/Technology/Amsterdam/) **Location:** Amsterdam, Netherlands **Visa Sponsorship:** Yes **Remote:** No **Technologies:** C++14 on Linux, next to that C#, Python and Lua and FPGAs also form part of our technology stack. **Contact:** Please e-mail Jinre van der Veen or Patrycja Ostrowska at [recruitment@optiver.com](mailto:recruitment@optiver.com) for any questions.
I am currently taking Data Structures in University. I wanted to learn how build a graph from scratch. 
Fair enough. r/cpp is not ~that~ kind of sub-reddit, it's about general news interesting for the larger cpp-community. You could post on r/cpp_questions or https://codereview.stackexchange.com/, where you could have/get some feedback and constructive comments regarding your project.
To answer your questions about the debug experience, no it is not as good in VSCode. It is a much better and integrated experience in VS. It is getting better as time goes on in VSCode but it lacks the decades of work that have gone in to VS proper. 
Alright. Will do that. Thank you!
How would you define the initialization order? What kind of help do you expect from the language regarding multithreading?
I recommend it! For a quick question r/cpp_questions is good (the good peops there won't dis you for not formulating your thing perfectly (contrary to stackoverflow.com) and on https://codereview.stackexchange.com/ the peops there will give you the Full Monty (warning, sometimes not good for self-esteem, but you'll be a better person/programmer thereafter).
Well, nothing has made it to C++23: We haven't finished C++20 yet. &amp;#x200B; Last February (in Kona), the `constinit` feature has been approved by the Evolution Work Group for integration into C++20. For that to be successful, the proposed wording changes have to be reviewed and approved this July (in Cologne) by the Core Working Group, and then the proposal has to be approved in full committee session. (I don't anticipate problems, but you never know.) &amp;#x200B; `constinit` is different from `constexpr` in that it's only a marker for the initialization itself, not for the affected variable. I.e., the initializer has to be a *constant initializer*, but the variable may be mutable (whereas a `constexpr` variable is not mutable). E.g.: constinit int ci = 41; constexpr int ce = 42; int main() { ci += 1; // Okay. ce += 1; // Error. return 0; }
Alright I'm going to say some heresy now. This is me discrediting myself from being respected ever again, this is my springtime for hitler I hate cmake. I hate make. I hate all of the build systems because they're all universally terrible by virtue of being text based What I like is codeblocks's build system. I'm only a simple lonely indie (or small team) developer, so I don't need anything wildly complicated. It is literally impossible for me to make mistakes, because you can simply clone a build system. It comes with a default project set up. Bam I never have to type anything other than -lnameoflibrary under linker settings, and that's a hard compile error if its wrong. I can easily make virtual targets. Adding new files is trivial because it automatically integrates with the build system. Compiler settings are discoverable Codeblocks **is not good**. Its autocomplete is rickety at best, and it lacks tools compared to modern compilers. Because of this, I had an initiative where I sat down and tried to use alternate IDEs. I skipped only visual studio (as a dedicated replacement) for ideological reasons, although I've used it extensively recently WTF is going on with all IDE's. The build system integration is terrible. Trying to get QT to work with cmake required an understanding of cmake syntax which seems baffling. There were untyped strings everywhere. QT's other build systems were also... not very good to put it gently, either deprecated or they didn't work. Its hard to make release/debug/profile configurations, and editing settings is editing compounded strings of text, instead of fail-proof checkboxes I am building a game in codeblocks (simple c++17 mmo, sfml/imgui, and also relativistic light propagation because I am incapable of making fun). Its super easy for me to create a "deploy" configuration from within the ide that automatically copies all my binaries onto my pre-prod server, as well as uploading binaries directly to steam. Server deployment is a two step process (build -&gt; reboot). Deploying to steam is a 3 step process (build -&gt; batch file -&gt; deploy because I intentionally added another safety check) Using cmake and other build tools feels like stepping back in time 20 years to when unix was cool and tar -gxzfyq was considered UI design I get the incredibly distinct feeling that people just hate text based build systems because they're terrible to use full of errors and you have to learn syntax for literally no reason but nobody feels confident enough to say it because its become like a cargo cult of "l33t haxxors" and you have no idea how to do anything because every single build system uses a completely different set of languages and references and terminology and structure and everything. There's no discoverability of features. We've added programming to something which only needs programming in the worst case (complex build deployments, very custom builds), and programming is hard. A scripting language as part of your build can be useful. I don't know why its cmake. I don't understand why cmake was built other than that people seem to hate themselves and want to make life as intentionally hard as possible on programmers who want to write code instead of writing code to make their code go And don't even get me started on git on the cli vs tortoisegit the end
I meant C++20 sorry for that! I see what it solves now. Compile-time initialization but mutable afterwards.
Is there any easy way to achieve this in visual studio? Something like the intellij scratch files.
Personally, I think monstrosities like GNU autotools have give makefiles a bad name. I regularly work on a project that's entirely built by makefiles and I find them pretty easy and straightforward. GNU autotools is a huge pile of poorly documented shell scripting and macro skullduggery that was designed to allow a project to be compiled on a dozen different UNIX variants with differing buggy and poorly standards compliant compilers, linkers, runtimes and implementations of "make". If you're just targetting one or a few modern operating systems, it's totally unnecessary. Despite ostensibly supporting things like VMS, Windows and OS/2, it never really worked outside of UNIX-like systems anyway.
As someone who learned programming in Windows, Makefiles were one of the fiest things I tried to learn when coding on Linux. Every tutorial I find starts explaining how to include all headers and source files and just plops down a mess of special arguments that's barely readable if you haven't memorized what it does. It honestly felt like the stereotypical "programmers of old made things needlessly obtuse to show how smart they were" kind of thing.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/b9s39n/noob_here_if_a_2d_matrix_is_created_using/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I think a big problem is that different IDEs have different ideas for *how* a project gets handled. For instance, Visual Studio keeps a *massive* XML configuration file, but unless you're working on a large project yourself, you barely need anything more than the "when was this file last edited and built so we know when to rebuild it if it changed" and basic include and linking settings. CMake also tries to unify this, but it becomes unwieldy because of how many features of IDE specific. For example, all my Visual Studio projects have to define a default startup project, because if I don't set it, every time we run CMake it defaults to the Zero Build project (as if I *ever* wanted to run that instead of my project). Now, personally, I think this behavior should be default, but it isn't.
We have Rust now and its build system.
Or very capable and easier to use. Meson.
You're so confident that you're right, above my experience, and other people's experience. I've told you to look up the advice on Google, but you dismissed them out of hand as wrong, and then you expressed incredulity at what amounts to basic C++. Why should I do your homework for you? I'm happy to let you wallow in your incompetence and knowing that you're not the type of person that will ever let yourself get better.
I am so with you on the UI arguments. With cmake, I'll tell you that it's far easier for a user than it is for a developer (much like a C++ lib lol). As a user, I love projects with cmake (using cmake-gui) because I can actually get it to work even when the assumptions of the developer about the deploy environment are violated. It sucks at auto finding things but so long as I have an opportunity to fix it manually within a decently intuitive UI I'm golden. I'm very sad that git is more popular than mercurial because TortoiseHG is the best goddamn UI I've ever used for a VCS.
I agree with you to a certain degree. I think CMake is absolutely not pleasant to work with. Make is even worse. I may be nitpicking, but I think your definition of text based is pretty odd. You said that the Codeblocks build system is XML - that's text. Visual Studio solution files are text. So they are text based. It sounds more like the difference is imperative vs. declarative. And the main problem is that IDE support for the build systems is poor, which I absolutely agree with. And I also don't think the design of CMake makes such integration easy. I like the idea of automatically creating a build file when creating a new project in the IDE and being able to easily edit it directly in the IDE. But I also want to feel like I am in control of my build files and want them to be portable, which is where Visual Studio solution files break down for me. I kind of like build2's idea of being mostly declarative, but with the possibility to do some more advanced stuff. It feels like it could work fairly well to integrate with an IDE. But it also feels like there are so many files for a build2 project that are all over the place that it becomes harder to reason about, which is probably my biggest gripe with it. Anyway, the current situation with both build systems and IDE's in C++ sucks right now.
I think the value and real learning this comes from getting involved with a good cohort that you can talk to and ask questions. If you take advantage of that then it could be good, otherwise your time and money might be better spent elsewhere. For example for $1000 you could go to CPP Con. 
&gt; While I agree with you, I don’t want to speculate on delete’s implementation if I don’t know the environment, especially because describing what’s happening in a simple example won’t be representative for a more complex example involving class types and memory with different alignments that may or may not sit on page boundaries, where a specific malloc/free implementation may do something different. To be fair, the vast majority of delete implementations just call free directly. MSVC is unique in only 1 of it's delete implementations: aligned delete, which it calls _aligned_free. libcxx does this, stdlibc++, MSVC does this. It's not something that it's unfair to assume.
&gt; […] does not: Change the contents of the memory referenced by the pointer Not _quite_ true. Depending on the implementation of the default allocator (or operator delete), deleting a pointer to a large(-ish) memory area could cause it to be unmapped from the process's address space. The contents is gone (until the VA is possibly reused) and accessing the memory will segfault.
VSCode is awesome for small to medium web development projects, which is what I mainly use it for. For something like C++ I'm way too spoiled by the full Visual Studio IDE. There's nothing that comes close. I hope MS invests more resources into getting the full VS IDE to work (natively) on Linux.
I'm really liking GN which is used to build chrome. The only outstanding issues I have with it is that it depends on some chrome dependencies project, and porting projects from cmake is a pain (more because of cmake). 
Here's something that will really piss everyone off: The reliance on Make/cmake is because C won the war, but there's nothing to say that a compiler can't be smart enough to figure out where things are and link them itself. &amp;#x200B; Basically we all use these shit tools because of inertia. 
Except the only reason Cargo is simple is because it forces you to only have a sensible structure. I find cmake about as simple if you just stick to conventions layout. It's 99% declarative and you just specify which files build which targets and the specify the intertarget dependencies. Easy peasy. It only gets ugly when you start to do crazy stuff, which unfortunately is very common in legacy stuff where each project organised the code in their own snowflake way
As a user of cmake, I love it when it works, but hate it when there's some blank variable hidden somewhere in the project's configuration that the dev insists on being set to one of three things specified in the README, and cmake-gui doesn't expose a box to define the thing. I feel like I see that too often...and that having the variable at least mentioned in the README is being a little optimistic.
Make is much simpler than C++ though, so if you can learn C++ why not a build system? It actually seems like a common thing among my colleagues, they are very smart and know tons of C++ corner cases. But when it comes the build system they just wing it and refuse to actually sit down and learn it properly
OK. Noted. That's github recentralisation over a decentralised system like git, heh :)
This is not a meme subreddit. 
&gt;because they're all universally terrible by virtue of being text based &gt; &gt;... &gt; &gt; What I like is codeblocks's build system. ... Its XML so its mega easy to edit if you need to by hand which I have needed to do single digit times. &amp;#x200B; Isn't XML text? I know nothing of codeblocks ... is your point that codeblocks has GUI tools for telling the build system what you want to do so you do not have to learn the syntax of the text representation? &amp;#x200B;
CMake isn't the only option though. It may have been the only good option five years ago, but recently the 3rd generation build systems have become ready and going with something like Meson or QBS is a much nicer experience overall.
Thank you for both answering the question OP asked, AND providing the "correct" way of doing things.
The thing that still surprises me is how opinionated the debate over build systems has gotten. Somehow, everyone seems to agree (well, at least many) that cmake is not perfect, while at the same time fiercely opposing any alternatives, that IMO bring some much needed innovation and fresh ideas. &amp;#x200B; As a developer of a reasonably well-received build system myself (I won't utter its name here, as that will get me downvoted) I can definitely see the appeal of cmake as a defacto standard for building C/C++ projects, but I wish the community was more accepting towards different approaches.
Modules having nothing to do with it, it doesn't affect `constinit` at all.
Because in ideal case, you write it once and forget about it, especially when you work with bigger projects over years. Learning all shitty quirks of build system just to not touch it for the next N-months seems like waste of time.
The issue is more that it's the library/opensouce project makers that first need to be convinced, users will follow if those build systems are indeed superior.
Because doing it has a cost.
ERRATUM: both github and gitlab repos contain the same. It's the content of the master and docker branches that totally differ :O
&gt; BTW I know only one widely used 2D library that uses namespaces, which is AGG (and maybe cairomm, but not sure how much used it is). Others such as Qt and SKIA don't use namespaces and it seems just fine. Indeed but that's only 2D libraries, there are other libraries in other domains that have different approaches. Your rational makes sense to me as long as "cross-language compatibility" is a feature. I think the only other way to achieve that is to go remote-protocol and that's probably not what you want here. It would be cool if the proposal from Herb Sutter about an optionally used fixed ABI had traction, that would have, I think helped with these issues. Anyway...
Why would you just leave it? The build system needs to evolve with the rest of the project like any other code. 
+1 for that, we commonly see scientific notation in our work. 
Location: Nebraska Looking for full time development or devops position. 6 years development experience in proprietary software development, 1 year cpp. Looking for local jobs or ones where remote working is possible.
cmake bad meson good
Note: after re-reading my comment, it feels like a rant, and it kind of is. It's not targeted at you. I just really don't like build systems because they seem to take the least-efficient approach possible instead of adopting sane defaults, and they tend to have trash documentation. &gt;But when it comes the build system they just wing it and refuse to actually sit down and learn it properly Honestly, this is probably because so many build systems are just needlessly convoluted. CMake, for example, defaults your startup project to "ZERO BUILD", but if you're using Visual Studio you'll *never* (or very rarely) want that to be the case. So you have to include the VS-specific command to set the startup project to your actual project. But then you need to add OS and IDE-specific `if` statements in your CMakeLists.txt file. These kinds of things should be default behavior (since the majority of people end-up doing it by default), but no, build systems seem to take the extreme "What if X?" approach and make *everything* optional, while doing the bare minimum for "default" builds. This just leads to people having to find and use the most obscure commands just to get a project working as intended, or configure their IDEs to work around how the build system works. And it doesn't help that a lot of these build systems seem to think they're C++, and adopt its backwards-compatibility principles, when redesigning some parts of the build system would allow things to be much cleaner. All the "target_X" commands in CMake are "the modern way to do things", but people don't use them because a quick Google search to find-out how to do a certain thing leads to 6+ year-old Stack Overflow posts that use "the old way" instead. Hell, the SFML team recently "modernized" their CMake integration. They made a whole Reddit post about it, but when I actually tried to use it, I had to do a bunch of "old-school" CMake. Why? Because their modernization doesn't actually use "modern" CMake, it uses "old modern" CMake. Not that I blame them, because God-forbid CMake update their documentation to put the modern approach first and give a warning to features that should be deprecated in favor of the new ones.
I'm guessing you aren't looking for a criticism of your code decisions. But why use MPI? I would think std::thread is more than sufficient for this task.
The thing is nobody likes wasting time compiling, so inevitably any time spent messing with the build system is going to be a chore.
I'd do with shared mem or something, but it is for an university job. They asked me to parallelize an algorithm that uses multidimensional structures with MPI, so i thought that in my case the best option is distribute the picture to the threads.
Yup... Something like this is the dev's fault but it's hard to get it right as a dev so shrug.
If I remember my 80s technology correctly, MPI is multi process not multi thread. but you can index-subdivide your domain and perform the calculations with just a few lines of code using std::thread. &amp;#x200B; And judging by your choices of int\*\*s I'm guessing your professors are either C or Fortran-70 trained.
oh... okay I'll fix it
I just put myself in the frame where CMake is basically it's own scripting language, and there are best practices for it. After spending months working with CMake day to day, it actually makes sense, and it only makes sense if you know the layout of Makefiles. For example, if you try to use an XML builder library without knowing the layout of XML, you're going to have a bad time. It finally hit me that a target in CMake, is literally going to be a target when the makefiles are produced. The properties of the target is the info that's going to be used to build it. Everything revolves around targets, their properties and limiting the scope of exposing those properties to other targets when they're linked together. For example, if you have a bunch of executable targets that you're going to be making, and you just want to run that one file. You can literally do: `make my_exe` and it will only compile that one. `make install` means at some point install had to be designated a target. I'd recommend looking at this [modern cmake tutorial,](https://cliutils.gitlab.io/modern-cmake/) it's great. 
I'm just using int\*\* because when i want to scatters the buffer i need to use a mpi type, so MPI\_INT is what i could use, if not i'd work with Mat image normally as my sequential code. &amp;#x200B; But is strange for me use MPI for this situation with memory working instead openmp. Thanks for you reply.
That's not the compiler's job. Then you'd have to have a different compiler for every type of use case. Make is just one way of helping you create *your own* simpler interface. But there are other tools that automatically handle more stuff for you. If you like the Go model, for example, there's no reason you couldn't have a tool that "just works" with C/++ the same way, but gets to reuse the same standard compiler under the hood.
I mean, that argument is a bit lazy, as well. There is a very, very high likelihood of what is happening here pretty much being literally what I'd hypothetically quoted, and it wouldn't hurt to say "In most implementations, and most likely here...". Heck, aside from implementations potentially using `aligned_malloc`/`free`, I can't think of any mainstream ones that wouldn't match that pattern in almost all situations, especially one this user is likely using.
Would SDL_BlitSurface be faster in some way than using SDL_RenderCopy(SDL_Renderer *, SDL_Texture *, ...) ? Here's my minimal example of 2D drawing on the CPU in SDL: https://gist.github.com/CoryBloyd/6725bb78323bb1157ff8d4175d42d789
you could make a class and put all your globals in it/add locks. but i should hate to always have that even when I don't need it bit like wearing a coat year round even when it's hot out
I'm not sure that allocating as a double dim array doesnt gurentee that the rows are contiguous. Try to allocate as a 1d structure and impose a 2d addressing scheme ( I = i*n + j for row major ). Alternatively, you can Scatter the rows individually, but I'd advise against it as it wont scale.
I'm not sure I'd this is causing issues, but typically with MPI programs you use continuous data stores, so even if you do something in 2d the array is allocated in one chunk. I'll try to give more info later, but I'm in mobile so can't compile and debug what is going on. Do you have an input file you can share?
Correct. I may yet merge them since it seems Cirrus CI supports not wasting hours building gcc for every merge into `master`. I want to test that before I do that though.
I dont think that contiguos mem is the problem, i could use scatter fine if i put a single if(!ip); but the program freezes at the gatter moment. So i dont know how is scatter working btw. I have used pictures with more than 1k rows-cols more or less, any picture is valid, when the program does not execute with error i will debug any case with % operator for all sizes. Thanks for reply! 
I meant static initialization order between different modules
Are you trying to scatter or gather across dimensions at all? If so then your non-contiguous memory is almost certainly an issue.
I think you're right with SDL_RenderCopy, my knowledge is a little dated. The migration guide from SDL1.2 to SDL2 shows and compares the different video methods better than I could do and favors your method. https://wiki.libsdl.org/MigrationGuide#Video
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/b9pks8/can_someone_please_explain_to_me_why_the/ek73ixa/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I want to fragment the picture with rows/num_proc average, scatter and then gatter. Maybe im wrong
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/b9q7u3/add_define_flags_with_cmake/ek73k84/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/b8uo5a/this_program_prints_no_move_ctor_why/ek73nn5/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/b8vtuh/fron_nodejs_to_c/ek73oer/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Scatter and gather *what*?
Sorry, i mean i want to scatter a picture as 2d array. What i do is initialize the matrix with a Mat image from opencv
You want to understand your toolchain no? How the text you write gets transformed into machine code. That involves understanding your build system
I think you're missing my point. I'm not saying CMake doesn't have it's quirks. It's that I see devs with shitty build system setups because they don't take the time to learn those quirks, using "All build systems suck" as an excuse, while they at the same time happily learn the many more quirks of C++ It frustrates my to no end that my colleagues spend so much time and energy to learn C++ in great detail and then just throw their hands up and refuse to learn their build system
My understanding is that it's not changed compared to static initialization order between translation units?
This only works on random access iterators... which is likely why the implementation is the way it is.
In the send/recvs you’re doing sizeof(pointer_to_arr), your pic struct, when you’d want to be doing to size of what you’re sending instead (3 ints) I think from the pastebin. 
The fact that CMake is winning the build system war is a testament to how shitty of a situation the C++ community is in. When people who understand or are well paid competent C++ programmers are dicking about in a declarative / procedural language frankenstein of a language which makes visual basic seem like the most elegant language on the block you know something is wrong. In the meantime python developers just go ´pypi install whatever-the-hell-I-want` no matter platform.
&gt;Note: after re-reading my comment, it feels like a rant, and it kind of is. It's not targeted at you. I just really don't like build systems because they seem to take the least-efficient approach possible instead of adopting sane defaults, and they tend to have trash documentation. This is also true of most software. I think you have misidentified the problem. You don't like software! This is a joke about software, not what you do or don't like. In truth I think one issue is just how flexible C++ is as a language. Should we structure our C++ files to make the build easy? Yes. Do we? Not usually.
I love the extension, however the IntelliSense engine generates huge files in the ipch folder (precompiled headers) since this update I believe. A single header file can generate a hundred megabyte of IntelliSense data or something :/ The default maximum for a project is 5 Gb or something! What gives? 
In my case is because lack of proper info or a really good doc of CMake, i bougth the kitware book and is only the online docs printed, the problem is when the doc are bad and there arent much any other alternative The moment they start to care about how things are done and make it easy with examples much of the hate will be gone, like for example you go into the "include_directories" and the page show the doc but also a warning, "This should be deprecated, look [X] instead" and you enter that new comand and you get a proper doc (not how it is today) and a few examples of how to use. Todays docs only works if you know how it works and for a refresh, if not the case, well, what happens is obvious, hate and angry will increase We deserve something better that we have today, and because they dont want to "force" to use new standards (Modern CMake if you want to put a name on it) but instead all is allowed so you will end with a mess, a working mess but that no one in his rigth mind will want to touch at all once is working
What's going on with IDE's is what's going on in all of IT. Everything is terrible and we would need to restart everything from scratch starting from hardware. Obvious not going to happen anytime soon.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Modules provide an explicit dependency graph between translation units, so if module foo depends on module bar, an implementation could initialize the global variables of bar before foo, I guess.
If I am understanding you correctly, you want each rank to have a picture as a 2d array of ints. As written, it looks like every process gets the entire image. Then, each image does some sort of gradient process on some specific range. It doesn't look like each rank actually needs the whole image -- maybe just the row above and below the region it is assigned. Then, you try to gather all the calculations to rank 0. Is this right? ----- Why are you using variable-length arrays for pic and picAux, but then not using them for pic3?
Yeah, dont need to bcast the entire picture to all ranks, but i'm just trying to make working the scatter job. I do cols\*rows/num\_procs scatter, not full buffer. And yeah, i want to.
Personally I'd much rather have a build system with character like CMake than some soulless lowest-common-denominator farce like that.
awesome set of posts ! &amp;#x200B;
Do you really have to use such a cringy title?
Thank you!
The title is aimed at a post which was posted 2 days ago [https://www.reddit.com/r/cpp/comments/b8qtcx/its\_2019\_we\_have\_the\_power\_of\_constexpr\_and/](https://www.reddit.com/r/cpp/comments/b8qtcx/its_2019_we_have_the_power_of_constexpr_and/) I just wanted to show that with some creativity you can at least achieve something close what was requested, so I wrote this library over the last two evenings. I mean if there is interest I could try to improve it. I would also love to hear suggestions of how I could work around the current limits or use better workarounds.
yeah this is pretty much exactly what I meant
What is the point of using this over magic\_enum?
[TIGR](https://bitbucket.org/rmitton/tigr/src/) is a small cross-platform library that exposes window as a pixel array, with support for text output and image blitting. Seems to be abandoned, but work OK, in my experience.
This is a great feature, I've come across two minor issues: - they are placed above the header guard/pragma in headers where there are no existing includes. - if there is an `#ifdef` block at the end of the include list it is placed within the main body of that block. This doesn't happen if there is one or more includes after the block. Thanks for all the excellent work btw!
They could've ride Mesons straight to dev-ops to destroy the build errors.
If you just need to convert to and from string, I think there is no real difference. I think my implementation is a bit more efficient/ elegant. E.g. I use an O(1) technique for to_string, but I don't think that matters much. I basically just added the enumeration on top and that was basically requested by the post mentioned above.
Author claims GCC doesn't fully support C++17, which is wrong. GCC 7 and beyond have full "experimental" support for C++17 language features, and GCC 8 even has partial C++2a (aka C++20) support (also experimental ofc), which GCC9 will expand upon.
All you really need to know about cmake is from that one time I filed a bug: * this functionality doesn't work correctly on Unix, here's a patch * "but the function you added won't work on Windows" * here's a link to the documentation proving that the necessary function does, in fact, exist on Windows and do the right thing * (still doesn't merge it) * (10 years later and it still doesn't work)
Any chance for C++11 or 14 compatibility?
For older compilers you can try Evo C++ library: [https://github.com/jlctools/evo](https://github.com/jlctools/evo) &amp;#x200B; See Enum Conversions in documentation: [http://jlctools.github.io/evo/evo-0.5/html/EnumConversion.html](http://jlctools.github.io/evo/evo-0.5/html/EnumConversion.html) &amp;#x200B; There's also Better Enums: [http://aantron.github.io/better-enums/](http://aantron.github.io/better-enums/)
If you manage your deps with Conan, you basically turn every dep into a micro sdk that cmake can use via pkgconfig files, which are really just pointers to where the deps are installed under Conan. Then you are free to use any damn build system you want: meson, buckaroo, b2, evoke, (whatever). We really have to start addressing the paper cuts to onboarding with modern c++ or we are just going to get outpaced by (insert language with opinionated build and packaging scheme here).
Just as a psa, I don't think dekkers algorithm would work in a gpu environment, there is one potential deadlock which is where both threads acquire their flag simultaneously every iteration (as is the case on a gpu due to the way threads work)
You have to give me a lot more to go on than that. 
I think what they are doing is interesting, and I sympathise to an extent with their desire to get paid. But, the AGPL doesn't get around the Apple app store problem and the AGPL is no different than the GPL from an app store perspective. Note the following line in the FSF discussion of the app store - "**this analysis would apply to all versions of the GNU GPL and AGPL" -** [**https://www.fsf.org/blogs/licensing/more-about-the-app-store-gpl-enforcement**](https://www.fsf.org/blogs/licensing/more-about-the-app-store-gpl-enforcement) Thus regrettably anyone interested in learning a cross-platform framework for mobile devices is best looking elsewhere given that this library, either in its current GPL form on GitHub or in the apparent future AGPL version mentioned on the podcast, can't be use for iOS apps.
any examples? any tests?
Updated with link to documentation: [http://jlctools.github.io/evo/evo-0.5/html/index.html](http://jlctools.github.io/evo/evo-0.5/html/index.html)
The documentation has lots of examples. I updated the post with a link. I have not open-sourced the unit tests yet as they're massive and a bit of a mess.
Nice work! Thank you for sharing. Looking forward to reading your posts tonight over a few cups of tea.
And [wise_enum](https://github.com/quicknir/wise_enum) and [meta_enum](https://github.com/therocode/meta_enum).
have an upvote saving the post so it not gets lost for me :) thanks for posting it!
It depends on compiler internals __PRETTY_FUNCTION__ (gcc, clang) and __FUNCSIG__ (msvc). 
Awesome work. I remember people were upset about your posts. This is a way better to highlight all the short topics from your website.
&gt; I hate cmake. I hate make. I hate all of the build systems because they're all universally terrible by virtue of being text Wait. What?! No. You're writing code. In text. The build system is code. The problem with any of this stuff is *not* that they're text based.
I do remember you. I really really really like your posts alot. Have you on my feed. Really appreciate all the work from you, and hope that you will continue doing so :)
Writing code is terrible though, its full of bugs and unreliable. Build systems don't need to have code as their primary language, although you do definitely need a scripting language for extras Its the same as git on the cli vs tortoisegit IMO. For 99.9% of use cases, tortoisegit completely outstrips git on the cli in terms of usability and making errors. For me there is absolutely no argument as to which is better, except for the very occasional time where you need to A: script git, or B: do something which tortoisegit has missed
&gt; Writing code is terrible though I think you may have picked the wrong job...
They are probably preparing the infrastructure for the holy Grail of large projects, Find All References
I'm being realistic - all code is a surface for bugs to be born on. The less code I write, the better. If I could do my work without writing a single line of code, I would (although it might be less fun) Don't get me wrong, I *like* programming. But my main mission currently is to figure out ways to produce software with as few defects in as possible, which is why rust is so interesting to me. If that means ditching some of the programming involved or systematic changes in my tooling which involve less easy mistakes, then I'm all for it So far cmake seems like it will introduce many bugs compared to codeblocks's build system with little gain, other than being a widely used system which is not a requirement in my very particular corner of the universe I don't think that the goal of cmake is incompatible with ease of use (except for necessary complexities) and being bug limiting though, it just seems that cmake follows a slightly older mentality of how software should be interacted with, that's relatively widely subscribed to
It's my first time seeing your blogs, so I checked enum to string part one and two because I had to switch enums to strings a lot in my project (I have atleast 5 to 7 enum to string methods). And you taught me a much better way of doing those, I can't wait to read your other posts!
Tried both CMake and Autotools, prefer the latter. I have a simple template for when ever I want to start a new project that compiles and install binaries in the correct place on a Posix system using the FHS, which is this: **bootstrap:** #! /bin/sh autoreconf --verbose --install --force **configure.ac:** AC_INIT([hello], [1.0]) AM_INIT_AUTOMAKE([-Wall -Werror foreign subdir-objects]) AC_PROG_CXX AC_CONFIG_FILES([Makefile]) AC_OUTPUT **Makefile.am****:** bin_PROGRAMS = hello hello_SOURCES = src/main.cpp **src/main.cpp:** #include &lt;iostream&gt; int main () { std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl; return 0; } To compile and install, run these commands in a bash shell: mkdir build cd build (cd ..; ./bootstrap) ../configure # `--prefix=/usr/local` is default. make -B sudo make install-strip # `install-strip` reduces binary size. To uninstall, just do `sudo make uninstall`. I don't get what is so hard about Autotools. in fact, I find it easier than CMake.
This was actually the winner of the little ["interesting"-but-valid C++ code contest](https://zygoloid.github.io/cppcontest2018.html) around the last CppCon.
&gt;using cmake-gui Oh really? I've found that cmake-gui is kind of buggy, but I haven't used it recently much at all - a lot of the prevailing opinion i saw like 5 years ago was "if you use the gui you're a moron" etc &gt;I'm very sad that git is more popular than mercurial because TortoiseHG is the best goddamn UI I've ever used for a VCS. +1 for this, tortoisehg is awesome. Mercurial in a lot of respects was just "git but well its a bit better designed". I stuck with mercurial for years until I was forced to switch due to performance problems, unfortunately - the reality is that git is much better supported That said tortoisegit is pretty great too and I don't find myself missing mercurial that much anymore
Yeah you're right, what I object to is that A: programmability is the default rather than the worst case (declarative/imperative), B: editing text files by hand is the default (ide integration is poor) &gt;I kind of like build2's idea of being mostly declarative, but with the possibility to do some more advanced stuff. It feels like it could work fairly well to integrate with an IDE. But it also feels like there are so many files for a build2 project that are all over the place that it becomes harder to reason about, which is probably my biggest gripe with it. I'll have to have a go on build2. I've done a lot of ui programming recently so maybe I'll get sufficiently frustrated that I replicate codeblocks's project management system so I can ditch it
I mean, I think cmake is far from ideal, and agree that its problems are evident of an older mentality (along with everything kitware makes). I just don't think the problems have *anything* to do with that it's code/text based. In the end it's all code even if someone puts a UI on it. A UI doesn't prevent bugs, it just makes discoverability easier and automation harder. I'll use both GUIs and CLIs but force me to choose and take a CLI over a GUI in a heartbeat. It I can't automate it, it's broken.
a lot of the prevailing opinion i saw like 5 years ago was "if you use the gui you're a moron" etc Buncha tryhards At work I'm stuck with tfs so lol
This has been solved ages ago with the singleton pattern. Better yet, don't use globals
&gt;a lot of the prevailing opinion i saw like 5 years ago was "if you use the gui you're a moron" etc &gt;Buncha tryhards This will probably turn into a dissertation but I always thought this was really interesting There's 3 things that never added up to me while I was learning to program and use technology in a more advanced way 1. Why do many people use only the cli and dismiss gui tools out of hand? 2. Why is linux so incredibly un-user friendly? 3. Why is the tooling around coding so bad? (Ide's, compilers, build systems, code exploration, refactoring, project standards, deploying stuff, automation etc) ~~4. How did Dark Alex manage to produce such an advanced piece of custom firmware so quickly compared to literally the entire rest of the community and where did the header files and function names for the suspiciously user friendly cross compiling toolchain come from so quickly for the psp within like a week of its release~~ It was only much later that I really sussed out that this is really a cultural 'problem' with programmers. I think its because programming didn't really originate as a job or a profession, a bunch of people just got into it because it was interesting. I suspect that's how most people here got into it which is rare as most professions go - EG I suspect almost nobody ever sat down and went "Hoo boy I love spreadsheets better learn me some excel macros so I can grow up and work in accounting" Its something that people did because they enjoy doing it, so the purpose isn't *necessarily* to produce software or not, its the enjoyment of doing the thing itself. Over time it developed into its own subculture with strong anticapitalist overtones, a strong sense of 'fuck the man', headed by notorious toe eater richard stallman (who is increasingly right about everything), and notorious abrasive linus (who turned out to be right about lots of things) So from that angle I totally get it. Its a bunch of stuff produced by random disjointed individuals in a subculture that inherently dismisses authority. Everything's just sort of amalgamated together from people's hobbies, there's no plan - people are just doing stuff that they want to do. Trying to tell people that there's a better way to do stuff is kind of a 'fuck you' to them, because its like telling a craftsman that his house is built with shitey methods I do think the industry is starting to mature though in very positive ways, rust is a huge sign that this is getting better overall - if you'd tried to built rust 10 years ago nobody would have used it, because we were still firmly entrenched in the mindset of "C is the best thing ever" In terms of a culture of creating good software I still personally think that programming is in its extreme infancy. There's so many things that can go wrong that simply don't need to go wrong, but nobody has taken the time to solve them On the other hand I like writing documentation for stuff so maybe I'm just weird ~~and also he was probably the relative of an unfirable important firmware engineer~~ &gt;At work I'm stuck with tfs so lol I'm so sorry for your loss
Your comment has been automatically removed because it appears to contain disrespectful profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/b9qu1g/i_understand_cmake_now/ek89p1c/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Regarding the &lt;random&gt; library, I would state it's not [all] very good. The Mersenne-twister is not a very good generator [when tested with modern tools like practrand] (while having a huge footprint, you don't want too many of those hanging around, the large state also has implications for [the effect of bad] seeding)) and the implementation [at least in VS] of f.e. `std::uniform_int_distribution` (the most used distribution I would guess) is way behind the curve and a much faster implementation is possible. Then `std::seed_seq`has issues as well and does actually not do what it promises.
Same thing with version control systems (esp. Git) for that matter. Many skilled C++ devs just see the VCS as an evil obstacle and refuse to learn it.
Since you don't like to waste time compiling, you invest in your build system (hand in hand with sw architecture) to make the build snappy.
The main difference between static-enums and the options listed above is that they all require you to define the enum via macro (either the initial declaration or you have to list all the options). That's why it's probably a valid choice for 3rd party enums which you have no control over. As far as I'm aware none of the other libraries can do that (automatically). 
I don't disagree mind you, just stating why people find build systems frustrating.
Yeah I totally agree, it's just that build systems are the one hurdle that C/C++ has that no other language really has to deal with. Every other language has generally 1 package manager and 1 build system (if necessary). It's a big hurdle to get people to jump into C/C++.
Yes that also the reason why older versions of gcc are not supported. Only with version 9 pretty function was marked constexpr.
For me it's not about how hard or easy it is to use. Whatever system you know/prefer, you'll end up using some sort of template that enables you to quickly get started with a new project (the trick is to scale it with larger projects), so most tools are equally "difficult" in that way. No, my problem is with performance and portability. Most autotools projects that I have encountered have prohibitively slow build times, and to make things worse they tend to have problems with their dependency graphs (could be bad luck - maybe not entirely autotools' fault?) so you can't trust `make -j20` to work. If a build system does not use ninja (or something with comparable performance) under the hood, it's pretty much disqualified in my book. Also, autotools is problematic if you want to support Windows and MSVC (I'm a sucker for portable code, so I want my build system to support Linux+macOS+Windows+BSD out of the box). 
Well, still, just from my limited experience there is a high correlation between the people getting frustrated by build systems and the people not wanting to learn them. It's a lot less frustrating if you learn how they work (just like with c++)
Yes it's just like with C++, stick to the modern parts and best practices it's simple And yeah for both of these, c++ and cmake, I wish there were optional flags that disabled all the legacy crap
Fully agree. My favorite non cryptographic rng is sfc64 from PractRand. It is extremely fast and has only 32 bytes footprint. I have an implementation here: https://gist.github.com/martinus/c43d99ad0008e11fcdbf06982e25f464
Yes, for a 32-bit PRNG, it's among the best.
I would have to think about that. I think I would only have to replace the fold expressions. That being said you need the latest gcc or a quite recent MSVC anyways. What would be your use case?
The problem is also that it is hard to know what are the new parts and which are replacing, it should be in the docs but it is not making even harder to try to do your best And of course in CMake docs there is no such things as best practices, well, maybe the tiny tutorial may count as it is intended of how to use but not for me Thats the real problem, in C++ i can see that in the 11 version they introduced auto and it is recomended for every type you has to guest to avoid castings or the new pointers like unique_ptr that replaces the old ones, if you take care you can know all of that in the docs, something that is not posible with CMake docs, even Google`s proyects uses CMake the wrong way so imagine what mess has to be to even create Ninja to replace CMake
sfc64 is 64bit
But you say it has a 32-bit footprint, those 2 things don't go together [I think].
Average period is 2^255, min &gt;= 2^64. That's quite good
I am looking [and had that in mind] [this implementation](https://gist.github.com/imneme/f1f7821f07cf76504a97f6537c818083). // - 256 state bits, uint64_t output // - 128 state bits, uint32_t output Unless I'm misunderstanding, you're saying the opposite, 64-bit output from a 32-bit state. 
Got it now, I somehow failed to see the above, we have a different definition of what 64-bit signifies. I was talking about the size of the state, which is 256-bits, your are talking about the [4 64-bit] variables that make up the state [of 256 bits].
&gt; in C++ i can see that in the 11 version they introduced auto and it is recomended for every type you has to guest to avoid castings or the new pointers like unique_ptr that replaces the old ones Not sure that is a good example, using `auto` _everyone_ certainly isn't established best practice. It's one way of doing for sure, but lots of people really really hate this way of writing code as it makes it harder to read.
There's a reason I laughed so hard at [this xkcd](https://xkcd.com/1987/)
Did you have a look at this [lehmer PRNG](https://gist.github.com/imneme/aeae7628565f15fb3fef54be8533e39c).
I did, but it requires 128 bit types which are not available everywhere. Also it's not as well tested
Thats why on the docs (and i in the post) says that in the cases you dont have a 100% certanty of what type it is is the way to go, like if it is reallity an iterator and has to be casted to X looping on a foreach, a waste of time and CPU ticks. The case is that it is in the docs so if you read it you get the intended use and proper info about it, the CMake version would be "New type variable auto, it can hold any other types inside" and thats all you can get from they
Well Clang supports it, so that means all major 64-bit platforms. With VC you can use the `_umul128` intrinsic.
Thanks for your feedback! Just to clarify, we have been talking about the GNU LGPL (Lesser General Public License), *not* about the AGPL (Affero General Public License). Our current understanding is that the LGPL is in fact compatible with the iOS App Store terms of service. As described in the interview, the main line of reasoning here is that with the LGPL you are free to license your app under a different license, be it open source or not, which can then be compatible with the iOS App Store's terms. We strongly believe that providing a dual licensing option (LGPL + commercial) will allow us to deliver value to users of the framework beyond what would be possible with other licensing models. From our perspective, this should be a viable compromise allowing us to solve existing pain points with native app development effectively and sustainably while still remaining completely open source.
Sure, python doesn't have to deal with a plethora of problems which are inherit to C / C++ builds. But the fact of the matter is that probably 10% - 20% of the content on this very sub is articles trying to teach "modern CMake", meanwhile learning how to prepare your python package for pypi is like an hour tops of reading some documentation. A library dependency in a project should be 1 line which specifies a version range, whether it's private dependency ( completely encapsulated ) or public ( it's in your public API ), and that should be it for the common case. There should be no such thing as vcpkg, it should already be that easy by default. We shouldn't have to use a build generator, with a plugin, to generate a half decent project file for another tool ( MSVC in this case ), which then is able to compile your code.
why do i need a second string class? does this extra complexity not in fact burden me?
I really like the topics you have but the style with all the smileys :/
I use it mostly with unreal engine and VS 2019 is far faster than I was used to. I would much rather use Sublime Text, as that's my go-to, but with such a large codebase I can't live without the auto completion and refactoring ReSharper gives me. The ccls language server is almost there but it seems that clang can't handle a lot of the forward declarations within the engine so it tells me there are errors everywhere. Can't wait for the day when I'm free from using visual studio, but it seems like by that point visual studio will probably be as good as every other text editor considering how much better it's gotten with every release.
Interesting 
Ah sorry thought you meant auto everywhere. Yep for things like iterators it's indeed best practice
It might be people who went through the change from autotools to CMake. CMake is without a shadow of a doubt a better build system, but switching is still a disruptive process. 
How much *high performance*? Any benchmarks? When I look at your code I see lots of standard C functions called all over the place (memcpy, malloc, realloc, free ...) and vanilla c++ as would be used by first-grade CS. What exactly are high-performance optimizations you are talking about? Robustness? Why? What does it do better than STL, Boost &amp; Co? For example your String looks just like poorman's implementation of std::string, I see nothing special in there that std::string does not already do, so why would I use it? &amp;#x200B; Looks to me just like another Java-inspired API design which typically is popular among new examined CS student comming out from their university Java-world. &amp;#x200B; Sorry if I am too harsh about it, I am just wondering what place does it fit. Kudos for offering async I/O if you have implemented it portable in at least linux/win/mac oses.
Also because prior to then gcc used the numeric values of the enum in pretty function, if I'm not mistaken? 
And "the enumeration values have to be in the range of \[-127, 128\] for signed types and \[0, 255\] for unsigned types.". &amp;#x200B; That's a pretty big limitation.
In this benchmark Sfc64 is actually faster than the lehmer's PRNGs: http://quick-bench.com/SDmC8-PbpLBS4r2pobHnBnh1BAA
Good work, interesting stuff. Is there a way to know what machine we are dealing with?
I'm stuck with older compilers so it wouldn't help anyway.
here's the cmake equivalent : cmake_minimum_required(VERSION 3.14) project(hello VERSION 1.0) add_executable(hello hello.cpp) install(TARGETS hello RUNTIME DESTINATION bin) To compile and install, run these commands in a bash shell: mkdir build cd build cmake .. cmake --build . --target install/strip pardon me but I find CMake much saner and much easier
&gt; meanwhile learning how to prepare your python package for pypi is like an hour tops of reading some documentation. as someone who tried to make python packages backed by a C library, I really disagree
&gt; Trying to get QT to work with cmake required an understanding of cmake syntax which seems baffling. huh. using CMake in QtCreator is a matter of opening a CMakeLists.txt with the IDE &gt; Its hard to make release/debug/profile configurations it makes release / debug config by default and you can add further configurations in a graphical editor 
&gt; Note the following line in the FSF discussion of the app store - this discussion is outdated. back in time you needed to pay Apple 99$ to have the right to push code on your device, but nowadays it's entirely free.
I sighed so much when I read your post. Not that there is nothing wrong with CMake, but honestly just stop with the empty Python argument. Python's build and environment situation is vastly different from C++ or C for that matter. It has to actually deal with the machine it runs on not some scripting environment. Its code is not running against a standardized virtual machine but against a great variety of operating systems, CPUs and types of build targets that Python never needs to deal with. If you had referenced crates in rust or something similar your arguments would have made some sense but as it is nothing about building in Python has much relevance to the oddity of the C++ world standardizing around CMake. 
Wait until you discover ranges !
Meson with subprojects is [pretty much exactly that](https://mesonbuild.com/Subprojects.html) with the added bonus that you can use system-provided dependencies transparently if they exist.
Correct, in the current specification, but a few of us would like to provide some guarantees based on imports and module ownership.
That is essential what we are aiming for. The devil is in the details.
I see it saves some typing, but does it also improve the generated binary code [a real question]?
I believe what it means is that the API isn't macro-based. That's pretty common for defining enums, but I'm unsure of what that would look like for accessing enum information where you couldn't trivially convert it to a non-macro-based API. Macros for config are still quite common.
Not sure if that was meant sarcastic? The macro usage referred to the typical macros that you have in to use for similar libraries like wise-enum. I could have also used a static constexpr int, I just thought that I should give the consumer of the library a bit more flexibility to play around with some values.
With 3.14 you can drop the install destination as it now has a default of “bin”
I don't know that the FSF would agree. What I can find about the "free" ability to sideload apps onto an iDevice is that they only last 7 days, and then you need to repeat. I suspect the 7 day limitation would still be viewed as a further restriction that is prohibited by the GPL, though like anything to do with legal agreements a lawyer would really be needed.
I should have made myself clearer - apart from the problems above, which in the end are small, I think your library may be the best one so far for improving C++ handling of enums.
I remember reading some parts about this in one of the modules paper. If I remember correctly it was about giving guarantees that static objects bound to a module are always initialized before anything importing them. Is this what you are referring to? Is there a reason this was not part of the currently accepted proposal(s)?
The idea was around before that - the winner learned the technique from others. Credit is due, I believe, to Ernesto Raser, building on Manu Sánchez' CTTI library. 
I thought on the podcast you said AGPL, though it is certainly possible that I misheard. The LGPL would appear to solve the problems with the Apple app store.
 #define STATIC_ENUM_FUNCSIG // Unsupported compiler. #endif You could use `#error`. It might not be standard, but even if the compiler doesn't recognize it, well... it should generate generate an error anyway :p
To be fair, I'm credited in CTTI as I showed Manu the trick. But yes, I didn't came up with it.
We're also skeptical as to whether this would resolve the issue. We will be having meetings with our legal team in the next couple of weeks to verify our current view on the legal implications of both the GPL and LGPL. We will add this question to our list and let you guys know about the outcome. If you are interested, follow us on Twitter (@bodenhq) to stay in the loop.
(Nice win btw - didn't mean to discredit - just props to Ernesto, though maybe he rediscovered it.)
[Cppreference](https://en.cppreference.com/w/cpp/preprocessor/error) would suggest it's standard, with well defined behaviour
just took my .vcxproj project with 20 files and logically split them into 4 projects and added dependencies. as a result, compile time increased by \~5 times. :( How is it possible?
This is awesome, thanks for sharing!
👌
If you can, use the [wise_enum](https://github.com/quicknir/wise_enum) library.
Thanks for the great posts. Especially liked the hashing, TOTP, and gRPC examples!
Thank you!
`#error` is standard, `#warning` is not.
On rust vs C, no, the main reason is that there is already a huge body of work already written in C. A big part of programing is being able to use existing code than having to roll your own every single time.
Why did you rewrite everything that already exists in other libraries, including the standard C++ library? Is yours somehow better? If so, in what ways is it better and where are the supporting metrics? Which commercial or open source products are using this? If not, then why should anyone use it, and why should you bother maintaining it?
I really like that the blogs are short and to the point! Good job!
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/ba6itb/need_help_creating_an_template_abstract_factory/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
**Company**: [**Summitto**](https://summitto.com/) **Type**: Full time **Description**: Summitto is an award-winning startup building the largest invoice registration network of the world. The purpose? Helping EU tax authorities to **eliminate 50 billion EUR in annual invoicing fraud**. If you’re excited to build and design **open-source** software which will be used by **millions of companies**, we are looking for you! We're hiring junior ánd senior developers at the moment. Experience with cryptography is a plus, but not required! **Here’s a little taste of your challenge, you will help build:** * a distributed systems consensus algorithm * blockchain data structures * fraud identification algorithms * secure interfaces and integrations **Location**: Amsterdam **Remote**: No **Visa Sponsorship**: yes **Technologies**: C++17, python. **Contact**: [**careers@summitto.com**](mailto:careers@summitto.com) questions are always welcome!
Never knew about those. Thanks for the tip! The are quite new though came in version 3.13 if I read the documentation correctly. My script that was using the above style solution was done back in 2011. So this will simplify stuff in the future. Also according to the docs these settings only works with Visual Studio generators. Hence it cannot be used yet since VS2019 do not support Visual Studio Generators (yet). But once again, thank you for the tip. Always great when you can get old cruft out of your CMake scripts.
Sure, in 2011, anything goes. Now, developers are quite receptive to bugs and missing features like that one. So if you have more things you need, please ask about it!
I just looked the first one 'better bloom filter' and it doesn't look like it works. What it does is Finds hash once and runs a pseudo random number generator for other hashes. The point of bloom filter is you use multiple hash functions so that the chances of collision is decreased. In your implementation, they will be the same hashes. E.g. Lets say two strings foo, bar generates same hash function, &amp;#x200B; Bloom filter |string|hash1|hash2|hash3| |:-|:-|:-|:-| |foo|42|34|88| |bar|42|53|23| &amp;#x200B; Your implementation: [https://vorbrodt.blog/2019/04/05/better-bloom-filter/](https://vorbrodt.blog/2019/04/05/better-bloom-filter/) string: foo hash1(foo) =&gt; 42 PRNG(42) -&gt; 23, 45, 53 string: bar hash1(bar) =&gt; 42 PRNG(42) -&gt; 23, 45, 53
Fair point, but... the point of 1 hash seeding RNG is to set multiple bits in the array per one input. It is more likely that 2 different hashes will cause collisions in bits, than 2 inputs causing 1 hash collision. so this approach prevents the first scenario. I agree, for best implementation I would need to use multiple hashing functions... but where do I find those in standard C++? :(
So you don't know who came up first with the trick either?
Counting the days until we could get rid of compiler specific tricks or external parsers to do something as ubiquitous as converting strings to enums and vice versa. Meanwhile: constexpr auto a = tinyrefl::enum_cast&lt;Enum&gt;("A");
Here's the documentation: http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html
* solve all problems™
For those of you crazy enough to use this trick, beware of MSVC adding struct/class prefixes to the string for class types. Oh, also some versions of gcc do not print the enum value name in the pretty function string but use a C casting syntax: enum class Enum{ A, // prints (Enum)0 B, // prints (Enum)1 // And so on }
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Thanks! this helped a lot
Those are compiler flags and instructs to the compiler to produce more optimize machine code. At -o0 there are no optimize flag on. At each level (o1,o2,o3) more flags are set. You can read the documentation for your compiler to find what what each level turns on and what each flag does. Either way you probably don't want to do this. The assignment is probably to improve the actual code. 
Great posts!
`template &lt;typename E, E V&gt;` With C++17 you can just use `template &lt;auto V&gt;`, don't you? Anyway, nicely done! Thanks for sharing it.
Thanks, these are good questions. I'll work on adding an FAQ. Meanwhile here are some short answers: * [Sharing](http://jlctools.github.io/evo/evo-0.5/html/Sharing.html) (Copy-On-Write) and [Slicing](http://jlctools.github.io/evo/evo-0.5/html/Slicing.html). C++11 standard [doesn't allow COW](https://stackoverflow.com/questions/12199710/legality-of-cow-stdstring-implementation-in-c11), and the standard favors things like iterator safety and backwards compatibility over performance. It's not that hard to beat STL on performance (especially on debug builds). * evo::String does a lot more than std::string, especially on [splitting and tokenizing](http://jlctools.github.io/evo/evo-0.5/html/StringParsing.html) without allocating/copying memory and without needing error-prone "index math". * C functions like memcpy(), etc are optimized by compilers like GCC using assembly. For other things like a tokenizer skipping whitespace I use SSE optimizations. I have a long list of TODOs, which includes publishing some good benchmarks -- I do welcome contributions! &amp;#x200B; If you're already using C++17, Boost, and various other libraries and take full advantage of std::string\_view and are happy with that then you probably don't need Evo.
Maybe you don't need it. Evo has STL compatibility so they can be used together if you like. As mentioned in another post, Evo strings do offer a lot more functionality than STL strings.
&gt; Is this what you are referring to? Yes. _Module ownership_ is the technical term for "bound to a module". &gt; Is there a reason this was not part of the currently accepted proposal(s)? Well, when we did the Modules TS, we didn't want to require any more new linker technology than what we already have. Eventually, I convinced myself that the C++ toolsets ecosystem is now ready to provide this guarantee at no cost -- remember *zero abstraction overhead* is the C++'s North Star. 
The fact that there language doesn't support enum to string natively is one of the greatest embarrassments of the 21 century
It seems the only way to write a cross platform dynamic library is to make the interface pure C, hence why the first line of code in the link is 'extern C'. I always think it's a bit crap that C++ isn't dll compatible across compilers and that it doesn't even have a keyword to mark a function as exported. I feel like what happend was this... * C++ wanted constructors for objects * A constructor is an anonomous method, so how do we define many constructors? as they would all have the same name * We need overloading to support having many constructors * We might as well support overloading on all methods while we are at it * compiler implementors then have to introduce "name mangling" to solve the overloaded method linking problem * And now we can't make dynamic libraries work in C++ as the name mangling is different across compilers So C++ never adressed this problem (and no standard "export" keyword) and that's why it's such a mess. &amp;#x200B;
See my other comment here on performance and functionality. We use Evo where I work at [The Rubicon Project](https://rubiconproject.com/) on our proprietary ad server, which gets billions of HTTP requests per day. Outside my small circle I'm not aware of anyone else using it -- this is my first public announcement of it here.
Wow that's a lot of stuff. I'm just starting this stuff
Recently got into freelancing again. I have a long term contract that is going to take most of my time hopefully, but I'm always in the market for something small on the side maybe. I have approximately 15 years of experience developing with C++ on a number of platforms in a number of disparate domains--I understand the language at a fairly advanced level. I also have a lot of experience with the Linux system in addition to development on Windows. Remote only or local to the Las Vegas area. Not currently interested in gaming related projects (talking about slots, not video games) or "full time," "permanent" positions. In addition to development tasks, I can also train your developers in things like C++, design, automation, unit testing, etc...
well I do now. :D
A somewhat older implementation, but it still does the job: https://github.com/ArashPartow/bloom
&gt; and backwards compatibility over performance Funny thing that changing std::string from COW to it's current form (or rather forbidding COW) was one of a few back-compat breaks in C++11.
17.642 quadrillion.
Good job! Very interesting!
C++23
I've been using Qt for about 6 months and so far pretty happy with it. Just curious, what do you mean by Qt uses "ancient paradigms" and is "slow"? 
You might want to also consider Emscripten (compiling to WebAssembly) and then using a JavaScript library. It's a slight slowdown -- but only slight! -- and then allows your game to run anywhere there's a web browser. https://emscripten.org/ 
How do you get bindings to, say, react if you wanted to write C++?
I'm not a huge Qt fan myself, but it's not slow by any means.
This seems like a completely bass-ackwards way of getting a UI into your game engine, IMHO
I quite like [turbobadger](https://github.com/fruxo/turbobadger). The only problem I find is it doesn't have much documentation, so you'll have to look at the examples, mostly.
Uses inheritance instead of composition. Slow compared to GPU rendered UIs, especially if you need custom widgets (for example bezier curve editors). You probably will never hit that point in non-intensive applications however.
thx!
How about [GuiLite](https://github.com/idea4good/GuiLite)
What the...? No ImGui? @ /u/pgroarke &amp;#x200B; ImGui (for prototypes and debug UIs) and Qt (for full-fledged GU applications) are pretty much the only GUI libraries that matter in C++, IMHO.
It looks very decent. I listed it in the dead category since it hasn't been updated in years though.
What's wrong with inheritance? Qt has built in opengl handling, you seem to be implying that it doesn't support GPU rendering at all?
Of course IMGUI! It is listed as Dear ImGui, its real name ;) Right there at the top.
ty! Adding it :)
Ohh, my bad! I completely missed it.
Well the qt scenegraph is opengl based. Im not sure why are you making these claims
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Reading the docs, it seems only QML uses their GPU scene graph. &amp;#x200B; &gt;**QPainter** The Qpainter engine uses software to paint, and is used when drawing Qimages or Qwidgets. Its advantage over OpenGL is the high quality when antialiasing is enabled, and a complete feature set. &gt; &gt;The Qpainter can use an OpenGL engine, but as the document mentions it is more suceptible to state changes. And has to be used carefully. &amp;#x200B; AKA their OpenGL implementation isn't up to par ;) Now, I don't keep up with Qt news. Last time I tried using their painter, perf degraded after 3 bezier curves with circles and squares. Maybe things are different now.
I really like the idea and the amount of research you've put into this, but some of the cons (and a few pros) can seem really...superficial, like: - Sciter actually uses a JS derivative language as part of the UI; it's not entirely C++. - GTK's website screenshots are super old, and GIMP actually uses an older version (it doesn't even really stand for GIMP ToolKit anymore). It supports CSS for theming the UI and can be made to look really gorgeous (IMO the new version of the Adwaita theme looks pretty nice OOTB too.) IME it's not that hard to build for as well, and you'll primarily be using prebuilt binaries (e.g. from your distro or MSYS2). Also, Glade can be used on plain GTK, not just gtkmm. - Again gtkmm would be primarily prebuilt or automatically built versions, so the autotools shouldn't have much of an impact. - CEGUI...actually I have nothing to say here, building that crud is nightmare fuel. - nuklear is actually a bit odd to use IME; it's by no means terrible but definitely requires quite a bit of glue, especially if you want to use system fonts. God forbid you want to use system fonts... - If you're including NanoVG as a gui library you might as well include Skia and Cairo... - "doesn’t use cmake" isn't necessarily a con. Also again, you're rarely going to be building morda from source... - Seems a bit unfair to put "not battle tested" under Nana when there are sever others here that don't seem to be used much more. - "requires SFML", not really that big of a dependency... I will admit I laughed at "might be interesting if you are targeting a hipster retro userbase", just too accurate. A few more things to note: - Few of these likely support Wayland, sadly. - Not all of these have OOTB system font support. 
Qml qt quick is more or less the preferred way of writing a qt gui nowadays. Anyway I dont usually do bezier guis :D Ps have a look at this project... https://github.com/uwerat/qskinny
If I understood the website correctly, it's not even C++ at the end but straight JavaScript. So there's no binding...
Sharing strings is actually a bad idea in practice. It does not save much space, and make it bound to atomics, which costs a lot from a global point of view. memcpy already uses sse4 when it is applicable normally. Without benchmarks, this is kinda "useless". Additionally, gcc may remove calls to memcpy/memset and co when it deems see fit, which should make performances far better than a custom implementation in practice.
Additionally, SubString is merely std::string_view, so I [personally] don't see the point 
QT has some C stuff in it, instead of using C++ paradigms. One thing I can think of is that it still uses some macros, which are annoying and confusing for someone who focuses on C++ and not C. The Q_OBJECT macro was so confusing to me I still don't understand what it does, how it works, or how to use it properly. I recently switched to gtkmm and find it much more usable as an intermediate C++ programmer, even though it doesn't have the most thorough documentation. gtkmm is written in "pure C++" and doesn't require any macros, and it uses things like move constructors, so you don't need to use C pointers. I'm not an expert in QT, but it seems to require a lot of non C++. In gtkmm if I want to derive a class from the base classes, I just do it as one would expect and it just works, no idiocyncracies to wrestle with.
Not the only ones, JUCE is great!
I've been using gtkmm for a little while now and I really like it. Before that I used Qt, but it was really way too confusing for me. I've done Android and Swing UI programming in Java, so I have some experience with GUI libraries, but Qt seemed to be an amalgamation of C and C++ which I did not like using. Its use of macros for instance confused me to no end. gtkmm actually uses C++ and not C, which makes it much smoother to work with and maintain good C++ practices. Only problem with gtkmm is poor documentation. It's not terrible, but things aren't explained as well as I'd hope, and the official API website seems like an outdated style. I'd still suggest it over Qt though, and it's 100% FOSS. If gtkmm had better API documentation it would be perfect imo.
This list would be more useful if it specified supported operating systems, whether or not they support direct GPU rendering and supported GPU APIs
&gt; SSO (Small String Optimization) provides far better optimizations Yes for small strings, while for larger strings, the cost of atomics is much smaller than the cost of heap allocations. Hence, it depends on the use case.
inheritance is the base class of evil https://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil 
In terms of *raw* performance no inheritance should be faster than inheritance due to the fact that inheritance introduces the usage of pointers under the hood to call inherited methods. If you're doing something over and over again, this can result in poor cache usage. Realistically, though, you'll probably never see it actually affect performance unless you're working in gamedev (because you've got to work within fractions of a second constantly).
That's only true if everything is virtual, which doesn't necessarily have to be the case.
JUCE is incorrectly listed as closed source.
While I love all the new stuff modern C++ has been adopting, especially with regards to RAII and the additional data structures being introduced via the standard library, I am not sure you can teach some of these higher level abstractions or explain to them why they're necessary if you don't start from the basics. I mean, let's consider teaching destructors and why they're needed...can you really teach that without dealing with raw pointers? What about copy constructors? Move constructors? Even things like `unique_ptr` and `shared_ptr` would be tough to explain without making it look like an arbitrary language-design quirk. Just choosing between the two requires knowledge of how the pointers do reference counting, at which point you'd be trying to teach people what reference counting is before they've even grasped raw memory allocations and deallocations with `new` and `delete`. I think any new C++ class should teach both the basics (C with standard out as you call it) and then teach the modern C++ abstractions shortly after or during. This way students will understand why these abstractions exist, why they're safer, etc.
Inheritance does not imply virtual member functions. Therefore the rest of your comment doesn't apply to all situations (or even most?) involving inheritance.
Catchy title. Can I have a tl;dr?
It seems you have listed every non-dead, bright-colored GUI as "not pretty". If that didn't happen by accident, I invite you to do an image search for the phrases "cool GUI" (mostly dark) and "useable GUI" (all bright). &amp;#x200B;
The macros used in the Qt project are not "C". Macros are a full fledged citizen of the C++ language. Qt, as a library is written in pure C++, aside from possibly some platform specific bits that I've never encountered while trudging through the code of it. Gtkmm is a C++ wrapper on top of a C library...
This meme has nothing to do with cmake, meson suffers from the same thing
Can you please explain why we should throw a useful tool like inheritance from the toolbox? Just because some dude who was probably scarred for life by a near-Java experience has made a video in which he gives his personal (and in my opinion rather flawed) opinion on the matter doesn't make it God's truth. He lists such brilliant gems like "object lifetime management leads to garbage collection or reference counting" Isn't unique\_ptr isn't a thing anymore? Since when is managing lifetimes even an issue in C++? And then he brings "synchronisation issues" into it - is he attempting to tell us that objects that don't use inheritance are somehow thread-safe? Basically he seems to believe the sky is falling because inheritance \*\*\*MIGHT\*\*\* lead some people to use shared\_ptr. Why should we take that sort of BS into account for our own programming decisions? &amp;#x200B;
Nice list. Would be more enjoyable without the “af”, and “cancer”.
[OWLNext](https://sourceforge.net/projects/owlnext) is missed.
&gt; amount of research "ugly as fuck" and "smells like build hell" doesn't seem like research.
CopperSpice is literally a fork of Qt 4.8, but with less features (I remember qmoc wasn't still possible)
Agreed on benchmarks. Are there any specific cases you'd like to see? &amp;#x200B; If you're doing a lot of splitting and tokenizing then COW can out-perform SSO. With SSO each sub-string is at least a memcpy(). SSO has trade-offs with memory size as well. This makes a difference when you start building a large list or map of strings. Especially with large strings. Memory size is often a big concern with servers and game engines. I have considered making a StringSSO variant with COW &amp; SSO, but now I'm convinced adding allocator pools for existing String is a better idea (on my TODO list).
Easiest way is to use evo::String and you get automatic optimization with COW. Evo strings also have a lot more features (split/tokenize/convert/strip/etc).
Licensing would be interesting too for us embedded folk. 
libui seems to be missing, although I'm not sure how active the author still is, the previous update was in september I believe
http://wtl.sourceforge.net/
You can't do composition without inheritance in c++, so it's more efficient to inherit once instead of once for every behaviour you want to compose since you will have only one vtable instead of N. Also, Qt can totally be made to use OpenGL - see Qt Quick Scene Graph and Qt3D
Q_OBJECT is here for reflection which C++ doesn't have. 
I'm not sure you lnow what C is. There's zero C in Qt. If you associate macros to C, then I suppose boost is one of the biggest C codebases out there.
Banning inheritance has been a recent trend in OOP as a whole. That's why languages like Rust have implemented different strategies for dynamic polymorphism. I too believe that subtyping polymorphism is an epic failure and should be avoided.
You can. That's a totally mislead statement.
The whole point of copperspice was to ditch qmoc.
Nana is a great library but is kindda underappreciated. I think it's the best open source free license library right now. It does lack easy tutorials and in-depth documentation though. 
QtWidgets *is* slow. Unfortunately. The content of entire window is rendered in software (entire backing store framebuffer is in RAM) and then pushed to video memory. On Windows, this is fine, however on OS X pushing pixels from system memory to video memory is quite slow. Just try scrolling in Qt Creator on a 4K screen, you get nowhere near 60fps. It feels rather sluggish. There was an improvement about a year ago where unnecessary color conversion was removed when blitting those pixels, but it's still quite slow. Qt Quick Scene graph on the other hand is fully accelerated, but it functionality wise Qt Quick really lags behind Qt widgets for developing desktop applications.
[removed]
Your comment has been automatically removed because it appears to contain disrespectful profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/babfl5/a_pretty_big_list_of_c_gui_libraries/ekay77u/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
No FLTK. Faster Than Light ToolKit?
I know some people want us to think it's a trend, but whether it's true or wise are different questions. Has it been used wrong? Sure. Show me one language feature that has not been used wrong... No reason to "ban", or to throw around completely unwarranted phrases like "epic failure". 
Maybe Slate? The GUI lib of UE4
Alrigt, I am sorry for not looking at your library more deeper then just skimming over it. Thank you for explanations! I believe that even std lib will use malloc/free &amp; co behind their new/delete operators or whatever malloc/free/memcpy maps on the respective platform, so I am not really sure if you are winning anything by implementing your own in hope you will get more optimized by compiler, unless you go full path with assembly and vectorization. I don't know, I am not an expert to be honest. For COW I was fan of it before, but I have not done much research on the subject since c++11, more than I am aware that there are divided opinions about the usefulness. I don't always agree with c++ standard, I think it sometimes forgets it's pragmatic purpose and goes too much on academic side (for example I don't wish to type nullptr instead of simple 0, I would love to have simple lambda functions as just simple nested functions instead of piggy back them on OO design with this ugly constructor \[ ... \] language they come up with and so on). Forbidding COW might be one of those things, but I can understand that in a general implementation it might make sense and leaving COW for custom class in special cases where it does make sense. I am not sure that you must have spliting &amp; tokenizing implemented in class itself. I think std::string already has too much functionality baked in, but when it comes to api design it is always subjective. If you wish to add more functionality it make sense to extend std::string so you can use your class in same places as std::string, or to write your class to work with std::string. I didn't check how is your interoperability with std::string.
I would list Qt widgets and Qt quick as 2 different GUI frameworks, even though both are part of the Qt project. Both are great in my opinion. Qt quick requires learning QML a declarative markup language with JS thrown in the mix. 
Did you have a look at cinder: https://github.com/cinder/Cinder? 
... how ? 
You have a ton of static composition tools in the template toolbox. Policy-based design and CRTP. In term of generic polymorphism, I agree there are not many options. But we have stuff like Mixins. And also the good old 'composition by containment'.
Inheritance should be an implementation detail.
&gt; You have a ton of static composition tools in the template toolbox. this would require the whole GUI framework to entirely live at compile-time (good luck hot-patching), and you wouldn't be able to generate new events at run-time. That would be a no-go for many projects due to the increased compile-times. &gt; And also the good old 'composition by containment'. what's this ? 
&gt; what's this ? Member variable-ing.
... how does this work ? how do I go from, e.g. class MyWidget : public Widget { private: void onMousePress(float x, float y, int button) override; }; int main() { Window window; MyWidget widg; window.addWidget(widg); window.show(); } to e.g. class MyWidget : public Widget { MousePressHandler mousePress; }; without additionnally passing a bunch of pointers to the parent widget class which will convert the window system events into events that your app can process.
Well you know what? In the little example you brought up I actually support lambda functions as callbacks rather than all the inheritance jazz. Don't you think it is a MUCH simpler answer?
no, that's terrible : now every lambda will certainly store an additionnal `this` pointer to the parent MyWidget (say, if you want to change the color of the widget when clicking, etc). So `sizeof(ComposedWidget) == sizeof(InheritedWidget) + number of handlers * sizeof(this)` And that's not accounting the horrifying possibility that you store your lambdas in `std::function` in a base class, because now you have one vtable and potentially one additionnal memory allocation **per handler**. 
&gt; What I can find about the "free" ability to sideload apps onto an iDevice is that they only last 7 days where did you find that ? I never had this (though I haven't done that in about a year). 
What are you talking about? Of course you're not inheriting if you use callbacks! No need for a stupid vtable zoo!
Which one is the easiest to learn? 
Isn't SDL2 a framework? If not then what do you call it? 
OP never claimed that they were being purely factual, this is simply a list with GUI libraries and short notes from him. But yes, "ugly af" and "smells like build hell" does imply that the author has done research. It's hard to be more than superficial when you are looking at 35 completely different implementations of the same or similar feature set.
Is there a reason you didn't use an existing parser like Antlr4 instead of writing a custom parser?
NIH no fun.
&gt; Of course you're not inheriting if you use callbacks! No need for a stupid vtable zoo! I would like to see how your callbacks work then
For me and my clients JUCE is perfect. You drfibetrly have to get used to it and it doesn't have the shallowest learning curve but neither has Qt! JUCE is a great framework with a nice and flexible developer team that help you solve your bugs and problems. The community is great too and I have to say mobile development isn't of course as easy as developing in the native language of iOS/Android but it's truly cross-platform! 
 [http://nanapro.org/en-us/blog/2016/05/an-introduction-to-nana-c-library/](http://nanapro.org/en-us/blog/2016/05/an-introduction-to-nana-c-library/) &amp;#x200B; Here you go. They work like this. &amp;#x200B; I'm not trying to tell you that nana is 100% inheritance free or doesn't use inheritance internally. But I would like you to know that we actually use inheritance way too much. It's a solution to a non-problem. Personally, I think yes we cannot dump them completely. However, it's a really big solution when you actually need small things. And we can work it out in those cases.
No, no, I think you misunderstood the point of why we think inheritance is bad. Inheritance is itself not a bad thing. It is definitely a solution to a problem. The problem is that inheritance is a high-caliber solution you are supposed to use even for small problems. The fact that we have to inherit deeeep hierarchies just to perform dynamic polymorphism is sometimes overwhelming. I just wanted a glass of water but what inheritance gives us is the whole kitchen sink. How is this not an epic failure to provide a 'good solution'?
I plan on destroying the current "least worst" option (Qt) with neoGFX. :D https://neogfx.org
nana uses std::function everywhere. You know that std::function is implemented with inheritance, right ? so back to what I said, instead of having one vtable per object, you get one vtable *per callback*. hello binary bloat.
&gt;std::function everywhere. You know that std::function is implemented with inheritance, right ? so back to what I said, instead of having one vtable per object, you get one vtable &gt; &gt;per callback yeah missed that. But I was talking about the API aspect anyway.
&gt; some dude lol
&gt;The problem is that inheritance is a high-caliber solution you are supposed to use even for small problems. According to whom? &gt;The fact that we have to inherit deeeep hierarchies Who makes you do that? And even if it turns out that dr. Stroustrup is paying a gang of thugs to hang around your house and beat you up whenever you use a hierarchy less than gsl::min_hierarchy_depth, while by itself somewhat disturbing, what's the problem with it anyway? &gt;I just wanted a glass of water but what inheritance gives us is the whole kitchen sink. How is this not an epic failure to provide a 'good solution'? The only epic failure here is that you apparently went out and bought a kitchen sink, when all you needed was a glass of water. Why would you do such a thing? And why are you arguing against other people's use of kitchen sinks? Maybe they are cooking food. Maybe they are doing dishes. Maybe they actually need a kitchen sink, and get mightily annoyed by your anti-kitchen sink-zealotry. 
\&gt; Who makes you do that? Libraries with inheritance APIs make me do that of course. Why am I bothering about others' kitchen sink? because I am forced to use a kitchen sink too. It's that simple Why can't I not use a kitchen sink? Maybe It's because I have to use Rust :S (but I don't want to)
&gt; on OS X pushing pixels from system memory to video memory is quite slow Indeed, Widget graphics on OSX used to be very slow. But since Qt 5.10 this is no longer the case and widget graphics are as fast as on Windows. I am doing real time graphics on 5K screens (about 20 fps) with no problem (something I thought would never be possible). However, this is with a good Qt expertise and experience of writing fast code. This being said, this might not be enough for a game app. And secondly, GPU graphics are obviously faster in any case. But this is also possible with Qt. 
Nice, keep it up! I hope those disgusting Vista-esque gradients are 100% optional though. :p
A few issues: - Some of these GUI libraries do not have cons listed, when they do have cons (Dear IMGUI isn't perfect, although it's good) which immediately smells like it's a very opiniated list, which is not useful for people who look for tools by comparing with their context see if the cons are acceptable. - Immediate mode gui libraries and the others should be separated, they imply a widely different way to code. - Some of the libraries only work inside your own display system (like Dear IMGUI) which is another massively different category. - The "ugly af" comments are not helpful at all. Same for most of the comments you make on the libraries you didn't try. - Boost.UI is NOT a Boost library (it have never been peer reviewed, maybe it's a candidate but it's not obvious from the doc). - How "javascript" is an issue for tools that work with HTML/CSS/JS??? 
But 20fps on 5K screen *is* slow. Anything cocoa, Qt scene graph or even electron based will do 60fps without breaking a sweat. That's night and day difference.
(And nobody use)
I was searching google for something similar yesterday so thanks for this
I like gradients but yes there will be a flat skin too. 
Also [ultrali.ght](https://ultralig.ht/), though licensing is still unclear.
I would treat Widgets and Quick differently as well. Note that nowadays you can also use Qt Quick with QSkinny and QNanoPainter, which would be in C++ only. Those projects are third party, and might not be considered as stable as Qt Quick Controls.
Great work. I really dig your summary of Qt as it is pretty much exactly what I feel. As I am currently looking for a replacement of Qt, may I ask, which lib would you recommend that: * supports HighDPI displays * looks ‘native’ on Windows and Linux * goes well with CMake * BSD compatible license * has an editor * modern C++
Nice. How does it perform on Linux, Android, macOS, and iOS?
It should perform the same no matter what the OS. 
Agree. Btw have you used Qt Quick? It’s obviously more fluid but in my limited experience it eats a ton of RAM.
What about [Verdigris](https://woboq.com/blog/verdigris-qt-without-moc.html)?
SDL2 is the simple directmedia layer, it doesn't have GUI functionality built in, but you could implement those features on top.
Great work! I have one that I'm not 100% sure it qualifies. There's the Slate UI Framework [https://docs.unrealengine.com/en-us/Programming/Slate](https://docs.unrealengine.com/en-us/Programming/Slate) In theory you don't need the entire Unreal engine to make an application with the GUI framework, but I don't really know why someone would do that, beside for the Unreal Editor.
I wonder how it'll end up being burned in a volcano in the end...
will add, thx!
Hmmm, good question. I'll think about it, but I'm leaning towards not including at it would require a lot of work.
Yep, I put it at the bottom since they don't have screenshots :) 
I did, but I don't think you can extract their GUI lib to work standalone? Let me know if that's the case.
It's there, look again ;)
Suggestion: maybe you can publish a link to wikipedia for easy access to platforms, licenses and so on like https://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries
There was an attempt at humor ;) I was split with NanoVG, but yes I think I'll remove it. "doesn’t use cmake" means they hardcoded all platforms IDE projects, which is 100% code smell in my book. I'll bet you one of those projects is out-of-sync. "requires SFML" is a big deal as it is an OpenGL context loader, and others may use SDL/GLFW to load the context. It means you can't use it in that case. &amp;#x200B; The post isn't meant to be super serious research, and its certainly not trying to be "objective". Just what I could spot looking at their project in \~10 minutes. If you do have experience with some libraries and have extra pros/cons, let me know! I will happily add info. Good day :)
I would like to give you the "understands internet" trophy today, cheers :)
TBH, most of them are compatible with Windows, Mac, Linux. I'll consider it for a future iteration, I'm a bit burnt right now.
note taken
A random thought I’ve had going around my head for a while - and be aware I don’t really know what I’m talking about here - would it be possible to pull out the C++ classes Chromium uses to represent elements on a web-page, and then expose a C++ way to connect those up into a UI? That could be a fascinating way to develop cross-platform apps. (Feel free to rip this idea to shreds. I’ve never looked at the Chromium code)
It isn't? My bad, will update. Thank you!
Well you can't have your cake and eat it too XD
If you are going for a native look, I think you would want to look at wxWidgets or boost.ui. Let me know if there is any other GUI lib with that focus in mind.
This is where you are mistaken. It’s not about my cake. People won’t judge me based on your style. They will judge you. 
ah it is Windows only, I don't list single platform libs unless they are dead.
:+1:
I'll guess Qt, simply because it is the most popular. Dear ImGui is also quite simple and fast to setup.
It is your right to judge me ;)
I might do a second pass adding platform/licensing info. Just not this w-e.
Nowhere did I say I judge you. I gave you feedback. You can think about it or be pissed about it. It’s your call. 
Yes 20 fps is slow compared to 60 fps. I just want to mention that widget painting is as fast on Mac as on Windows, nowadays. And that 20 fps on a 5K screen is decent anyway, especially when you consider that each pixel is painted individually by the CPU (but SIMD used a lot).
What do you mean by stand alone in that context? I haven't used cinder for anything significant yet. I just was curious if you excluded it on purpose and if so why.
Well it isn't a GUI library, it is a multimedia/2d/3d library, no?
valid criticism, fixed
Enabling this would be a huge gain for image processing algorithms where we very often work on 2D matrices of 8bit values.. &amp;#x200B;
The code for widget painting is exactly same on Windows as it is on Mac, and so is the performance. Which is generally quite good. But in my experience the bottleneck is flushing the backing store. In OS X this involves either creating CGImageRef from backing store and updating CALayer with it, or uprating opengl texture with new backing store content. Both of these unfortunately take lot of time. Even if you have empty window with no widgets, you still won't be able to do this at 60FPS @ 4k. In my experience this is till significantly faster on Windows, where the backing store simply does BitBlt, which seems way better suited for this use case.
Yes, but you can just use the graphics part. But now that you mention it, I don't think it provides buttons and stuff like that out of the box 
That’s what I figured after reading the post too. Boost.UI actually does look nice but the sparse docs and the fact that they are not ‘ready’ set me off a little. Also, I don’t like how they call themselves a Boost lib which they are not. WxWidgets have been around for a long time and that’s something to look at for sure. 
I have no idea why this doesn't vectorize, or why it should, but no sane library stores images this way.
Looks interesting. Too bad it is licensed under GPLv3 though since that will not work for me...
Evo strings have basic find, split, and token methods. Python was an inspiration here. Most of the tokenization support is in separate classes like evo::StrTok and evo::StrTokQ. For more on Evo STL compatibility see [here](http://jlctools.github.io/evo/evo-0.5/html/StlCompatibility.html) 
When 1.0 is released I will move to a dual LGPL/commercial license. 
do you necessarily need to learn a framework to develop a simple basic GUI for your C++ code like for example a tic tac toe game? 
Looks like sth is wrong with getting context of 2d array with char. It looks it's ok after splitting fors: [https://godbolt.org/z/lQHrNB](https://godbolt.org/z/lQHrNB)
Seems a pretty standard case where the compiler cannot even be certain there's no aliasing in your pointers : https://godbolt.org/z/1os3ZJ
Very nice work! Do you also have any benchmarks regarding the query performance? I'd be also interested in comparing your hash table to Tessil robin hood implementation ([https://github.com/Tessil/robin-map](https://github.com/Tessil/robin-map))
My uneducated guess would be that the aliasing heuristics are different for `char*` and non-`char*` pointers. Adding `__restrict` to the pointers fixes the issue.
The [Wikipedia list](https://en.wikipedia.org/wiki/List_of_widget_toolkits) is smaller, but has that information for the libraries it does include.
I’m currently making a windows-only C++ service as a side project, and it needs a very simple window just to change some settings, anyone have a good suggestion of which library to use for this? Are any of them able to use with the standard createwindow/windowproc, or do they usually make their own window?
1) Very unlikely. 2) Parts of the API are still defined as TODO, so it is still in flux.
Good trick indeed. Too bad it requires new compiler versions. What if you weren't interested in the to\_string function but only to the size one. Would a new compiler still be needed?
So you want to manipulate an HTML DOM in C++? Why not just use Electron at that point? 
&gt; I've compiled the libraries here with screenshots, short descriptions and pros/cons I could quickly gather. Let me know if I missed anything (alive or dead)! This is great, I've been looking for something like this. Finding examples/screenshots of GUI's can be hard sometimes.
1) Very low. I'm in the minority of thinking that it would be great to have a way to create a basic window with basic mouse and keyboard io that can push pixels or serve as an OpenGL/Vulcan context. I seem to be in the majority however in thinking that the API and underlying mechanics proposed did not get down to the fundamental principles and came off as fairly awkward and misinformed. 
That’s not quite what I’m imagining. I think. I don’t really know. I think what I’m imagining is using the cross-platform rendering capabilities of Electron, but being able to do that from C++ with a standard set of widgets to avoid the Javascript layer. But this is probably based on a fundamental misunderstanding (on my part) of how Chromium actually works. Allow me to go off topic for a minute - I can see a future where Electron becomes a default cross-platform app engine. I’m not saying I will like this future, I’m saying it’s a clear possibility. In fact I take Microsoft dropping Edge and rebuilding it with Chromium as a big push in this direction. MS already have web versions of all their main products - why not go the whole hog and drop the native versions and bundle Electron versions instead? They could take it one step further and have a shared instance of Chromium on Windows that ran all of Office to avoid some of the bloat. I’m wondering how we can avoid that future and the many wasted CPU cycles it will entail.
I was so excited to read what you wrote about Fox-Toolkit since that's what we use where I work. The cons sums it up just about perfectly, lol!
I agree with you on that one: it would be great if we had a library that abstracts things like windows, events, etc. As for drawing, if the first version gave access to a bitmap-like abstraction (so drawing libraries can target it, independently of the standard), we would already have made a giant leap forward. I imagine this would also be considerably less controversial than a drawing library; windows and events are not that incredibly exciting. &amp;#x200B;
&gt;ImGui Not a good sign when the test app crashes immediately - [https://i.imgur.com/EeIhXp6.png](https://i.imgur.com/EeIhXp6.png)
right, but do you know why the compiler behave differently for different data types ? 
Internally there is not a big difference between to\_string and checking if an enum exists. The problem with GCC is that \_\_pretty\_function\_\_ isn't constexpr for some older versions and there are gcc versions where pretty function works differently for enums. MSVC fails on some of the advanced template stuff for older versions... So if your not using clang I think your out of luck.
In computer vision we often embed theses pointer into objects (opencv cv::Mat for example), this prevent us to use restrict.
Actually many CV libraries map a contiguous array of pixels into a array of pointers pointing the the first pixel of each row. More info here: [https://stackoverflow.com/questions/44129851/allocation-of-memory-in-numerical-recipies-c](https://stackoverflow.com/questions/44129851/allocation-of-memory-in-numerical-recipies-c)
That's my current workaround. But it'll be much cleaner if the simpler version get vectorize. And having the loop vectorized on int but not on char does not make sense to me... &amp;#x200B; Does somebody knows who could be able to push this feature in the next version of clang ?? &amp;#x200B; &amp;#x200B;
Well, let's see. The standard is now that two pointers to different types aren't allowed to alias so it'd be UB. So the compiler automatically assumes they are "restrict" to each other. But if I'm not wrong, char is special case since it's used for memcpy and the like. A `char*` doesn't count as "not alias" to any other memory. So as a rough guess, the compiler cannot assume that your writing to a `char*` isn't changing the value of the `char**` pointers you use.
Nice! Probably many of us had done a similar research sometime but haven't published it. IMO, trying to do/emulate native look in a cross-platform UI library is a bit of wasted effort nowadays, since users seem to not care about it and happily use bloated electron-based apps. Web and desktop interfaces are converging, whether we like it or not, so we might as well use anything decent. Also [I've tried](https://gist.github.com/yuyoyuppe/ee6afa12e7a72db122a9aca0d449ae76) using [Windows Composition Engine](https://msdn.microsoft.com/magazine/dn745861.aspx) to get multiple Imgui windows drawn on a transparent background with GPU blending, but the only blending mode that Windows supports is `DXGI_ALPHA_MODE_PREMULTIPLIED`, so we are out of luck(or I'm missing something). There's an easier option to just create titless and borderless window if your software doesn't need to have multiple windows simultaneously.
Hi, I’m pretty new to C++ GUI development, I’m eager to learn more. I have a copy of Charles Petzold’s book on Windows programming with the Win32 API. Are the libraries you listed completely independent from the Win32 libraries? Or are they built on top of / extensions of the core system libraries? Thanks for putting the list together, it’s quite extensive! 
A bummer that we don't have a proper way in C++ to give the compiler hints about aliasing. Some time ago a saw a post about a possible std::alias contract. Is there any news on that?
I don't see any CV libs mentioned in that SO question or answers. But this is obviously bullshit because loading a pointer to start of the row can be orders of magnitude slower than computing it's offset, and doesn't require memory to store the pointers. 
So, which of those requirements does Qt not meet? Why are you looking to replace it?
Qt is both very popular (despite people on this subreddit seeming to have something against it) and has great documentation and examples.
It should work with NVIDIA or Radeon; as the project states it is still a work in progress. 
If you read the error you will see that OpenSSH needs to be installed for the test app. 
You can probably fix it by enabling TBAA with enum Int8 : signed char {}; enum UInt8 : unsigned char {}; and using those for everything instead of `int8_t*`/`char*`
Wow, this is amazing! &amp;#x200B; I recently became interested in trying to develop GUI applications and gain experience with user interface. It seems like starting with Qt is not a bad option, as it is battle tested, mature and many programmers use it, but I'm a little overwhelmed by what seems to be the many "sub facilities" it has to offer (QtWidgets, QtQuick, QML...) Does anyone have a link to some summary of these different terms and/or a link to a tutorial with current-best-practices?
Look at this presentation: [Life of a Pixel by Steve Kobes](https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.g28c53b6c30_3_95) There is a problem with chromium although. It uses a Garbage Collector internally called Oilpan for DOM nodes as those objects are exported out for JavaScript which doesn't do manual memory management. [Blink GC API reference](https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/heap/BlinkGCAPIReference.md) The easy part is the painting layer in Chrome as the Skia API pretty much usable and crossplatform. [https://skia.org/](https://skia.org/) You can reuse the layout engine from Chromium also. [https://github.com/chromium/chromium/tree/master/third\_party/blink/renderer/core/layout/ng](https://github.com/chromium/chromium/tree/master/third_party/blink/renderer/core/layout/ng) 
Next time read the README. It tells you what to do (in this case install OpenSSL).
It's not so bad, thanks to hardware memory access prediction. But it is still worse than contiguous memory as it will waste a little bit of memory bandwidth.
I'd rather find a better, less dependent GUI library. Good luck with your work, anyway.
The OpenSSL dependency is there due to Boost being dependent on it. It can be built without that dependency though. Thanks for letting me know that you can find something "better". :/
iOS and Android compatibility are important as well. I use the Qt QML system for rendering UI for compositing into 3D VR scenes and it's support for Android is critical for me.
Space, why use a container ship to carry a letter when you can use an envelope? Same thing with int and double, you need to be efficient. 
&gt;windows and events are not that incredibly exciting. Why not just use SDL? I am not sure if having a library that deals with windows and events would be that useful considering how fast the landscape changes compared to the C++ standardization and how different those things would be on various platforms.
An int is 4 bytes, a double is 8. It's a waste of resources to allocate more memory than needed to get the job done.
That's not really an explanation - a float is 4 bytes.
[relevant question](https://www.reddit.com/r/javahelp/comments/3qutst/newbie_why_would_you_use_int_over_double_ever/)
He wasn't asking about a float though. He was asking about int and double. Comparing ints and doubles, the main reason is efficiency.
Integer operations are faster than floating-point ones. 2*2 is faster than 2.0*2.0. 
Doubles aren't exactly precise. Equality comparison operator `==` doesn't usually work like you'd expect it too. Look up floating point arithmetic. Short story is, you usually want to default to ints unless you really need fractions.
Sometimes you dont want decimals. For example: you have an algorithm that determines the number of people that can fit in a room.if you have a room that fits 25 people, a room half the size could fit 12, it wouldnt make sense to say 12.5 people fit in that room. That might be one case you want an int as opposed to double.
The reason you use an int instead of a double is for space efficiency. The reason you use an int instead of a float is to avoid inefficient and inaccurate representations. Just because OP's question is inarticulate doesn't mean the given answer is wrong because you consider it incomplete.
To add to what others have said, try initialising a double to 3.0, then put a breakpoint after it and see what number you get in the debugger - it won't be (quite) 3. The small error you get representing numbers as doubles will lead to a violation of associativty -- so while a + b = b + a, a + (b + c) != (a + b) + c. Try getting a few billion doubles and shuffle them into a random order and sum each set of pairs (that is, (x1 + x2) + (x3 + x4) + .... Reshuffle and do the same again. Odds on you'll see a slightly different answer. &amp;#x200B; Floating point maths is ugly and inevitably error-prone and there are times that integer maths is to be strongly preferred. There's a reason, for instance, that FLAC is written using integer maths - it guarantees associativity and commutiity, and it would be trickier to guarantee lossless encoding if they were using doubles, which won't. &amp;#x200B; This isn't to say that you always want to use ints; quite possibly you're doing something where you don't care about the errors introduced by floating point maths, or simply have to live with it. Integer types, for instance, have a dramatically smaller dynamic range. It's hard to represent 10\^76 as an integer, but trivial as a float. But there are times you *don't* have to use doubles, at which point an integer type may well be preferred.
By the way, `float` uses binary fractions, not decimal. If you want to exactly represent decimal values (for example in financial accounts), then to keep rounding predictable, you should use integers (but not necessarily `int`) with the unit being one cent or whatever.
&gt; it wouldnt make sense to say 12.5 people fit in that room tell that to a statistician
Not is only a question of space. Size of int depends on platform (most of cases 32 bits, so 4 bytes), as long, that could be of 4 or 8 bytes size depending on platform again. But it doesn't mean that double is always preferably to long (when 64 bits size) or int64_t. The main reason is efficiency. C++ is a language for performance, and floating point ops are much more expensive in CPU usage and time that its equivalent integer operations. So, if you don't need floating point numbers, don't pay for that. Also, there are a lot of cases where you cannot simply use floating point numbers. For example, to indexing a vector. What is supposed to be the element v[5.3]? And what about v[-2.09878E+23]? C++ is very strict on types, and indexing or pointer arithmetic require integer types.
Okay, maybe not the best example. But I was thinking about the signs that are posted on conference rooms or assembly halls that tell the capacity of the room, they are always integer values.
You can use a wrench to drive nails to soft wood but a hammer is by far the better tool for the job. There are many reasons: ints are faster, they take less memory (it depends a bit but as a general rule), their comparison works the way you expect to (floating point can get weird) and so on. However, to me the most compelling reason is the expression of intent. By using an integer, you are making a statement about the use of the variable. A house cannot have 2.7 rooms, a person cannot have 1.5332 children and a container cannot have 4.5 places where you can put things. Programming is about telling the compiler what you want the computer to do, and sensible use of variable types is one of the best ways to do it.
While you might be technically right, you're missing the point of the question completely. There are 32-bit and 64-bit flavours of both ints and floats. You know what OP was trying to ask, there's no need to be obtuse. Advantages of int (long, short or normal) over floating point (single precision or double precision): 1. Guaranteed precision and no floating point errors. Try comparing `1/10 == 0.1` 2. You can perform meaningful bitwise operations ints. 3. Integers can be used to address memory. 4. Integer arithmetic can be a lot more efficient on some architectures compared to floating-point arithmetic. 5. Floating point errors. 6. Some operators (like modulo) and functions only work with ints. On most modern 64-bit architectures, 32-bit data types will be padded to 64-bit so in that regard, your answer is completely wrong. This is just off the top of my head.
On most modern 64-bit architectures, 32-bit data types are padded to 64-bit so it makes no difference at all.
An `int` is typically not what you want. A `for` loop counter can be an `int`, but it's better to make it a `size_t`. That `age` member a variable should probably be an `u8` because humans don't live longer than 255 unless you believe the Old Testament. `int` has a nonspecific size and this is by design; consequently, your code is not portable because some other platform might decide to give an `int` just 16 bytes. The correct solution is, therefore, to use `int32_t` and similar from `&lt;csdint&gt;`. An even better solution is to typedef these into even shorter symbols such as `i32`, `u8` and so on. It gets even worse because int-int operations in C++ don't get promoted to `double`, so if you do division of two ints you still get an int having, essentially, incorrect value as result of division. Some PLs automatically promote integer calculations to FP, but C++ does not. TL;DR you probably don't want to use `int`, ever. /s
&gt; it won't be (quite) 3 This is not true. Double can represent integers up to +- 2^53 exactly.
Because an `int` is an exact value for all the value it allows. But a `double` is an approximation, a sum of fractions. Which sometimes is exact, and sometimes not, and some values cannot be represented exactly represented in a double.
Yes, very true - 3 was an atrocious example written overquickly. 0.3 would have been a better choice...
&gt; double can take decimal It doesn't store base 10 values, it stores base 2 and since humans tend to use base ten everywhere you get a lot of unexpected issues with that, just try comparing 0.1 + 0.2 with 0.3. None of them map well to binary floating point values, so you end up with rounded values that are close but not quite your original input and as a result the addition of not quite 0.1 + not quite 0.2 does not add up to not quite 0.3 . If you are dealing with base 10 values with a clear cut off point you can just use fixed point values, say 1 dollar is 100 cents. No need to get dollar results that look like $1.0000231141513151135 just because your input and computations constantly round to the next best binary floating point representation. 
At one time, some decades ago, that used to be so. Nowadays such a claim needs to specify the system and be backed up by measurements.
the problem with doubles is the [following](https://wandbox.org/permlink/ugixU9p4V2GQz2Z0) : double x = 1e100; double y = x + 1; if(x == y) { printf("oopsie\n"); }
Yes, decimal values and fractions are problematic if you require exact values.
Ok. But why?
Imho bad example. If you're algorithm uses arithmetic operations that could produce fractions, you must likely do want to use floats and then use something like sound or floor as part of the algorithm. 
Can't double represent all values of an int exactly?
Is there really any system where this is untrue?
You couldn't even use an int here, so how is this relevant to the question?
`int`s are useful for when you want to specify whole numbers. `double`s are useful when you want to specify fractional numbers. However, be mindful of the fact that `double`s are implemented a sum of binary fractions, so you can't represent certain fractions exactly (see more [here](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)). Neither is better than the other, they're just different tools for the job.
&gt; The reason you use an int instead of a double is for space efficiency. No, the reason to use an `int` is because it is the correct type for the data you need going to represent. You use integers for array indices not because of space, but because `a[2.5]` makes no sense. In particular, `float` and `int` are often exactly the same size...
Floating point being slower than int, or the other way around? If the former x86, addition, subtraction and multiplication are the same speed and floating point division is actually faster, plus there are SSE instructions for floating point division and not integer division. If the other way around, then anything without an FPU, but I can't be more specific than that.
XD
&gt; ints are faster It obviously depends on the architecture, but at least on relatively modern (read: not ancient) x86 CPUs they are the same speed for everything but division, where floating point is faster.
Username checks out.
Because x86_64 has horrible vectorization support at byte level. VcCpp specifically (which is likely to get in the std) can't allow them.
imgui is great for prototypes imho
yep pretty much
Note that floating point division is faster than int division on many modern processors. Can be surprising. See also https://youtu.be/o4-CwDo2zpg
Most of these are independent. Those that focus on a native look (wxWidgets for example) will wrap various platform apis to the least common denominator and expose that to the user.
A better question to me is why straight `int`s instead of more precisely sized integral types. In my personal code I like to prefer `std::int32_t` over `int`. I don't like the idea of a type changing size underneath me just because I've changed where I'm compiling to. Sadly I've lost this argument at work as the opinion is "Don't worry about it if it doesn't matter."
touché
On the other hand a float holding 2 makes perfect sense, if all you need is what is in position 2 of the array. Maybe it's an associative array in which case, I might actually need 2.5 as an index. The reason you use a single precision integer instead of a double precision integer is for space efficiency reasons. You are trading off accuracy for space. If your number is less than what fits into single precision then you do not gain accuracy using double ints instead of single precision. Of course you can put a float and an int into the same sized box, that's the point of single precision. But please explain to me how there is no penalty to converting, handling, and manipulating IEEE 754 representations instead of unsigned integers? Maybe that's the real reason you use ints in arrays instead of floats.
Not the person you replied to, but I've ran into a use case where floating point operations were just unusable. I don't remember all the details, even though it was "only" two years ago. A dsPIC32 (unsure if those things even have an FPU) had an interrupt triggered each millisecond. `atan(x/y)` took much longer than 1ms. `atan2(x,y)` was considerably faster and worked most of the time. In the end we had to implement fixed point arithmetic types to avoid `float`s. I really wish fixed point was part of both C and C++ language.
Ok thanks, I just added #error for the unsupported compilers.
According to https://www.agner.org/optimize/instruction_tables.pdf, floating point add has 4x the latency and 1/3rd the throughput as integer add... so, no.
Maybe I've got this completely wrong, but SDL, to the best of my knowledge, is a library for writing games that focuses on giving you a single, full-screen screenbuffer to write to. What I have in mind is more intended for writing desktop applications. And is that changing? To me it looks like we have the exact same primitives and events we had back in 1985 or so. 
Agner Fog's Instruction tables are a great resource if you want to know about instruction timings. But they do not tell everything. For example you need to consider the overhead for moving between vector/fpu/general purpose registers too. This and the fact that modern cpus use many optimizations (superscaler, Out-of-order execution, speculative execution, etc ... ) makes it pretty hard to say how real programs will perform. 
There's nothing wrong inheritance. All this recent anti-inheritance stuff going around is just yet another fashion. Since software is still hard, and OO and inheritance are widely used, apparently it must be the problem. Of course ten years from now, some one will be telling them that whatever they replaced those with is the root of all evil and they should be using inheritance. If you know what you are doing, inheritance is a hugely powerful tool. Don't let anyone convince you otherwise.
The problem is the dereferencing the points twice in the main body of the for loop. Clang doesn't know what to do with it for char\* types. &amp;#x200B; [https://godbolt.org/z/0GaJK5](https://godbolt.org/z/0GaJK5)
Hm, good points. Although if multiplying by two, as in the example, that's a bitwise shift and not even an integer mult.
&gt; Because an int is an exact value for all the value it allows. A double is also an exact value for all the values it allows. It just does not allow all the values the intervall of its domain. 
Exactly relying on truncation for correct results is potentially very error-prone.
How many of these tools are there now? Right off the top of my head I can think of cppUnit and CppUtest?
GPUs, probably.... :)
+1 on the expression of intent. But even more so than expressing your intent to the compiler, what is important is the expression of intent of whoever reads your code (even your future self). The compiler is fine thinking 2.7 rooms are possible since it doesn't know what a room is, but it's gonna look weird for you. Documentation is key in programming and self-documenting code goes a long way. But also, on a more technical level, performance, memory usage and precission are not to be forgotten. Your CPU is a machine designed to operate on ints better than floats, mostly (if you were writing GPU code, like a shader, "why would you ever use ints" would be a more relevant question). In the end, just use int because what you are represting _is_ an int (a countable, integer amount of stuff, indices, etc).
Qtest, Google test, boost test, catch 2 to name a few
I probably used fewer than ten doubles in the last year of professional programming, and thousands of ints. A lot of the time you don't need floating points.
Usual question: why would I use this over gtest?
No. Only powers of two that are small enough to fit into the mantissa. And some architectures even get those wrong.
No. If the effect of a method is unclear, you need to name/document it better. If outside code cares about members, you should be using a struct and mutating it with free functions. Give more details (what is this object modelling?) for more concrete answers.
I would like to add my own dead project: [Vaca](https://github.com/dacap/vaca) ([screenshots](https://github.com/dacap/vaca/wiki/Examples))
What do you mean "padded to 64-bit" ? Why? What triggers the padding and what for? What exactly is padded? :D 
If this is significant enough - and the kernel involved is small enough - your best bet is to do the vectorization yourself with intrinsics. Stuff like this demonstrates how fickle or fragile autovec can be. Unless you're on the codegen like a hawk you don't know when or why you'll be losing autovec for any reason.
roger roger
It's obviously not just powers of two. You don't think 3 can be stored exactly as a floating point number?
Too add yet another dependency to your project /s
How about using `std::uint8_t`? It would kind of be the better type to represent [0, 255] image data anyway?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bamq6f/need_help_with_time_related_problem_in_c/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Isn't it typedef?
Solved!
Two possible reasons. 1. The hardware doesn't have good support for vectorizing 8-bit elements. 2. char * behaves like void * in the aliasing rules. Any pointer could alias it. This is not the case for other types like int.