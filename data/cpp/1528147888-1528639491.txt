nek je ziv i zdrav 
Erich Keane: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0781r0.html
The proposed sort-only-one solution is more complicated and not really asymptotically better than the first. `unordered_set/map`'s worst case being O(n^2) is hardly relevant, except in a security context... Instead, the average case O(n) is what matters, and that makes it the clear overall winner. There was little point in even discussing the nuances of tge subpar sorting-based approach. 
I wish you could do that at a namespace level. i.e. `namespace foo const {}`. Everything in the namespace would be const unless marked as mutable. Could that break existing code in any way?
Thanks
&gt; In the C++ language const is a totally optional keyword No it's not - at least non-const reference binding doesn't work with temporaries, so good luck with void foo(string&amp; s); foo(bar.substr(4));
If you consider `m = n`, then yes. But `m` and `n` are separate variables. There are many situations where `n = O(m)`. Consider, for example, that `m` is upper bound with a (sane) constant `k`. The complexities are: - two-sorts: `O(n + n log n)` as everything else is constant time - single-sort: `O(n)` as sorting and searching is constant time Now, the hash-based `std::unordered_set` solution should be the clear winner, but it is not, at least not with the latest libstdc++'s implementation. One place where the hash-based solution fares worse by default is memory complexity. Namely, in practice, sorting can usually be done in-place (there is often no need to copy the data before sorting) whereas creating an instance of `std::unordered_set` will require `O(n)` memory. And the usual `std::sort` implementations try to be very cache friendly, which is not the case with `std::unordered_set`. 
Mora i to ponekad ;)
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
First one doesn't work with the current templates, because `argc` is only known at runtime. If you want the second one you can easily write it yourself: #include &lt;vector&gt; #include &lt;string&gt; int MyMain(const std::vector&lt;std::string&gt;&amp; Args) noexcept; int main(int argc,char** argv){ return MyMain(std::vector&lt;std::string&gt;(argv,argv+argc)); } I personally see no benefit to adding something so trivial to the standard.
Do you know why exactly it was „shutdown in flames“? I mean I certainly don’t like magic, intransparent compiler types. But if that means independence from C relicts (like preprocessor) I am willing to take the trade. (Example: std::source_location)
The problem is `const` in C++ isn't about mutability. It just says, at the point of use, it can't be modified. It says nothing about the state inside being immutable and changed from somewhere else. That's why you can have `const volatile` to read from memory mapped registers. It prevents you from writing to it, but it doesn't mean it's the same value. Having everything `const` by default gives the wrong impression that it's about immutability when it's not.
What would you call it?
Copy construction
Does the standard define anywhere that assignment of primitive types is considered copy construction? It sounds pedantic as hell being a primitive and all, but hey... this is C++ and language lawyers are a thing, so can you find me some tangible proof of this so I can go forth and spread thy word to thy masses?
I agree with you generally, but may I ask why you're bringing up the preprocessor? I don't exactly see how it's related to the topic at hand.
\&gt; I personally see no benefit to adding something so trivial to the standard, when it is only used in one place. One advantage would be that you could pretty much ignore C features \(except when interfacing with C code\) in a C\+\+ program if the "modern" approach would permeate everything. Isn't this one of the selling points of Rust? That you don't have to deal with legacy features. From a practical standpoint, I also don't think it's that important though. Personally, I actually mix C and C\+\+ even in other places sometimes when it's appropriate and more modern approaches wouldn't really be worth the hassle. This might seem to be in contrast to the text above.
Not at all.
Initialization
It has nothing to do with primitive types. Literally the `type name = value` is copy-construction. That's how you write it out. That it looks like assignment is irrelevant, that's not what the standard says it means.
Google's style guide is good. Just make it work for you. You can even - *gasp* (I know! debauchery!) - fork it for your own use, and modify as needed.
I won't say it's completely useless, because it's not. Here it looks like much too complex. With an union, we would have been directly able to access the `red` property. The `complex` case would have been more interesting IMO when we need to convert polar coordinates into Euclidian ones. Yet in that case changing the phase could be named `rotate()` for instance. My issue with setters, and indirectly properties, is that's a facility that encourages bad design.
Would it kill you to just give me a link to the section in the standard like I've been asking? It's probably less work to just paste me a link than write out the above.
Well it’s about modernizing parts of the language in order to make them more secure, clean... you name it. The referred proposal is doing exactly that. It’s proposing to replace the C argv and argc signature with a „magic“ C++ compiler type. I think recent progressions in the language like constexpr if, source_location, modules also do that, in a way, by resolving dependencies on the C preprocessor.
Okay, yeah... I still think the preprocessor is off-topic in particular in this thread as we're just referring to replacing raw pointers/data with well-constructed objects (neither of which has anything inherently to do with the preprocessor), but I otherwise agree with you entirely.
I was initially referring to „magic types“ and how I am willing to accept them if they resolve dependencies on C. Source_location (and the preprocessor) is just an example that illustrates that trade-off: compiler magic vs rusty old C preprocessor. 
Gotcha. Thanks for the clarification. I'm going to try to understand what source_location is. 
Yeah it’s essentially like the __FILE__ macro, except that it’s not a macro an Instantiated inside a the functions arguments (I think)
The const on the int and float does nothing in a declaration like this, only on the definition.
To whom? To compiler? Sure But not to human...
It is not copy construction, but copy initialization https://en.cppreference.com/w/cpp/language/copy_initialization
Yes to a human. They are values, and so are 'in' parameters whether const or otherwise, as the function cannot affect the values the caller passed in. 'const' here says that in the definition, the local variable (effectively) is a const one. In the declaration it provide no information to the human, because you could make a value parameter const in the declaration, and non-const in the definition.
&gt; Yes to a human. They are values, and so are 'in' parameters whether const or otherwise, as the function cannot affect the values the caller passed in. Huh?! Sure it can. If it is non-const, you could alter it inside the function. &gt; In the declaration it provide no information to the human Sure it does - it tells human those are input parameters &gt; because you could make a value parameter const in the declaration, and non-const in the definition. well, tools are there to do checks for that...
Whether it can be altered inside the function body is not related to in/out parameters. Those reflect how the function can affect the value for the caller. Whether const-qualified or not, value parameters cannot be altered from the caller's perspective, so are always in parameters. clang-tidy does indeed have a check - it says something like "const-qualification of value parameters has no affect on declarations", a warning your example would trigger.
Thanks, this is exactly what I wanted to see! /u/thukydides0 Apparently it's copy initialization instead, since we're on the pedantic side of things you need to take a look. /u/m-in see how easy this was? You need to do this next time instead of writing a bunch of stuff with nothing concrete. Why can't you be like /u/Iwan_Zotow
With lambdas, it's a *very good* thing that it captures `const` by default. The fact that you forget to put `mutable` is a good thing because it needs to be an explicit choice to modify the external environment. Most uses of lambda should not modify the external environment.
No, as they may be built entirely at compile-time and be constexpr. That said, optimizers unfortunately tend to not handle the tables too well when dispatching through them -- a switch statement backend and even recursive chained if statements often outperform the table-based approach.
It sounds like you mostly built boost asio using processes instead of threads. 
There doesn't seem to be any informaiton about the benchmark at all, not even the values of N and M, which would seem to be important when comparing algorithms of different complexities. IMHO the benchmark really says nothing without some attemp to vary N and M, and see where the crossover point is. In the example problem, like many real world problems, N and M will be in very specific ranges (at least in decent codebases without a huge number of global variables), so having the crossover point would let us draw useful conclusions about a given use case.
Once you go "tab=8s", you never go back.
I reckon it would be improved with a screenshot!
That is the pattern. Caller allocates buffer and library call fills memory with result/output.
The main issue is there aren't safe ways of doing type punning in C++. Usually sanity prevails and implementations do what you expect them to as long as every type has the same size and alignment requirements and they don't need a constructor or destructor and satisfy any definition of POD. Do you have any example of an implementation where this doesn't work?
Stop watching and start writing. And Pareto's rule of thumb suggests you can ignore 80% of that big project. Use your skills to find the 20% that does the important stuff and it will put the 80% into context.
If your implementation defines the behavior for type punning and documents it, and if you keep that implementation version-locked, then it's okay. But my point is not that, it's about guarantees. Do you have the guarantee that all implementations will be nice and behave alike? It's not a trivial problem. &gt; I know there's std::memcpy but it's much more verbose and annoying to use. And that's a good thing. You're not supposed to break the type system, and if you really want to, then it's better be explicit.
Contribute to an open source project. They usually have beginner friendly tasks, welcome contributions, provide all sorts of real world challenges and problems, and will teach you how to navigate large codebases.
I get your point, and I know that for example implementations can decide to launch a nuke if you access memory out of bounds, but I've yet to see a compiler that didn't deal with type punning in a reasonable and sane way. You can have unit tests to check that it's working as well, it's not like you're hoping it does.
Yes, because the eventual target for this, Spartan, an alternative Java program launcher, enable Java programmers to fork child processes executing from the same program code and security context. This will facilitate a reactive programing manner of interacting with the child processes. The Java programmer's API will be styled after existing Java reactive programming standards
Reading and watching videos are great for learning new concepts, but you'll only get comfortable with using those concepts, and with working with larger codebases, once you've started actually *doing* it. I went from the typical undergrad\-sized programs to a product with millions of lines of code. Through practice, you learn to only pay attention to the parts of the program that are pertinent to what you're doing. Practice is key, though.
Why is this better?! Because it's "C++[number]-like? Not enough, not in my book. The pure C form has the following advantages: * OS already has all the data, no need to copy it to you * no allocations to do it * same code between C and C++ argc is only known at run-time, so `std::array` is a no-go.
This project reminded me the talk of Matt Godbolt at CppCon 2017. Specifically, the compiler explorer started as bare CLI calls to well\-known tools: [video](https://youtu.be/bSkpMdDe4g4?t=907). I highly recommend to watch it. $ g++ /tmp/test.cc -O2 -c -S -o - -masm=intel \ | c++filt \ | grep -vE '\s+\.'
So github has a bunch of open source projects, do you suggest I try to look into contributing to big name ones or try to find some local repos, which are a bit harder.
Why pass in an array at all? Why not pass the command line exactly as it is and let the program parse it into arguments? int main(std::string_view arg) You can even make it const.
do you have any benchmarks? it would be nice to build one. Also, in another comment at r/programming I saw this statement: &gt; Every call to visit is going to create a bunch of functions that end up in your text segment. from https://old.reddit.com/r/programming/comments/8ojwsc/everything_you_need_to_know_about_stdvariant_from/e04f3fg/ 
Is there a way to pass something to a constexpr variable during compilation stage?
True, but these are edge cases. I would argue that making things `const` would imply immutability in most cases, or semantically `const`, or at least mandate some degree thread safety. That is, while a `const` value might be mutable by something else, **you** can't change it. And its access is guaranteed to be well formed, or at least writes to it (by something else) is always atomic. Aslo, at the end of the day, we really want to reduce the chances of introducing errors, or allowing the compiler to enforce best practices, rather than covering all bases. 
To solve what problem? argc still can never be known until a certain number of arguments are passed in at runtime (specifically - argc number of arguments)
It's not best practice to promise something it's not. It is best practice to have immutable things where possible. But it's not best practice to pretend something (functionally) guarantees you immutability when it can't. Immutability means no changes whatsoever, so it doesn't matter if changes are done atomically or not. An atomically changed object is mutable if it has an observable side-effect. The whole point of immutability is the knowledge that a value doesn't change. It would be good to have immutability by default, but const by default is a bad emulation of it.
I was trying to communicate that you should always benchmark these for your domain - that is why I didn't post the details of my benchmark. What I can say is that the set sizes were quite large - the benchmark was not done on the *lambda capture* example.
Thanks for your suggestions! &gt;\[U64\] is unportable. You should include \&lt;cstdint\&gt; and use std::uint64\_t instead. I should have documented this :\) C\+\+11 requires unsigned long long as the argument of discard\(\). A bit ugly to spell it out so added an alias and also used it for loop counters, where we don't care about size. We'll replace the latter with size\_t and also add a static\_assert\+numeric\_limits \- thanks.
Does anyone have a clang-format file that roughly is core guidelines+Stroustrup style?
Why would an implicit const give more if a wrong impression than an explicit const?
&gt; Since when was MT fast We include it in comparisons because it is widely used \(\&gt;200K occurrences on Github\). &gt;The formulation of this claim \(...real world...indicate...\) makes me suspicious. It's in contrast to artificial microbenchmarks. No one actually calls generate repeatedly and ignores the result \-\- that's what discard is for. The paper lists several additional reasons why such microbenchmarks are unrealistic: 1. higher cache hit rate 2. more likely to benefit from loop stream decoder 3. lower resource utilization, e.g. load\-store buffers By contrast, shuffling and sampling are used in actual programs, so we measure those. &gt;Exactly, so is seems a good idea to provide them to all out\-of\-the\-box. Agreed, this was a proof of concept and a complete implementation is on the way. &gt;Mersenne Twister isn't the fastest MT. There's a version that uses SSE2. Has all the same flaws as the original but does run faster. Agreed. We cite it in the paper but point out MT anyway shouldn't be used due to the flaws. &gt;there's no official variant called pcg64\_c32... maybe they meant pcg64\_k32 The \*c\* variants are attempts toward "Enhanced Cryptographic Security". They are briefly described in Section 7.2 of [http://www.pcg\-random.org/pdf/hmc\-cs\-2014\-0905.pdf](http://www.pcg-random.org/pdf/hmc-cs-2014-0905.pdf), but there's no formal analysis nor proof of backtracking resistance. &gt;I assume its not linked because "accompanying publication is pending". But I suspect the "The algorithm has three building blocks" bit of the readme is effectively a summary of it. Yes, the paper is under review. It analyzes performance and proves indistinguishability from random \+ backtracking resistance. &gt;This looks great; languages like Rust have shown that it's reasonable to provide strong randomness by default so the faster that can be the better. Thanks! Yes, we're excited that strong\-by\-default is now feasible. &gt; I always feel a bit weird about RNGs that depend on AES hardware acceleration, though, since platform\-specific hackery is never the nicest requirement. I understand. Fortunately the platform\-specific part is only about 100 LoC, and AES is also in POWER8 and ARMv8. &gt; In addition to that there are apparently versions of Salsa or Chacha that when used with SSE can outperform even AES\-NI. Bit of a stretch \- we permute blocks of 16 bytes, so chacha20 and salsa20 are more like 10\-20 cycles per byte \[[https://bench.cr.yp.to/results\-stream.html](https://bench.cr.yp.to/results-stream.html)\]. Randen is 7x as fast as an OS\-provided generator using chacha20. Reducing rounds can help, but only by \~25&amp;#37; because 15 rounds are required to ensure differential characteristics have probabilities \&lt; 2\^\-128.
Why do you think looking up something in the standard is less work than writing a few lines on Reddit?
Yep CppCoreGuidelines is the way to go for new projects. With naming conventions the idea that you have a choice is a common misbelief. You use what the language uses (or what the existing code uses in legacy projects). Whitespace you solve by picking one of the preexisting styles in clang-format, maybe tweak a few settings if that floats your boat. Note that K&amp;R braces is considered the original C++ style, and Allman braces is mostly a Microsoft dialect. All other other languages try to be consistent, C++ is the odd one out.
&gt; According to David, constexpr will be more powerful and more forgiving in the next standard, there will be constexpr memory allocations, std::vector, constexpr! and many other things. What is this constexpr! feature?
You are aware, that parameters declared without the `&amp;` are copies of the argument passed to the function call and can therefore not be used to alter the original variable regardless of whether they are const or not.
Ugh. No thanks. That's how you get the Windows Situation where each program ends up with incompatible quoting rules etc.
Just a general question. We can pass stuff to macros with -D. Is it possible to initialize a constexpr variable like this?
For user-controllable input, `unordered_foo`'s worst case should *always* be assumed to happen. It's not sane for a generic library routine to assume that it will never be called on pedantic input. There's a reason we condemn sorting algorithms that fail badly on almost-sorted or reverse-sorted inputs.
You can use a macro in the variable definition ? constexpr int value = MY_VALUE; And set MY_VALUE in your compiler's options
You should try doing a CFBS-layout sort instead of a normal sort. The sort shouldn't be any more expensive but the lookups will be much better (assuming your data exceeds the L1 cache size). ... I never finished my STL-interface-compatible adaptor templates, did I.
In Unix, arguments are actually a list. When you're in a shell like bash, it decides that spaces should separate things (with all its complex quoting rules), but in most languages like python or c, the exec system call takes a list
This is how I've found it in the wild in the game cheat dev community: https://github.com/qis/xorstr
Really, it should be a `std::array_view&lt;std:: string_view&gt;&gt;` but for some reason the standard committee can't figure out how to put a pointed and a length in the same struct. I don't think it's a good idea to add a vector of strings because that's just wasted time copying them to the heap. 
yuck. no way to do without macro?
There's [P0784](https://wg21.link/p0784), but that's not been voted in to the standard yet AFAIK.
That's not what he said - he said explicity *immutability*. There's a big difference between `const` and "immutable". Implicit const is *not* a stand-in for implicit *immutability*.
So? big deal. Instead of doing C style initialization, do C++ style initialization. That's not a good reason to use C over C++. 
Common constexpr may be evaluated at runtime or compiletime. Constexpr! enforces the calculations to be performed at compiletime, which is really good for reflection. Unlike constexpr, if the expression did not evaluate at compiletime, constexpr! gives a compiler error. Check the slides here, page 78 and forwards: http://cppconf.ru/talks/day-2/track-a/1.pdf
That's not a pitfall of having a C wrapper, that's a pitfall of object-oriented design not supported by C. If, in C, you also did an object-oriented design, with manual vtables, lots of macros and interfaces ala COM, you'd still have the same problem.
`std::span&lt;&gt;` is already in C++20.
I dislike "tab=8s" (I'm a "tab=4s" guy), but I totally understand the reasoning behind it. If you had a hard rule of "never more than 80 char per line", you can't have complicated nesting and force refactoring in sub-function. This work well with C since it doesn't have complicated construction, but how do you do it in C++ with namespace, classes, lambda constructed in function call, …?
What who said? You said &gt; Having everything const by default gives the wrong impression that it's about immutability when it's not. And I wonder why "Having everything const by default" would give more if a wrong impression than the current situation, where const needs to be declared explicit.
We've used the [Unreal style guide](https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard) on my last couple of projects. It has some good generic advice, but I would suggest ignoring the more pernickety stuff, unless you're actually working with the Unreal Engine, which requires you to follow the unusual naming conventions, so that it can do reflection. 
IIRC their is a way to create a link to any proposal, something like http://www.open-std.org/p/0186. Do you know what this API is, I can't remember it.
I'm a contract videogame programmer, so the answer is: I follow whatever the company guidelines call for. Typically, videogame code doesn't use RTTI or exceptions, and follow CamelCase naming rules, m_ member variables, s_ static variables, and tab=4s. It's remarkably consistent across the industry, for some reason. Maybe because it's a variant on Microsoft coding standards, and most game devs work primarily on Windows? Hard to say. And we're seeing more and more adoption of C++ 11 and up, which is a good thing to see. It makes your code a lot more bulletproof. You'd better have a *very* compelling reason to use raw (owning) pointers or arrays, these days. I use a similar style myself, and Allman-style (aligned) braces, although it doesn't kill me if I have to use K&amp;R in my contract work.
1. Software engineering \(help you make big project clean\). Example book is "Clean Code" by Robert C. Martin. 2. Algorithms and data structures \(help you make your apps perform good\). Example book is "Introduction to Algorithms" by Cormen. 3. Get deep knowladge about your tools \(for example Linux\+GCC\+GDB is pretty standard toolset. Additionaly some nice IDE like Qt Creator, CLion, or Visual Studio for Windows\). This is my advice, I don't want to say it is the only right way.
Not using const because you can circumvent it seems silly. The more constrains the better
In a declaration, const values (including the value of a pointer) guarantee nothing. They are complete lies. #include &lt;iostream&gt; int foo(const int x); int main() { std::cout &lt;&lt; foo(2) &lt;&lt; std::endl; } int foo(/*note: no const*/ int x) { x *= 2; return x; } 
Hi, author here. I will add a gif demo tomorrow. Thanks for the suggestion!
No one said anything about not having const.
There are two issues here: immutability, and const. const != immutability. He's arguing for const by default as a stand in for immutability by default. They are two different things.
I say go for big name ones. They usually have a more established process for dealing with external contributors than small random projects by individual developers. Facebook and Google have a ton of huge projects that are developed by dozens of people, are often deployed in production (so you can have a pretty big impact!) and have all of the properties I mentioned above. I'd roam the github orgs of those two and pick something you like (there's hundreds of repos).
:-o That's great if you like to waste a great deal of your monitor space on whitespace and don't mind if your code is forced off the right edge when you view it on github. I've worked in codebases with 2-space tabs, and that worked for me, though I didn't love it. What possible advantage do 8 space tabs have over 4?
Don't think so. I think of the point of constexpr is to keep things inside the code, available at compile time. Changing a value like that is before compile time and that would be code generation I guess. That's what macros are for
You just said you'd prefer not to have const by default
Const by default is still better than mutable by default.
Yes. Which is not the same as "not using const". You wrote "not using const". "Not using const" and "not const by default" are two completely different ideas.
Yes he did. He said this: &gt; and be explicit with mutability Two sides of the same coin. As for: &gt; Const by default is still better than mutable by default. Please read my original comment. The opposite of mutability is immutability, not `const`.
He said mutability, 
And I said they're two sides of the same coin.
N is one if you visit one variant. vtables don't offer double or higher dispatch, so comparing it to the double or higher visit isn't useful.
Yes he reiterated that const by default is better than mutabable by default, while you still argue that because const is not immutable it's not worth having by default.
&gt; You use what the language uses This depends on the language. Some languages (like Go) have a strictly mandated all-encompassing style that describes absolutely everything. Some languages (like Python) have a canonical style specification, but one that is deliberately somewhat loose. Some languages like C++ have a multiplicity of different style guidelines. In C++, the STL uses underscores, but pretty well every program I ever worked on uses CamelCase for classes at least - so in practice people don't do that. &gt; Whitespace you solve by picking one of the preexisting styles in clang-format, I have been on two C++ projects where we attempted to do this. Both of them failed to come up with a rule that the group liked - I confess that the last one was a couple of years ago but there do not appear to have been huge changes to clang-format in that time. The issue is that clang-format reformats to some canonical form (the exact one depends on the options you give clang-format): throws away all of the existing whitespace and reformats entirely according to its own rules. Unfortunately, people seem to find that undesirable. A classic sticking point is enums. Often individual enums are important, and you just want to have one enumerated type per line, sometimes with a lot of documentation: enum class Results { ok, missingData, notAnAnimal, perhapsAnAnimal, // This handles Aibos and gummy bears, but see issue #389345 // and we need to document a bunch of other stuff here blah blah anotherCondition }; clang-format will not respect this - it will glue multiple enums onto one line and reorganize the comments. Were I embarking on a solo project, I might likely pick some clang-format that didn't totally repulse me and then use it slavishly, just for definiteness - but I really understand the groups' rejection of the choices we had. 
You're the one who still has a problem with me using the word immutability when he didn't have the problem because you don't seem to understand they're both sides of the same coin. I know he still disagreed with me, and I explained myself further in that discussion. You could address those points I used, but you choose to argue over your inability to comprehend.
Was using chromium style, recently moved to LLVM style :\)
&gt; It's not best practice to promise something it's not. It is best practice to have immutable things where possible. But it's not best practice to pretend something (functionally) guarantees you immutability when it can't. I don't fully agree. Default `const` forces you to be to be explicit about wanting to change something by annotating it with `mutable`. It encourages best practice, because a) it's difficult to write code that unwittingly mutates something; and b) it forces you to think hard about interfaces, where to mutate objects and why. Even if `const` is not truly immutable in all cases, the compiler still assists you with reducing mistakes. &gt; Immutability means no changes whatsoever, so it doesn't matter if changes are done atomically or not. An atomically changed object is mutable if it has an observable side-effect. Sure. Although you could consider a `const` an object that is read-only, like memory mapped registers you mentioned earlier. That said, I'd prefer something more descriptive, like a `readonly` for such scenarios. &gt; The whole point of immutability is the knowledge that a value doesn't change. I think the "immutability" definition is sufficient enough (conceptually at least) if a `const` object mutates without visible side-effects. Example: A resource object might manage data that is expensive setup, and lazily constructs its internal state on first `const` access, and caches it for subsequent accesses. As long as the scheme is thread safe, and the internal state is atomically changed, the class will fulfils its `const` criteria from an external observer. 
wg21.link/p0186
&gt;With an union, we would have been directly able to access the red property. Could you show, please? In my example class is some sort of wrapper/adaptor to "native". What we do, is in some sense .... "cast" "native" to our interface . ... Let me "rephrase" my example: class Color { DxColor native; // some DirectX color representation. public: auto red(){ return Property( [&amp;]() -&gt; char { return native.getRed(); } [&amp;](char color){ native.setRGB(color, green(), blue()) }, ); } auto green() return Property( [&amp;]() -&gt; char { return native.getGreen(); } [&amp;](char color){ native.setRGB(red(), color, blue()) }, ); } auto blue() return Property( [&amp;]() -&gt; char { return native.getBlue(); } [&amp;](char color){ native.setRGB(red(), green(), color) }, ); } } I think wrappers is a good example where Properties can be used in a right way. What you fear \- is that call to setter will cause some side\-effects, which will affect results from other getters... Thus \- you don't strictly see "point of encapsulation"... If that is the thing \- I think you just don't have to treat Property as Value/Object, Property IS part of object. Mutating property of object = mutating object itself. *I think const\-correctness should solve this problem, don't it?* And I think, your example with Rational is incorrect. You can't change numerator/denominator separately \- numerator/denominator pair is kinda atomic in this particular object.
That was pretty insightful. Thanks :)
&gt; Default const forces you to be to be explicit about wanting to change something by annotating it with mutable Like I said, I agree with the idea of default immutability. My only issue is the use of the term `const`. It's like when people used the keyword `volatile` to mean `atomic`. It's just the wrong term for it and it leads to the wrong impression. In a immutable-by-default language, the `const` as a keyword wouldn't even exist, but the term would still lead to a misunderstanding. &gt; That said, I'd prefer something more descriptive, like a readonly for such scenarios. Unfortunately, C++ is a language of backwards compatibility, which is why I think the term `const` should stay meaning what it means.
Ah, the horse has bolted long ago. Not expecting C++ to change. I'm just having a whinge on the internet.
Dumb question. range\-v3 changed api several times. For example, current range\-v3 is incompatible with VS2015\-range. Does NanoRange is drop\-in replacement for range\-v3, or not? If yes, will you follow changes in range\-v3 api?
\&gt; auto is crippled auto shouldn't be overused anyway, in my opinion. Sometimes it's entirely obvious what the type is, but it can harm the understandability of the code for other people. E.g. I already consider usage of auto in foreach\-loops \(const auto &amp;\) overuse, when the type is reasonably short.
https://asciinema.org
With the CamelCase, yes it's unfortunate and something we have to live with. I don't think we should throw away all consistency though just because we can't have 100%. If you can't use C++ style for types, At least use C++ style under_score for functions and variables. Regarding clang-format, we mandate it as a git commit hook. Yes it's not perfect but people should just get over themselves. You save so much time by avoiding all style bikeshedding. Besides you can always wrap sections in "clang-format off". 
Yes is suspect it's because it's the Microsoft style. A relic from the time when people made up their own style guides. If C++ was new today I'm absolutely certain the Stroustrup style would be idiomatic style.
No immutability is the opposite and doesn't need to enter inte considerarion at all. The arguement is to strengthen constraints, not having them being the opposite. Obviously immutability would be even better. But const is a decent compromise given what's possible.
I was confused: Auto can be used for most reasonable stuff using the Autosar guidelines \- the forced return types in lambdas are a pet peeve of mine. But to be honest: I like auto in cases where it is obvious or I simply do not care. \(And I prefer auto with trailing return types\). Depends on what is 'important'. But yes, C is still prevalent \- especially in safety relevant &amp; basic software. In current cars C\+\+ is \(mainly?\) used for applications like ADAS etc. This is changing at the moment \- e.g. Autosar has spent a lot of effort by creating [Autosar Adaptive Platform](https://www.autosar.org/standards/adaptive-platform/), which consists of multiple C\+\+ modules \(with C\+\+ APIs\) on top of a POSIX OS. Brake/engine ECUs won't use this platform , but AFAIK many highlevel functionalities will.
&gt; world what is the advantage with pure C vs C-like code in C++ C, having less design paradigms than C++, renders itself to simpler designs (people who would make an over-engineered C++ API, when writing a C API will overcomplicate it to a lesser degree). If you (really really) do write C-like code in C++ the advantage of C is not there though. Also, if you need abstractions that are not present in C, even this advantage goes away. 
Link to the never\-finished\-STL\-interface\-compatible\-adaptor\-templates? :\)
&gt; That's great if you like to waste a great deal of your monitor space on whitespace and don't mind if your code is forced off the right edge when you view it on github. Sounds like you don't get the point of using tabs in such situations. You can't really some someone is using X-length tabs becuse tabs are dependent on the given settings. Eg bitbucket displays tabs as 8 characters but you can set it to 2 for yourself and don't bother about who likes which indent. The core argument about using tabs is to let everyone set preferred length. &gt; I've worked in codebases with 2-space tabs, and that worked for me, though I didn't love it. What possible advantage do 8 space tabs have over 4? In terms of the advantage, 8-length tabs are simply more visible. I don't like K&amp;R brace style, but if the given repo uses tabs, setting them to display as 8 characters helps me with reading nested blocks of code.
I put the lambda body on a separate line for readability. std::algo(cont.begin(), cont.end(), [&amp;](long_named_args...) { /* body ......................................... */ }); 
Something something close to core guidelines but no strict rules (although I would say the project uses too much `auto`). At least where I work reviewers focus on readabiliy and functionality - as long as it looks good will be shipped. In home I'm still experimenting (I think I will try with `m_` since it's good for autocomplete) but already know I like tabs as 8 characters and everything_snake_names.
&gt; I still wonder how owners in C are treated. There's no such concept. Usually, after getting it wrong a few times, people start organizing their APIs so that if you have an API that allocates some resources, you should have a corresponding API that deallocates those resources, at the same level of abstraction. This is just good practice though, not a rule of the language.
 constexpr int value = #include "no_macros_just_a_preprocessor_hack" ;
There is a classic (1996) by John Lakos: Large-Scale C++ Software Design It seems to get some update this summer (July 21st): Large-Scale C++ Volume I: Process and Architecture
This isn't a dumb question at all :) NanoRange isn't a drop-in replacement for Range-V3 (even for the subset of Range-V3 it implements). The algorithms signatures and constraints are basically the same, but concepts emulation is done very differently for example. NanoRange aims to provide an implementation of the Range facilities that will end up in C++20. But at the moment there are lots of proposals in flight and things change after every meeting, so I'll be updating NanoRange to keep track of that. As we get closer to C++20 and things settle down, NanoRange will become more stable. Range-V3 on the other hand isn't quite tracking the ranges proposals as closely at the moment. Now that it has numbered releases and lots and lots of users, I think Eric is (understandably) a bit more cautious about making breaking changes.
JSF - at least we're supposed to before it's delivered. http://www.stroustrup.com/JSF-AV-rules.pdf We have interns working on rules to check for it, now :) I like the Google style personally. Typing out std::string /every time/ is a bit of a pain but, I've gotten used to it. And it's nice to know where everything comes from when you're looking at new code. The same goes for the practice of full paths for the headers. "util.h", "manager.h" you say? Yeah great, thanks. 
Actually, my question (I cited the exact sentence from you that I'm referring to) still stands (I don't know if you have realized you are talking to two different persons)
printf returns number of printed characters. [http://en.cppreference.com/w/cpp/io/c/fprintf](http://en.cppreference.com/w/cpp/io/c/fprintf)
What do you think it should be? Why?
The -D compiler option creates a macro, which you can then use inside another macro or a constexpr. constexpr int value = my_function(MY_VALUE);
&gt; i = printf\("&amp;#37;d",printf\("Hello world linux\\n"\)\); This line is effectively the same as this, because you've got a printf in the middle of a printf: int retVal = printf\("Hello world linux\\n"\)\); // retVal becomes 18 i = printf\("&amp;#37;d", retVal\); // retValis 18, so printf prints out 18 and i becomes 2
I got it thank you.. If there was 400 characters, I would be 3.
Thank u
Write a trivial script to generate a header full of constants.
Everyone is using quicksort though.
Correct!
All standard library implementations I know use introsort for std::sort, wghich has O(n log n) worst case. 
Yes, but not posted. Will in the next couple weeks. If you want to try a visit-like operation that is backed by switch instead of a table, you can use `argot::call(your_lambda, argot::prov::alternative_of(your_std_variant));` at http://github.com/mattcalabrese/argot (requires modern clang). This operation also has a precondition of the variant not being in the valueless by exception state.
I agree with you generally, but may I ask why you're using commas in lieu of quotes?
Because my keyboard is German and it that does that automatically...
I don't want original to be altered, I don't want copy to be altered, "const" in projects I manage means INPUT CONSTANT, always there, tools enforce the policy. I find idiotic to describe in doxygen with some magic markdown "this is input, this is output". Code is written for humans, you know...
Everything is great, but you forgot to move your repo out from github ;\)
The first two objections are trivially handled with `span&lt;string_view&gt;`, or whatever, as many people have pointed out. Same code between C and C++; this is largely irrelevant in the context of `main` as I can't imagine a situation where it would be useful to compile main with both compilers. Anyhow I doubt it's worth adding to the standard simply because there are more important things but I think the right C++ formulation is quite clearly better.
Is a "deep" \(however one would define that\) knowledge of C\+\+ important for getting a job in that space after University in your opinion? I can use C\+\+ and some of its modern features \(not just C with classes.. although mostly that\) but dealing with template metaprogramming and stuff like that is highly annoying in my opinion and I'd rather deal with general CS/Math/Engineering topics in the mean time.
On MacOS the auto completion with Clang works fine, it’s a bit of a shame that most of my work is done in Windows where it is unusable like the one of the comments said. 
From what I hear: No. First of there is enough work in C development. Additionally I think there aren't nearly enough experienced Embedded C++ developers around (at least in Germany) for them to be picky, so I guess it's more important to be willing to learn. But: at least where I work there is no way that you can avoid templates (e.g. polymorphism without virtuals). Additionally, because of safety requirements there are no OSS libraries (and thus a lot of reinventing the wheel). Exceptions (and with it the STLs containers) are a no go... The most annoying things about it are process things (for SPICE, ISO etc.) and error messages... For me it is a lot of fun, but sometimes I feel more like a STL developer than embedded engineer. 
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8orqgg/need_help_with_a_program/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I would characterize it as a feature mismatch between languages. You lose really foundational things like RAII which relies on classes and templates but is really a thing in itself. You have to map function overloads out to different names or not use overloading. You have to wrap container access. You can't expose templates directly. You have to provide ways to destroy things that were created with new or avoid using new on things externally visible. You could certainly refuse to use all these parts of C++, but at some point, why aren't you just writing your code in C? C++ doesn't make writing and maintaining a library any easier if you can't use most of its features. My point is that once you give in and start using C++ features in the inner workings of your library there is always going to be tension trying to push those C++ workings to be externally visible as a clunky C wrapper.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8os1ts/c_beginner_and_udemy/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; sometimes I feel more like a STL developer than embedded engineer. I'm not the person you were replying to, but just out of curiosity, is that a good thing or a bad thing? ;-) Or neither?
With union, according to your **previous** example, it could be done with: #include &lt;iostream&gt; #include &lt;cstdint&gt; union Color { std::uint32_t raw = 0; #if ! defined(__BYTE_ORDER__) # error "Sorry!" #elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ struct { uint8_t blue, green, red, dummy__; }; #else struct { uint8_t dummy__, red, green, blue; }; #endif }; int main() { Color c; c.red = 255; std::cout &lt;&lt; std::hex &lt;&lt; c.raw &lt;&lt; '\n'; c.raw = 0x00ff8020; std::cout &lt;&lt; "red:" &lt;&lt; static_cast&lt;int&gt;(c.red) &lt;&lt; '\n'; std::cout &lt;&lt; "green:" &lt;&lt; static_cast&lt;int&gt;(c.green) &lt;&lt; '\n'; std::cout &lt;&lt; "blue:" &lt;&lt; static_cast&lt;int&gt;(c.blue) &lt;&lt; '\n'; } &gt; And I think, your example with Rational is incorrect. You can't change numerator/denominator separately - numerator/denominator pair is kinda atomic in this particular object. Indeed. It's definitively incorrect. While professional implementations of `Rational`/`Fraction` don't fall in the trap, typical implementations of Average Joe/Student usually do.
Is his name Bjarne? No. Then why should anyone care who he/she is?
Yeah) Could you show a good place for that?)
You know that was a joke, right? ;)
Sure, nice joke
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8ocpme/about_overloaded_functions/e05rx53/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
[OP] &gt; 2 overloaded functions one with 2 parameters and the other with 3 parameters and a default value [You] &gt; No one because such code will not compile. #include &lt;stdio.h&gt; void foo(int, int) { puts("ints"); } void foo(double, double, double = 0.0) { puts("doubles"); } int main() { foo(0, 0); } (Of course, it's ambiguous if the parameters have the same types.)
Agreed. I had to stop using Qt Creator only because of that. And well, CMake project generation does not work well on my setup, but there were ways around that.
If you know where it is, it's very easy to find. When I have to find things I've read in the standard it's usually a very quick endeavor as I know approximately where it's located and can fish it out quickly from there. Sometimes I even remember some of the phrases so a ctrl + f will find it nearly instantaneously. That is also besides the point: we already have seen information on here that is not correct, so I would like to see someone who claims they know what it is to find it as they know where it will be. I've seen too many people claim things that are "in the standard" and it turns out they are wrong... and I'm tired of constantly trying to battle disinfo and anything that makes my life easier is a welcome thing. This language is already ridiculous and bloated as is, _anything_ that saves time on learning it is worth it in my opinion.
Where does doxygen come into it? You claimed that without const, the function could alter the parameters passed to it which is simply not true when you pass by value. Hence value parameters are always input parameters regardless of if they are const qualified or not. This is not "by convention" or has to be annotated, but it is just how the language works. I don't know why this is so hard for you to understand - are you coming from another programming language that handles things differently?
Why don't you use built-in code model? It's rather fast.
GitLab.
Is there any clean way to avoid having to repeat the argument types when creating the config class? Potentially some macro magic? Did you evaluate tge tradeoff there? ^(^(God, we need reflection.))
Nah doesn't work for me either. Opening files is sometimes excrutiatingly painful. The project is very big, but it is ridiculous how long it takes to parse a file. I don't know man, I don't see the difference between using clang code model and not using it, it is pretty slow every now and then.
It was a bug, now fixed. Thanks for the feedback!
It depends (of course :-D). On the one hand it is fun and challenging to implement things like variant, optional &amp; others and you learn a lot about the language etc. On the other hand it can be tiring (and time consuming) if you just want to use a variant and have to write it from scratch (including things like specifications, 100% Coverage (MCDC). 
Good question. I'm still thinking about such macro magic. It would be cool to have something like this: `RACONFIG_BEGIN(my_config)` `// options go here` `RACONFIG_END()` I believe Boost.Preprocessor can help to achieve that.
How does it compares to KDevelop's Clang highlight/completion?
Have you compared the result to any of the dozen other program option libraries out there?
The working python version: https://github.com/o11c/python-uni/blob/master/uni/mem/_cfbs.py (and other nearby files to use it) Probably easier to port directly than make it STL-compatible, for one-shot purposes. &lt;rant&gt; I've pulled out the C++, but after a computer migration I no longer have all the compiler versions installed to test quirks against. Plus, I chose to stick with Debian stable this time since KDE is always buggy otherwise, but that means you can't really upgrade system GCC, so I'm stuck on 6-or-earlier. At least the GCC 5 painful migration is over (I can't imagine what it's like on platforms where *every* compiler release requires a migration). I've forgotten how masochistic it is to work this deep in C++. I mean, at least it (mostly) makes *using* the algorithms easy, but ... I keep wanting to work on my polyglot language so I can just write what I *mean* and automatically produce C++ and other languages natural code, but ... &lt;/rant&gt;
constexpr! functions from [P1073R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1073r0.html).
This is just one uneducated impression, but the last time I did a comparison KDevelop's Clang based completion was considerably faster than Qt Creator's, but at the expense of KDevelop spending a ridiculous amount of time and CPU doing an initial project wide parse.
 Nice one :\-D 
In C I'd agree but in C++ with nested lambdas, classes, namespaces, etc it just gets a little absurd. When coding in Scala indenting at 2 spaces makes for the same reason pushed to the extreme.
I'm thinking that if you need a wrapper for a program options library, then there's something seriously going wrong somewhere. I like boost program\_options \(as it is\), I just wish it was standalone/header\-only. I've tried the most famous header\-only modern C\+\+ alternatives and none was able to cover my use cases, there's always something missing with regards to multi\-arguments, parsing, etc., that program\_options is able to do but no other library could do.
This is now required by the Standard. If you see quicksort used to implement \`std::sort\` somewhere, please file a bug against the library in question.
Cool, I might try to find a student to port it to C++ next year :)
There are a ton of people who contribute heavily to C\+\+ and whose opinions we should care about. Herb Sutter, Stephen T. Lavavej, Eric Niebler, Howard Hinnant, Chandler Carruth, Sean Parent, among others. While Andre Weissflog has contributed to some very useful projects, his views on modern C\+\+ are out\-of\-line with a lot of the C\+\+ community. He even goes so far as to say C isn't so bad when you don't use it in ways C is typically used (like not having pointers be the owners of memory). He does come off as a hipster despite his long experience; he's not making substantive arguments when he discounts (without evidence or argument) the work that has been put into improving C\+\+ over the last decade.
Why would an initial parse be useful for single-file clang-based completion? I'm very curious where the difference in speed between KDevelop and QtCreator's clang code models might come from (or even between mac/win versions of QtCreator).
Maybe the author has only used really old versions of MSVC, which have that as an extension?
at least on win for me any file access takes *age*. Running CMake on a hello world takes a good 7-8 seconds, on a NVMe SSD without encryption and active virus protection ; it's incomparably fast on linux on the same machine / SSD.
I just want to delegate some routine job to the compiler. Consider the case when you have several projects (microservices). Each project depends on about 20 parameters. Parameters come from command line and file. Parameters from file and command line have different names (i.e. "cass\-threads" and "cassandra.threads" to group into sections). So using ProgramOptions directly you have to create at least 2 options\_description instances and to register options in each of them. Some options require verifiers thus you'll have to register them twice too. And so on... for each project... Also there are no support for set/unordered\_set out of the box. So I've come to this solution.
`auto` is a keyword. I don't have to know how it was declared in some header file somewhere to know whether my lambda is generic or not. (leaving out the possibility of `#define something auto`, but in that case the author should be taken behind a shed and shot)
Never heard of him.
I always thought that was the only way to go to make things simple and clear and not scare away everyone. Client/business code is not where the complexity is.
Gradle. :-) 
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8onaup/need_some_c_advice_moving_forward/e06a7bk/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Quite often, Windows Defender can be the culprit. You could check that. There's ways of adding exceptions to Windows Defender (though not ideal obviously, but Microsoft kind of fucked this up, Defender is always checking every file access etc.)
I've been working on it for the last couple hours, and realizing one important lack: I never actually *figured out* how to implement the RandomAccessIterator part, and BidirectionalIterator isn't really enough for an adaptor. The missing functions are equivalent to: def to_logical_index(pi, sz): return make_order(range(sz))[pi] def to_physical_index(li, sz): return list(iter_forward(sz))[li] except without that terrible complexity. `to_logical_index` isn't necessarily needed, but it gives more flexibility for internal layout (especially for `ptrdiff_t operator - (cfbs_adaptor, cfbs_adaptor)`. I can write maintainable code easily, but my theoretical background is weaker than I'd like. 
Very nice
This is exactly why I push for the adjective syntax. Just the concept as parameter type placeholder is ambiguous when reading, you have to check if the name is a concept or not. The adjective syntax forces `func(Concept auto)`. Or `func(auto Concept)`, There's the `auto` keyword that denotes that it's not a fixed type, just like`auto`, but constrained by `Concept`.
Funny that you mention this as I have had the opposite experience. It seems like the animations make the completion popup slower than it needs to be, and it doesen't always trigger on special symbols like ., -&gt;, :: etc. That semantic highlighting is nice though.
C++ was like a box of chocolates, you never know what you're gonna get.
Given the textual nature of C++ headers (and #includes) a single-file parse might actually need the "entire project", depending on whether you want to be really conformant. The original (now, "old") code model of Qt Created used a few tricks in order to be efficient. I wrote an article about it a while back, when I was the C++ maintainer. Surprisingly, I still found it here: https://web.archive.org/web/20130925144221/http://ltcmelo.com/blog/2013/03/17/a-bit-about-qt-creators-c-model/
Whatever the code I'm working on uses.
I don't really see any reason for there to be a singleton at all; even if it's your preference the library shouldn't assume this because it's trivial to turn a regular type into a singleton but you can't un-singleton something. I also don't see any reason to have getters instead of just direct field access. `cfg.get&lt;option::port&gt;()` is very verbose compared to `cfg.port`. IMHO, a much better interface MAKE_CONFIG_STRUCT(MyConfig, (host, std::string, "localhost", "Listening host"), (port, unsigned short, 80, "Listening port")) Then, simply: auto my_config = parse&lt;MyConfig&gt;(argc, argv); std::cerr &lt;&lt; my_config. No singletons, setters, or getters. Just define a POD type that can automatically construct itself from argc and argv. 
Does it happen with other projects? You might be hitting some pathological case.
&gt;&gt;c++11 Consider yourself lucky.
This is the main problem i found with the new decidedly not uniform initialisation syntax - it adds yet another way to initialise stuff that seems to only be appropriate in some situations with all sorts of little quirks to it that make it not universally applicable As far as I can tell, its basically good for initialising container types like std::vector and map, and that's about it I'm not a c++ expert by any stretch though so maybe i'm totally missing something
Turned out to be ridiculously simple, as I kind of expected. The trick is to count the "holes" in the complete tree and adjust the logical index, then use: def to_physical_index_complete(li, sz): assert ((sz + 1) &amp; sz) == 0, 'sz must be one-less-than a power-of-2' assert 0 &lt;= li &lt; sz while li &amp; 1: li &gt;&gt;= 1 sz &gt;&gt;= 1 return (sz&gt;&gt;1) + (li&gt;&gt;1) Also, I just realized that I refactored a copy of the container code out to a non-project-specific repo: https://github.com/o11c/python-o11c/blob/master/o11c/containers/_cfbs.py Haven't pushed yet since I want to dedup the "left" and "right" functions (is there a word for "successor or predecessor"? perhaps `adcessor`?), and also finish the `to_logical_index` function. I'm probably going to give up on the C++ port again for a while ... but at least the Python code has shaped-up enough to prove that it's *possible*.
There are reasons to prefer brace initialization in general. The only place I’m aware of that it’s not always possible is that a std::initializer_list constructor is always preferred, so you need parens if there is ambiguity, and this can be tricky in a template. Braced initialization prevents narrowing conversions so you get some additional type safety. It also prevents the [most vexing parse](https://en.wikipedia.org/wiki/Most_vexing_parse). Of course you also get nice collection literals as you mentioned. 
&gt; its basically good for initialising container types like std::vector and map Even then, it inhibits move semantics.
While it is nice to have more precise code model in QtCreator Clang code model excruciatingly slow on larger projects which I generally prefer IDEs for browsing complex data structures in 10s of thousands line projects. In one robotics project I tried to load project on QtCreator. Project had numerous dependencies Cuda, OpenCV, ROS etc. most of the time autocompletion with clang was just a burden. I was using Creator that came with Qt 5.9 but it was unbearably slow. I could write faster even quickly lookup doxygen docs while waiting clang to complete parsing. The old code model is fast and helpful when using plain functions but it sucks on template types it can't even autocomplete items stored in std::vector while using bracket operators. I tried, KDevelop 4.8 as an clang-free alternative which was nice and could do templates but it was way harder to configure and unstable. I am still searching lightweight (that's why I don't prefer Eclipse and Clion that are both startup time and configuration nightmares) but powerful IDE which can do autocompletes as well as Visual Studio. QtCreator is very close but they have to improve their code model strategy. Interfacing with clang is nice but spawning an external process and communicating with it might not be the best way to autocomplete. Introducing it to a 20kloc project just blows it apart. Instead of leaving old code model I wish they have improved and augmented it with clang.
Can you overload using constexpr! to specify a compile-time execution path and a runtime execution path?
FWIW the style I've converged on is "use brace initialization in almost all cases, and avoid ever writing \`std::initializer\_list\` constructors"
... and, pushed (also realized I had a working DenseMap implementation already committed but not pushed for ages). BUT I just realized that it's nonsensical to use existing STL algorithms through an adapted CFBS, since CFBS splits exactly on a power of 2, whereas normal binary search divides the range in half. (Obviously, they occasionally line up, but for data sets large enough to be interesting, the probability is vanishingly small). Probably for the best for clarity's sake anyway. Obviously ports of the `{,multi}{map,set}` implementations are still sensible.
Oh, look, I found a parrot. How exciting
Why? There hasn't been anything I couldn't do in C, from kernel development to high performance communication libraries. The C\+\+ runtime and a lot of the existing libraries make performance reproducibility hard, and there are C libraries for almost everything, from RB Trees to hash maps.
C++ lives on a system with a C interface, so string view has a very big chance of being copied and allocation being beeded.
It would be nice if there was a way to get the assembler output... *for a single file* in my CMake build. I usually have to turn it on for the whole project.
avoid ever writing \`std::initializer\_list\` constructors" Could you allobrate on why its not a good idea to write those constructors for your own types?
&gt; Braced initialization prevents narrowing conversions so you get some additional type safety. One of my coworkers who is on the committee pointed out [these examples](https://godbolt.org/g/bBTJCV) to me the other day. I'm not sure if everyone would agree that's *type safety* exactly, but I'd call it such. And to be frank, if I'm going to pick a rule of thumb, I'd rather have those examples fail to compile and allow narrowing conversions. (He did say this is an area the committee is working on improving, though what that means I don't know. I suggested pulling from Unicode's reservoir of delimiters, perhaps `S s«1, 2»;`)
Yes, and call it a struct instead.
We'll have to see how it pans out. Will they remove xbox-emulator code? How about politically (f.e. Chinese) tainted content.
They're insanely greedy and often disallow you from using braces to call other constructors.
Does const affect code-generation?
In fact we are augmenting it with clang because clang can't yet replace everything old code model offers. External process was a necessary evil unfortunately. Clang is still not stable enough to keep it in the same process with Qt Creator.
as far as naming goes, how about: Alias → “pointer\-like type” → “zeiger” Strong Alias → Alias → “reference\-like type” → T&amp; Weak Alias → Reference → “pointer\-like type” → T\* I suggest the name strong alias since everything is implicit. It makes a stronger statement about the alias (zeiger) in that there is no differentiation between accessing/creating the object or the alias. Think of it like nicknames to people. If a nickname is strong enough (Ronaldinho) it stands by itself, you know its ( Ronaldinho Gaúcho ). If its weak, you need more context (Ronaldo from Brazil or Ronaldo from Portugal). You explicitly state which one you point to. (I may or may not have contracted World Cup fever) 
For a vector its pretty nice to have an initializer\_list constructor i would argue, same for std::set or similar classes. Would you argue that even those perks are not worth the trouble?
&gt; As far as I can tell, its basically good for initialising container types like std::vector and map, and that's about it That's especially a situation where I avoid them. I've shoot myself in the foot too many times. Just recently, I did this: class MyType { public: MyType(double val) : mVal(val) {} private: double mVal; }; And then somewhere else I was trying to do in-class initialization of a vector using the `vector( size_type count, const T&amp; value)` ctor like this: struct MyTypeHolder { vector&lt;MyType&gt; vec{ 6, MyType(0.6)}; }; The size of the vector became 2. It casts the integer (6) to double, then constructs a `MyType`, then used `vector( std::initializer_list&lt;T&gt; init)`. I don't understand why, and gave up trying to. Also, since it's in-class initialization, for whatever reason I can't use parentheses there, which would have given the correct result. What's even more worrying is that making `MyType`'s ctor `explicit`, does result in a vector with the expected size of 6. Which means a small change like that could silently break other pieces of code. So IMHO, initialization is completely messed up. 
I love being able to easily initialize containers with a list of elements, as well as other clever uses like a JSON object. However, I don't think making it the same syntax used to call other constructors was a good choice. It's hard to say whether a plain list constructor is worth the trouble to me or if I'd consider an alternate best-we've-got constructor like `vector foo = list_of(1, 4, 5);` or `vector foo{from_list, 1, 4, 5};`.
Maybe there should be some efforts generally in speeding-up clang itself ?
There are - it was much worse before :) And more performance improvements are coming (for example completion when '.' needs to be replaced by '-&gt;' will be much faster soon)
No, please, no narrowing
You talk to yourself? :)
Maybe because of brace elision?
EWG just voted on Monday to not treat such types as aggregates. Even without the change, I wouldn't find the examples persuasive. It's only triggered in corner cases (all-public data members and all constructors are either deleted or defaulted) that are highly unlikely to be present in anything other than intentionally constructed "WTF" snippets.
I'm not arguing C vs C++ here because your points are all valid in that regard; it's your old-school C++ vs modern C++ view that needs correction. The line I am referring to was in a bullet point about *C++* being a language in your toolkit. If you aren't going to modernise your knowledge of C++ then you may as well remove C++ from your 'toolkit' because as you seem aware, modern C++ is vastly different to C++03 and prior. It's like the Python 2 vs Python 3 debate, except in this analogy no-one is using C++03 any more and modern C++ can actually solve problems that were either unsolvable previously or required vast amounts of effort. Modern C++ is effectively a new language with new paradigms and design principles.
But you can't have your options spread in other files (e.g. you are forcing them to be together). 
How exciting! How exciting!
In the post they mentioned they are looking at using clangd - that will solve the spawning issue.
Is it really harder to just use a variadic constructor? 
&gt; Maybe because of brace elision? I don't know, seems like it only applies when using double braces? &gt; Making the constructor explicit disables automatic conversion, so the overload resolution works "correctly". Yes indeed. So adding `explicit` should result in a compiler error since it can't do an implicit construction, not a differently sized vector. 
What about this std::vector&lt;int&gt; foo{1, 2}; // braced initialisation std::vector&lt;int&gt; foo{{1, 2}}; // initialiser list 
I use braces, when I logically want to store the values inside the data structure (e.g. arrays, pods math vectors, smart pointers) and parentheses if the constructor is more about parametrizing the data structure (initial size, web address to connect to). That seems the most natural (maybe even intended) way to use it.
Why would you want to use braces to call other constructors in the first place? The only reason to write initializater_list constructors in the first place is usually because you want your type to behave like an array / container. If that is the case, then why would you expect `my_array a{1,2}` to do anything but fill a with the values 1,2?
Why would you want to use braces to call other constructors in the first place? The only reason to write initializater_list constructors in the first place is usually because you want your type to behave like an array / container. If that is the case, then why would you expect `my_array a{1,2}` to do anything but fill a with the values 1,2?
It's really interesting to see different experiences for Clang Code Model. We have been using it on fairly large codebase (10k files, 1mln lines of code) and it performs really well, faster than CLion or vscode+cquery. This is all on MacOS, though.
No, visual studio adds stupid warnings for perfectly safe functions.
Yes, and the effect is huge. Watch this: https://youtu.be/zBkNBP00wJE?t=26m55s
\_CRT\_SECURE\_NO\_WARNINGS is not a stupid warning, and most standard C functions aren't perfectly safe, as you never know when someone will call them with a buffer overflow.
&gt; What's even more worrying is that making MyType's ctor explicit I may not be up to date with c++ however I was under the impression that single argument constructors should be almost always explicit. 
I would suggest std::vector&lt;int&gt; foo{1, 2}; // braced initialisation std::vector&lt;int&gt; foo = {1, 2}; // initializer list Braces without `=` always call a constructor, brace after `=` always use initializer list.
It is, a warning is shown even when using strcpy (IIRC) in a safe manner just because you are using it. There is no reasons a compiler should emit a warning on a standard C function. It could be eventually be shown when using deprecated ones like `gets`.
How about reporting the warning upstream? If the project is still active, they might have interest in fixing the warnings.
I would compare the modern C++ also to a box of chocolates. With size of 100 by 100 where you don't know what to choose. 
 \_CRT\_SECURE\_NO\_WARNINGS is not a warning, it's a setting that controls whether certain warnings are issed or not. Most standard C functions are perfectly safe. A few are not, have been considered deprecated by most programmers for decades and cause these warnings. A few are "almost always used in a safe manner", but also cause this warning. Take \`snprintf\` for example. In 99.99&amp;#37; of cases, the \`count\` parameter will contain the size of the buffer being passed in, but apparently that's not "secure" so \`sprintf\_s\` was created where, in those 99.99&amp;#37; of cases, you're just going to pass in the size twice. Then there's nonsense like \`strerror\_s\` which is not only *less* secure than \`strerror\` (it's possible to pass in a short buffer and lie about its length), it's also far slower (it copies the string, rather than just returning a pointer to a fixed table; the standard says that the returned string cannot be modified, the fact that it's not declared \`const\` is historical cruft) and for bonus redunancy, it's exactly equivelent to the pre\-existing standard (not supported by MS) \`strerror\_r\` except that the arguments are in a different order...
I was going along with the whole uniform initialization thing. I don't mind the braces if they're actually uniform, but they're not.
As far as I remember, this can run into its own corner cases, unfortunately.
You'd still run into things like `vector foo(5, 2); // Is it a list or a size and value?` I can't speak on how big an issue this would be in general even if vector had its constructors adjusted.
Changing a cross-platform library to use non-portable functions instead of those in the standard is a non-starter; they might have interest in _suppressing_ the warnings, but there's nothing to "fix" here.
How does that work to create a temporary on the fly?
No. The safer function variants provided by Visual C++ are not portable.
It's not terribly difficult to accomodate cases like that though, you could write a *vector_range_t* or something POD type for the "create a vector of x size with values y" ctor, or you could just write your variadic ctor like *vec(const value_type&amp; t1, const value_type&amp; t2, const value_type&amp; t3, const value_type&amp;... rest)* 
I started doubting myself, I always assumed it did, but the article sort of implies it doesn't matter. I that would have been the case I'd rather not use const (I religiously do though).
Adding `explicit` means the implicit conversion for `MyType` is not available, but the `vector` still has the `size, fill` constructor.
The point is that you use all these features internally, and only expose the input/output functions.
No use OCaml instead 
Rust has some tasty shinies for you. Personally, I would really like to get fabric-like constructor preventing ambiguity. I.e. auto vec = std::vector&lt;int&gt;::from_list(1, 2, 3); //[1, 2, 3] auto vec1 = std::vector&lt;int&gt;::x_of_y(3, 2); //[2, 2, 2]
&gt; You could check that sorry, this was not clear, that's what I meant when I said "without active virus protection"
Interesting, this is a functionality I've been actually missing from constexpr. It sounds really useful and easy/low-impact to add to C++.
I'm not surprised. "My" syntax seems rather obbvious and I'm definitely not the first one who thought of it. I was just hoping someone would say what's the corner case here.
Good point!
half of it is needed, the other half is nomenclature
&gt;With union, according to your **previous** example, it could be done with: What **is** that thing? Anonymous union? Union\-like class? What about dummy? I think, its obvious that properties fit much better here, then whatever is that union. &gt;While professional implementations of Rational/Fraction don't fall in the trap... I think GMP, actually allow you to change numerator / denumerator. See [http://www.ontko.com/pub/rayo/gmp/gmp\_7.html](http://www.ontko.com/pub/rayo/gmp/gmp_7.html) **mpq\_set\_num** / **mpq\_set\_den** .
Awesome! I’ve been looking for a new std::variant (for MAC/iOS apps) to replace my home grown implementation. Using BSL makes it easy to get it into production- thanks!
KDevelop has the best highlighting, hands down. I've mostly settled on Qt Creator now, but I've switched back and forth between it and KDevelop several time. Whichever I'm on, I'm always missing something from the other.
One example comes to mind is this: struct Point { int x, y; }; struct Foo { Foo(initializer_list&lt;int&gt;); Foo(Point); }; Foo f{{1, 2}}; // Point or list? It's hard to turn that into something realistic on the spot.
&gt; As of this writing, Visual Studio 2017 has no header named either `&lt;experimental/memory_resource&gt;` or `&lt;memory_resource&gt;`. IIRC it was added in VS2017.6, in March.
Nice to hear it's used!
`lexical_cast`'s fast-path is for `CharT const*`+`std::size_t`, so if you call a different overload the number of instructions cuts in about half: https://godbolt.org/g/fC7u9B I think most of the remaining bloat is for fallback code that will never be executed given your input types. :-[
There are compiler warnings for that
It depends what you call "perfectly safe" localtime is not safe in multithreaded code. So we need warning to use localtime_s on windows and localtime_r on linux ;)
I don't have any warning on Linux with both clang/gcc and `-Wall -Wextra -std=c11` using localtime in C.
My first thought was "obviously an initialiser list", but a moment later I realised your point.
Correct. My VS15.7 definitely has it.
 std::array&lt;char, 5&gt; str{"12345"}; int result; std::from_chars(str.data(), str.data()+str.size(), result); print(result); Is the quickest, but it seems to require newest gcc
I am all for constructive criticism and conversation. My comment was directly in response to the derisive nature of the comment I replied to. Calling somebody a "hipster" etc in a derisive way amounts to a personal attack on someones character instead of discussing what you don't agree with in the post.
Okay. Specifically what problem can "modern C++" solve that C can't?
"12345" was just an example. Clearly the strings can have varying length.
`std::array` as input was also just an example – `from_chars`
I added link to the documentation.
Is that going to be faster than just wrapping localtime in a mutex? 
FYI: Joaquín M López Muñoz wrote [several blog posts](http://bannalia.blogspot.com/2015/06/cache-friendly-binary-search.html) on this topic in 2015, including a prototype [implementation](https://github.com/joaquintides/bannalia/blob/master/levelorder_vector.cpp) 
Is `memory_resource` essentially a typeless version of `allocator`? I've not kept up.
Maybe: [https://www.boost.org/doc/libs/1\_67\_0/libs/convert/doc/html/index.html](https://www.boost.org/doc/libs/1_67_0/libs/convert/doc/html/index.html)
You can use non-brace initialization in that position with some thought: vector&lt;MyType&gt; vec = vector&lt;MyType&gt;(6, MyType(0.6)); (This is technically copy-initialization (whereas your example with braces is direct-initialization), but the semantics are the same when you are initializing with a prvalue expression of the right type.)
Constructors should have names. Constructor overloading is the root problem here.
I'd agree that this constructor in particular should have more naming info attached. In many other cases, I find constructors to be descriptive with no additional naming info taking up space.
\&gt; Could you allobrate on why its not a good idea to write those constructors for your own types? My main beef with \`std::initializer\_list\` is that: 1. It makes it hard to use brace\-list initialization in generic code, because you try to invoke a constructor, and then overload resolution fails because the standard says that the compiler must try to match it with \`std::initializer\_list\` if such a constructor is present. There's no good way to work around in that situation other than deleting the \`std::initializer\_list\`. For a concrete code example, see here: [https://github.com/cbeck88/lua\-primer/blob/master/include/primer/userdata.hpp#L39](https://github.com/cbeck88/lua-primer/blob/master/include/primer/userdata.hpp#L39) I'm trying to allocate the user's type at memory owned by lua using perfect forwarding. But if the user\-type has an initializer\_list constructor, it's typically not going to work because I'm using brace list initialization. OTOH, I can't change this to use paren\-based initialization because then all the times when I use a struct as userdata aren't going to compile. I guess with years more experience, the answer here should actually be that I use SFINAE with \`std::is\_aggregate\` and use brace list initialization in that case, and paren initialization otherwise? Idk I didn't think of that at the time. 2. The \`std::initializer\_list\` doesn't let me find the \*length\* of the initializer list at compile time, even though it is a compile time constant. This really sucks and in some cases it turns compile\-time errors into run\-time errors. For instance, what if your container has a compile\-time fixed maximum size? We had this exact issue in the "frozen" library: [https://github.com/serge\-sans\-paille/frozen/pull/41](https://github.com/serge-sans-paille/frozen/pull/41) The lib was written with all of the containers having \`std::initializer\_list\&lt;T\&gt;\` constructors, but this means that if the user accidentally passes too many elements, it's a run\-time error instead of compile\-time. If we just used \`const T (&amp;)\[N\]\` instead of \`std::initializer\_list\&lt;T\&gt;\` then we can static assert that \`N\` is not too large. So there's approximately zero value add from \`std::initializer\_list\`, it's just turning compile\-time errors into run\-time errors, for the benefit of one less set of braces... IMO always use \`const T (&amp;)\[N\]\` instead of \`std::initializer\_list\&lt;T\&gt;\` so that you can get the size of the list at compile\-time.
There are even stronger reasons to avoid braced initialization outside of the situations where it's required: https://abseil.io/tips/88
``` class Foo { static Foo constructor_with_name(args...); }; ```
What makes BSL easier than MIT license?
That's what you get when you incrementally transform C into a modern programming language... while keeping it an almost-compliant C implementation all that time. I'm not sure how it could all be reworked without introducing some radically new syntax, and deprecating some common features of the old syntax.
There's no temporary, other than the initializer list, of course. The initializer list would be assured to exist while the initialization is performed - that's how it goes in all other cases, too.
Yes, I'm somewhat cautious about making changes, but that's not why range-v3 is a bit behind the curve. I just don't have much time to keep range-v3 abreast of all the developments on the Committee. I am sprinting to get Ranges into C++20, sprinting to find the basis operations of futures and executors, and sprinting to design a reactive streams library library on top of ranges and coroutines. I'm booked.
Thank you so much.
Can you explain this in more detail? Why would those types not be aggregates, what distinction did they vote in?
The paper to make parens do aggregate initialization is actually progressing in EWG. That should mainly address the generic side of things. Funny how the most uniform initialization we've got will be with parens then. The `size` thing isn't ideal, but isn't as bad as you make it sound. constexpr `size` was added in C++14, so in a constexpr context, an assert on the size will trigger a compile-time error. In addition, `assert` is constexpr-compatible in C++14. One additional gripe that many people do have with `initializer_list` is that it doesn't support moving the elements.
&gt; I don't understand why, and gave up trying to. List constructors are extremely greedy. If they can be called, expect them to be called. In your case, it can be called because the arguments you gave were compatible with `MyType`.
It's not a defect (at least, it's by design). C++ has way fewer arbitrary restrictions that other languages when it comes to this sort of thing. It's part of the beauty of the language. It generally leaves stuff like this up to the programmer, so if you don't want private members to become public, keep them in the private sector :)
if anyone is interested, one of the project I'm working on is slowly but surely accumulating a swathe of useful third-party libs (mostly containers and MPL) such as these: https://github.com/OSSIA/libossia/tree/master/3rdparty ; I am thinking more and more of bundling them in some single repo / namespace and ensure that they have similar, std-like APIs by sending savage pull requests to their authors.
This is a Very Good Thing™; I would even go so far as to say that in proper application of the template method design pattern, _all_ virtual member functions should be private. At my current employer we don't use dynamic polymorphism enough to necessitate more than "use good taste" as a guideline, but I've worked at multiple places in the past where non-private virtual methods automatically failed code-review.
And what about protected? virtual protected equals to private, then. Why it even allowed?
Sounds interesting \^\^ Will have a closer look at it.
Yeah, u/kylehectic probably meant it in a way to attach his character and I don't mind your reply. My comment was really more aimed at u/TotallyUnspecial saying (a) there are other people besides Bjarne who can give constructive criticism, (b) that Andre is to be respected, and (c) there's some merit to u/kylehectic's criticism (though as you point out u/kylehectic was more an attack than constructive criticism).
I'd go with coding standards of people who mostly know what they're doing, e.g. google's. You don't need to take it all in, of course, those are tweakable rules - but they eliminate most questions. They have spent a *lot* of work making those coding standards work, and be comprehensive.
Why is what allowed? Protected virtual members..?
They are both Turing complete languages. There isn't any computability problem that C\+\+ can solve that C can't. Likewise, there's nothing that C can solve that Fortan can't \-\- or perhaps even scarier: there's nothing that C can solve that JavaScript can't. The problems that modern C\+\+ solves have to do with expressability and abstractions. One great strength of C\+\+ is zero overhead abstractions (powered by really great optimizers). Take a look at \[this video\]([https://www.youtube.com/watch?v=zBkNBP00wJE](https://www.youtube.com/watch?v=zBkNBP00wJE)) for an example. Expressability is often matter of taste so one person's problem may not be a problem for someone else. C\+\+ is pretty darn good at zero\-overhead abstractions though, but this again bleeds a bit into personal opinion since not everyone thinks a certain abstraction will be good. So there are certainly non\-computability problems C\+\+ solves that C can't, but those problems may not be *problems* for everyone.
It's possible that it makes sense for using code that is aware of the concrete class to make use of a function that it does not make sense for users of the base class to use. That said, even if it were required to be private in the subclass, it takes only seconds to write: public: void public_do_run() { do_run(); } anyhow.
I agree, this does seem possible.
Slightly OT but do you happen to know if the version of libc++ in the Xcode 10 beta supports std::variant?
Protected virtual members \- I mean, if they exact as private.
To be clear, a derived class can override a private virtual member but cannot directly invoke it without changing its accessibility level somehow; however, it can do both to a protected virtual member... In any case, it would be a bit arbitrary to disallow something that isn't negatively affecting anything, no?
I haven’t tried it yet, but I sure hope so! When I first started iOS development Xcode had better c++ standards compliance than android studio NDK. Amazingly, vs is now the leader, followed closely by android studio and Xcode has barely budged...
For the record, we document this [on VCBlog](https://blogs.msdn.microsoft.com/vcblog/2018/05/07/announcing-msvc-conforms-to-the-c-standard/) via my table, and [on docs.microsoft.com](https://docs.microsoft.com/en-us/cpp/visual-cpp-language-conformance).
IANAL: as I understand it I don’t need to mention the library in my about box for BSL but MIT does So I can drop it in and go vs needing to track it in the case of MIT. This is especially painful for internal utility libraries that get used in many apps (update the license section of 10 different apps)
&gt; That said, even if it were required to be private in the subclass, it takes only seconds to write: Well, that one could be enforced too. "Allow to call private virtual's only from definition class" \- that would make sense.
No, but we have a separate paper proposing a mechanism for that: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0595r1.html
&gt; "Allow to call private virtual's only from definition class" - that would make sense. Definitely not – non-private virtual members are at the very least a code smell, and I've worked at multiple places in the past where non-private virtuals were immediate code-review flags. I would go so far as to say that to implement the template method design pattern correctly in C++, all virtual members should be private.
I guess I am looking for specifics, not just assertive statements.
So you're saying if a function overrides a private member function, make it uncallable except through a reference to the base class and the v-table? I suspect this would add more confusion than it's worth. But if you wanted to emulate that you could instead of using inheretance have the base class take a function object as a constructor parameter and keep it in a private data member. The subclass would have no way to refer to that data member and so it would be uncallable but one could nonetheless provide different implementations in different subclasses. ... Except of course unless they store their own reference to that function object.
Why the preference for `std::is_constant_evaluated` over something like overloadable `constexpr` as a modifier for arguments? Just curious, as it would make separating the functions logically a bit easier. Do you know if GCC or Clang are currently implementing either of these proposals (either in trunk or in branches)?
Interesting
Clang actually validates that its suggestions allow the code to compile in some contexts, and uses lots of context-sensitive cues to give better suggestions.
Interesting topic. I came across [something similar](https://github.com/BartVandewoestyne/Cpp/blob/master/examples/C%2B%2B98/virtual_functions_changing_access_level.cpp) too. According to this [Stackoverflow post](https://stackoverflow.com/questions/4094534/how-and-why-is-it-possible-to-change-access-level-of-a-member), the Annotated C\+\+ Reference Manual prohibited it originally, but later on the Standard evolved [and it was eventually allowed](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1602.pdf). I am interested in several things regarding this topic: 1. Where exactly in the Annotated C\+\+ Reference manual was it stated that it was prohibited? Can't find the section and don't feel like re\-reading the whole book ;\-) 2. Where in the current C\+\+17 standard is this allowed now? 3. Is changing the access level \*always\* bad practice, or are there use cases (design patterns, idioms,...) where this actually makes sense? Please provide references that explain why it is either \*always\* bad practice, or that explain uses cases where it makes sense.
Good to know, thanks. Out of curiosity, do you know whether this was a performance burden in some left-out contexts?
I observed the same issue back when C++11 was fairly new, and was able to replace all my limited usage of lexical_cast with `std::to_string` and `std::stoi` (and related functions), with the result of much smaller binaries.
Largely because overload resolution is a static process, and the same function call expression may be reached in both constant evaluation and at runtime. We could provide a mechanism to give two implementations for a single function, but providing a bool seems more flexible. I believe there is a GCC implementation for is_constant_evaluated. I don't think constexpr! has been implemented yet.
This is great!!!!
We only perform typo correction after encountering an error, and skip it in SFINAE contexts (at least, AFAIR), so performance isn't a huge concern, but our implementation is actually pretty fast anyway. The left-out contexts are a mix of places where we haven't implemented the "try it and see" approach yet, and places where the effect is nonlocal (we only check that the immediately-enclosing context is valid, which works pretty well when correcting an expression, but doesn't let us prune bad corrections for the type of a variable based on how the variable is used).
Virtual protected is not private, it's a virtual method that is protected. Protected members in base classes can be accessed by inheriting classes. Private methods can only be accessed in the class they are defined. 
* C\+\+ templates make it really easy to create trees, maps, sets (or other data structures) with different specific types for nodes, keys, values, etc.... C will either rely on void\* (which will require extra allocations and casting) or require the use of macros to declare and define the structures and support functions. With these same templates, it's easy to embed one data structure into another \-\- what I mean is to have a map of maps or a set of vectors. With C, that embedding becomes much more difficult to define and deal with. * C\+\+'s RAII makes it really easy to ensure that things like mutexes get released even in the presence of early return statements. The same is true for other resources that need to be freed \-\- file handles, memory, etc.... * C\+\+'s range\-based for is really nice (concise &amp; clear) syntactic sugar for iterating over container elements. * In C\+\+, you can define the underlying integer data type to be associated with an enumeration. * C\+\+ is more strict in its type system than C, allowing more coding errors to be caught at compile time. (No implicit casts from void\*, const values *must* be initialized, among others.) * C\+\+'s constexpr allows for quite complex calculations to occur at compilation time. This means something like the FFTW library could be written entirely in C\+\+ without the need to have OCaml generate the constants. C does have some nice features that C\+\+ is missing like restrict and designated initializers. As is usual, one should evaluate the cost/benefit for a given project. C\+\+ though offers a lot more unique features than C does that I would choose C\+\+ for most projects and use C only where I really need restrict for some optimizations. Even then that code would likely only be in a single file or some library \-\- probably not my entire project. But that is just me; you very well may have a different opinion.
&gt; I suspect this would add more confusion than it's worth. Its not like private virtuals is that obvious thing now... &gt; But if you wanted to emulate that ... I just end up with passkey idiom // Passkey idiom #https://stackoverflow.com/questions/3220009/is-this-key-oriented-access-protection-pattern-a-known-idiom // #https://stackoverflow.com/a/3218920 template &lt;typename T1, typename T2 = int, typename T3 = int&gt; class Access { friend T1; friend T2; friend T3; Access() {} Access(Access const&amp;) {} }; class Base{ private: virtual void run(Access&lt;Base&gt;) = 0; public: void run(){ run({}); } }; class A : public Base { public: // public, private, protected - it doesn't matter you can't access it virtual void run(Access&lt;Base&gt;) override {} }; int main() { A a; a.run(); }
Why do you think it's insanity? Sometimes it does come in useful to increase encapsulation. Remember, the entire point of private/protected/public visibilities is not to change the code that gets compiled, but just act as documentation for the code that cannot be ignored. Also, the override keyword doesn't change accessibility. It just ensures you are overriding a virtual method in the base class (so you don't accidentally not override something due to a spelling mistake or const omission, etc). 
&gt; Its not like private virtuals is that obvious thing now... They should be – the template method design pattern is an established thing... :-]
&gt; require newest gcc (and C++17) Or VS 15.7+
Thank you. That's very informative.
&gt; Remember, the entire point of private/protected/public visibilities is not to change the code that gets compiled, but just act as documentation For me point of visibility \- is to **ENFORCE** object encapsulation, not to document it. Either I misunderstand you. &gt;Also, the override keyword doesn't change accessibility. It just ensures you are overriding a virtual But it could make compile time visibility checks too.
&gt; They should be But can they be? Whats the selling point of private virtual? Does not allow to call it, but require to implement? &gt; the template method design pattern is an established thing. But in C\+\+ it could be violated! Well.. in some sense... Just override private virtual as public \- and that's it \- you can now access implementation thing.
&gt; Private methods can only be accessed in the class they are defined. And I think thats the confusing part for virtuals. Where are they DEFINED? At place where they are literally defined \- in the Base class, or in the implementation definition? As is \- its implementation definition. But is this logically correct?
Instead of fixing their "c++17-compliant" compiler, they're hacking hana. Great.
That’s stretching the truth “While work remains to be done in the compiler, because of the heavy demand for this library from our customers, we have made source workarounds in Boost.Hana for the remaining compiler bugs. This was needed so we can have complete test coverage of all the known issues. We are now building it in our daily testing repertoire to maintain regression-free compiler development while we progress toward achieving one-to-one parity with the public library sources.” Plus they contacted the author of Boost.Hana and has been receptive to the idea in addition to bug reports
It's not a code problem, it's the compiler telling you not to use a standard function and suggesting a vendor-specific alternative to lock you into one platform.
Probably depends on how often multiple threads call the function at the same time.
&gt; C will either rely on void* (which will require extra allocations and casting) or require the use of macros to declare and define the structures and support functions. 1) I don't agree with the "extra allocations" part, but the rest is basically "so what?" I could easily rephrase what you've written to say that C++'s downside is that it relies on templates instead of macros and casting. I don't see how either is easier to understand or more functionally correct. 2) C++'s RAII: Why can't you just use __attribute__((cleanup (scoped))); in C? This lets you specify a function to run when a variable goes out of scope. The Linux Kernel, for example, also has fairly straight-forward abstractions to implement RAII functionality. 3) C++'s range-based for: C has very similar things that you do with macros and can create and iterate over all kinds of recursive data structures. I don't see why this is really needed, either. You can just rely on sentinal values or passing size parameters. Why is this better than the C ways? 4) Enumerations and Ints: I am fairly sure that enumeration values in C are just ints. 5) C++ is more strict in its type system than C: You can use void* and casts in C++. 6)C++'s constexpr: I've seen this argument before and I've actually used it with an N-queens example. And then the person produced a C macro that solved the N-queens problem. 7) Zero-cost abstractions just means that abstraction doesn't impose a cost over the optimal implementation of the task it is abstracting. Effectively that means it's as fast as could be done in C. &gt;for most projects and use C only where I really need restrict for some optimizations. Think of it this way: if you wanted to use C++ to write some code in the Linux kernel, you wouldn't be able to use any of C++'s libraries, because they would all rely on new() which effectively is a malloc--&gt;mmap/sbrk call beneath the hood. These are userspace calls. How could I use any of this boost or STL crap inside a Linux Kernel, for example?
If one function is not thread safe, how is the other function made thread safe? Also what program is calling localtime so much from different threads that it is the bottleneck? Lets really think about this for a moment. 
Are you asking how virtual functions themselves are implemented (the virtual function pointer table) or something else?
Well, localtime_r() is thread safe because it takes a user-supplied struct tm instead of using a single global one like localtime(). If said user gives it the address of a static or global struct... that's on them for misusing it. Plus, of course, it doesn't require a mutex at all, making it more attractive. What if you forget to acquire the lock before using localtime()? What if there *is* lots of contention for the lock? The simpler, lockless alternative is just better because stuff like that becomes a non-issue.
Again, this comes back to a language design issue. Like I said before, c++ avoids arbitrary restrictions where it can (as opposed to C# for example, which piles them on). I can't count the number of times I've had to expose something I didn't want to in C# simply to get around arbitrary restrictions around inheritance. 
.... How is that stretching the truth ? The truth is that for the last year we have been fed with tons of msdn articles with sentences such as "visual studio standard library is c++17 feature complete " while not all c++11/14 stuff was implemented or more recently, "c++17 100% compliance in vs 2017 15.7" which are LIES. 
Great news. Happy that we will be able to use Boost.Hana with MSVC. Also, I like how the progress is very transparent. A grep for "*BOOST\_HANA\_WORKAROUND\_MSVC\_"* will show all the remaining compiler issues. I wish something like that could be done with Ranges\-V3 with that level of detail and transparency.
Most Boost libraries have compiler\-specific workarounds, for all the compilers. Microsoft have been particularly helpful by maintaining those workarounds for you so you the author doesn't have to. They found a showstopper bug in Outcome recently, it was actually because MSVC was more conforming to the standard than GCC or clang in that specific area. I do agree that it is a bit of a stretch to claim C\+\+ 17, the quality of implementation isn't quite there yet. But given recent progress, I am very confident they'll be there very soon now. And word is they'll be implementing quite a few of the proposed major C\+\+ 23 language improvements long before the other compilers, so expect clang and GCC to start trailing MSVC in years to come.
&gt; Whats the selling point of private virtual? Does not allow to call it, but require to implement? Yes, exactly. &gt; But in C++ it could be violated! That goes for any idiom or attempt at safety; nothing special here that I can think of. &gt; Just override private virtual as public - and that's it - you can now access implementation thing. This is to aid Murphy; Machiavelli can't be helped. &gt; BTW, template pattern can live with protected virtuals too. This is to enforce the pattern, again excepting Machiavelli. All in all, I regard this is as being on the same level as const-correctness – nothing can be unimpeachably enforced, but as long as everyone plays along it can be very useful.
You saying that private methods can be called **ONLY** at definition site (class). But which one is definition site? This class Base{ virtual void run() = 0; } or this class A: public Base{ virtual void run() override{} } At the end, you can call them from both A and Base. So this means that there is 2 run() definitions? I'm saying that this is confusing.
1) If you are dealing with a type-generic data structure using void* in C, how do you account for sizes of different data types? Without dynamically allocating memory, you have to settle for some maximum size. That limits you though and your data structure isn't truly generic. 2) attribute((cleanup(scoped))) is, as far as I can tell, not standard C but rather a GCC extension (possibly supported by a few other compilers). 3) I mentioned it was sugar. It just looks cleaner, but the same can be done with macros in C, sure. 4) Right, but in C++ I can make my enumeration be of type unsigned char and only occupy one byte of memory. Sure you can work around this in C by not declaring your variables to be of an enumeration type, but that can be a little less clear. 5) Yes, but casts are more explicit. And there are other areas in C++'s type system that are more strict. 6) C++'s constexpr allows for loops. Maybe things are possible with C macros, but C++'s constexpr allows for a much cleaner syntax. &gt; Think of it this way: if you wanted to use C++ to write some code in the Linux kernel, you wouldn't be able to use any of C++'s libraries, because they would all rely on new() which effectively is a malloc--&gt;mmap/sbrk call beneath the hood. These are userspace calls. How could I use any of this boost or STL crap inside a Linux Kernel, for example? You can use plenty of C++ without using new and delete. The STL allows for custom allocators and with those allocators, you could use them in kernal space. I don't know that I'd *recommend* that, but it's possible. Look, as I said in my earlier post, both languages are Turing complete. And I also mentioned that this other stuff is a matter of taste. We could go on and on about what's better. You asked for concrete points. I mentioned motivating examples with the understanding that it's taste. Your taste is obviously different, so I don't think it's worth arguing further. 
&gt; I'm saying that this is confusing. That's rarely a good enough justification for C++ to go out the way to disallow something that's otherwise harmless; other languages concern themselves more with this sort of thing. And who's to say it's not useful to someone, somewhere? That's a bit like trying to prove a negative.
Can you share examples?
The _s API invented by MS is most of the time completely insane and "nobody" uses it. Honestly this is so bad that this could be used as an example of what NOT to do when designing a C API (even if some original functions they tried to replace have some problems, their replacement are often worse). IIRC it is merely in an optional Annex of the standard, that is not widely available (because it is insane, and so nobody cares) Avoid that mess unless you absolutely can't. So yes, defining _CRT_SECURE_NO_WARNINGS is perfectly OK. I would actually recommend to do it by default. 
&gt; Also, with C++17 features complete modulo bugs, when can we expect to start seeing C++2a features? We can't talk about timelines yet, but they're on our radar. Currently, we're working on finishing the preprocessor overhaul in the compiler, finishing &lt;charconv&gt; in the STL (integers shipped in 15.7, floating from_chars is shipping in 15.8, floating to_chars is my current task), and fixing bugs.
I've specifically been trying to prevent anyone from overstating our conformance on VCBlog and elsewhere. Typically this takes the form of someone submitting a blog post draft for review, and me replying in 24-point yellow-highlighted font, **we cannot say this**. We've made great strides in conformance lately which we want to tell the world about, but I've always considered it important to keep our messaging accurate (as I've been blogging about our conformance status since the 2010 era) by phrasing our statements carefully and mentioning exceptions. For example, I specifically said [VS 2015 Update 2’s STL is C++17-so-far Feature Complete](https://blogs.msdn.microsoft.com/vcblog/2016/01/22/vs-2015-update-2s-stl-is-c17-so-far-feature-complete/) because for a brief shining moment in Jan 2016, we had actually caught up with all STL features that had been voted in at the time (although not all Library Issues, as mentioned in the exceptions). This wasn't a claim about compiler conformance, as the headline explicitly noted. We recently blogged about [Announcing: MSVC Conforms to the C++ Standard](https://blogs.msdn.microsoft.com/vcblog/2018/05/07/announcing-msvc-conforms-to-the-c-standard/) which was a slight simplification - as the body of the post notes, the preprocessor and FP charconv are incomplete, and there are bugs and issues. But feature-wise, having 99.5% of features implemented is something notable. If you can point to specific sections of posts or articles that are inaccurate, I would appreciate it, so I can learn to watch out for future inaccuracies.
Is missing one of my favourite idiomatic uses for it. if(auto value = get_optional_something()) { std::cout &lt;&lt; *value &lt;&lt; "\n"; } 
I dont follow what you mean by 1. In C you store pointers to these data structures via void*. The size of void* will be platform dependent, e.g., 32 or 64 bits.... 2) it is supported by ICC and I believe PGI compilers support it. 6. Why cant you do loops with macros? 
&gt; And who's to say it's not useful to someone, somewhere? Well, true \- but this is the road to C and Javascript.... C\+\+ allow to have compile time checks, MORE strict than C. In some places it can provide more guarantees then C# / Java at compile time. Compile time checks if not bread and butter, then just important thing in C\+\+. I don't know... wiggle things like this... For the name of what? What this access uplift even good for?
&gt; Where in the current C++17 standard is this allowed now? Normatively, this is specified via "nothing prohibits it". There's an informative footnote, at least. N4750 13.3 [class.virtual]/2, footnote 111: "Access control (Clause 14) is not considered in determining overriding."
Also with STL, I'm not sure you can get around of STL's user-space allocation. For example, how do you ensure the variables that are allocated on the stack in STL happen in kernel space and not user-space? Sure, you can make "new" use kalloc, but if anywhere in STL it does for example: int x = 5; How do you ensure that this isn't done in the application's memory space and not the kernel's memory? Also, STL assumes exceptions are okay. 
private virtual is the default (in well-written code) protected virtual is what we use when a virtual has code that we want to give derived class a chance to run. As in, derived might do something an then call Base::vf();) nothing "changed accessibility level" in your example, accessibility (which defines public interface) has nothing to do with customization points (virtual members) 
I believe the default Linux mutex is a futex, which is a CAS or something unless there's contention, in which case it does the whole kernel call. Ie, uncontended, it's about as fast as dereffing a shared_ptr. 
I understand why one could feel this is a problem, I just don't understand why some people are surprised by it, specially after using the `override` keyword. You're _overriding_ a method, completely changing what it does, why wouldn't you also be able to override its access control?
But to do this takes away power from the programmer with questionable benefit. If I'm implementing a class I should have full control over the accessibility of its members. There should be as few obscure rules as reasonably possible. Having inconsistent accessibility of an overridden method doesn't even break encapsulation. Take this example: #include &lt;memory&gt; class Base { virtual void do_stuff() { // secret implementation stuff here } }; class Derived : public Base { public: void do_stuff() override {} }; int main() { std::unique_ptr&lt;Base&gt; base = std::make_unique&lt;Derived&gt;(); std::unique_ptr&lt;Derived&gt; derived = std::make_unique&lt;Derived&gt;(); // Doesn't compile. // base-&gt;do_stuff(); // Compiles. derived-&gt;do_stuff(); } I still can't call Base::do_stuff from anywhere except Base. I can't even call Derived::do_stuff from a reference to Base without doing a downcast to Derived. I can't see the danger that would warrant extra rules here.
AppleClang is already way worse than MSVC ever was since VS 2010/2012 or something...
`std::optional` is only a simple of algebraic data types. Too bad C++'s `std::visit` looks [like a joke](https://bitbashing.io/std-visit.html) in comparison to proper pattern matching idioms of Rust or Swift.
That's on linux as a system call, so why not just use a similar system call on windows? (I'm guessing there is one, I haven't looked). As for wrapping in a mutex - this is C++, you can just do that with a class and even use a scope lock, so the mutex unlock isn't going to be forgotten.
So the complaint is "not enough syntactic sugar". That us weaksauce. There are plenty of bigger problems with the lack of pattern matching. The fact they lack: varient.match([&amp;](std::string const&amp; s){ },[&amp;](int x){ },[&amp;](bool b){ }); is far drom the big one. The big one is the difficulty in deeper pattern matching, as opposed to simple current overload resolution. First iterations of std library features are rarely optimally user friendly; they are aimed at correctness and performance first. I wouldn't have a novice programmer directly use std thread, std visit or even std regex. But all of them (except regex) are great building blocks for a useable library. 
To silence warnings about unused function results.
presumably it is used to silence the compiler warning message. 
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
I really dislike it. I would insist on using the new conditional thingy (?) if(auto value = get_optional_something(); value) { std::cout &lt;&lt; *value &lt;&lt; "\n"; } 
`do_run` is public in A, and you are calling it on an instance of A, so that compiles. If you write `Base * b = new A(); b-&gt;do_run();`, it doesn't compile then because you are calling private function. So, you can always override a virtual function no matter it's private or not in the parent class because you just rewrite the virtual table, but when you can access that function (the entry in the virtual table) depends on whether it's visible in the instance. And you don't change the visibility in the parent class, indeed there is no way you can access the private function in the parent class from either the derived class or outside.
Eh this just seems to make pointers seem 10 times more confusing to me.
"if initializer" works to describe this feature
Thanks!
**Company:** [Microsoft](https://www.microsoft.com) \&gt; [C\+\+ team](https://blogs.msdn.microsoft.com/vcblog/) \&gt; [C\+\+ Developer Advocate](https://careers.microsoft.com/us/en/job/442634/Senior-Program-Manager) **Type:** Full time, Senior Program Manager **Location:** Redmond, WA, US or remote **Remote:** Yes (details below) **Description:** Our mission on the C\+\+ team at Microsoft is to build the best C\+\+ tools for any developer, any app, any platform. Did you know that our C\+\+ compiler and libraries are fully conforming with the latest C\+\+ standard? Or that Visual Studio can use C\+\+ to build not just apps for Windows, but also for Linux, Android, and iOS? How about the rich C\+\+ experience in Visual Studio Code that is available on Windows, Linux, and macOS? And did you hear about Microsoft's latest announcement for an open source C\+\+ library manager for Windows, Linux, and macOS? There are still many C\+\+ devs in our target audience, VS users or not, that haven’t heard about any of this news and we need your help! We are looking for a developer advocate to help us reach the entire C\+\+ developer market around the world and build a large and dynamic C\+\+ community for the Visual Studio family of products. This position *can be remote. We are optimizing for finding the best person over optimizing for where they are located*. Travel will be required, depending on where developer events are held, and also to Redmond. *Responsibilities:* * You will collaborate with the PM team on integrating C\+\+ developer feedback into Microsoft products. * You will measure our customer reach and provide data\-driven insights into where the team should focus their efforts. * You will be the editor\-in\-chief of our Visual C\+\+ blog and rely on several Microsoft\-wide supporting programs and resources, e.g. MVP program, MS Academy. Your goal is to double and then double again our blog readership and engagement. * You will integrate the work of the product and engineering teams at Microsoft in compelling content, apps, and demos. * You will share these through our established channels (blogs, social media, conferences, direct customer outreach, MVP program) or experiment with new channels with the goal of supporting both new and existing audiences. * You will work with marketing teams to ensure Microsoft conferences have the right C\+\+ content. * You will collaborate with our doc writers to ensure our documentation is consistent with the product. * You will make sure that no question about one of our C\+\+ products goes unanswered on the internet (not necessarily by answering it yourself, but at least by connecting the right person on our team to the forum to answer it) *Qualifications:* * A BS or Master’s degree in Computer Science or equivalent industry experience * 2\+ years of software development experience. * Evidence of being both a strong technical writer as well as a dynamic public speaker. * Experience working with communities, social media, and blogging required. * Previous experience as a C\+\+ developer is required. * Previous experience with campaign tracking, SEO/SEM, or a desire to build those muscles, is important. Ability to meet Microsoft, customer and/or government security screening requirements are required for this role. These requirements include but are not limited to the following specialized security screenings: This position will be required to pass the Microsoft Cloud background check upon hire/transfer and every two years thereafter. **Visa Sponsorship:** No **Technologies:** C\+\+, Visual Studio **Contact:** [Apply for job](https://careers.microsoft.com/us/en/job/442634/Senior-Program-Manager) or DM @mluparu on twitter or email mluparu at microsoft.com with any questions you might have
I feel like they have been making a lot of progress lately, and while they might be claiming a few things that are a bit of a stretch, I'm fully supportive of their effort and methods. They were so far off with their compiler a few years ago that we can't expect them to be perfectly conforming in all the crazy corner cases that a library like Hana uses. It would be wrong if they were "hacking Hana" and then stopping at this stage. But instead, they are just making Hana available to their users earlier while they keep on fixing their bugs. That's great IMO and I wish other compiler vendors were so dedicated. Also, they have found legitimate bugs in Hana (this naturally happens if you compile with a new compiler) and I've been working at fixing those in the upstream repository.
FWIW, you actually don't have to do a lot of OS rearchitecting because you already have a way to map the hardware into a user address space: mmap. And the nice part about that is that it already gives you a way to communicate directly with the hardware with (minimal) interference from the OS. Performance\-sensitive applications \_already\_ go to great lengths to avoid the OS as it is (databases very much included), so this would just continue that existing trend and make it really easy. All that said: filesystems are not going to disappear because you need a way to encapsulate the notion of datasets. Files turn out to be a decent way to do that. And because of mmap, the FS doesn't have to be in the data path, so why \_not\_ have access to the FS and its utilities?
I have benchmarks supporting this here :) [https://github.com/cbeck88/strict\-variant](https://github.com/cbeck88/strict-variant)
\&gt; edit: I know there's std::memcpy but it's much more verbose and annoying to use. This is a cop out and FWIW this would not fly in code review at my company
Note that &lt;charconv&gt;'s integer overloads for `from_chars()` and `to_chars()` are available in VS 2017 15.7. They have reasonable performance although they haven't been hyper-optimized yet. Floating-point `from_chars()` will be available in 15.8 (it's about 40% faster than our CRT). I'm working on floating-point `to_chars()` right now (expected to be blazing fast).
People made it defined behaviour in C, I'd argue C++ standard is lacking there. Different companies have different coding standards and constraints. Maybe you don't need to support multiple compilers, maybe your compiler is stupid and doesn't optimize things how you want, sometimes it can make the interface more convenient...
What I mean by (1) is that in C\+\+ containers, your data can be stored contiguously with other parts of the data structure reducing the need for indirection. Take tree for example. In C, you may have a node defined as: struct TreeNode { struct TreeNode* left; struct TreeNode* right; void* data; }; In C\+\+, after template expanstion, the compiler will see something like this: struct TreeNode { struct TreeNode* left; struct TreeNode* right; int data; // &lt;-- No pointer here. This is data. No indirection needed. }; I hope that makes more sense. (2) Sure. Extensions are available on many compilers, but not everywhere. Many C\+\+ compilers offer extensions found in C99 and C11, but not in standard C\+\+ like \_\_restrict\_\_. I was just trying to stick to the standards, but if we allow extensions, then many more things are allowed in both languages. (6) I don't mean that you can't do loops with macros. In C loops often will not be compile\-time evaluated. C\+\+'s constexpr allows compile\-time evaluation of calculations involving loops, if statements, and even some math functions. (OK, Boost.Preprocessor does allow some cool tricks to do preprocessor\-loops, but most compilers' macro expansion stack is much shorter than what can be accomplished with macros. For example, I've written code that will generate quadruple\-precision values for the natural logarithm, sin, cos, exponentional, and gammaln functions at compile time (final evaluated values can be found in the assembly output, with the code to generate the values being absent in the assembly output). As far as I know, this would be much more difficult in C.
\&gt; People made it defined behaviour in C, I'd argue C\+\+ standard is lacking there. I don't think this is true, I think in C89 strict aliasing wasn't a thing and most forms of type punning were implementation defined, and in C99 they made most (if not all?) of it undefined behavior, moving in the C\+\+ direction. I read a few of articles from the time where C programmers cursed this decision, and how much of their code was wrecked by this \-\- indeed not everyone adopted newer C standards. The point is that type\-based alias analysis is (or at least was) the most practical way to enable some important optimizations that arise in common low level situations. If you aren't using ancient compilers I wouldn't recommend doing illegal type puns in C code, and I wouldn't trust \`\-fno\-strict\-aliasing\` to just make it okay in all situations either. Compilers are pretty complicated and as an engineer I just have a hard time believing that they can change things in such a fundamental way with the flip of a switch and be sure that they turned off every relevant part of the compiler that might use type information this way. And there is no standard documentation around what \`\-fno\-strict\-aliasing\` means, so it's really hard to know what you actually gain by doing this \-\- what type casts are still illegal and what documentation should we refer to to figure out what code is correct when this flag is on? (I'm not a compiler engineer, maybe I shouldn't be so skeptical)
I think you only run into strict aliasing issues if you try to do very weird things. If we're talking extracting the mantissa of a float, there's very little the compiler can do to mess up your day. And according to [this](https://stackoverflow.com/a/11443087) answer, it's safe to do with unions but not pointers (since it could reorder some operations, but I guess you could use memory barriers for that). It seems to be safe according to the C11 standard and it is explicitly allowed.
I don't agree about using type punning through a union to extract mantissa from float, that's the kind of tech debt that no serious project wants to accumulate. My reference for this kind of thing is here. https://blog.regehr.org/archives/959 if you want to take bytes from one place and reinterpret them as int, memcpy them on top of an int. Then you know it is aligned correctly etc, and if there was no alignment issue, the temporary will get optimized out. It's safe and there's no performance win from doing things the illegal way so why would you screw around
I think this example overlooks the syntax part. In this case you hide it in a function. But to take a similar example if you wanted to address a byte inside a int (for example in an image with RGBA), unions provide a very easy to use interface (you can use the int to initialize or copy the whole pixel, or just look through one color value). You can make a safe function with no UB, and a good compiler can probably make it just as fast, but the interface is likely to be more verbose. I wish there was a nicer syntax for these things without issues. If you have to write a `getR()`, `getG()` and `getB()` function that's not very friendly. Obviously you still have potential issues with endianess, but that's the case either way. By the way sending two pointers to a function with different types is really asking for strict aliasing to get you, is it realistic?
&gt; Whether one gets bad_alloc because one rans out-of-memory, requested a zero-size, or passed it a non-power-of-two alignment, that's pretty much irrelevant at the point where one catch the bad alloc. You seem to be wholly missing the point. In very generic systems, the code that calculates the size to be allocated and the code which actually does the allocation and manages the resulting pointers are potentially wholly separate. A module might request multiple allocations of various computed sizes, and would only want `bad_alloc` to be thrown if a true actual failure occurred (e.g., inability to allocated the requested memory). If `new` throws on size-zero allocations, then the generic code must `try`/`catch` around each and every `new` expression, or it must explicitly check for any provided size-zero requests and specially handle/ignore them. Both of those are additional special cases not needed if zero-sized `new` returns instead of throwing. And those special cases are out in user code that then needs additional test code and complicates test coverage. Which is bad engineering.
The "but what about" section pretty clearly defines what's left to do and where the shortcomings are, but I think some people would in general terms (reasonably) object to msvc being labelled as conforming when it still has quite a few more major bugs than other compilers that prevent it from compiling common libraries That said, I have no idea why people seem to be so upset about this, particularly given that the compiler is improving at the fastest rate in its history, and particularly given that its borderline arguing semantics at this point Also, doubly so given that I personally use MinGW and most big libraries seem to hack around it being a weird compiler. MSVC may be more deviant currently than the other major compilers, but once you get to the stage of 'it works except with these workarounds' you're getting pretty close to the other compilers I think a lot of people are still burnt by msvc by how it was only a few years ago, where calling it anything-conforming was definitely more than pushing it. I also suspect there's some general anti-microsoft sentiment mixed in there as well, particularly which has been seen fairly en masse with the github situation
That's just repeating yourself for no reason...
Counterpoint: template &lt;typename T&gt; struct Rectangle { T x, y, w, h; } Now add a "last x" property which is exactly interchangeable with `x + w - 1`. Without some kind of property mechanism in the language now w and last_x are accessed differently than each other. There are plenty of cases where the invariants of a purely data struct are easily implemented in getters / setters, and some kind of language help to make them pretty would be nice. That said, I'll gladly wait for metaclasses to get properties. 
&gt; Then you know it is aligned correctly etc, and if there was no alignment issue, the temporary will get optimized out. It's safe and there's no performance win from doing things the illegal way so why would you screw around Doing it via union has no alignment issues and is legal – in C. Using `memcpy` is unavoidable in C++, I think we all agree.
Writing to `raw` and then reading from one of the other three is UB. Many compilers implement what you'd expect, but that's not something people should be comfortable doing. 
First of all, I don't think they said anything about 100%. Second, your original claim was that "instead of fixing their compiler .." which is not true. They are fixing their compiler **and in addition** provide those workarounds.
You have to keep the mutex locked as long as you are using the returned pointer. That can be quite some hassle.
&gt; We recently blogged about Announcing: MSVC Conforms to the C++ Standard which was a slight simplification **a slight simplification** ? Like, do you know what I would get if I was a... say... electrical outlet maker and I make ads with "buy doom_Oo7 electrical plugs, they conform to the ISO/IEC standard for plugs"... and they didn't ? I would get a trial !
You can try xmake. https://xmake.io
The first one isn't a definition.
I did some benchmarking about a year ago (string/number conversion). lexical\_cast came out dead last, is very slow, but has a good api. The winner in terms of speed was the dtoa lib, but it means including thousands of lines of impossible to read code. Close to dtoa was boost::spirits converters, though they have a slightly strange syntax. 
Why? What's the advantage? It doesn't add any more information, but is more verbose.
looking at the code generated by current implementations, std::variant is all but optimized for performance. I still think types like tuple, pair, optional, variant should be part of the language which often would allow simpler syntax &amp; better performance.
That misses the point that the memory won't ever be erased. You already have OSs (iOS, Android) where filesystems exist, but are (mostly) hidden from the user. If smartphones now had no memory, and only had very fast flash... Of course the filesystem is not going away for a long time, just as batch processing didn't go away when punched cards (and magnetic tapes) gave way to hard disks. But surely will become much more niche, substituted perhaps by some object storage.
A good overview is here: [https://youtu.be/v3dz\-AKOVL8?t=19m9s](https://youtu.be/v3dz-AKOVL8?t=19m9s) It enables polymorphic allocators, so you may have "one true allocator type" where you can just configure the backing memory resource
For the syntax: it's not the worlds cleanest thing, but just include template&lt;class... Ts&gt; struct overloaded : Ts... { using Ts::operator()...; }; template&lt;class... Ts&gt; overloaded(Ts...) -&gt; overloaded&lt;Ts...&gt;; and you're good to go with the clean lambda syntax.
I tend to agree to be able to stick to the rule 'no assignment in conditions'.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8p8gk1/help_w_installing_google_library/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
MSDN states: &gt; Both the 32-bit and 64-bit versions of gmtime, mktime, mkgmtime, and localtime all use a single tm structure **per thread** for the conversion. It just isn't safe on Linux: &gt; The four functions asctime(), ctime(), gmtime() and localtime() return a pointer to static data and hence are not thread-safe. Microsoft seems to have the saner localtime implementation. 
My gripe with this is that you can't extend this to multiple cases eg. if(auto thing1 = get_optional_1() &amp;&amp; auto thing2 = get_optional_2()) { std::cout &lt;&lt; *thing1 &lt;&lt; *thing2 &lt;&lt; "\n"; }
sorry, but you can't be serious. Here's some code that has been building just fine in AppleClang for months and still fails miserably without a ton of hacks and "simplifications" in MSVC ; https://github.com/OSSIA/score/blob/b65955b62ea78cabdf652c2a730e840b6ab130b6/base/plugins/score-plugin-engine/Engine/Node/Executor.hpp#L266
Here's some code that has been compiling fine in all major compilers for the past half a year, if not year, but still fails on Xcode 9.3 (haven't tested 9.4 yet): \`\`\` #include \&lt;optional\&gt; std::optional\&lt;int\&gt; o; o = 5; int o\_i = o.value(); \`\`\` (My use case was slightly more complicated but I think it reduced pretty much to this. It's possible even the include still fails.)
What is the benefit with this over if(var) { Print *var } 
Your example takes an extra line - that's not a big deal, except that the variable `var`'s scope is far bigger, and you might accidentally use it later even if it is empty - undefined behavior. The huge advantage of `if (auto var = foo()) {` is that `var` is in scope _exactly if it is not empty_. There is literally no way to try to access its value if it is empty - no way to cause undefined behavior.
No it doesnt. U chose whitespace and lines yourself. Its an if check and a print statement..
Out of interest, any reason you didn't go with mpark::variant for this?
That's really cool. But one question: You mention everywhere that these types (e.g. optional/variant) are "C++17-like". What I'm interested in as a potential user of these libraries is whether they're 100% conforming to the standard (where possible, of course, I guess pre-C++11 without move this is not possible), or whether they're anything that's done differently as in the standard, for whatever reason. So what does "C++17-like" mean? Are they 100% drop-in replacements?
I'm realizing that I have an issue between `std::unique_ptr` and `std::optional`. There seems to be exactly one essential difference - `std::unique_ptr` manages a pointer that's guaranteed to be on the heap, whereas `std::optional` contains a block of memory in its footprint that is managed using placement `new` and placement `delete`. And there are differences that are consequences of that. It seems to me that these boil down to `std::unique_ptr` offering three extra services: 1. a `release()` method that returns the pointer 2. `reset()` with a non-`nullptr` argument, which allows a raw pointer to be assigned into it 3. a custom deleter (and IMHO the only reason to use either 1. or 2. is if you're working with legacy code or a C library - otherwise there's no excuse for managing raw pointers by hand.) So why don't they have exactly the same interface, wherever possible? Why does `std::optional` have methods `has_value()`, `value()` and `value_or()` but `std::unique_ptr` does not? (And why are they not documented as "variations of the same idea" but instead as two totally different things?)
Stuff like std::any is a good pick for plugins. Suppose you have a system with plugins that produce data and plugins that consume data. Something like std::any can be used for making sure plugins can exchange data and checking the type at runtime. Mismatched plugins can then be detected.
You can break any compiler with a valid code. For example, there is no full support of C++11 in clang: https://godbolt.org/g/fX8gxe 
but that's only a matter of library. You can use &lt;experimental/optional&gt;, you can use &lt;boost/optional&gt; or one of the trillion lightweight optional implementations on github that are better than std's one anyways ; but you can't go around core language changes if you expect specific performance characteristics that only compile-time computations can give you.
Wewt? I am not asking for formating guidelines, but functionality of statements. I do see your point of locality of variable for the right cases. It still looks less readable to me though
Maybe it just needs something like this? class Base{ private: // Note - "sealed" keyword virtual void do_run() sealed = 0; public: void run(){ do_run(); } }; class A : public Base { public: // compiler error "changing visibility of sealed virtual member" virtual void do_run() override {} }; keyword "sealed" \- forbid changing of virtual member visibility. All derived classes, which override that virtual must keep the same access level. In case of multiple inheritance, if two sealed appear with different access levels \- its compiler error. Or "sealed\_access".... To distinguish from "final" keyword. But... Probably things like this will eventually float the Vasa.
That's only useful in cases where the type is declared outside the condition. When you specify the type (or auto) then it can not go wrong (unless it goes wrong).
So [last time](https://www.reddit.com/r/cpp/comments/8ob7dd/nanorange_msvccompatible_implementation_of_the/e02plj9/) you complained they couldn't build boost (actually just hana) and now you're complaining that they made hana build? It's not like they are going to avoid fixing the bugs, but this lets people use hana in the interim.
For ranges, consider the recently posted [nanorange](https://www.reddit.com/r/cpp/comments/8ob7dd/nanorange_msvccompatible_implementation_of_the/) lib. It only includes the parts that have been voted into C++20 rather than the entire range_v3 library, but it is MSVC compatible!
&gt; If new throws on size-zero allocations, then the generic code must try/catch around each and every new expression, or it must explicitly check for any provided size-zero requests and specially handle/ignore them. Both of those are additional special cases not needed if zero-sized new returns instead of throwing. I completely agree. However, I think that this is only a benefit if user code does not need to handle zero in any special way. If it does, then the zero-handling logic becomes split, part of it living inside the allocator, and part of it inside user code.
The third overload is there to allow the following to be a nop. int i = custom::lexical_cast&lt;int&gt;(12345); // input not stringy.
&gt;C++17-like ? Like: does one think of similarities first, or of differences first? Thanks for raising this question. It indicates the formulation can be improved. The general idea: - C++17: you get std::*type* via namespace `nonstd` - non-C++17: "best-effort" given what the type requires and the standard provides. I try to document differences that result from the C++ standard used in the Synopses, see e.g. [Interface of *optional lite*](https://github.com/martinmoene/optional-lite#interface-of-optional-lite). Some types are still underway in the standardization process and are changing along the way. An example of this can be seen in [*expected lite*](https://github.com/martinmoene/expected-lite), that provides a [deprecation control `nsel_P0323R`](https://github.com/martinmoene/expected-lite/blob/a04a67f42559160dcad8e1df49d2cde67285c574/include/nonstd/expected.hpp#L27). I try to keep-up with the changes, but will always lag. Thanks for pointing out about CMake's internal options `-B` and `-H`.
[http://fmtlib.net/latest/index.html](http://fmtlib.net/latest/index.html) as proposed for standardisation
Here is another library for the same purpose but with probably easier to use syntax: [discreture](https://gitlab.com/miguelraggi/discreture) You can do things like: ``` for (auto p : combinations("Hello world!"s, 3)) { // use p[0], p[1], p[2], p[3] } ``` and the speed is better (but only single threaded). For example, to generate all (28 choose 14) combinations, it takes 0.062s in my computer (single threaded), as opposed to the 0.2s in this library (and that is when using 4 threads).
It's unfortunate boost::string\_ref doesn't activate that fast path. If you don't need exceptions, [try\_lexical\_convert](https://www.boost.org/doc/libs/1_67_0/doc/html/boost_lexical_cast/synopsis.html#boost_lexical_cast.synopsis.try_lexical_convert) will reduce the generated code further. Almost to the same size as spirit. The remaining bloat is lexical\_cast's use of locales, which can't be disabled, from what I've found.
How about: class Base { public: virtual doFoo() = 0; }; class Base { private: doFoo(); }; 
Concise code is not necessarily more readable. I’ve never like declarations inside of if statements, but with the semicolon I feel it reads like a for loop and therefore the condition jumps out
\&gt; last few weeks an amazing range of few ;)
Unfortunately, `const` disables move semantics, thus being bad for performance. 
&gt;Concise code is not necessarily more readable. True, but the same is true for the inverse ( more verbose code isn't necessarily more readable either). In this example, the additional characters `; value` add no information, they don't introduce a more readable name or help to break up a long and complex expression, it doesn't become more explicit what you are doing (like adding a namespace qualification might) and as a bonus point it adds the (small) chance to introducing a typo. So in the end it just means my brain has to read and process more text without making any of that processing simpler. If you prefer to use the new syntax everywhere it's possible instead of everywhere it adds value, be my guest, but please don't enforce your personal preferences on others (the "I would insist on" part of your post is what rubbed me the wrong way -sorry for that). BTW.: A more verbose version, that would potentially add value would e.g. be: if( auto value = get_optional_something() value.has_value()) { } because now it is immediately clear, what branch is taken in case of success (many c-api functions signal errors via non-zero values, that convert to true)
That is if you are allowed to use libraries other than the STL where you work...
I bet you’d need to test larger data sets before you’d see any performance improvements.
you can use it if thing1 and 2 are of the same type as `if (auto thing1 = get_optional_1(), thing2 = get_optional_2(); thing1 &amp;&amp; thing2) {` `std::cout &lt;&lt; *thing1 &lt;&lt; *thing2 &lt;&lt; '\n';` `}`
The design pattern [NVI](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface) (non virtual interface) is based on this idiom.
`&lt;experimental/optional&gt;` is broken on Xcode so no, you can't use it (for example it doesn't have `::value()` IIRC). So you need a 3rd-party library - just for macOS. But yes you're right, these are still somewhat easier to workaround than compiler problems. But still it doesn't change the fact that Microsoft is working on it heavily, while from Apple we're getting signals that they care shit about C++ for a few years now (well to be precise, no signals at all is what we're getting, not even change notes ;-) ).
NVI would be in win, if it would be possible to enforce private virtuals to remains private.
&gt; non-C++17: "best-effort" given what the type requires and the standard provides. Cool, thanks for the clarification! &gt; I try to document differences that result from the C\+\+ standard used in the Synopses, see e.g. Interface of optional lite. Hmm yes I saw these tables but all I can see is a large table with the API. Where are the actual differences listed to the standard (if there are any)? Maybe I'm blind, in that case I apologize, but the table is quite large, particularly if I'm only interested in the **differences** to the standard. If I want to look up the `optional` API, I go to [cppreference.com](https://cppreference.com). And most people don't know the details of the `std::` `optional` from the top of their head so they can't read your table and see "Oh yes, this and that is different". :-) It would be nice to see the differences (the important thing) in one place. Then you could even remove the interface description because people go to cppreference.com for that, and they just need your table to know the differences to `std::`.
The way I think about `std::optional&lt;T&gt;` is that it’s equivalent to `std::pair&lt;T, bool&gt;`, where the `bool` represents whether the value for T has been explicitly set or not (or set and “cleared.”)
Maybe. But discreture can also do parallel easily. I just commited a little tutorial that prints this for iterating over all (40 choose 11) combinations: Time taken to see all 2311801440 combinations using 1 processors: 3.23509 Time taken to see all 2311801440 combinations using 2 processors: 1.63198 Time taken to see all 2311801440 combinations using 3 processors: 1.09133 Time taken to see all 2311801440 combinations using 4 processors: 0.818618 Time taken to see all 2311801440 combinations using 5 processors: 0.952753 Time taken to see all 2311801440 combinations using 6 processors: 0.822638 Time taken to see all 2311801440 combinations using 7 processors: 0.793062 Time taken to see all 2311801440 combinations using 8 processors: 0.745046 Of course, permutations can also be created in parallel in a very similar fashion.
You can get my benchmark code at my repo. next_comb: 19ms next_comb_with_state: 2ms discreture: 2ms My next_comb_with_state is on par with discreture. The article document that new function is at https://codingtidbit.com/2018/06/06/improved-next-combination-with-state/
My code can run massively on CUDA with some modification because all the code it uses, self-contained in function itself.
While it may be sufficient for many use cases to only have initializer_list temporaries, I would not appreciate this step back from being able to create arbitrary containers as temporaries. For example, a templated function may require that its argument be an AssociativeContainer, which an initializer_list of pairs is not.
Thanks for your feedback that enables me to improve the various descriptions. I agree with skipping a repetition of the std API. It'is something I already have begun to do in some projects, see for example [synopsis of *span lite*](https://github.com/martinmoene/span-lite#synopsis).
`string_view` never allocates...
Returned pointer? Why wouldn't you just return or write the data that you want by value? Where would a pointer come in to play here? 
You have to scan the compilation db again by running `Tools -&gt; Compilation Database -&gt; Reload`.
&gt; &gt; &gt; The huge advantage of if (auto var = foo()) { is that var is in scope exactly if it is not empty. There is literally no way to try to access its value if it is empty - no way to cause undefined behavior. The f@ck ? Are you confusing formatting and lexical scope ? with: if (auto a=f()) std::cout &lt;&lt; *a &lt;&lt; std::endl; std::cout &lt;&lt; *a &lt;&lt; std::endl; will fail to compile, while type a; if ((a=f())) std::cout &lt;&lt; *a &lt;&lt; std::endl; std::cout &lt;&lt; *a &lt;&lt; std::endl; will compile and crash if a is not set. (And needs you to type the type. And is less generic. And is longer to write).
Oh, right.. Derp on my part. :-]
Accidentally typing `=` instead of `==` is such a common error that someone casually reading the original code might think that such an error had been made here. Static analyzers are liable to flag it as well. Adding a bit of redundancy makes the intent clear and thus less likely to be “fixed” by someone else down the line.
It does not, but it doesn't null-terminate, and systems C interface **really** likes that 0.
Sorry, you can't tell me that if you are reading if(auto value = get_optional_value()) You are thinking "hm, maybe the author actually meant" if(auto value == get_optional_value()) (which wouldn't compile anyway) And btw: you don't even need a separate static analyzer: If your compiler doesn't warm you about if(a = b), then get yourself a better compiler
No? Tom stated that my example took an extra line. The only reason my example took an extra line was due to my choice of formatting.
`std::unique_ptr` conveys ownership semantics. `std::optional` doens't.
Indeed, {fmt} can be used for T \-\&gt; string casts. It doesn't generate much code ([https://godbolt.org/g/Gfj3mp](https://godbolt.org/g/Gfj3mp)) and is pretty fast.
I understand the concept of scope just fine, which is why I see the point that was made. My formatting comment was due to Tom claiming my code example needed an additional line. Let me be clear: the extra lines in MY example was purely a formatting choice. Hence I was curious of the logical diffence and not formatting 
&gt; The huge advantage of `if (auto var = foo()) {` is that `var` is in scope _exactly if it is not empty_. There is literally no way to try to access its value if it is empty - no way to cause undefined behavior. No — the variable is in scope for the whole `if` statement, including its potential `else` ([demo](https://godbolt.org/g/Lws9uk)). This syntax gives succinctness and restricts scope, but not _that_ much...
The only other issue I can see is that there could be certain times where you'd want specific behavior *iif* a specific parameter is known at compile-time, even if not all parameters are known (and thus the function itself isn't constant_evaluated).
This isn't assignment, it's copy-initialization.
Copy assignment I think on some (older) compilers? Anyway you know what I mean.
No, I don't; this is always construction, never assignment, so the dogma against assignment in conditionals simply doesn't apply here.
Hm, by that logic, GCC should say experimental support for C\+\+98, since [unicode identifiers](https://gcc.gnu.org/wiki/FAQ#What_is_the_status_of_adding_the_UTF-8_support_for_identifier_names_in_GCC.3F) still do not work. Or the fact that some C\+\+98 STL functions are broken in `libstdc++`: For example [`std::get_time`](http://en.cppreference.com/w/cpp/io/manip/get_time) currently (as of GCC 8) does not support `%n`, `%t`, requires leading zeroes for `%d` and requires full names for months with `%b`.
I first started back in September last year but ran into problems with MSVC and gave up... I picked it up again in mid-May and basically started again from scratch. It’s better this time round 🙂.
Not wanting to beat a dead horse, but I think he extra statement in your example is not a formatting choice: you have to declare the variable in a separate statement. But the core issue is the scope, which is what Tom said in his original comment and is showed in my example. That said, no need to debate this to death, have a nice day.
Plenty of other things don’t build and they aren’t going to just go around and hack all of them. You’re missing the point so you could mock me with a straw man. 
Oh you are referring to pointer initialisation? I thought it was referred to number of lines. Everyone to their own styles :)
Oh. I got dribbled through the legs by his statement. I though his critique of my "line" referred to the four number of lines i had displayed on my phone as opposed to the three lines of code at the example i queried. I get you now. An extra statement. Yes, I suppose it's more compact. Less readable for me personally, but everyone to their own style! Have a great day.
MSVC continues its blockbuster record of progress, love it!
Looks interesting. You might want to crosspost this to r/Compilers.
Hmm, ok, if you guys say so I believe it. It's news to me.
Unless an application rolls its own parsing, instead of using CommandLineToArgvW (or just relying on main), this isn't an issue. Maybe MinGW does something weird, IDK.
Does anyone have any details or examples about this tool? The website is pretty vague and seems to be unfinished except for some very large stock images.
&gt; Sorry, you can't tell me that if you are reading… No, not me. Someone else. Never overestimate the intelligence of the person maintaining your code in five years. 
From a footnote in C11 §6.5.2.3: &gt; If the member used to read the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called "type punning"). This might be a trap representation. IIUC C99 is when it became legal, but I don't have a copy of that handy and don't know if there was similar wording.
You're poking into random areas of memory you don't have permission to use, which is undefined behavior. Anything can happen, from getting gibberish to your program crashing to it developing sentience (granted, that's on the low end of the probability scale).
Can you link a bug report or provide a reproducer?
Which version of c++1z is it? It didn't like std::byte.
"Just try to make it fit in with the surrounding code" Pros -- very few pointless arguments about coding style Cons -- very few pointless arguments about coding style
The hand rolled was done ~2 years ago in a hurry. I had written a bunch of code that depended on variant on windows, then switched to Mac and found Xcode still didn’t support it. I learned three things over the course of the following week: 1) I need a CI setup (we still don’t...) 2) I should have looked on github first... 3) Apple apparently has there own version of llvm/clang and it is no longer up to date
We just hired a guy straight out of college with a bit of C experience and no C++ experience, to work on a team that does primarily C++. We might be an outlier, but my guess is "no".
[removed]
&gt;What I mean by (1) is that in C\+\+ containers, your data can be stored contiguously with other parts of the data structure reducing the need for indirection. Take tree for example. In C, you may have a node defined as: &gt; &gt; struct TreeNode &gt; { &gt; struct TreeNode* left; &gt; struct TreeNode* right; &gt; void* data; &gt; }; Intrusive lists (which would be equivalent to your C++ example) are fairly common in C, especially in the Linux kernel: `container_of` is used in 5684 files in the 4.17 release. 
`int x = 5` would but `x` on the stack. Your question doesn't make sense...
There is a userspace stack and a kernel slace stack. How would you tell STL to put x in the kernel space stack amd not userspace stack?
You may find #define with(decl) if (decl; true) with (auto value = get_optional_something()) if (value) { std::cout &lt;&lt; *value &lt;&lt; "\n"; } more readable (but I'll stick to `if (auto value = get_optional_something())` because it is more idiomatic).
&gt;There is a userspace stack and a kernel slace stack. No, there isn't. When you call into the kernel it uses the top of the userspace stack that called in. (Threads started in the kernel get their own "kernel only" stack, though). &gt;How would you tell STL to put x in the kernel space stack amd not userspace stack? Well, the function is currently executing in kernel space, so I'd expect it uses the kernel part of the stack.... 
\&gt; The current installer integrates with MSVC 2010, 2012, 2013 and 2015. Unfortunately, the clang installer doesn't integrates with MSVC 2017.
Yes there is. You know nothing about kernel development. You know even less about programming languages.
Well I've written 4 drivers for a piece of hardware, so I'd like to think that I know *something* about kernel development. I'll try to find a source for my argument, thiugh, since I'm pretty sure I am correct. 
Good news! I found [a source](https://stackoverflow.com/questions/12911841/kernel-stack-and-user-space-stack?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa) that says I am incorrect. The userspace stack is not used when switching into kernel space. Easy eample why: the kernel can't trust that the stack pointer is valid / safe when userspace can set it to anything it wants. However, the kernel stacks are setup *per-thread* - every userspace stack has a corresponding kernel stack that's used when switching in. 
You realize that the compiler generates assembly code to put variables on certain stacks, right? How will the STL libraries know to put the appropriate variables on the right stack?
Yes, and it does that using the stack pointer register, correct? In kernel space, the stack pointer would point into the kernel stack, so local variables would go there, correct?
Since comments there are closed, maybe people here will get something from this. Maybe even Trevor, the commenter I'd like to address: I'm not a huge fan if IBM's XL C/C++ compilers, they've given me a lot of trouble, but they do [actually support](https://en.cppreference.com/w/cpp/compiler_support) all of C++11, and much of C++14.
For x86 maybe.. I haven't looked at x86 in a while. I think x86 only has one stack register
Coming back to C++ after lots of time in Scala, I do find `optional` to be kind of weak sauce. In Scala, if you're not regularly using `Option`, you're doing things wrong. I've seldom felt any desire to use the equivalent-ish `optional` in C++.
This is off topic for /r/cpp, maybe try /r/cpp_questions
And that is what I was saying before; you either need macros, manual allocation with use of void\*, or something that isn't fully generic. In C\+\+ with templates, you get the cache locality of intrusive containers without requiring the user to define something as intrusive.
That indentation style makes the code extremely hard to read
Is there a reason you choose not to make use of [GenerateExportHeader](https://cmake.org/cmake/help/v3.0/module/GenerateExportHeader.html) and just have the CMakeLists.txt responsible for creating the library check whether or not the build is a static lib or shared and call generate_export_header(yart)?
You'll have to do it by hand, i.e. extract the batch file (and read what it does), modify the props and target files and put them in the correct directories.
No, I wasn't aware of this module. Thanks for pointing this out, it's quite useful.
https://github.com/minimaxir/big-list-of-naughty-strings
Please, never use #define to invent your own keywords. Anyone reading that is going to just have a big WTF moment before they figure out what you did, especially if they're not familiar with languages in which that's a thing. I'd much rather see straight C++ than someone being clever with the preprocessor. Actually, I use to dislike assignment inside if statements, but I've recently reversed my position on it, simply because I like that the value is scoped to the block inside the statement, and doesn't unintentionally pollute the rest of the function. I certainly acknowledge that unless you're used to that particular idiom, it's slightly less clear what's happening, but having said that, it's not a hard concept to grasp and learn.
You should probably do versioning in the project() call, and use find_dependency() in the Config.cmake.in file. 
https://github.com/nst/JSONTestSuite
nice to see CMake confirmed as the most popular build system !
I am supprised that Qt Creator is such inpopular IDE. Its great, multiplatform and with Cmake support. It evolve very fast too. Maybe people thinks it is for Qt framework only.
I am personnally contemplating using clang on all three systems for a simple but sadly very practical reason : I want to add some JIT compilation parts to the software I'm working on. To do C++ JIT, I have to have a standard library at my disposal. If I want my jitted code to interoperate with the "host" software, it has to be the same standard library than the one used to build the host software, due to ABI compatibility. And I cannot redistribute MSVC standard headers with my software legally. Hence, I would have to use clang + libc++ on windows too since those I can ship along. 
Blender 3d has also recently enabled clang support for Windows in their 2.8 branch... Along with Chrome maybe these are just 3 isolated incidents, or maybe somethings about to give? While I think the FE team has done a commendable job with both implementation and communication (frequent, meaningful msvc releases, ample blog updates etc.) perhaps the BE and tooling teams are not remaining front and center enough? Language and library compliance are table stakes nowadays; folks need something more to judge a compiler on. Knowing how code generation quality is improving wrt speed, debuggability, etc. would go a long way into helping this issue. We need more blog posts like: https://blogs.msdn.microsoft.com/vcblog/2017/12/03/msvc-code-optimizer-improvements-in-visual-studio-2017-versions-15-5-and-15-3/ Additionally, while we do get updates about static analysis somewhat frequently, the tooling story is still woefully lacking. The SA support that is there remains too false-positive happy, there's no talk about dynamic analysis (ASAN), and nothing along the lines of clang-tidy yet either. These things start to add up...
I've been interested in trying this for some time, but one of my blockers, at least on Windows, is cmake still doesn't truly support clang on Windows. They only support the clang\-cl via a toolset that uses the VS 2015 STL. It'd be great to see options for the STL to be made, as well as support for normal clang\+\+. There's a bug tracking this here: [https://gitlab.kitware.com/cmake/cmake/issues/16439](https://gitlab.kitware.com/cmake/cmake/issues/16439) And some work on a branch here: [https://gitlab.kitware.com/dutow/cmake/tree/clang\-gnulike\-support](https://gitlab.kitware.com/dutow/cmake/tree/clang-gnulike-support) But there hasn't been any updates in a couple months.
Which is the reason that `argv` strings *are* null terminated. Yes, you can't always give something you have as a `string_view` to a C interface, but we're talking about going the other way. So the null terminator is there *already*.
Ok, my last statement (copy assignment) is complete nonsense. Disregarding that, I'm still not sure where I stand on the 'single equality sign in conditionals'. Right now, when I see one it's a red flag and I look closer. If I stop having this reflex because it's a normal thing to do it can let subtle bugs slip by.
Fair enough. For me, having a type name there in front (or `auto`) is enough to make things clear for me; having your editor make typenames stand out helps. That said, I prefer braced-list-init over copy-init anyway, so it's a moot point.
10000 nested arrays break your parser: [https://gist.github.com/flopp/be098859e6bc612dda28e700966b15c8](https://gist.github.com/flopp/be098859e6bc612dda28e700966b15c8)
&gt; You might have seen or have used file(GLOB ...) before, please be advised that you should explicitly list the source files like the example above for the build system to automatically reconfigure CMake when you add a new source file. If you list your source files by hand, then the reconfiguration will happen because you edit your CMakeLists.txt to add the new file.. or is this an IDE feature? ^also_stop_GLOB_hate
Because you change the CMake file CMake will know that something changed. If you just GLOB everything, than CMake won't know that something changed, thus it won't rerun to include your newly added files.
Situations with Web and C++ are similar - standards are growing so fast and enormously that many implementers found them unable to keep up and only a few web engines and C++ compilers developed by large teams are remaining relevant.
Instead of setting the version variables yourself you can just provided it as after the optional VERSION argument of the project command which will automatically create CMake variables you can use https://cmake.org/cmake/help/latest/command/project.html
You are installing targets and so on into variable that is not defined and you don't explain what to define it to either. Well, since I am here, I am going to plug this instead: https://codingnest.com/basic-cmake-part-2/
At least in the past, one big advantage of compiling your product with multiple compilers was to easier find bugs in your software that may not materialize with a particular version of a particular compiler (UB and IB in particular) and to profit from multiple different diagnostic engines. This might be less of an argument nower days with better tooling (sanitizers and powerfull static analysis tools), but still, making oneself dependent on a single compiler seems like a bit of a gamble (although the current situation where you also have only a single supported compiler per platform is probably even worse)
Although still experimental, gcc 8 added a JIT compilation library that might be of your interest.
XL is not a bad compiler at all but it does not do much to make developers life easy. I remember many colleagues refusing to build with xlc for bluegene's power arch and instead use a gcc cross compiler, because many times valid code in gcc and icc was producing compile errors in xlc.
With that argument you can justify anything you do "somewhere, someone might find this more easier to understand than that". Again, if(auto value == get_optional_value()) would not compile, so why would someone assume that this was the intended code? At some point you have to assume at least a minimum of competence from your coworkers (or your future self) otherwise you can jsut give up right away. And if that hypothetical someone makes such assumptions, why wouldn't he assume that instead of if(auto value = get_optional_value(); value) you actually meant if(auto value = get_optional_value(); !value) because why else would that redundant expression be there? 
Comments under the post at r/programming discussed the potential sample bias. They used JetBrains channels, Twitter Ads and Google Adwords to reach respondents. Their main reports excluded JetBrains channels, but even coming from the twitter and google ads, I would assume that people familiar with JetBrains and their technologies were more likely to fill the survey.
The Qt has kind of similar problem like Microsoft. They name everyting Qt while Microsoft names everyring Visual. Names of each product are very similar and users run into confusion. Kinda surprised that Eclipse is higher than Qt, but in recent years it has got significant updates and has better built-in parser than the one in Qt Creator. Probably nothing can beat VS/CLion with ReSharper but Eclipse and Qt give the best free IDEs.
I was talking about the pointer returned by `std::localtime` i.e.: mutex.lock(); std::tm* my_tm_ptr = std::localtime(time_ptr); mutex.unlock(); //use my_tm_ptr is not safe. And yes, you should definetly do mutex.lock(); std::tm my_tm = *std::localtime(time_ptr); mutex.unlock(); //use my_tm Somehow I didn't think about that simple fix when I wrote the reply. But in any case you still have the problem that everyone, everywhere has to remember never to use an unprotected `std::localtime` (and of course it doesn't scale anymore but I doubt that is common requirement)
Qt Creator support Clang code model now (since 5.7 enabled by default). Clang is never wrong so the parser is great too. The only problem with it is it's performance, especially RAM consumption. Eclipse on the other side is still better at refactoring C\+\+ code though.
Great spot. I shall fix it.
You are right, I'll fix that. 
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8pipof/looking_to_learn_c_i_have_a_couple_questions/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I think so too. Doesn't gcc's "-Weffc++" even warn about single-parameter ctors not being declared explicit?
Not sure, what your post is trying to say. I was not advocating that those member functions should be named consistently and specifically they should not be called `get()`. I was saying that all the functions that are actually a abstraction leaks are not called `get`. So unless I see more examples where `.get()` is an abstraction leak than the smart_pointer.get() case (where I disagree that it is an abstraction leak in the first place) I will disagree with your original statement. &gt; .get() is a universal symbol of abstraction leak Imho it is short, catchy, sounds right at first look -- but is imho plain wrong and not supported by evidence. 
My point was: there is already an easier/ way to handle dependencies than e.g. 5-10 years ago. 
&gt; I find get() on smart pointers worth checking in code reviews. Sure, so are many other things. That doesn't make it a symbol of abstraction leak 
 I have a project named [SiriKali](https://mhogomchungu.github.io/sirikali/) and i use gcc to build windows binaries. Why arent more projects use gcc on windows? Most C++ projects usually ship with a C based API for maximum portability. 
This is way too much boilerplate. Maybe I should write a tool for generating cmake\-files one day. On the other hand I might as well output ninja\-files or makefiles directly or compile it directly...
I **really** don't think that a string view that includes a terminating 0 is normal; do you?!
Sure, I understand this. My issue was with the wording, but on third reading, maybe it only confused me ([...] add a new source file [to the add_library() call]). I am also on the side that globbing should just work (DRY), but barring that, I think that Probability(forgetting to put file in CMakeLists.txt) ~ Probability(forgetting to rerun CMake) (but I know that many people are in the anti-GLOB camp).
&gt; Probably nothing can beat VS/CLion with ReSharper Not having to buy a beefy computer just to run ReSharper 
Or not wanting to spend the money on the license
&gt; Eclipse on the other side is still better at refactoring C++ code though. Qt Creator still can't rename file in a project (you have to manually edit project file, file name and all includes)
I'm pretty sure you just have to go to the right build directory and type "make some_file.s" at least on Linux.
This article and comment thread really illustrates how much of a clusterfuck CMake is. Jesus...
You said it, man.
It depends on the build system you are using. You can't do it while using CMake, as this process just can not be fully automated when using CMake.
Really? Isn't Qt generating CMake files? Like, every time you build with Eclipse it regenerates GNU makefile
Really. Qt Creator can make a project, but it even can not automatically add new file to the project. Just checked: [http://pix.toile\-libre.org/upload/original/1528460486.png](http://pix.toile-libre.org/upload/original/1528460486.png) Notice: GNU Makefile are being generated by cmake, not by Eclipse. CMake files are just too complicated to be edited automatically. It has multiple versions and files can be included in several ways, not to mention pattern matching (you can write \*.cpp and it works). Of course Qt Creator could make support only for self\-created `QMakeList.txt` but if you create a project in Qt Creator, QMake or Qbs are default build systems. If it works properly in all situations in Eclipse, I'm amazed.
In works everytime in Eclipse, but Eclipse generates GNU make from it's project file - no intermediate CMake step (no support for it, maybe there is a plugin). The generation itself in Eclipse works seamlessly, it can also use wilcards and add non-source files. There are also pre- and post- build commands available + generation customization. The system is really good, but it is made specifically to work with Eclipse project files. No CMake support from the CDT core.
OK, now I see what do you mean. Qt Creator also is able to do all those things, but with QMake or Qbs projects. Only CMake projects is an issue :)
This is why I sometimes hate to work with VS. No other compiler has such problem.
It’s deprecated and unnecessary now, it seems. 
So I don't really get why I should use find\_dependency(), since I now have to put my public dependencies in 2 places. What I normally do is have a Dependencies.cmake file that I include from both my main CMakeLists.txt file and my Config.cmake file (it gets installed too). I normally define a variable before the include in one of the files that I can then use to do private vs. public dependencies. I get the same args to find\_package since it's the same calls and I only have 1 list of dependencies.
How so?
Yeah, I can't think of another tool that I've used for years that incremented a version and suddenly everything I've ever done is now wrong, and the new way is far more convoluted and confusing. 
Yeah. I’ve started to prefer meson. Like cmake is OK but it makes it way too easy to do the wrong thing.
Why is the constructor method call weird syntax? Does the author not realize that classes in C++ are just widths and initialization with 'new' calls whatever constructor is specified (or the default one if syntax is omitted)? This is like, the basics of how C++ works.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8pkdsf/i_want_to_learn_how_a_computer_works/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Just like c++
Took me a bit to figure it out, looking at later documentations for GenerateExportHeader it lists: &gt; This function is deprecated. Set the target properties CXX_VISIBILITY_PRESET and VISIBILITY_INLINES_HIDDEN instead.
I'm sure Raymond Chen is aware.
It's a macro to obey stuff like QUIET when your Config.cmake file is called from find_package. As for not wanting to write your dependencies twice, I'm sure you could use the PATH_VARS feature of configure_package_config_file() to automatically write those for you.
You don't need to do most of this stuff. This is just useful info for if you want to create a library so that other people can get it with the find_package() call. I did most/all of this for a library, and the main CMakeLists.txt is roughly 100 LOC.
Note: This comment _only_ applies to the `add_compiler_export_flags()` function from that module. The rest of the module remains valid and useful.
Pffft, real men pipe shell echoes to source files.
&gt;So why don't they have exactly the same interface, wherever possible? Why does std::optional have methods has_value(), value() and value_or() but std::unique_ptr does not? `optional` is just a wrapper around a value while `unique_ptr` is a wrapper around a pointer. You can return a `unique_ptr` with zero cost while returning an `optional` is either a copy or a move of whatever type is in the `optional`. As far as interface `unique_ptr` is similar to `shared_ptr` and a mostly drop in replacement for `auto_ptr` where `optional` is at least a little more intuitive.
I prefer this syntax to placement new. Why was it removed?
For people who just want to use small libraries, making them yourself often is the most difficult on c/c++ in my experience. Sure, sometimes you will build a Java library yourself, but they sometimes even contain their building program themselves. In C++ I had like 4 libraries that just spammed out errors until I had the patience to fix them myself and I think that's kind of bumming 
This syntax is terrible because it gives the impression that it's okay to use `-&gt;` on uninitialized memory. And it sort of goes hand in hand with people abusing `this` set to null.
So this is how you call constructors on uninitialized memory :) I was working close to metal and wanted to use some features of C++ and placement new/new would either have to be overridden or replaced in every class without proper support
Do we have some kind of guides for converting large legacy projects from custom makefiles to CMake? Like we sometimes see talks about adopting modern C++ features in legacy C++ codebases? I would be really interested to hear of someone who managed this even on a small project (say a few hundred shared libraries and a dozen or so exes) targeting a few different platforms. Management are really keen on CMake but the more I look into it the more sceptical I am that it will solve more problems than it engenders. It just looks really inflexible.
I dislike placement new because it can be overloaded (even if it is *technically* illegal to do so). Take your point about it looking bad to operate on uninitialized memory, but it's a special case which is symmetrical with the explicit destructor call. It's all moot anyway, as it's no longer valid. I was just curious as to the motivation behind it.
The thing is that I libraries are exactly what I am interested in. And if writing the build-file for a library without external dependencies takes more than 5 lines (which is already generous IMO), then the build-system sucks. It's not as if writing libraries would in any way be an exotic task.
Why is it illegal to overload placement null?
Very interesting article, l learned a lot about new CMake features. But I still don't understand why GLOB is bad. With GLOB I just add new files to the tree, clean reconfigure CMake and I can build. Otherwise I would have to type the new files in my CMakeLists.txt for the small benefit that I don't have to do a reconfigure. For me GLOB is the much simpler workflow. To be honest, GLOB was the reason I started using CMake, because I was annoyed to type new files in my makefiles. Am I missing something?
I see, haha yes! Couldn't agree more with you :-)
Pretty cool survey, the rest of it is nice as well, see for example "Key takeaways &amp; fun facts" and "Demographics"! Thank you JetBrains :-)
Well you can write a 5 LOC cmake build file, but with ~100 LOC I can do the following * Create a lib without globbing (better for speed) * Properly install it to standard (OS-agnostic) dirs, which the user can change * "Attach" the header(s) so they get installed/included * Define build/linking dependencies so we don't "poison" the end-users project with global settings * Require certain compiler features, like varidic temples, a std version, etc., and specify whether they're build-time only, or also needed when linking to the lib * Auto-generate a file that lets people easily find and link my lib with 2 lines of code * Auto-generate the version file so people can (optionally) specify a compatible version when finding the lib There's other things done in those ~100 LOC, but those are the main important bits. Of course adding dependencies or more source files will make the file grow, but it doesn't add much more complexity.
http://reddit.com/r/cpp_questions
It’s not that inflexible, but there are tricky stuff, that is true, especially when you begin to add custom commands/targets. But from what I remember when using Autotools it is not more painful... It is when you have to support multiple systems that CMake shows its real value, since its purpose is to generate platform-specific configuration. FWIW I currently work on a software (~20 devs) that was available on Windows only; we moved to CMake and now support Windows, Mac, iOS, Android, Linux. It was relatively painless. We also use CMake to compile/cross-compile our dependencies (eg. boost, cpprest...). 
The problem with GLOB is that it is evaluated at configure-time, so if you add a file it will not be seen by CMake unless you re-generate your build configuration. As you said you can clean then re-configure but when working on a large project this becomes really time-consuming. Also, just like you have to remember to mention a new file in a CMakeLists.txt, you also have to remember to re-configure your project.
No, the article explains this is an old and crufty way of doing things. Placement `new` is the correct way to do this going all the way back to C++98.
I agree for very very large projects, clean reconfigure could be much worse. I'm just very lazy at typing.....
C++ standard: &gt; §18.4.​1.3 Placement forms &gt; These functions are reserved, a C++ program may not define functions that displace the versions in the Standard C++ library. So, the compiler will let you define `void* operator new(size_t, void*)`, but you mustn't if you want to be compliant.
Btw, it's pretty "logical" in the way that you can do something like this: #include &lt;cstdio&gt; struct C { void foo() { std::puts(__func__); } }; int main() { C* ptr = new C(); ptr-&gt;C::foo(); ptr-&gt;C::C::C::foo(); delete ptr; } Output: https://wandbox.org/permlink/qD2hxXPa74i8zGO9 Reference: https://en.cppreference.com/w/cpp/language/injected-class-name 
I never said it was correct, in my setup calling placement new calls a pure virtual which crashes, this old trick allowed me to get a working build until we can get a proper libc/libcpp built for this metal platform until those are ready. 
Agreed, C\+\+ build systems are such a pain in the ass. When I write a library in Go, I have to write exactly 0 lines of build system code. It just works, and I put it up in a repository on Github (or other hosting site) and the tooling can find it. The next version of Go is adding build\-in support for versioning, so there will be a \`go.mod\` file you need to put in your library repo if it has any external dependencies to specify their versions, but even that is just one line per dependency. Meanwhile I've released exactly 0 C\+\+ libraries because I still have no idea what the best practices and tools are for releasing C\+\+ code for public consumption.
The class name injection might be "logical", but constructors don't have names, unlike your `foo()`.
Calling a pure virtual from a constructor is undefined behavior. Calling virtuals from constructors and destructors in general is recommended against because the runtime type of the object is not yet its final most derived type.
Huh. Seems like a pretty inconsistent rule. Thanks for letting me know.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8pm9gd/how_to_incorporate_a_driver_that_reads_in_xbox/e0cghs1/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
While using a single compiler might allow the early adoption of new features in production builds, you may lose the ability to experiment with new features that are only being shipped by the other compilers you won't be supporting anymore. It's a tradeoff and there's no absolute answer.
Yeah I don't think you are reading what I wrote at all at this point. So I just deleted it
The lack of symmetry between using placement new and explicitly calling a destructor is jarring, though. Perhaps we need a placement delete operator? Or perhaps a very explicit placement new/placement delete?
It's also a rule (like many others) that is oft violated in the embedded sphere.
Sorry, I'm kind of new to this stuff. A simulation of a computer? Is it similar to a program run in a virtual desktop like vmware? How is it different? Looks pretty neat, though.
I mean, you can call it a VM but it is not made to run Linux distros, Windows etc, or simulate a real PC. It is simulating a PC with custom architectures i made and thanks
This is totally something different.
How is \`std::optional\` C\+\+ feature? It's just a part of standard library, not a part of language. What is more, it was succesfully written for old versions of C\+\+ in \`boost\` library. So the terminology is pretty bad here.
&gt; Create a lib without globbing (better for speed) Globbing is a basic requirement from a build-system, if it doesn't have that, it sucks. &gt; Properly install it to standard (OS-agnostic) dirs, which the user can change A build-system should do that by default &gt; "Attach" the header(s) so they get installed/included I'm fine with that being one (1) of the five lines &gt; Define build/linking dependencies so we don't "poison" the end-users project with global settings I was talking about a library without dependencies. I'm fine with one additional line of a `target_link_libraries`-equivalent per target. &gt; Require certain compiler features, like varidic templates, a std version, etc., and specify whether they're build-time only, or also needed when linking to the lib In general the build-system should always ensure that the compilers use the latest released standard. If anything out of the ordinary is required I'm fine with one additional line to request a specific language-standard. &gt; Auto-generate a file that lets people easily find and link my lib with 2 lines of code A good build-system should not require any additional lines to provide that functionality. &gt; Auto-generate the version file so people can (optionally) specify a compatible version when finding the lib I'd say that the version might be one of the five lines. So, some example how such a file could look: project(foo, 1.2.3): lib := add_library("foo", "src/*.cpp", "include/foo/*.hpp") lib.add_dependencies(boost::whatever, bar, baz) tests := lib.add_unitest("test/*.cpp") tests.add_dependencies(catch) The third argument of `add_library` would be the files that are part of the public interface and `lib.add_unittest` would implicitly add `lib` as dependency for `tests`. For a straightforward library like this, there is no reason to be more complicated than that.
I looked around but dont get me wrong, i liked but even that i cant get clear a few things -You should make more clear the parts of the hardware and the software ones, because there are two completely differents parts -The examples are kind of basic, i will be more interested on the interrupts of the keyboard/networking working -Please, specify how and the way to make asm code for the project because i know assembler and if i enter in one of the .sal i see instructions that i had all clear like inc or clr but there are others that i only can guess, move.s?, div.u? Is the .s and .u refering to short and unsigned? I may think but it will be nice if you clarify it Awesome work and i hope you take my "critic" as it should, a constructive way because is how i wrote it, to help not to hurt
Of course, any feedback is welcome :) And yes, i do understand your points. 1) To what parts are you referring to exactly? I have some idea what you mean but i am not really sure. 2) Yes, i am aware of that and the .sal and .cbc are kinda all over the place right now but i am fixing that in the next commit or two and making specific relevant examples and tutorials how to use the features. Some of the programs in CPU\_Programs are even outdated and need updating. 3) There are Assembly Documentation.txt abd GPU Assembly Documentation.txt in Text\_Files folder but i think they can get some more detailed descriptions in them
That'd be great if it were that simple, but I haven't found something that automatically does all that stuff. If you know of a build system that does then I'm up to try it.
How is this on topic for /r/cpp?
https://wg21.link/p1008
Any particular examples? 
I think it is absolutely absurd we can just call destructors on random pieces of memory but that we have to include a header (```&lt;new&gt;```) in order to be able to call constructors on a piece of memory.......
If we compare to 10 years ago, didn't we had 1 less compiler (only gcc, Intel and Microsoft's compiler) since clang didn't exist. We never had a lot of great compiler for c\+\+. Or do I missed something?
Cause it's a C++ project?
Maybe you should write an article on how to do this, sounds like you really get it. 
How, pray tell, do you think the compiler 'knows which stack' to put variables upon when you're writing *kernel* code?
Thank you so much for the link. I have been looking for something like that ever since VS 2017 came out!
Is it? I don't really see anything about that in the description.
I had actually go and look this up, because I didn't believe you. While cppreference isn't clear on that, or I didn't find it, from playing around with my compiler, it seems you are right. Man, that sucks. Does anyone know the reasoning behind that?
I have considered making concise example repo's for different situations (lib, exe, dependencies, etc.), but haven't gotten around to it yet. Maybe soonish... One caveat is that because of the massive size of Cmake, I'm always finiding new useful features/variables that I didn't know about. That makes writing articles like this one difficult. As you can see, the OP got a bunch of recommendations on how to do things better.
I see your point but at the same time it's not like the subreddit's flooded with off-topic posts. It's not exactly flooded with anything, in fact.
It's like an emulator for a computer that has never physically existed. There are a few other somewhat\-similar projects that call themselves "fantasy consoles". "PICO\-8" comes to mind as an example.
That's true, but I like high-signal low-bandwidth subreddits.
Please post language questions to /r/cpp_questions
https://stackoverflow.com/q/38835747/1774667 -- it isn;t hard to create a smart method pointer that does `visit` for you. method mp_foo=[](auto&amp;&amp;self){return self.foo();}; then std::variant&lt;type_1, type_2&gt; var=/* whatever */; (var-&gt;*mp_foo)(); still requires some boilerplate, but it is minimal.
 target_compile_features(yart PUBLIC cxx_std_17) target_compile_options(yart PRIVATE $&lt;$&lt;OR:$&lt;CXX_COMPILER_ID:Clang&gt;,$&lt;CXX_COMPILER_ID:GNU&gt;&gt;: -pipe -march=native $&lt;$&lt;CONFIG:Debug&gt;:-O0 -Wall -Wextra&gt;&gt; $&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;: $&lt;$&lt;CONFIG:Debug&gt;:/Od /Wall /Zi&gt;&gt; ) Man I hate "Modern CMake". The ideas are fantastic but the language and syntax is easily one of the single worst things in the world of programming.
If you can help it avoid new keyword.
You're very lucky. I assume they knew you did not have C++ experience and that you were going to learn on the job?
Sounds like a great move! Use your first working day to work through smaller toy problems, second day, set up the company build environment, third day, start reading your project code and prepare to contribute? A hashmap is a hashmap, no matter the language. 
There are directions to approach C++ and you should do both: One is to focus on Modern C++ with the understanding that it deprecates a lot of classic complexity, but does not does not delete it. Ex: constexpr if() vs SFINAE. The C++ Core Guidelines are good for that. The other is to understand the bits and bytes of raw C. It’s still there under it all. Abstractions leak. You are running on an actual machine, not an abstract one. There are good guides for learning C. I don’t know them. But, a good C++ book for this is the classic *Inside the C++ Object Model*. It removes a lot of the mystery of how things work at the level of bytes. In Java Land, that kind of mystery is assumed to be a given and a Good Thing^(TM). Welcome to a new way.
Of course. I told them in the beginning. And convinced that I could learn quickly and perform the best I can. I am very confident about my learning skills.
You're welcome.
Donno what I would use it for, but it sounds like a fun project to work on.
Or at least for every new, there must be a delete (or passed to an RAII object that will delete for you).
Redistributing stdlibc++ headers and compiling and linking code on the fly may present some interesting licensing concerns.
We didn't have many great compilers until quite recently, but there have historically been [many *more* C++ compilers generally available and undergoing active development](https://en.cppreference.com/w/cpp/compiler_support).
Yep, I have a lot of war stories that involve XLC++, including a wrong code generation error involving TLS and how the linker would handle the compiler's output. Definitely not my favorite compiler, by a long shot.
That's rare among employers especially where I'm from. A week's a short time. This is my goto for anything C++ https://www.youtube.com/watch?v=IzNtM038JuI (and part 2). I revisit these two parts of the lecture regularly.
It's illegal to override `void* operator new(size_t, void*)`, it's not illegal to overload placement new. Overriding it means to implement a version of `void* operator new(size_t, void*)` different from the one provided by `&lt;new&gt;`. Overloading means to define `operator new` with different signatures, such as `void* operator new(size_t size, const char* file, int line, int column)`.
&gt;I am a Java dev with years of experience &gt;C++ Primer That book isn't really aimed at your level of programming knowledge. It's not a bad book, but it will take you a while to get to the useful parts. I would recommend Bjarne's *A Tour of C++* to get you familiar with the essentials of the language and Scott's *Effective Modern C++* to dive into the very important details of things like template type deducation, forwarding/move semantics, and lambdas. Getting accustomed to a language that has both value and reference semantics takes practice- especially when learning the implicit rules. &gt;But the problem is that I have zero experience (industry wise) in C++. If possible, could you provide some more description about the industry you are entering? There is very likely someone in the sub who also works in that field and can help you focus your efforts. --- I have a few ideas for helping you quickly transition to a more C++-oriented perspective (do with them what you will). 1. Learn the details of how classes work (It might seem silly, but C++ classes are very different beasts from Java ones). When are constructors, destructors, and assignment operators implicitly defined? 2. Prefer composition over inheritance. The lack of an `implements` keyword will take some getting used to. 3. Learn `std::vector`. Learn it well. Learn to love it. Learn to use it always. Then learn the other containers. 4. Show your [algorithms](http://en.cppreference.com/w/cpp/algorithm) some love, too! 5. You don't have to learn it all in one day! Just play with something until you feel comfortable using it, then move to the next feature. 6. Ask lots of questions. This sub is more for discussion of the language. /r/cpp_questions is for asking about code. Welcome to the world of zero-overhead abstractions! It's a curious land of fantastic expressiveness and dark corners full of Undefined Behavior. Be sure to bring a towel! 
Simulates circuits. Did you take circuit theory or maybe machine structures in school? It's actually not any different than vm from a theoretical perspective, but when we talk about vms we usually mean simulated byte code, whereas here we talk about simulated circuits. Both circuits and byte codes (GOTO model) are Turing complete so ultimately it's "the same" thing.
I'm going to go out on a limb and guess you've been brought in to help maintain a legacy code base. It's probably 15 years old or more and it's only a couple guys working on it? If so I wouldn't worry so much about the recommendations about learning modern C++ and avoiding 'new' and so forth. Your job will be to do things in accordance with whatever mess is established.
"nucleotide polymorphism......I ain't got a clue" - Sherman Klump, Nutty Professor 
Scott Meyer's Effective C++ series is a must read. Get used to reading disassembly in the debugger to get a real feel for what code is actually doing. Unlearn a lot of Java habits and be very cognizant of allocations. Memory management is very different in C++. You, as a programmer, are responsible for allocation and freeing memory, and a lot of that (like in Java) may be hidden from you in the code you write. Depending on the application domain, understanding what the hardware is actually doing may be important.
 `using a&lt;gregate =` Trying to drive me crazy? Fix that syntax, then I can read your code :| Thank you, clang.
You may also want to watch CppCon talks (from Herb Sutter or Bjarne Stroustrup for example ) and read : - https://isocpp.github.ioCppCoreGuidelinesCppCoreGuidelines - fluentcpp - preshing on programming - arne-mertz.de - https://www.bfilipek.com And lot others :). 
Fixed, thanks ;) For whatever reason my spellchecker is not working so I used some random website whitch messed up some stuff. I though I caught all of it, but it dosen't look like! I hope it's good know.
Not requiring your types to inherit from a class and still treating them in a polymorphic manner is intriguing, but as far as removing the indirection, isn't it only replaced by some form of switch case / hashmap / array indexing inside "visit" to find which method to call based on the variant's type\_id?
Avoid this and you'll be fine: `pMyLargeMemoryBuffer = null; // Free Memory` hint: that's not how you free memory in C\+\+. (true story, author was coming from a java) Seriously, be conscious of your memory management (do use unique\_ptr!) and the rest is nothing more than translating the containers you are used to, to std / in\-house versions. You'll still be learning in 10\+ years, so don't worry if you have to look something up on StackOverflow!
I mean, there is no real useful purpose for it since it cannot interact with a real PC, only other vPCs. Best thing to do is just have fun messing around with it and making programs ¯\\\_(ツ)\_/¯ 
Like no, just don't. If you know what you are doing sure, why not, but not otherwise.
I looked at the stackoverflow question, but I was not able to compile it. What are your \`method\` and his \`pseudo\_method\_print\` types? How can \`\-\&gt;\*\` access to \`foo()\` since \`var\` isn't a pointer and \`mp\_foo\` isn't a member function of \`var\` (so \`.\*\` doesn't work either). Can you please give a mininal working example.
&gt; I feel that it's probably over-engineering. welcome to the world of C++ my friend. the performance overhead is not quite as simple as counting vtable access. your variant uses a if/switch kind of decision logic, inheritance uses a vtable. in both cases you'll have a branch that involves branch prediction and might have a significant effect on your icache due to there being a multitude of branch targets (not all of them might fit into the cache). the first indirection to get to the vtable is not really significant. Performance of CPUs is unfortunately not this easy to reason about. A much bigger factor is code inlining, which is possible with the variant style and when you can inline code the reorder buffer in your CPU gets something it can work with, as well as the compiler getting many more opportunities for optimization. If you want to go into the details, you can tap into expert knowledge on youtube. it's an active research topic. A decade down the road C++ may get a clean solution to solve this problem, because runtime polymorphism is of course quite essential and C++ should be better at dealing with it besides the inheritance approach, especially since the OOP paradigm is marginalized in C++ often. Maybe reflection+metaclasses will make it possible to do this kind of polymorphism without gratuitous boilerplate. https://www.youtube.com/watch?v=gVGtNFg4ay0 https://www.youtube.com/watch?v=QGcVXgEVMJg if you are just looking for something that you can use, it would be a good idea to not bake your own solution, but use one ready-made that is mentioned in the above talks.
"Keep it simple". If you need to print Hello World, `"std::cout &lt;&lt; "Hello, World!\n";` suffices; there is no need for a templated output factory that can create output to any number of output providers, or generate output texts in any language, or whatever. Just keep it simple. You found your way to this group, so it's probably best to warn you now: the only people hanging out here are either busy working on the C++ standard, or writing the most generic-est, most zero-overhead-est libraries you could possibly imagine. None of them have the slighest interest in keeping things simple, so if you ask questions here always keep that in mind. You should get rid of that Java-thing where you allocate everything with 'new', avoid templates for now, and use exceptions from day one otherwise it will be a massive pain to put in later. Oh, and check out STL, it has some really useful containers like std::vector and std::map.
Just as a remark: compilers do speculative inning through virtual function pointers. I wouldn't dare estimating performance impact of one solution vs the other without benchmarking the concrete use case (code green with std::variant seems to be rather bad at the moment)
&gt; compilers do speculative inning through virtual function pointers. is that so?
This appears to be a (probably editorial) defect in the standard. Per [ISO Directives](https://www.iso.org/sites/directives/current/part2/index.xhtml#table017), "may not" in the ISO standard means "is not required to".
Expect to be shocked at how little of real-world required functionality the STL provides. Java's JRE spoils you.
awesome
Keep it simple. Memory management is the biggest difference. Use the stack more, and know the lifetimes/ownership of your objects. Free functions are just fine, and should be used. Use the standard libraries, especially vector, map, and unique_ptr. I found Effective C++ very good, but Modern Effective C++ is a bit too much. Good luck! I love C++, fwiw.
Careful with terminology. Both subclassing and insurance of `std::variant` are *dynamic* polymorphism, even if the latter uses static polymorphism (= overloading) to dispatch calls. The difference is that dynamic polymorphism dispatches calls based on the type of late bond values (i.e. determined at runtime). Whereas static polymorphism only uses the declared type (the variable's type rather than the value's type).
The other class of these, `_SCL_SECURE_NO_WARNINGS`, is slated for removal in 2017 15.8.
Prepare your Angus 
Unfortunately the Annex doesn't agree with our old _s functions, and it appears unlikely we could actually implement the Annex as standardized. Keep in mind these things are from the 2002-2004 timeframe of "Oh we need to fix all the security things, and the &lt;string.h&gt; functions are responsible for 90% of these exploitable bugs."
Seems to me that great progress was achieved at that meeting. Makes me optimistic.
No news about networking? 
/s
It depends on executors, which is still under work.
Thanks for the update! Do you know what the decision was on making std::span's index\_type unsigned or any of the other proposed changes to std::span?
There wasn't enough consensus to change, so the status quo remains. I was not a party to the discussions myself.
No consensus. Will be discussed further in San Diego.
Why so much verbose boilerplate to export installed targets? The build already knows how to install them, what they are, what dependencies they have, versions of everything. It's hardly surprising people often don't bother.
Current design of `std::span` is really weird in some ways :&lt;
Avoid new like the plague. Prefer value semantics whenever that is possible. Learn std::vector and learn the std::algorithms.
&gt; A future proposal along these lines may use an "adjective" syntax, e.g. `template void foo(Integral auto i)`. I weakly support this, if `auto` is optional, and preferably only if it's followed by &amp;&amp;. &gt; After the discussion, there was no consensus to continue work on 2D graphics in the C++ International Standard at this time; perhaps we'll revisit the idea a few years down the road. This is seriously disappointing. Being able to draw simple graphs on screen would be nice in Standard C++, without having to set up extra libraries for new_system_xyz.
Terrible news. I'm very interested in it too. Good to see some mention of timeouts there but the API is... odd. Is it expected that we specify the timeout on the socket's stream before each call to socket.connect() and socket.read()? 
I am also in the minority of those who would like a simple GUI in C++. Targeted teaching and for those who do not care to much about performance. Still I do understand the position of the committee and even agree with it. I hope Guy and the other guys working at the 2D proposal publish their work so that we could have it as a de facto standard for e.g. teaching. Qt and other GUIs are to complicated, to proprietary and to loaded with historical bad stuff to be the right GUI for this.
2D graphics is different from GUIs though. Nobody has proposed to standardize the later.
None of them are ubiquitous though. And AFAIK all of them are application-as-solution, and I think what might be a necessary solution to cover enough bases for it to become ubiquitous, is some kind of standardized repository format, so that vcpkg, conan, build2 and cmake-hunter could all retrieve libraries from the same place. Or of course, that any of the solutions just hits critical mass and becomes a kinda de facto standard. I just hope that whatever solution "wins" supports package versioning ([vcpkg does not AFAICS](https://github.com/Microsoft/vcpkg/issues/1681)) and is possible to use cross-platform (and probably a host of other things I can not remember right now). And I hope at least one hits critical mass, because I would prefer to handle all dependencies in projects the same way, and that is only possible if the manager has a lot of libraries available.
Have you seen estimate for Reflection? Conservatively, we will get it 8 years from now.
I love the fact that small fixes to simplify writing code are added: non\-type class tenplate parameters and explicit bool can and will make a difference when writing code. Of course, concepts and contract programming are also so welcome :)
Last nigth i was searching about networking and concerrency to see how it was, now i know, thanks for posting because i couldnt get the info, in fact i looked at isocpp and i was truly believing that networking will arrive with C++20 100% If anything cant make it for the next release dont worry, keep the hard work and thanks for doing it, one day i will join but i am not a guru and i feel i will disturb more than anything, only to make quorum but voting what others tell me because i am afraid of choosing wrong and hurting the comunity, i will voted yes to almost all and because most are delayed means i was wrong
When I read the `explicit(bool)` paper, the only thing that comes to mind is Stroustrup's "Remember the vasa" paper. Instead of having a language-wide reflection about *all* modifier keywords, e.g. `virtual`, `constexpr`, `volatile`, `mutable`, hell maybe even `public/private/protected` we are going to get fine-grained papers for every C++ feature, while we could get a single general thinking about making all the keywords in the language functions of constexpr values to enable complete generic programming abilities.
Well, I understand the concerns but asio is around so you can use it as a reasonable replacement.
Another question if you have time, any news about the SG14 proposals on std::expected, std::status\_code and std::error? I just want to reiterate, this is great stuff all around. Concepts, Contracts, and Ranges are going to be awesome as foundational building blocks, looking forward to it. Reflection TS too, if it gets implemented quickly by the popular compilers.
* ispow2, ceil2, floor2, log2p1 These functions are actually extremely useful for developing C++ math libraries. Currently many math libraries including my own implement these functions using bit twiddling hacks. I have 3 C++ math libs where I have my own versions of ```ispow2```, ```ceil2``` and ```floor2```. Can wait to get rid of that code and use the functions from the standard!
&gt; Why didn't constexpr-if become "constexpr-all control flow" ? Because `constexpr for`, et al do not have clear semantics?
Start small and work your way up. Start with a hello world, maybe some fizzbuzz Then try rock paper scissors Now try to read a CSV file into a matrix class ... Just try something bigger better than the last thing you made. Also, keep in mind that TensorFlow is HUGE, it took dozens (maybe hundreds) of developers years to get TF where it is right now, you won't be able to do that on your own. 
Great report! Was there any discussion on the static exception proposals or std::expected or is that a matter for a future meeting?
Asio doesn't support timers properly at all for sync operations, and for async there's a lot of faff with deadline timers. In reality, the timeout is set on the socket itself, yet neither asio nor the networking TS make this possible for some reason.
My biggest heroes of all time met only a few minutes away... So that's why I felt a disturbance in the force. Looks great, thanks for the update.
Actually I do not know how timers are handled in the TS. What are the differences?
I think everyone empathizes with this. C\+\+ seems to be making the slow crawl back to the kind of programming that was available with the various LISP dialects. But realistically, I think it's better that we get incremental improvements every 2\-3 years instead of going for another 10\+ year long period with little consensus, and then certain compiler vendors being slow to implement new standards when they do get finalized. No one wants to see that happen again. Maybe what we need is some genius to come up with advanced tooling and/or deep learning that could accelerate the process of language evolution in more or less rigorous manner?
In boost.asio you have to create a separate deadline_timer and add it to the ioservice. This TS seems to allow timed ops on the socket's stream, not on the socket itself
What are the applications of that? Deadline dispatching of stream data? No idea but would like to know a bit more. I am a lot into network programming and learning more as I go.
OMG... not that reflection proposal, please... It's hard to use, verbose compared to herb &amp; andrew sutton's value-based reflection proposal ...
Any word on making something like: constexpr i = 19; instead of constexpr auto i= 19; constexpr alone is enough to make things obvious
LEWG accepted the library bits; there wasn't enough time in EWG. Don't know about std::expected.
AFAIK EWG decided to use value-based reflection. But value-based reflection is a bit tricky in its current form due to some implementation issues, it is still heavily discussed in EWG and SG7.
No there wasn't. But I really don't see the motivation behind dropping the 'auto'. IMO it's unnecessary.
One doesn't need to be religious about not using new. I would say it also depends what kind of code/program you're working on. A shortly running app (or one that allocates all on startup as often in embedded) can do perfectly fine without delete, just let the OS clean up after return. And then there is placement new of course.
I have nothing about using new, but I would recommend that beginners not use it because they are at risk of abusing it. There are certainly valid use-cases of it.
not only does it have fairly clear semantics - basically, what you would get in a MPL library such as brigand::for_each, etc, but it also has a working implementation [right here](https://cppx.godbolt.org/)
We decided to make `span` SemiRegular and that is I think a sufficient and necessary fix ( short of nuking span , which was decided against )
Sure it does, it's basically forced loop unrolling.
The problem really is that the use of new requires rigor, every Jeckell needs to meet with his friend Hyde at some point, but other then that, there are few pitfalls (I'm excluding placement new here). I actually think it's not a bad beginner thing to learn properly (and then use with moderation). I learned C before C++, so I'm probably biased.
Can someone clarify the status of modules? Afaik there was a plan to merge the current state of modules TS into the standard, while working on additional features on the "TS-Branch", which then might or might not get merged into c++20 depending on time. Has this two step process been abandoned?
I'm completely fine with that, but it's pretty common that beginners learn to use new incorrectly (and placement new is never discussed), see also Java students who are learning C++.
I was able to catch part of [Herb's proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf), and it was well regarded by LEWG, and further work was encouraged. I don't believe SG14 met explicitly, as they do most of their work over conference calls.
It's fun how we have two replies "Sure is has clear semantics" where semantics they have in mind are completely different.
Name me a software developer that doesn't need contracts.
This paper is not (and was never) geared towards C\+\+20. LEWG (overwhelmingly) liked the direction, there hasn't been any in\-depth discussion, and no formal acceptance, yet. LEWG voted and agreed on two things: * We agreed that throwing on precondition violations is not a good general policy * We want to investigate the direction of terminating instead of throwing for Out\-of\-Memory (OOM) errors This opens the way for the discussion on Herbs paper, and similar work in this area. This also tells people who think that this is a fundamentally bad Idea, and that the status\-quo or some other direction is better to write well reasoned Papers soonish. 
People have described in excruciating detail the flaws with the existing proposal, and have suggested alternative directions the committee would be receptive to; yet no one defending the existing proposal can explain how it would be superior to a purpose-build library. Guy's proposal is already public and any are welcome to build a library from it. In fact doing so and gaining a wide following amongst teachers and students would be the only argument that would have any meaning at this point.
The trip reports for the previous meeting also mentioned its dependency on executors and the possibility that executors won't be ready for C++20. [Example 1](https://botondballo.wordpress.com/2018/03/28/trip-report-c-standards-meeting-in-jacksonville-march-2018/) [Example 2](https://www.reddit.com/r/cpp/comments/854mu9/2018_jacksonville_iso_c_committee_reddit_trip/)
As far as I can tell, /u/doom_Oo7 and I are saying the same thing in different ways.
Any insider updates regarding Coroutines TS? Where's the discussion leaning considering Core Coroutines? (ping /u/GorNishanov)
&gt; I am very confident about my learning skills. I'm sure you are. C++ is a mega-language, with bits in it that don't necessarily work well together. There are many many pitfalls. With C you can shoot yourself in the foot, with C++ you can blow you leg of. The experts (as there are many here, or the people from Boost) have spent 10's of years to get to the level where they are, and even they fall on their face sometimes as while they push the boundaries of the language actually hit to pitfalls more easily.
for the sake of precision, the `static / constexpr for` I'm thinking of works with tuples, e.g. for (auto f : std::make_tuple(1, 23.45, std::string("foo")) { std::cout &lt;&lt; f &lt;&lt; " "; } which has of course no other options than unrolling the loop for each type
I like the idea of extending NTTP to arbitrary classes ([p0732r1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0732r1.pdf)), however I am less thrilled at the execution. There are obviously technical issues at play here, and the authors of the paper using a defaulted `operator&lt;=&gt;` to work around them is a clever work-around... However, the resulting introduction of `std::basic_fixed_string` leaves a sour taste in my mouth to be honest. C++ already has: - C-strings, - `std::string`, - `std::string_view`. And the authors add `std::basic_fixed_string` to use strings at compile-time, a **4-th** alternative. This further split the ecosystem: any function which return a `std::string` cannot then be used in compile-time contexts, and instead must be copy/pasted and adapted to return a `std::basic_fixed_string` for this purpose, or made template itself (but deduction of return types doesn't work, so doing so would be a breaking change). :(
So you are describing a range-based for that is not based on range protocol (cppx uses tuple protocol, brigand::for_each seems to only works with a specific type). I think the difference between it and range-based for is much bigger than the difference between `constexpr if` and good old `if`. And how do you picture a constexpr version of traditional ("C-style") `for` statement?
You can't roll any networked app out that doesn't have timeouts. If some server you're talking to fails then your app will grind to a halt because it will wait forever for a response that will never come.
I presented expected to LWG again, they reviewed a substantial part of the wording, and I got extra out of hand review from one member. I’ll apply that feedback, update he paper, and ty to get more out of band feedback before San Diego. LWG is truly overloaded, so this takes time. The target is still a TS.
&gt; And the authors add `std::basic_fixed_string` to use strings at compile-time, a **4-th** alternative. They don't. Yes it's in the proposal for some reason, but it's not in wording that got accepted.
The TS was merge proposed but rejected. Maybe next time. Core Coroutines reached no consensus.
Because if you use gcc, you'll be using MinGW or something derived from/similar to that. You'll be working in your own eco-system (you'll be calling low level OS functions through MinGW stub libs). For C this is no problem, but with C++ name-mangling will force you to have a MinGW lib for everything. This means the Intel MKL library (number crunching) f.e. is not available to you, so for a number of people, this is not an option. Clang/LLVM has solved this problem, one can use either clang++ (with bash (msys) if you like) or clang-cl from VS. There is a (commercial) plugin though that allows you to use Visual Studio and gcc (it uses (bash) make-files under the hood. There is a good (very up-to-date) build of gcc (including gfortran, useful for blas/lapack f.e) from http://www.equation.com/servlet/equation.cmd?fa=fortran . I've used it in the past and it works very well. STL (one of the mods), also has a distribution, it comes with quite a lot of batteries included (https://nuwen.net/).
Actually, whether they do or not is of little consequence. The fact remains that `std::string`, `std::vector`, and most (if not all) current standard library containers will remain unusable in NTTP following this proposal, so that equivalent (but different) containers must be designed to be used in compile-time computations and as template arguments. This is, truly, the heart of my complaint. NTTP is good, but it further promote splitting the ecosystem between compile-time available and unavailable constructs. C++ is already widely unsafe. ODR is already widely unsafe. `#ifndef DEBUG` to define debug-only members is already widely unsafe. It seems to me it would be preferable to just jump the gun and allow user-defined `==` to apply here, so that `std::string` and al *could* be allowed as NTTP (if only in the future). Diagnosing issues with user-defined `==` would be left as a quality of implementation detail (at the very least, I'd encourage application to check that `x == y =&gt; y == x` each time an equality check is performed). And we would avoid further splitting the ecosystem along the compile-time line.
Thanks! This library looks very interesting. Any comparison with Intel TBB ?
These tutorials are amazing, the first one is really useful for just getting me up to speed a bit with more modern standards. My CMakeLists.txt file still had `add_definitions(-std=c++11 -Wall)` in it, based on lots of online tutorials. It is easy to understand, but now I get it when people say "You should really modernize that." Also, this new one on incorporating libraries is very helpful too! I've just begun using FLTK, make, and cmake, and this tutorial couldn't have come at a better time.
It's more controversial than I expected, but I feel people were interested in seeing Gor-Routines and Core-Routines find common ground, which if I followed was about * allowing more customization points to allow a greater diversity of coroutine implementations * changing syntax to operator-based instead of keyword based And to see how GorRoutines interact with Executors (still being baked). Specifically tricky things like what if you send a coroutine off to an executor and the coroutine is co_returns on a different thread it co_awaited on? Your thread local storage will no longer be the same, and since mutexes are thread dependent, taking a lock over shared data wouldn't work. Or worse a user just assumes coroutines can never context switch and takes zero precautions.
Not necessarily. There are proposals to make existing containers constexpr ([p0784](https://wg21.link/p0784). &gt; I'd encourage application to check that `x == y =&gt; y == x` each time an equality check is performed Which is near impossible to prove, or very expensive for a non-trivial operator==. The standard still has to say what should happen if this is not the case though, which would either be UB or IL;NDR. Neither of these options are attractive IMO.
Too long
I think it was the right decision. Did u read the paper from Google? I always felt also that the style for C++ is weird and it has far too many customization points. On my view, they should be function objects that remember where they stopped last time and the rest should go in a library as much as possible.
When you screw something up in Java you get a beautiful stack trace of exactly what and where it happened. When you screw something up in C++ you get a segmentation fault. Use a debugger, it will give you a stack trace.
I'm not really familiar with coroutines stuff, so I can't comment.
With the help of threads is that possible? I tell u bc I just wrote a client using aync write and connect with asio. And yes, I do not want it to hang forever. What are the alrernatives here?
Let me try (I was at the meeting). There were two votes as part of the merging effort: to work on merging Modules TS and the Atom proposal and to add a specific subset of the merged proposal into the IS. The first was approved while the second was rejected. To expand a bit on the part that was rejected, it was a subset that basically did not contain any uncontroversial/unresolved issues. Specifically, it did not have any support for the global module fragment, which means it would have only been usable in purely modular code (i.e., you wouldn't even be able to include `&lt;cassert&gt;`). I personally think it was a good thing it was rejected since it wouldn't have been usable for anything practical anyway. Note also that this does not necessarily mean that there will be no modules in C++20 -- if sufficient progress is made for the next meeting on the merge, it is entirely plausible that a new subset (or even the entire thing) will be proposed for IS.
&gt; Unfortunately the Annex doesn't agree with our old _s functions, and it appears unlikely we could actually implement the Annex as standardized. Ok so it is basically even more unusable than I even thought :p &gt; Keep in mind these things are from the 2002-2004 timeframe of "Oh we need to fix all the security things, and the &lt;string.h&gt; functions are responsible for 90% of these exploitable bugs." Well in the context it was arguably better than doing nothing. Also, it might have been adapted to migrating gigantic code bases and somehow mitigating the security impact of some bugs. But for new projects (or even maintaining legacy projects), I would never use that. Especially now that I know no standardized version will likely ever be available. 
We have finite resources. LWG members estimated it would take a full meeting's worth of time to get the proposal to a TS (and it wasn't even ready for their review). A full meeting of LWG time is 1/5th of the time they spend on new feature development for the next international standard. Which major feature would you want to drop from C++20 to make time for a 2D graphics technical specification?
Yah, I agree. I think we will remember it as a historic meeting.
It's not Core-Routines. It's Gro-Routines.
Some of us are still around. Where are you at?
What was the right decision?
Right is to not make it in. It requires escape analysis in the optimizer and has other drawbacks. Elliding allocations in practice, in Google paper's words, is challenging. There are more things why I do not personally like it, for example bc it puts a too big customization point hooked into the language. But my main concern is actually the likely performance and just drop the function object model that I think it is much easier to reason about and more familiar to C++. Of course, just my two cents.
I don't have my notes but I seem to think that paper was approved at plenary?
I have been hearing wrong the entire time. :)
No it wasn't. It was accepted by EWG and CWG now needs to review it.
I guess many people don't realize the huge effort required to write a specification that enables multiple implementations that work (and in the case of graphics render) correctly and without divergence (other than implementation details). It's not like the committee thinks certain features are not useful or not important enough. I typically work ~60-70h at a committee meeting. I believe everyone here puts in as much effort as (s)he can.
My understanding was Google was much less concerned about performance, and Gor mentioned his implementation has wide usage in Azure. I don't think there's anything in there that can't be fixed implementation wise, or presents a poor abstraction, and I know people want to be using coroutines today. Moreover this is just the current plenary. There's still one more to go, and the vote was very close.
Well, the Google paper mentions at the very beginning that it is NOT an efficient abstraction... so I do not know how concerned they are but it appears at the beginning of the paper. Anyway it is me who personally thinks also that a function object interface with all in library as much as possible would be better. But I do not have the depth of level of analysis that Mr. Gor has. My opinion is way more superficial, of course. And maybe many things, as you say, can be properly fixed for landing in C++20.
You work more than that :)
Thank you for the clarification. It's easy to lose track.
I wasn’t in that session, but from what I heard there’s consensus to look into transforming `bad_alloc` into a call to `terminate`.
me. I believe contracts are a bad idea for C++. 
Not to mention that LWG is very overloaded and often do an ungrateful job. I also heard concerns about portability of results: if the implementations don’t render the same thing then bug reports flow in. Overall many people expressed a desire to lean on other, established, standards and implementations. DPI independence, text, etc, aren’t an easy thing!
`std::string` returning functions wouldn't be able to be used in compile-time context anyway. Unless some form of `constexpr new` is formalized.
As well as providing `try_` versions of methods that allocate, like `push_back`, if you don't want to terminate.
Awesome, thanks for the update! I'm looking forward to seeing where that proposal goes.
That wasn't the question. Also, you provided no justification.
There is a refence implementation in existance: https://github.com/mikebmcl/P0267_RefImpl
&gt; Qt and other GUIs are to complicated Wrong. It's really simple and it's built-in quality documentation is great for teaching. I know that first hand, since that's how I've started learning C++. I've just started a course that taught C++ with Qt and in 4 months we were already writing simple fun games.
p0709r0 was not reviewed this week - it was just the parts about contracts and treating heap allocation failure specially that were presented to LEWG for directional guidance. I'm hoping the full p0709r0 will go to EWG in San Diego.
It would be very nice if we had some sort of wildcard option for the `target_compile_features` command, that included all the features of a given standard.
Which schools use it to teach?
`cxx_std_XX` where XX is the year.
&gt; Clang/LLVM has solved this problem, one can use either clang++ (with bash (msys) if you like) or clang-cl from Visual Studio. clang++ and clang-cl are just different front-end drivers for the same compiler, and they produce the same output. I.e., it's not the case that clang++ works with MinGW ABI; on Windows, Clang works with MSVC's only.
&gt; Which is near impossible to prove, or very expensive for a non-trivial operator==. I was not thinking of formally proving equivalence, but simply thinking that each time `x == y` is performed in the context of type-checking, the mirror check `y == x` could also be performed and verified to be consistent. Similar to what Java `sort` does [when it detects inconsistency in the supplied comparator](https://stackoverflow.com/questions/30678589/how-does-java-detect-comparator-contract-violation).
Cool. Thanks.
Yes, it's really unfortunate that it is not already formalized. I would certainly have favored the reverse sequence of events since we would not be left wondering whether introducing a new string class just to throw it way when `std::string` becomes usable (if ever) or not. It would be relatively simple too, since it's already been demonstrated to be feasible (and relatively easy) and it would also finally allow storing instance of `std::string` in ROM, rather than have a plethora of constructors executing each time the executable starts :x
Are contracts somewhat like how interfaces are done in c#? If so, that would be absalutly amazing. While this can be done now via templates and iterators, compile times get painful when having that massive hpp file included many times. C# has for example ienumerable which means the argument must satisfy an interface that supports enumerating over itself. I don't think it has fine grained versions like random access, forward only, etc iterators from c++, but I found it extremely useful and helpful for writing cleaner code. 
While it might be "enough", it's still good to define the other known features. Some compilers can "be aware" of C++11 without implementing XYZ feature. https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html
I would agree only if a feature that we have been waiting for for many years got merged, like modules or reflection. I don't see that in the report, but maybe you can clarify why do you see it as historic?
More likely you deleted it, because it was stupid.
I suspect it won’t take _that_ long. I’m hoping we’ll have a pretty good document out of SG7 within a year (constexpr-based, with simple reification constructs). Whether that will go first through another TS round or aimed straight at IS status, I don’t know but I’m hoping C++23 will have it integrated either way. (Of course, I may be optimistic here.)
No idea. I just wanted to point out that people who like Graphics TS proposal can start using it today without waiting for anyone to "build a library from it".
I've used Cpr, and I really like how simple it is, but the repo needs maintainers. There's some useful PR's sitting there unmerged, and no commits in 7 months.
The discussion in EWG produced a “consensus” to integrate Gor’s design. However, that consensus was not terribly strong, and the opposition was convincing enough to get several national bodies to block the corresponding plenary vote. (I’m personally hoping that Gor’s design or something like it will eventually make it as I think it is the considerably better approach.)
explicit(bool) had concrete and specific motivations as discussed in its paper. I think making an ambitious proposal that adds this syntax to all similar keywords would be rejected for not having enough justification as explicit(bool) did. It could also delay getting something usable early (what we just got) due to being too ambitious... However, I think your argument makes sense and it's possible that this will open the door to have a more general design for all keywords.
&gt; I think making an ambitious proposal that adds this syntax to all similar keywords would be rejected for not having enough justification as explicit(bool) did. Consistency is imho enough of a justification in itself.
I fully agree. I think that the reason is that it is meant to be as flexible as possible for `cmake.in` writers, but they could have as well a default solution for those of us who don't care (like `write_package_config_file`).
Use RAII. Don't use manual memory allocation unless you need to use a C API that forces you to use specific functions to allocate and release memory, even then don't mix memory allocation code with anything else: create a class to encapsulate manual memory management, use the Rule of 5 to make it follow RAII. Don't use smart pointers if you can use RAII and aliases*. Coming from Java you will be tempted to use smart pointers everywhere, but that will deny the performance advantages of C++ RAII. The std::shared_ptr should be used only to share objects between threads, otherwise your will keep coding like Java and you will hate C++ because it is not Java. * C++ documentation love to call aliases "references", but conceptually is better to call them aliases. In Java references can be tested for equality, stored, and changed to reference some other object. C++ aliases are more abstract since you can't compare them, store them, or make them alias something else. Use std::ref and std::cref to create a reference from an alias. Those references can be compared, stored and changed to reference something else. Null should never be aliased, and therefore std::ref should never reference a null. C++ supports const correctness, usually newcomers fail to see how helpful is that feature and see it as a chore. Don't be one of them, it is great for readability and allows the compiler to know more about your intentions. Immutable objects don't need synchronization between threads beyond using std::shared_ptr. Const correctness will help you to identify them. 
First, the answer to that question has a live example link. -&gt;* can be overloaded. Third, doing it for variant is much easier than for any. Most of the machinery is auto-writing and dispatching to a vtable analogue; `std::visit` does that for you for variant.
Good point
Thank you for the clarification -- I only made the end of the talk.
We've been waiting for contracrs for years, and non-type template parameters have been wanted by some people forever.
Yes, of course, never intended to say they were the same. If you use clang with msys, you are obviously still targeting MSVC's libs (not MinGW), but you could use make.
The counter argument (at least at one point) was that Qt wasn't idiomatic C++ (if you're teaching C++ not gui); ie. it has it doesn't use STL and uses a non standard meta object system.
Though I work hard on applications, I still have some raw loops. 
No -- preconditions, postconditions, and assertions. 
Not only should you use unique_ptr (or shared_ptr) instead of new, you should think twice before dynamically allocating objects in the first place - many objects in C++ simply don't need it and it adds complicated questions about lifetime to the code. 
C\+\+ and verbosity, while u can do something like `immutable i = 0` in D, I don't know why same can't be done fo`r constexp`r.After all, modern C\+\+ auto usage was from D.
It's not dropping `auto` completely, it's just that `auto` in `constexpr auto i = 9;` context makes little sense since `constexpr` alone is enough to infer type.
Here are some past discussions: * https://www.reddit.com/r/cpp/comments/6bt79c/what_is_the_best_rest_api_client_library_for_linux/ * https://www.reddit.com/r/cpp/comments/6hr46f/full_httpwebsocket_server_framework_c11/ * https://www.reddit.com/r/cpp/comments/60aswg/simple_requests_library_a_simple_library_for/ * https://www.reddit.com/r/cpp/comments/4o5zdm/a_good_c_or_c_honestly_so_long_as_it_works_http/ * https://www.reddit.com/r/cpp/comments/4945z3/what_is_the_best_c_webserver_framework/ Since those discussions, Boost started including Beast in its 1.67 release in December 2017.
+1, please give us some nice flow graph benchmarks :p 
Thank you for expressing my intention. I believe the low-level user interface is very much anti C++ with loads of opportunity to write wrong/bad code. Two-phase construction, raw new, non-STL containers, macroes.
Thank you for the clarification. I have not followed the proposal, but was simply in favour for the vague reason that I really wish for C++ that it be easier to teach.
It literally was the question...
It does use STL to some extent (i.e. to extent that is possible to keep its SC and ABI guarantees). Also, nothing stops you from using STL as much as you like in your code. It doesn't prevent teaching "idiomatic C++" since it's mostly subjective. In the real word no one would be writing pure "idiomatic C++", since all big projects invent their own idioms anyway.
Couple things. First, we need to stop using Vasa as a synonym for "thing I don't like." This feature is too specific and not worth the space, Vasa! This feature is too general and takes over the language, Vasa! Second, I don't think you appreciate the enormity of the change you are suggesting. Do you have _any_ motivating examples for making any of the other keywords/specifiers/qualifiers/etc. conditional? "Consistency" is really not a sufficient justification here. The only other one I can think of that has _any_ use is conditional `delete`. But that one looks syntactically absurd: template &lt;typename T&gt; void foo() = delete(/* something dependent */) { // something } Third, `for constexpr` is a very different construct than `if constexpr`, and it doesnt quite mirror `for` in the same way. It would use a complete different trait, and involve lots of template instantiations in a completely novel context. It's also not clear to me what either `while constexpr` or `switch constexpr` would mean. Which again - adding something because "consistency" is not sufficient.
I also mostly disagree with this. Something doesn't become better just because you replace `Foo * foo = new Foo(...)` with `Foo *foo = make_foo(...)`. Also, almost everything you've wrote applies to projects that one might consider to be and example of a very good and modern C++ codebase, like LLVM.
This might be subjective, but I find Sean Parents talk much, much better.
I love the way we are moving forward. Thanks guys!
Swift's "STL" is absolutely beautiful. Abrahams did an amazing job there. 
This person answered the question "are contacts a good idea?" That wasnt the question asked.
Seriously? The comment that was _directly replied to_ read &gt; Name me a software developer that doesn't need contracts.
I clicked for the `co_co_await` keyword, representing **co**re **co**routines. I was disappointed.
Last time I used it their model view architecture expected Q-containers as input/given as output. My information may indeed be old.
C++ is neither a subset nor a superset of C. The two languages are similar, however, and it’s not hard to get C code to compile under a C++ compiler. However, idiomatic C++ is very different from idiomatic C.
I'm guessing your question boils down to "which one should I learn?" The C syntax and library are basically a subset of C\+\+. You can feed most C code to a C\+\+ compiler and have it work with very little or no modification. That said, the way you write code in C is different from the way you write code in C\+\+. If your goal is to write code for microcontrollers (MCUs), then your choice of language might be made for you: some MCUs don't have working C\+\+ compilers. If your MCU vendor provides a toolchain and you're just starting out, I suggest you use that. I've worked mostly with ARM Cortex M MCUs using the GNU ARM Embedded Tools. The toolchain works well for me and includes modern C\+\+. But be warned: These tools don't come with a Wizard or easy\-to follow tutorial! To use them effectively you need to understand the different parts of the toolchain, including linking, loading, how your MCU boots, memory layouts, etc. I've seen a few tutorials here and there (like [https://gnu\-mcu\-eclipse.github.io/](https://gnu-mcu-eclipse.github.io/)) that can help you get blinky going (blinky is the "hello, world" of MCUs) but its easy for things to go wrong and get frustrating. If your goal is to write code for games, then your choice of language is a bit more flexible, though some of the big game engines are C\+\+. For small games with few different kinds of things on the screen (like pong with "paddles", "ball", and "score") you could use either C or C\+\+, but once you start trying to model game worlds, it's more natural to think of things in terms of objects, so I think C\+\+ is my suggestion for this application. Having said all that, if you just want use "embedded systems" or "games" as a vehicle for learning C or C\+\+ in the first place, I think you're in for a world of hurt because there are enough pitfalls in C and C\+\+ without the pitfalls associated with MCUs and games! And if your goal is to *create* something in the embedded or games space, there are programming languages and frameworks that don't impose such a high burden of knowledge on the user like Arduino and pyGame. My recommendation is to learn C or C\+\+ first (probably C\+\+) and then start to apply it to games and embedded.
If you learn C++ eventually you will wind up learning C. If for no reason other than you will have to read all the C code that people will write in your C++ projects.
Years with that company may be taking a toll on him. 
http://www.stroustrup.com/bs_faq.html#C-is-subset Might be interesting.
Technically C++ is all about Objects. But Java takes this to a whole other level. Kind of like how I might admire a cool looking train compared to a trainspotter. So, be prepared to tone down your object usage. If you have an object class that is 8 classes deep, then you are just programming Java using a C++ compiler. I have seen people making the switch get obsessed with things like Pure Virtual this and that to the point that they end up not learning C++ as they were trying to just do Java. Look at C++ in the same way C++ programmers look at C. It is much closer to the actual machine than Java by far. C++ has been marching further away from the machine but compared to Java it is very close. Then remember C++ has certain vices and virtues. It is really good at doing huge amounts of math work really fast. You want to slug through 50gigs of numeric data, and with some serious thinking you might get your C++ doing things that you wouldn't have bothered with in Java. But then you hit serious string manipulation and good luck. Or you hit something like endienness and you will find your brain pretzeled. Have fun and just remember that while it looks the same the entire philosophy is different. Just look at the two very different crowds using it. Java (or .net) is often 1000's of programmers working for a large corporation on a massive never-ending project. C++ tends to be small teams working on a "product" 
You should have put your answer into a templated form so that the answer could be used for all future questions. It doesn't matter that nobody could maintain it and that it takes 1 hour to grok what your 20 line function does. 
My guess is that anyone "new" to C++ in a job will be writing sub portions of a system and certainly won't be writing embedded. Thus, they should avoid new as much as possible. That said, I write embedded and long lived server stuff that allocates much on startup and keeps it forever and use news. I put in a comment for each and every one of them saying. Bad, but this allocation is here to stay. 
&gt; An operator-like token has two major advantages over an English-derived keyword: &gt; - An operator can more easily avoid tying itself to a particular use case, as co_await is tied to asynchrony. &gt; - An operator need not choose between colliding with existing identifiers in user code, or being so awkwardly spelled that no existing code uses it. It must avoid colliding with existing C++ syntax, but that’s a far more manageable problem Bikeshed objection to [&lt;-]: A pretty severe disadvantage is that it adds cognitive load to every use of the faux-keyword, because we have to parse a set of cryptic symbols in order to remember whether this is a lambda capture or a suspend point. Contrast this with "co_await". Maybe await isn't the best keyword because it excludes some use cases, but at least the word "wait" in the keyword implies that we'll be suspending, without having to think too hard about it. Another severe disadvantage is in new user experience. A keyword is inherently more searchable than yet another "pile of symbols" operator, and so it's inherently easier to research. I have the same two objections to "[] do" further on in the proposal. Since an identifier wouldn't be valid in that spot (i think), how about "[] coroutine"? I urge you guys to seriously rethink trying to make C++ even more of a "heap of indecipherable symbols" language. Non-bikeshedding thoughts: My biggest objection to the established coroutines TS is the problems of parameter capture: Pass by reference works as long as you pass objects that will live as long as the coroutine does, but I imagine that many C++ developers will pass objects by const-reference without even thinking about it, and be surprised when those references go bad. And lambda captures are just plain hard to think about when it comes to coroutines, since there's a lot of overlap between the concepts of parameter capture and lambda capture, but they're different in subtle ways. I have a few unanswered, or kind-of answered questions after reading the proposal. - I don't see an example in the code of actually suspending, such as in the case of waiting on a future. What does that look like? Do you have to call a library function to suspend? Write a new keyword? Does every use of an unwrap expression unconditionally suspend? [I think it's the latter, but I want to make sure]. - If you "unwrap expression" on a future, how do you imagine resuming the coroutine? I suppose if you're returning the future object to the caller, the caller can then do a ".then()" type thing on the future? - Do you have a vision for how to handle the common async use case of "unwrap expressioning" on an already-completed task? I suppose you could return the task to the caller, and the caller would be responsible for checking if it's done? - Do local variables of a coroutine have a stable address across suspend points? IMO this is something we should fight to keep, as it makes coroutines much easier to reason about, yet simultaneously I imagine that it's one of the main reasons why the existing coroutines TS is required to allocate. Overall this proposal does seem much easier to reason about from a library implementor's perspective. I've written a coroutine library for game development under the current TS, and from the library user's perspective it's great - but under the hood, there's so much code to write and dig through to understand why things happen.
That's still the case (though there are talks to changing some Q containers to std ones for Qt6 when there is a clear benefit), but their interface is STL compatible so you can use STL algorithms on them just fine. So you can use necessary Q containers for GUI side of things and STL anywhere else without much friction. It's a thing but hardly a negative one.
Note that the direction group recommended further work towards simple interactive graphical capabilities. So hopefully in some future...
The type-based reflection TS is useful to gain experience about the granularity of available reflective info. SG7 already agreed that it’s not the way forward for the IS (and instead we’re working toward a constexpr-based system). This week EWG approved the needed constexpr extension (particularly, “immediate functions”, improved constexpr allocation, and constant-evaluation-context query). I expect San Diego will see the first serious discussion of the reflection proposal itself. (We’ve got the design mostly worked out.)
No, modern C++ auto usage was not from D. It first appeared in prototypes of the Cfront compiler in the 80s, well before D was started. 
What was th discussion concerning the “Deducing This” paper http://wg21.link/P0847R0 It seemed like it would have really helped in reducing the boilerplate when having const and r-value member function overloads 
One more unanswered question: how does this handle the "initial_suspend" idea? For game development, I want tight control over when during a frame my coroutine resumes - and so if I start a coroutine, I don't want to execute any of it right away, I want to hold it until the correct point in the frame, and then resume it. If the coroutine unconditionally runs until the first suspend point, things will run at an unexpected time in the frame. Does this proposal have control over this kind of thing? This proposal looks very similar to Rust's async RFC https://github.com/rust-lang/rfcs/pull/2394 In Rust's model, the thing tagged with "async" doesn't ever run until you explicity resume it. So if you write this: async fn print_async() { println!("Hello from print_async") } Then nothing will happen until the first call to poll(). But if you write this: fn print_async() { println!("Initialization part"); async { println!("Async part"); } } The initialization thing will be printed immediately, and the second print call will only happen on the first poll. Am I wrong in thinking that this (C++) proposal trivially supports the same pattern as rust for "run until the first suspend point" thinking, via the [] do syntax? 
When the standards committee gives us a replacement for macros, maybe we'll start seeing less macros. 
constexpr isn't forced anything.
explicit(bool) does simplify the language. When library has to invent pseudo\-keywords to do things that is not simplifying the language. That was an easy thing for Core to fix, and they did. &gt;Why didn't constexpr\-if become "constexpr\-all control flow" ? Because the intent was to replace tag dispatch with something said more directly in Core. None of the other control flow operations need to be constexpr because none of the other control flow operations intend to create regions of code with statements that were otherwise ill formed. A for or while would essentially always need to be well formed except for the if cases (loop never executes). A switch would probably have been reasonable, but that's a lot more difficult to specify which statements need to be well formed when when fallthrough is involved. Constexpr if solves all the problems that paper was looking to solve. &gt;Basically, the way it works is that since "large" papers are generally not-well-received, we can't ever get a coherent, global vision on the language. I think that has more to do with "large" papers touch large numbers of things, and thus are more likely to create disagreement with one or more national bodies. They also tend to be Core changes, and Core changes are always somewhat more contentious because you can't ignore them. Don't like a type in the standard library? Don't use it. Don't like something in Core? Too bad.
Hmmm a close approximation of this can be done with just Library tech today. Core might be able to do it now that structured bindings are in. I guess all I can say is, papers welcome?
Good luck inventing a name mangling scheme for non literal types :)
&gt; Well in the context it was arguably better than doing nothing. That's all I'm saying. I'm not arguing for the _s functions specifically other than that I hate NTBSes with the fire of 1000 suns. &gt; But for new projects (or even maintaining legacy projects now), I would never use that. Sure, but probably because good string manipulation can't happen with NTBSes, so you're using some kind of string structure anyway :)
Conspiracy theory much?
The proposal from the direction group you are referring to has never been voted on or adopted by the committee. The committee took three votes on whether to proceed with graphics. All three votes failed. I don't want you to get your hopes up. We are not pursuing graphics any time soon.
Which book do you recommend to learn C++ best practices like as you mentioned to avoid the keyword new, to use nullptr instead of 0 or null, etc?
Another one that fails (as of 15.7.3) : #include &lt;type_traits&gt; template &lt;typename Factory_T, typename... Types_T&gt; struct foo_t { static constexpr bool foo = (std::is_base_of&lt;Factory_T, Types_T&gt;::value &amp;&amp; ...); }; struct A {}; struct B: A{}; struct C: A{}; foo_t&lt;A, B, C&gt; f; =&gt; foo.cpp(5): error C2059: syntax error: '...' foo.cpp(11): note: see reference to class template instantiation 'foo_t&lt;A,B,C&gt;' being compiled foo.cpp(5): error C4430: missing type specifier - int assumed. Note: C++ does not support default-int 
That's basically tuple_for_each, f.ex. from Mp11: https://www.boost.org/doc/libs/1_67_0/libs/mp11/doc/html/mp11.html#tuple_for_each_tp_f
Well I'm just starting to hate them, hopefully in a few years I'll hate them enough to avoid them completely. Although given poor language model support for strings literals other than NTBS (or maybe it could be solved by quality of impl?), structured strings can sometimes have insane bloat impact in non trivial programs (for ex if you want to have some in headers). Oh maybe string_view solves that also, not sure. 
Before the meeting, it was decided to prioritise all the stuff which is for C\+\+ 20, and leave off anything not squarely C\+\+ 20 focused. During the meeting, I got the reference implementation for P1031 *Low level file i/o* fully working with proposed P1028 `std::error`. I also got the nod to start writing the draft TS for P1031, which most interestingly I believe will be the first TS to use P0380 *Contracts*, the first to use P0709 *Deterministic exceptions*, and the first to use P1028 `std::error`. The aim is for the TS to enter the C++ 23 IS, but much hangs around P0709's progress.
Andrew left Microsoft. I am eternal, but I'm not a compiler dev, so can I ask you to file compiler bugs through [Developer Community](https://developercommunity.visualstudio.com/)? Click on the C++ tab there.
You mean like [More constexpr containers](https://wg21.link/p0784)?
Short version, the motivation is good, the problem should be solved, but with a more palatable syntax along the lines of `template&lt;typename Self&gt;void foo(int) Self&amp;&amp; self {}`.
Whats the downside of library approaches? GSL and many others have expect()/ensure() functions which standardize the design without adding new syntax. 
Try Juce library - its easy to use and has all the basic stuff. 
Haven’t compiled any detailed comparisons yet. Good idea tho
The advantage of the other syntax was you could do some cool stuff like recursive lambdas and CRTP without templates. 
Embrace and extinguish?
Yep. Something like that. 
I had Juce in my mind as the next GUI to try, and your comment just reinforced my guess that Juce is a good GUI library available for standard GUI stuff.
Honestly, I think current development of iso c++ is happening slower than in the 03-11 time frame
I'm lukewarm about contracts. I think static exceptions would be more helpful.
You should definitely give it a try... I have tried Qt, Cocos2d-x, multiple fully-functional game engines for my basic 2D GUI stuff... Everything was messy, overloaded or underdeveloped. I am now using it for desktop GUI, but will port on mobile ASAP. And they have a Projucer toolkit, which is a decent replacement of QMake build system of Qt - it generates project files for your IDE of choice, based on a single file. It also supports continuous code modification during runtime simulation, so you can rearrange elements on the screen through the code during runtime..
I can see reasons for LLVMs usage of weird constructs. But the reason that QT uses those constructs are mostly because it is a very old project and has decided to preserve backwards compatibility. At least that is what Lars Knoll has stated in public. I can understand and even respect that decision. But it is one reason that QT is unfit in a teaching context. Another one is the QT license. 
I'm lukewarm about contracts. I think static exceptions would be more helpful.
modules using dlopen?
In some places yes. In others, they are just different. I.e. STL has no COW containers, while in Qt most of them are COW, which is relied upon in several context. Also, they have a strong backward and forward ABI guarantee, which is nearly impossible to do if you expose almost any STL class (there are some exceptions, like std::pair) in your API. And I'm not even talking about QString which is just leaps above std::string in usability. I don't think they are weird. They just provide different value. I don't see how that somehow makes them bad or how it makes Qt unfit to be used as a teaching tool. It doesn't make teaching STL any harder, but it makes teaching C++ as a whole with a good and fun GUI apps easier.
That would be coo_coo
'C++ Coding Standards', by Herb Sutter and Andrei Alexandrescu. It's a distillation of maybe 4 books of Herb Sutter's "Exceptional C++" series, so it's drinking from a firehose, but you can't go wrong with it. Also, maybe, "Effective Modern C++" if your new place lets you use the latest version of the language. If you're more of a newb, Scott Meyers' 'Effective C++' and 'More Effective C++' are good, solid advice, especially the first. 
&gt; I don't see an example in the code of actually suspending, such as in the case of waiting on a future. What does that look like? Do you have to call a library function to suspend? Write a new keyword? That's the first example in the appendix, and also the running example in the "Coroutine functions" section. The "wait on a future" part is an unwrap expression on the future returned from some API function, e.g. `[&lt;-]connection.Read(buffer.data(), buffer.size())`. &gt; Does every use of an unwrap expression unconditionally suspend? [I think it's the latter, but I want to make sure]. That's determined by the implementation of `[&lt;-]`. If it immediately tail-calls back into the coroutine, the unwrap expression doesn't suspend (or alternatively- it does, but is immediately resumed). If it stashes the coroutine and suspend point somewhere and returns, the unwrap expression suspends and can be resumed later. &gt; Do local variables of a coroutine have a stable address across suspend points? From what I understand, yes. The "Expository implementation" section gives the anonymous type deleted copy and move constructors/operators, and it hints that `make_future` would do a `make_shared`-style allocation of its argument. Ideally, there would be no allocation for coroutines called by other coroutines (and their state blocks would be in their caller's "stack"), and there would be one allocation for top-level coroutines launched on executors or whatever (and that would contain the whole "tree" if it's non-recursive). I don't know that the paper addresses this ideal, but it seems possible? If not and it just leaves it up to `make_future` et al to do or not do the allocation, that's still slightly better than the TS in the sense that the library author *can* bypass it.
string utilities! Geez!
I can’t imagine the committee could standardize the handling of DPI independence at this time considering it’s not a fully solved problem in many frameworks and operating systems, and it would be a shame to standardize something without support for it. 
You can still do that with this syntax.
Why anybody isn't mentioning nana? I think nana is a prime gold example for a modern C++ API GUI library. It's simply amazing and elegant
Why anybody isn't mentioning nana? I think nana is a prime gold example for a modern C++ API GUI library. It's simply amazing and elegant
First of all, don't overdo the free function thing. I wouldn't use ideas likes "good practice" or "bad practice" - it just leads to cargo cult programming. Second, it sounds like you just want overloads. Define `connect(WifiFi&amp;)` vs `connect(3G&amp;)`, and if you have generic code, template&lt;ConnType&gt; void do_something(ConnType&amp; conn) { // ... connect(conn); }
Did you try running gdb on the code that shows this behavior? The sanitizers can screw up the locations in the debug info, so seeing if it works with gdb is a good way to check if this is the case.
&gt; Bad, but this allocation is here to stay. LOL. I wish somebody would give me a job in C++ without (job-)experience. I'm writing C++ (11/14/17) on a daily basis for at least 8 years. It seems unfair, but heck the world's unfair, so nothing new.
&gt; My recommendation is to learn C or C++ first (probably C++) and then start to apply it to games and embedded. I would recommend learning C++ first, based on my own experience of doing the opposite. It took me a really long time to get my head around (now) simple things as classes, just because it was so alien. Recently I started a project and decided to write it in C. The result was very different from what I would have written all those years ago and I found that it's easy/possible/good to adopt things from C++ (f.e. a vector "class" using 2 levels of macros, one level for the "methods" and one level for the template parameters, worked a treat).
The contract is a part of the declaration, so it's self documenting. Otherwise you'd need to look at the implementation or trust the English.
&gt; Do local variables of a coroutine have a stable address across suspend points? &gt; &gt; From what I understand, yes. The "Expository implementation" section gives the anonymous type deleted copy and move constructors/operators, and it hints that make_future would do a make_shared-style allocation of its argument. The reason I'm worried about this is because of this: &gt; If it stashes the coroutine and suspend point somewhere and returns, the unwrap expression suspends and can be resumed later. "stash it somewhere" to me implies changing its address. In the appendix future example, the "struct resume_promise" type stores a value of the opaque SuspendPoint template type. Is it clear to you what this type is? It isn't to me, but I may be missing something. * It seems like it's a compiler-generated type, one for each spot that the coroutine suspends? IE the compiler will call this function at each suspend point, giving it a different template. * If everything above is correct, that implies to me that this type contains the actual values of variables that live across the specified suspend point. * If everything above is correct, then they must have been moved from their original location, right? It's not like you're given a pointer to an original memory location, the code just `new`s a new instance of this promise struct, so the data goes wherever the allocator says. * If everything above is correct, when the coroutine is resumed, what happens to this struct? Is everything moved back to the original memory location? If so, how? It looks more like it just calls the function and leaves the suspend point struct at its current location. And if it really is moved, why not just leave that data at its original location instead of moving it around? ***I'm obviously making a ton of assumptions here about this works, but the only conclusion I can draw from this example is that objects don't keep a stable address across suspend points, and it looks like non-movable types are flat-out not support.*** Can anybody else help me out here? Am I just missing details from the paper, or is the paper missing the details? IMO it's a dealbreaker for this proposal if the address of an object changes from before the suspend to after.
It's noted. Thanks you.
How bad? Are we talking like "It'll add a few extra milliseconds to this operation" bad, or "this is going to take an extra minute/hour" bad? I think unless your program needs to be super fast, the benefits described in the article are worth a small hit.
I actually never knew that there was under-the-hood benefits as well, I just had it hammered into me by teachers that using const wherever I could is best because it makes it easier to understand. People can always know instantly if a variable can change or not. It lets people "disregard" variables that can't change while debugging, for instance. But yeah, after seeing such a massive difference, I'm definitely gonna keep doing it.
&gt; "stash it somewhere" to me implies changing its address. In the appendix future example, the "struct resume_promise" type stores a value of the opaque SuspendPoint template type. `SuspendPoint` may be an opaque type but it's also known to be round-trippable with `size_t`. It does not contain the values of variables, only the location of the unwrap expression in the coroutine's control flow. The values are stored in the `Coroutine` template parameter type, which is the type of the lambda-like expression. This object is the thing that's made non-movable in the example, and the thing that `make_future` allocates.
U heard wrong, not even in C++98 days. C++ is moving away from C with every iteration.
Yep, this will be actually useful in that microcontroller niche, since there are lots of C code
&gt; Am I wrong in thinking that this (C++) proposal trivially supports the same pattern as rust for "run until the first suspend point" thinking, via the [] do syntax? That sounds correct. The `[] do` expression shouldn't execute anything until it's called. The wrapped version (e.g. a function that returns `make_future([] do { ... })`) could set things up either way, though- the idea seems to be to preserve the same flexibility as the TS, of letting you use either "run until the first suspend point" or "wait until the first poll."
I definitely prefer Cpr to the top link returned in the google search. That's why I wrote this article to bump it up in google ranking.
You're right, thanks for clearing it up. I suppose the template paramerter still needs to exist, because the template parameter will statically determine which suspend point to resume from?
I agree with the author, P0528R2 seems like a bad idea because 1. The CPU can't possibly know which bits are padding, and 2. the compiler can't know whether a struct `T` defined somewhere will be used in `std::atomic` in an unrelated compilation unit (thus _conditional_ packing or zeroing of `T` -- depending on whether it's used in `atomic` can't work.) One viable "magic" solution I can think of is that the compiler _unconditionally_ zeroes out padding bits when allocating a `T`. This zeroing can be restricted to types smaller than the largest available atomic operation on the architecture. Another one is that cmpxchg zeroes padding of both arguments before doing the actual operation, but since one of the arguments is in memory, this incurs possibly even more overhead than zeroing out padding of `T` during allocation. Basically, I agree with the author: it's the _user's_ responsibility to carefully lay out `T` and `atomic` should `static_assert` that `T` has no padding bits and continue to use `memcmp` for equality. 
Yeah, though I think it's purely an optimization. You could make them all a single type and it would just mean a few more switches at runtime.
Why do we need `bit_cast`? Can't they fix / extend `reinterpret_cast` so that it actually behaves according to its description: "Unlike `static_cast`, but like `const_cast`, the `reinterpret_cast` expression does not compile to any CPU instructions. It is purely a compiler directive which instructs the compiler to treat the sequence of bits (object representation) of expression as if it had the type new_type. " [taken from cppreference] Specifically: 1. Bless it as not suffering from aliasing rules 2. Make it accept non-pointer arguments (e.g. `auto x = reinterpret_cast&lt;int&gt;(3.14f)` should work)
As I went back and read the paper with a better understanding, I realized that it looks like you have to allocate a new promise at each new suspend point in this demo? `make_resume_promise` allocates, and is called from `operator[{#^^={&gt;]()` First of all, am I misreading this? It wouldn't be the first time I misinterpreted the paper in this thread, but it really looks like `make_resume_promise` allocates at every suspend point. Assuming I'm not misreading, given that this whole proposal exists to reduce the necessary allocations for a resumable function, it seems like a pretty big missed opportunity to include an example that has one allocation per suspend, while the coroutines TS has exactly one allocation for the entire coroutine. Is it even possible to write a dynamic dispatch coroutine that only allocates once? * If you can cast SuspendPoint to a `size_t` as the paper says, I suppose you could cast it and store only a size_t, without an template parameter for the SuspendPoint type. But once you cast away the SuspendPoint type, how do you get it back? * Do you even need to get it back, or is the size_t sufficient? * If the size_t is sufficient, then I would guess that resuming a coroutine with a size_t would involve dynamic dispatch, but resuming it with a templated SuspendPoint object would result in static dispatch? * If a size_t isn't sufficient and you *must* have access to the SuspendPoint template type in order to resume the coroutine, I guess an important question that isn't clear from the paper is, is there one SuspendPoint type for each coroutine? Or is there one SuspendPoint type per usage of `operator[#%$^#]()`? * If there's one per coroutine, then it seems straightforward to make the `shared_coroutine_state` type templated on this type, instead of the `resume_promise` struct, letting us get away with not allocating the `resume_preomise` at every suspend. * If there's one per suspend point and it's required to resume the coroutine, I can't think of a way to get around allocating `resume_promise`at every suspend point. Hopefully I just missed something in the paper and the answers to these questions are obvious.
&gt; There is no standard way to read a directory. To open a socket. To open an http connection. To do real thread programming. It's true these couldn't be done in 2000, but the point is that in 2000 it wasn't expected; now it is. I'm not sure I follow. Thread programming is definitely here and it's fantastic. Lots of the standardization efforts went into unifying concepts across different CPU architectures, and OS concepts follow on the back of that. We also DO have a way to read a directory. So of the things you mentioned, only sockets is missing (HTTP is not distinct from a socket).
Presumably there is a really good reason for avoiding T::operator==? 
This is an old problem, known as the [expression problem](http://wiki.c2.com/?ExpressionProblem). Eli Bendersky has an excellent introduction on this [here](https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions/). As you noted, advantage of inheritance is that it is open. You can add additional datatypes easily - just define a new class. However, lets say you want to add a new method to your classes - `void bar()`. Now you are in a soup, as you must must modify all the classes in the hierarchy, some of which you may not control. The variant solution is the other way round. You cannot add new types easily, but you can add new operations very easily. The boilerplate is because C++ doesn't support sum types natively yet, but it is coming. There are several solutions to the expression problem. One solution is multimethods, methods which can dispatch on multiple virtual parameters. There has been some work on multimethods in C++ (I seem to recall a paper by Stroustrup), but nothing has been proposed for standardization yet.
I understand why strict aliasing exists, but it seems like a rule made to make life easier for compiler writers instead of users. I think the user-friendly thing to do would be to make `-fno-strict-aliasing` behavior the default, and to finally have `restrict` pointers and references in C++.
I don't agree with a couple of your points. * Template tricks are not only useful for hobbyists and people in academia. They enable nice library interfaces that are then useful for everybody. They are also useful if you want to create a library with a nice interface. Our (company) libraries have a couple libraries which use a lot of TMP, so yes they are harder to maintain, but all their clients are easier to maintain so overall it's a win. * Just because feature A doesn't get done doesn't mean feature B hits sooner. If people can't agree on how something can be done, no amount of focus will make it move. * Also, if they can't agree and you just pick one way, chances are a good portion of users will call the feature "not useful" because it is not implemented in the way they expect. The chief architect of Java called serialization (as done by Java) a horrible mistake and they plan to redo it fresh ... people would like to avoid situations like that. * Directory traversal and sockets were pretty common in 2000 :) Threading wasn't as necessary because CPUs still were scaling from making them faster instead of getting more cores, but the interfaces to that didn't change that much Don't get me wrong, I'd like to have reflection and all that stuff, but if it's another &lt;locale&gt; it might as well be a library that doesn't exist.
&gt; Standards too need to be questioned. Yet he doesn't participate in standardization work, as far as I know...
This will require to mark almost everything as restrict to allow even basic optimizations. Aliasing is actually very rare so 'assume no aliasing' is a convenient default.
Ranges hasn't been officially merged yet, but after this meeting it's as close to a sure thing as you can get.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8puo8u/how_similar_are_c_and_c/e0f84l2/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
It's mostly a legacy thing: https://blogs.msdn.microsoft.com/oldnewthing/20080325-00/?p=23013/ Windows is pretty old, if it had been designed today it'd be much easier to understand.
I couldn't agree more. One thing I personally find very disappointing: modules is still not guaranteed for C++20, even though speeding up our compiles would be the single most important contribution to productivity we could have. It doesn't even seem to be a priority. Worse: new libraries, such as ranges v3, are so heavily templated that compiling them takes significantly longer than equivalent STL code, so if anything we are moving backwards. Not to mention all those "header only libraries" that swap a single five minute installation job for an unending number of times you pay for additional compile cost. I also believe the focus of language development is far too strongly on performance now, with zero consideration given to things like simplicity and usability. C++ should not aspire to be the fastest language nobody knows how to write anything in. 
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
[You forgot again.](https://www.reddit.com/r/cpp/comments/8ltamv/this_subreddit_is_not_a_bug_tracker/dzjllh6/) :p
Thanks for the explanation and I'm very sorry to hear that. I might be a bit fatalistic here, but c++20 might be the point where I finally loose faith in the ability of iso c++ to move forward with sufficient speed to remain interesting for new projects. If people want to tailor it around their needs of their legacy software, then maybe c++ should be considered just that: A programming language for legacy software.
No it's not. Consistency is often used as justification but always in conjunction with something else like "it's obvious", "less boilerplate", ... Why in the world would you want to have a conditional virtual, mutable or even constexpr?? Explain that and provide examples how this improves code we have today and you have a valid proposal (and you're allowed to use the consistency argument). Just allowing stuff because of consistency is bad because it opens up features that nobody will use and might lead to unreadable code by people who think they need it but actually don't. Do you have any idea how long variable declarations are going to be if you allow conditional volatile and const?
Because back in the day, our primitive ancestors were being hunted by pointers, and thought that if they had enough typedefs the evil asterisks would leave them alone. There was a lot of superstition in those days; think of typedef as a kind of garlic and pointers being vampires, and you're not far off. The old ones practiced cargo-cult programming, and worried that things like the definition of char or int might suddenly change. Having your own private type at least insulated you from those changes... Or so they thought. But I ask you, where are those old ones now? They were swallowed by the sea, or taken by great Cthulhu, and all we have left is the ruins of their monuments, as you have found. 
I'm a bit late to the party here, but better late than never. I'm the author of P0732 (except the UDL bit, which is Louis'). The use of `std::fixed_string` in the paper was just to provide an example of how the language feature could be used, apologies if that wasn't clear. `std::fixed_string` has been proposed separately, it's [P0259](http://wg21.link/p0259), but proposal is dormant at the moment. I see use cases for it even in the absence of P0732, so I don't view it as "`std::string` for use in NTTPs", but rather a useful addition to the library on its own. I'd also like to have a `std::fixed_capacity_string` in the library, taking your list up to 5 alternatives :-) P0732 doesn't close the door to allowing `std::string` in NTTPs in the future, assuming the technical barriers can be overcome. Writing the paper for that extension is not something that I plan on doing, but I'd be interested to see it if you or someone else does.
But he is not wrong. Just because some detail is in a standard, doesn’t mean it’s actually a good feature. Few things have been deprecated in c++ for that reason. 
The *amount* of development happening now, and the depth of it, is totally unprecedented.
Go and Rust are not viable alternatives to C++, at least for me: There is dearth of Go or Rust jobs in Singapore.
This is completely the wrong view! The WG14 and WG21 committees exist to make the c and c++ languages better for all users, not just ourselves. While we should encourage people, especially domain experts who may not be languages experts, to participate in the process, the committee has failed if that is actually the only way for the language to improve for you. When entering committee we should check our specific needs at the door and commit ourselves to doing what is best for the language and its users.
Well it depends on the case. You actually can redistribute headers and libraries if you provide a mean to access the source code. I still remember when canonical was mailing dvds with a pre compiled Ubuntu, and it was full of gpl software.
There is undoubtedly a performance hit when enabling no-strict-aliasing, but for me it's single-digit percent in an application that should theoretically benefit a great deal from the missed optimisations, with aliasing very common. The issue here isn't the assumption, it's why the assumption is allowed, which is that violating it is undefined behaviour. And there is no mechanism to say "don't assume that here". 
But standards aren't there to be "good". They're there to make things portable and interoperable. In that case, standards often have to choose the suboptimal. So him throwing shade at standard committees members is precisely because he doesn't participate in standardization. Linus has the luxury of being a dictator, and only has to maintain code written for one compiler that runs on the metal.
You don't need threads, you can put a deadline_timer onto the same ioservice as your socket. When that fires you either have a timeout event or a timer csncellation. There's example code out there on the boost website, but the point is that *everyone* will have to write the same boilerplate code to handle something relatively simple.
I'm with you that strict-alias by default would require marking many things, but aliasing is not as rare as you may think. Considering raw pointers, references due to only being syntactic sugar and even aliasing in class members/member functions introduce quite a lot places for aliasing to take place. Some of them even not obvious to an everyday C++ user. 
His problem with C++ is that he can't read and understand all the code in it because C++ uses abstractions and his solution is to implement everything himself, yeah right. C++ is provably easier to maintain and less error prone than C. Just another grumpy rant on the Internet. 
That would be absurd. Seriously, who thinks this is a good idea!?
 `std::string` in `constexpr` context is where this is going, but a lot of building blocks are needed to get there. 
I don't think "tailoring to legacy software" is what happened in this particular instance. Rather, it was tailoring to the needs of real software which will still need to include headers (C, operating system, etc). 
Did you have real world benchmark data to back that up or are you guessing? Let me provide some anecdata in the other direction. We went through the effort to get strict applying clean, but none of our benchmarks showed improvement above the noise floor (some were faster, some were slower, never by much in either direction, and overall it seemed to make no difference). In the end, we decided to leave strict aliasing disabled because it wasn't worth the risk of miscompilation. I spend a lot of time (maybe too much) reading the assembly output from the compiler, and I almost never see meaningful improvements that TBAA could possibly help. In general, hot loops are either over two pointers to the same type, or when doing string processing over char pointers. Also remember that TBAA is just one kind of alias analysis, and in my view it is the least useful for most real applications. Finally, for most code correctness is much more important than performance. Only after profiling to identify where it really matters should you even consider tradeoffs that that risk correctness.
Are you really claiming that Linus doesn't care about portability? How many platforms do you test your code on? Linux seems like one of the most portable large codebases I'm aware of. And it compiles with at least two compilers, and I think I remember an effort to make it work with icc. I can't think of a good reason for Linux to try to support compiling with MSVC.
Yes, quite right, thanks. Of course I meant override.
I think the whole idea of this paper is just too much for an already existing language with similar features already present. Having both templates and what the paper proposes would further subdivide the language. It's a good mechanic overall, but only in itself (Julia has something like this, but it's a new and not settled language). From what I gather it doesn't introduce any new possibilities so it could be considered syntactic sugar. A very big one, too big to be introduced IMO. I haven't read the whole paper and am not familiar with all other papers that are referenced so if this introduces something actually new (with respect to referenced papers) that would be a big deal please correct me.
tl;dw Don't use raw for loops in your code, use algorithms. Learn the STL algorithms and complexity. Partition algorithms are very useful.
Keep it simple! You have a tool in your toolbox called inheritance. Your connection class sounds like a great thing to model using that tool: an abstract connection just has pure virtual functions for connecting, disconnecting, etc., and implementations thereof can be built for 3G, wifi, and whatever other connections you might need. Even better: any state you need can be neatly encapsulated as well. Why would you avoid the most obvious, straightforward solution? Because some random dude on the internet said so? As for free functions... As a general rule of thumb, functions and variables should exist at the most limited scope possible. Class scope is more limited than free, so that's generally to be preferred. The guideline for free functions makes more sense when applied to generic algorithms, not so much for application level code with a specific purpose. If something is part of a connection class but just happens to not touch any state (some address verifier, maybe), and you only ever need it in that class, by all means make it a private function. 
&gt; How many platforms do you test your code on? Linux seems like one of the most portable large codebases I'm aware of. welll... so far it only compiles with GCC so realistically it only targets a single platform.
You sound like you're taking offense on Linus' behalf. &gt; Are you really claiming that Linus doesn't care about portability? and &gt; Linux seems like one of the most portable large codebases I'm aware of. Yeah, because he makes it portable with compiler flags. So no, he doesn't care about portability because he uses GCC and its flags for that. And the only reason it compiles in clang is because other people who cared about it worked on it, and because the clang people made a choice to be GCC compatible. Linus himself has never pushed for compilation outside of GCC. So, no, he really doesn't care about portability because he assumes GCC will take care of it. Well, GCC, and the C standards committees has to care about more than just Linus' kernel.
Why does networking have a dependency on executors? Who asked for executors?
AFAIK `restrict` enables much more optimizations than strict aliasing ; with strict aliasing you can have code such as void f(float* a, float* b) { // ... } where a and b point to the same object, while this is disallowed (more precisely, use of each pointer is disallowed if I'm not mistaken) if `a` and `b` are tagged `restrict`
Was there a decision to support other parts of p1024r0 e.g. missing front/back and striking the redundant () operator?
P0732 has nothing to do with std::string in a constexpr context - it would not qualify as one of the types you could use as a value template parameter. On the other hand, the constexpr allocation paper and is_constant_evaluated() will allow for constexpr std::string. 
In my case it's not a problem since my software is GPLv3. However, I already ship with a language that uses LLVM (http://faust.grame.fr/) so it makes sense to use LLVM's JIT for me.
LEWG voted in favour of the other bits of P1024, apart from at() and the non-member subview operations. I’ll write a follow-up paper for the next meeting with only the non-controversial parts, which hopefully will get through. Longer term, it might make sense for span to inherit from P0789’s view_interface CRTP base class, in which case it would get at() (and front() and back()) for “free”. But we’ll see what happens...
“Trust the english” seems totally ok for me. Is this the only reason?
I see mdspan people would like to change span template parameters to use C array notation such as span&lt;int[2]&gt; instead of span&lt;int,2&gt; and span&lt;int[]&gt;. Do u really think that's an improvement? They argue with consistency with unique_ptr but I think that's misleading. Unique_ptr needs special array syntax to distinguish between single element and array allocation but in case of span it's about dynamic vs static extent - array is implicit here. Finally keeping the parameters is consistent with std::array and std::vector
&gt; This is why we use -fwrapv So the whole linux kernel turns off int overflow optimisations!? The 'use int everywhere' C++ people should take note.
Unfortunately the C++ committee will not change anything unless you write and submit a paper, fly to a meeting somewhere around the world to champion it or delegate this task to other person. I hope one day they allow contributing ordinary people by creating an issue or pull request on Github or some other service. 
&gt; explicit(bool) does simplify the language. It simplifies the language usage, not the language definition. But there's a whole lot of people who try to learn the language formally, by its definition (and judge it by its definition, too).
&gt; I guess all I can say is, papers welcome? Aren't there already papers for this ? At the very least the metaclasses paper assumes the existence of the feature.
Well, there are plenty of people going to meetings here. While this is not ready to be used as a paper as is, it's already pretty good. If someone in the right working groups sees this and is interested to promote it, I think OP could find the motivation to write the paper.
&gt; One way we can tell that C++ is not sufficient is to imagine an alternate world in which it is. In that world, older C projects would routinely up-migrate to C++. Major OS kernels would be written in C++, and existing kernel implementations like Linux would be upgrading to it. In the real world, this ain’t happening. What? Linux isn't never going to get rewritten in C++ because it is huge and doing so would just be a waste of time. C++ and C are completely different languages, you can't just compile your C code with a C++ compiler and slowly add C++ features. It's just not possible without a (complete) rewrite. And who says that some *smaller* C projects get rewritten in C++? rxvt and urxvt come to mind. It's just not possible for large projects, which is completely fine.
I am well aware of fiascos such as vector&lt;bool&gt; and auto_ptr. But the point is that it's pretty pointless to sit on the sidelines and complain. If you really care, and you're right, it shouldn't be too hard to change the standard by actually participating in the standardisation process. But Linus all too often takes the approach of just complaining about stuff, without actually doing anything to change it.
I think the point is that Linus has another idea on what C should be than the standards committee. The committee is for things like portability. Linus doesn't care about compat at all because Linux only uses gcc which does the same thing on all platforms, and so his rant is completely unjustified.
*A collection of personal notes and thoughts on rvalue references, their role in move semantics and how they can significantly increase the performance of your applications.*
There are quite a few jobs for Go devs in the UK
As I understood Linus' rant, the feature he complained a out was bad, not just bad for his needs. And no matter what the process is for changing the standard, you have to either follow the process or work to change the process to accomplish a change. Not just sit on the side lines and complain like you're 4 years old and expect that someone else will champion your cause for you. (This is of course different from rejecting changes that depend on the bad parts of the language into your project.)
What's the issue with writing a paper? It requires you to put your thoughts on paper and explore possible technical problems.
Sweet, I really look forward to poorly coded WebAssembly adverts
And even with that heavy process, there are more papers than there is time to process them all in each meeting. 
My feeling is that LT sees the union as a memory location of correct (maximum) size of the types in the union. He (and he supports this by saying that gcc does it (and by implication clang, and AFAIK vc as well)) is a location in memory, that he should be able to change to his hearths' concern (type punning, it's all about type punning). I guess there is a clash between the memory model in the std (being more abstract) and the memory model in gcc (and the rest), being very concrete, and the way LT sees it. It's like many of those other things like NULL, in every compiler known to mankind it equates to 0, but this is not guaranteed in the standard, it could just as well be 1, without violating the std.
Isn't there where we are going anyway? That is, if the aluded to `basic_fixed_string` can be used as a template parameter, it needs to be mangled, doesn't it?
Where did static exceptions come from? They're two completely separate features and having one doesn't preclude the others. Contracts has been in TS form for quite a while now, whereas this static exceptions proposal is brand new and, AFAIU, hasn't even been presented to EWG.
&gt; We know that when a function returns an object by value, the compiler has to create a temporary — yet fully-fledged — object (rvalue). It that specific case, no object is created because no prvalue is being materialized, since C++17.
I'm a bit confused as to what you are saying. Possibly the compiler writers side with LT, gcc obviously does, as pointed out by LT, and clang aims to be a drop-in-replacement of gcc, so that should do the same thing. AFAIK vc does as well. In one of the cppcon17 presentations, a presenter used type punning in an example, he was corrected and told to use std::memcpy to achieve the same, then someone else (knowledgeable I presume) chimed in to state that that was formally also UB. The discussion ended inconclusive and nobody else had an answer as to how to do this (type punning) legally. Sometimes you want to get the mantisse out of an IEEE754 float, how to do that, by calculation (i.e. division/exponentiation)?
Contracts are like [Code Contracts](https://docs.microsoft.com/en-us/dotnet/framework/debug-trace-profile/code-contracts) in C#. So far, the fundamentals. Things like class invariants and LSP support can come later.
I think these kinds of blog posts speak volumes about human psychology when it comes to programming languages. People like to make definitive judgements and statements because it feels good to be certain of something, but the reality is never that simple and conclusive. C is simple, but lack of STL, virtual dispatch, templates etc. can become very problematic. If you use C++ with insane template hacks, nobody will understand your code. People always tend to drift into using language features for the sake of using them, because feeling clever feels good. I feel that a lot of people in the C++ community are under impression that they have to use all these fancy abstractions to make the code generic and reusable before making it usable in the first place, just because it's "the right way". Many people (including me) fell into this trap of obfuscating code for the sake of intellectual masturbation. The most productive way to work is moderation. In C++, you don't pay for the complexity you don't introduce in your program in the first place (basically only RAII and proper objects are required to be compatible with STL and other C++ code). If your code **gets the job done** without causing you much pain (complexity, maintenance etc.), then it's good code.
I described the issue with the process as a whole, not just the one part you mentioned.
To me this is a moot argument. After all, constepxpr functions do things that were already possible before too. But we needed tools to make it simple and accessible, thus efforts were put into providing a better alternative (making the clunky way obsolete). Ideas like metaclasses or type functions (this proposal) try to do the same but with metaprogramming (type transformations and generation). The question is more like: would it be worth adding that? Would it solve so many issues that metaprogramming would be considered simple, obvious to beginners and therefore experts?
That's not my understanding. If you tag pointers with restrict and alias anyway, this entails UB, the compiler is allowed to optimize as if the pointers point to different objects, even if this creates havoc because you violated the rule pre-condition(s) of restrict.
C and C\+\+ are not &gt;completely different languages. C is mostly subset of C\+\+ . You don't need to rewrite your C code in C\+\+. Here is a list of possible changes that your code may require ["How to change the C constructs to their corresponding C\+\+ constructs"](https://support.sas.com/documentation/onlinedoc/sasc/doc/cplus/znid-149.htm) Linux kernel \- is, you know, kernel and has many C\+\+ features don't work in kernel mode and Linus has phobia of C\+\+ and OOP in general. That's why it will not be rewritten, not because of its size. 
Thanks, this is really interesting. I effectivly remember that Stroustrup talked in one of his talks in the cppcon 2014-2016 about multimethods. It was in a talk about free functions and member function and how to unify the syntax.
Thanks for the precision, you are right.
Yes it is (at least it what I understand of `std::visit()`). &gt;Not requiring your types to inherit from a class and still treating them in a polymorphic manner is intriguing. Technically it's what we are doing with template function ;) But there I was looking at the storage problem instead of the calling problem. And it's also what we can do with `std::any`.
&gt; Welcome to the world of C++ my friend. I know! I will watch the videos, thanks for pointing it. And yes with metaclasses it would be extremely easy to do. `using W = my_variant&lt;T,U&gt;` would create a function in `W` for every functions in `T`, `U` and `V`, with those function calling std::visit on the underlying type (writting all the boilerplate I've done). And you should even be able to call a function of `T` through `W` even if it doesn't exist for `U`.
Its good to complain, otherwise how would the people who standardize know that there is a possible issue?
&gt; not because of its size. I'm pretty sure that is one reason. C++ may use several features of C, but there are so many different constructs in C that behave differently in C++ (without any warnings or errors) that I'd call them completely different languages.
Well I agree, going to meetings is hard. Maybe we should have some form of forum where people can request other people who actually go to meetings to champion their proposal?
What idea that CMake come up with is directly fantastic? :D It's a horrible and unnecessary piece of software junk created by someone who obviously didn't want to put time into understanding what others have already done before. Typical example of reinventing the wheel and making it square instead of round.
Linus doesn't have a phobia of C++ in general - he has written a scuba diving application in C++. He thinks it's a stupid idea to write an OS in C++, and he had good reason to.
+1 on not programming via emoticons. There is a proposal one one of the mailing list for an operator &amp;&amp;&gt; Awful
By participating in the standardization work??? Such as writing a paper explaining why something is bad, and suggesting how to fix it. Or even just read other people's papers and respond to the bad parts. Ranting about something in a mailing list is just that - a rant.
Optimisations are only part of the reasons for using signed integers (almost) everywhere. I for one got sick of dealing with mixing signed and unsigned integers and decided to just make them all signed. All of a sudden comparisons worked the way I wanted. I would do it, even if I compiled with `-fwrapv`.
The Networking TS has its own form of executors that are specific to its needs. But the need to specify the execution context of an asynchronous operation is common to lots of domains. For example, parallel algorithms also need something like executors, so an effort was made to define general-purpose executors and rebase Networking on that. So that's how we got here.
Many people do recommend using free functions when possible, though. And for good reason. Take operator* for multiplying a complex number with an int, for example. If implemented as a member function, we get something like Complex Complex::operator*(int rhs) const { // ... } But we probably want to write the int on the left side as well, but in that case we get Complex operator*(int lhs, const Complex&amp; rhs) { // ... } So we don't have any consistency. In OPs case, maybe he wants some function getBestConnection, to compare a 3G connection and a Wi-Fi connection and see which one to use. But on which type of connection should we define it?
Or maybe we should have some form of forum where people can discuss the proposals, iterate on them and finally accept or reject them right there. This way the committee could work for the whole year instead of a few overloaded weeks per year. 
It's a real shame. It would have been nice if it could have been a standardised version of Boost.ASIO with placeholders in the API to deal with feature-creep such as executors.
Have a look at the std-proposals mailing list, which does exactly that minus the final approval of the committee, although several committee members are in it 
Not everybody can participate in standardization. Not everybody has the time, means or money. That doesn't mean that those people's opinions are not valuable to the people who do the standardization work. Of course it's easier for them to say "You're not participating - your loss", but not everybody can participate and it's worth listening to these opinions as well. It's sort-of the same with politics. Not everybody can or wants to or has the time to participate in politics. You have a life and a 100% job as a programmer, maybe a family and kids in the evening. You don't want to become a politician or you can't become an activist. Yet there is some political subjects where you want to give input, criticize, or make your voice heard. This is easily possible through telling an intermediary (e.g. your local politician) and voting - e.g. vote for a particular party in local and country-wide elections. And you don't have to join a party or be a 10%, 20% or full-time politician.
 *YOU* are full of bullshit. C++ is a horrible language. It's made more horrible by the fact that a lot of substandard programmers use it, to the point where it's much much easier to generate total and utter crap with it. Quite frankly, even if the choice of C were to do *nothing* but keep the C++ programmers out, that in itself would be a huge reason to use C. In other words: the choice of C is the only sane choice. I know Miles Bader jokingly said "to piss you off", but it's actually true. I've come to the conclusion that any programmer that would prefer the project to be in C++ over C is likely a programmer that I really *would* prefer to piss off, so that he doesn't come and screw up any project I'm involved with. [http://harmful.cat\-v.org/software/c\+\+/linus](http://harmful.cat-v.org/software/c++/linus) I'd say he is a dick and has a phobia of C\+\+ and OOP . 
 template&lt;auto F&gt; using get_type = typename decltype(F())::type; template&lt;class T&gt; using decay_t = get_type&lt;[] { using U = remove_reference_t&lt;T&gt;; if constexpr (is_array_v&lt;U&gt;) return type_identity&lt;remove_extent_t&lt;U&gt;*&gt;{}; else if constexpr (is_function_v&lt;U&gt;) return type_identity&lt;add_pointer_t&lt;U&gt;&gt;{}; else return type_identity&lt;remove_cv_t&lt;U&gt;&gt;{}; }&gt;; Nice.
But in politics, you take part of the process by the mere act of voting! This is more a case of NOT voting, and then complain that the elected president is shit. If you don't like something, use the established process to change it. If you do t like the process, try to improve it. If you can't be arsed to do any of it, then STFU. As far as I know, if you write a paper to the C++ standards committee, you can get a member of the committee to champion it for you so you don't have to participate in the meetings yourself. I'm sure the C standards committee has a similar system.
https://subsurface-divelog.org Written by Linus Torvalds (and others) in C++. So I'd say it's not a strong phobia...
Argh, another series of articles that totally gets lvalues and rvalues wrong. &gt;In C++ an lvalue is something that points to a specific memory location. On the other hand, a rvalue is something that doesn't point anywhere. No, no, no, no, no. 
&gt; I see mdspan people would like to change span template parameters to use C array notation such as span&lt;int[2]&gt; instead of span&lt;int,2&gt; and span&lt;int[]&gt;. That is no longer the case. Source: I am a "mdspan person".
I am still confused if I just want to install a third-party library using `cmake`, but not for immediate use in some other project, but just so I have it installed on my system. How would I do that? This is something I run into all the time with external libraries like OpenCV or FLTK and I frankly have no idea how to do it. I usually end up just running away crying.
Dirk Hohndel, Tomaz Canabrava and others. not Linus and others. [https://github.com/Subsurface\-divelog/subsurface/graphs/contributors](https://github.com/Subsurface-divelog/subsurface/graphs/contributors) 
At this meeting: * Record attendance: 157 people, which would be high for a US meeting, and is extraordinary for a Europe meeting. * Contracts landed for C++20. * Core library concepts landed for C++20, marking the first time the language feature is used in the library. * The above two items are likely to open the floodgates; concepts and contracts will likely now be deployed throughout the standard library. * Ranges landing for C++20, but after this meeting it seems inevitable. * It became clear the Modules TS will probably not be adopted as-is and may miss C++20. * It became clear the Coroutines TS will probably not be adopted as-is and may need design changes to have a shot for C++20. * It became clear the Executors proposal will probably not be adopted as-is and may need design changes to have a shot for C++20. * Parallelism TS v2 shipped. * Reflection TS v1 went out for ballot. * An unprecedented 3 additional meetings were added between this meeting and the next full committee meeting. * The first concrete discussion on package management was held.
There are much better ways to learn C++.
The `atomic` methods map down to atomic intrinsics which themselves map down to bare CPU instructions. The CPU instruction used in `compare_exchange` (aka, [Compare And Swap](https://en.wikipedia.org/wiki/Compare-and-swap)) simply compares the bits, it does not invoke any user-defined function.
&gt; The discussion ended inconclusive and nobody else had an answer as to how to do this (type punning) legally. From the top off my head, the rules are: 1. You can cast any `T*` to `char*` and use `char*` for **reading**, 2. Otherwise use `memcpy`, so long as the destination type has *vacuous initialization*^1 Fortunately, most optimizers are very good at simply eliding the `memcpy` call and just reading/writing at the original bytes through different "lenses". ^1 *See basic.life, in essence, if the type has no non-defaulted constructor, recursively.*
Do you have a better explanation? There seem to be 2-3 common ones that aren’t quite right.
Aren't there some optimizations that can be applied with `-fwrapv` only? Notably, `-fwrapv` should make additions commutative and associative again, since "temporary" overflow in the course of evaluation no longer matters; or can compilers already optimize as such even in when signed behavior is undefined?
[This is not too bad](http://eel.is/c++draft/basic.lval), although you can skip point 11 as it's not directly relevant to the topic
Not exactly succinct though, is it?
I thought about this and I think it's an unintentionally good thing it isn't symmetrical. The word `delete` implies releasing the memory associated with the resource. While calling the destructor only says "run this function", and the memory is left in place, since it could be on the stack. Placement delete would actually confuse the issue by making it seem like you can delete memory of the object.
It's a lot shorter than the predecessor to the article we are commenting on, while also covering a lot more ground
&gt; Not everybody has the time, means or money. Linus certainly has more than most. Except time. But I'm sure it'd e easy for him to find a "champion" to represent his views. But it's just no in his interest. He'd probably rather hack gcc with some non-standard extensions.
Can you explain that? I do not see how the compiler can (ab)use UB in this case? In which case could the compiler use a possible "temporary" overflow to screw you?