Don't forget to hop on the voat.co train while you're at it.
Yea. Naming a backdoor "telemetry" is high quality concealment.
It important to realize that telemetry in this case is not sending anything back to Microsoft or anything. It is just broadcasting events that other applications on your machine can subscribe to. This is typically used by profilers and other development tools.
I am confused now. Do you find it useful but wastes a lot of memory? Or are both c# .net and java misused? That's why people think they are slow and inefficient?
If they wanted to hide it they wouldn't have called it telemetry.
`-fno-ms-compatibility -fno-ms-extensions -fno-delayed-template-parsing` Don't these flags switch off the Microsoft-related deviations? 
"Other applications" can include the legions of telemetry gubbins that send data back to Microsoft, though
That's terrible. Building a PDB won't affect the release mode generated code. It's mostly a map of offsets to symbols, and vice versa. 
He didn't say he was racist. 
That is true. It might even include malicious stuff if some spyware managed to get into your computer somehow.
See in [Agner Fog's blog](http://agner.org/optimize/blog/read.php?i=49#49), for example.
Neither – they aren’t wasteful, at all. They’re also not really misused – it’s just bad marketing. Look at the High Frequency Trading stuff – a very performance and efficiency critical market – almost everything is in Java.
Seems bizarre to not broadcast this when creating a project that it will be built with telemetry enabled. Feels like they are just planning to boost sales of pitchforks. I can't imagine them finishing this feature and going "enabling this by default and not making it obvious won't confuse or infuriate anyone!" D'oh!
MS could have avoided all the conspiracy theories if they had named these functions 'trace_main' or 'log_main' instead of telemetry, and documented it.
I removed points 3 and 4 from my post above. I originally thought the word "telemetry" here meant the same as Windows 10 telemetry (phoning home). It may have just been an unfortunate naming convention.
Did you know about https://github.com/mbcrawfo/GenericMakefile when you started your project?
You're still linking the CRT implicitly. 
HCMC Ho Chi Minh City, just the place. - The duration is around 1 hour :). I think my audience knows that beforehand. Should I still put it? - Live code: yes, you are right about that, I will when I upload to github. The talk itself try not to be "language-lawyer" precise or we could get lost in the details. The slot is around 1 hour or so. Highly appreciated feedback. :)
I did not say that sources must be there. MS normally gives most of the CRT sources, but not all,bits have been missing regularly. That said, one still can't hide what that does: disassembly is still there.
nope, didn't. That one has some features that this one doesn't such as separate release and debug builds and versioning. This one is less reliant on shells and a bit more flexible in other regards to binary and library outputs. Might take some hints from that one.
I don't quite get what the fuss is here, or with telemetry in general. Microsoft is an operating systems company. One of their goals is to make operating systems better. In this age it's accepted that one of the best ways to understand and target investments in a software product is through instrumentation and telemetry. Being able to understand how your install base uses your products helps you figure out how to make investments to improve your product. All big web companies do this. Every click, scroll, message, and page load you perform with Google/Facebook/Twitter/Insta/Snapchat is logged and aggregated so they can better understand how to improve the service. Android does this. iOS does this. Every product does this. In this form, the data collection is benign, harmless, and only makes the product better. The controversy usually comes when a company attempts to monetize on that data. I can understand the outrage there, it's frustrating and feels like you're being taken advantage of in an underhanded way. That's tougher and I get it. The economic reality is that to build systems that are competitive they need to be sold at a price point that's at parity with the rest of the market. Software's price point, for consumers at least, is somewhere between free and actually giving the customer money. People have spoken, they will refuse to pay a single dollar for most software products, but will happily put up with some advertising. It's annoying, but when I really think about it I think we (either we the consumers, or we the employed software developers) got the better end of the deal. We've effectively gotten scummy advertisers to fund a huge chunk of our modern digital infrastructure, and all we had to do is let them take up a few square inches of ad space near our eyeballs. That small space funds a large chunk of SF's engineers, all the digital platforms that enrich our lives, and a lot of 'good for humanity' works in the form of Google X Labs / MSR / Facebook Research efforts. / my 2cents
&gt; If you walk through your code using Visual Studio's provided disassembly view, you will NOT see these function calls. Only when you use a third-party application like Ida do the call become visible. That's the only thing that really bothers me. The functionality itself seems reasonable. I'd even buy that it might be useful or just very innocuous and that they felt they didn't need to really publicise it very "loudly". But if they are hiding it on purpose in their disassembly view, that's a big WTF. Edit: The disassembly view is uglier than OP's in visual studio, but I DO see some telemetry stuff in there.
Don't quite understand how a compiler and standard library implementation "inserting code" is "suspicious". The CRT has always had to insert code before main() is called, to initialize per thread data (e.g. errno), call constructors on globals, bind stdout to the console, etc. Emitting an ETW event letting you see when the CRT code is done and your code starts in a profile seems pretty tame by comparison.
ETW is just a tool that logs events. You could replace everything in your statement above from ".etl" with ".txt" and it would semantically be the same thing. If this stuff was being transmitted to a remote machine by the CRT that'd be one thing, but that's not happening here. As for "any program with sufficient privilege" -- any program with sufficient privilege could take SeDebugPrivilege, set a breakpoint in any `main` they see, and log that off somewhere. ETW does not change the attack surface here as creating a system wide data collector like that requires administrative privileges. This feature makes it easier for users to understand when the CRT initialization code completes when looking at ETW performance traces. It doesn't make it any easier for malicious data collection to occur.
And if I want to broadcast, I would write that in myself, thank you MS.
I guess Thompson was right all along... it's [Reflecting on Trusting trust](http://delivery.acm.org/10.1145/360000/358210/reflections.pdf?ip=74.45.209.25&amp;id=358210&amp;acc=OPEN&amp;key=4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E6D218144511F3437&amp;CFID=601281357&amp;CFTOKEN=32242092&amp;__acm__=1462726305_0e7dd7ecf161735c7b58e93622c7b302) all over again.
It was a function break point, based on the symbol name. I might be messing something up, feel free to try it yourself!
&gt; Any program with sufficient privilege can enable tracing of specific event types throughout the system, and user intervention is not required to do so. Sure, but that "Sufficient privilege" is Local Administrator - if I'm local admin I can attach a debugger to your process and spy just as effectively, or do any number of things. 
Yea, I just don't get how everyone is jumping on the drama train without even like, you know, just analyzing what these functions even do. That isn't hard, and I fully expect everyone that is interested in C++ to be able to utilize a debugger. It seems like there is still a surprising amount of people that will take every single bit of drama (in this case based completely on a fundamental misunderstanding of the workings of the CRT) to preach against Microsoft. At least the MSVC/STL/CRT guys do not deserve that, at all. This here has nothing to do with the "real" Windows 10 telemetry and from the disassembly seems to be completely harmless, yet it is completely blown out of proportion. 
I think the idea of including such 'usefulness' yourself is more in tune with c++ devs expectations rather then quietly including without barely a word. Having to link an obj to get rid of it is pretty much 180 degrees of my experience and expectations.
also getting it to work on big windows project is kinda painfull
Everything you say is true. The problem here is it is hidden and undocumented and does it without it being explicit. That kind of thing is what causes blue screens because the coder doesn't know what's really happening.
Looks like Consolas.
Just update your O.S. to Windows 10. 
It's not something you have to worry about at all.
&gt; One of their goals is to make operating systems better. Yeah... and fairies dance with unicorns in my lawn.
 &gt;His issue seems to be mocking over criticism. Maybe maybe not, however I still have to say that he or she needs to get over this issue if they expect to work in industry. &gt;Having somebody tell you how much of a faggot you are for using a raw owning pointer, isn't going to help anybody. Of course not, however this is the Internet and you can't take crap from people seriously. In fact I would have to say the ability to filter out the nonsense on the net is critical to using it to educate your self. Beyond all of that I really think I learn more from sites where there is an active discussion in the comments section about the code posted. Sometimes it isn't right or wrong but points of view. When it is about right from wrong everybody benefits. In a nutshell at some point the poster has to understand at this is an industry where everybody has to learn no matter how long they have been in the industry. 
Just because others agree with you doesn't make it right!!!! For example: The KKk has lots of members that are seemingly in agreement, but that seldom makes them right about anything. 
Yeah, coming in here and using a tone in your posting that is designed to manage the reaction in certain ways certainly qualifies as such. There are a number of you going around doing this here.
We use performance tracing tools too. On our own boxes. (There's also a bunch of telemetry the IDE collects if you have sending that turned on; but the CRT isn't doing that and I don't believe that's what this is for)
"How dare someone disagree in a reasonable tone" how about step right off
It's stuff like this that makes me never use primitive types directly - I always use typedefs like `std::size_t` and `std::int64_t` - seeing a raw `int` in code is a code smell to me.
C type naming is just plain atrocious. What sick mind could spawn all this ints, longs, long longs, long long ints, `const long const long static const int const signed` (!!!).
Isn't the std::(u)intN_t {8, 16, 32, 64 ∈ N} part actually not in the standard? 
It says optional, though.
It sounds like this function call emits an ETW event to say that main is about to start. This can then be used for profiling. Events like this help to give context to the execution of a program and make analysis easier so they are a *good* thing. I make use of custom ETW events quite heavily in UIforETW (https://randomascii.wordpress.com/2015/09/24/etw-central/) in order to help with trace analysis by injecting input events, CPU frequency data, etc. My only question here would be "what ETW provider do I need to enable in order to listen to these events so that I can do more effective profiling." If you think it's spyware then you need to show data being transmitted across the network or some-such, otherwise it's just baseless speculation.
&gt; Because it's opt-in by default, not opt-out. I find nearly insulting to my intelligence that this must be the case without informing users and on top of that I cannot even see what this black box contains. Why users were not informed? I do not want to think bad, but it does not look nice at all. &gt; The users would have said no. Well, yes, so maybe that is a signal of what should not be done in the first place. If you do not treat your user-base respectfully, you could loose it.
Parts are optional, but only if the underlying hardware does not support it. Most of it is not optional.
There's an annoying wart. Changing `uintmax_t` breaks any ABI which used it. In fact, some compilers offer 128-bit types (e.g. gcc) but they leave `intmax_t` as 64-bit. 
Data point: a work colleague uses the following: #define AND &amp;&amp; #define NOT ! #define OR || Before the days of syntax highlighting, this helped. The all-caps stands out from its surroundings. But I think it is redundant now; and the lower-case versions you mention don't share the benefit of standing out. In fact they stand out less than the symbol versions. 
Which is wrong. Using size_t fir it's defined purpose is fine, nothing wrong with it, but always using fixed width integers is non-portable. Compiling your code for x86 will suddenly make it slower. If you want to have an integer in native word size use int_fastXX_t, it's almost always int for x86 and long for x86_64. Also worth mentioning, using an int is almost always fine, only memory addressing with 32-bit ints on x86_64 is flawed due to their broken ISA. 
There is another very good reason why even those compilers which offer 128-bit integers don't set `(u)intmax_t` to 128 bits, and it's the same reason why adding 128 to the list of magic numbers in the standard wouldn't actually achieve anything: there is no common processor which offers 128-bit GPRs and does 128-bit math. Where these and wider integer types are offered by compilers, they're almost always implemented in software.
link to no_telemetry.obj
std::(u)int_leastn_t and std::(u)int_fastn_t should always be available (and are probably what you want. For example for a loop counter you should proobabally use std::int_fast32_t)
No need. just wait for win10_force_update_main_invoke_trigger.
/r/iamverysmart
Personally you could, but what about other published libraries?
That hasn't been valid since at least C89, modern C is far easier to understand `static const long const long const int const signed`, see? You can mix in some more `const`s too, useful for padding short lines instead of tabs or when you really want your maintainer to know it's `const`. `int const const const const const const const`.
&gt; Apparently it's only VS15 feature. So is telemetry on Windows. It's "only" a Windows 10 feature meaning it'll probably stay like that for all future releases. Also watch out for any suspicious "patches" for previous VS versions. :)
Everyone is upvoting with a silent nod, but I wanted to say that this is one of the most useful and highest quality C++ libraries out there. Lots of great features, fast and well-documented.
Hell, I'd even be happy with an idiomatic C++ library with big integer support (yes, gmp is great, no, it is not idiomatic).
Intresting. In what domains are they used, do you know? I feel like any domain that would need quad-precision would have more to gain using fixed-point, but that is just my intuition.
VS and sublime for c++, both with vim plugins. On Linux it's vim and automatic make script, but I'm mostly just fixing the port there. Edit: I seem to have found a stray tab with this thread in it :)
How is it broken? Not familiar with this.
Sorry for the late reply. I had just thrown something together in about a half hour. I had the MutexedObject inheriting from the user type. Locking returned a temporary that held a atomic in the MutexedObject under a spin lock. It had a nice syntax without any pointer dereferencing. However did not have the increased safety of your solution. i.e safe and unsafe access were identical through the MutexedObject by inheritance. Safety was made by calling the lock. Here is the code template&lt;typename T&gt; class MutexedObject : public T { class ObjectLock{ public: ObjectLock(std::atomic_flag&amp; lock) : lock_(lock) { while (lock_.test_and_set(std::memory_order_acquire)) // acquire lock ; // spin } ~ObjectLock(){ lock_.clear(std::memory_order_release); } private: std::atomic_flag&amp; lock_; }; public: ObjectLock lock(){ return ObjectLock(lock_); } private: T object_; std::atomic_flag lock_ = ATOMIC_FLAG_INIT; }; 
I basically quickly wrote the minimal functional code for the strategy. Not nearly as safe and thought out as what you came up with.
If you need a fixed width integer, you obviously use `uintXX_t`, etc. But for the majority of use cases of an `int` in a program, you don't need fixed width integers, and it's always better to use `int`, `long` or `int_fastXX_t`.
Yea, inheritance can be pretty fragile. I'm sure there are more than just the few problems you mentioned with this, which is also why unique_ptr doesn't inherit what it points to as well. Your code inherits from T and also has a T member. I assume that's a mistake.
The description looks interesting. However, I am concerned about the LGPL license. LGPL is very problematic in a header-only library. (Basically it becomes the GPL). If you look at all the major C++ libraries - the vast majority have a BSD style free license and not a copy-left based license. If you want to get the widest use and feedback and have other libraries use it, I would recommend that you change the license to something like the Boost Software License - http://www.boost.org/users/license.html
&gt; LGPL is very problematic in a header-only library. (Basically it becomes the GPL). No, the opposite is the case, as the Eigen-team explained here: http://eigen.tuxfamily.org/index.php?title=Licensing_FAQ&amp;oldid=1116
There are many different possibilities to extend the design, another extension would for instance be to parse as far as possible and return an iterator to the first non-digit, allowing fast parsing of many numbers. I guess the best would be if everyone interested stated their preferred features and if their are some that are very often requested, I might add those in the future. (So just like you did ;-))
I'd direct people to the [issues page](https://gitlab.com/FJW/str_to_integer/issues) for your project - it'll make it for you to keep track of requests, and for other to avoid duplicating requests.
Yep definitely a mistake. Remnant of a different approach.
Eigen, actually switched from the LGPL to MPL. The page you linked, is old. Here is the new licensing FAQ http://eigen.tuxfamily.org/index.php?title=Licensing_FAQ Here is the discussion for changing the license to MPL http://thread.gmane.org/gmane.comp.lib.eigen/2667 Here is an excerpt from the post &gt; *** What are the problems we're trying to solve, with the current Eigen licensing? *** &gt; 1. Excessive complexity of the LGPL is scaring away potential users In addition, as the FAQ you originally linked states that header-only libraries are a problem in LGPL version 2, but not in version 3. Because your library is licensed as LGPL version 2, the only thing that makes it not equivalent to the GPL is the fact that you have "or later versions" in your licensing. The License.txt you have in the gitlab repo would actually be equivalent to the GPL because it is version 2.1 of the LGPL. This just serves to illustrate the inherent complexity of the LGPL, and that many developers and and companies will not want to deal with this type of legal subtlety. This is your code and you are free to license how you see fit. However, I repeat my earlier recommendation that if you want to the widest use and feedback, going for a license like the Boost Software License will help. EDIT: Here is a discussion on the KDE list about LGPL and header only libraries https://forum.kde.org/viewtopic.php?f=74&amp;t=61965 Note that per this discussion, a header-only library under LGPL 2.1 would be the equivalent of GPL. 
Actually I've never seen one faster than the one included in boost::spirit, in either direction. And it has a far better license.
I just measured it: In general it seems to be about twice as fast, but the compile-times to use it are as horrible as they were the last time I used it and IMHO the `sti`-interface is a lot better than the one from boost. And that is ignoring that spirit has a way more complicated implementation.
&gt;some codebases that focus on performance disable **optimizations** altogether You probably meant exceptions there.
While I do get where you are coming from, at least in my (totaly unbiased ;-)) opinion, sti isn't overly bad here as well (It's not the elsewhere mentioned boost::spirit): you only instantiate the iterator/integer-combos that you actually use which in reality are not likely to be overly many. 
**Company:** Optiver **Type:** Full time **Description:** At Optiver, a proprietary trading firm, we need the most advanced technology and continuous innovation to remain successful as a global market maker. We build high-performance software that is used by our own traders to trade a variety of financial instruments on exchanges. Our story begins in 1986, with a single trader on the floor of Amsterdam's options exchange. Today, we are at the forefront of trading and technology, employing around 950 Optiverians of 40 nationalities across offices on four continents. ****Jobs @ Optiver**** * [Graduate Software Developer](http://www.optiver.com/amsterdam/careers/job-vacancies/details/9281/Graduate-Software-Developer?utm_source=Reddit&amp;utm_medium=Jobposting&amp;utm_term=Graduate%20Software%20Developer%20Reddit&amp;utm_content=Textlink&amp;utm_campaign=Graduate%20Software%20Developer%20Reddit%20Posting#.VzC82IRcRBc) * [Software Developer](http://www.optiver.com/amsterdam/careers/job-vacancies/details/9101/Software-Developer?utm_source=Reddit&amp;utm_medium=Posting&amp;utm_term=Software%20Developer&amp;utm_content=textlink&amp;utm_campaign=Software%20Developer%20Reddit%20Posting#.VzC7-YRcRBc) **Location:** Amsterdam, Netherlands **Visa Sponsorship:** Yes **Remote:** No **Technologies:** C++14, C#, Java - Linux - scripting in Python and Lua **Contact:** Please e-mail Marlouk Stek at recruitment@optiver.com for any questions. For more information about our jobs and events, click [here](http://www.optiver.com/amsterdam/careers/jobs-and-events?utm_source=Reddit&amp;utm_medium=Jobposting&amp;utm_term=Job%20overview&amp;utm_content=Textlink&amp;utm_campaign=Job%20overview%20Reddit%20posting).
I recreated it using the windows api and std:chrono. Thanks anyway!
&gt; though maybe the compiler manages to optimize it. It cannot for input-iterators, and unless I could gain significant advantages out of it, I'd rather have it as general as (without reducing ease of use) possible.
Very true, however someone made a boost::convert-style interface for it once just to be a simple and fast replacement for libraries like this. It was built to minimize compiling time and it worked fantastically. Someone should remake it for Spirit3 (the new one that also has a lot if compile speed boosts itself). Edit: Spirit is also a full generic parser to/from any text, binary, structured, and internal data, so yes it is more complex.
The best that can be said is that the situation has got a lot better in recent years. These days, GCC, Clang and VC++ have implemented most features in a C++ standard before the standard is released (though VC++ still lags more than the others, and has longstanding bugs in its implementation that look like they'll never be resolved). With the vast majority of embedded platforms using GCC as their toolchain, it's at least possible to build a toolchain for most embedded systems with absolutely bleeding edge language support.
Don't forget the iterators: `std::string::iterator`, `std::string::const_iterator`, `char*`, `const char*`, … Normally you should only ever use the first two and maybe the last, but the code explicitly supports things like `std::istreambuf_iterator&lt;char&gt;` as well.
Thank you very much: &gt; A. constexpr implies const so having them on the same declaration is redundant AFAIK not on methods, but &gt; On the static variables, you just want constexpr. you are right there. &gt; B. constexpr on local variables is basically silly. &gt;The compiler knows everything about those variables and their scope - they are going to be optimized out entirely under even the most minimal optimizer settings. I used to believe that as well, but it turns out that this is not necessarily the case (even under `-O3`), as it is up to the compiler to decide how much work it wants to perform there. I think it could also spawn errors in the cases where the constants are converted via `Integer{constant}` to another type, as only constexpr guarantees that this works well if the conversion is not lossy in general. &gt; C. But actually - your whole char_literals class might not need to exist. &gt; Why not write Char('A')? Seems to work. I think you are right there (though I'd use `static_cast` or brace-conversion, but fair enough). &gt; I'm a little short on time, but basically you should be able to go to base 36 (0-9 and a-z) and I don't think you do - if only because the character 'z' is nowhere in the code. It's implicitly there as `ca + Base - 11`. which evaluates to 'z' if `Base == 36`. So I think this is not a bug. &gt; E. Dependency on "catch". &gt; You should check in catch.hpp with your library and/or give instructions as to how to effectively change the include path to include a path to that library. At least on Debian catch is available as an officially maintained package, so I am not going to include it (as I in general don't like to paste libraries that are maintained elsewhere into my projects), but you are right that this should be documented. &gt; make your guards start with a single _. This would be undefined behavior, as only the stdlib is allowed to use identifiers that start with an underscore followed by an uppercase-letter. &gt; use spaces instead of tabs It highly depends at which implementation you look at and I consider tabs to be strictly superior. &gt; use namespace `detail` instead of namespace `impl` That one, I will consider, though. So, thanks again, and I'll be glad for any further comments (not just by you).
I've pinged ClangCrew (we talked about this in a meeting but I forget the details).
It looks like the ARMCLANG as opposed to ARMCC compiler is not actually supported properly by the MDK (IDE), although I have more questions into Keil support to try to figure out just what _is_ supported.
Sure -- I have very nice versions of C++ available on my Mac under Clang/LLVM/XCode. I just can't use them for my actual work :(
&gt; Instantiating a template on nearly every integer you use In this case, he instantiates a template for every integer _used for a base in arithmetic._ This is a very small set! In most of code, this means one or two instantiations - for 10 and for 16. In my whole life, I have probably used only 2, 8, 10 and 16 as number bases.
Then tell me how would you write a for loop with size_t iterating from the last element to the first one? It's my guilty pleasure to use signed types in situations like these.
&gt; UTF-16LE ~~Windows uses LE? Seriously? That would mean that `c - L'0'` wouldn't work to get the numeric value of a digit. This would require a lookup-table or at least an additional shift-operation for every such conversion.~~ ~~if `('a' + 1 == 'b') and ('A' + 1 == 'B') and ('0' + 1 == '9')` then this library should work for you. This is the only place where endianess comes into play. Is LE on windows really implemented so that this breaks? (I sincerely don't know, and I don't have a Windows to check.)~~ ~~If this is really the case, I will tone down that comment in the readme and add a few expletives against Windows-designers. I'll then have to see if there is a general way to support those systems without breaking it for everyone else.~~ Edit: now that I think about it, this should work if they use the right comparison and addition-operators internally so that the user doesn't notice. In that case I should probably delete the entire sentences about it… Edit 2: removed it now, I guess I just had a wrong mental model.
Put it on [the list](http://en.cppreference.com/w/cpp/compiler_support). Having more entries that aren't just all green or all red would be quite informative.
The first programming joke I ever told was screencapping a compiler error where GCC insisted that *"`long long long` is too long."*
They are painfully slow, don't throw exceptions on errors and you cannot simply create the desired value as an rvalue, meaning that there is no way to do something like this: const auto val = str_to_&lt;int&gt;("23"); std::stringstream{"23"} &gt;&gt; you_need_an_existing_non_const_var_here;
for (size_t i = n - 1; i + 1 &gt; 0; i--) - basically the same as reverse iterators for vector.
It doesn't have to do anything since x86 is little endian.
I've added folly to [format-benchmark](https://github.com/fmtlib/format-benchmark) and here are some preliminary results: fmt timings: real 1.33 user 1.32 sys 0.00 folly timings: real 1.52 user 1.51 sys 0.00 boost timings: real 7.96 user 7.96 sys 0.00 As you can see fmt is ~14% faster than folly which is a pretty good result considering that folly uses the double-conversion library to format doubles (this is what takes most time on this benchmark) and fmt doesn't. On integer formatting the difference is likely to be bigger.
&gt; I think if you implement this there will be significant performance impact. As I describe in the README, I consider that behavior to be stupid, dangerous and inefficient and one of the main reasons why I implemented sti, was to create a replacement with an API that behaves more sane. &gt; Not sure if the intention was to replace strtol though... exactly that &gt; Should make sure it works with these examples too: No, `0123 != 123` is a very dangerous way to cater to an unbelievably rare use-case at best and a source of serious bugs at worst. If you need that behavior use `strtoi`, but apart from implementing a C/C++/python/…-compiler, nothing of which is a software for normal end-users, I have a very hard time thinking about a legit use case. OTOH think about the accountants who enter their decimal numbers with a leading zero…
It will in later versions :)
I made my own measurements and did some tests. I found out what causes your implementation to be so much slower than boost::spirit. to_digit functions contain "throw" and quite complex error message generation. Simply moving this code to separate function (it can be "inline". At least gcc realizes it's not wise to actually inline that function) will bring performance to boost::spirit and naive implementation level. Too big to_digit function code probably causes cache misses which cause the performance drop. I submitted a merge request.
&gt; constexpr implies const so having them on the same declaration is redundant. Your link goes to the code line `constexpr auto c0 = static_cast&lt;Char&gt;('0');` which doesn't have `const` in it 
&gt; IMHO the `sti`-interface is a lot better than the one from boost I’d be careful with generalised statements like this. You’re definitely right that the `sti` interface is *simpler*. But one of the core aspects of a good API is composability. And Spirit gets full marks here whereas your API isn’t composable. Now, this is entirely fine for simple number parsing, don’t get me wrong. But I find that, beyond simple one-off scripts, whenever applications use such number parsing functions they’d benefit from a proper and/or more flexible parser instead.
Windows API strings use UTF-16. There's no endianness. Endianness is a property of representations , but Windows API strings are specified in terms of `wchar_t` values. The terms "UTF-16LE" and "UTF-16BE" mainly apply when talking about disk files or narrow character streams. 
Stream I/O is slow because: * It has runtime localization support * It can't look ahead in the string 
Awesome, thanks a lot!
&gt; `0123 != 123` is a very dangerous way to cater to an unbelievably rare use-case at best &gt; &gt; , I have a very hard time thinking about a legit use case. How about for parsing C or C++ code? 
I don't think that the C++ standard would be what you want. It's a specification, not a guide to learning c++. The comment I've heard a lot is "The C++ standard is a reference, not a tutorial"
Honest question. Since size_t is unsigned, is the compiler allowed to assume that "i + 1 &gt; 0" is always true and make optimization/UB decisions accordingly? 
Well, I think it'd be a nice extra feature to be able to parse strings like integer literals in code, if you *also* had a proper integer parser.
&gt; You’re definitely right that the sti interface is simpler. But one of the core aspects of a good API is composability. And Spirit gets full marks here whereas your API isn’t composable. Yeah, you are right, I picked the wrong word there; or rather I was thinking about one specific use-case.
I'll check it out tomorrow (It's 00:19 here), but that sounds awesome. Edit: Looks like that really was the main-problem. After merging your PR it really tends to have similar speed to spirit::x3.
Unsigned overflow is perfectly defined, i.e. `((size_t)-1) + 1 == 0` and so compiler cannot optimize `i + 1 &gt; 0` away
You're right, doesn't look very mature yet
Awesome library. Have been a fan for the past few releases. This is one of the first libraries I show to people as a counterpoint in response to "C++ is a hard low-level language." Your library successfully combines ease-of-use, customization, portability, and performance. Looking forward to working with this release. 
No. `wchar_t` is a type. Yes, little endian systems use little endian representation. Other systems may use other representations. 
&gt; ??!??! FTFY
&gt; `for (size_t i = n - 1; i + 1 &gt; 0; i--) ` If `n = 0` then `n - 1` overflows which is perfectly defined (i'm assuming that `n` is unsigned) but will probably index out-of-bounds.
CEDET does do that. It's not perfect, but I use it without any gtags, cscope, or the other things it supports. I imagine it's better with any of that configured. I believe this is it, though I'm not at work atm (the shortcut I use is C-c C-r): [CEDET Symbol References](http://cedet.sourceforge.net/symref.shtml) For me, live project scope grep with projectile/helm makes up for any short comings. None of that is exactly what you requested though.
OK so here is what I see in lvm/projects/libcxx/src/string.cpp from latest git 1. `std::stoi` calls `as_integer&lt;T&gt;( "stoi", str, idx, base )` passing a `"stoi"` c-string that needs to be converted to std::string which might be a potential unnecessary string allocation 2. `as_integer()` calls `as_integer_helper()` passing the c-function that will actually make the conversion (say `strtol`). Then it does other tests and throw exceptions which might be another time consuming task. 3. `as_integer_helper()` calls the c-function and then manages the state of `errno`, which for sure wastes a lot of time. So all in all `std::stoi()` is in fact just adding another layer on top of C and I believe the exception management that is taking a huge toll in performance. 
I know c++, I just want a deeper understanding of how things work and why they work that way.
For OP's library, it doesn't look like a huge deal, indeed. But for bounded::integer, it's every min/max integer combo.
I meant for bounded::integer, which is for every min/max combo.
Well, it's not easy to calculate, which is partially why I'm wary of these kind of libs. You'd have to measure a large application with and without it. It may not add much, but then again, I've never had a problem with strtoul anyway.
&gt; For example for a loop counter you should proobabally use std::int_fast32_t That's your _worst case_ option on x64 because it will require sign-extension for addressing. For loop counters specifically, `std::size_t` is always ideal, or `std::intptr_t` if you need a signed type. (Indeed, this is _exactly_ what the article is about.)
Figure out what command line your IDE used. Then go through the flags one by one and look up what they do. This will give you some idea about which flags are common and useful.
A build tool compliments the compiler to get an IDE-like build process. CMake and GNU Make are normally used on Unix systems. `man` is your friend. Also check the official documentation for the tools you're using.
The upcoming [Boost.Metaparse](http://www.boost.org/doc/libs/1_61_0_b1/doc/html/metaparse.html) can do exactly that.
minimal game using SFML
Is locale taken into account? That is, is "123,456" 123456 in en-us (and an error fr-fr), is "123.456" 123456 in fr-fr (and an error in en-us)?
Since no one has posted any actual concrete numbers yet, here are the results on my system of `sti::str_to&lt;int&gt;` vs `boost::spirit::x3::parse(x3::int_)` vs `std::stoi`. value method elapsed result 1: str_to&lt;...&gt; in 135ms 0 1: x3::parse in 96ms 0 1: stoi in 821ms 0 10: str_to&lt;...&gt; in 185ms 0 10: x3::parse in 111ms 0 10: stoi in 861ms 0 -10: str_to&lt;...&gt; in 181ms 0 -10: x3::parse in 119ms 0 -10: stoi in 857ms 0 1000: str_to&lt;...&gt; in 274ms 0 1000: x3::parse in 142ms 0 1000: stoi in 924ms 0 10000: str_to&lt;...&gt; in 317ms 0 10000: x3::parse in 170ms 0 10000: stoi in 967ms 0 100000: str_to&lt;...&gt; in 367ms 0 100000: x3::parse in 185ms 0 100000: stoi in 985ms 0 1000000: str_to&lt;...&gt; in 419ms 0 1000000: x3::parse in 201ms 0 1000000: stoi in 1016ms 0 -1000000: str_to&lt;...&gt; in 413ms 0 -1000000: x3::parse in 208ms 0 -1000000: stoi in 1009ms 0 I've fixed the iteration count to 10'000'000 for all values. Environment is Win10 x64, Clang/C2 March update x64 -03 on VC++ 2015 Update 2, Boost.Spirit.X3 that comes with Boost 1.60. So, for me X3 averages out to about 81% faster overall.
That would be awesome if it works indeed! Spirit however can parse from decimal format, hex, any use defined one possible, floating point, fixed point, tuples, etc... If you use your style but support all base conversion types that spirit does too then it would be a great easy replacement for small things! 
a minimal bash-like shell
There is always endianness as long as there is a way to screw it. Can you read only one byte at a time from memory? Then you can screw the endianness. Not specified endianness just means follow the processor endianness. 
On VC++ `std::int_fast32_t` maps to `int` regardless of x86 or x64. &gt; since 64bit is faster on x64? It's only faster as a loop counter; otherwise it has no intrinsic benefit over a 32-bit instruction at all, so the fastest 32-bit int is still just `int`.
i think this might be a good starting point: http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list
&gt; But on the other hand, I feel like I need to share the fact that the world of C++ as available to real programmers lags far behind the cutting edge of the language, which in the last decade has seemed to me increasingly like an academic research project further and further divorced from the real world. &gt; In this case, about 13 years behind. Not every project outside of embedded is *academic research*. The *real world* is much bigger than that, and is also populated by *real programmers*. So just because some parts of embedded programmers are disconnected from the present by poorly maintained toolchains, please do not assume that all other *real programmers* work under the same constraints.
&gt; I feel like I need to share the fact that the world of C++ as available to real programmers lags far behind the cutting edge of the language At work, we are using Visual C++ 6 (maintaining a 20yo app).
Isn't the problem rather that `i+1&gt;0` will always evaluate to true regardless of optimizations?
https://www.reddit.com/r/dailyprogrammer Help an open source project, I think Battle of Westnoth needed more hands, there are more.
If that would be safe, nullptr wouldn't be necessary. If NULL was defined just as 0 without a casting to pointer that change may cause the code to behave differently. 
Yeah, but if you don't just read one byte of a `wchar_t` from memory then it's not an issue. C++ works in terms of values, not representations. There's no endianness in the Windows API. You could inspect a particular system's representation but that doesn't matter as nothing in the API depends on it. 
&gt; I've used an IDE to program, and my knowledge of how compiling actually works is up to about g++ a.cpp -o a.exe. That's actually pretty much it, the only thing g++ does is compile c++ code. You might need to learn about how to split c++ code into separate translation units (so that you can compile those incrementally or in parallel). You might want to, for learning purposes, try to understand Makefiles. They are just "shell scripts" that call g++ for different translation units to create different object files, and then call the linker to combine them into bigger object files, libraries, or executables. They also call the linker to link your object files against the system libraries they need (either statically or dynamically at run-time). If you don't know how translation units, object files, and linking go together, look those terms up. Once that it is clear, the purpose of makefiles will also be clear: the larger the project the larger the number of calls to g++ and linker, so makefiles are just scripts that do all those calls for you in a clever way. If you think about portability across different operating system and environments, the purpose of cmake should also be clear: each platform has its own idiosynchrasies that results in makefiles having different "formats". Instead of maintaining makefiles for each platform you want to compile on, you can use CMake to write a "makefile specification" once and let it generate makefiles for whatever platform you want to compile on. 
&gt; [...] they were releasing a compiler update that includes a new compiler built on Clang that supports a modern C++ Bless Clang. The modular design helps a lot, it basically decouple the front end (compiler itself), the optimizer, and the backend (generate code for the target machine).
And as I pointed out, LGPL2+ implies LGPL3 if you want it, where this is not the case.
Nothing out of the ordinary paying thousands for an open-source toolchain. Several platforms that I use professionally charge many, many thousands of pounds for their development environment. When you get right down to it, this is a source code editor (often not a very good one), an open-source toolchain (often a very old one - we are still using GCC 2.95 on one of them!) and an automated FTP &amp; telnet client to copy the executable to the target and reboot it. If you're happy doing a little bit of scripting and building a cross-GCC from scratch, you can do it all for free. No-one does, because £10k for a license is still less than you'd spend arsing around getting it all working right.
Thanks for the detailed explanation, I've simply thrown out both by now.
Oh...that looks very useful as starting point for cmake...thanks a lot, will keep a bookmark for the future.
Naturally: libstdc++ as shipped with GCC5 on x64 Linux, for one-digit, decimal integers. While the factor gets smaller when numbers get bigger, it stays quite large.
/u/Latexi95 proposed some changes that gave my lib another speedup, so those numbers should be outdated by now.
Well, let's hope that most successful software companies in this world consist of moral people who follow the law even if it's completely unenforcable.
The _interface_ is templated. How are you going to put it in a library? Unless you specifically instantiate every combination in that lib. For `bounded::integer` that wouldn't really be possible though. High compilation times are fine for release builds, but can be detrimental in debug builds.
Currently it's not really possible. Modules should make templates faster to compile though (once instead of N times).
I don't believe this is true? Templates will only need to be parsed once (with modules), but I can't see how you could prevent needless template instantiations, since you don't know what instantiations will be needed until they're used in different object files. If I use `Foo&lt;int&gt;` in three different files I don't know how the compiler can prevent 3 instantiations of that. So slight speed up, but not as much as you're thinking.
Your if statements need `==`, not `=`.
Thanks for the kind feedback and spreading the word =).
Are you sure that using 10 multipliers, instead of random numbers, is not affecting the results? In my tests after changes I made, sti, and boost spirit speeds were pretty identical. Naive implementation was only slightly faster
Yeah, you are correct. I should remind myself that there are a lot of features of the Keil MDK I really like, especially for debugging and profiling, and they have in fact saved me enormous amounts of time. I have used other kinds of toolchains over the years for embedded, sometimes ancient compilers and hand-edited Makefiles and link maps in DOS boxes, and some things have actually improved over the years...
http://adventofcode.com
I meant simply this: any given program will use a small set of instantiations. One can wrap those instantiations into a library and expose as non-templated code, use this from precompiled header etc.
But that doesn't really work for `bounded::integer`.
So, what does this do that standard source code analysis present in most IDEs doesn't do? I'm trying to understand if all I get for my money is graphs only, or something more. I don't think I'd need the graphs for anything...
Off topic for this subreddit - please go to /r/cpp_questions.
noexcept looks like it is definitely an improvement. I look forward to being able to use them. Any time now...
Even then, do you really have so many of the combinations? Also, you can enable function merging to merge identical function definitions at binary level. Then only RTTI is remaining... the one C++ feature which is often paid for even when unused.
What most IDE's give you is "Go to definition", "Find All References" and maybe "Find symbol". That is already pretty nice for some quick lookups, like figuring out where a function is called by looking at all references in the list file by file. But if you are working on a big code base, that you didn't write yourself, you spend a lot of time doing these "quick" lookups. Where is this function called, and who calls the caller and the caller's caller? What classes are derived from this interface, and which methods get overridden by which class? Where is this field accessed and where does it get assigned? About 70% of a software developers time is actually spent reading source code and there is still no proper tool for that (https://blogs.msdn.microsoft.com/peterhal/2006/01/04/what-do-programmers-really-do-anyway-aka-part-2-of-the-yardstick-saga/). So we developed Coati, a tool designed for exploring and navigating source code. Coati analyzes source code and provides the user with a simple user interface for navigating this data: The search field knows all the symbols; the graph visualization shows how the symbol relates to others and the code view shows all the details of the implementation. The graph is the most noticeable piece of the UI, but it's just one part of a bigger UI concept. Having used Coati for a couple months now, I can say that it has proven to be useful in lots of cases, especially when reading code of a teammate. I truly think that we are onto something big here. If you want a test license please write to support@coati.io or send me an e-mail address via direct message. Sorry this has gotten so long.
OpenMW is a open source Morrowind engine and they were recently looking for C++ developers to contribute. 
A programming language interpreter. Lisp would be easiest, since the grammar is pretty much just lists.
hi everyone. This is Steve Carroll, the dev manager for the Visual C++ team. Tl;dr: thanks folks for the feedback. Our team will be removing this from our static libs in Update 3. Our intent was benign – our desire was to build a framework that will help investigate performance problems and improve the quality of our optimizer should we get any reports of slowdowns or endemic perf problems in the field. We apologize for raising the suspicion levels even further by not including the CRT source, this was just an oversight on our part. Despite that, some of you already investigated how this mechanism works in nice detail. As you have already called out, what the code does is trigger an ETW event which, when it’s turned on, will emit timestamps and module loads events. The event data can only be interpreted if a customer gives us symbol information (i.e. PDBs) so this data is only applicable to customers that are actively seeking help from us and are willing to share these PDBs as part of their investigation. We haven’t actually gone through this full exercise with any customers to date though, and we are so far relying on our established approaches to investigate and address potential problems instead. We plan to remove these events in Update 3. In the meantime, to remove this dependency in Update 2, you should add notelemetry.obj to your linker command line. If you’re generally concerned about phone-home scenarios, more information about how to configuring Windows 10 appropriately to your needs can be found here: https://technet.microsoft.com/en-us/itpro/windows/manage/configure-windows-10-devices-to-stop-data-flow-to-microsoft#bkmk-priv-feedback Thanks.
added here: https://www.reddit.com/r/cpp/comments/4ibauu/visual_studio_adding_telemetry_function_calls_to/d30dmvu
Thank you for the answer I don't think burning the feature down is necessary. But put it behind a flag, or better yet, in a separate library / object that must explicitly be linked/called. &gt; Our intent was benign – our desire was to build a framework that will help investigate performance problems and improve the quality of our optimizer should we get any reports of slowdowns or endemic perf problems in the field. Great. But the CRT should not be "a framework that will help investigate performance problems". That's better left to the FTWHIPP. Sane defaults yada yada. 
I was wondering when the next version would be out. Thanks for posting this. 
That approach is very brittle and would only work if the relative positions of every byte of data is the same between instances of the program. It is just better to use proper data serialization for compatibility reasons. 
yep, appreciate that feedback. 
http://exceptionsafecode.com/
Write a small game engine. Pick a 2D game you'd be interested in making and write it from the ground up. How much of it you can realistically write yourself depends on the amount of time you have for your project. I'd recommend using a framework that encapsulates things like input events and rendering (unless that stuff is interesting to you and you have the time). SFML would be a pretty good fit. It abstracts a lot of lower level stuff such as OpenGL and HID. Get a few good books related to game and engine development and you should be good to go, as long as you can invest enough time. I really like Jason Gregory's Game Engine Architecture and Bob Nystrom's Game Programming Patterns. 
Yeah, I've got a whole pile of articles and Herb Sutter's books... it ain't pretty. I was interested to learn of the existence of the Cppcast and the _C++ Today_ book, so thanks for that...
Writing *anything* in c++ not small enough to fit into one code file is much more complicated than a language like java, particularly when you're new to the language. Make sure to lower your scope a bit. If you don't mind a bit of 3d/vector math, ray-tracers are fun and very open-ended to extending functionality and scope as far as you want. There's a great book, "Ray-tracing in one weekend", that is a great starter, plus two more books "Ray-tracing: the next week" and "Ray-tracing: the rest of your life". They're like $3 each too! Edit: why am I being down-voted without explanation?
That would be the same thing. You'd still have to cast this to const and cast away const on the returned value. It would just move the work the const version does into a private function for (if I understand what you mean) no reason.
You can believe an argument, instead of a person. Signedness: * Is not unlike null references, which Tony Hoare calls his [billion dollar mistake](https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions). If you're always using signed integers; but you almost never *need* signed integers; you are constantly having to check for negative values. * Is implicit overloading. If you have MoveForward(unsigned int), you can only use it to move forward. But if you have MoveForward(int), you can use it to move backward by passing a negative value. If there is a security distinction between moving forward and moving backward, you cannot just prohibit access to MoveBackward; you also have to check for negative parameters to MoveForward, and ensure that no internal calculation could result in a negative value being used. C and C++ are mostly un-designed languages, and are therefore full of these artifacts. C++ not only has the possibility of * having to check for null pointers everywhere people can't use references; * having to check for negative values everywhere people don't use *unsigned*; but the language has *in addition* defined object move construction and assignment in a way such that objects must have null states, which then also must be checked. So you have the equivalent of the "null reference problem" in *at least three places*. As far as appeal to authority goes &amp;ndash; consider that the same author and committee that brought you C++, also brought you C++.
X-Post referenced from /r/programming by /u/mntruell [A lightweight C++ machine learning library for embedded electronics and robotics](https://www.reddit.com/r/programming/comments/4iryfl/a_lightweight_c_machine_learning_library_for/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^my ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
&gt; analogy to completely unrelated bad thing Let me get that for you: https://www.logicallyfallacious.com/tools/lp/Bo/LogicalFallacies/181/Weak_Analogy This has nothing to do with null pointers, and nothing to do with move construction. I've heard all these arguments before, they're weak, all of those really smart people have presented really strong arguments, which I've listened to. Wide consensus of experts is "appeal to authority" in the context of debating societies; in a more practical viewpoint it should very very strongly affect your priors in a Bayesian sense. Your first example is especially fun to debunk: void MoveForward(uint64_t step) { m_step += step; m_data[m_step]... } Hmmm, so if `m_step` and `step` are both unsigned, we'll be doing some addition in a *modular* space, so if -1 is passed for`step`, which will implicitly convert (or, if you prefer, could just pass the largest unsigned integer)... See where this is going? It's basically equivalent for MoveForward to take signed or unsigned.
Not sure why I am problematic, I have not resorted to personal statements. We had a discussion about throwing from destructors, another example where there is overwhelming consensus that throwing from destructors is highly specious and should be avoided as much as possible. Our discussion was civil. As to your other comment: great, I think we've found agreement. You believe unsigned should be used preferentially *if* arithmetic yielded hardware exceptions by default on overflow. Since it does not, you agree that example is moot, and will be using signed from now on, right?
&gt; Not sure why I am problematic, I have not resorted to personal statements. You don't have to make personal statements to be problematic. It is sufficient to be adversarial. You wrote a statement of mine was "fun to debunk". You did not debunk anything. You instead replied using unreasonable assumptions that indicate you either have no desire to understand what I'm saying, or are *incapable*, and yet arrogant about it. This makes you less than completely desirable, no matter how I slice it. &gt; You believe unsigned should be used preferentially if arithmetic yielded hardware exceptions by default on overflow. No. You are again too clever by half, and this is not moving the conversation forward. In the absence of hardware exceptions, you have to check the upper bound for all parameters, signed or unsigned. Then in addition, you have to check for negative values with signed integers. This check can be elided for unsigned.
I wrote "fun to debunk", I meant just that. It's not arrogant because I'm not putting myself on a pedestal; anyone could debunk it. Now you're insinuating I'm incapable of understanding you, escalate much? &gt; you less than completely desirable Escalate *much*. It can be elided for signed as well on any 2's complement machine, i.e. any machine you're likely to be programming on. I guess then you're too clever by unsigned half, implicitly converted to signed, where the largest signed clever_t is half-1.
What I plan on doing this summer is writing a compiler in c++ for a c-like language (I plan to implement ints, loops, and if statements, I'll see what all I can do over the summer) and target arm architecture. Finally something I can use my raspberry pi for!
*sigh* Yes, you can do: if ((uint) value &gt; X) But then, why use an int to begin with?
&gt; You don't have to make personal statements to be problematic. It is sufficient to be adversarial. Oh _good lord_ forbid someone disagree with you!
&gt; Software that wants overflow should use special operations to indicate it's desired. Like, for example, using an unsigned type..?
&gt; Oh good lord forbid someone disagree with you! Premature disagreement is mostly indistinguishable from idiocy. When discussing a technical matter, useful conversation is not really about conclusions, it's about exploring the landscape and calling out its features. If you find someone who thinks differently about something, the proper thing to do is to ask *why* - what other features of the landscape is this person seeing. So, it's not that a person is an idiot because they disagree with *me*. It's because they approach the conversation by completely skipping the step of exploring the landscape, to begin with.
Same here!
Eh, you're the one who seems to have some hangup with /u/quicknir, not the other way around. Indeed, in _this_ thread, you appear to me to be the only one "skipping the step of exploring the landscape", citing the strawman of previous discussions with someone else in order to dismiss this discussion. Just sayin'.
6 months... you could read many of the papers in WG21, from the c++ proposals and pick some of them you would like to have in the standard and implement them, the ones that belong to libraries. That would be a good learning exercise, besides that, it would be really useful for the community. :)
&gt; Like, for example, using an unsigned type..? You seem to be assuming a fictional universe where using a signed type gives you automatic overflow checks and exceptions. If such checks and exceptions were for some reason bundled with signed types, then I would use signed types to benefit. However, I would find the bundling of such checks with *signed* types, in particular, a questionable decision, and would prefer to be able to use these checks with unsigned types, also. Signedness is a form of overloading. Overloading is implicitness, and implicitness that can't be avoided is a bad design. A good design needs to encourage explicitness, with any implicitness carefully weighed against its security implications.
Where exactly are the C++ proposals?
You're the one that wanted overflow checks and exceptions, not me. I'm _totally fine_ with overflow being UB, just like I'm _totally fine_ with not having traffic signs pointing backwards on the highway "just in case someone doesn't follow the rules" and gets on the wrong direction – that's a pointless expense, and all governments I'm aware of agree. - If I know overflow won't occur and care about the optimization benefits, I'll use a signed type. - If I want overflow to be legal for validation/verification purposes, I'll use an unsigned type. - If I want overflow checks and/or exceptions I'll used a checked type. Three solutions for three different problem-scenarios is totally fine with me. Just because it isn't for you, why do you assume everyone agrees with you? EDIT: To clarify, I personally go against the C++ committee's current wisdom of using signed types whenever possible, and strongly prefer unsigned types. I just _also_ think signed overflow being UB is perfectly acceptable, even a good thing, since it gives signed types some use.
To piggy back off of this. You could do something with robotics. Writing something like a particle filter for perception with robotics is similar to a Monte Carlo simulation and has some real-world industrial applications that are very popular in robotics (even though most people use Kalman Filters instead of particle filters). 
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/ 
yeah, i'm the dev manager for VC++ so I watch /r/cpp pretty closely to stay in touch with what's going on with engaged c++ devs. I wanted to make sure I had the complete story before I posted so I needed the extra day to ask a bunch of questions of the team before we made a decision and responded.
to be honest, I'm never quite sure what the appropriate reddiquette is on points like this. I really value this forum as a way to gather information on trends in cpp and a way to get a head's up on issues like this so I try to be pretty cautious with things that might be considered self-promotion. In this particular case I added a top level comment and then linked to it from places that people specifically called me via /u/spongo2. :) but, my comment above is now the team's plan of record and I'm not trying to hide it or anything.
Neural network? :)
I'm just a little concerned as this post got a lot of views, but few will be interested enough to check back for updates (though I for one was kind of stalking your account for the last few days :p). Simply I want for those other people [that don't check back or don't care about MSVC] to know what's up as they may have formed an (quite negative) impression that would matter when they do start to care doing stuff in MSVC.
If you want, I have some basic but useful documentation I wrote on compiling through the command line with gcc and g++. It's very simple and readable. You can learn everything I have just by Google searching and putting in some work though. Edit: Sorry guys my internet has been out due to storms. Here's the link: https://github.com/Adobe-Android/Cpp_Docs/blob/master/G%2B%2B%20Compilation%20Reference.txt
Why bother making this comment if you're not going to post a link?
I really don't know why you feel the need to burden me with these perceptions.
Because you're the one who took _your own_ thread and turned it from a discussion into an argument. And because I've seen you do this on multiple occasions. Glass houses and all that...
Quoth the mighty standard thusly ( [conv.integral]/2 ): &gt; If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2^_n_ where _n_ is the number of bits used to represent the unsigned type). [_Note:_ In a two's complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). —_end note_] I.e., modular arithmetic guarantees defined behavior.
You're telling me I'm unqualified for my career now? Yikes! You can write security embedded software using library types instead of builtin _**primitive**s_ (I trust my emphasis doesn't go unnoticed) – I've been paid to do that for years. ;-] You expect too much of poor, simple `int`; it has well-defined behavior, including the undefined parts! That is enough; further domain requirements are best left for libraries, and on that I can't imagine we disagree...
In my opinion, quicknir expressed himself in a way that was disrespectful. I therefore replied in kind. Quicknir recovered, and I recovered in kind. Maybe I am being over-sensitive. However, no one has to *keep* having an argument with me, unless they want to. I am, generally, always open to recover.
I do not; I just came to the discussion a few hours later than you two and my responses were order read, not order said. :-]
&gt; Do bad calls need to happen in order for undefined behavior to be triggered? The behavior of undefined behavior is undefined, even on a temporal level. ;-]
:-) Yeah, I find it funny when people say the same to me. Then again, I've sometimes changed my mind after such conversations. It can be traumatic when people say things ignoring credentials. But it's valuable to have a way to discuss that ignores credentials. Max Planck is quoted as saying that "Science advances one funeral at a time." At least [one study](http://www.vox.com/science-and-health/2015/12/15/10219330/elite-scientists-hold-back-progress) has found evidence to support this. This indicates that credentials lead to a sort of rigor mortis where we take for granted what's actually detrimental and obstructive. If we have forums like this, that do not respect credentials &amp;ndash; where even the most senior experts' long-standing convictions can be challenged as bullcrap and bullshit &amp;ndash; perhaps we can have progress without having to have as many funerals. Which is to say &amp;ndash; perhaps... we can trade our deaths as people, for many small deaths of our egos. :) Anyway. You argued there are different tools, and one of them is a checked type. That is my qualm &amp;ndash; there isn't a checked type that's also performant. I shouldn't have to slow down every aspect of my program to get checked arithmetic. And yet... there we are.
&gt; So I could have some bad code deep inside the source that never gets triggered and it could still mess things up? Or source that doesn't execute because it was conditional on UB, e.g. relying on the behavior of signed integer overflow. &gt; Gezz, this is funky stuff...not sure where to start. Yes, it can be a mess. ;-D
&gt; that never gets triggered No, the compiler has to prove that the code is *always* triggered to optimize undefined behavior backward in time. In this case that code can simply be compiled out just because is UB (no need to prove that is never triggered).
Sorry, all intern positions for this summer have been filled
`std::take_innards` would have had my vote.
They thought about it for 10+ years. At one point it was about adding "move constructors", opposed to already-existing "copy constructors" so the topic was copy vs. move and the name stuck.
std::move is just a cast to rvalue. int -&gt; int&amp;&amp; It's implementation is really simple. Just std::remove_reference and static_cast It could be a keyword but using a word like "move" would break so much code. They are not going to add additional keywords unless it's absolutely necessary
Also, "move" telegraphs the intent much better but this is of course subjective. The downside is that if there is no one to receive the "move" then it is NOP, which is a case where the rvalue_cast would be more descriptive: "doesn't do jack ****" :P 
Rvalue references are just references with different "conversion" and binding rules. Because of this, std::move() is little more than a cast.
std::move makes the code more readable, revealing the intent of the cast to an rvalue. It is more confusing when read in the docs than when seen in action. 
We work with Qt ourselves. It works fine with Coati, except for the SIGNALS &amp; SLOTS stuff, because it uses macro action that converts the function names. We haven't tested the other frameworks. Coati uses clang for analysis, so generally speaking you can analyze every standard C/C++ source code. If you want to test Coati on some code yourself please write to support@coati.io
You're welcome. :)
TIL that the following aren't equivalent :( template &lt;typename T&gt; auto foo(T&amp;&amp; t) -&gt; decltype(t.bar()) { return t.bar(); } and template &lt;typename T&gt; auto foo(T&amp;&amp; t) { return t.bar(); } As much as I love C++ I'm starting to see the point of people that say it's too complicated.
In any case, people who prefer a different name can just inject it into std namespace a e.g. rvalue_cast. 
&gt; if you’re like me and you like to implement your own locks This would get **so downvoted** if someone else who didn't work at apple posted it.
thanks for improving the CMake experience!
Hey, I had exactly same problem. We had to write a 1500 LoC C++ program. I used SFML and made this in about one month of work (mostly debugging, cuz used TinyXML and it was parsing xml level data very slowly due to some bugs in the library), then I used RapidXML and it solved all my problems. Used Tiled editor to draw a map using downloaded tilesheets. Collision is not per pixel perfect, but using AABB instead. Flowers are animated and player is doing animation, while moving, also when player moves &gt;50% of screen, the camera is following him, pokemon style. Here is the screenshot http://i.imgur.com/eYEM1kv.png Later SFML was limiting me, cause I wanted to easily use OpenGL and move to 3D, so used SDL2. It is handling much better window creation and mouse stuffs, but is lowlevel and requires much more work. In SFML I could simply use sf::VertexArray which was super to draw whole map in one drawcall, instead of making a draw call for each tile and so I didnt have to play with OpenGL at all, I could focus on C++, but in SDL I have to manually setup the vertex array, send data to shaders and draw them, is a bit harder, but gives you freedom. This is some of my progress in SDL and OpenGL http://i.imgur.com/vBLBjrS.png (gui, FPS camera looking at another camera - drawing its frustum + culling green points are inside frustum, red are outside, loading 3d animated models, using geometry shader to draw vertex normals) - it was few months of work to learn. I did not read any books while doing this 2D game, cause I was so curious and wanted to do it while discovering. Then I had so many questions and was reading Stroustroup's and Meyer's books and later OpenGL online materials. Hope you get some idea and will choose what will fit you :)
You are welcome:-) I hope I can coax some better information on the project out of CMake for the next release, but unfortunately that build system is not really forthcoming with the information it has:-/ So no promises there.
Nope. Qt Creator is still built by most people using qmake (qbs is still an option for that). For your own projects you can still use qmake, qbs, cmake and autotools (after enabling the appropriate plugin if necessary). I hope I did not forget any supported build system:-)
I saw you were also engaged in the CMake daemon mode discussion, is there any progress? For me, this sounds like a very promising path! 
Well, of course. When you start injecting things into std you better know why. As for why, for the std:: purists who think a feature should be in std::. I'm quite fond of std::move, conveys it's intent well.
I wonder if money would solve this. It's in the interest of the whole C++ community to have a cross platform build system which works with all major IDEs. One major quirk of CMake is its debugging part. [cmake-deamon](https://steveire.wordpress.com/2016/01/24/cmake-daemon-for-user-tools/) fixes this problem. [The Standard C++ Foundation](https://isocpp.org/) has money, wouldn't it make sense to invest in one major part of C++?
It's part of the C++ design philosophy: you should never introduce a compiler change where a library change will do. The minimum compiler change required to support std::move was rvalue references, so that went into the language.
"move()" doesn't empty the object being moved. rvalue overloads might - in this case thread must have a move assignment operator that slurps the guts out of its source (i.e. 't').
`std::move()` is not doing that, the move constructor for `std::thread` is. `std::move()` casts the expression to an rvalue, which makes the move constructor a better match than the copy constructor during the overload resolution phase. And the move constructor contains the logic for stealing the guts out of the object being moved from, whereas the copy constructor is not allowed to touch the object being copied from. Edit: in the specific case of `std::thread` the copy constructor is deleted so it can't be called, but that doesn't always apply in the general case. 
The rationale is to highlight the move operation.
That makes sense, thanks.
You used two operations in the second line and complain as if only one operation took place. 
"move enables move semantics" "Why?" "Because it makes it an rvalue" "What's an rvalue?"
&gt; The author of said patch does not want to continue to work on cmake. Isn't Stephen Kelly the author of this patch? IIRC he's the guy behind the daemon mode and also the guy behind most if not all of the awesome changes that modernized CMake. Are you saying he stopped working on CMake? That would be a tremendous loss.
More like "because it is used to invoke the move constructor". 
Ping [/u/steveire](https://www.reddit.com/user/steveire) for more info. Maybe he can shed some light. Pushing cmake-deamon upstream requires work, maybe [The Standard C++ Foundation](https://isocpp.org/) can fund this work. They have funded Eric Niebler for his ranges work, so there is a precedent :)
As far as I know those are unchanged. You could try a generic highlighter. That should help a bit, even though it is not a real code model backing the highlighting.
The cmake is improved, but I can no longer use ninja build on OSX? Anyone else seeing this issue? Also, being able to define cmake variables seems to be missing. I search for bugs for both (https://bugreports.qt.io/browse/QTCREATORBUG-16163?jql=affectedVersion%20in%20(%22Qt%20Creator%204.0.0%22%2C%20%22Qt%20Creator%204.0.0-beta1%22%2C%20%22Qt%20Creator%204.0.0-rc1%22%2C%20%22Qt%20Creator%204.0.1%20(4.0%20branch)%22%2C%20%22Qt%20Creator%204.1.0%20(master%20branch)%22)%20AND%20text%20~%20%22ninja%22) and couldn't find anything... Anything I am missing before opening an issue?
Just tried and i cant seem to find a way to ran cmake with my preferred options.When i start my project,it just runs cmake to configure the project and i cant seem to be able to add additional options. It was possible in previous versions to do so easily because Qt creator generated a prompt with a text field where cmake options can be entered. 
You can configure cmake flags in the Projects panel (Ctrl + 5).
I was refering more to that general statement that &gt; The author of said patch does not want to continue to work on cmake sounded like "does not want to continue to work on cmake **at all**". I was looking for some clarification regarding whether that referred to Stephen Kelly and maybe his reasons if it's him, and not specifically regarding the daemon.
That panel seems to allow me to edit options that are already there,what i was looking for was to add an option that was not auto added there. I seem to have discovered what i needed to do and that is to go to menu-&gt;tools-&gt;options-&gt;build and run-&gt;kit-&gt;kits-&gt;select kit-&gt;click "change" on the cmake configuratio line to get cmake configuration dialog where i can add my custom cmake option. I think the above worked and it is not very intuitive,i am not even sure thats whats needed for it to work but my problem is now gone. This is not intuitive at all.
You really created an lvalue function so you wouldn't have to declare your ifstream on the line above? There are also some trivial cases where your function is rather unsafe, like int&amp; a = lvalue(2); Which would compile, but dangle. I actually think the compiler should warn for these (detect whether or not T&amp;&amp; r is a temporary, and give the same warning about returning an lvalue ref to a temporary).
Why not do it directly? template&lt;typename... Args&gt; std::vector&lt;std::size_t&gt; calcSizes() { return { sizeof( Args )... }; } [**Live example**](http://coliru.stacked-crooked.com/a/0c5e2111c931753a)
Well, because I'm not so smart :D. Let's now think that the post is about a small collection of useful programming techniques. I'll update my post, thank you.
hi! thanks for the reply and to be honest, I'm actually quite happy that people are noticing our more open stance. We try hard to make sure the message gets out about the work we do. In this particular case, we decided to abandon this plan almost as soon as the code was completed so we never got to the point where we publicized it. I agree that it would have been good to survey this one in advance.
Absolutely agree. Especially with small and direct code. I'll not remove post thought because I put a time on it. But will update it definitely. P.S.: That's why I love reddit - I always get very delicate and precise feedback on my posts. 
The point of having an rvalue is exactly why it was named `move` in the first place: to specify that you want to move the value from this source into some destination, rather than just copying it. That, of course, assumes that there's an rvalue constructor (or assignment operator) for the type that will actually do a move instead of a copy. That's not always the case, but is often enough to be pretty useful. In case it's not clear what the use of doing that is: almost exclusively speed. At least in the vast majority of cases, the primary reason to do a move instead of a copy is that it's faster. In a few cases it has a secondary advantage that the move is guaranteed not to throw any exceptions (where a copy frequently would). The typical example would be something like a large string or `vector`. A vector will typically contain something like one pointer and two integers. With a move, you just copy those directly (and typically zero them out in the source). By doing that, you avoid having to allocate a whole new block of storage for the data, and copying all the contents of that storage to the new vector. For a really tiny vector, expect this to be 3 to 5 times as fast. For a large one, it can easily be thousands of times faster than a copy. The other big reason is move-only types. These are less common, but still common enough to note. The obvious example here is a `std::unique_ptr`. You're not allowed to copy one (that's what the `unique` refers to), but you are allowed to move one (because that maintains its uniqueness). Nonetheless, the most common case is just to gain speed.
It's been a while since I looked at Qt Creator, so apologies if this is a trivial question. Last time I used it (around 2012 I think) I immediately searched how to remove that vertical bar on the left (Welcome / Edit / Design / etc...), and I could not find anything, so I closed it forever. Has this been adressed since then ? 
I'd say this is way too hard for a beginner in many cases. For example, most of them cover at least move semantics.
&gt; The assumption is that cmake will put everything it cares about into its cache. So there should be no need to add values:-) Seconding the fact that this 100% wrong. The old dialog that allowed first-run defines to be added is a necessity.
Thanks so much! I tried PATH= once, but didn't work. I don't think I escaped things correctly... 
Looks like I'm gonna give it a new try then :) Thanks !
Bah. I can now compile, but no source files show up in the "Project" other than the root CMakeLists.txt file. The executables are also missing... I guess I'll have to go back to Make, and sit around while it takes forever to build!
I don't know of one, no. However, [this](https://github.com/facebook/hhvm/blob/master/hphp/runtime/base/atomic-shared-ptr.h) turned up in a DuckDuckGo search. I don't know anything about its correctness or usage. I will try to catch Michael before the week is over and ask him if he is willing to share his work.
I hadn't heard of RCU, thanks. I'll read your link in the near future. I was unaware of Petrank's work with Timnat. That paper will take at least a couple of days for me to process -- maybe much longer.
&gt; Is there a third option? Inherit from the default exception and have the best of both worlds.
In my opinion, all exceptions MUST: * Derive from std::exception or childs; * Use custom type defined in your public headers; * Derive from your module base exception. Raising &lt;stdexcept&gt; exceptions is a bad idea because they can clash with other libraries exceptions. So instead of: &gt;try { &gt; work_from_moduleA(); &gt; work_from_moduleB(); &gt; work_from_moduleC(); &gt;} catch (ModuleAError&amp; ) { &gt;} catch (ModuleBError&amp; ) { &gt;} catch (ModuleCError&amp; ) { &gt;} library client will be forced to wrap every API call into separate catch block to distinguish errors. Deriving your exceptions from &lt;stdexcept&gt; will allow to catch errors by generic category and log error message from what(). Finally, your base module exception makes it easy to suppress any exceptions from your library and propogate other exceptions down.
I found a workaround that does not involve creating project-specific kits. In short, hand-edit the CMakeLists.txt.user that QTC creates to add the variables you need to the sections with key "CMake.Configuration".
Show the first error in the output tab.
You use VS2015 Update 2? The project is created newly with that VS version?
I also developed a small JSON library earlier and faced a similar problem: // simplified version struct object { T get(std::string key) { return impl_map.at(key); } }; This get() function can throw a std::out_of_range exception. However I think a new invalid_key exception is much more expressive. So I had to catch out_of_range and throw an invalid_key However there is a interesting possibility: user may pass a template parameter which you can throw: template&lt;class Ex=invalid_key&gt; T get(...) I do not think it is an answer for your question, but it may give you some idea.
Looking briefly at the implementation, it seems that shared pointer allows different threads to all refer to a shared object through different copies of the shared pointer (ie the shared reference count manipulations are all atomic). In other words, it is just like std::shared_pointer. atomic_shared_pointer allows different threads to access the same atomic_shared_ptr. 
Have you looked at moodycamel concurrent queue? It works very well, I've already relied on it quite a bit.
I'm having a hard time finding a good example involving move().
Why yes.
Re-run the installer and select the components. 
See this thread: https://www.reddit.com/r/cpp/comments/4iucld/qt_creator_400_released/d31839c Also writing to CMake mailing lists should bring you more answers: https://cmake.org/mailing-lists/ Our hope is that somebody with deep pockets sees the cmake-daemon's potential and fixes this problem by throwing money at it :)
You can have a look into how [KDevelop parses CMake files](https://github.com/KDE/kdevelop/tree/master/projectmanagers/cmake). You can also find [build instructions here](http://kfunk.org/2016/02/16/building-kdevelop-5-from-source-on-ubuntu-15-10/). You can even contact the KDevelop developers on the [mailing list](https://mail.kde.org/mailman/listinfo/kdevelop-devel), since afaik they are also interested in making a proper cmake parser lib out of this. Besides that, also QtCreator handles cmake better now in version 4, so it may make sense to get an idea from there, too.
That daemon was updated 2 months ago. In the world of compilers and build systems, that's considered very recent.
I've looked at it, and it appears to be a tweak to the venerable [lock-free CAS queue](http://www.research.ibm.com/people/m/michael/podc-1996.pdf) with additional fine-grain parallelism (to further eliminate contention). While lockfree, it's not wait-free (like the paper OP posted). But more importantly, it has a [limitation](http://moodycamel.com/blog/2014/a-fast-general-purpose-lock-free-queue-for-c++) which makes it unsuitable for some domains: &gt; Of course, this also makes dequeueing slightly more complicated: Now we have to check every sub-queue for items when dequeuing. Interestingly, it turns out that the order that elements are pulled from the sub-queues really doesn't matter. All elements from a given producer thread will necessarily still be seen in that same order relative to each other when dequeued (since the sub-queue preserves that order), albeit with elements from other sub-queues possibly interleaved. An example with 3 concurrent threads consistently hitting this queue: Producer threads A and B, Consumer thread C Time| Thread A | Thread B | Thread C ---|---|----|---- 1| enqueue(a1)| | 2| |enqueue(b1)| dequeue(a1) 3| enqueue(a2)| enqueue(b2) | dequeue(a2) Since thread C was still working on A's subqueue, it may have automatically picked up a2 despite the fact that b1 was enqueued before it. It may be a product of an asymmetric producer/consumer issue, but for symmetric cases there's no guarantee of ordering (since thread scheduling is usually left to the OS). For symmetric cases, I believe it may be more logical to assign a specialized single-producer, single-consumer queue for each pair anyway and do away with the master "god" container- since it complicates things IMO. tl;dr - Ordering is only maintained for each producer's dedicated subqueue. I imagine that the majority of users won't be negatively affected, since they're usually using serial threads and would only care about ordering sequence for each producer enqueues- think of a server handling incoming requests from multiple users- servicing requests from different users out of sequence would go largely unnoticed (and might actually be more ideal due to cache, locality of reference, etc), as long as each user's own request is handled in the proper order. However, this solution becomes unsuitable once you start performing related enqueues via multithreaded dispatch mechanisms like a threadpool or task scheduler. The concept of "producer thread" gets very cloudy as you migrate from serial multithreaded to task-based architectures, and the inability to maintain ordering between enqueues and dequeues across individual subqueues could potentially present a serious hindrance. Recently, I opted to use tbb::concurrent_queue for our asynchronous event handling system (we're also using TBB's task scheduler), and it's been pretty scalable as far as parallelism goes. I am looking forward to seeing implementations of Kogan/Petrank waitfree queue as C++ catches up.
That's a good point - and one advantage of approach 1: any exceptions from STL containers blend in nicely with the own exceptions...
To get compiler flags on the various source files you can do this: cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON [path] and pass the generated compile_commands.json to libclang.
For some reason the ping from /u/cristianadam didn't actually ping me (should it have? I don't know lots about reddit), but I stopped by the thread anyway. I'm still interested in making the daemon mode happen, but I can't do all the work. Kitware people have been completely silent on the topic: http://thread.gmane.org/gmane.comp.lib.qt.creator/11794/focus=16116. I haven't been working on CMake for several months already for various reasons, but all I was doing for the preceeding year was refactoring to make the daemon possible (and generally clean up the code). Without a reason to do that, it's not a good way to spend my time :). The last feature I added landed in CMake 3.3 (exporting targets which populate INTERFACE_SOURCES), so you might eventually notice the features in the vein of 'usage requirements' dry up, depending on how up to date your cmake release is. Thanks for the feedback that you appreciated the work I did on CMake! Modernizing it was a lot of work over multiple years, and most people don't know about it. You can watch Bill talk about moderizations in https://www.youtube.com/watch?v=TqjtN8NGtl4 and he says 'we' so much, anyone would think it was the work of Kitware, but that's not the case. 
I'm glad to see that people took notice of the cmake daemon idea, and that it's generally seen as promising by the community. The internal refactoring that would be required in CMake to make a library API for advanced features is the same refactoring that would be needed for a daemon mode. However, I think a daemon mode has a greater chance of being accepted than a proposal to add a library interface. Nevertheless, there has only been silence from Kitware in response to the blog and video I made, so that is part of the reason for stalled progress on the daemon http://thread.gmane.org/gmane.comp.lib.qt.creator/11794/focus=16116 - I don't know what to tell to people who are interested in working on it. It would not be a huge amount of work to finish the daemon enough to get an initial version upstream.
Hey, thank you for this awesome response! I read through the thread you linked, it seems like the interest from a number of people is definitely there, including Brad King, who seems to like it too. But yes, it seems like nobody really wants to commit to anything. I didn't watch most of the talk you linked, but I really hope you are getting the credit you deserve, but if I know about it (and I'm not too into CMake intestines) chances are a lot of other people do too! :-)
create a build dir, run cmake in it, open generated *.cbp file.
And, you can often fit it within the stl api, so you get my_company::sort_works_great_on_our_particular_use_case( begin, end ); So you get the best of both worlds. We did this with both algorithms and with containers and it was very very useful. 
With Coati we actually do the same thing. You can also feed the compile commands from the compilation database directly to clang tools - so the integration works quite well. Listing a projects headers is a different story. As CMake only provides you with the include directories you could either list all headers found in these directories or you could try to feed the compile commands to a clang-tool and use the preprocessor callbacks (http://clang.llvm.org/doxygen/classclang_1_1PPCallbacks.html) to detect all the headers that are really included somewhere.
Yes, exactly - thank you so much.
I have never seen a speaker in C++ conferences that I enjoy his talks like Chandler Carruth, he presents his material in an interesting way always, Love all his talks.
&gt;In C++, methods have to be part of a class and defined (or at least declared) in its body. You cannot add a method to a class without changing the class's source code. ... but free functions are still a thing. Template each evaluator and then define for each type. New type? Implement evaluators for new type. New evaluator? Create the new template and implement for each existing type. There's life beyond classes in c++;
IMO the major point of the STL is that: &gt; STL algorithms are designed to scale They are not designed to be the fastest solution to any particular problem. They are designed to scale almost optimally to very large inputs. They save you a lot of time, they are pretty fast, and if the input of your program changes suddenly by multiple orders of magnitude everything will still be fine if you use the STL. In the 1% of your code that is actually a hotspot you can roll in your own algorithm and data-structures. Thinking about the STL as "something that can be beaten" misses the point. It's not about beating anything, but about making your programs robust against sudden changes in the order of magnitude of their inputs.
By the way, have you considered reaching out to the JetBrains people? The ones that develop CLion specifically. I could imaging that they would be willing to put a little bit of manpower behind it. At the moment CLion does a refresh of the project if anything in CMakeLists changes, so quite stupid actually (or "the best that can be done today"). I think they would benefit immensely from the daemon! They invest quite heavily in CMake and their whole IDE revolves around it. I'd try contacting [Dmitri](https://twitter.com/dnesteruk). Or maybe even try Microsoft too. They're very interested in CMake in VS lately.
I will go slightly further and argue that 'programmer performance' is not indistinguishable from CPU performance. Why do I say that? Because programmer time is a limited resource and time saved using the STL, even if it's not the theoretical best performance, gives back time to find those hot spots and optimize them. 
TL;DR: That's what anonymous namespaces are for. "Keep everything inside the class" is literally the opposite of what I would endorse as good C++. Classes should maintain the invariants of their data members. That's it. Even operators should be free functions when possible. If you're in a source file, put your implementation details inside of an anonymous namespace. If you're in a header file and you can't refactor it easily, make a 'detail' namespace. Boost literally uses the namespace `boost::detail`.
This doesn't work when you have a `Expr*` representing a tree constructed at runtime. Templates are great for compile-time, static polymoprhism; they're utterly useless for the issue described in the article.
Are you sure you didn't want Boost.Variant? Or if that doesn't work, some sort of mixture, where subclasses are preserved but not arbitrary types. One example I can think of is `struct sockaddr/sockaddr_storage`, which has something like 60 "subclasses" that I've seen, and can add more at any time. Code review: * You don't seem to be checking size validity in `copy_from_another` etc. * Your move constructor/assignment actually performs a copy. * You don't ensure alignment. * You aren't exception-safe at all. Since you allow a NULL state, it's a SMOC, but it may be worth forbidding non-`noexcept` moves anyway. * For GCC &lt; 5, there is `std::has_trivial_copy_constructor` 
 The article was intended to show a "from scratch" evolution of a string splitting algorithm in an STL style -- from conception as a plain English description of what we'd like to do, to a final generic function that can be applied to any C++ input sequence -- and a demonstration that this approach can lead to code that is just as fast (or in my case actually faster) than specialised code written just for this one problem. I'm curious as to what problems you feel I "invented" for the article? If you feel that the [`strtok` code](https://gist.github.com/tcbrindle/56276f1a727e97c93203#file-tokenizer_comparison-cpp-L70) is more readable than the [version using the generic splitter](https://gist.github.com/tcbrindle/56276f1a727e97c93203#file-tokenizer_comparison-cpp-L158) then I doubt I'm going to able to change your mind, but I respectfully disagree. 
Did you have a look at: https://github.com/eggs-cpp/variant K-ballo has a blog series about his reasoning behind his variant here: http://talesofcpp.fusionfenix.com/post-17/eggs.variant---part-i It would be nice to add it to the benchmark. The system-wide dependency on gtest is not recommended btw as far as I know. PAPI repository is for whatever reason inaccessible so reproducing your results on different machines is currently not possible. 
I don't want to be mean or anything but just sifting quickly through the code, I think it's fairly low quality. It's mostly C-with-classes with a couple of C++ thrown in. The error handling is a catastrophe: std::cout &lt;&lt; ...; throw 1; The RNG is your typical beginner mistake: (float)rand() / (float)RAND_MAX Plenty of things that should be one-liners with the proper use of `&lt;algorithm&gt;`, passing vectors by value, and so on... Overall perhaps a nice pet project to play with but definitely not I'd personally risk using, as it seems to be written by people with very little C++ experience.
&gt; Why do you say that about GCC &lt; 5, I dont get it ? Before libstdc++ got the real `std::is_trivially_copyable` it had `std::has_trivial_copy_constructor`. If you're using an old version of the toolset you may need to use the latter.
I will gladly help getting the patch into shape for the initial merge. But with the reaction from Kitware to that patch so far I am very much afraid that it will just sit there and rot away once it is merged. Fixing daemon-mode as cmake developes is not what I want to do for the next years. For the same reason I do not care to write my own custom generator for cmake/Qt Creator.
&gt; So here you are — it is in nanoseconds, the lower the better: what were the build options ?
&gt; Yes, I am sure I didnt want to use Boost.Variant in the case I had ! What was this case ? 
Would something like `__builtin_unreachable()` work?
So, in c++, if I have a hash map of methods instead of vtables, do I still have the expression problem? I don't, because the map can be modified at runtime. So the expression problem is nothing more than a problem arising from the hardcodedness of values. Not really a problem...
There is no known lockfree implementation. Two attempts to develop a conforming lockfree implementation have been unsuccessful. A number of members of the standards committee (myself included) doubt that a portable lockfree implementation can be developed. I believe an implementation on x86 may be possible. I've yet to try myself.
Given your interest here, you may also be interested in how to implement [sort algorithms with modern C++](http://stackoverflow.com/questions/24650626). This also nicely shows the power of the STL :-)
By the way, why do you define non-const-ref constructuctors? Shouldn't const-ref + rvalue-ref be enough?
That it doesn't need QT?
It is wrong to say it is an *issue* ; it simply leaves to the user the alignment - and its easy with alignas. Why should static_any always align your data ? Does std::vector align your data ? 
Wow good timing, I was just about to build versions of 1.60 for our servers. Glad I saw this. Boost.DLL looks like it could be great. There's no native way to do cross platform plugins right now (without 3rd party libraries), so it's great to have this personally available to use without having to drag in another dependency. EDIT: It looks like boost::optional&lt; boost::optional&lt;T&gt; &amp; &gt; is broken with their new specialization for optional references. EDIT 2: [Here's an extremely lightly tested fix if anyone else's optionals are broken](https://github.com/boostorg/optional/pull/18)
In this case it is not enough due to the ctor static_any(T&amp;&amp;). I need an overloading otherwise this templated ctor eats everything. At the beginning I did some SFINAE like enable_if&lt;!std::same&lt;any, T&gt;&gt; but when I added the support of constructing from any&lt;M&gt; with N != M, SFINAE was not enough (or maybe it is, but overloading is way easier to achieve that :))
I was expecting this... :] 
anyone have any experience working with compute?
Does this not work? #ifdef NDEBUG #define DFALLTHROUGH [[fallthrough]] #else #define DFALLTHROUGH #endif switch(...) { default: DFALLTHROUGH assert(false); ... }
Then documentation must warn the user that they must use alignas specifier, otherwise it can be UB to put, for example, a double into your `any`. 
1. This was not required in previous versions of Qt Creator. Existing projects which used the standalone Ninja generator behaved oddly when I opened them in Qt Creator 4. 2. I was not presented with a warning nor did I see any obvious documentation that a change in generator to one using CodeBlocks is needed. 3. Why is this change required? I thought Qt Creator parsed the CMake files directly.
Interesting. I'm glad there is less magic and this behavior has been made more clear. I now see the warning icon you're talking about. It would be more obvious if it appeared next to the CMake Generator dropdown as I didn't notice it at first. Thanks for the info!
libpapi is packaged in the majority of Linux distributions ; what are you using ? But I do agree that the dependency sucks just to measure time here. I will fix that somehow.
I can get you a guy who has ~5 years of experience with it.
You don't tend to do those sorts of things with an IDE either. I don't think anyone is pushing for the idea that this library would have 100% CMake coverage or that you'd want a more complex, custom setup to be dropped into the library and be understood 100%. Most people are going to use it to create tools that can manipulate the project in specific ways, and that IS something the library could enable just fine.
Why not just throw std::logic_error("Unreachable code"); That way there's no fallthrough.
I second that. I wish (L)GPL code (with or without exceptions) stayed in the world of C developers which it was originally designed for. I have yet to find a LGPL library that has no alternative with a (really) free software license or that is not easy to write yourself.
While I agree with everything you said I still agree with everything I said: the STL is pretty fast and it scales. 99% of your code is not a hot spot, and there it saves you a lot of time. Yeah red-black trees are horrible, but a lot of times it just doesn't matter. &gt; The unordered_map is completely mediocre and could be beaten by an average grad student from any major university. The data-structures that come with the standard library chose some tradeoffs 25 years ago that make them very usable but far from optimal. There are others with STL interface (Boost, TBB, Folly, Google...). &gt; The mechanism for adding new hashable types is terrible. There was progress to improve this (Howard Hinnant's "Types don't know hash" for example), but is not there yet. &gt; Finally, there is the whole iterator abstraction, which is just a mistake. The entrenched notion that everything is a 1D problem, and all of the staged generalizations from forward only to random access is silly. There is also past work to improve this (hierarchical iterators) and a lot of interest to allow this for ranges (there might be some work to advance this this summer). It took me 15 min to build a range for indexing n-rank tensors (which are inherently multi-dimensional) using range-v3 building blocks (so it can be done). ASL's forest and Boost.Graph demonstrate ways of doing this for other multi-dimensional data-structures, but still the main motivation is just fast iteration over a `std::deque` which is an inherently multi-dimensional container. So I agree with you. The STL could be better, and there are a lot of ideas and ways to make it better both inside and outside the standardization process. However nobody gets paid to fix this. The fixes have to not make thing worse, they have to be backwards compatible, make _a lot_ of nitpicky people happy, go through the standardization process... While there are a lot of non-standardized alternatives to the stl containers, almost nobody is willing to put in their unpaid free time to fix these things for everybody. If you are really that sure about how to make these things better you should write an ISO paper.
Nice! Seeing Boost Compute is a very nice step forward. The Boost community reminds me that Apples Swift could use a similar community. In fact many fringe languages could use such a process and a way to evaluate ideas. Thanks to everyone involved in Boost!!!
Good article, but it does not discuss a very important component of the problem - in fact probably what makes the problem so hard and compelling - static type safety.
&gt;The unordered_map is completely mediocre and could be beaten by an average grad student from any major university. I think it's shameful that we had to wait until 2011 to even get a slightly usable O(1) hash table, and the red-black-tree map should be forgotten altogether. map is *ordered*. (And so is set). Defining ordering is easier than defining a hash. Why do you say that unordered map/set are slightly usable? My point: your writing reeks of misguided elitism.
Do you mean get an error at compile time when either a free function or a member function that implements an operation is missing? My understanding is that as long as you always work with `Expr`s you'll get an error whenever you try to use something that does not fulfill the requirements of the any(meaning something that is missing one of the operations). 
&gt; map is ordered. (And so is set). Defining ordering is easier than defining a hash. You don't know what you're talking about. &gt; Why do you say that unordered map/set are slightly usable? Because paying for a cache miss log(N) times is worse than paying for a cache miss 1 time. &gt; My point: your writing reeks of misguided elitism. Am I supposed to apologize for being more educated than you? 
With the second question I assume you are referring to `using namespace std;` and similar, and you might already have guessed it from /u/Netzapper's answer, but it is because classes aren't namespaces. If you do: namespace mystuff { //stuff here } Then `using namespace mystuff;` works as expected. It is also not always bad practice. If you are writing a program where you use a lot of things from a particular namespace and you feel it makes reading the code easier then free to use `using`. The problem with `using` is when it is used in header files, because it will also take place in every file that `#include`s that header file which can cause all sorts of ugly messes. You can also use `using` inside individual functions in which case it will only work for that particular function and that is fine to do in a header.
&gt; they probably did make a lot more sense back in the 90s when CPUs had fewer levels of cache and so forth. Even in the 90s, we knew about hash tables and when they were better than trees. This is 60s and 70s level computer science, and people were already paying to cache misses in the 80s. &gt; The STL made having standardized containers popular. Before the STL, no language had standardized containers. Yes,you had classes in college that taught data structures and algorithms, but you had to code that stuff up yourself. This is revisionist history (or just ignorance). Plenty of languages had collections before C++. For instance SNOBOL had Lists and Tables in the 60s. I'm sure we could find earlier examples, probably including Lisp in the 50s. &gt; What are your complaints about unordered_map? That is a hash table based map and was introduced to the standard in C++11. Not all hash tables are created equal. 
&gt; Whoa!!! What's your beef dude? Sorry Brah, didn't mean to harsh your buzz. &gt; There's a reason the GoF taught iterator as a pattern and why Stepanov included it as part of the STL. Because they didn't know any better and he was trying out a theory? Whatever. You like the STL, and don't ever let anyone tell you it isn't perfect! 
&gt; I've been cringing everytime I happened to see another commit that added "MSVC compatibility" to clang, meaning it'd understand the command line flags or behave just as quirky. I'd really wish for a gcc compatible clang on windows, Clang intends to provide both; if you use clang-cl.exe you get MSVC flags and if you use clang.exe you get gcc style flags. The default target also differs, but you can manually say whether you're targeting MSVC or mingw with either. As for libc++ support, I just don't think this is that important for two reasons: Microsoft's standard library hasn't been lagging behind the standards the way their compiler has, so you just don't need a replacement for the libraries like you need for the compiler. Secondly, you must use the platforms' library implementation for ABI compatibility anyway. 
I don't think your comments support the assertion that clang is hardly cross platform. libc++ isn't clang, and wouldn't provide ABI compatibility. Using the platform headers doesn't mean clang isn't cross platform; IMO it actually weighs in favor of clang's cross platform support. You also don't actually need Visual Studio. You can simply use the Windows SDK to get the platform headers and such. I assume your description of setting it up as a nightmare applies to setting it up with mingw. I haven't done that so I can't say whether that's true or not, but my experiences setting clang up on Windows certainly have not been nightmares.
Yes, I got bit by this a few weeks ago. I can tell you from experience that it's easy to miss the `::type` even when comparing your code directly with cppreference.com.
&gt; The Boost community reminds me that Apples Swift could use a similar community. Ironic since the technical lead for the Swift standard libraries is none other than David Abrahams, a principal cofounder of Boost.
Alright, so the core of clang is cross-platform, but the whole combined package is what I am interested in. They're definitely making a lot of progress - things have been better every time I have tried - but as of right now it's still more work than it is worth for me. Clang and the other LLVM projects are great, just not for Windows users (yet).
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Disclosure: I'm the poster above... Look, I made some reasonable arguments about why the STL doesn't deserve all the love it's getting in this thread. Joe Shmoe's best response is "Whoa!!! What's your beef?" and various appeals to authority.... Below, you wrote: &gt; Is that a pissing contest you really want to start? There's always someone more "educated" out there, and chances are good they aren't pricks about it. I'm sorry you couldn't follow the train of thought, but the guy called me a "misguided elitist". He's the one who jumped to personal insults... How come you don't call him out for being an asshole? Why aren't you protecting me from him? It doesn't matter. I'm happy to be the asshole, or the prick, or whatever else you want to call me. Just be sure not to make a logical reply to what I originally said...
I would offer assistance but with out any example of the basic code or snippet even would be a guess Could it be your not actually making any std::cout calls ie not writing anything to console
&gt; Nobody gives a shit if you're right if you're also being an asshole for no apparent reason. Actually, some people are pretty good at separating the technical content from the (perceived) tone... You and the people who gave me lame replies and insults just aren't in that group. 
No. The author of that paper gave a talk with the same title at C++Now a few hours ago. Sadly I missed it as I had to leave early :(
I've removed your post as beginner questions are off-topic for this subreddit. Try StackOverflow or /r/cpp_questions as the sidebar advises. For the ultimate in simplicity, you can try my [MinGW distro](http://nuwen.net/mingw.html). If that doesn't work (and you're running x64 Windows, Win7 or newer), something is seriously screwed up with your system (possibly antivirus?).
http://pastebin.com/tM4WFA6D That is all I'm trying to run. 
Be careful about switching code from one compiler to another as some use header files specifically for that system example visual studio adds a header file that will generate errors on any other compiler
3 configurations...two for developers with the old and new gcc abi, and then a special one for our distributions against an old version of glibc. I dunno how long they take, I just kick them off do something else.
try chrome app 'draw.io'
&gt; OK, I'm confused. What are your complaints about unordered_map? That is a hash table based map and was introduced to the standard in C++11. Assuming /u/dryandwet is coming at this from a performance standpoint, the standard specs out the `std::unordered_map` APIs such that it **must** be implemented in a certain often-suboptimal way (read: it basically mandates that you use buckets instead of probing; the latter is preferable in many cases because it requires fewer mallocs and is more cache-friendly). IIRC, the same restriction applies to `std::unordered_set`, as well. Because of this, many performance-minded C++ programmers are unhappy with `std::unordered_map`, and end up rolling their own. (To be clear, I'm not taking sides/etc. here; I'm just trying to elaborate a bit on why `std::unordered_*` isn't universally loved)
You still need to pass the files to standardese. It doesn't (cannot) get them from the compile commands.
Yes - JF both wrote the paper and gave the presentation.
It was glorious. He packed 8 hours of words into 90 minutes.
Yes I do pass my own files to standardese, I will look into what's going on though. I am getting assertion failures as well
No updates to Asio EDIT: It gives me the feeling that the author is busy trying to integrate it in the ISO C++ and got little time to work on Boost.Asio itself.
Thats most likely it. I guess (hope) it has to do with macros inside your function signatures. Currently fixing that issue.
He also participates in pretty heated coroutines debate. 
Possibly... However when someone contributes their time for free they are free to contribute as they wish.
Practically speaking, if I'm supplying a DLL to a variety of clients, I can't dictate when they update their toolchain. If this is a scenario that I support, then I need to be very careful about how I design my interface to prevent any potential ABI/memory issues. There are plenty of resources online that discuss designing safe, binary-compatible DLL interfaces and avoiding the pitfalls of using standard containers.
**Company:** King's College London, [Department of Imaging Sciences and Biomedical Engineering](http://www.kcl.ac.uk/lsm/research/divisions/imaging/index.aspx) **Type:** Contract until November 2017 **Description:** We are looking for a mid-level software developer to continue work on our [CRIMSON medical image segmentation and blood flow modelling package](http://www.crimson.software/), alongside a team of academic researchers, within a university research group. CRIMSON is currently developed under a European Research Council-funded project at St Thomas' Hospital in London and at the University of Michigan (USA) by professor C.A. Figueroa. CRIMSON aims to become the premier platform for medical image-based cardiovascular simulation. Integrating all aspects of the simulation process (medical image data visualisation, segmentation and simulation), CRIMSON is both feature-rich and intuitive to use. The successful applicant will work in the unique and stimulating environment of the Division of Imaging Sciences and Biomedical Engineering, located at St Thomas' hospital in London. Located directly across Big Ben, the division has raised to the very top of the Biomedical Engineering Research in the UK and Europe. A unique combination of imaging scientists, clinicians and engineers makes for a eminently translational environment in which opportunities for industry collaboration and spin-off are numerous. The ideal applicant will have several years experience of large software projects in C++, and be proficient with Qt and Python. A University degree in Computer Science or a related field is essential. Knowledge of medical image processing would be a plus, and the level of your involvement in research (as opposed to development) is negotiable. **Location:** Central London, UK **Remote:** We can be flexible, but you must be able to travel to the office as needed. **Visa Sponsorship:** EU only **Technologies:** C++14, primarily Windows but also Linux builds; Mac a plus. The key technologies include Qt, Python, [MITK](http://mitk.org/wiki/MITK), [ITK](https://itk.org/), [VTK](http://www.vtk.org/), CMake &amp; Visual Studio, Boost. **Contact:** Please email Prof. Alberto Figueroa for further information: alberto.figueroa@kcl.ac.uk
I'll have to cram 9 hours of words into 60 minutes for CppCon. CHALLENGE ACCEPTED!
By the standards of TMP libraries it's quite fast, as it does optimize for build speed and has some fairly novel things for that (e.g. it uses lambdas in some places specifically to get shorter symbol names, which ends up being a significant optimization). A fast TMP library is still pretty slow by most other standards, of course.
Beginner questions are off-topic for this subreddit, please read the sidebar.
&gt;If I know overflow won't occur and care about the optimization benefits, I'll use a signed type. What performance benefits does a signed type bring?
The ones the article is about. ;-] Signed overflow is UB so the compiler can/will optimize out any codepath for handling said overflow.
Yeah, but when somebody's trying to learn C++, throwing Makefile syntax at them is not helpful. One thing at a time.
I see, so the compiler inserts behavior to handle the overflow of unsigned integers automatically, is that correct?
To Piggy back on this though, that is not something I would consider a term project. For one of my university classes (our intro to robotics) writing a particle filter was a project that lasted 3 weeks, and that was full slam implementation, not just a particle filter.
Doesn't mention return types. Wasn't the return type deduction extremely limited in C++11 and generalized in C++14? Also I didn't see mention of parameters being optional or mutable (const by default).
&gt; Wasn't the return type deduction extremely limited in C++11 and generalized in C++14? Yup, but that was because function return-type deduction was limited in C++11, and opened up in C++14.
Probably should also have mentioned `mutable`.
14 also added default parameters.
&gt; The following is the smallest lambda expression with its three parts: `[](){}` Actually, empty parameter lists can be omitted, so this can be shortened further to `[]{}`. I've always wondered why that is. It doesn't really save all that much typing or reduce boilerplate to be worth a special rule, in my view. (In fact, I can't quite remember the last time I used a parameter-less lambda at all in production code.)
this is from an older code base so please be careful of the raw `new` and `delete`. Request* requestObject = new Request(); doSomethingWithRequest(*requestObject); and the function is defined as void doSomethingWithRequest(Request&amp; req); even in some loops for(auto iter = requests.begin(); iter != requests.end(); ++iter) { Request&amp; req = **iter; // requests is a vector of pointers // other code using req like a normal object } This might be dangerous if the pointer points to a `nullptr` but generally make ownership management pretty simple, now i know that whenever i get an object as a pointer it's the callee's responsibility to free it otherwise it's owned by some other object. *bonus question*: how useful could it possibly be with a `shared_ptr` or `unique_ptr`?
&gt; Actually, empty parameter lists can be omitted, so this can be shortened further to `[]{}`. To be fair, it did say the smallest _with its three parts_.
&gt;But, you say, surely volatile always means volatile, there’s nothing wrong with my benign races, nothing could even go wrong with non-temporal accesses, and who needs 6 memory orderings anyways‽ Not too often that you see an interrobang in the wild.
I use this pattern [too](https://github.com/mhogomchungu/cryfs-gui/blob/cc8f8b990edef72c88210a4f2ff833c65864af84/src/favorites.h#L40) when i create objects that manage themselves. Another place where i use this pattern is [here](https://github.com/mhogomchungu/zuluCrypt/blob/f25d4e5e4fc2fe0619e4a5dcb01d4294d13e37bd/zuluMount-gui/zulumount.cpp#L541)
Since you want a "pattern", I'll call it *micro-crash*. For example, I have a stateful object that processes some events. When it encounters an unrecoverable error, it throws an exception caught by its owner's event loop. The owner deletes the object and creates a new one doing the same job. Much simpler than trying to restore the (very possibly corrupt) state to something meaningful. 
Bad examples, in this particular case mistake #0 is using a pointer to save a handful of bytes (the size of the std::string class wrapper and the Aircraft class 'this'), but increasing the complexity of your program massively.
You are right the parenthesis can be omitted, but as I said that's the minimum with the three parts of the lambda expression. It was just to show the parts of the lambda
The favorites object creates a GUI element a user has to close to continue using the application and the object deletes [itself](https://github.com/mhogomchungu/cryfs-gui/blob/cc8f8b990edef72c88210a4f2ff833c65864af84/src/favorites.cpp#L133) when a user closes the GUI element.
I've been using QtC for many years now. Unfortunately, ever since I switched all my code to C++14, the experience has been very poor. It's still excellent for C++98 though.
In C++11/14, you need custom deleter. Support of array in shared_ptr was added in TS Array. Cf http://stackoverflow.com/questions/13061979/shared-ptr-to-an-array-should-it-be-used for example
The "fix" for Mistake 5 actually enacts Mistake 4 
how about: m_languageAction = m-&gt;addAction(tr("Select Language")); ?
The fix for Mistake 10 is wrong. Another thread could release the last reference in between the `expired` and the `lock` check. Instead you should `lock` first and then check the result locked is not null before dereferencing. We could call this Mistake 11: Race condition
It's out-of-range conversion to signed type which is implementation-defined
&gt;non-portable. Compiling your code for x86 will suddenly make it slower. Comparing apples and oranges here. And "non-portable" means it breaks when ported, not runs imperceptibly slower. 
I heard there's something in developmend called "x32 ABI", which will use 32-bit pointers on x86_64 hardware
that will [work](https://github.com/mhogomchungu/cryfs-gui/commit/38b61f4691e6f763dc4b10b76a68e71ebb6eccb1)
That does not change anything ; nor the design, implementation or code of Boost.Any changed for years. But if you have any doubts, feel free to benchmark the last version... 
There is a dot. Indicating the end of the sentence. I never said running slower means non-portable. I just said always using fixed-width integers in non-portable. 
Out of curiosity, which hardware benefits from using float4? AFAIK at least none of the modern desktop GPUs are vectored.
Did you write it completely from scratch without any knowledge of C++? Writing an actual library level C++ project like this that is extensible and usable in multiple situations would be a good term project for someone without any C++ experience. 
For translations and localized text formatting: http://www.boost.org/doc/libs/1_60_0/libs/locale/doc/html/messages_formatting.html http://www.boost.org/doc/libs/1_60_0/libs/locale/doc/html/localized_text_formatting.html
Sometimes, you need an id number for something. And sometimes, you need multiple different id number spaces for different types of things. One function may need to use both. Using integers everywhere can easily lead to confusion and bugs. void doSomething(int fooID, int barID); doSomething(barID, fooID); //runtime error! doSomething(fooID, 0); //seems suspicious Making a fully abstracted type is a pain though. So I tend to do the "easy" 90% benefit for 10% effort approach... struct FooID { FooID() : val(0) {} int val; } struct BarID { BarID() : val(0) {} int val; } doSomething(FooID foo, BarID bar); doSomething(barID, fooID); // compiler error doSomething(fooID, 0); // compiler error Yes, this could be templated on some tag type for more code reuse. It could have a bunch of different operations, like op&lt; on it. The 'val' member could be hidden to make things more difficult for the Machiavellian programmers out there. But these simple ID structures can be typed out really quick, and there aren't a bunch of different gotchas hiding in them, and they aren't difficult to understand. They do add a lot of type safety though.
Ah, that makes sense. Thanks for explaining.
Required for what?
It is required.
For places like this, I'd suggest putting approx. salary ranges. For people from North America or western Europe to have more clear picture.
&gt; Generally input validation is done at the stage where the input enters I'd like to add that in a client/server architecture, it's important to validate input at the server as well, especially if the server is visible to the general public.
[relevant link imo](https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/) In fact, pretty much anything coming from Herb Sutter or written by Scott Meyers.
I attended this talk and kept waiting for the hammer/point to drop. It never really did. I usually like Sean Parent's material, but this just seemed like some unintelligible notes for an in development book chapter. There just wasn't a clear message or direction. Edit: BTW, clicking the link takes you to a different video than the embedded video. I'm talking about the 2015 embedded video.
I was trying to post the talk on how to eliminate raw loops with &lt;algorithm&gt;. Too bad.
Or use reverse-iterators through the map (e.g. rbegin(), rend())
&gt;I just said always using fixed-width integers in non-portable. You seemed to be claiming that the reason using fixed-width integers is non-portable is that your program runs slower. If that is not what you are claiming, then why do you think using fixed-width integers is non-portable? 
I concur, and I agree with your desire to promote this. I got the idea within the first 15 minutes and was happy. Then my son woke up from his nap, so I paused. Perhaps this is why I am not upset: I will finish later. "Read the fine API" (STL 11/+, in this case) is hard news for some programmers with lots of experience. "I've been writing embedded C++ since you were playing pogs" can also mean "I have never had a spare day to learn how everyone else made a better mouse trap." Every one of us has probably wasted a week on code that already existed. So, what lesson can we hand each other from this? 1) Take some time to read STL each day or week; 2) Build exercises from what you read, based on code you already have; 3) Do comparative builds to compare performance (time, stack size, etc).
I am sorry if I dont grace your presence with a youtube video. I dont mind the downvotes, I think he made some really weak points. I agree strongly with his points about free software. Why don't you ask the mods why I subscribe?
&gt; What this is telling us is that a sequence of statements separated by commas is evaluated left-to-right, and furthermore, the results of the first statement are fully evaluated before the next statement is executed. It's worth mentioning that this does not apply to overloaded comma operators, only the built-in one.
Well then.
How many architectures can you name where `int32_t` will not be supported? I'm happy to say "portable" to describe code that uses `int32_t`. "Portable" means "can be ported". If a platform comes up that doesn't have this type then the compiler will give an error and the porter can do the porting. This is better than silent undefined behaviour. 
Correct. If that's a concern you can work around it (as I learned at C++Now this week) with something like (unknownop(), void(), nextop())
This is actually what they do in the MSVC C++ standard library - STL went through and fixed all uses of the comma operator such that no user-defined versions could ever be used.
I added a test that audits all STL algorithms with all permutations of iterator strengths. Recently, running libc++'s tests against our STL found a few more offenders hiding in locales, and I checked in a fix for Update 3. The expressions that we use are `++it1, (void) ++it2` and `++it1, (void) ++it2, ++it3` which defends both commas (we never have four expressions). We say `(void) ++it1, ++it2` only when we need the RHS result.
HFTPro definitely does know what he's talking about. He's a guru in the C++ algorithmic trading world, having single-handedly developed one of the best if not best sell side trading platforms to date - that has billions of dollars churning through it every second of every trading day. So he's pretty cool in that respect - Go HFTPro! 
&gt; Assuming /u/dryandwet is coming at this from a performance standpoint, the standard specs out the std::unordered_map APIs such that it must be implemented in a certain often-suboptimal way OK. Yeah, I've heard this before. That makes sense.
[removed]
The clang-based code model should be a improvement there. But admittedly that is not where the old code model used to be yet. We are working on that.
His rant is less cool though, at least what he posts in this reddit thread here. 
[removed]
Yeah, I'm happy with how much I got to do. I don't know what other methods beside starting in an IDE others professors use, but I honestly really happy with how much I learned throughout that course :). So, sense my program does not need CodeBlock to run, how would I go about running it outside of codeblocks? I use a lot of the built in libraries and I am curious as to where those are stored? Does each program on my computer contain the contents of those libraries within its program files? I am definitely interested if you wouldn't mind looking for me! I'm sure it's a step up and it's a step I am glad to take. 
 If you forceinline it, it disappears(must turn exceptions off, they break forceinline). But yes for high performance, the compiler isn't so smart with piles of nested templates, and uses some heuristics to guess what you are trying to do.. and fails often enough(often). PGO seems to fix it, but who has time to keep running PGO? I agree that the committee isn't serious about high performance, too busy waxing on about exceptions, and adding mostly useless features like fold expressions instead of common sense shit. C++ as a language is really quite bad, Rust shows how to do it better, only tooling and momentum is keeping C++ going now. 
 Ya Rust doesn't have that yet, nor values in generics, which kinda sucks. Pretty sure they are planning to add support in the future though, and since they don't have a committee, I'm hopeful that it will be a reasonable amount of time :)
&gt; https://brightwhiz.com/wp-content/uploads/2015/09/moderncpp.jpg lol
[removed]
[removed]
[removed]
 Intrinsics aren't part of C++, just happen to be supported by some compilers. Inline assembly is also not part of the language, and MSVC disables it in 64 bit builds. C++ could have language level support for SIMD data types, but it doesn't. Alternatively C++ could have language level support for guaranteeing auto vectorization, say an attribute [[vectorize]] to specify that this loop *must* be auto vectorized, or fail to compile. I've only tested MSVC's auto vectorizer, but it basically couldn't auto vectorize anything but the most contrived examples. 
Yes, how does this go against my comment or support yours?
.
Never gonna us 2gigs worth of map entries. Its more of a topcoder trick, avoids typing greater&lt;&gt; and so forth 
Sorry for the late response, I was on OSX and it was not available in brew, but I'm using Arch at home, so I'll have a second look later. 
Which bug? The object receives external input, an some sequences of events may cause it to end up in an invalid state. Then the object is destroyed and recreated. 
This comment alone is enough to not take seriously anything you say. No one asked to show code that you worked on or disclose algorithms, you were asked for some examples. When you have a point of view that is questionable is good to provide some proofs, but as it is what you're actually saying is "'Modern C++' is not worth the investment because it performs worse than old C++, check it yourself if you don't believe me".
But you can make test cases to show case the compilation problem as you see it. If you think you have found a problem, which even hinders your work, why not submit it to the committee yourself?
TL;DR I work in a field where I have performance constraints that do not apply to 99% of even C++ programmers. At my work when I suggest, "We may want to use an FPGA for that." no one laughs in my face like would happen to well over 99% of the professional programmers in the world. Therefore, Modern C++ is dying.
So, what exactly was rust lacking for your purposes? 
&gt; All the tools are proprietary and extremely expensive, That's not completely true. Both Xilinx and Altera have free versions of their toolchains. These are limited in several ways (for example in the range of devices you can compile for), but it is definitely enough to start. 
I do a pimpl like that now: function&lt;void(const string&amp;)&gt; create(int ctorParam) { auto impl = make_shared&lt;Impl&gt;(ctorParam); return [impl] (const string&amp;) { // do stuff with impl } } Usage: auto func = create(123); func("abc"); If you return a tuple of lambdas - they are like member functions. Horribly inefficient, but opaque as hell (and eventually, you stop having classes; mostly tuples and functions).
&gt; Modules will hopefully help once they arrive Famous last words.
**Company**: [Grow Software Ltd] (https://www.grow.am) **Type**: Full time **Description**: GROW is an exciting software development company, based in London, working in the field of additive manufacturing. Over the past four years, GROW has been working with some of the leading companies in additive manufacturing to develop a unique technology to enable secure, reliable distributed manufacturing using AM technology. Using GROW software, our clients will be able to protect their IP, ensure output consistency and keep a complete quantity and quality audit trail for all remotely manufactured parts. The benefits of distributed manufacturing in reducing inventories, shipping costs and wastage while improving lead times are such that this is widely considered to herald the biggest shake up in manufacturing for a generation. As Software Engineer, you will be a core member of a small development team making major contributions to our desktop applications. You will be dealing with a core C++/MFC product and utilising WPF in future development work. Our desktop software connects to cloud based APIs and also to third party desktop service APIs of leading 3D Printing Manufacturers, you will integrate our software with additional new desktop APIs. **Location**: UK, London, Paddington **Remote**: No **Visa Sponsorship**: No **Technologies**: C++ 10, .Net 4.0, Visual Studio 2015 **Contact**: Send your CV to Dermot Madden, CTO at dermot@grow.am **NOTE: NO RECRUITERS**
yes, faster compile times are one of the main benefits I saw when I ported a modern c++ application to an Altera FPGA + verilog. /s
If you want to talk about getting closer to the hardware, maybe have a look at Cisco's usNIC and the community libfabric interfaces. You'll need specific hardware support to get any benefit from either of those. Some of Intel's line of server NICs may be included.
I'll have a look, but we use another vendor's for NICs acceleration and they have their own libraries that I plan to use at a second stage. 
Boost Compute no, but it's backed by OpenCL and there's an entire subreddit for that.
Is this for HFT? If yes, the usual solution is to implement feed handlers directly in hardware (FPGA) on markets where it provides an advantage, and for all other socket operations use kernel-bypass libraries provided by your NIC vendor (Mellanox VMA, Solarflare OpenOnload, Intel DPDK). Lowest latency is usually achieved by pegging threads to cores and having them busy spin on synchronous, non-blocking I/O. You'll probably want to use raw sockets as "advanced" optimizations include building partial protocol frames.
The safe bool idiom is a particularly bad thing to list there as it's been obsolete since C++11.
Do you accept pull requests? I'd like to link to my talks using a text file, as my slides have multiple formats and my second talk is code-only.
Because the long type name is hidden behind a non-template struct, thanks to inheritance. Try it out in the [benchmark code](http://melpon.org/wandbox/permlink/aot9ePGgtKtVKVKP), by calling something like: injector.nope(); You will see this result when erasure is enabled: prog.cc:461:12: error: no member named 'nope' in 'i' injector.nope(); ~~~~~~~~ ^ 1 error generated. *(as you can see, the compiler does not show the inherited-from type)* ...and this result when disabled: &gt; prog.cc:461:12: error: no member named 'nope' in 'boost::di::v1_0_1::core::injector&lt;boost::di::v1_0_1::config, boost::di::v1_0_1::core::pool&lt;boost::di::v1_0_1::aux::type_list&lt;&gt; &gt;, boost::di::v1_0_1::core::injector&lt;boost::di::v1_0_1::config, boost::di::v1_0_1::core::pool&lt;boost::di::v1_0_1::aux::type_list&lt;&gt; &gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X0, X0, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X1, X1, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X2, X2, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X3, X3, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X4, X4, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X5, X5, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X6, X6, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X7, X7, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X8, X8, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X9, X9, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X10, X10, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X11, X11, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X12, X12, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X13, X13, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X14, X14, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X15, X15, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X16, X16, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X17, X17, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X18, X18, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X19, X19, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X20, X20, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X21, X21, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X22, X22, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X23, X23, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X24, X24, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X25, X25, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X26, X26, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X27, X27, boost::di::v1_0_1::no_name, void&gt;, boost::di::v1_0_1::core::dependency&lt;boost::di::v1_0_1::scopes::unique, X28, X28, boost::di::v1_0_1::no_name, void&gt;, ... (too long)
Nice article! Although having "fought myself into" the subject prior to this article, there were still some nice things to pick up. If you are interested in variadic compile time stuff you may enjoy taking a look at: https://github.com/Voultapher/Vool/blob/master/Vool.h For example vool::util::all_true should have the same functionality as your and_all, without using constexpr --- Seeing your use of common_type, keep in mind its not allways fitting arithmetic tasks, int16_t and uint32_t will result in uint32_t using common type, witch is unable to hold the full range of int16_t values and may contradict intuition. Further would I recommend using enable_if and SFINAE in such fashion that success instantiates the implementation and failure a set of static_asserts, otherwise you'll quickly run into nasty or completely incomprehensible/ unrelated errors.
Ah, you're correct - I didn't test gcc incorrectly assuming it would have the same output. I'll add a note for the report and ask the author if there's a way lambda typename erasure can work with gcc.
Lot of "old" books are interesting to read, like "Effective"s, or "C++ in Depth" series (red books). The question is rather: what order to read them? It's probably better to start with more recent books, like C++ Primer (Lippmann), C++ STL (Josuttis), C++ Langage (Stroustrup), etc. And Modern Effective C++ for C++11/14 (Meyers) (a must-to-read for me).
It's still useful, even if it is a bit dated. While reading it, keep in mind the changes that C++11 / 14 brought. Particularly move semantics, unique_ptr, unordered_*, and lambdas.
Isn't C++ STL (Josuttis) (1999) older than Effective STL (2001) ?
So would you suggest Modern Effective C++ be read before Effective STL i.e. the former will cover all the newly introduced features?
[removed]
[removed]
You'll probably have to delve into COM – my condolences for choosing that as a first C++ project. ;-]
There is a 2nd edition of the Josuttis book which adds C++11 coverage – highly recommended!
The two books do a good job of complementing each other. They don't cover the same material. For example, Effective STL spends a lot of time helping you figure out which container is the right container for your use case. Effective Modern C++ doesn't spend much (if any) time on that topic. As far as which order to read them in... I don't really have a strong opinion either way. If you really want to learn C++ well, you will likely want to read each at least twice, just with some time / experience in between the readings.
&gt; Alternatively C++ could have language level support for guaranteeing auto vectorization Check OpenMP4 #pragma omp simd 
&gt; process Mediawiki markup offline Did you see mwparserfromhell?
I've got the four Meyers. It should be mandatory in all the shelves of C++ beginners. Although a bit outdated on some topics (already said here) Effective STL is still relevant and a good purchase. 
"Expecting it" is not an excuse for "did nothing about it".
Your best bet is to use some existing framework for Windows services, rather then implementing it with Win32 API. For instance: http://www.codeproject.com/Articles/781449/A-Simple-Cplusplus-Class-Framework-for-Services 
[removed]
perhaps you didn't notice the /s. I didn't dislike the article, mostly, thought it raised quite a few good points though I disagree with many of them, but hey I don't work in HFT! That said, what I found slightly weird was to suggest that longer compile times is a big problem with modern c++ then suggest that switching to HDLs was the way forward.
[removed]
`if constexpr` FUCK YEAH! `operator.()` I'm extremely skeptical as to what ambiguities this introduces. UFCS: Wouldn't it be great if we could also have the reverse, that `a.f()` would be interpreted as `f(a)`, so we could define extension methods that can be called like member functions (and thus can be chained)?
It sounds like you are under the impression that COM is difficult, yet fun. I can assure you there is no fun to be had.
That's the spirit.
An alternative option to /u/nemtrif is mix your work with C# (C++/CLI). These days Microsoft focus more heavily on .NET and C# as the core tools to work with Windows. Making a Windows Service is crazy easy in C#, so you could create a C# Windows Service and it's back-end would be your C++ code.
Most development companies do not use C++ as their day-to-day language. The strength of C++ is the low level that you are able to achieve. This leads to high performance, slow-to-develop code. If you want to use C++ in your job, look into financial companies, video game companies, and any large-cap tech companies (fb, google, msft). Good luck 
&gt; Can a person like me (described below) land a job in software development using C++ and ideally getting trained at the expense of an employer? Getting paid to learn C++...?
Thanks for your response :-)
I take that as a "no" then :-)
Yeah thanks! These are the ones that tend to use C++, hence my interest in this language.
I'm honestly just trying to make a .exe file that will just pull the raw data on the system usage and logs and dump them in a MySQL server. I have everything there configured with python and MySQL. I figured it'd just be easier to have a single .exe file that I could then just jump on each system click the file and install the service.
Hmm possibly, this is the only part of my work that I'm doing with C++.
Extension methods are something I (and I believe many others) believe is sorely missing from C++. 
[removed]
Minor version updates consisting mostly of API stabilization. Yeah, _totally_ more work than move semantics, variadic templates, constexpr, the math special functions, `&lt;regex&gt;`/`&lt;random&gt;` etc. /s
Rundeck kind of may be what you are looking for. It's a Java program that records the state and return codes for jobs you can schedule to run, and has an acceptable web interface. Definitely works great for monitoring some of my personal batch jobs.
As others said, might not be the most straight forward first project... but if you are up for reading documentation - you can probably do it. Use the Win32 APIs for event logs. MSDN - Consuming Event Logs: https://msdn.microsoft.com/en-us/library/windows/desktop/dd996910%28v=vs.85%29.aspx MSDN - Windows Event Log Function Reference: https://msdn.microsoft.com/en-us/library/windows/desktop/aa385784%28v=vs.85%29.aspx First link will be more of an tutorial-like overview with some code samples. The second link is a straight up reference manual for the event log. Note at the bottom of any of the documented functions, it'll tell you which headers to include (in your cpp file), and which libraries you need to link to (in your Visual Studio solution / makefile...)
It's definitely a good read -- about C++'s pre-11 dark history -- so that you know the committee is not only adding attractive features, but also doing real, tough work.
&gt;For our Linux servers I already have a python script &gt;What would be the systems resources What do you mean? Aren't you supposed to show the same resources that the Linux script gives? &gt;I'd like to have a service that (every 5-30 seconds) out puts the servers resource data to a MySQL server Why a service? You can simply write an executable and make the Windows Task scheduler call it. Now, Task scheduler can only call it at most once per minute, but AFAIK that is just like cron under Unix, so care to explain how do you call your Python script on Linux each 5sec? About your data: do you know about [Windows Performance Counters](https://msdn.microsoft.com/en-us/library/windows/desktop/aa373083)? (They can probably give you more data than you wish for :-)). &gt;What would be the ... event logs. Control Panel -&gt; Administrative Tools -&gt; Event Log? (No performance data there though).
This sounds very interesting! I really, really wished I could have been there!
&gt; After enough time, C++ became from the "fast language" to the "functional language" and performance was put aside. It is currently well known that several systems within C++ are inherently slow like iostreams, strings iostream performance a consequence of modern C++? Next up how modern medicine gave Julius Caesar autism. 
I don't quite understand what they did to UFCS. It seems the opposite of what people wanted?
Now if only my embedded compiler vendor would support CPP11+. I came in probably 6 months too late to put that on the list when evaluating it. Luckily, I just got word last night that they should be adding full CPP14 support later this year.
It lets you create multidimensional arrays and operate with them without needing to write explicit loops and without creating temporaries. You get to use a compact syntax for these operations, similar to APL or Numpy or Octave. Like Blitz++, or Boost.MultiArray, or even &lt;valarray&gt; to some extent, I suppose —there are a number of similar libraries in C++. 
Nice talk - Andrei is one of my favorite presenters. Just wanted to mention that the kind of introspection and compile-time branching mentioned in the talk are possible in C++14, albeit with a less convenient syntax. It is possible to branch on compile-time conditions using `static_if` *([example from my C++Now 2016 talk](https://github.com/SuperV1234/cppnow2016/blob/master/static_control_flow/code/p02.cpp))* and to check for the availability of member functions and fields using facilities similar to [`boost::hana::is_valid`](https://github.com/boostorg/hana/blob/master/example/type/is_valid.cpp). You could also elegantly combine various function that depend on compile-time conditions using constructs such as [`fit::conditional`](http://fit.readthedocs.io/en/latest/conditional/index.html).
no mention of clang-tidy? AFAIK it has some checks (like cpp-guidelines checks) that are not part of static-analyzer. Might be worth checking that out in a future post :)
[removed]
Great point. I think Andrei's comment "You can't write fast, generic code in C++" (see https://twitter.com/incomputable/status/723093723454705664?lang=en) will be proven wrong. So far I have not seen any examples of fast, generic D code that could not be implemented in C++14.
 You blame the mentality behind modern C++ for the issues iostreams has and claim nobody cares enough to fix it. I spend days reducing and replacing calls to iostreams, reusing stream objects, moving around rdbufs myself and simply do not see the connection with modern C++. The streams were always slow and people needing performance always tried to avoid them. From what I have read their design makes them hard to optimize and is considered a lost cause. Among vector&lt;bool&gt; and auto_ptr they are one of the bad design decisions inherited from the early days of c++ and thankfully using them is optional most of the time.
That's fair. The answer to your question is probably nothing. I'm not sure. It would be interesting to check some of the operations. I'll make a note! This library is something of an experiment. It doesn't even have general reductions. The loop unrolling is the simplest it can be. I do have some benchmarks (test/bench*), but they're just to show the overhead of the expression template syntax vs writing loops by hand or using raw pointers. It's meant to be a compact library, taking advantage of C++14, without dependencies, that you can poke at, but that is still quite general —user defined types, arbitrary rank, arbitrary number of arguments, automatic broadcasting. The main reason I started to write it was that I was intrigued by the array semantics of J ([J for C](http://www.jsoftware.com/help/jforc/contents.htm)) and I wanted to see how they could be adapted to C++. 
cppdepend is nice with a pretty GUI
[removed]
[removed]
So which of these CPUs doesn't process instructions linearly? Because multi-core systems still process linearly, albeit on separate cores. Which just means the programmer needs to synchronize. And none of that really has anything to do with "Modern" C++ not being suitable; if anything, "Modern" C++ is *better* suited to parallel tasks.
I'd like for the service to show the same data as the Linux servers but I feel Python is much more of a task to run on multiple windows boxes throughout an office and I'd like to use some of the C++ knowledge that school has been teaching me. For the Python script I have a "while True:" loop thus it's always running, with a "time.sleep(10)" to add a 10 second delay. It stores the computer name, username, IP address, system up-time, CPU usage as a percentage, memory percentage, memory usage, memory total and HDD info. It takes the raw data and stores it across the network in a MySQL db so I can graph it and query it to a webpage for a quick reference when scanning all our servers. I'll be adding more pages to the site for our IDS, firewall and ticketing system. Kind of forgot about cron jobs, creating such a system based application is all relevantly new to me and I'm doing it more to learn to better my development skills, though it will also make my departments job easier. I'm trying to make a service because I was hoping if it runs successfully on servers, I could run it on some of the employees desktops in the background of their systems. The event logs would just be nice so I can see an error occur before an employee walks into my office and says something isn't working. Also Windows Performance Counters looks beautiful. Otherwise would it be easier to pull this all over the network rather than push it to MySQL?
This is awesome, I just want to see errors before any are reported or noticed and sometimes the event logs can tell me which system is or will be acting up.
Should change !(a &lt; b) for (a &gt;= b), not (a &gt; b) 
Maybe I am missing something *(and, if so, I'd like you to elaborate on that)*, but you can definitely branch at compile-time with C++14 and you can definitely check whether a member field/type exists or whether an expression is valid at compile-time. You can also check if an expression would throw an exception at compile-time. Here's an example C++14 implementation of the `find` function from your slides. It probably requires some minor adjustments to compile, but it's extremely close to real C++14 code: template &lt; typename R, typename E, typename = std::enable_if_t &lt; is_input_range&lt;R&gt;{} &amp;&amp; is_same&lt;decltype(declval&lt;R&gt;().front() == e), bool&gt; &gt; &gt; auto find(R r, E e) { static_if(is_random_access_range&lt;R&gt;{} &amp;&amp; has_slicing&lt;R&gt;{}) .then([](auto x_r, auto x_e) { static_if(noexcept(declval&lt;R&gt;()[0] = declval&lt;R&gt;()[0])) .then([](auto y_r, auto y_e) { // sentinel implementation }) .else_([](auto y_r, auto y_e) { // indexed implementation })(x_r, x_e); }) .else_([](auto x_r, auto x_e) { // conservative implementation })(r, e); } Sure, it's not as pretty or as easy to maintain as the D version. But it's not that bad either. It will get better looking and easier to maintain with C++17 features. Also macros and better constructs can definitely help. Unless &gt; you can't write fast generic code in C++ was a joke that whooshed over my head, I still do not believe your claims are true. I recognize the value of the much better metaprogramming facilities in D, but I do not agree with the fact that modern C++ isn't capable of similar results, albeit with worse syntax. 
[removed]
Please add the Remote and Visa Sponsorship fields as requested by the template, even if the answers are No.
Thought the same thing when I saw the re-sharper hint.
You are multiplying in the wrong order. Should look like auto temp1 = info.Projection * info.Clip; GLM is based on glsl specifications. Therefore the matrices are column major and you want to multiply from right to left instead of from left to right.
Thanks very much. I see that now. That explains what I'm doing wrong and how to fix it.
can you use your `static_if` to generate conditional data members in a class template? AFAICS, in C++ you currently have to rely on either explicit template specialization (duplicating large parts of the member functions), or you can use a `std::tuple` with `std::conditional_t` on its elements, and rely on the empty-base-optimization. It's not pretty and doesn't scale either way. `static if` for data members is a MUST for generic programming.
Not sure about D, but Rust has destructive moves while C++ does not. That means a generic sort or shuffle function will never be as fast as possible in C++.
I've used a code project service framework for years on a Windows service project. When time came to redo the project, I used the MSDN sample and modified it: [CppWindowsService] (https://code.msdn.microsoft.com/windowsapps/CppWindowsService-cacf4948) It worked really well and was easy to adapt to my needs...
[removed]
That's a good point. I am not currently aware of a "clean" solution that does not make use of multiple inheritance and specialization. I can think of using `static_if` to produce a compile-time list of types that can be used to generate an `std::tuple`, but that's not very elegant. 
&gt; I don't know any C++ web frameworks (though I am certain they exist) I've had positive experiences with both [Wt](https://www.webtoolkit.eu/wt) and [libRocket](http://librocket.com/).
&gt; at least against Eigen3 and Blaze Most importantly IMO would be [Boost.uBLAS](http://www.boost.org/libs/numeric/ublas/), since it can use various backends with a uniform interface.
Thanks! :D
I'm in the embedded field. I work with FPGAs. FPGAs are a different beast than a modern CPU. They're more analogous to a GPU, and even then they're still different because of how they handle concurrent data access. And is your point then that Modern C++ isn't well-suited to FPGA programming?
Your situation is pretty much textbook simple. The only slightly tricky piece is getting Boost and Eigen to work from there. What pieces are giving you trouble?
[removed]
This reminds me of a rant on this sub a few weeks ago complaining that the C++ Standard committee didn't mandate maximum performance on the latest hardware that had just been released. The guy went on for ages and then deleted the thread. 
&gt;having single-handedly developed one of the best if not best sell side trading platforms to date - that has billions of dollars churning through it every second of every trading day. You know these systems just exist to funnel money away from normal people and into merchant bankers' offshore accounts, right? Accelerating the widening of wealth inequality. History will look back on creators of automated financial trading software the same way we look back on the construction workers at Auschwitz. 
I wonder how much of this is just that the implementor of exceptions made no effort to reduce the code size. Exceptions are basically equivalent to a bunch of setjmp/longjmp calls so in theory there need not be a large size penalty.
Why are you mucking around on Reddit then
[removed]
thats very close what I got going now, though I have the app gui good dirs within a src dir. looks good!
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Euh, no, you're mistaken. The very purpose of task scheduler is unattended execution.
&gt; It has been 10 years that C++ does not provide a single advancement that makes my professional life better, easier or more profitable in any sense. Pretty much everything put into the standards have a reference implementation before they are put in. They are put in because people want it. Are you telling me in your entire time coding things you have never used `std::find`, `std::partition`, `std::sort` or anything inside `&lt;algorithm&gt;`? Never thought that lambdas would make all that code cleaner, maintainable, and save time?
I didn't know that. The last time I tried to find my way in, it felt like I was walking on a rope, and most links lead to pages that say: "Great offer, starting at $35 Gazillion only!" or worse, "Contact us for a quote". Now that you nudged me, I've searched for "free FPGA development tools" and the results seem promising :) thanks.
[std::mem::swap](https://doc.rust-lang.org/std/mem/fn.swap.html) swaps items without any destructive moves.
is this even practical? wouldn't the virtual memory space never let you get near the 4GB mark? i mean, when it is near, it probably be 64bit anyway, and having 4GB allocated on a 32bit system for one process... well you have other problems.
I had a fairly big project which used flat paths, when it bited and we had to change everything to full paths because of too much name collisions, it hurted. Use long paths the soonest pissible.
TL;DR - super practical to exploit Beyond crashing the process, by far the common attack here is failing a malloc. It's very, very common to not check all your allocation return values; if you try to allocate 4gb, then malloc fails without a check, then use my data - there are many cases I'll then get control of execution or a more useful write for an attack. This isn't new (early 2000s), super easy, and is very common (binary exploitation 101 really) Source: I do this for a living. 
An x86 /LARGEADDRESSAWARE process on x64 Windows can get within 64K of the top of address space. 4GB of VA also doesn't get 4GB of commit since a lot of it can get eaten up by fragmentation and shared memory mappings. I've seen this get pretty bad on Windows and really horrendous on OS X with graphics drivers. 
isn't the first `f(x)` `x.f()` in your comment ?
&gt; `class alignas(64)` It's certainly too late but in my opinion it would have made much more sense to handle this with attributes : [[alignas:64]] class foo { ... }; 
Inheriting from `std::tuple` is pretty clever since it allows you to access data members by its index and allows you defining multiple data-members of the same type. Nice. Thanks. 
I think /u/whichton meant that in C++ after moving from an object you still need to leave the object in an unspecified but valid state. There is no need to do so in Rust. So in C++ an algorithm like `erase_remove_if` is going to restore the invariants of moved-from objects to a valid state at every step of the algorithm even though some of these objects are going to be destroyed at the end. There are a lot of types for which this is expensive (say a `list` implementation with a sentinel node that might need to allocate memory on `move`, no, this is not a joke). In Rust there is just no need to restore an object invariants after moving from it since when you move an object you cannot use that variable binding anymore until you reassign something to it, and if you don't assign anything to it, the destructor for that binding won't be called (since the move was already "destructive").
ahh, complete misread on my part. Thanks :-).
There is a drawback in that controlling the alignment is slightly more difficult (`tuple` could reorder internally), and not all stdlib implementations make sure to tag the tuple elements, which sometimes leads to missed EBO opportunities when having multiple same-type tuple elements. 
For Altera, it is [here](http://dl.altera.com/?edition=lite). You have to register, but it is free. 
&gt; It should be mandatory in all the shelves of C++ beginners. Not just beginners. I was programming in C++ for over 10 years before I read the Effective C++ books, and they completely changed my world. Effective STL probably had the most impact because STL is almost a language in itself. 
I recently gave a shot to ReSharper C++ again, but I still find it pretty inaccurate. VA is also not perfect, but has considerably less false positives and cases of simply not finding a symbol. The latter is very frustrating. ReSharper does have a number of compelling features over VA, but until the accuracy is improved, all of that is in vain. 
&gt; I know I need a cmakelist file in each directory No, you don't. In fact, you are better off not placing one in each directory. It gets hairy very soon and your changes will need to be all over the place. The only valid use case I found for that is when I want the subdirectories to be also compilable standalone. This is useful for a library that ships with example projects. The main CMakeLists.txt can reference the examples and build them, but they are also buildable on their own.
Please let us know about any inaccuracies via our [issue tracker](https://youtrack.jetbrains.com/issues?q=project:%20%7BReSharper%20C%2B%2B%7D). Since R++'s static analysis features depend heavily on the accuracy of code understanding, we take these issues very seriously.
Please vote for the associated [feature request](https://youtrack.jetbrains.com/issue/RSCPP-13896) to help us prioritize new features.
Thanks, it's good to know that you are paying attention to these problems; I'd happily report them, but I don't think I can reasonably do without violating my NDA. If I can reproduce a problem with compatible example, I will make sure to do so.
Recently I asked related [question on SO](http://stackoverflow.com/questions/37076184/what-if-object-is-located-at-highest-address-possible) but can't get as good explanation as here.
/u/nj96 if I were to put this together the way it's stated, for my purpose of monitoring would I be putting an endless loop with a 30 second sleep function in the OnStart() function then just pull the information I'm trying to gather and shoot it towards the MySQL server? /u/dodheim not that I'm second guessing anyone but why would you say it's not good C++? Do you recommend any other resource or have a reference? So far I'm still sifting through the ones posted as they all seem useful for different parts of the same project.
Oh, I got it now. I thought that the action was to replace the !(a &lt; b) for an equivalent one without the ! operator, which should be a&gt;=b. Now I understand that 'negate' and 'flip arguments' are two different actions not related.
alignas is, grammatically, an attribute-specifier, along with all [[]]'s
I know it's not perfect but out of all the Windows service templates out I felt that it gets you going the quickest and doesn't require understanding the under-the-hood stuff when it comes to windows services...
I use mongoose to provide a management API in one of my apps. Then a single page app using react.js and bootstrap for UI. 
What happened to using clang by default?
I'm debugging it a little but it does seem to be a solid framework, I just can't seem to get certain parts to work.
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I highly doubt algorithms as generic as the ones in `&lt;algorithm&gt;` would be slower than your hand written ones. Also the "STL" is way more than just containers. Some neat things in `&lt;algorithm&gt;` and `&lt;functional&gt;` are as generic as it gets so they should work with EASTL. It might be true that intrusive containers might work better for your use case, but you can use standard algorithms on them assuming you provide standard compliant iterators. For intrusives, you can use boost for now (or your own). Perhaps they will be added to the standard one day maybe. And finally, `std::function` is NOT the only way to store a lambda. You can implicitly convert a lambda to a function pointer (provided it doesn't have captures). You can also get the type with `decltype`. Usually something like `template &lt;typename F&gt; return_type f(F&amp;&amp; callable)` is fine and it works with all callables. You can also use `auto` to deal with lambdas. Bottom line is that lambdas aren't supposed to have any performance penalties.
I can't help but feel there was an article where the author put a lot of emphasis on designing your libraries to do this. Making your own expression templates presents a wide array of possible bad errors, so Proto fit right in. Edit: IT WAS PROTO! It's no wonder it's a bother to find; it was on cpp-next. https://web.archive.org/web/20140113222954/http://cpp-next.com/archive/2010/09/expressive-c-why-template-errors-suck-and-what-you-can-do-about-it/
[removed]
Still no news on fixing the crazy high memory or CPU usage. Or supporting and build system other than CMake. Still, nice to see the new auto complete.
It's not good C++ because it's C code with the words `class` and `virtual` thrown in, which aren't even in the top 75% of useful C++ features; the code is oriented around C datatypes, including C-strings, and uses C APIs exclusively, even for said C-strings. You'll need to use the same parts of the Windows API as that code does, of course, but aside from those direct interactions I would consider the rest of the code to be counterproductive as a resource for learning C++.
I'd like it if they just used clang for their in-ide parsing because their custom one they've got right now highlights things as errors that aren't actually errors. And it's slow as all hell.
correct. clang is an option.
Add some examples in the readme.
Yeah, the "this is an error because the expression is beyond my ability to parse" is really annoying and can get confusing for beginners. (I currently teach beginner C++ and some people have CLion)
Yeah I agree. Anything templated and mildly complex is annoying. This is only eap 1 and they have flagged the code model as a thing to improve. The huge CPU hit at the beginning is pretty frustrating 
Isn't SIP completely independent of clang?
I agree, but from what they write on their bugtracker, they made a conscious choice and are sticking to it. One of the problems is probably that they want to use their existing toolchains and everything is in Java or another JVM-based language. In my opinion, it's a bad choice too.
Yes - the clang python binding (cindex.py) is used to parse C++ headers. Then SIP files are generated from the parsed classes and methods. In between, some methods are filtered out if they're not bindable to python for example, and some other custom code added. Then the `sip` tool is run on the sip files to create C++ files. Then those C++ files are built with whatever compiler/toolchain you are using.
Missing Microsoft Channel 9 Going Native with lots of relevant stuff https://channel9.msdn.com/Shows/C9-GoingNative
I also have a code-only talk :-(
No one has convinced me yet to use shared_ptr, unique_ptr, auto_ptr, etc. I still just use raw pointers. I like managing my own memory.
[removed]
Thanks a lot for the quick response, got it! Lucas
I'm noticing it as bit screwball-ish with the datatypes, the different C strings aren't mingling well together. I'm not familiar with the use of virtual but class I use pretty frequently in class and kind of enjoy as compared to struct since it gives me a little more control with the usage. I do like the stricture though for this framework though, it's very easy for me to read, if only it wasn't mixing the C API. Maybe I can just use it for a reference and build my own framework in exclusively C++.
I have 9 errors of different variables not able to convert to LPCSTR or LPCSTR, mostly because they are PWSTR.
you'll find /r/programming is full of 20 year old jackasses that know everything.
&gt; You missed the connection - the committee is more worried about the "cool factor" of functional programming - and thus developing Modern C++ - and leaves the very real stumbling stones that assault us, the users, every day untouched. Do you have any actual evidence of that? &gt; nobody really wants to take on this pickle because everyone there is on a circlejerk hype binge. Within the standards committee you're probably right, but in the C++ community as a whole that's not even close to true. There are 3rd party libraries that are designed to be more type safe, more printf-like, and much much faster than iostreams. I think maybe you should differentiate between the standards committee and the C++ community. Or maybe I should say it wasn't clear to me that you were making that differentiation.
[removed]
I think 'avoid topcoder tricks' is a pretty good pattern for actual work. 
&gt; Most of the evidence is in form of reports that my clients paid me to produce. I would have to risk a lot to release them or redo all that work. The guys paid not only for the results but for the code that produce the results as well so what can I do? Well you can't blame people for not reacting well if you're not allowing this to be peer reviewed. I don't really have an opinion one way or the other I just wondered what you based it off of. &gt; community - I just got some nasty attacks on LinkedIn. I remove them all, they are not worth replying to as they are basically flames/rants. I made myself promise never posting here at /r/cpp. It's hard because there's so much vitriol aimed at C++ in general and people get really defensive about it, even irrationally so. I'm one of those poor lost souls that actually loves C++ and thinks PHP is a great language as long as you understand when and where to apply it so I see that vitriol, and it's response, from multiple camps. Don't even get me started on rust's community. I like rust well enough, but I've seen people attack C++ for things that make no sense and I'm fairly certain they didn't know what they were talking about. The same thing happens between RoR and PHP (although not Ruby and PHP, which is weird to me). I guess my point is that people in general are stupid emotional creatures, especially the ones who enjoy the sound of their own voice on social media. When I was talking about the C++ community I meant more about the people in the trenches doing library work, etc. I'm sure they're not all completely rational people, but I get to enjoy their work without witnessing such silliness since I tend to stay away from social media. &gt; I wanted to make a challenge - people would write anything in "Modern C++"and I will deliver the same code running faster with a pre-C++11 syntax. This is to show that nothing pre-including c++11 has contributed a dime for performance. Is that really the claim though? That C++11 and beyond can legitimately produce code that can't be matched by C++98 in terms of performance? I have no doubt there's some 20 year old kid with a hardon for C++ trying to make that argument, but in general amongst more experienced C++ developers? Even Bjarne has talks where he describes move semantics as giving language/compiler support for patterns he's been using for years, just manually. And I know a lot of the discussion around the newer smart pointers/objects has involved talking about when/where/why it's better to use raw pointers (or things like string_view) because there's definitely a performance hit for passing smart pointers everywhere.
I have the feeling that /r/cpp is actually enough to be up to date. I have learned much in the short time following the posts here. Btw. another conference that also has some c++ talks is NDC.
Maybe you should try [juci++](https://github.com/cppit/jucipp), its a clang-based IDE for C++.
Research narrow strings vs. wide strings in the context of Windows. There is plenty of material, books even. TL;DR, use the `_T` macro, which you can find well documented on MSDN.
If you are using C++11, take a look at Brigand https://github.com/edouarda/brigand The problem with MPL is variadic templates basically obsoleted the way it handled type lists.
There has been updates since 2004, but no major changes. Its better to use a library like [brigand](https://github.com/edouarda/brigand) or there is a newer one called [Metal](https://github.com/brunocodutra/metal). I think brigand is a little more mature and has a larger support of compilers.
Yeah I seen the minor updates but it hasn't had any real changes. It definitely doesn't seem to get any real attention. 
It's dead and should be avoided. You are better to write everything from scratch unless you are ok living in the past. You will redo everything with Hana. 
Being C++03-oriented..?
If the choice is between "supporting CMake well" and "supporting multiple build systems poorly", then I'll take solid CMake support every time. CMake is the closest we have to a de facto cross-platform standard for C++ right now, which is sorely needed, so its use should be encouraged.
My experience with MPL has been that it's easy to write things which do awful things to your compilation speed and give bad error messages, and it had some seemingly goofy limitations due to what could actually be implemented. I haven't used brigand, but I would expect it to improve significantly on these. I say "obvious immediate downsides" because I never had issues with writing things that appeared to work and be acceptable but later turned out to be problematic, so trying out MPL-based solutions to problems is low risk compared to something that you might have to rip out months later after thousands of lines of code have come to depend on it.
&gt; Yeah, but you don't notice it all that much. You most certainly do in terms of compile times, given any non-trivial use. Literally an order of magnitude. In terms of functionality (minus implementation limitations), agreed.
So what type of product do you print? Pain, suffering and death? Because that's what *Pathos* means in Greek.
I'd say many, if not most, at least indirectly depend on Boost.MPL.
What are you securing against who?
Yep - removed. A top-level comment in the stickied post will be accepted, as long it follows the template.
When benchmarking a given algorithm, the results get biased by the time taken to include header files, preprocessing macros and constructing sequences. However there's no portable way to get the time taken to compile only a small portion of the source file, so we basically compile it twice, preprocessing away the portion in which we are interested in one of the runs, and then subtract the results. For some really fast algorithms that can yield negative compile times due to the noise imposed by the operating system. [see here](https://github.com/ldionne/metabench/pull/109) for the relevant discussion
The benchmark results look almost identical for &lt; 20 elements on all libraries. I am a happy meta user and wonder if you could comment on why should I look at brigand on metal, what do they bring to the table? pros and cons with respect to meta, etc.
That's the tricky part - the results only show the time taken to compile the algorithm, but not to include headers and run the preprocessor. MPL, for example, is **very** dependent on the preprocessor, but because we are supressing the time taken to preprocess everything, it looks comparably as fast as modern libraries. As a general rule, multiply MPL results by 5-10 before comparing to the newer libraries so as to get the real picture as seen by the user in the end.
As the developer behind Metal, I can give you the big picture the way I see it: * Meta and Brigand are eager, that is, metafunctions are evaluated immediately, just like regular functions in C++. On the other hand Metal follows MPL original design and uses *lazy* metafunctions [1], that is, in order to *evaluate* a metafunction one needs to name the nested &lt;&gt;::type (or in the case of Metal use the [adaptor suffixed by _t]( http://brunocodutra.github.io/metal/#expression)). The big advantage of the lazy design are [lambda expressions]( http://www.boost.org/doc/libs/1_61_0/libs/mpl/doc/refmanual/lambda-expression.html) * Metal has been designed so that *everything* is SFINAE friendly, for example, you could feed an integer type where a *list* is expected and you won’t get a hard compiler error as long as you do it in a SFINAE context (think std::enable_if). AFAICT neither Brigand nor Meta provide such strong guarantees, so depending on what you use you get a hard compiler error even on SFINAE contexts (that’s the main reason why Metal is slightly slower than Meta for some algorithms). * Brigand has been designed for sheer performance, so basically they tweak every algorithm implementation so as to be [the fastest possible]( https://github.com/edouarda/brigand/issues/127#issuecomment-191324374), even if it leads to extensive code replication. Metal on the other hand has been designed to have the smallest LOC count possible while still being orders of magnitude faster than MPL. Meta seems to be somewhat in the middle. * Meta and Brigand leverage the concept of [Metafunction Class](http://www.boost.org/doc/libs/1_61_0/libs/mpl/doc/refmanual/metafunction-class.html) just like MPL. Metal has abolished this concept entirely in favor of [typed lambdas](http://brunocodutra.github.io/metal/#lambda) (metal::lambda) and lambda expressions [1]. In summary they are different approaches to the same challange, each focusing on different aspects, so from the perspective of a *regular* metaprogrammer (i.e. a happy MPL user) it basically boils down to personal preference. [1] Currently I’m experimenting with making Metal eager and drop support for lambda expressions, but that hasn't been settled yet. 
Really good stuff. The soft part, as you mention, really matters... You need to be motivated and keeping track of what you do to finish a good C++ book.
[QT's](https://www.qt.io/download/) development environment comes with a compiler. I strongly prefer it to visual studio. It is cross platform, you don't have to use the QT libs (though I don't know why you wouldn't if your environment didn't force you to). 
&gt; Yeah, you could test for typeof(p.owns(b) || f.owns(b)) in D just as well. Awesome, I didn't know that. &gt; The question is, however, how do you use those without static if? Higher order functions. Ultimately with design by introspection, you are more concerned about whether certain usage patterns are valid(and picking an alternative) than about evaluating boolean expressions(which is what an `if` implies). &gt; Are the slides somewhere? The slides are [here](https://gitlab.com/pfultz2/cppnow2016). There is a pdf version there so you don't have to build them.
&gt; Maybe I am weird but I really like meta because its very simple. It is, but it feels like it not very stable, and it broke its api recently. &gt; What are your thoughts on Metal and Brigand? I haven't used either extensively, and I have been leaning towards point-free style over traditional metaprogramming.
&gt; The big advantage of the lazy design are lambda expressions Doesn't laziness help compile-times as well? &gt; Metal has been designed so that everything is SFINAE friendly I like this design, but I found it very difficult to get clean error messages. Mainly because compilers don't treat undefined template instantations the same as overload resolution failure. &gt; Meta and Brigand leverage the concept of Metafunction Class just like MPL. It would be nice to have a metaprogramming library to support the core metaprogramming concepts such as metafunction and metafunction class. Especially since a lot of code is written with this in mind. &gt; Metal has abolished this concept entirely in favor of typed lambdas (metal::lambda) and lambda expressions [1]. Wouldn't a metafunction class be simpler? It also allows another library to provide their own type of lambda expression(perhaps they want to use named placeholders like in meta). It seems simpler and more flexible.
As far as I know, it only comes with an (excellent) IDE, Qt Creator, which I prefer over Visual Studio even. However it still needs a compiler to work with. The Visual C++ compiler included with Visual Studio is my preferred choice on Windows.
&gt; Doesn't laziness help compile-times as well? While it makes a lot of sense to think so, it is actually much easier to write faster TMP if you design it to be eager, but a well designed lazy API performs just as fast. The trick here is to realize alias templates, differently from inheritance, do *propagate* SFINAE contexts. &gt;&gt; Metal has been designed so that everything is SFINAE friendly &gt; I like this design, but I found it very difficult to get clean error messages. Yes, that's a bit of a shortcoming of SFINAE friendliness indeed. &gt; It would be nice to have a metaprogramming library to support the core metaprogramming concepts such as metafunction and metafunction class. The problem with metafunction classes is the fact their type is undefined, that is, one can't match a template signature against it. What I call *typed lambdas* on the other hand are required to take the form of a `template&lt;template&lt;typename...&gt; class&gt; class`, which can be used for template specialization. &gt; It also allows another library to provide their own type of lambda Good point, that can be overcome by allowing **any** type that matches the above signature to be treated as a Lambda, instead of requiring it to be an instance of `metal::lambda`. That is not really an issue to implement and since you pointed it out, it might be worth it generalizing the definition. Logged it [here](https://github.com/brunocodutra/metal/issues/31). &gt; perhaps they want to use named placeholders like in meta Named placeholders and bind expressions [are supported](http://brunocodutra.github.io/metal/#lambda) by Metal too. Think of instances of `metal::lambda` as *unbound expressions* (thus also variadic). 
Most IDEs are pretty good at detecting a compiler or bundling something. In this day and age, it's usually just installing, creating a project, and running. 
&gt; The problem with metafunction classes is the fact their type is undefined, that is, one can't match a template signature against it. Why is that needed? And can't you get the signature from `T::template apply`? &gt; The problem with metafunction classes is the fact their type is undefined, that is, one can't match a template signature against it. What I call typed lambdas on the other hand are required to take the form of a template&lt;template&lt;typename...&gt; class&gt; class, which can be used for template specialization. But then you can't return `template&lt;template&lt;typename...&gt; class&gt; class` from a metafunction.
no. learning to use a console is absolutely essential to growing as a developer.
Hmm, maybe I wasn't clear, consider the following: using lbd = metal::lambda&lt;std::add_pointer&gt;; `lbd` is a regular type just like any other and a valid Lambda. Suppose we want a metafunction `call` that evaluates typed Lambdas only, so that `typename call&lt;lbd, void&gt;::type` yields `void*`. One could simply define it as follows: template&lt;typename f, typename... args&gt; struct call {}; template&lt;template&lt;typename...&gt; class f, typename... args&gt; struct call&lt;metal::lambda&lt;f&gt;, args...&gt; : metal::invoke&lt;metal::lambda&lt;f&gt;, args...&gt; {}; You might ask why we would want to specialize it like so instead of simply forwarding to `metal::invoke`. The answer is simple: SFINAE typename call&lt;int, void&gt;::type error: no type named "type" in ... * bear in mind `metal::invoke_t&lt;int, void&gt;` yields `int`. The thing is metafunction classes don't really add anything. Perhaps you're jumping to the conclusion they would be required in order to implement *bind expressions* but in fact it turns out those are even easier to implement using typed Lambdas, so you can certainly do the following using Metal. using lbd2 = metal::bind_t&lt;lbd, metal::_2&gt;; static_assert(std::is_same&lt;metal::invoke_t&lt;lbd2, void, int&gt;, int*&gt;{}, "");
growing, not becoming one. learn the fucking difference.
So it's not related to C++ that's used in emergency services?
look at that account name though
it's not spam, I don't want to use my original account - to ask such a dumb question, nothing sinister.
Brigand looks very interesting however I find the minimal documentation and lack of use examples to be a huge deterrent to adoption. Hana is not an option due to no windows... Are Hana and MPL simuliar enough to Brigand that I can get an idea of it's usefulness by reading their documentation? How I wish Hana would work on windows... Maybe I should try to use clang on windows?
Do you have to build GCC 6 from source, or is there a PPA that works? I tried the ubuntu-toolchain-r/test PPA the other day on a completely fresh Ubuntu Server 16.04 install and it didn't work for reasons I didn't bother investigating.
For Hana on Windows I did have some success using Clang/C2 in Visual Studio. 
Defaulted template types also work with constructors, so another point in their favor (that one can be consistent). It's the more idiomatic choice in my experience. I can't honestly recommend this blog post, there are too many errors and points of confusion. 
I see what you mean, but check paul's cppnow 2016 presentation: https://gitlab.com/pfultz2/cppnow2016/blob/master/metaprogrammingmustgo.pdf It shows how to use Boost.FIT (which has been conditionally accepted) to implement your take on allocators (which is great btw) using introspection in C++. Yes, there are some macros, and yes, its a bit ugly, but I wouldn't put it on the same level as doing OOP in C. Anyhow thanks for still doing C++ talks. Almost every single talk you gave has bootstrapped a change in C++ for the better. Iterators must die revitalized the interest on ranges, `std::expected` might actually land soon, the allocators talk has already a comprehensive implementation in C++ by foonathan, even the static if proposal is going to partially land as `constexpr if` without mentioning how scope fail can be implemented in std c++ now...
First of all, it's awesome that you're interested in learning and teaching about C++. Your writing indicates you have a knack for bringing a complicated subject to an unfamiliar audience, which is not easy for most people to do. I'll be looking forward to your posts in the future. However, as others have said, there is much room for improvement in your post. For what it's worth, Most of my TMP knowledge comes from StackOverflow, experimentation, and blog posts like yours. Unfortunately, if I had stumbled across this tutorial while I was learning TMP, I would have experienced some unnecessary frustration. For the sake of those trying to learn, I really hope the suggestions in this comment section don't fall on deaf ears. Your tutorial has potential to be very useful, so I hope you are not discouraged when others point out problems. Since you're asking for feedback and ideas, I'll offer some of my own: 1) TEST your code -- always! In my opinion, example code should be absolutely bulletproof. At a bare minimum, one should use `assert` and `static_assert`to "prove" correctness of runtime and compile-time examples, respectively. Just because the program compiles and runs doesn't mean it does what you expect -- `[static_]assert` offers a path to mitigate this concern. Your first example compiles and runs, but (as another commenter pointed out) the `typename T::type` parameter is utterly nonsensical in the context of argument deduction. Think about it -- what could that possibly mean? If you had tried something like the following, you would have realized your mistake before posting: ``` template &lt;typename T&gt; constexpr auto foo(typename T::type) { return 0; } template &lt;typename T&gt; constexpr auto foo(T) { return 1; } struct MyStruct { using type = int; }; // fails! The code doesn't follow your intent static_assert(foo(MyStruct{}) == 0, ""); static_assert(foo(0) == 1, ""); int main() {} ``` As you can see, `constexpr` and `static_assert` work very well for these kinds of examples. Assertions are also a form of self-documenting code. With assertions, we can express intent, AND make our code more robust at the same time. Note: It's useful to think of `::` as a wall that the compiler cannot climb over during argument deduction. 2) I think it's very nice for TMP examples to be offered in a tidy, self-contained format, like the code above -- all you have to do is copy, paste, and compile. Of course, you often don't want to post an entire program to make a quick point of something. For those cases (and others), it's great to include a [link to a full example in an online IDE](http://melpon.org/wandbox/permlink/v3X6ppmQ2IqoXJ1Y). This way, it's easier for others to trust you, since it's easy to test whether the code is legit. This also encourages experimentation and feedback. The downside is that you have to remember to keep your IDE links up-to-date, although there are ways to actually [deploy your code online as a part your build process](https://github.com/boostorg/hana/blob/master/cmake/wandbox.py). 3) Nitpicking here, but the modern consensus is to [avoid `typedef`s -- use aliases instead](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t43-prefer-using-over-typedef-for-defining-aliases), like this: ``` using type = int; ``` This correlates to the familiar "variable name = expression" syntax that we all know and love. It's also simply easier to follow, since the `=` serves as an anchor point for the eyes. Along the same lines, I suggest you embrace [uniform initialization syntax](http://programmers.stackexchange.com/questions/133688/is-c11-uniform-initialization-a-replacement-for-the-old-style-syntax). This is mostly another a style suggestion, but uniform initialization allows us to quickly distinguish constructor calls from ordinary function calls (and thus, type identifiers from function identifiers). 4) Use `auto` to reduce code noise. This line has a lot of noise: ``` const std::less&lt;int&gt;&amp; l = std::less&lt;int&gt;(); ``` This line does not (as far as C++ goes, anyway): ``` const auto&amp; l = std::less&lt;int&gt;{}; ``` 5) Nitpicking again, but there is also no good reason to make a reference in the line above (in my opinion). Yes, [const references do locally prolong the life of a temporary](https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/), but it's a special-case for something that would be undefined behavior basically everywhere else. Again, style choice here -- I just flinch when I see this. Thanks to copy elision, there's typically no harm in taking in taking it by value ([live example](http://melpon.org/wandbox/permlink/R1l9JCCLEwB2LOFg)). Of course, you can always just declare it the normal way (without an assignment operator). 6) Your blog post is very short for such a deep topic. I think you can dive much deeper into the topic without risking overwhelming your audience. For starters: * `std::enable_if` can be used in several ways - you basically have it, but [this answer](http://stackoverflow.com/a/34706276/2397809) to my StackOverflow question might introduce you to a thing or two, like it did for me (P.S. - don't vote brigade) * `std::enable_if_t` makes code a bit easier to read and write * Expression SFINAE: * [is_valid](https://www.reddit.com/r/cpp/comments/3r0gri/an_introduction_to_cs_sfinae_concept_compiletime/cwkq0rj) -- a construct from u/louis_dionne's Boost.Hana library (link is a public domain standalone implementation) * [std::void_t](http://stackoverflow.com/questions/27687389/how-does-void-t-work) Hope this helps -- take my advice with a grain of salt. Good luck! Edit: formatting, word choice, punctuation, grammar, link fix
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; This makes the barrier for writing tests much lower - you don't have to: 1. make a separate source file 2. include a bunch of stuff in it 3. add it to the build system and 4. add it to source control - You can just write the tests for a class or a piece of functionality at the bottom of it's source file - or even header file! Do not underestimate this. I've started including tests alongside some of the hairier code and it removes one barrier to writing tests. Low compile-times removes another. Definitely checking this out! Thanks for posting.
Indeed! it was written to be as transparent to the build as possible - did you check the [benchmarks](https://github.com/onqtam/doctest/blob/master/doc/markdown/benchmarks.md#conclusion)?
I did, they look pretty incredible but the killer feature is the combination of the `CHECK` macro decomposing the expressions and the performance. Hopefully I get some time to take a look at it soon-ish.
Is there a reason you prefer to allocate it before hand ? I saw the Allocate when needed part on several posts/websites online.. Thanks !
\#4 should be reworded a bit. Inheritance doesn't imply virtual tables. Inheritance has plenty of use cases. Like type traits, CRTP, `std::vector` using `std::__vector_base` etc.
No problem!
definitely not expert on the topic, but exceptions provide in practice no guarantee on how slow will they be, so possibly avoid using them in real time code
The expression decomposing is very clever. I couldn't figure out how it was happening without looking at the code itself. Although `CHECK(1 &lt;&lt; 1 == 2)` won't compile, but that's an edge case. The decomposition works for pretty much all sane use cases. But it would be nice if you could overload `operator&lt;&lt;` for `Expression_lhs&lt;&gt;` to be a `static_assert` about why it doesn't work. Thoughts? Okay for a PR?
hmmm. yes :D I do disable some warnings within the header, but I reenable them after it. I might try to minimize the warnings I've silenced within the header itself, but some things like ```-Winline``` and ```-Weffc++``` are a pain in the ass.
How does it compare to Visual Studio's Testing framework, other than being portable?
Anyone able to compare this to catch. My favourite header only test framework?
How does it work when you mix tests with production code? I mean, do I somehow get real executable and one with tests(by using some flags passed to the compilator), or are tests somehow combined with application executable(so I pass some argument to the commandline if I want to run test suite)? I'm a bit confused about it. Also, if one decides to write unit tests in that style, I think best way would be putting all tests relevant to the class right below it, all tests relevant to a given method right below it, the same with functions. And then using some IDE/editor feature to automatically fold tests until you want to see them. But I'm not sure if any IDE would make it simple. Maybe vim is configurable enough to do that, through. Or is there an option to fold only macros in mainstream IDE's? Also, how does it compare directly with Catch? Apart from performance, are there any additional advantages or disadvantages you can think of?
The end goal is to have everything Catch has, but with the addition of even more things - which I like from other testing frameworks. I've provided a comparison regarding compile times in [the documentation](https://github.com/onqtam/doctest/blob/master/doc/markdown/benchmarks.md) The currently missing (but planned) features which Catch has are: - tags! - crash handling (division by 0, null ptr dereference, etc) - different reporters (xml, jUnit compatible, etc). - logging of variables/messages for when an assertion fails - time reports of tests - the ability for the user to write a reporter - matchers, generators This might look like a long list, but you can go far with the library in it's current form. [THIS](https://github.com/onqtam/doctest/blob/master/doc/markdown/roadmap.md#roadmap) is the full list of features currently planned. I decided to ship a first release without all essential features now to see what the reactions are from the community.
I think Boost Test had it many many years ago but I stopped using it because it felt like using Java (lots of ceremony)
&gt;Although CHECK(1 &lt;&lt; 1 == 2) won't compile, but that's an edge case. Wouldn't it compile if you put '1 &lt;&lt; 1' in the parens?
I've never actually used it... doctest is modeled after Catch and has some other features and ideas taken from other testing frameworks - but all are standalone portable frameworks. Maybe I should look into that...
Agree 100%. And in the fairly rare case that you do actually need polymorphism - in other words, where you really do need to look up which function to call from a table - you won't be able to do a better job by rolling your own.
When you mix production code and tests you get 1 binary, yes. And using command line options you may choose to: - run only the tests - run just a query from the testing framework - like how many tests are registered - ```--count``` - run only the application and skip the tests - run both the tests and the application And you can remove everything testing-related from the binary with 1 ```#define``` - for example for a "release" build. How does it compare to Catch? see [this](https://www.reddit.com/r/cpp/comments/4kibl4/doctest_the_lightest_feature_rich_c_single_header/d3fguwq) comment from the current thread. And apart from build-time performance: - it offers the way to remove everything testing-related from the binary - produces 0 warnings and doesn't pollute the global namespace Also considering I recently quit my job - there will be somewhat active development on the project.
This looks incredibly promising, I hope you are able to keep working on it.
&gt;Be honest, explain that you have no clue what real-time programming is, but would love to learn. If he knows it's real-time beforehand, he might at least be expected to have done some basic research. He could admit he doesn't know much, but saying he doesn't have a clue sounds similar to "I know what I could have looked up, but couldn't be bothered" to me.
Yes - the startup time is just the test registration - it uses a hashset to filter out duplicated tests (when written in a header file). There are some allocations going on while tests get registered - I might look into making some specialized allocator to minimize the startup time. There is also a neat trick which requires no allocations if I don't have to check for uniqueness - I might create a singly linked list on startup - by just connecting the "nodes". You are right about the global variable - some of the macros end up creating variables in the global namespace - but they are prefix-ed. Maybe I should make this clear in the documentation... But I'm pretty sure nothing will ever clash - I hope you dont write variables like ```DOCTEST_AUTOGEN_FUNC_34```. but If you just include the header - nothing gets dragged - not even ```strcmp```!
Yes you're right. But `1 &lt;&lt; 1 == 2` is a valid expression and if it doesn't work then it should output a clear message as to why it doesn't work or how to work around it.
another thing added in the todo list (static_assert for c++11)! 
Just realized you could literally use the preprocessor to do this haha
For sure, I was just saying that reducing compile times makes it more likely
&gt;You are right about the global variable - some of the macros end up creating variables in the global namespace - but they are prefix-ed. Maybe I should make this clear in the documentation... About that, if you can, make prefix which is unlikely to be used as a variable name, and isn't a prefix of an C++ keyword. For example CATCH uses something like 'autoRegistrar'. It somehow messes up with my auto-completion in CLion - I want to use 'auto' keyword, and it auto-completes to this 'autoRegistrarXX', where XX is an number... &gt; I hope you dont write variables like DOCTEST_AUTOGEN_FUNC_34. If it's in uppercase, then hopefully it won't interfere with autocompletion.
even with uppercase and a DOCTEST_ prefix visual studio still suggests me those variables when having typed ```aut``` - so ok - I will make it something like ```ZZZZZZZZ```
This is so disgustingly cringy.
Yep. I recently got a job doing embedded microcontroller C/C++. My biggest/best experience in tight memory before that was working on a lot of reverse engineered code bases, where I was implementing patches into binaries to create third party APIs. This meant replicating data structures that you have no control over, and getting away with keeping existing memory structures (some of them that _had_ virtual tables already) untouched despite wanting all the niceties of classes. It really made you think about your class design and inheritance. Going from that to microcontrollers ... not so bad.
Amazing! Congratulations! BTW, there's no such thing as *just* comms.. It's pretty central to any platform. Building a real realtime systems is a great opportunity and will make you a better, more conscientious developer, regardless of how many years experience you might have had prior...
Right on. Scheduling in a realtime system is paramount. OP, look up some scheduling algorithms. Additionally, as you noted, memory pools can be very important as well.
thanks for the comment, I fixed my post
You don't need to avoid STL or exceptions you need to know their costs - namely possibly bad implementation (and bad performance characteristics on numerous STL implementations - never use STL lists) and stack unwinding for exceptions - which isn't a performance cost so much as it is a space cost unless you're using exceptions for the wrong reasons. Don't allocate as required, allocate beforehand. Avoid thrashing the cache (store things that are used together near each other in memory). Allocate on the stack if possible ("free"). Real time programming is more about locks and concurrency. Not blocking, blocking at the right times, who's waiting on what, etc. The other big thing is cache misses - they normally cause the processor to yield in critical systems because ram is too slow. These are not basic concepts, I've been doing this for 3 years and I still make a lot of mistakes. In your interview do not try to and show that you understand these; try to show that you're interested. Ask questions that show you're interested ("I asked online and some yahoo on the web told me that locking schemes were important in real time programming. What design patterns do you use to address this issue?"). I have to stress this: DO NOT try and prove yourself an expert, you want to come off as an enthusiastic amateur that wants to learn.
How do your compile times compare to Catch's? 
see the [compile time benchmarks](https://github.com/onqtam/doctest/blob/master/doc/markdown/benchmarks.md) - just including the header is ~50 times faster for MSVC (not in the source file where the library gets implemented - there it's just a few times which doesn't matter - but everywhere else)
The author of catch does not allow the use of any c++11/14 code in his library. That could be one reason someone may not want to contribute.
[include-what-you-use](http://include-what-you-use.org/) tries its best to convert headers into forward references when possible.
The use of `#pragma once` with the Visual C++ compiler isn't necessary -- the compiler will recognize and "optimize" the standard include guard pattern, like any other C++ compiler does these days. So, there is no need for those additional three lines. Keep it simple.
&gt;Both GCC and LLVM are smart enough to generate as efficient code as you would have expected from the invalid version above. Actually, they both have an extension to the language saying that this is a valid and not UB as fuck. GCC came up with the extension and LLVM adopted it, because it wants full drop-in compatibility.
What was most/all headers to him? It is really simple * Anything that is outside the project should go there (exception: headers who change often, e.g. a project depends on a library and they are developed "together", that is, library headers change with the project). * Project's own headers should not go there (exception: for some crazy reason, some project header changes never/almost never).
thanks /u/jurniss. This is exactly what i'm going for. I wont become an expert and I wont go in there pretending to be one. but at least I will show that i've done some research on the high level aspects and that i am willing to learn. !
that's exactly why I asked all these questions. I want to show them that i am interested and that I have a basic idea of what RTS are. I wont pretend to be an expert. They would probably rip me apart. Most experienced developers know how to spot a wanna be
good points ! I will do that. I already brushed up on my concurrency skills. 
In regards to header include guards, I recommend using #pragma once It is easier to use, teach, and less prone to errors. The only major downside is portability because it is not part of the C++ standard. However, if you are writing C++14, then portability is not an issue. Look at https://en.wikipedia.org/wiki/Pragma_once#Portability and compare with http://en.cppreference.com/w/cpp/compiler_support More compilers have support for pragma once than for generic lambdas.
Noooo! std::any is an abomination! I'm done, folks. If this piece of shit makes it into the standard, I'm done with this language. 
Sounds like they did. You use cmake.
Well, it's been accepted for C++17 for a while now. It's also been in use for a while in the form of boost::any for a much longer time as well.
Good find! I didn't notice that. "It compiles" here certainly **won't** mean _it works as expected_.
How does the first one work when it (presumably) uses a variable that hasn't been declared yet?
The rules are different for C++; for example, union-based aliasing is not allowed in C++, except for the common initial sequence rule. Elsewhere, C is more strict than C++; firstly, it has `restrict`, which C++ has to manage without; secondly, in C++ the "points to" rule requires some relaxation (although indications are this will be tightened up in C++17).
Huh? This is **6.5.2.3 Structure and union members**, footnote 95: &gt; If the member used to read the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called "type punning"). This might be a trap representation. Yes, it's UB in C++, but this article is about C (and thus somewhat offtopic, though still interesting).
This is by far the most complicated thing I've ever done with C++ templates, but I think it turned out alright! If somebody can see a better way to do this, let me know. I'll gladly accept any feedback I can get. 
I hacked something ugly like this together to test CLion, but it was a pain and didn't fully work correctly. The CMake syntax is bad enough when you are using it to build, why would you want to use this when you aren't even using the build system? Compared to qtcreator where you just specify one header path per line, could not be simpler.
Well then that explains what he was searching for.
Well, in C90 it's implementation-defined. I don't know of any C compilers that claim C90 compliance and do anything other than type-punning when reading inactive union members in C90 mode, but I suppose it's a possibility; do you know of any?
&gt; "wondering if there are actual pain points to using it" For me, not using proper variadic templates for typelists been a significant pain point in my projects in the past. I had to debug a crash in some code once -- some class `A` which we implemented had a bug, but it was being used in a `boost::variant`, so all of the backtraces were horrible. Meaning, every time the type of the variant would appear in the backtrace, there would be almost 20 instance of `boost::detail::variant::void_` their dummy placeholder type in fake type list. 20 instances of that is almost 400 characters, and sometimes this type would occur half a dozen time in the name of a function, because the variant type would itself be a template parameter. Result was that something like 75% of the characters in our 40 line backtrace was just repetitions of the phrase `boost::detail::variant::void_`. I consider that to be a dramatic reduction in readability and the lengths I had to go to to sanitize these backtraces and make them readable, so I could get the info to solve the bug, motivated me get rid of `boost::variant` in our project, and upgrade to a C++11 variadic variant instead. Most experienced C++ programmers would just tell you to suck it up about this, and of course they are right, backtrace readibility just isn't that high in the totem pole of concerns you are normally thinking about. But I think it doesn't change the fact that it is at least a small "pain point".
Some of these are pretty domain-specific and may be specific to your compiler, OS, etc. I develop embedded code that runs on ARM chips using FreeRTOS. Our devices are instruments for research and testing labs, but they are not FDA-approved for medical use. I try not to do any dynamic allocation, after the box is up and running, at all. Basically, there is a malloc(), but I use it only for all my different task initialization methods that run once at startup. Most of what is allocated are mutexes and queues (FreeRTOS objects). I never write "malloc" or "new" explicitly in my code. When I allocate a FreeRTOS object, I immediately check it for NULL and a failure is a critical fault; the box will not run. The boxes all run the same startup sequence every time; if it works on one, one time, it should work on all of them. All my tasks use a FreeRTOS sleep API call, vTaskDelayUntil( &amp;xLastWakeTime, xFrequency ); http://www.freertos.org/vtaskdelayuntil.html Either that, or that sleep on queues. This works really well to keep them in lock-step. As long as the worst-case time it takes to get from wakeup to sleep again is not arbitrarily high, my tasks do a great job of running at the exact frequencies I specify, even in the presence of interrupt handlers. I have to say this is the first project I've used it for, but I really love FreeRTOS. Most of our current application is in plain C. I am struggling to get my compiler to work with some C++11 features so that I can statically initialize class objects the way I want (I need initializer lists and some other features). Basically, I want to use trees of class objects but never execute "new" at runtime. I'd really like &lt;array&gt; too but it's not clear if I'll be able to get that working. If I can't get the features I want working, I'll be having to allocate my objects statically but then do a bunch of post-construction setup, which is doable but ugly and error-prone. There are some other issues where I have to be careful to allocate enough stack space for each task. I have access to printf for debugging but printf on a handful of floats can use a rather shocking amount of stack space. So I have a lot of conditionals on setting up stack space (debugging flags). 
&gt; No speed cost associated with allocating. I would add: the cost of allocating, if you don't do allocating, never _changes_, so it is predictable.
Which version of MSVC are you using?
So create a global lambda object? I'd rather create a global function and use std::bind. When in closed scope I will most likely use lambdas.
I'm not sure what the scope of your code is, in any case you would use the lambda where you would use bind, not instead of of the function. There's almost no (other than some corner case I forget) reason to use bind at all in 14. 
Well `(hash1 &lt;&lt; 32) | hash2` is a pretty shitty way to combine 2 hashes.
Real-time is all about keeping up with requests with high *reliability* and *consistency*, speed only comes second (or is that third now?). Real-time is about constantly hitting deadlines, not necessarily about fast deadlines. For a real-time system, I would allocate as much as possible early on and never let go of the memory, since that way nothing else can cause you to run out of memory and fall behind on schedule, which means death in real-time systems. And allocation could itself have a minuscule time cost, so getting over with it early on good be a good idea for performance later down the road.
 #ifdef _MSC_VER #pragma once #endif // _MSC_VER What the hell is the point of this madness? The C++ standard already dictates that all compilers are to ignore any unrecognized pragmas (that is, they will at most emit a warning, but it won't break anything). And `#pragma once` is nowadays supported by all major compilers, not just VC, so that's only shooting yourself in the leg...
`void*`
It's not combining 2 hashes. It's combining the two parts of the pair. This stretches the definition of "hash" a little, but there's nothing wrong with being inclusive, and this sort of thing can in fact be a perfectly good hash function! You do have to be choosing it deliberately, though... When I first learned about hash tables a common suggestion was to make the bucket count a prime. That puts up some kind of defence against hash functions like this one, since it mixes more significant bits of the hash into the result. This appears to be what the author is expecting. If you've got a decent hash function, though, there's no need to do that. If all the bits are basically random, you don't need to mix upper bits in - you've got everything you need in the lower bits already. That means you can have a bucket count that's a power of two, and extract the bucket index with a (cheap) masking operation. However the caller does need to provide a hash function that actually does some hashing... I vote for the latter approach myself - you don't need a table of primes, and I say it's absolutely fine to expect the caller to provide a good hash function (that's then used fairly transparently). If there's anything wrong with VC++'s `std::unordered_map`, it isn't (on the face of it) this aspect. But both approaches are valid.
Ah thanks. That was unplanned to try it there, but I went ahead and gave it a shot.
&gt; TIL: concatenating integers is a bad hash function.
Have you ever thought about a non node-based implementation like [.NET's Dictionary&lt;K, V&gt;](http://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,d3599058f8d79be0)? 
&gt; Multiple hashes are assigned to the same bucket This is a standard tenant of hash tables, though, right? Every time a class reintroduced hash tables to me in college, one of the main takeaways was always that the bucket space is generally smaller than the domain of possible values, pigeon-holing multiple hashes to the same bucket and triggering whatever collision process you use.
The or (|) operator is shitty because it looses information. The operation should be reversable if one of the operands is given, otherwise for a fixed operand it maps multiple inputs to the same output. You should prefer doing a xor instead of or. The concatenation does not directly weakens the hash until you consider that it's not uncommon to only use a prefix or suffix to classify the space into wider sets. In that case concatenation wastes the information added by the part that's left out of the chosen substring loosing information from the original classification. By doing permutations (rotations) and xors you are basically doing a permutation of the Domain, so you don't shrink it or shift the likelihood towards some portion of it.
The problem with powers of two, it's that they basically use only a suffix of the hash, which basically ignores part of the information that you had. Using primes would be a good idea if you are into division, but as there are better ways to combine hashes that allow for using suffixes/powers of 2, then it makes little sense to patch an inexistent problem with harder hash remapping (dividing).
If your hash is any good, all the bits are equally well distributed. Personally, I don't use `std::hash` so I can guarantee all my hashes come from a good stream in the first place, so I don't need Boost's extra step to turn bad hashes into good ones.
Why do people find PascalCase so alluring in the snake_case world of C++?
&gt; The use of the singleton pattern can help a lot for system-resources like files, memory, etc How are you going to test this code when it just goes off and grabs what is essentially a global variable?
Companies like Microsoft are too big for their own good. It's best to see the different projects as completely separate entity. It may be easier for some guys on reddit to have an exchange with the VC team than for someone in, say, the SQL server team, or in this case, the Bing Ad team. It also explain why a company can release 3 different products doing the same thing on the same week. The hall is just to damn long. 
In my experience it can be useful as a way to separate ApplicationCode from lower level library_code. 
I've always been taught and told to use camelCase
Has anyone suggested deprecating the bucket functionality to the LEWG?
FWIW, g++ trunk doesn't compile as well, [see](http://melpon.org/wandbox/permlink/JTdJ44HujXRVXX1H). I doubted it's a extension of clang. Edit: found the relevant [SO question](http://stackoverflow.com/questions/14285198/why-doesnt-the-c11-auto-keyword-work-for-static-members), the answer suggests that it's not allowed.
Pretty much. He just had to use `boost::hash_combine` instead of concatenating the two integers.
It depends on what the programmer who set the code style is comfortable with. I use Hungarian notation because that's how i first learned to program. As long as you're consistent it's not a big deal.
Is there any text of this presentation? Does not want to waste hour of my time watching it.
nice, thx for share.
Which is why the "solution" suggested in the article baffles me. The author just inverts the order of the concatenation but that just shifts the problem. Why not *fix* the problem by mixing the numbers using one of the established and well studied methods?!
Another awesome presentation by Gabriel Dos Reis, I really like how he does the presentations, clear and easy to understand. I believe modules should be the number one priority in the new C++ features. It will not only simplify the creation and import of libraries but also improve a LOT compilation times.
Nice work! I found a typo in one of your examples: doubleRet::const_binder&lt;&amp;Vector::getX&gt;::bind(mrb, "x"); doubleRet::const_binder&lt;&amp;Vector::getY&gt;::bind(mrb, "x"); I'm working on something similar, but with a slightly different approach: my primary focus is a wrapper with overloading support, so I can write something like this in ruby code: objectRegistry.add(CppObjectA.new) objectRegistry.add(CppObjectB.new) and it would call two different overloads / template instantations C++ functions with different C++ types (CppObjectA and CppObjectB). But it currently only exists as a few proof of concept trials, I have some open questions left before I can implement a full wrapper.
&gt;As long as you're consistent it's not a big deal. Which PascalCase never is since the whole standard library is snake_case. 
Ack, you're right. I'm always mixing those up... even when I wrote it I thought I might be mixing it up. Hopefully it's still obvious what I meant.
Hmm, and I tried decltype(A::m_a) in there and it works. It just seems odd that if decltype works that auto won't. I see their argument that auto requires the type to be derived to what is being assigned, but auto can never be used otherwise in this case.
Don't worry about it. Most of the Windows software is built using Visual C++, so it's definitely "good enough". Bonus: it generates debug info in PDBs, that means you'll be able to use all the awesome windows debugging and profiling tooling.
Nice, thanks! 
Well because it was in use in parts of the C++ world even before there was an ISO standard. Let alone that camel case is also popular in many other languages. I think it is ridiculous when people complain about such mundane things.
Visual studio compiler is (or will be soon) available as a command line standalone application. So you can use any ide and compile with both compilers anyways. Personally I use eclipse and write code that compiles both with mingw and visual studio via cmake :)
Hmm, no standard library support for `std::hash&lt;tuple&lt;int, int&gt;&gt;`, that is sad. Since we have `std::hash&lt;std::string&gt;` it would be possible to do something like reinterpreter_cast `std::tie(datum1, datum2)` to `char*` (or maybe to `std::array&lt;char, 8&gt;` would be better, because terminating null could appear in the middle) and hash it like string / binary blob.
It is a stand alone component and it always has been. The compliers executable is cl.exe: https://msdn.microsoft.com/en-us/library/610ecb4h.aspx . The compiler toolchain and the IDE are *always* separate. &gt; Personally I use eclipse and write code that compiles both with mingw and visual studio via cmake :) **FACEPALM**. Please tell me that you're joking and that I just fell for it hard. 
It's always been packaged with VS. Now you can get the "Visual C++ Build Tools Standalone". As for the rest, not sure which part scares you? But it's all pretty much valid in the industry I work in. - Eclipse, because I'm swapping between projects/languages/operating systems constantly and want a consistent IDE. - MinGW because it's the closest to GCC and gives me a good indication of whether or not my code will compile cross-platform without having to wait for the build system. My code has to run on OSX, Linux and Windows. - Visual C++ because it often has higher performance with math calculations than MinGW. It's often comparable to GCC on Linux though. Visual C++ debugs better on Windows too. - CMake because building and packing source code for people who are not software developers/programmers is a lot easier if you can standardise. Scientific software often developed by scientists is also usually very difficult to compile/integrate into your project. Wrapping with cmake is usually easiest/quickest to ensure I can deliver the project as source code to scientists who can build the project and dependencies locally. TBH My work requires me to use multiple languages, compilers, ides, build chains and operating systems. I don't have a personal favourite; just work to make the environment as simple as possible. Edit: Formatting
Maybe I was being pedantic? If I swap out "compiles" with "builds" in that sentence then it becomes correct. The two terms are different though, and we should emphasis that instead of adding to the confusion for newer users. 
You can also use ninja with Visual C++ :) The main benefit of Visual C++, IMO, is the fact that it produces smaller binaries, and it compiles a bit faster (using ninja and not msbuild). Regarding PGO, MinGW also has PGO, and the instrumented binary is not as slow as Visual C++'s version. See my article [Speeding up libclang on Windows](https://cristianadam.eu/20160104/speeding-up-libclang-on-windows/) for some numbers. Write cross platform code, and, always benchmark! 
Was this recent? I remember fighting with SSE intrinsics a few years ago where some of the code gen was just bonkers... it was either 2008 or 2010. MS seems to make pretty solid strides with every release. If you're on the latest hotness, you can try their new optimizer too. https://blogs.msdn.microsoft.com/vcblog/2016/05/04/new-code-optimizer/ Maybe you can give Clang a shot as well, it's mostly just drop in and a couple minor tweaks later I had my stuff building. Just change the platform in your project settings. http://llvm.org/builds/ Clang's surprised me several times with what it's managed to concoct vs MSVC.
&gt; Personally I use eclipse and write code that compiles both with mingw and visual studio via cmake :) What do you do for a GUI? I've always used C++Builder for Windows GUI but it is a pain for anything else except GUI-building. All of the GUI solutions for the G++ or MSVC seem quite cumbersome in comparsion, e.g. wxWidgets builds a 30MB DLL and still is a lot of work to use; make a New MFC application in VS express and literally it makes 30 files of boilerplate 
Visual C++ has higher performance with math calculations than MinGW? Any chance you have data/examples or a reference? It seems to directly contradict /u/Harha further down: https://www.reddit.com/r/cpp/comments/4kv7nq/mingw_vs_visual_c_on_performance/d3i1t9b
Oh awesome. Thanks for pointing that out. Have a cmake superbuild project and have had a fair bit of problems getting qtcreator but this was the last missing piece.
You can re-read for comprehension far better from a transcript, too.
&gt; Hmm, no standard library support for `std::hash&lt;tuple&lt;int, int&gt;&gt;`, that is sad. Agreed. &gt; the rest of your comment Vehemently disagreed.
Before worrying about performance,I would worry about conformance for personal use. I'm not a Windows user when programming, but from what I see on SO, that is not where MSVC excels. Also, gcc and clang are free, which is nice.
Obvious problems I see just from the API: * It's still focused on codepoints, not grapheme clusters, which should nearly always be used. * It doesn't deal with columns. * Documentation is wrong: casefolding is uppercase for some scripts, e.g. Cherokee. * It confuses general categories of upper/lower/title with the ability to transform them, e.g. consider the dedicated roman numeral codepoints (which are `Nl` not `L&amp;`)
QT. C++ GUI is still kind of a shitty area still.
It doesn't matter ***Why*** on this one, it's because your coming across as entitled. The video author doesn't owe you anything, it's mean to insult them *"Does not want to waste hour of my time watching it"*.
I believe until a couple releases ago, performance of intrinsics was not as good on MSVC. I know they have improved, but I don't know exactly where they stand now in comparison. I can't seem to find any C++ compiler benchmark comparisons online. Anyway, in general MSVC code quality is very good. Also, incremental LTCG in VS2015 makes compiling release builds way faster.
This is literally the only C++ benchmark comparison I can find online: http://www.g-truc.net/post-0372.html From that, it looks like before 2010, SSE perf was pretty bad, but in VS2010 it became faster than GCC. That graph is a few years old though... so I guess it needs to be taken with a grain of salt.
Any rational person interprets the question as "is there a way I can avoid wasting an hour of my time by being able to read it rather than listen to it?" If _you_ interpreted it otherwise, then that's unfortunate for everyone involved. If you actually _did_ interpret it that way and still pursued this conversation then I am simply dumbfounded. Nobody said the author owes anybody anything. The question is if there's a time-saving alternative to watching a video; unless you're the author and simply love the sound of your own voice, why the fuck are you being defensive?
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Visual studio community is free right?
I would hesitate,but would not mind being over-ruled by the team. My rationale: minimize compile-time dependency for clients who do not use that particular method (if applicable).
It's stackless coroutine so there's no call stacks, instead, there's a coroutine frame that holds the variables local to the coroutine. Resuming a coroutine has the overhead as calling a virtual function, and suspending a coroutine has the overhead as returning from a function. Accessing local variables in a coroutine has the overhead as accessing data members of a struct.
More obvious things: Some people may choose to type and read code while the video is playing in the background. Other people use screenreaders - so they'd be listening to it anyway. Also, sometimes switching focus between senses is an alternative to taking a break. That extra hour is not necessarily lost. 
Is there a reason you're using Eclipse instead of Qt Creator? Creator can use MSVC+MingW as well, and I feel like it's way better integrated with Qt (well, d'uh!).
**Company:** [Klebert Engineering](http://www.klebert-engineering.com/) **Type:** full time **About Us:** We are a small and highly efficient engineering company that helps our customers build digital maps for automotive infotainment and autonomous driving. We are working together with the Navigation Data Standard (NDS) consortium and its members, providing technical solutions and tooling support for the automotive mapping industry. So we deal with challenges like squeezing the whole world’s map data onto one SD card and connecting the map of tomorrow to the cloud. **Job Description:** We develop applications that are used to analyse and visualize digital maps. Designing and realizing intuitive GUIs, working on 3D visualization and writing high-performance code are our daily business. We use a modern development infrastructure with an integrated setup of Git (Stash), Continuous Integration (Bamboo) and Backlog/Sprint Tracker (JIRA Agile). As we are developing cross-platform applications team members are free to use Linux, OS X or Windows for development. **Location:** Munich Area, Germany **Remote:** No **Visa Sponsorship:** We prefer candidates who are already permitted to work in the European Union but we are open for discussion. **Technologies:** C, C++, JavaScript, Qt5, SQLite **Contact:** jobs@klebert-engineering.com
Which style would you use when writing a cross-platform abstraction? Windows or Unix? Consistency is more important than adopting the style of the library/API you start off with.
There are a few active IRC channels on freenode. \##C++-General (About anything related to C++) \##C++ (Strictly standard (ISO) C++) \##C++-Basic (For beginners) There is also #C++ on EFNET, but I found the people to be... rather unpleasant there. I know it's not Slack, but the communities are large and active. The main C++ channel has over 970 users in it and the general channel has almost 400 users in it.
yes! It's called ```SUBCASE``` but it works just like a section in Catch
wow, very nice ! gonna try this on my app, only for the moc time improvement which is roughly one fifth of my build time. edit: &gt; Support for templated QObject. &gt; Support for QObject nested in another class. I'm crying.
Personally, I'd rather see Concepts first, if either had to be prioritised. I'm real sick of obscure errors in headers I should never have to be aware of. But Concepts and Modules together in C++ vNext would make it finally seem like using a modern language.
Absolutely agree here. It annoys me that much of the material on MSDN (picking one example - other's are just as guilty) is now in video, but this is a talk from a conference, so its fairly understandable that its a video. If it really pissed me off as much as dodheim, I may consider typing it up and posting it underneath the video for the benefit of others, but the rant above just seems like an overdeveloped sense of entitlement.
Concepts don't seem to improve the errors that much in their current form. May be worth simply prioritizing the lower hanging fruit for now.
And boy, are people good at C++ in ##C++. 
I submitted the same link a few days ago, and the mods removed it because "C is off topic" (which I disagree with).
While some of it doesn't apply to C++ (e.g. type punning using unions is UB in C++) some of it does apply. I'm invoking the mods so that they can remove it if they want to.
I have not tried. It is using C++14 feature, some of them might not be supported by MSVC. Please try and let me know what the error are, it might be possible to work them around.
Nice.
Interresting. The problem comes from the two NOTIFY signal. Strange that one of the tests is having several properties with the NOTIFY signal of the same type. I think this might be another GCC bug. Comparing pointer to member function should be constexpr i think. At least it works with clang, but gcc throws an error. struct Foo { void ccc(); void ddd(); }; constexpr auto foo1 = &amp;Foo::ccc == &amp;Foo::ddd; // Error with GCC constexpr auto foo2 = &amp;Foo::ccc == &amp;Foo::ccc; // Ok I'll try to workaround this bug. EDIT: I pushed a workaround https://github.com/woboq/verdigris/commit/f3663356868038f42cb9e8258df44a1d156f1c12 The bug is already known in the GCC bug tracker: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=69681
I was not aware of the new release. I don't believe it was already available at the moment I ran the benchmarks a few weeks ago. I did not do myself the benchmark of the runtime performence of CopperSpice. I based my data on the benchmark that were done by somebody else and reported to me. I was looking for tests or benchmark for CopperSpice that i could use to test my solution, but i have not find any.
For years they have always been behind the game actually. They cherry-pick features from past and potential future standards at will, with many holes to be able call it feature complete in none. I dunno what's up now, but I won't be surprised it wouldn't work because of C++14 relaxed constexpr usage, which is required by this project. Last time I checked there were bugs, but possibly it could have been fixed in the very latest compiler version. EDIT: "Finally, C++14’s min()/max()/minmax() for initializer_list and C++17’s min_element()/max_element()/minmax_element() inherently contain loops, so they require C++14 extended constexpr support from the compiler, which is not yet available." Source: https://blogs.msdn.microsoft.com/vcblog/2016/01/22/vs-2015-update-2s-stl-is-c17-so-far-feature-complete/
Yeah, the standard library is very good (c++14 and c++17-as-it-stands library features supported 100%) but the compiler is kind of meh because it barely supports c++11 iirc. Which makes the pair as a whole kind of meh.
I'm almost tempted to take this as a challenge, but I guess I'll refrain.
Define it right with the declaration.
That's only legal for const integral values, and since C++11 for constexpr literal values, that are not ODR-used.
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; What's wrong with their containers? `deque` is useless due to its tiny block size and the `unordered_` types have naive bucketing logic. AFAIK, other than these five, the rest of the containers are fine. The `&lt;random&gt;`, `&lt;regex&gt;`, and `&lt;filesystem&gt;` implementations are also highly questionable, though I understand /u/BillyONeal has been giving the latter some love lately.
I just build from source. Sometimes getting ubuntu to use the right version with the right stdlibc++ for the system is tricky.
Removing again - C is still off-topic. There's a C subreddit if you want that. An article about type punning in C++ would be on-topic.
`deque` is one of those chicken and egg problems -- it doesn't get love because customers tell us they don't use it, which means customers don't use it.... `&lt;regex&gt;` is really in need of complete replacement `&lt;filesystem&gt;` is going to need to be overhauled due to [REDACTED](https://twitter.com/h0x0d/status/736018035887079424), though we want serious issues in the standardese fixed, namely around how `directory_iterator` is allowed to cache things I'm not aware of serious problems in `&lt;random&gt;` other than the string representation of some engines is broken (which almost nobody even tries to use). So if you see issues, please file bugs!
https://www.juce.com/releases/projucer-juce-4
It's all about your tone. 
It's pretty close to c++14 support. I know it used to be awful, but I've been using 14 features when relevant and having no problems. 
From the link: &gt;Requirements &gt;Mac OS X 10.9 or higher, with Xcode 6.3 or higher installed &gt;Limited functionality on Windows 7 or higher, full version coming soon 
You still create your free function, but just use a lambda in the same place you were using bind. It will simply act as a wrapper to call the free function with whatever arguments.
You are right, though they tend to be misused. 
Ok, thanks.
There is nothing in the release notes of 4.1 or 4.2 saying that anything has changed for linux or windows. Do you use this and if so have you gotten live compilation to work on windows?
Live compilation is not part of the windows or linux versions. I'm not sure why this isn't sinking in. I tolerate ignorance and arrogance separately but both at the same time is poisonous. I'm guessing your aggressive misunderstanding is habitual, but if you know nothing about what you are talking about and have no interest in even the most trivial surface level comprehension, why even reply? 
Something like this: template&lt;size_t... I&gt; struct encrypted_string&lt;std::index_sequence&lt;I...&gt;&gt; { std::array&lt;char, sizeof...(I)+1&gt; buf; constexpr static char encrypt(char c) { return c ^ 0x41; } constexpr static char decrypt(char c) { return encrypt(c); } constexpr explicit __forceinline encrypted_string(const char* str) : buf{ encrypt(str[I])... } { } inline const char* decrypt() { for (size_t i = 0; i &lt; sizeof...(I); ++i) { buf[i] = decrypt(buf[i]); } buf[sizeof...(I)] = 0; return buf.data(); }}; If you gotta a really large OpenGL/OCL kernel this lets you vaguely protect your IP.
Epic answer.
I hang out on irc a lot and ##c++ is one of the most unpleasant elitist channels I have seen. A shame for the community IMO
Am I? Am I _expecting_ that? That's what you got from my post? Amazing.
&gt; Or let me read it, FFS Seemed that way to me. Maybe you need to learn how to communicate better.
This is a brilliant exercise.
extreme shitposting
I wouldn't. Using 1 question it's impossible to determine someone's knowledge of a subject. You are going to have a lot of false positive and negatives. 
Get a life
..but if you had to :) . Gun to the head.
[removed]
What does "Resource Acquisition Is Initialization (RAII)" actually mean?
"What level of C++ programmer are you?"
I think that was the Wu's wildly unsuccessful follow up to C.R.E.A.M.
That C++ has some really weird acronyms? SFINAE is my favorite.
If you could change one aspect of the language what would you want?
"What is your level in C++?"
Which editor do you use?
Someone asked Bjarne Stoustrop that question. If I recall correctly, he rated himself as a '7'.
Dunning-Kruger in action.
Explain the name lookup rules of C++ (which would include argument-dependent lookup, lookup in templates and at the point of instantiation, use of the typename keyword, name hiding, etc.) *alternatively,* The export keyword which allowed for templates to be defined outside of header files was removed in C++11 because it was nearly impossible for compilers to implement. Why would this feature be so difficult to support?
What makes C++ different from C?
When is explicit template instantiation necessary, and what could be done to "fix it"? *alternatively* What is the rule of five?
"5/7"
"If you had to ask 1 single C++ question to determine the level of a programmer, what would it be ?" No, seriously, that's what I would ask. It would tell me which topic *they* consider advanced or complicated or important, which in turn would inform me how advanced they are.
I love to ask people what are the rules of thumb of passing arguments to a function and returning and why, if they talk about the regular by pointer by const ref yada yada, I know they at least listened in class. If they start talking about rvalues and rvo I know they actually read about c++
When you use a template in code that is shared between libraries you need to do so in order for it to be exported.
To continue this hypothetical, my response is one of the following: * Ha! You're hired * Yes * Pick one and tell me more
Is that a question?
Alternative operator representations.
So what you are saying is, OP is actually evaluating all of us right now. 
My favorite question is to ask "If an exception is thrown, and not caught by the same function that threw it, will any variables have their destructors called, and could you get memory leaks?" Then I follow up asking how they could prevent those sorts of memory leaks. If a person seems advanced, I'll try to see if they understand what the clone idiom is for.
Are you only looking to work with language lawyers? 
CREAM?
&gt; answer I taught an undergrad engineering course in numerical methods, primarily using Fortran but I gave one assignment in C++ (really pretty much C) just to give them a taste. Maybe 30-40 lines of code. I overheard one of the students later when asked where he stood 1-10 in C++, and he confidently answered "oh about a 7". Guy had never written an object in his life. 
1) Yes and yes. 2) RAII 3) Polymorphic copy.
"And before I answer that... What do you think is *your* level in C++?"
This is susceptible to the Dunning Kruger effect.
I have come at peace with the idea that no programming language is perfect and that changing an aspect of it, presumably for my personal benefit, could be detrimental and even catastrophic to others. I'm also not a PhD in language design and my insight into the world of C++ is limited to my own experience as I have not spent the last 15 years actively seeking other programmers' experiences, insights and ideas. As much as the standards committee may be derided sometimes, I know enough to not pretend like I know more than they do.
TMP is the one thing that seems to come relatively natural to me that nobody else seems to get, it's nice office cred, and surprisingly useful.
Get this man a job in management!
Do you actually know a 65 bit system?
I should have mentioned that the question is not intended to be yes/no, but an explanation of what does and what doesn't leak, and why.
IIRC if you ask a bunch of random people to name a random number between 1 and 10, 7 is usually the most popular. 
What's the difference between list and vector in term of memory layout ? I'd ask this question because a top student in a c++ game programming class seemed to completely fail to understand the difference. The basics are important, if you don't know about low level programming, you won't benefit from using C++.
I primarily do compiler work, so understanding the "scary" parts of the language is important not only for code quality but for the final product. But I agree that it's probably a niche requirement. I would have completely different requirements if I were looking for, say, game developers (who need to make things very fast, often forgo templates and otherwise ignore the scary parts of C++, and care deeply about cache locality and platform-specific optimizations).
Over 9000 
There's no good answer, however depending on the "depth" of the criticism you may gain some understanding into how deep the answerer dived into the language.
Amusing, I much prefer `not`, `and` and `or` :)
I care about productivity. The two biggest productivity hits in projects of the scale I care about are currently compilation/linking time and the cost of rolling out systemic changes to to multi-million line code bases. The specific implementation of the improvements are less important to me than the problems themselves. This isn't a sexy answer and there are plenty of smaller scale features that provide huge benefit, but none of them would impact productivity in the same order of magnitude for as many programmers.
I've always thought between the pointer syntax, references and plain variables there's just one too many ways to access a variable, pretty sure you could drop and make the whole language more straight forward.
Explicit template instantiation is pretty cool, you just have to remember to instantiate everything you plan to use. 
Tabs are for indentation and spaces are for alignment. :) 
If I could have one thing it would be better language constructs to handle very large levels of parallelism. The recent additions with futures has been a start. But in my line of work (computational science) we're starring down a very scary road where computers have hundreds of cores. C++ doesn't really have a great answer to simply describing how to exploit that level of parallelism. Yes, there's openMP, yes you can roll your own custom thread pool. Yes with enough elbow grease you can get the job done. But I wish it was simpler. I'm probably asking too much from a compiled language. If I could have 2 things, my second would be faster compile times. I'm extremely jealous of my friends who work in dynamic languages. They don't know the pain of having to make a one line change in a header file that everything depends on. 
It's closely related to functional programming, so if you have some experience with that it really helps 
What is your most/least favorite thing about C++? This will tell you everything you need to know about what that person knows about C++! Replace C++ with any technology and it is equally as valid.
I ask this question in interviews, but the trick is to follow up. When they inevitably say "7", ask what a 6 would struggle with. They will almost invariably tell you the most recent, most complicated thing they felt they did.
Anyone who asks this question and uses the number at its face value is a fool. It's a good intro question to open up follow ups, but the answer itself is meaningless.
Yes, of course. But is the answer really important? When you hire someone, you usually don't need someone with a specific "level" (not too bad, but not need to be the best in the world), but someone who can learn (C++, but also everything he need to work in your company), someone who can work with your team, and lot of things (not just technical skills). Questions in interview are not just to know the "level" of someone, but to know him. Questions are just to start discussion. Then, probably all questions are good. (but I really like the question of specialpatrol)
There are some domains of C++ that don't use exceptions though. You may be doing yourself a disservice by using this as a strict gate.
Mainly because of VC++, the flag to enable them can also have some funky side effects iirc.
"How do you invert a binary tree?" - Google
&lt;joke&gt;10/10 of course. According to Dunning Kruger effect.&lt;/joke&gt; It's really a important question. It's not because you are the candidate than you can't choose your company and ask some questions. But it's probably a bad answer to this question. (And more generally, don't answer a question to a question).
I enjoyed the Google phone screen scale: 1 "I've heard of this thing" to 10 "I've written books on and/or designed thing"
&gt;&lt;awkward silence&gt;
You should probably not use templates at all if you want fast builds
Nah, you can use it without /Za, just include `&lt;iso646.h&gt;`.
I don't exactly believe that the question captures the spirit of OP's post, but I see your point. I had not considered that.
The point was about what changes one would like made to the language.
level of programmer: Mathematician
I'd change basic types naming scheme to something more consistent. All those ints, longs, long longs, shorts, long long longs const const consts and etc. are ugly but people use them.
I was reading some code from a coworker today to see how he did it previously and only after couple of minutes I realized he uses "and" and "not" a lot. It's not a problem - it's readable and everything. It's just a strange feeling - "can he do this?".
I work in HPC. We have simulations that run on tens of thousands of cores for months at a time. We use extensive templating to compute adjoints of non-linear systems (adjoint is a really clever way of determining what inputs to our simulation have a big impact on the outputs). It is technically possible to write code which computes adjoints "by hand" but in practice for complex coupled simulations templating is really the only sane way of doing it. The runtime benefits and reduction in complexity of maintaining the software we get from templating is massive. Your response may be "well, then you just have to deal with slow builds". And you're right. But that doesn't mean I have to like it. The question was if I got to *change* something =) 
Get rid of implicit casting please.
If they answer higher than a 7 on a 1-10 scale, and I don't recognize the C++ books they've written, that's a red flag. The best C++ programmers I know think of themselves as a 6-7ish. The worst ones think of themselves as a 9. Good programmers who need more practice in C++ think of themselves as a 4-5.
No default/copy/assign constructors by default.
Something that would illustrate their knowledge of nullptr/nullptr_t and the obsolescence of void* I find use of NULL and void* to be a good indicator of out-of-date programming techniques.
Is there any internship opportunities available for summer 2017? 
I suppose the question would be more like "What would you change in C++ that would benefit only you, disregarding others?" since it's purely theoretical. But I agree. Programming languages are tools, and it's not possible to have a perfect tool. You can improve them, but your goal should be to make the best with the tools you currently have.
STL containers - not usable without exceptions. std::string, too. They can exhibit UB if you turn exceptions off, and their necessity is in the API design. 
It helps if you're experienced in another language as well. I'm starting to learn some c# for work and the null member access operator is awesome, you can access something with "?." instead of "." and it performs a null check first and returns null if the left operand is null. In C++ something like "?-&gt;" could be nice. My vote is still for something like modules though.
That is very true, and runtime isn't something I can generally afford. That's is the main reason we're using C++ to begin with. It would be great if we had some kind of toggle though. Build fast for development. Build slow for performance.
It can be used to instantiate templates in static libraries, as explained here: https://msdn.microsoft.com/en-us/library/by56e477%28v=vs.140%29.aspx If you're dealing with dynamic libraries, it may be necessary to have the correct implementation of a template to avoid ABI issues. This article covers the issues related to it: https://blogs.gentoo.org/mgorny/2012/08/20/the-impact-of-cxx-templates-on-library-abi/ I recall having compiler errors when using templates in code that is accessed by another dll. That's one of the reasons why it is generally recommended to avoid using non-primitive types in dll interfaces, since it can cause all sorts of problems. Imagine if you accessed a vector provided by a dll that statically links with the CRT. You'd be using your own heap to reallocate the internal array, while its memory is actually managed by the dll. That usually ends with heap corruption and a crash due to invalid heap data being accessed.
Frankly, if you're not an i/o library writer or something similar, you don't need to know this obscure implementation detail. After all, it's impossible to know everything. This is more of a curious fact that you can discuss with other devs at a drink or at a conference. I fail to see how this can be used to determine someone's knowledge of C++. Of course, you should know how streams works since that's a fundamental feature of the language.
Lol, well, I'm still in the "university student" phase of my CS career. I don't recall the textbooks or teachers mentioning that specific aspect of exceptions (though it's possible I just missed it), so I didn't even realize calling destructors and memory leaks in exceptions was a thing. But on the plus side, "how the stack unwinds when an exception is thrown" tells me what terms to search for so I can read up on it.
Honestly, for my own sanity, what I'd want most is some way of safely and efficiently writing (and referencing) libraries that doesn't involve putting the code in one file and the declarations in another file. I understand the reasoning behind 'header files', but with modern technology there's *gotta* be a more programmer-friendly way of doing that.
So, I want to build myself up as someone worth hiring during an interview, but not too much or I might come off as overconfident? You might as well ask applicants to guess a number from 1 to 10, and hire the guy who guesses closest to your arbitrary value. I'm always a 10 today, but I'll always strive to be an 11 tomorrow, and I always seem like I was a 3 yesterday.
&gt; That C++ has some really weird acronyms? SFINAE is my favorite. Mine is the CRTP.
My favorite follow-up question to this was: "You rated yourself an N. What is something that you know that a level N-1 would struggle with?" This forced them to articulate the level.
Use independent tasks. C++11 style future, async plus a decent thread pool beneath it - yes, that's a 17 proposal, but no language change needed - and you should be set for at least up to a thousand order-of-size.
You got -flto for slower production builds now? :-)
try stdint.h, from C99 / C++11. 
Why not? You should use them where possible, and you should maximize when they are possible. Don't go do your own memory management and you should be able to use what the compiler outputs every time - Rule of Zero.
+1 to that, but do keep in mind how many times an implicit cast happens. There are a *lot* of implicit casts. Heck, -1 + 40u involves a cast.
&gt; templating is really the only sane way of doing it Let's not get carried away.
You don't get too much notice unless you do things like while (on and on and on and on) ... which are legal, but silly.
"Capable candidates from the no-exception world" can and should still know the basics of exception-safety. To ignore exceptions altogether, even if you don't use them on a daily basis, is too narrow a world-view.
Honestly, I've got no idea what I could say. Things like lack of reflection, modules or unified call syntax are feature requests - they don't seem like a fit answer to the question. 
I would amend it to "No default/copy/assign constructors by default *if there are non-static data members of pointer or reference type.*" It's safe to assume that implicitly-generated copy c'tors/assignment operators for types with pointer members is a huge point-of-failure for C++, statistically speaking.
My general experience is that an employer who asks those type of questions (that question, and the whole topic, really) is only worth the entertainment you can get out of them in their horrible hiring process.
There is nothing special about jacobians that makes them only be able to be computed at compile time, and I'd your jobs are running for months at a time it seems like initializing them would be beyond trivial.
I'd hate this question. Seriously, how could I make that assessment. Only by elimination + guess. Options 1 to 5 are eliminated because nobody would rate himself as sub-average. Option 10 is eliminated because that would mean you know absolutely everything there is to know about the language. That leaves only 6-7-8-9. So yes, most people will answer 7-8. Which makes this exercise completely useless. 
Any good tips on getting started? I'm doing a hobby project in C++ with Asio (cpp-netlib) to get my feet back under me. I'd like to know more.
Well, maybe, but why run the calculator when you can start R and do simple calculations a lot more easily? (and also do not simple calculations, if so inclined) Seems like an app is designed to look just such-and-so and a program is designed to do stuff... better to run a program, I'd say.
&gt; We could live without references. Sure would make `this` annoying to use, though.
Resource Allocation Determined By Scope (RADBS) Scoped Resource Allocation (SRA) I probably could think of 10 better acronyms than RAII... who thought RAII is a good one?
&gt; , and it's nearly-useless, so nobody does that. Maybe it's just the library vendors, but it seems like I'm always seeing references to it when browsing new C++. 
"What is `partial_sort` for?" I like this question because there are a zillion answers and basically nobody knows what they are, so the more diverse answers I get, the better a window I get
&gt; I've got pretty opposite opinion. I think that headers are a bad thing - they directly break DRY rule. I think you mean that source files are a bad thing, because they include the same headers over and over. &gt; It's inconvenient to declare things twice. No, it's inconvenient to declare something and then define it separately, as with source files. It's _convenient_ to declare and define in the same place, as with header files. You seem to have this whole thing backwards. o_O
I think he means something like swapping all the left and right children so the order is reversed ... (?)
So given the obvious implementation of bidirectional iterators for such a tree, `std::reverse`..?
I couldn't care less about the details of the poorly designed and needlessly complicated iostreams library that violates Separation of Concerns.
How would you create an optimal thread-safe, lock-free singleton template class derived from a base class using lazy evaluation and memory-acquire ordering, making sure all unnecessary default methods are hidden? (Of course, I would give them access to an IDE and search; I'm not evil.) This tests the following: **Basic Level:** - Class definitions. - Public/Private methods and member variables. - Basic understanding of design patterns. - Static methods. - Object instantiation. (You would be surprised how many people put the singleton logic in the constructor.) - Public and private methods, including private constructor. - Inheritance. - Virtual destructor. - Generic programming. - Rule of 3. **Intermediate Level:** - Threading concepts. - Unique pointer. - Memory pool concepts. - Double-check locking. - Rule of 5. **Advanced Level:** - Atomic locking. - Atomic memory order. - Rule of 0. 
This is "the" wrong answer to this question. C++ and C differ more than differences in their standards. A better programmer would mention how idiomatic C++ and C are different. S/He would add how compile time checking is a thing in C++ therefore testing process will differ in C and C++. An even better programmer would mention, due C++ having compile time generics, their implementation will be vastly different and C++ would be a more complicated language; thus, new platforms would first implement C and later C++. This makes C better language for new platforms as compiler would be more approachable. See, I found three more differences in a minute: idiomatic language, testing, implementations. So, the pure syntactic difference between C and C++ is not the only difference and, when I'm hiring, I would expect my programmer to reason way more than that.
That works in a language that has a universal "null," but what would we return in C++? Let's say I have struct A { int foo() // ... }; and a `unique_ptr&lt;A&gt; a`, then what type would `a?-&gt;foo()` be? `optional&lt;int&gt;`? What if the signature of `foo` is already `optional&lt;int&gt; foo()`, or worse, an alternative `optional` implementation?
This is more of a data structures question than of a C++ question. Also, as a programmer, if you don't know the difference between a Linked List and an Array List you must probably quit your job. This is CS 101, they teach this in literally first CS classes. So, I think this is a very elementary question. You could ask the difference between A* and Dijkstra's Algorithm and have a more sensical hiring process.
I kinda just wish that C++ didn't rely upon copying a whole file into a header. I guess that would actually be the modules. Though I have to admit that it allows for some surprising flexibility. I'm not sure that I like the ocaml way of packaging it either. I think that rust uses a similar system, but I just can't bring myself to like it. It's exactly what I want at the cost of the structure I already enjoy, though I guess it's just my own fault for not learning the semantics of their interface specifications. All the other systems seem to be too high level to mesh well with the sort of thinking that I tend to do when I write some c++ code. 
This is basically a short-circuiting `std::enable_if`, with better error messages. Is there a better way to achieve this? Thoughts? (Edit: besides concepts, of course.) It's really nice to supply these messages for preemptive failures, in order to prevent those nasty compile errors occurring somewhere deep within a template instantiation. The STL would benefit greatly from something like this, IMO (compile time performance notwithstanding). Although there's not really any documentation yet, I think anyone who works with TMP will immediately recognize why this is useful. The example should suffice for now. I'd be happy to read any feedback you might have.
I disagree, I think it's a good gauge of someone's specific C++ knowledge. Knowing what it is, how to get past it, and when it's necessary to do so are all factors that give a bearing on their experience level.
I'm not sure I would want the nullity check, I would instead do away with nulls in favor of pattern matching and Optional types. Rust did this and it convinced me that no language needs null.
A fully-applied implementation can be in another translation unit. I do it all the time.
Do you by any chance mean mirror a binary tree instead of inverting?
Type erasure is still a good use case for `void*`, no?
I think that declaring it the same way as you would use it seems appropriate to me. I can see that it might not necessarily be the best thing for clarity. 
How else could it work? Once you have a pointer to the base class, at compile time there's no information available except that you're calling a public virtual function. This is exactly where you would want to use private inheritance to prevent the cast to base in the first place.
classes and templates. there's some other stuff, but that's mostly it.
I think I want standardised name mangling. If other languages could do a native call to a C++ library with the ease that we can do one to a C library, without having to worry about what compiler was used, that'd be pretty sweet.
Easier to say, that's for sure.
Yeah, and even if casts of simple arithmetic types are allowed (as long as there occurs no loss of data like double -&gt; int) those casts shouldn't be of too big a concern. But then, how hard is it to add (double) to "-1+40u"? There's also the issue that implicit double -&gt; int casts may cast pointers (correct me if I'm wrong), which could mess up pointer arithmetic and change values outside of a data structure, so sticking to explicit casts is the safest thing to do and will probably safe you a lot more typing in the future.
The question is to determine the *level* of the C++ programmer. If they don't even know what the rule of five is, that's meaningful. So is if they know what it is but have to look it up. If they can write all five without having to look it up, and can tell me the circumstances when it's necessary to define the five (as in, the compiler won't generate them automatically), then they probably know C++ pretty well. Copy/Move constructors and the equivalent assignment instructors are pretty important in modern C++, and knowing when they will be invoked and when the compiler will need you to spell them out means you have a good grasp of what's going on under the hood.
Depends on the structure of your code. If you use a lot of polymorphism, you should probably be defining a lot of move/copy constructors/assignment operators.
Thanks, this actually looks useful! Didn't know about it before.
Eh, it's pretty common parlance these days. If a programmer didn't know it by that name, but could explain all five aspects when prompted with the underlying intention of the rule, I think that counts as a passing grade.
Yes, we tried -ffast-math out a while back and the code failed tests. Had to turn it off. In some fields being 1% off isn't a big deal, for us it was.
Yea. It's been about 10 years ago since we played with it. My memory is exactly the same as yours. Great for things like games/rendering where precision can be slightly off. Horrible for scientific modeling.
Good answer. That a job candidate even knows what template metaprogramming is is already a very good sign. Some answers I've gotten over the years (some good, some not so good): * Templates: Too complicated; generated code also gets bloated. * Virtual functions: Too slow. * Private data members: Too constraining. * Exceptions: Too hard to reason about program flow. * Virtual inheritance: Too confusing and error-prone. * Namespaces: Annoying to type and to read. * `const` anything: Not worth the trouble.
Honestly, I'd just ask someone to write a simple for-loop.
Exceptions is a good one. I'd expect candidates to understand good exception safety, but if they can provide an argument for deliberately avoiding exception (over)use in our own code then that's excellent.
Gimme a couple days and I'll put together a solution. I'm knee deep procrastinating coding something else at the moment. Edit: It's not fair to leave you hanging-- I would use std::atomic::compare_exchange_weak in a loop to check a flag that represents the status of the instantiation.
So, have you used `&lt;algorithm&gt;` or `&lt;vector&gt;`? Because there's TMP going on in there.
And on that note, let shenanigans ensue :P
I think we should have nulls, but its usage should be discouraged. EDIT: made null plural 'cus english
is some shenanigans the technical term, lol.
What can you tell me about nodes. 
or maybe: "if you could have a language that is exactly identical bar one change what would that change be"
Man, fuck pointers. Such a pain in the ass when you first start out. 
inception
u/bluelinebrewing just got destroyed.
Wow meta-programming!
I sucked with templates until I learned Haskell.
Some compilers have already deprecated digraphs and trigraphs though (C++17 is meant to deprecate them).
These are one of the *least* used features, certainly not one of the most used.
I'm with you, it's about dynamic store heap. vector::at (or array) are a small ones, one can easily avoid them "manally". But heap is a **huge** one, if used (my work does it, cross platform, two Unix flavors and Win). In embedded, you're right, it is less of an issue. One can turn exceptions on for a selected set of translation units, that allows to initialize containers properly, turn them off elsewhere, and make sure not to touch heap from there (one can make sure of that by making operator new etc unavailable there).
&gt;I think you mean that source files are a bad thing, because they include the same headers over and over. Nope, because you need source files, in one shape or another. What is wrong is existence of headers as an idiomatic system to 'export' stuff out of the source files. &gt;No, it's inconvenient to declare something and then define it separately, as with source files. It's convenient to declare and define in the same place, as with header files. Of course I meant that. But if it's in the same place, you need only an definition, because it already is declaration...
If you write code that creates memory make sure you write code that gets rid of it?
I would ask the person to show me projects they made for fun.
thought so, thanks. So for if(!std::cin.get()=='\n') means it red the first character and throuwn it away?
another thing is ??
the madness that is rvalue, xvalue and lengths to which developer must go to ensure copy elision. most other languages already move reference innately. async await and task may be another.
Like dynamic executable bundling shared objects. Thanks to ingenious way unix operating systems are set up doing this is much easier on windows. Funny eh? Before you ask why - if i bundle 3 applications that make use of opnessl i would rather bundle openssl once instead of linking it in every executable.
The idea is good, but the cornercases are ugly. Much like TMP itself, actually.
Operator overloads. Nontrivial operations must have nontrivial representation. There's usually a restricted context in which they are unambiguous (basically dealing with vector/SIMD data) and the way you need to implement them is a bit iffy (member func vs `friend` etc). Plus, grepping for them is a lot of fun and IDE integration was still years behind last time I checked. I just never managed to get me to like them. I use them very rarely.
What about Java, which gives you [ArrayList](https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html)? It's a list! And a vector! But not a [Vector](https://docs.oracle.com/javase/7/docs/api/java/util/Vector.html)! /r I've seen a dude graduating with 99% rates (no idea how they are in your country) and being unable to distinguish an USB1.x from a serial. Because hardware is irrelevant. Ugh.
"What's the description of some projects you used C++ for?"
At the end of the day, memory addresses are real and someone has to work with pointers so the rest of us can use references. C++ lets you do both. This is not a bad feature.
I really like CopperSpice project, but when I see at the compile times... Fast compile times are very compelling to me in particular. I cannot wait for C++ modules. Are there any plans to speed-up compile times? I think they are really important, maybe more than run-time speed, since they do not seem to be an issue in Qt. Also makes the binaries bigger I think? I am not sure I fully understood: the cause of this is templates? I am not a heavy user of CopperSpice at the moment, so you should not take me too seriously :D. But... who knows, maybe some day, because I cannot stand the moc easily. 
BTW, are you planning to upload the slides for C++ Now 2016? I would like to take a look into them if that is possible.
Not all programmers go through cs 101.
It's not usually good practice to have a lot of runtime polymorphism...
It looks like you have not dealt with computational/algorithmic/automatic differentiation yet. Look it up, try it yourself, and then realize why templates are a perfect fit for this stuff. Some approaches also utilize a kind of preprocessor, but that method has its own issues. Reality shows that most time operator overloading for templated types is the easiest and sometimes even most efficient method for dealing with our beloved derivatives, especially in legacy applications we want to augment. For newly written code I readily agree that you are able to cook up a scheme that allows for easier computations. But existing code will almost always benefit most from templates in a reasonable amount of time.
How do you allocate space for the type as a member? Is it always a pointer to a separate heap allocation? Does it sneakily append space for its hidden members, and just not expose them? To be honest, modules will probably give you what you actually want here, in a much more reasonable way...
Is it the creation that needs to be guaranteed thread safe, or the instance itself? Because I don't really see how "template" fits in unless it's a template container for a singleton holding a factory-allocated instance of a class with specific polymorphic type determined on first use. Which doesn't really point to any need for hand-rolling memory ordered atomics; std::call_once on the factory wrapper would be sufficient. If the instance needs to be thread safe (this is rarely a good design choice) then you'll need to be more specific about what it is an instance of...
So... modules.
&gt; Array List C++ people don't think in these terms, do they? Are you some Java-ist?
I know that. But I feel like this makes whole 'rate yourself on a 1-10 scale' question completely useless. If Scott Meyers is 5, then what is average C++ developer? 2? But 2, on a scale 1-10, sounds like you're just completely clueless about the language. And, as you said, impostor syndrome. Are there people knowing C++ better than Bjarne? Probably, yes. How many, through? Maybe 10, maybe 100 language lawyers. So, if best people can rate themselves as 8/10, what's the point of 9 and 10? And IMHO people like Bjarne and Scott are just trying to be humble, and emphase the point that even they don't know *every detail* of the language. It's not really about impostor syndrome. And Dunning-Kruger effect makes it only worse. Even if I know about it, I can't know on which side I'm. Using system like 'if I feel I'm good, I'm bad and vice versa' is just stupid. And these self-evaluation scores can change very frequently, usually drastically. Sometimes I feel confident in C++, sometimes I feel like I'm about to drown in the complexity of the language. That's why I think asking people to evaluate themselves is pointless. You have to evaluate them yourself. I think I'd rate myself 7 or something like that. But, the problem is, I'd do the same in the past too. When I didn't know templates, for example(I mean defining them, not using templated classes/functions). Or smart pointers. So I likely should to rate myself 4, or something like that. Because in a few years I will look at now and see that "I really didn't know anything". But I don't feel like my knowledge about C++ is 4/10. Hmm... I will answer these questions and you'll tell me what would you think about me if it were an interview, okay? &gt;"what does std::move actually do?" It casts given argument to an rvalue reference of it's type. So in "Object o; std::move&lt;o&gt;;" std::move returns Object&amp;&amp;. &gt;"explain the relationship between rvalue, lvalue, prvalue, ~~rvalue~~ xvalue, and glvalue" It's mostly about what can be moved, and what can be addressed. Rvalue can be moved. Glvalue can be addressed. Prvalue is an rvalue, and additionally it can't be addressed. Lvalue is glvalue, and it can't be moved. Xvalue means expiring object, at the end of it's lifetime. It's both glvalue and rvalue - it can be moved and does have an address. &gt;"what is the impact of capturing a temporary by rvalue reference? by lvalue const reference?" \#1: Dangling reference. \#2: Valid reference, it will prolong temporary's lifetime. Okay, I've checked if it's roughly right on the internet now. I don't know where did an idea that I can't bind temporary to an rvalue reference came from.
No no. I just used array list as a name to concrete data structure that std::vector uses. You can argue standard merely defines the definition but not implementation but this is not valid since the only list implementation with O(1) access, linear space etc is array list (however you want to name it).
What does this even mean?
Yeah, I take issue with the term "array list". The word is simply "array". :-)
&gt; If I could have one thing it would be better language constructs to handle very large levels of parallelism. The recent additions with futures has been a start. But in my line of work (computational science) we're starring down a very scary road where computers have hundreds of cores. C++ doesn't really have a great answer to simply describing how to exploit that level of parallelism. Same line of work here. Co-array Fortran is a marvelous thing. There's so many aspects of modern Fortran I'd like to have in C++ (or vice versa) in HPC. 
Any link to the more technical talk he refers to in the first couple of seconds if it happened to be recorded too? My time machine is acting up today...
It's very hard to write "never empty" objects in C++. You almost always want objects to be at least move constructible so they can be returned from a function, and just generally passed between scopes. But this brings up the question: when I move the object, what state is the left behind object in? This causes all kinds of correctness and performance issues. Thus, most C++ objects generally have to have some kind of empty state built in. For containers this is pretty natural, but consider e.g. an object that represents a file. What is the point of that object having a "no file" state? But that's exactly what ifstream has (for example). Some kind of destructive move could perhaps fix things, but it's honestly not clear. In general using the moved-from object can only come up in practice if you explicitly apply std::move, so maybe getting static analyzer that consistently warn about user after move will be good enough.
How is this not a lock? It's a spin lock. Typically mutex implementations will actually briefly spin lock first, and then put the thread to sleep so it stops wasting resources if it can't get the lock quickly. So you may as well just use a mutex. Lock free means using neither mutexes nor spinlocks. A lock free single producer/consumer queue uses neither of these, in fact the only tool that it needs beyond typical single-threaded code is a couple of memory fences to prevent instruction reordering.