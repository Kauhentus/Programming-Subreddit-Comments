Thank you for explaining this in such clear and useable ways. I can already imagine where I‚Äôll apply concepts in my codebase now.
some answers (courtesy of Volker Krause, author of the blog post) : - no, the GPL version does not have QtC integration - debug builds are only needed for very few features, such as the object creation or paint operation stack trace, and the corresponding "navigate to source" feature - everything shown in the release annoucement also works with release builds
[Here](https://www.linkedin.com/feed/update/urn:li:activity:6553959068640260096) are the slides from the presentation.
Yeah, later in the series I plan to have that as a class when teaching about RAII (alongside a custom smart pointer implementation)
If you flush the buffer using std::endl, otherwise the difference between std::cout and fprintf is fractional.
I strongly disagree from experience.
In that case it flushes twice instead of once ‚Äì while the second flush must certainly be cheaper, I very much doubt it's free.
I still doubt that that is what the question is about. Much more likely is that try_read means: "Give me the data if it is available and return false otherwise", whereas read means: "Block until the data is available", but of course only the OP can really tell.
How is `endl` flushing twice ?
`std::endl` is shorthand for `'\n' &lt;&lt; std::flush`, so if `\n` is flushing then `endl` must necessarily be flushing twice.
The standard does not imply `std::endl` to be implemented that way. It must print a newline and flush. If the implementation does already that when printing `\n`, then the implementation may as well just print `\n` when `std::endl` is used. From cppreference: &gt; In many implementations, standard output is line-buffered, and writing '\n' causes a flush anyway, unless std::ios::sync_with_stdio(false) was executed. In those situations, unnecessary endl only degrades the performance of file output, not standard output. So it does not degrade performance for the case I am talking about.
I used to use rtags and back then it was not LSP based. However, it worked really well with emacs. I moved to clangd now though. The only problem with clangd is you need to be on really recent clang. Other than that, it has worked well for me.
I think the problem with clangd is that it moves really fast. Not sure what version you used, but I recommend latest to give it a fair go. clangd 7 was very unstable.
&gt; The problem what I see here is that the API design is bad for generic programming. No it isn't. Your API is worse for generic programming. With the API in the standard a function template that only needs to use `lock()` and/or `try_lock()` can work with any type meeting the _Lockable_ requirements. A function template needing to use `try_lock_for(duration)` needs a type meeting the _TimedLockable_ requirements. Some mutex types only meet the _Lockable_ requirements and not the _TimedLockable_ requirements. With your API all mutexes have to support timeouts, and function templates cannot specify their requirements in terms of the simpler _Lockable_ concept.
Hi, thanks for your hard work and for a great tool. Can clangd perform project wide renames? This is one feature from rtags I used a lot.
&gt; The standard does not imply `std::endl` to be implemented that way. It must print a newline and flush. That is exactly the point I was making without being pedantic about the details, so we're in agreement. &gt; If the implementation does already that when printing `\n`, then the implementation may as well just print `\n` when `std::endl` is used. `std::endl` operates on a `std::basic_ostream&lt;CharT, Traits&gt;&amp;`; it has no awareness of nor special treatment for `cout`, nor does `endl` necessarily know/control what buffering might be taking place at the C-runtime or shell or OS levels. What you say is nice in theory but I'm not aware of any implementation that doesn't flush twice here. (If you do I'd be very curious to know!) &gt; So it does not degrade performance for the case I am talking about. AFAICT, the case you are talking about is purely hypothetical; in practice, it does. ;-]
Ah, actually, a feature that I \*really\* would love to have is unused includes. Please see this thread, where [anastasiak2512](https://www.reddit.com/user/anastasiak2512/) discusses it in the context of CLion: [https://www.reddit.com/r/cpp/comments/c5vnhw/clion\_20192\_eap\_brings\_experimental\_lldbbased/](https://www.reddit.com/r/cpp/comments/c5vnhw/clion_20192_eap_brings_experimental_lldbbased/)
because of checking if the result is nil or not, every time you get the result, most of the time i want to propagate error the error automatically ,had there been a nice clean way to execute next statement if there is no error and propagate it upward to call stack if there is error, then handling would have been much better. Plus there is std:::expected proposal to with monadic interface (its also proposed for std::optional) its interface is similar to Promises in js (just interface nothing else) . These are just my thoughts tho, and no denying go is great language with some cool abstractions like goroutines. but its error handling is something i think can be improved, Anyways i am just curious are you planning to integrate this lib in your daily code or you just wrote it for experimentation purposes ? :)
Any presentation o Docs for the low band reader ?
FYI `std::format` is coming soon, which introduces a printf-style but type-safe string formatter for C++ - after that most of the nonsense with streams and formatting can be dropped. Added bonus - it's considerably faster than sprintf.
clangd is kinda unusable when working on a cross-compiled project. The usual compile\_commands.json created with bear/cmake for cross-compilation will have a `&lt;target&gt;-&lt;vendor&gt;-&lt;system&gt;` triple. Clang can probably inherit `--target` from the binary name (e.g, `aarch64-unknown-linux-g++` \-&gt; `clang++ --target=aarch64-unknown-linux`) but clangd still needs `--gcc-toolchain` flag to find the standard C++ library. How can I add it? With ccls I can add .ccls file with the flags that I need to append. &amp;#x200B; Another thing, how to blacklist some flags like `-fstack-usage` or `-fconserve-stack` which are used in projects like linux kernel or uboot?
Yes sorry about that. Just giving further references. No I have not used FastBuild. My reccomendation would be to first identify your current bottlenecks, fix low hanging fruit and otherwise best practices (IWYU etc), and then think about what use cases you need to improve (CI? Incremental builds? Frequent branch or configuration switching?). Certain tools and techniques are only suitable for specific use cases. E.g. unity builds can accellerate some clean builds, but usually makes for worse parallelization (e.g. multi-core builds and distributed compilation) and worse incremental build times. When reasoning about these thimgs I fimd that it helps to set absolute goals, like: "Full rebuild in CI should be less than 2 minutes in 90% of the build jobs". That way you can start to attack things like build parallelism, hardware requirements etc. Lastly, there is no fix-all solution for C++, because every code base is unique. You can find tools that make the situation better, but to meet your goals you need to solve many different problems (tools, code structure, hardware, etc).
About assimp and hunter... Amazing guy [rbsheth](https://github.com/rbsheth) fixed everything 8 days ago [https://github.com/ruslo/hunter/pull/1909](https://github.com/ruslo/hunter/pull/1909)
[Previous discussion](https://www.reddit.com/r/cpp/comments/6xeqr3/compiler_undefined_behavior_calls_nevercalled/?st=jxvuo5vi&amp;sh=16028a32).
Please learn how to use markdown formatting (and _always_ preview before posting). Also, as per the sidebar: &gt; For C++ questions, answers, help, and advice see r/cpp_questions or StackOverflow. That being said, you probably just need to use `memcpy`.
&gt;FYI `std::format` is coming soon, which introduces a printf-style but type-safe string formatter for C++ - after that most of the nonsense with streams and formatting can be dropped. Yeah right, because everybody will just drop decades of code because of `std::format`‚Ä¶ We to this day can't even deprecated `std::vector&lt;bool&gt;` ffs!
I've encountered very little code that's actually used stream formatting - 99% fall back on wrappers of sprintf if they need to format things...
That's the thing with anecdotal evidence, I haven't encountered sprintf/‚Ä¶ in our production code in a long time. All the code I work with is heavily based on streams...
This is a future live event scheduled in 2 days. Why did you post it today instead of on July 11th. What possible discussion could you hope for on content that isn't consumable yet?
By that do you mean they are strong types, or that they have a namespace?
Thx for the notice! Will bring popcorn üçøü•§
To my knowledge, R0 never allowed user-defined comparisons because the paper rose from the idea that the defaulted spaceship gives us a way to do this safely. The paper did, however, make an incorrect-for-some-enums assertion about the current state of affairs and aimed to preserve that assertion into the future, and that seems to be the focus of this article's author. As for the second example, I did see it pointed out that the author founded this point on the false premise that the code is valid.
You can't pass them to a function taking e.g. an int as a parameter and you can't pass an int to a function that expects an `MyEnum` parameter.
Ok so they‚Äôre strong types. That‚Äôs actually pretty important, yeah.
Facebook is really pushing hard for this
I very, very much doubt that virtual function calls are in any way the limiting factor when writing to the console. A typical OS-call will have many times the overhead of a virtual function call.
I had that feeling to, but never benchmarked it. Did you? On which OS? To the console or to a file?
Don‚Äôt forget things like sprintf that have no OS involvement at all. Virtual function overhead is actually the primary difference in such cases.
And yet another nice piece of work, where the only concern of the cpp community is the use of iostreams. I find that quite sad .
Thanks for being nice :) I'm happy with the community's criticism, it will help me improve my next tutorial.
I wouldn't say so. LSP servers are just becoming more and more useful. Having a text editor that can provide semantically aware completion, navigation, refactoring, etc, is useful. Turns out, that's a hard problem to solve for a lot of languages, especially C++. LSP servers make those features much easier for text editors to implement.
I mean, knowing it's going to happen is interesting. But not mentioning it's a future event in the title is infuriating.
The cpptools extension still wants to fight clangd a lot it seems. I keep trying to turn off cpptools intellisense entirely and somehow failing. It constantly gives me false red squigglies that go away once I compile.
How is boost::fiber different than boost::asio::strand?
I have uninstalled cpptools and have only clangd extension installed for C++ language and it seems to provide all functionalities. Do you need cpptools for any particular reason?
"Learning the source code of LLVM optimizers will help you write your optimizations, allowing you to improve the code for some specific cases." As if I don't have enough to do already.
Which is why I explicitly talked about writing to the console. But even that aside: Have you actually measured the overhead of virtual function calls? Personally I'd actually doubt that the virtual function calls are the main reason for any performance difference, even if you do only formatting. E.g. std::stringstream just does a lot more stuff than sprintf (not saying that it should do it).
warning: may not be the best use of time. ymmv. this advice is given without even the implication of warranty
In addition to the `split_at_mut` example below, you can also borrow elements of the same array or slice using patterns: let mut array = [0, 1]; let [first, second] = &amp;mut array; *first += 1; *second += 1; assert_eq!(array, [1, 2]); My question about borrowing multiple elements of a slice "the easy way" is, when do we expect it work? Should it only work when the indexes you're borrowing are constants? (If so, it might not be very useful.) Is the compiler expected to do constant propagation to determine whether your code works? If so, would that mean a future version of the compiler with a different optimizer might fail to compile code that used to compile before?
yeah i thought the whole point of "trust the compiler" was not making you have to worry about this shit
I'm assuming you have seen this but if not, it might be a cool bit of info towards your goal: [Noria is a pure Rust high performance database](https://github.com/mit-pdos/noria). Has some unique design concepts not really possible without Rust's borrow checker. [Here's a good talk on it's design if you want more info](https://www.youtube.com/watch?v=s19G6n0UjsM).
Note to anyone going to read that a lot of the comments are pretty toxic. A lot of strong feelings around optimization of UB.
Are there any \*working\* instructions on how to get this to run on Windows? It seems like a very useful tool but all I can get out of it is failures to connect, errors about probes not being found (whatever that means), hanging application, etc. I've followed the instructions on the Qt side and also on your own site, but nothing seems to work.
What about https://cde.stensal.com/a/SNZTJBj8rgYgUiXE And why You are running Vue in development mode. Make sure to turn on production mode when deploying for production.
I have no problem within the criticism. I have a problem with what the criticism focuses on.
The memory you tried to allocate is too large. Its execution was terminated. I may add a better error message. Try a smaller size. &amp;#x200B; Thank you. I will remove vue, it is actually not used much.
&gt; Though it would be useful to have some means to say, I want the freaking vector to be immutable, period, which would cause the second statement to fail. Rust can do this through a library solution using privacy, for an example see https://users.rust-lang.org/t/immutable-frozen-t-type/23868. However, I've never found the need for it.
Just looking at the source, one of the first things that jumps out is that not a single class follows the Rule of Three, much less the more-modern Rule of Five.
We've been using Optix in our CAD system for a while, it works just fine on budget GPUs. Though the only real advantage over regular opengl is order independent transparency.
I believe what you're looking for is CodeLens, which unfortunately is only partially available in 2019 Community (primarily excluding blame) and totally absent in earlier Community versions.
Well, mathematically, fractions only have weak equality, and to match intuition, template parameters must have strong equality. It's possible to have your "transformation" under the rules of P0732. Just have two classes, one for representing the "canonical form" (has strong structural equality), the other for representing the untransformed value (need not have strong equality). Then the "transformation" is simply the conversion from the latter to the former. This does not require any more mechanism than already existing in the language.
Which should serve as yet another warning signal that the current state of UB - and compiler writers interpretation of it - is simply not workable.
Give us the slides Eric
You are right. Thank you!
How else are people who would wish to watch it live going to know about it in advance? Anyway, it's only natural that a post regarding async would be a `future&lt;event&gt;`.
Haha. Touch√©.
I checked it before, it looked tailored to C# and the annotations seemed quite a bit different at a glance (one per function?). We're using 2017 Professional, is it supposed to work there?
This isn't a C++ question.
Look forward to checking this out.
What does "LaTeX-like" mean?
If you want and kind of actual discussion, consider formatting your post properly...
Titles can't be edited, but I've added link flair.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/caxx1o/another_libuv_singleheader_wrapper_call_for/etdo0gb/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
There is a file in the root of the repo called "INSTALL.txt", or something similar. It contains instructions to build it in all supported platforms. I can guarantee the Windows an OSX instructions work correctly. This tool has made developing ui in Qt crazy easy. My whole team relies on it daily, it has crashes every now an then but overall it is a great tool.
They want to get into your keyboard through your source code.
You can include other source files using @input(*path-to-file*) which makes setting up templates easy, I kinda enjoy making websites with it and webdev used to bore the crap out of me. Feels more like normal programming again. You can also use mathjax for displaying LaTeX equations as shown on the displaying mathematics page in the docs.
Would love to know how you go and what you think.. If you give up with frustration anywhere would love to know where and why too..
&gt; strand fibers are synchronous execution contexts within a single thread that can interleave asynchronously. They can be used without any event loop. For example, [GAIA](https://github.com/romange/gaia/) provides [fiber friendly file](https://github.com/romange/gaia/blob/master/file/fiber_file.h) that does not involve any ASIO elements. strand - serializes execution of callbacks in ASIO loop between multiple threads. You do not need strand if you use a single thread. Also the coding is different. With fibers I write code: fibers::fiber fb([] { int my_state; do_io1(&amp;my_state); // does not block the thread but blocks this fiber do_io2(&amp;my_state);}); // does not start before do_io1 finishes with ASIO: int* my_state = new int; strand.post(boost::bind(&amp;do_io1, my_state)); strand.post(boost::bind(&amp;do_io2, my_state)); strand.post(boost::bind(&amp;delete_my_state, my_state)); The first approach looks like our hello world application: simple, readable. the callback based approach is doable but hard to reason about.
Except new is implemented via malloc, so it's still C on the lowest layer. I think the C++ vs C thing should be thought of like safe vs unsafe rust. All the same language, but you use C only when necessary.
\&gt; I still use ccls because when I open a .h/.hpp file, it immediately prioritizes indexing the .cpp file with the same name Oh, neat! That sounds very doable. We're just turning on background indexing for the 9 release, I'll try to sneak that in. Filed [https://github.com/clangd/clangd/issues/78](https://github.com/clangd/clangd/issues/78)
Glad it's useful! So far the rename has just been one file, but we're getting the pieces into place. (The biggest one being background indexing on by default). The v9 release will still be single-file only, but should accurately detect when that makes it impossible to safely rename. We'll work on cross-file rename for v10. It's easy if the index is completely up to date, the question is what to do if it isn't (references might be missing, or point to other text). Doing a full parse of every potentially-affected file would be \*really\* slow. Do you have any idea how RTags recovered from these situations?
We've talked a **lot** about this feature, and I really want it. Like so many things in C++, there's at least some ambiguity in what "unused" means, and plenty of difficulty in getting all the edge cases right. I suspect the trick is working out how to be useful and not annoying, **without** having to be right in all cases. /u/anastasiak2512 I understand the obstacles to upstreaming, if you feel like sharing any experiences about the design or implementation, that'd still be really useful. I opened https://github.com/clangd/clangd/issues/79.
I'm not so familiar with driver/cross-compilation topics myself, I'm going to point a colleague at this post and hopefully get a more informed response. It'd be nice if more of these cases would work out-of-the-box. We've talked about various ways of transforming flags before. Maybe time to stop bikeshedding and add something. Some well-known but unsupported flags like `-fstack-usage` could probably just always be blacklisted. Please add any more examples you run into to https://github.com/clangd/clangd/issues/80
The compiler doesn't emit the information we need. There are a couple of efforts that could make it do so: - modules: in a modules-enabled build, the compiler is going to end up populating a modules cache. We might be able to index from that. Unfortunately, hardly anyone's using a modules based build today. - Index-While-Build: this is a dedicated effort to have clang emit the information needed to build an index. Unfortunately I think both of these require clangd to be (close to) version-locked with the host compiler (which has to be clang!) to read its data files. (IWB format may become stable over time. Modules probably won't). This version-locking to be present on Mac (XCode comes with a toolchain, a matching version of clangd, etc) but so much on other platforms (host compiler may well be some old GCC). Not-coincidentally, Apple is pushing full-steam-ahead on index-while-build, and we haven't really prioritized this in clangd yet.
please don't post clickbait not-videos. Post something saying "here's a link to this talk that happens on july 11"
posts can be deleted, though.
Looking forward to this! I sincerely hope the C++ async story improves.
This sounds interesting. However, while C-Reduce is valuable for reducing regression test burden, it may be of interest to retain the original unreduced test code for documentation purpose in case the original triggering cases are forgotten given that storage is getting cheaper.
Most compilers give you the ability to turn off the weird optimizers. The problem is all of them provide performance benefits in most cases since that is why they were written. This example can provide more performant initialization than the standard allows for as an example. Heck in normal code this might "fix" a race condition by ensuring your only initialization function is called first.
**Company:** [Loki](https://loki.network/) **Type:** Full time **Description:** Loki is an open source, fully funded project aiming to develop a censorship resistant stake based onion routing network. We are looking for a Mid level C++ developer who is interested in working on building onion routing networks. Anyone who applies for this role should be highly confident in the fundamentals of decentralized networks and anonymous network design. You will be working on [Lokinet](https://github.com/loki-project/loki-network) which is a large open source codebase. Over the course of your employment you will be expected to frequently contribute to design discussions as Lokinet is run by a small team. Particular proficiency in any of the following areas is desirable, but not a requirement: ‚Ä¢ Strong Mathematical or Computer Science background ‚Ä¢ Large project experience (especially in architecture) ‚Ä¢ Experience with Distributed Networks/Networking ‚Ä¢ High level of working C++ experience (5+ years) ‚Ä¢ Interest in Onion routing networks ‚Ä¢ Open Source Projects/git **Location:** Our Physical offices are in Melbourne, Australia. **Remote:** Yes, remote work is preferable, for this role you will need to work inside the normal hours of ET (Eastern Time) **Visa Sponsorship:** Yes, for the right candidate **Technologies:** For the part of the code you will be working on we use C++14, although in about 2 weeks we're moving to C++17, You can use Windows, Linux or Mac, Although Linux environments will likely be easier to develop on, a Working knowledge of C would be useful. **Contact:** PM me on Reddit
&gt; c++ style of thinking There is no such a thing, is just some people who confine themselves inside a box. At most you could say the syntax favors certain paradigms and makes harder or fugly to code following other paradims.
So should we start with quantum mechanics? After all, that's what you need to understand transistors. I really understood the elegance of qsort only after learning about p-n-junction depletion lengths! Or do we accept that we just don't need that? For your example: what do we gain introdicung someone to `malloc` when we honestly never expect them to use it? Or, more to the point: expect them to never use it. The distinction of raw memory allocation and construction becomes relevant only when you go to the finer details of POD types and placement new. And how often do we need that?
That sounds quite impressive and useful. I'd love to try it out, but without some minimal documentation and some tutorials that seems very difficult and probably a waste of time)
By doing it in C++ directly you get independent from the build system. In my experience this is preferrable. Same for __has_include vs build system detection.
&gt; all I/O in C++ is performed using streams I cannot even begin to explain how wrong that is
Unless I missed them you seem to be missing unit tests. Also your CSV reader will fall over on real data. You should read up on modern cmake e.g. don't use include directories. you say C++11 minimum but your cmake sets c++17 required
So, will this be usable in debug mode? Can I stop my code somewhere in the middle of it and use this interpreter to execute commands on existing variables? (I mean, during runtime, initiated const variables that are constexpr-able should be constexpr as far as an interpreter is concerned, no?)
The codebase in this world is mostly pre-C++11 Newer projects usually choose Java, that includes Finance btw.
Not really anymore. In finance, most coding is done in Java which is currently getting as fast as C++ code. A lot of projects in finance are moving old C++ code to Java.
It's not proper async though, it only allows you to perform requests in batches
Honestly that says more about glibc than static linking in general. With musl the statically and dynamically linked executables are of the same size.
I didn't any examples too
Bare minimum documentation is available at [https://github.com/sumeetchhetri/ffead-cpp/wiki](https://github.com/sumeetchhetri/ffead-cpp/wiki) and sample applications are present at [https://github.com/sumeetchhetri/ffead-cpp/tree/master/web](https://github.com/sumeetchhetri/ffead-cpp/tree/master/web). I do agree on the documentation part though, I have been really poor at it all this time.
Sample applications are located at [https://github.com/sumeetchhetri/ffead-cpp/tree/master/web](https://github.com/sumeetchhetri/ffead-cpp/tree/master/web)
Updated the c++17 requirement, thanks for highlighting the issue with the CSV reader, will fix it soon.
https://en.m.wikipedia.org/wiki/Learned_helplessness
I think this can't happen in Rust: * statics must be initialized, * function types can't be null (you'd need to wrap them into an `Option&lt;Function&gt;`), essentially, either the compiler optimizes the body of `main` away completely, which is what it would do in the case closest to this example, or only a function that the user has set into the static gets called.
Can you talk about the performance as represented by the TechEmpower framework benchmarks? https://www.techempower.com/benchmarks/#section=data-r18&amp;hw=ph&amp;test=fortune&amp;l=ziimf3-f
What's he advantage over shared\_ptr? What are possible use cases where it's better?
Interesting, looking forward to the next post.
Sorry, I didn"t see the other wikipages on my mobille - that might already be enough to get started. Thank you.
Its a great talk on writing code for real hardware, but I expected more about the actual C++ memory model. From the title I though that the talk would go through the C++ standard and explain all the ordering operations.
\&gt; What's he advantage over shared\_ptr? That shared\_value doesn't allocate on the heap \&gt; What are possible use cases where it's better? \_Assuming\_ moving of the value is a lot faster than allocating on the heap, creating shared\_value should be faster than creating a shared\_ptr. My assumption may be wrong though, I'm happy to be convinced otherwise.
Updated URL: https://blog.regehr.org/archives/1678
If you can try to use a library for CSV reading. There loads of edge cases that can be missed if you try to implement it yourself.
But not allocating on the heap will make moves usually as expensive as copies, or did i misunderstood something?
Don't you need to allocte the list nodes, though? Or is the intention that all `shared_value&lt;T&gt;` instances are located on the stack? In the latter case, I'm not sure I understand how this is intended to be used, maybe it would be helpful to add a small usage example to your reference implementation?
This will make moving/copying shared_values themselves an expensive operation, not to mention preserving thread safety guarantees of shared_ptr practically impossible. All this, plus the fact you will need significantly more space makes the whole thing not worth saving one (or two) allocations IMO.
\&gt; But not allocating on the heap will make moves usually as expensive as copies Not necessarily, e.g. if we have \`shared\_value&lt;std::vector&lt;char&gt;&gt;\` then moving the vector around will only move the internal pointer to the data of the vector (i.e. it will not create copies of the vector nor its data).
\&gt; Don't you need to allocte the list nodes, though? No \&gt; Or is the intention that all shared\_value&lt;T&gt; instances are located on the stack? &amp;#x200B; Yes, this is correct, they are kind similar to the Boost.Intrusive list. \&gt; In the latter case, I'm not sure I understand how this is intended to be used, maybe it would be helpful to add a small usage example to your reference implementation? I'll try to come up with a better example, but in the mean time, would you say the example in the original post isn't clear?
&gt; would you say the example in the original post isn't clear? Yes, I would say so, since the problem and the solution there seem to be hidden relatively deep inside the implementation details of `boost::asio`.
\&gt; This will make moving/copying shared\_values themselves an expensive operation I don't really see why? IMO copying e.g. shared\_value&lt;std::vector&lt;char&gt;&gt; is about as fast as moving std::vector&lt;char&gt; (which in turn is about as fast as copying one size\_t and one char\* variables). \&gt; not to mention preserving thread safety guarantees of shared\_ptr practically impossible. Right, this is really just a sketch and I haven't though about thread safety yet, though jumping to the conclusion that it will be impossible seems too quick. Again, I'm happy to be corrected. \&gt; you will need significantly more space Again, if you take the example shared\_value&lt;std::vector&lt;char&gt;&gt; then I don't see the \*significant\* increase in space. Of course, if sizeof(T) is huge, then you're right, but one has to weight all pros and cons like with any other structure (IMO).
Then again, if we're ignoring the internal buffer, *allocating* space for the vector itself is also just a matter of adjusting one pointer in the malloc implementation (i.e. the end of the 24-byte bin), so it's not even necessarily cheaper than the move assignment operator ;)
OT but why are you escaping the formatting?
I'm not a frequent reddit poster, thus not really sure what I'm doing with the formatting :D
Are you using new Reddit? If so, turn off the fancy pants editor and use the markdown editor. Your formatting will work then.
Not sure I understand. Are you saying that doing ``` auto foo = std::make_shared&lt;std::vector&lt;char&gt;&gt;(); ``` is cheaper than doing: ``` std::vector&lt;char&gt; foo(); std::vector&lt;char&gt; bar(move(foo)); ``` ?
https://lmgtfy.com/?q=see+if+file+exists+c%2B%2B https://lmgtfy.com/?q=sqlite+c%2B%2B https://lmgtfy.com/?q=create+file+C%2B%2B
Hm, I do try to switch to markdown, but sometimes I forget. Is there a settings to make markdown the default?
Yes, there is something in your personal settings. But sometimes it goes back on its own.
I'll look into it, thanks
I'm not really sold on the performance benefits being significant. And what I'm _definitely_ not sold on is them being significant enough to warrant turning such unsafe optimizations (escalating "simple" bugs to potentially order of magnitude worse ones) on by default. That kind of points to the root of the problem: We have a bunch of behavior that depends on things that aren't actually listed in any or two places (you basically have to read the whole standard to find all cases of UB), is potentially very dangerous (turning f.ex. segmentation fault DOS into privilege escalation), cannot be disabled by any single compiler switch and is _enabled by default_. I'd be all for allowing any optimizations based on UB as long as 1) the behaviors were clearly listed, 2) they could always be turned off by a single switch ("-fno-unsafe-opts") and 3) such optimizations were never on by default with any of the normal -O switches. So, rather like the current -ffast-math. Which incidentally also has never produced measurable speedup in my 15+ years of writing computationally intensive floating point code. But at least that is not on by default.
I'll look into it, thanks
I think it's a compiler bug. &gt;in accordance with the C standard, all global variables have zero values when a program starts The rest is a lengthy description of how some optimization is bugging out. AFAIK, according to standard, that pointer should have been initialized with zero, if it's not, then it was compiled with substandard compiler. LLVM is very cool technology, but contradictory to common belief, clang has a long way to go.
it's duplicate [https://www.reddit.com/r/cpp/comments/cbgtou/resharper\_c\_blog\_better\_ways\_to\_test\_with\_doctest/](https://www.reddit.com/r/cpp/comments/cbgtou/resharper_c_blog_better_ways_to_test_with_doctest/)
\&gt;IMO copying e.g. shared\_value&lt;std::vector&lt;char&gt;&gt; is about as fast as moving std::vector&lt;char&gt; Well, in the case of copying shared\_value you will have to traverse the list of values to the end and add one new instance. For moving, you'll have to update references to current instance in list to keep it correct. In case where it's the owning instance being moved, you'll also have to move the value itself, which may or may not be expensive. All that will have to either involve some expensive locking or non-trivial lock-free manipulations to guarantee thread safety. I consider that expensive compared to moving shared\_ptr (which is basically just copying one single pointer value and nullifying its previous location). &amp;#x200B; \&gt;though jumping to the conclusion that it will be impossible seems too quick. I was only saying preserving the same guarantees to those of shared\_ptr will be impossible. For example, you won't be able to dereference it as easily: you'll have to guarantee that value won't be moved-out by another thread while in use. Aside from the fact you have to traverse the list, this thing alone will make dereferencing (an essential or even prime op for smart pointers) expensive and require unobvious block/scope based apis. But maybe I'm not reading it right and you not intending to make shared\_value a drop-in replacement for shared\_ptr in the first place \&gt;Again, if you take the example shared\_value&lt;std::vector&lt;char&gt;&gt; then I don't see the \*significant\* increase in space Having to allocate sizeof(T) bytes of additional memory for every single instance of shared\_value "pointing" to the same object of type T sounds like a lot for real-life cases where a single shared value may be pointed by dozens of shared\_ptr's.
Thanks for the answers. Too bad that the GPL version doesn't have QtCreator integration. But I guess KDAB has to make money somehow, of course :-). Very interesting that most of the stuff doesn't need debug information. I wonder how they can read all this information, including e.g. variable information, from release builds. Other debuggers need a release build with debug information for that. Might be an opportunity for an interesting follow-up blog post.
You're right, I can see now that the example may be confusing to a non asio user. But there isn't really much to it. So instead of creating an artificial example, I'll rather try to explain the first one: Asio comes up with a structure called io_service (the name is being changed in newer versions, but that's not important). The io_service is basically a list of tasks that are pending to be executed. Conceptually, you wouldn't be far off to think of io_service as std::list&lt;std::function&lt;void()&gt;&gt; (plus nice API + thread safety + ...). Now, when working with asio, you often need to write functions like this: ``` template&lt;typename Handler&gt; void my_async_operation(Handler handler) { ... } ``` Where you don't know the type of Handler up front, and often its just something non-copyable that implements operator()(). Now imagine you want to execute the handler, but you don't want to execute it right from inside `my_async_handler`. Instead what you do is you (conceptually) "push_back" that handler to the io_service so that it is executed later. The "push_back" on io_service is done through the "post" function. Now, the documentation says that when using io_service::post, the handler you pass to it may be copied "as needed". This is a problem because the Handler type often doesn't have the copy constructor and so I can't do io_service.post([h = move(handler)] mutable { h(); }) because that lambda is now also non-copyable. So what I was previously doing was that I created `shared_ptr&lt;Handler&gt; hp` and moved the `handler` into it (as in the example). Then I captured that shared_ptr&lt;Handler&gt; in the lambda which is now copyable and passed that lambda to the io_service::post function. I was always uneasy about allocating in my_async_operation and because the Handler type is always assumed to be quickly movable, I came up with async_value. Thus, instead of allocating with shared_ptr&lt;Handler&gt;, I create shared_value&lt;Handler&gt;, then move the `handler` argument into it. Copying shared_value&lt;Handler&gt; is relatively cheap (as long as there aren't too many copies), and so I capture a copy of this shared_value&lt;Handler&gt; inside the lambda which will now also be copyable. Then pass that lambda into the io_service::post function.
You're right with many things, but mainly in that shared_value is indeed _not_ a drop in replacement for shared_ptr. Same as with e.g. std::vector and std::list, IMO shared_value may be more suitable (compared to shared_ptr) in some situations while not in others. As you indicated (and I also mentioned in my OP), shared_value is suitable when: * there is relatively few copies of the shared_value sharing the same value (e.g. 2 or 3) * sizeof(T) is relatively small (e.g. sizeof(std::vector&lt;char&gt;) is quite small, even though the data it holds may be big) * there is a need to create _many_ shared_value instances _not_ sharing the same value (i.e. many short lists) As it turns out, my use case right now is exactly that. And yes, locking is a problem, may be solvable maybe not. Certainly not trivial. My luck is currently in not having to deal with it as all my projects are - while async - only single threaded.
Aren‚Äôt they just using the metadata from MOC?
Very interesting. A few suggestions : * If you replace the doubly linked list with a singly linked list with head pointer, you get O(1) deference. The destructor then has to perform O(n) updates when destructing the head, but that's still O(1) amortized. * I don't think that `optional ` is really necessary - you should be able to use `aligned_storage` and manage lifetime yourself (since the head node knows whether it is the head). This also means not needing to worry about the presence of a move assignment operator.
I attended the talk and I share the sentiment.
&gt; If you replace the doubly linked list with a singly linked list ... I see, yes, I think that would indeed be quite a lot better. Thanks for the suggestion. &gt; I don't think that optional is really necessary ... Wouldn't I be just re-implementing optional with aligned_storage? Coming up with the solution to not having the move assignment operator was a little headache, but at the end I'm happy how it turned out (would be happier if I could use `if constexpr` for that instead of template specialization, but I'm using c++14 ATM). Are there other disadvantages to using optional you are thinking about?
A universal unsafe would probably be just dropping optimizations basically. If you want the safest option you don't want any standard breaking settings which most optimization passes usually violate in subtle ways. The performance gains are significant which is why every major compiler uses them. Fast math is mostly about checks for denormals and such IIRC.
It was (in effect) initialized with zero. There is an overriding "as-if" rule - basically, if your _well-formed_ program can't tell, the compiler doesn't need to do it. If you had 1000 global variables that are never accessed, the compiler doesn't need to initialize them, or even include them in the program. "If a tree falls in a forest, does it make a sound?" Yes, but the C++ simulation of it might not bother producing the sound, because you can't tell if it did or not.
I can think about of some criticisms but they aren't any of these. I think making claims about thread safety is pretty bold and I'm not sure why you claim copying is expensive when there was no talk about data sizes. I think having a shared value that runs the constructor when the reference count drops could have uses, possibly together with allocation with a larger structure, thus not based on the heap. Playing devil's advocate is fine, but don't make up nonsense just to try to squash someone's idea.
That's really cool
Aside from the unnecessary extra `bool` that repeats something you know already (whether the node is the head) you're generating unwanted code paths - the reason the move assignment operator is checked for is for the case when you're assigning an engaged `optional&lt;T&gt;` to another engaged `optional&lt;T&gt;`, but you know that never happens - so you have a pointless check and code that never gets called. You might be able to hint this to the compiler, but ISTM you'd do better to implement the bits of optional you need, of which there aren't that many.
Yeah, that's true, but in that case variable was accessed and standard insists that this variable has to be initialized with zero when application starts. This is either a compiler bug or substandard compiler, it simply assumes what it shouldn't assume. I would expect compiled program to make a function call on \`nullptr\`. Yeah, it's UB, but this is what it was programmed to do and this is what compiled program should do when computer programmer tell it to.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cbfgei/simple_database_program_cpp/etfu0yz/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Thanks, removed.
It sounds like it allows async (it gives you the file descriptors and you can wait on them)..... That sounds async to me :D
It would be a neat experiment to automatically annotate all member methods with `[[clang::callable_when(unconsumed)]]` and all move constructors with `[[clang::set_typestate(consumed)]]`
Are you aware that newer, NetworkingTS-compatible versions of asio [no longer require Handles to be copyable](https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/reference/Handler.html)?
I like the creativity, but I don't think this is a useful idea. 1. this will use a lot more space. realistically, you need three pointers (head/next/previous) and space for the object. This is needed for each copy. 2. this will either move a lot or be useless. Either you are working in one call stack and you might as well have used a regular old reference OR you are multithreaded in which case you will be moving from stack to stack which is just as expensive (if not worse) than simply allocating so there's no use. 3. typically the best types to move already do heap allocations. e.g. vector is expensive to copy and cheap to move. but it already does tons of heap allocations. 4. when shared pointer is too slow, there is a nice trick: store everything you need at the beginning of the container. e.g. for a vector, each thread would have a pointer to the heap object. the first item would be the ref count, then the vec size, then capacity, then the elements. etc. downside is you cannot easily add this to existing containers
christ, kicking rust while it's down like this is almost unethical lol
What do you mean? Rust doesn't need annotations to detect use-after-move.
Down? It's [dominating](https://www.techempower.com/benchmarks/#section=data-r18&amp;hw=ph&amp;test=fortune) ;)
&gt; Yeah, it's UB So all bets are off. That's the point of UB.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/cbjrm9/free_courseudemylearn_c_programming_mini_course/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
There is also [https://clang.llvm.org/extra/clang-tidy/checks/bugprone-use-after-move.html](https://clang.llvm.org/extra/clang-tidy/checks/bugprone-use-after-move.html)
I would not put too much confidence on these benchmarks. There are popular C/C++ frameworks missing in the list, and in many cases gcc (not used by rust) produce faster machine code than llvm (used by rust).
UB occurs when \`nullptr\` is called, not before that. Before that program should behave according to standard if it's compiled with conforming compiler. As far as i'm concerned, this means that at entry point \`Do\` should be initialized with zero. Do you see the difference between "program execution results in UB" and "compiler execution results in UB"? In former case it's application bug, in latter case it's a compiler bug.
Oh that looks interesting, thanks for bringing it up :)
Interesting, though the [io_context::post](https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/reference/io_context/post.html) page still says: &gt; The io_context will make a copy of the handler object as required So I'm guessing, while handlers don't need to be copy-able when passing them to (e.g.) async_read, they still need to be copyable when passing them to `io_context::post`.
&gt; I would not put too much confidence on these benchmarks. For this specific usecase, this is the best benchmark available, so it deserves *some* confidence. Even when there are lies, damn lies and benchmarks. &gt; There are popular C/C++ frameworks missing in the list Adding frameworks is a purely volunteer-driven process; essentially just a pull request to the git repository, so there is no "exclusion" there: https://github.com/TechEmpower/FrameworkBenchmarks/ It is regarded as courteous, though, to ask permission from the framework maintainers before making such a pull request. They may want to double-check the submission to ensure the framework is not accidentally mis-represented, for example. Unfortunately there is no way to know if said C++ frameworks would fare better, or far worse. So, for now, given the extensive competition here, I think it is fair to say that actix is the fastest framework benchmarked, and anyone who argues to the contrary is welcome to bring proofs to the table. &gt; and in many cases gcc (not used by rust) produce faster machine code than llvm (used by rust). This would match my experience, however the benchmarks are not necessarily that sensitive to the quality of the code generator at this level of optimization: - On the one hand GCC cannot save you from contention in the critical path. - On the other hand, C++ and Rust both offer significant abilities to micro-optimize the code yourself; down to using SIMD intrinsics rather than relying on auto-vectorization for example.
If by "kicking Rust while it's down", you mean "continuing to demonstrate how cumbersome it is to implement this stuff as libraries and compiler extensions instead of as core language features", agreed! As someone who writes C++ for a living I'm glad that this sort of stuff is making inroads, but it's so much clunkier to use than the equivalent Rust features.
From \[intro.execution\]: &gt; This International Standard imposes no requirements on the behavior of programs that contain undefined behavior. Individual operations are undefined, yes; but when a program _contains any operation_ that is undefined, as was said, all bets are off.
`io_context::post` is deprecated, it's replacement [`post`](https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/reference/post/overload1.html) has no such requirement.
So it looks like you're just trying to force shallow copies with a wrapper in case the first copy goes out of scope? If it's in the same thread you may be reusing the memory already in the stack if it's declared const (or force it by passing a reference), if there's no guarantee about the thread then you shouldn't be referencing another thread's stack without guarantees that the reference won't go out of scope.
&gt;your local object may very well end up in an invalid state. It‚Äôll still be destructible, of course, but it‚Äôs no longer logically valid Unless otherwise specified, all standard library objects that have been moved from are placed in a *valid* but *unspecified* state, i.e. they can be safely reassigned as well. It's a good thing to design your classes in the same way. &amp;#x200B; &gt; An obvious example is std::unique\_ptr Not a good example - unique\_ptr is guaranteed to be empty after move. Not dereferencable of course, but the state per se is perfectly valid.
You guys really into special olympics, aren't you? Sure, a program is crashing somewhere, let's make it crash twice as often with the power of optimizations. No problem, go crazy, i'll stick to GCC for now.
It did. It performed UB, as requested.
You're the one arguing with reality, mate.
hope g++ will support it
Removing the prev pointer makes destruction of a node in the middle of the list O(N). It might be worth keeping all 3 pointers?
Ah yeah, good point.
Yes, that's what I meant by "no longer logically valid". As in, perfectly valid from the compilers perspective, but invalid in the semantic context of the program.
A moved-from unique_ptr is a nullptr, which may be perfectly valid, even semantically. Often, it may not but that depends entirely on the context in which it is used.
&gt; but invalid in the semantic context of the program. It's also perfectly logically valid. Take this contrived example: std::unique_ptr&lt;Foo&gt; foo = std::make_unique&lt;Foo&gt;(); if (do_process_foo()) process_foo(std::move(foo)); if (foo) handle_unprocessed_foo(std::move(foo)); It's very important that `foo` is guaranteed empty after the move so that the behavior of the following `if` is correct/valid.
&gt; So it looks like you're just trying to force shallow copies with a wrapper in case the first copy goes out of scope? Yes, that description sounds correct. And you're also right about the threading part. In the projects Im working on Im not using threads. So I have the luxury of not having to care about thread safety. I do use single threaded asio with async functions however (where you pass handlers to async functions and they get executed in the same thread once the async op is done). In these cases this shared_value structure comes in handy.
Yes, I understand that. I'm probably not expressing myself in the best way. I only wanted to illustrate the fact that dereferencing the unique\_ptr after moving from it would be a bug. I didn't mean to imply that the object is somehow in an undefined or unpredictable state. I can see why the way I wrote it is confusing, so thank you for the feedback. :)
That immediately makes me wish for (much) more: It would be even cooler to have freely defined states and having both the positive (`state`), the negative (`~state`) and an uncertainty (`!state`) state for each state. E.g. for `std::vector`: clear [[set_typestate(empty)]] push_back [[set_typestate(~empty)]] pop_back [[set_typestate(!empty)]] [[callable_when(!empty)]] front [[callable_when(!empty)]] With `~empty` being strong negation (we known it is not empty) and `!empty` weak negation (we don't know that it is empty; with set_typestate it means that we are now uncertain about emptyness). Thus we express: * clear: Definitely empty afterwards. * push_back: Definitely not empty afterwards. * pop_back: Requires that we don't know that it is empty. (I'm not sure if the stricter "`callable_when(~empty)`: Requires that we know that it is not empty" would make more sense but probably that would be too strict. `callable_when(!empty)` would be fulfilled by both `~empty` and `!empty`, alternatively, `not_callable_when(empty)` might be a clearer notation). Afterwards, if we knew that the container was definitely not empty before (~empty), we don't know that anymore.
Thanks, I'll pass to the developers. But I guess there is so many things we really on additional to Clangd (and taken from CLion) in this features still, that upstreaming is simply not straightforward.
Yes, I think Im starting to agree with you
How would that work with exceptions?
P0732 NTTPs do not interact at all with the `std::has_strong_structural_equality` library template. They interact with the core-language notion of "strong structural equality." It is fundamentally true that `A::E` has strong structural equality in C++2a, regardless of whether the programmer instantiates the `std::has_strong_structural_equality` trait or not. It was a distraction to mention the library template at all. You don't need to instantiate the template in order to demonstrate the problem with P0732 NTTPs.
That's an interesting question and I to be honest, I don't know. Probably the safest default would be that if any `set_typestate` involving a state `x` is called, after throwing we assume `!x`. Of course we could invent other annotations like `set_typestate_throw` or `strong_exception_safety` (so that after throwing, any typestates remain unchanged). How does `consumed` interact with exceptions?
The move constructor is called on the moved-to object tho, so this would have to rely on some naming convention (like `invalidate` in the example from the post).
how is this different from what the callstack is already doing?
As daily user of VS2019 and VAX, I find VAX code navigation (open file in solution, find symbol,...) and code completion outperform IntelliSense in terms of speed and ergonomy (UI and UX), especially on huge codebase. However IntelliSense gives more accurate information that's why I'm using IntelliSense syntax coloration (VAX tends to be confused by symbols with same name but different kinds of). Regularly I'm trying to disable VAX to see IntelliSense improvements. There some, but VAX remains the king for what I mentioned above.
Author here, i believe self posting is allowed here, right?. I hope you enjoy it, and please leave some feedback.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/cpp] [Templated Runtime Polymorphism \[x-post r\/cpp\]](https://www.reddit.com/r/cpp/comments/cbnoy1/templated_runtime_polymorphism_xpost_rcpp/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Removed as duplicate.
As a long time user of VAX, I've found that with Visual Studio 2019, I stopped bothering to update my VAX license. The built-in Intellisense isn't perfect, but it's Good Enough(tm) finally that I don't find myself cursing the lack of VAX's feature set. I'd consider buying VAX or ReSharper for large/professional projects, but not home hobby use.
Sounds like you're overthinking things and over-abstracting. Hard to even understand what you're trying to do.
A moved-from `unique_ptr` is exactly the same as a default constructed one. Neither is "invalid".
No worries, online communication is deceptively difficult. :)
Will be keeping an eye on what you have next. Will this be similar to hippomocks, or will it require build system support? Also, how do you mock free or static functions with gmock? Is there better support than "write virtual wrappers and link those instead?"
You seem to be under the misunderstanding that your personal, naive mapping of C++ to assembly/machine code on the machine you are compiling the code to run on is what the code means. And I get it. That naive mapping is a great way to get a bit of intuition about what your code is doing. But if you stop there, you'll (a) be confused by what C++ actually does, and (b) not be able to write code that runs as fast. C++ program behaviour is defined in terms of an abstract machine. At runtime, the compiler is responsible to make code that is consistent with that abstract machine's behaviour. But the actual abstract machine variables, values, etc? There is zero requirement that the compiled program contain any of it. A value being zero in the abstract machine does not require any zero bytes at any time exist within the compiled executing program. Now, any *defined behaviour* that would generate *observable behaviour* where the value matters must behave as-if the zero was there. For a fun example, there are platforms where null pointers are 0xffffffff. Assigning literal zero to a pointer makes it 0xfffffff. Undefined behaviour where it would, if actually zero bytes, do something specific on the target platform? Need not be zero in the target platform. You may think you want a "convert code line by line to platform specific assembly, then as-if optimize", but that leads to horrid assembly code in even simple loops. The restrictions on what you are allowed to do permit the compiler to not have to prove intractable statements about your program in order to locally optimize really useful stuff. This example here is contrived, but the technique used here lets loops be inverted, complex equations be refactored and simplified, expensive function calls be elided, and lets programmers write clear structured code that converts to crazy optimized assembly. Note that if you want a hard crashing pointer you can write one. Just whip up a smart pointer, where `*`, `-&gt;`, `-&gt;*` and `()` all check for null and explicitly fast terminate your program. Find the right built-in and it could plausibly even compile to the asm you'd want.
I'd probably use the more standard term "type erasure" to describe what you're doing here. I also wouldn't really describe Sean parent style polymorphism as a type of pimpl pattern, there are some similarities obviously but the goals are completely different
You stopped before it gets really fun. A polymorphic method is something that can generate a method on a spedific type on request. auto print_all = poly_method&lt;void(std::ostream&amp;)&gt;{ [](auto&amp;&amp; self, auto&amp; os){ for(auto&amp;&amp;x) os&lt;&lt;x; }; Using that and some glue code you can support: std::variant&lt;std::vector&lt;int&gt;*,std::vector&lt;double&gt;*&gt; vars; vars-&gt;*print_all( std::cout ); now this is just simple visit with some operator overloading. But we can keep going: poly_any&lt;&amp;print_all&gt; printable; printable = std::vector&lt;int&gt;{1,2,3}; printable-&gt;*print_all(std::cout); here we can write a `poly_any` type that takes a pack of poly methods, then it writes a vtable for them. When assignes any value, it grabs the poly methids, generates a vtable for it with all of the methods it supports. When you `-&gt;*poly_method`, it then finds the entry innthe vtable and dispatches to it. You can get the compiler to write your vtables for you, and store them in a static local variable in a generation function. Why? Because it don't stop there: poly_view&lt;&amp;print_all&gt; is a trivially copyable noexcept view type that can store a view into anything printable. Or you can create an aspect-supporting vtable. Or a bunch of other insanity. By killing the C++ object model and taking its stuff, we get vtables that serve our needs, not the designs of 1980s OO C with classes programmers. I, for one, welcome our new metaclass overlords.
Use skip lists or similar. Get O(lgn) performance.
Does this also work for detecting when, for example a unique_ptr is both moved from and deferenced in an argument list during function invocation? (This slip up has bit me a couple times).
I alluded to the open vs closed very briefly (like a sentence or two), maybe it should have been expanded upon some more. I was mainly focused on getting people away from the C-style void* kind of programming (i find that C programmers refuse to use something if they don't know how it's implemented, so i decided to focus on implementation) and maybe neglected thinking more deeply about the themes i touched on. I am working on improving some things about the article, so I'll probably change the wording on the Sean Parent section (which admittedly feels kinda tacked on even though it was planned from the beginning) and try to touch on characteristics and pros vs cons of closed vs open... though it might be better to make a separate post about that.
Now that's some stuff straight from the arcana
Both intellisense and ReSharper++ are slow and buggy. I use vax's light parser only. It's smooth af and good enough.
So contracts? :)
Your final implementation has virtual call overhead, a non-trivial copy and a heap allocation. At that point just using the standard facade or visitor pattern approach should yield significantly better performance and simpler code.
I stopped using VAX with the improved intelisense features that came in with visual studio 2017. Even professionally, on our multi-million line code bases, the new feature set works just fine. Though I did make a theme to mimic VAX syntax highlight.
It doesn't seem to require copyable handler [https://wandbox.org/permlink/kYFq0jo8sjn8tu1y](https://wandbox.org/permlink/kYFq0jo8sjn8tu1y)
When you‚Äôre within a single thread, the compiler (and OS) is pretty smart and can already share that memory for many classes, and scope seems like your main issue. I haven‚Äôt used asio so I may be way off point, but since you‚Äôre not splitting this up into multiple threads, it seems to me that it makes sense to avoid the constant spawning of handlers and pooling some functionality together if that really is a bottleneck. Seems very niche but could be a useful class in a scenario similar to yours, probably better to propose a change to boost::asio than the standard library IMO.
That's insane. Just use value parameter, it will be copied into coroutine frame.
That's okay if the value is a small thing, otherwise you do want to pass a reference to something whose lifetime is correctly managed. The problem I see with co-routines is that they trivialize important architectural decisions: it is too easy to slip in a ```co_yield``` and hope for the best, but the use of this has to be considered at a more global level than just the function into which it is being inserted.
Hm, you're right, calling `asio::post(non_copyable{})` is OK, calling `io_ctx.get_executor().post(non_copyable{}, std::allocator&lt;non_copyable&gt;());` is also OK (which according to the docs is called from inside `asio::post`. The deprecated `io_ctx.post(non_copyable{})` gives error. Seems that Asio is using a similar "trick" as I was doing and moves the handler into a newly allocated memory but allocate using that Allocator argument. Also, maybe they forgot to remove the line saying "The executor will make a copy of the handler object as required." from [executor::post](https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/reference/executor/post.html) documentation. Thanks for the info
&gt;Even with a good pc, both plugins brought noticeable lag to typing, and I haven't figured out any combination of settings that seems to alleviate that at all. It doesn't seem like it was maxing out my 16 gigs of ram, and they're running at 3533hz. Really, wish I knew if there was a solution here. That's strange, I never noticed any slow down during typing even on quite large codebases, maybe during analysis phase (whish is basically just like one more compilation alongside) since it could used all of your cpu power. 16 gb ram doesn't matter though because Visual Studio environment is 32-bit and will cap at 3 gb which alas happens all too frequently in my experience. &gt;The thing I liked more about R++ was the on-the-fly code analysis that seemed to follow a lot of clang rules. It runs actual clang-tidy executable alongside and displays errors from it in convenient manner, it's very cool feature but R++ is responsible only for running and displaying results, not the analysis itself afaict. &gt;I haven't been able to really find a use for most of the other features because I'm not working with large enough code I guess the most useful features are still navigation code/file search, refactoring: i.e. renaming stuff, changing function signatures, overriding virtual functions, generating switch cases, automatically adding includes, etc. Some of it could be done from vanilla VS, but some of it still missing or unsatisfactory there, if you don't have experience it might be hard to decide.
Lambdas in general have the same problem of easily capturing references and accidentally being invoked after the object‚Äôs lifetime. The difference is that the extra syntax tells you that you‚Äôre doing something that‚Äôs not s normal function call and capturing state, so you can at least have an internal flag go off.
FSeam is generating source code compiled instead of the actual implementation. It does require build system support (as of today, CMake). For free and static method. You can either use a virtual wrapper, but it is also possible to make a mock by template (with a GMock type as template type). But in most of legacy code, it requires some refactoring to be able to do so.
I haven't used resharper in a professional setting for years and years. All I ever needed has been adopted by visual studio internally. I think the only people who swear by it are the kind of people who like to stick to what they know or are forced to by stupid old company policies.
&gt; I only wanted to illustrate the fact that dereferencing the unique_ptr after moving from it would be a bug. well, dereferencing a unique_ptr like that is the exact same bug std::unique_ptr&lt;...&gt; p{}; *p;
**Visual Assist X** is still good even with VS 2019. I'd say for VS2008 - VS2017 real development was almost impossible (or very very slow) without VAX or ReSharper. With VS 2019 it is not so painful anymore, but VAS still makes it faster and more fun. And if you have C++ programming as a hobby - you probably want to have fun, right?
If the reduced version tickles the same bug, why do you care if the original version is forgotten?
This is interesting. Have you noticed that your first and second examples can be fixed with changing -O3 to -O0?
But I'm not sure what features are actually saving me any time, so far.
It's fake. You cannot add any more work to it once perform() is called.
Thanks for the insight. I'm not actually sure how extensions like r++ or Vax are handled alongside VS memory but I did know it was limited by being 32 bits. I figured they might be running in their own containers alongside VS but I am not at all confident about that. I didn't know it was actually running clang tidy itself. Is there anything else out there that can get the same real-time results without manually running clang tidy?
Unfortunately currently they both running inside Visual Studio process, Resharper had some plans of moving out of process but I haven't heard about in a while. As for running clang-tidy, I don't see much downsides to it, it's out-of-process so it helps with ram usage. It complements Resharper's own checks rather than replaces them. R++ helps with the major problem of clang-tidy especially on windows - setting it up and getting good default set of checks. As an anecdote I had a case where resharper check was suggesting to add `typename` in certain place and clang-tidy was suggesting to remove it but it's not something which happens frequently luckily :)
VS Code. There is no reason why high school students aren't able to use a full featured one. And please don't listen to the people stuck in the 80s with their vim or emacs
There could be a case that a test case might not cover all the buggy cases which might appear to work at the time but another corner case showed up later. It would be great to modify/improve the original test case to cover the new corner case and generate a new reduced one instead of creating a new separate reduced test which could become harder to manage.
QtCreator could work. Really simple to install and Qt installer can also install MinGW. Also gives easy option to try C++ GUI programming.
&gt; There could be a case that a test case might not cover all the buggy cases which might appear to work at the time but another corner case showed up later. So "it compiles today but just in case it stops compiling one day it should be in the testsuite"? That doesn't scale. You can't just keep testing every piece of code on the off chance it catches a problem one day in the future. Why is that original piece of code more likely to catch the new bug that shows up later than any other arbitrary piece of code? &gt; which could become harder to manage. What would be hard to manage? Having two small files in a regression testsuite?
Poo, I would actually choose something very basic like gedit (or emacs) because IMO these students need to see how everything fits together at a low level. Let them run the compiler at the command line and see how the files sit in the filesystem.
They can already do that in VS Code.
Yes you can learn a lot from compiling on the terminal, but if you ask me that's no reason to use a text editor without any features, might as well use Word at that point. Use VS Code to write the code, compile it on a terminal. They don't need a "click this button to do the compiler magic for you" functionality, but syntax highlighting, auto-complete, and intellisense are all really useful tools. I just mentioned VS Community in case the teacher does want the students to skip the terminal for some reason.
That's not a fix - if it doesn't work on higher optimization settings, it means that you're exploiting undefined behavior in the language.
Well personally I would like to have the option to access the original test code in case a similar issue shows up later and can be covered by small modification by that test. Losing original test code still sounds a little scary to me as the meaning of reduced tests can get lost over time. Maybe I worry too much. But I agree that small regression tests are still good to manage.
For me, vax's built in parser is just way faster than intellisense and ReSharper. It rarely crashes and use far less ram and disk(you need turn off intellisense and set vax to use its own parser). Although the parser is less accuracy, I actually prefer it lists all possible entities even not opening any solution. There're also lots of handy features like toggle comments with single '/', quick list all symbol/files, quick action/rename/refactoring, code generation, suggestion using snippets/surrounding code, etc..
Yeah, it's not a fix, just a demonstration. It feels like something is poorly defined or definition has changed. So \`"hello world"\` isn't static anymore and temporary is destroyed before for-loop exits it seems, but suddently it all works with -O3 if \`const char \*\` is used instead of \`std::string\`. So changing value type removes UB? It is very true that something is not really defined, good point.
&gt; So changing value type removes UB? UB means that anything can happen, including the code working as intended.
If a similar issue shows up later then you must have a new reproducer, for it to have shown up. So you have a reproducer, which is all that matters. Going back to some other piece of code and tweaking it isn't necessary, because you have the new reproducer. Manually tweaking the old piece of code to make it also trigger the new issue (and isolating that from whatever other behaviour the original code might have) is more work than just doing another automated creduce run on the new reproducer. In GCC's case the original testcase is often recorded in bugzilla, so it's still there somewhere if you really care. But from my years of working on GCC I don't think that's often useful, or used. The effort of manually adjusting an old piece of code with lots of noise that isn't related to the bug is simply not worth my time. Remember this tool is for finding compiler bugs. Compilers don't care what the code _does_, only that the code is correctly translated. For the compiler developers' purposes it's far more useful to have a minimal reproducer that doesn't have lots of unrelated clutter, for all the reasons given in the article ("A reduced test case is preferable because ...").
Thanks for the explanation (especially the compiler perspective). I'm sold now :)
Hold on. What's exactly wrong with "Boring old way, redux2" (apart from the typo in the return type, should be unique_generator)? generator&lt;char&gt; explode(std::string_view sv) { for (char ch : sv) { co_yield ch; // Same bug! } } The reference type (std::string_view) is created from a string literal, which has static storage duration. There are no temporary string objects involved. What am I missing?
\-- What is the Answer to the Ultimate Question of Life, the Universe, and Everything \-- UB
&gt; A fellow teacher recommended Dev C++, which is something that a lot of programmers I know curse to death. I also have thought of Turbo C++ which features a very simplistic UI, but that's only because it's from the ages long past. for hell's sake where are you from ? Dev-C++ has been dead for 15 years. I think that we should collectively send a big message to most schools, manifesto-like, telling them that they are *harming* their students there.
I don't think it's the problem with the coroutines but the deeper problem with lifetimes in the language itself. I mean the code below will also blow up in one's face: for (auto c : std::string_view{returns_string()}.substr(2,3)) { ... } At least in coroutine case, it can be "fixed" by the implementer: generator&lt;char&gt; explode(std::string&amp;&amp;) = delete; or on a compiler level: warning C1337: don't pass temporary into a coroutine dumbass
He‚Äôs speaking from the general case where you aren‚Äôt guaranteed for it be referencing a static array.
&gt; for (auto c : std::string_view{returns_string()}.substr(2,3)) { ... } Is the `substr()` necessary to make it blow up?
Can you get an academic license for MSVC? I think that is great for getting started, assuming that they are on Windows. Precompiled headers will simplify things for them also.
The problem isn‚Äôt passing a temporary, it‚Äôs that the argument is a reference type.
community version is free.
Actually no, but then one wouldn't use string_view in the first place*, and it wouldn't blow up thanks to temporary lifetime extension. *^let ^say ^the ^one ^writing ^it ^wanted ^to ^save ^an ^allocation ^on ^substr
true warning C1337: don't pass temporary by reference to a coroutine dumbass
&gt; Precompiled headers will simplify things for them also. How so?
Yes, but said teacher [or institution] might not qualify?
You can set them up with just the headers you need and then they do one include. It makes building faster also.
The problem is obviously not [really] with the recommended tools, but with the fact that OP and his colleagues call themselves teachers.
s/argument/parameter
The problem isn‚Äôt passing a temporary, it‚Äôs that the **parameter** is a reference type, and then a temporary is bound to it. (On the suggested compiler warning) ^^This ^^was ^^posted ^^by ^^a ^^bot. ^^[Source](https://github.com/anirbanmu/substitute-bot)
The problem isn‚Äôt passing a temporary, it‚Äôs that the **parameter** is a reference type, and then a temporary is bound to it. (On the suggested compiler warning) ^^This ^^was ^^posted ^^by ^^a ^^bot. ^^[Source](https://github.com/anirbanmu/substitute-bot)
Why is this easier than including them directly and I seriously doubt that for any student-project compile times will be affected.
VS Code combined with whichever LSP implementation works on Windows (clangd?)
Comma needed before "dumbass". Can't look like a dumbass while calling out a dumbass :)
Using Visual Studio with vcpkg automagics adding include directories and linking libraries that would have to be done manually in some kind of build system (and potentially a project helper file for IDE-like intellisense) with other solutions. All the user has to do is install a package with vcpkg and when they simply `#include` a file from that package in a cpp/h file in their project the rest is all done for them. Having said that, is C++ the next logical step up from Scratch?
:( Thanks, but I'm afraid that this warning message won't pass the review either way.
Time to fork!
&lt;link to job postings for rust&gt; &lt;link to job postings for java&gt; "dominating"
Emacs But seriously, VS Code
Honestly, just use Visual Studio. The community version is free (as long as you don't make a profit from it), and you can probably grab an educational license (I don't see why the students would need one). Stuff like VS Code will require your students to add the proper C++ extensions themselves and you'll lack Visual Studio's debugger, which is considered the best C++ debugger by many.
Visual Studio Community Edition or whatever the free one is called
Speaking as a complete beginner to c++ and learning from a book as we speak to hear me out: Is an IDE really necessary at this stage? Why not just download a simple code editor and compile through a terminal? Learning that process is valuable in itself. I didn't want to spend time learning the ins and outs of an IDE that I may not even use in the future when I could just focus on the code. Besides if you're only teaching the basics, the terminal will tell you enough to be able to debug without adding breakpoints etc. Logistically, think about having to worry about getting people set up with the IDE, then all the issues people will have during class using it i.e. "this tool has disappeared from toolbar, I don't know where this is, etc. etc.". Probably not the answer you were looking for and others might disagree but speaking as a student in c++ myself I think this is the best way to go about it in order to focus on the code.
Check out [juCi++](https://gitlab.com/cppit/jucipp). The main rule while developing this IDE was to keep the UI as simple as possible (no buttons etc.) while still having the needed functionality easily available trough hot keys.
I second that
&gt; I don't think it's the problem with the coroutines but the deeper problem with lifetimes in the language itself. I agree, but I think it's both. Misunderstanding a symbol's lifetime offers an easy way to shoot yourself in the foot _and_ each coroutine provides several chances to pull the trigger. (More, we have all developed intuitions that are now wrong in c2a. I clearly need to start training my eye to notice `co_`* statements...)
Starting at too low level is how you end up pushing people away from programming IMO. When you first start to program, you want to make games, web sites,and other cool stuff. It's by easily allowing that that you can interest people in the craft. Of course, if they pursue learning the craft, they will eventually have to understand what the hell is happening at a lower level but at first, show them how fun and easy it can be to make something cool. Take two beginners, one in Python, the other in C++. By the nature of both these language, in a few weeks, the Python one could easily be taught how to create a simple game with a UI. The C++ one will still be making console app with endless segfault because "he needs to know how raw pointers and memory works before moving further". Stop teaching C, stop starting at the very low level and C++ can be a fun starting language.
I understand your point, but I think the public here isn't people how are actively pursuing a career as programmer, but rather potential hobbyists and programmers. I think the class should focus more on easily doing something cool, rather then showing them all the nooks and cranny of the language. Yeah, they will end up doing stuff they don't understand, but if they have fun and it capture their interest, they will end up learning that stuff later.
Most (if not all) of the same issues happen also with any other async function. If a function starts a new thread for doing an async operation, it must consider argument lifetime and decide on the correct way to get them (hint: usually by value). This should be up to the function implementor, the user shouldn't be required to handle this. This is why "being a coroutine" is an implementation detail (just like "using a thread internally") instead of being part of the interface (at least with the current draft).
Exactly. If we call ourselves teachers, then where the hell are our students going to, right? That's why I am finding recommendations to start change in our schools. My colleagues didn't even have professional work background with Software Development; they all had degrees in Computer Science and then permitted to teach. Meanwhile, I, too, have a degree in Computer Science but worked as a freelance Web developer for 3 years before I started teaching. And I am as clueless to C++ just as my students are. The only place I could look for help is here, where other developers could help me teach my students in a way that prepares them for the future, regardless if they want to enter the tech industry or not. I am so happy that a lot of you have given your recommendations, and I will be looking into all of them and tell my colleagues.
I don't see the extra copy, where is it? Do you mean in the Sean Parent style constructor? That's not necessarily a copy, you can std::move into a pass by value (So it does have a move worth of overhead). As for virtual call and heap allocation, yes. But that's a type of overhead that's usually expected in this kind of situation. I struggle to see how the facade pattern would help achieve template-based runtime polymorphism, but I do agree with your point about visitor: that's what std::variant does, and that's what the first half of the post speaks about.
&gt;where are you from ? In my country - Romania - my high school teacher considers Turbo C++ advanced because it has the `graphics.h` header included and requested me once to make it work on school's computers. I tried but I couldn't make it work and I tried to explain to him that the library is very old and Turbo C++ is not even developed anymore. With my limited knowledge I tried writing a library that uses SDL2 instead to draw simple stuff, I made it work on their computers and I made a simple template in codeblocks - the IDE that the school uses - to make it easy for students to create new projects. Sadly I have just finished high school and after I made it work they reinstalled windows on their computers and I did not get the chance to 'install' the library again. The same teacher says that codeblocks is a programming language - something like an advanced c++ that highlights text, that the only difference between c and c++ is printf vs cout, that iostream.h should always be used and I am not even kidding. &gt;I think that we should collectively send a big message to most schools, manifesto-like, telling them that they are *harming* their students there. Just PLEASE do it.
&gt;Having said that, is C++ the next logical step up from Scratch? No. But that is something that's beyond what I have power over. The country's Department of Education set up the curriculum and as an entry-level instructor, I can't do anything other than assisting my students ever so gently into C++ programming.
&gt; And I am as clueless to C++ just as my students are. So, the blind leading the blind? It's just abysmal that you even pretend to be a C++-teacher [and what about the institution that hired you for this purpose]. If you are a teacher, you would ~~give~~ advice and your opinion here.
&gt; The same teacher says that codeblocks is a programming language That's just... sad. To be honest, this type of scenario is very widespread here too (I'm from the Philippines). And I'm talking about universities and colleges that give out degrees in Computer Science and Information Technology. The teaching professionals just aren't that good in learning themselves, and give out wrong and misleading information. This results with students barely ready for work after they graduate, and the better students end up working as software developers in high paying companies; almost none of them even consider teaching.
&gt; I think that we should collectively send a big message to most schools, manifesto-like, telling them that they are harming their students there. I am from the Philippines and yes please, do that. I am teaching now because I have been in this cycle when I was taking up my degree. It was not just unproductive but toxic, you being taught something that's not even used anymore, wasting years of study only to come out with nothing useful learned. I just wanted to be a part of some sort of change, I guess, that's why I am teaching now.
&gt; you even pretend to be a C++-teacher I guess that's true, pretending to be something that I am not, "blind leading the blind". The only difference is that I know more than the basics of C++, and although I have no work experience with C++, I have worked on it for two years when I was studying. I may not be able to teach them everything, but I am more than capable of teaching what they need to learn to just see if they want to go into software development. &gt; what about the institution that hired you for this purpose You know how schools go. They just want to follow what is written on the stone tablets so they could operate for more money. Just a few of them actually push for change in our education system. I needed a job, they needed a teacher, so I went in. But out of my conscience and care for the future of these kids, I want to be more than just a teacher technoblabbering his way through the school year. &gt; If you are a teacher, you would *give* advice and your opinion here. I disagree. Teachers, though their job is to be content experts, should also learn. And to learn, the first step would be to be honest to yourself that you don't have an idea about a thing you are to teach. That is why I am here, asking for *the more expert's* advice and opinions. Please don't see me as an enemy or the cause of why we have problems in our system. I am trying my best to not contribute to that problem, if I can't be part of the solution.
When you mix concepts and coroutines you will have the same problem since you dont know the the exact type and whether it is a reference type. It is a responsibility of the caller to make sure the object stays alive. So coroutines have a lot in common with async functions when it comes to lifetime issues. Therefore it is not just an implementation detail whether a function is a coroutine.
Are you mad? This happens for most subjects. Most teachers do not have backgrounds of successful professional careers in their topic. Most maths teachers don't have a maths PhD, most chemistry teachers have never worked in a lab, etc etc. High school level is so far below professional practice it's not an issue. OPs special skills are in how to teach young people, rather than being a wizard in CPP. Unless it's a very expensive school, no where is hiring wizard programmers to teach their 16 year olds.
&gt; The only difference is that I know more than the basics of C++ ... Well, that's not a great qualification. I cook better than my wife, but that doesn't make me a chef. &gt; ... and although I have no work experience with C++, I have worked on it for two years when I was studying. Unless you are seriously clever, 2 years [of daily] programming in C++ [while keeping up with the standards] doesn't get you [or me] anywhere. &gt; You know how schools go. That's why I'm objecting, seems to be a problem in countries like India and apparently the Philippines. The thing is that you could be better as well, but you say you are not. &gt; Teachers, though their job is to be content experts, should also learn. Yes, so what happened, what stopped you from learning? Asking questions here is not gonna teach you program in C++.
&gt; Are you mad? No.
That would be true for pretty much anything that works with references, and doesn't illustrate anything special about coroutines. He could replace the generator with an std::function (which we have for ~8 years) and make more or less the same argument. Or with a normal struct that stores a reference. Or even with just a normal reference; can't count how many times I saw BS like: const std::string&amp; value = collection.GetOrReturnDefault(42, "default_value"); // I wonder why this code crashes sometimes, must be cosmic rays Blaming anything on coroutines in this context is just weird. The bit about initial_suspend is interesting (since I'm not familiar with coroutines in C++20, that was new information for me), everything else feels like unrelated ranting.
This is a ton of work. Congrats! However, maybe it's better to just use Wine if you're already using Linux VMs. Hopefully someday Microsoft will just ship native binaries of cl.exe and link.exe for Linux.
&gt; I cook better than my wife, but that doesn't make me a chef. I think you are missing the point. My students are high schoolers. They don't even know the word "programming" exists. The point of this class I am teaching is to pique their interests and give them ideas so they could decide whether to pursue a career on software development or not. They don't need to be C++ programmers by the end of the school year; they don't need to be hired to develop games or optimized utility software by the end of the school year. The goal of the class is to give them a brief introduction to programming so they could have an informed decision if they want to specialize in software development in senior high school. I don't need to be an expert, or know much really. I just need to let them have fun with the basics and create awesome things with it. &gt; Unless you are seriously clever, 2 years [of daily] programming in C++ [while keeping up with the standards] doesn't get you [or me] anywhere. Yet I have made a point-of-sale and payroll type of applications during those two years that I had been studying, the same types of application that these students are building in my class (according to the curriculum provided by the national department of education, of course). Like I said, I don't need to be an expert in C++, I just need to know more than just the basics so the students would know just what they need to enjoy programming. &gt; The thing is that you could be better as well, but you say you are not. When did I say I am not, or that I couldn't be better? I repeatedly said that I am trying. Isn't asking for recommendations a part of making myself a better teacher? Isn't searching for answers a way of improving? &gt; Yes, so what happened, what stopped you from learning? Please try to read my answer more thoroughly. &gt; Asking questions here is not gonna teach you program in C++. No it doesn't. I am asking for recommendations for an appropriate IDE to use, not how to program in C++ because I know enough to teach my students.
QT Creator or VS Code, both have - good autocomplete - good syntax highliting - go to definition - debugger - CMake support and both are cross platform (OSX, Linux, Windows)
I need to make sure my code builds with the MSVC toolchain for MSVC users. There is no way around it.
Isn't the fact that you need to build it kind of a non starter for what OP is looking for?
Also there's some cool plugins like clang power tools to aid with linting.
Is it just me or the generated assembly generator for these coroutine is abysmal? Even with `-O3` and `std::string_view` as parameter there is a thousand line assembly result. What is going on? It's not a complicated coroutine, no? Or is it the `unique_generator`'s fault?
By that do you mean pass-by-reference verses the sample code instead of pass-by-reference?
I second Qt Creator as well. It‚Äôs cross-platform. Has it‚Äôs own simple and grokkable build system which is also cross-platform, yet also supports cmake if the need arises. Can install mingw on windows using Qt installer. No need to do it manually.
could you write it any better?
Well, I don't know. I'm just curious why it does happen. Almost any other constructs in the language are easily optimisable. Clang even remove memory allocations with temporary vectors or string of a fixed size, and can also devirtualize a lot.
**Company:** [Optiver Europe](https://www.optiver.com/) **Type:** Full time, Summer Internships **Description:** Optiver is a leading trading firm driven by technology with over 1000 employees world-wide. We pioneer our own trading strategies and systems using clean code and the most advanced technology, running a global network with thousands of high-performance low-latency applications. Our engineers take ownership for the full stack of applications and the entire development life cycle. Working in collaboration with our Traders and Researchers, they develop proprietary software that is often deployed into production the same day, with immediate results and a direct impact. Check out our talk on CppCon [here](https://www.youtube.com/watch?v=NH1Tta7purM). If you enjoy working in a fast-paced environment with a short feedback loop and are interested in joining our technology team of over 150 people from 40 countries, have a look at our career opportunities below. ***Jobs @ Optiver:*** We are looking for exceptional engineers at any point of their career, who favour simple solutions for complex problems and have a passion for clean code and good architecture. Knowledge of financial systems or trading is not required. * [Software Developer](https://www.optiver.com/eu/en/job-opportunities/eu-1243339)/ [Graduate Software Developer](https://www.optiver.com/eu/en/job-opportunities/eu-510831?gh_jid=510831&amp;gh_src=6c0pe11) * [Application Engineer](https://www.optiver.com/eu/en/job-opportunities/eu-1207954)/ [Graduate Application Engineer](https://www.optiver.com/eu/en/job-opportunities/eu-652166) * [Network Engineer](https://www.optiver.com/eu/en/job-opportunities/eu-1615230) * [FPGA Engineer](https://www.optiver.com/eu/en/job-opportunities/eu-510906) * [And more](https://www.optiver.com/eu/en/job-opportunities/all/Technology/Amsterdam/) **Location:** Amsterdam, Netherlands **Visa Sponsorship:** Yes **Remote:** No **Technologies:** C++ on Linux, next to that C#, Python. Lua and FPGAs also form part of our technology stack. **Contact:** Please e-mail Jinre van der Veen or Patrycja Ostrowska at [recruitment@optiver.com](mailto:recruitment@optiver.com) for any questions.
CMake + VS code or Visual Studio if you are on windows, and CMake + QtCreator or KDevelop if on linux. &amp;#x200B; This is how I acheived the most success showing C++ to beginners.
I don't quite get the point of your example. Why would it crash?
Temporary lifetime extension isn't going to apply to `"default_value"`.
Sorry but I'm a little nervous to see you on here asking only about the IDE. Teaching cpp is (imo) pretty tricky so I'm surprised this is your only question. Also your colleague recommending such an old ide makes me think y'all aren't really keeping up with cpp which is scary because this language changes fast and a lot of cpp classes out there are utter trash because they're not kept up to date. I'm no expert, but SG20 are and I would recommend checking out their videos about learning and teaching cpp *before you do anything else*. At least watch the "critical" lectures and the ones about teaching cpp. https://www.cjdb.com.au/sg20-and-videos
Lambdas have concrete types, but can be inlined well. How are coroutines any different? Just imagine an automatic transform that turns a coroutine into a class with its members holding the state that needs to persist over yield points. That transform almost exactly parallels the capturing lambda -&gt; class transform that lambdas are conceptualized as. In any case, Rust's generators prove that this is possible in a language with a similar type system and compilation model to C++.
Do you have an implementation of this? I love the idea. However, I can't figure out how the `poly_method` reproduces `self`'s type when `self` is `auto&amp;&amp;`. Or is `poly_method` not erased yet, and the erasure happens later?
But the reference is bound to the result of the function call. The lifetime is extended.
Uh... and I wonder why I keep hearing Rust is obsolete in the face of modern C++.
&gt; The point of this class I am teaching is to pique their interests and give them ideas so they could decide whether to pursue a career on software development or not. Purely imo but c++ doesn't sound like the call then. Cpp is super deep to the point where if you're just trying to do simple projects with kids it's probably overkill. Ime the main killer for tiny projects is the dependency management wrt other languages. Pip install x vs good luck figuring out how to compile install and link x (not to mention having to first teach the students how compiling and linking work) Let's say you want to setup a simple program that reads an image from a file and detects faces using opencv. You will be done in python before you have even installed opencv on the c++ side. What motivated you to pick such an in depth language to teach absolute beginners when you yourself have minimum experience to begin with? &gt; They don't need to be C++ programmers by the end of the school year; they don't need to be hired to develop games or optimized utility software by the end of the school year. Again then what's the point of c++ here? The benefit of cpp (ime) is the control you get from the depth and complexity. If you're just trying to say "hey kids look at this" why try to make them swallow cpp? Imo if you're choosing cpp there has to be a legit justification for dealing with the language complexity and build systems. Otherwise try python seriously. Disclaimer: I'm not trying to say cpp is bad i actually love c++, just it wouldn't be my choice language for building simple projects with high schoolers esp if this is just a 1 year thing.
Assuming the signature of `GetOrReturnDefault` is something like `std::string const&amp; GetOrReturnDefault(int, std::string const&amp;) const`, I'll quote [cppreference](https://en.cppreference.com/w/cpp/language/reference_initialization#Lifetime_of_a_temporary) for lack of time to find a proper standard citation: &gt; a temporary bound to a reference parameter in a function call exists until the end of the full expression containing that function call: if the function returns a reference, which outlives the full expression, it becomes a dangling reference.
ho ho! tricksy c++, nifty quirks keeping us on our toes and mentally engaged! great article; thanks for sharing!
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/cpp_questions] [material for begining cpp](https://www.reddit.com/r/cpp_questions/comments/cbxraw/material_for_begining_cpp/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I guess the function returns a reference, but then it shouldn't accept temporaries.
/u/i007newtoreddit, it's going to be awkward when this thread is inevitably removed and your crosspost suddenly lacks all relevant information. ;-] Just post directly to /r/cpp_questions.
thanks and sorry i just started following cpp question so i repost it. i'll remember in future
&gt; Assuming the signature of `GetOrReturnDefault` is something like `std::string const&amp; GetOrReturnDefault(int, std::string const&amp;) const` Ah. Under such assumption, `value` would indeed be dangling.
Aren't all of these examples fixed by c++ 2a's new init-statement in ranged-based for loops?
Do I understand this correctly, that a by-value parameter always has to be copied /moved to the coroutine frame? Seems wasteful that it first had to be created on the stack in order to pass it to the function itself and then immediately move it to the heap.
Books
books, any good website or youtube channel etc. that can help me understand and learn cpp.
Check the FAQ
https://stackoverflow.com/a/388282
thanks
For UI simplicity, go with text editor that can compile files. **Visual Studio Code** is my pick in this matter. Install the C/C++ extension from the market. 2 clicks away and its ready to use. Another option would be **QtCreator community edition**. It's free, has awesome autocomplete, go-to definition, and suggestion, low on resource, runs everywhere, and would be relatively easy to teach GUI programming because it has built-in WYSIWYG designer. Students who are interested beyond the scope of the class can learn more on their own and use it to develop marketable software, so that's another huge plus to keep in mind. I use it everyday. Last but not least, **CLion**. Its a paid IDE, but fortunately JetBrains (the company behind it) gave 1 year extendable free license if one can provide a student email. Its downside is huge resource consumption (1.5GB+ RAM on my laptop after build, 500-800 MB idle with unused extensions disabled). Note: I'm aware of **Visual Studio** **IDE** (not Visual Studio Code), but since its not cross-platform I don't recommend it in educational setting.
In my experience vanilla VS intellisense is good enough for standard C++ since VS 2015 and getting better at every new version. I have been sort of forced to use VAX in the last couple of years because with Unreal Engine 4 it's the only way to get decent completion. Resharper, tried some years ago, nice features but horribly horribly slow.
\&gt; Fortunately, there is a way around it, by [installing Docker Engine - Enterprise](https://www.kauffmann.nl/2019/03/04/how-to-install-docker-on-windows-10-without-hyper-v/). Don't you need to purchase a license to use this?
If you follow the link, you can find this: &gt; Why do I start with this? Because both Docker Desktop for Windows and Docker Engine ‚Äì Enterprise can be downloaded and installed for free.
Visual Studio Code. It's easy to set up, and can provide decent IDE features even if you don't bother to set up all the integration with the build system and whatnot.
Yeah but can you use it for free? You can download and install a lot of stuff for free, but you're required to have a valid license to use it, even if the software doesn't enforce it.
I appreciate what Herb's trying to do, and I'd be interested in seeing the results, but I think picking 5 specific papers out of ~300 is quite difficult -- I can't imagine anyone is familiar with the contents of all of those papers, or has the time to go reading them all before making a decision. I think it might have been better to select a small number of "headline features" (maybe 20 or so) and say, "which of those would you like us to focus on for C++23? Please pick your 1, 2, 3 in order."
Or you could fix it by using an init-statement in your range-based for loop.
you are correct
which compiler? msvc can actually optimize them somewhat well
I agree with the sentiment, but it's really hard to "accidentally" co_yield since you need to call something that returns an awaitable AND it automatically makes you a coroutine (so you better already be implementing an awaitable or it'll just be a mess of compiler errors)
The [Docker Enterprise documentation](https://docs.docker.com/ee/supported-platforms/) lists Docker Enterprise and Docker Engine - Enterprise (Docker EE) as two separate products and has links to purchasing options for Docker Enterprise. Further, it says: &gt; This gives Enterprise users the ability to install as many CLI packages as needed without using the Engine node licenses for client-only systems. Which implies that using the Docker EE CLI does not require a license. The naming is somewhat terrible, I'll admit. Also, poking around the Docker CE docs, it seems that Docker EE is the only way to run Docker on Windows Server.
"bottom five" might be more fun to read
&gt; A fellow teacher recommended Dev C++, which is something that a lot of programmers I know curse to death. I also have thought of Turbo C++ which features a very simplistic UI, but that's only because it's from the ages long past. Please don't do either of these things. Do not teach current students yesteryears programming. Teach them modern C++17 using Visual Studio Code. It's free and open source and works on Linux + Windows + Darwin.
Would it help if I just listed my proposals here, and then you can stuff the ballots?
I have absolutely no idea which proposal numbers correspond to the features I want. I would have really appreciated a drop-down list of proposals to choose from
To be clear, please don't stuff the ballots. There is no boaty-mcboatface proposal. This is a helpful chance to give feedback.
You really have no idea what emacs is do you? "Without any feature" is very much not what anyone that knows the least bit about it would say. Emacs is really powerful. That said, I defo wouldn't advice a beginner to use emacs, since it can be daunting to learn how to use effectively. VSCode Is a lot more user friendly and does most things you might want, specially once you add some plugins.
I hate docker. And wonder why people so like use such hyped technologies...Just crap. Why you even tried docker for c++ ? For c++ it's not needed - when you compile your application with statically linking it will run basically everywhere...
I skimmed so far 8 of the 13 pages of proposals, seeing nothing so far that hit me as useful. Though some titles hinted at being essentially (design level) bug fixes. I guess if I delved into those, then some I might agree with. The &lt;b&gt;most important&lt;/b&gt; to me would be to not break existing code by changing the return type of `std::filesystem::path::u8string`. One can work around it changing all use of it in existing code to inefficiently copying the result bytewise to a `std::string`. Changing the return type to something incompatible is just so dang harebrained when viewed as something intended to be positive, an advantage. It's like whoever proposed that is, instead, waging a very narrowly focused war against use of C++ in Windows.
So you're saying one can fix dangerous use of temporaries by not using temporaries? https://i.imgur.com/PWG5trk.jpg
Are we trying to change it from `string` to `basic_string&lt;char8_t&gt;`
Why do you hate docker?
Yes, according to the documentation at [cppreference](https://en.cppreference.com/w/cpp/filesystem/path/string).
I used it mainly as a container for applications in AWS cloud. Here's a list of issues I had: 1) Deployment time is increasing dramatically. For example on AWS elasticbeanstalk you will wait around 15-30 minutes to deploy your binary. 2) Hard to configure proper logging. 3) Issues with debugging using gdb (for me it wasn't work at all) 4) Your process is running from root user by default (security risk). 5) If your process is writing many data to disk. For example logs - it will break a container after some time. And you will face with unexpected downtime. It's just too risky to use in production...
This is because we want char8_t to mean utf8, whereas char might mean anything. char often means "code page" on Windows. But u8string was always meant to mean utf8, not "some 8 bit thing" (IIUC).
The one linked on his blog post was clang I think
&gt; which part is at war with Windows? In practice, in Unix-based system the ordinary conversion to string gives UTF-8 encoding. Code that should be portable to Windows or is designed originally for Windows, needs to use `u8string` to guarantee UTF-8 encoded result. Until recently Windows did not natively have an UTF-8 locale, and such locale was not supported by the C or C++ runtime libraries. The change breaks all correct existing UTF-8 based Windows code that uses `std::filesystem::path`. I don't know how much code that is.
kdevelop (or Qt Creator). Reasonably intelligent suggestions, reasonably easy to use.
Agreed! The format is basically useless if you don't have an hour to spare to read through the list.
It's a survey of a sample of developers reading Herb's blog. By voting the ones we know about (which I did) I suspect Herb is going to go to the ISO C++ committee saying something like: "So I run this survey and the feedback says we should work on... oh, MY proposals! So should we start with Zero-overhead deterministic exceptions or Lifetime safety?"
So code that wants to be portable was calling u8string on both windows and posix, and could just use it on posix (in a string), but couldn't just use it on windows (unless they were in the UTF8 codepage). So they either wrote extra code on Windows, or they just passed along a string and Windows took it as a code-page string, and it happened to "work" because it was ascii. Or are there another scenarios? I'm not trying to argue, I'm really wondering if this will break code. It seems fundamentally wrong that the u8string function would return an ambiguous char type (ie `char`) instead of a stronger type (`char8_t`), so we want to fix it, and might be OK with breaking a few eggs here and there, but we also want to limit breakage.
I guess the idea is if you ever have foo().bar() in your for loop to write the following and you'll be a lot safer for ( auto range = foo(); auto x : range.bar() ) { ... }
Good point, maybe I should list my proposals.
I feel dumb, but I can't get all the pieces to fit together: if asio makes a copy of your handler, but the function that makes this copy goes out of scope before using the copied object, this copy necessarily lives in the heap, doesn't it ? If it is so, shared\_value is not useful in this case because it was allocated on the heap, that's what shared\_ptr is for. And if asio does not allocate the copy on the heap, it means this copy lives in the stack, which already manages the lifetime of the object for you (and thus no need for shared\_value, just a reference\_wrapper would make it copyable). I suspect asio allocates the copy on the heap. That doesn't mean shared\_value fails to do what you want it to do, I guess your implementation works as well for heap allocated and stack objects. But you would still get the allocation you were trying to avoid.
Windows-specific code based on UTF-8 converts to/from UTF-16 for the system API calls. Portable code needs not necessarily do anything special on Windows. That was one of the main original motivations for the file system library. Without it, one would need to treat Windows specially. With the proposed change that special casing of Winodws will again be necessary, and now with some needless inefficiency added, so, it's braindead when viewed as something intended to be positive. Instead of changing an existing function, *add* a function.
Yes, that fixes it, but that's not the point. `foo().bar()` shouldn't be dangerous in the first place.
Oh my brain hurts, I tried to follow boost from io\_service::post() to anything that looked like an allocation for the handler and I stumbled upon (boost/asio/impl/io\_context.hpp, line 198): `// Allocate and construct an operation to wrap the handler. typedef detail::completion_handler&lt; typename decay&lt;LegacyCompletionHandler&gt;::type&gt; op; typename op::ptr p = { detail::addressof(handler2.value), op::ptr::allocate(handler2.value), 0 }; p.p = new (p.v) op(handler2.value);` called from io\_context::post (line 215 of the same file). &amp;#x200B; I don't pretend to understand what is going on, but this seems to point towards the heap allocated copy hypothesis!
Most of these are as abstract and computer sciencey as Haskell and Lisp combined, with maybe a touch of Java. I love C++, it's great, everyone knows how to use it... But hasn't it gotten a little out of hand? Most of those titles look like you'd have to read the whole paper to even know what they're talking about. It reminds me of CoffeeScript. You can add to a standard library almost indefinitely, and you can add plenty of little things like decorators and comprehensions, but when you extend the language itself like this, the concept of "Knowing C++" ceases to exist. Because there's tons of extremely complicated addons, and any given project will use 10 of 50 of them. The effort to learn becomes essentially equivalent to learning several different languages, and you can't expect any consistency on any given project. The big thing C++ needs is built in support for finding libraries, like how python just knows to search in the current directory, and the configured search paths. The inability to just copy and paste a module into your project or install a popular lib through a packet manager seems to discourage using libraries a bit. Other than that... C++ is fine with me mostly as is.
None of these examples are fixed by that. The dangling happens before we even enter the for loop.
 &gt;&gt;&gt; "rust" &gt; "c++" True &gt;&gt;&gt; "rust" &gt; "java" True "dominating"
I think its more comparable to a function executed by a thread, as theyre both concurrent execution. Youd obviously not want to pass temporaries by const ref to either. Spinning off a thread is still a lot more visible than a function having one of these new coroutine keyword/operators hidden in there somewhere. I wish it was more obvious from the callers standpoint a coroutine is being kicked off.
That's what I use and it's a good choice. Not perfect by any means, but it's free, it works well enough, it's being actively moved forward, and it's the same on Windows and Linux so it's good for cross platform work.
What about for( auto&amp; x : f().g().h().i().j().k() ) { ... } How many temporaries do you suggest we keep for the entire duration of the for loop? That's a major change to the C++ standard compared to a minor alteration of the best practice for a range-based for loop with temporaries.
This is probably inviting ~~a flame war~~ a productive discussion, but mine are: **P1031** We desperately need a C++-native, fully type safe solution for file-level IO. Right now the C FILE* interface is ugly, prone to bugs and not really "portable". **P1030** std::filesystem::path is severely neglected in many areas (e.g. the lack of an iterator range constructor). This fixes one of those areas. **P1636** C++ types and algorithms (the standard library in general) should interoperate as much as possible. This is one step towards that interoperability. **P1729** With the advent of to_chars and from_chars, and formatting, the natural extension is scanning. **P1750** This, along with the proposal for loading dynamic libraries, makes C++ even more fully portable. Right now there are a few places left where you have to go down to the OS level to do language-level stuff, and this removes one of them. Also: * p1306 Expansion statements * p0323 std::expected * p0627 Function to mark unreachable code * p1310 Unifying the many ways to compare * p1228 std::concat
You still only need one to capture the result of `.k()`.
I can't find the async proposal about eliminating co\_ prefixes. Is it missing in the list?
That would have to be done in 20. The list is about 23.
I dont think the people who read his blog read only his blog and probably wouldnt be particularly partisan toward his proposals.
 int main() { for (std::string s = "hello world"; char ch : explode(s)) { std::cout &lt;&lt; ch &lt;&lt; '\n'; } } That doesn't help?
Oh, sure. That does. But nobody should have to write that. I don't consider that a solution.
Dominating labour office compared to java and c++, yes, thanks for repeating my joke...
Yeah, I'm sorry to say this, but this is a terrible idea and completely impossible to implement.
Why? It wouldn't be that hard to write a transpiler...
Does anyone know if there are any compilers out with early support for static exceptions? I'm particularly interested in compilers that run on FreeBSD.
So, a bad version of Python then?
Seems like you haven't thought things through. &gt; (optionally) use () for calling all methods (like C++'s cout and cin, which use &lt;&lt; and &gt;&gt;) Which operator would it use? cout doesn't just have `operator&lt;&lt;`, but many. How would an operator be chosen? Also what if the class already has an `operator()`? &gt; trailing semicolons (;) optional What's the parsing rule for this? Tentative parsing? Seems expensive. int a = b + 3 *f(c); // the compiler needs to parse this and decide whether it belongs to the previous statement or not &gt; (optionally) import -&gt; #include and declare -&gt; #define as well as other aliases to make your life easier Meh doesn't seem very important &gt; automatically detects variable type if none is passed int a; { a = 10; // does this declare a new variable? } &gt; (optionally) + for string concentation We already have this: "you are"s + std::to_string(age) + " years old" &gt; produces readable C++ using default headers instead of using external headers don't understand this IMO your improvements are very superfluous, they don't improve the language in any considerable way.
If enough people participate, it could be pretty interesting to data-mine the results to find correlation between clusters of papers and clusters of programmers selecting them, to identify the "kinds" of programmers caring about the C++ standard. My own top 4: **P0593** Implicit creation of objects for low-level object manipulation **P1759** Native handle from file streams **P1112** Language support for class layout control **P0205** Allow Seeding Random Number Engines With std::random_device
Disclaimer: I am not a lawyer. However, this is explained clearly by https://visualstudio.microsoft.com/vs/community/ in the "For organizations" section: &gt; An unlimited number of users within an organization can use Visual Studio Community for the following scenarios: in a classroom learning environment, for academic research, or for contributing to open source projects. &gt; For all other usage scenarios: &gt; In non-enterprise organizations, up to five users can use Visual Studio Community. In enterprise organizations (meaning those with &gt;250 PCs or &gt;$1 Million US Dollars in annual revenue), no use is permitted beyond the open source, academic research, and classroom learning environment scenarios described above.
By the default headers thing, I meant that instead of writing my own headers, the language would use C++ headers like iostream. I also am just starting C++ so was not aware that some of these features already existed (I also found c++ auto type just noe).
This was also supposed to be a transpiler to C++ rather than a full featured independent programming language
!remove
OP, A human moderator (u/STL) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cc1w1x/check_out_my_design_for_c/etjwsqs/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
although Python is a language I like a lot, it is interpreted and does not provide pointers etc. It also consumes more resources (although projects like MicroPython exist)
Sorry I edited the message, pls read the edit.
By the default headers thing, I meant that instead of writing my own headers, the language would use C++ headers like iostream. I also am just starting C++ so was not aware that some of these features already existed (I also found c++ auto type just now).
You overestimate high school students. Many of them are just doing the programming course randomly and aren‚Äôt interested. You would overwhelm them with setting up ‚Äúmagical‚Äù tools like compilers in vscode.
I think I found what I am looking for then. thanks everyone for spending time on this.
fmt seems awesome, plus the second answer on [https://stackoverflow.com/questions/2771266/semicolon-in-c](https://stackoverflow.com/questions/2771266/semicolon-in-c) told me why semicolons are good thing and semicolon insertion can lead to problems like in ECMAScript/JS
Deleting this post now
You should not be teaching them C++ at all, unless they are really excited and actually asked for it. If Scratch is what you are teaching right now, perhaps continue with Javascript or Python. If that‚Äôs not an option, try as hard as possible to keep them in the browser. Nobody wants to headache of installing and configuring Qt correctly or whatever IDE+compiler(+build system) you might choose. I realize this might not be a great response for the cpp subreddit, but in my opinion C++ should not be taught to high school students because of how difficult it is to teach correctly. The amount of dragons and edge cases behind every single corner of the language makes it very unsuitable to develop an intuition for how things work. C# or Go or Python are all leagues better at this.
&gt;How many temporaries do you suggest we keep for the entire duration of the for loop? I don't suggest anything because I don't think this can be fixed without major semantic changes. But if doing that was somehow realistic I'd say either: as many as it's goddamn needed for the program to be valid or none, but the code like this won't compile in the first place.
I firmly suggest you to quit this project as you're too unexperienced.
No. There isn't even a spec, I believe.
Yes, it isn't erased; the erasure happens (using it) in poly_any or poly_view's ctor.
The problem of the example is the API. If you don‚Äôt want people to pass temporaties, force them to pass a string&amp;, or let the function return a value.
"proposal to make unsigned integer overflow undefined behaviour, to improve consistency with signed integers"
How would you deal with lifetimes? Can you pass this anonymous type around? Why not make it syntactic sugar for a stringstream or similar? If I remember correctly C# implements it as syntactic sugar around string.Format, which is unsurprising. Perhaps make it syntactic sugar around the fmt library?
Is anyone else able to get this to actually work - I get the exact same warning even if I comment out the move operation. [https://godbolt.org/z/-4VCxu](https://godbolt.org/z/-4VCxu)
Is there such a proposal? I think it makes sense to add unsigned integer types where overflow is UB, and signed integer types with wrap around behaviour, but I don't think the existing types should be changed.
Well o guess it's time to talk about the elephant in the room here: how is this supposed to work out in the future? The committee will never be able to review let alone discuss all these papers. We lose a lot of great ideas that way and discourage people to spend time writing these papers.... What about creating an interactive community where people can discuss, criticize and vote for proposed papers to create a ranking of the most wanted features? This would help the committee prioritizing the papers and get valuable input from the community. Maybe something like this already exists....?
I'd prefer that to desugar `f"a is {a}, b is {b} and c is {c}"` to something like ::std::interpolated_literal{ ::std::array&lt;::std::string_view, 4&gt;{"a is ", ", b is ", " and c is ", ""}, ::std:::make_tuple(a, b, c), } where namespace std { template &lt;typename... Values&gt; struct interpolated_literal { array&lt;string_view, sizeof...(Values)&gt; chunks; tuple&lt;Values...&gt; values; }; }
&gt;Why not make it syntactic sugar for a stringstream or similar? &gt;If I remember correctly C# implements it as syntactic sugar around string.Format, which is unsurprising. Perhaps make it syntactic sugar around the fmt library? I think the intent is to not tie it into a specific part of the standard library. This way, if someone wants to format with some not-yet-invented library, they aren't out of luck. If someone wants to use this to produce a `QString` instead of a `std::string`, they aren't out of luck. If someone wants to do some fancy constexpr processing to modify the final output, they can. It's a lot more flexible to not tie the language feature into a specific library feature. This flexibility is similar to how user defined literals work.
It turns out language design is not simple.
I personnally submitted : * P0707 P0707 Metaclasses: Generative C++ * P0443 A Unified Executors Proposal for C++ * P1750 A Proposal to Add Process Management to the C++ Standard Library * P1485 Better keywords for the Coroutines TS * P0959 A Proposal for a Universally Unique Identifier Library
&gt; How would you deal with lifetimes? The idea is to capture by reference by default, but I plan on adding syntax/options to either have a lambda-like capture list, or to move rvalues into the cgenerated closure. --- &gt; Can you pass this anonymous type around? Sure, either use a template or type erased wrapper. --- &gt; Why not make it syntactic sugar for a stringstream or similar? Why would you do that? It restricts the use case for the literal to a particular library facility. I'd rather have the literal be independent from any printing/streaming facility, and provide a customization point. --- &gt; When I think about this it is purely syntactic sugar for an intuitive thing. The problem is that hardcoding this to anything specific (e.g. string or ostream) is a terrible idea, as it prevents it from being natively usable with other third-party libraries and adds overhead. Lambdas are anonymous types as well, and they work pretty well. Everyone loves them. --- &gt; does this deal with raw string literals? Not yet, but this should be explored in the future. A 'fR' prefix sounds reasonable.
I considered something like this, but I see it as more complicated/unnecessary. For starters, we're adding a dependency on std::array, std::string_view, and std::tuple. There is a compile-time impact for these. The second problem is that it doesn't handle positions well - what if the first expressions is at the beginning of the string? What if one of the expressions is repeated twice? What if there are multiple expressions in a row without strings in between? This model causes a lot of ambiguity IMHO. --- &gt; It can also be overloaded on. My proposed technique can also be overloaded on, unless I am missing something.
appveyor?
&gt; For starters, we're adding a dependency on std::array, std::string_view, and std::tuple. There is a compile-time impact for these. Fair enough, but these don't have to be exactly these. `string_view`s can be replaced with char array references, and both values and chunks put into unutterable generated tuple-like (in the structured binding sense) types. &gt; The second problem is that it doesn't handle positions well - what if the first expressions is at the beginning of the string? What if one of the expressions is repeated twice? What if there are multiple expressions in a row without strings in between? Interpolated literal with N values always has exactly N+1 string chunks interleaved with them, some of which can be empty. Repeated expressions don't need any special treatment. Surely you don't propose to deduplicate them and change side effects? &gt; My proposed technique can also be overloaded on, unless I am missing something. Yes, my bad.
Not sure I understand your question, but I'll take a guess. I test my software on AppVeyor, but sometimes it doesn't work. Instead of debugging by pushing a commit and waiting for AppVeyor to give me the next error, repeated 300 times, I'd like to have a container that I can iterate in locally.
I vote we wait for reflection/generation. By the time this is baked we'll hopefully be able to just implement it with reflection.
Extremely not confident in that. How would you be able to parse a string for valid expressions even with reflection? How would that work?
If you can access identifier names at compile time (i.e. in a constexpr context) through reflection, and you can parse the interpolated literals in a constexpr context (which we already can do, see the talk by Dusikova and the one by Turner and Deane, they both touch on constexpr parsing), you can then do the right thing using some metaprogramming.
Thank you! This is a godsend.
ayyy nice! I am super glad it was helpful :D
"Runtime equivalent of #include"
Also you don‚Äôt need to, you can just find stuff in {}s and emit that as code. If it‚Äôs not a valid expression you get a compiler error.
https://isocpp.org/files/papers/PO4116_emoticons.html
Changing signed integers to have defined overflow is a non breaking change though, it might make more sense to have int and unsigned int have the same semantics, and then introduce unwrapping_int and unsigned unwrapping_int. Less UB by default! :)
This for me is one of the huge problems of C++ compared to something like Rust By the very nature of the process, improvements to C++ are very slow, and bottlenecked extensively by committee. There's an argument to be made that this ensures quality, but lets be real - we've all seen the graphics proposal and how ludicrously bad of an idea that is There are tonnes of people who are relatively adept at C++ loitering around, C++ by its nature has a tonne of long term experts working with it. But the standards process isn't exactly... welcoming to new people - it seems to encourage people splurging a whole paper out, rather than collaborative discussion and building around concepts that need to be fixed in a group
There's an index: https://wg21.link/index.txt And a mailing: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/#mailing2019-06
It's a really short description for the feature so it may not informative for you. Sorry for that :( . What I wanted to share is that what I considered for both library and user code. For the article, will be glad to hear from you. I will update it with your opinions :)
What if instead, the format string literal evaluated to a tuple-like object containing the string with placeholders, and the values of the expressions? So `auto x = f"The result is {get_result()}\n"` would be similar to: template &lt;typename... Ts&gt; struct format_string : std::tuple&lt;Ts...&gt; {} auto x = format_string&lt;const char *, decltype(get_result())&gt;{ "The result is {}\n", get_result() }; If it inherits from std::tuple, then the std::get protocol would work, so reflection would be possible. The fact that there's a separate named type also makes it easy to add overloads that take format strings to existing functions, so a new constructor could be added to std::string if we want an easy way to create a std::string from a format string, or a new overload could be added to the fmt library to handle interpolated strings efficiently.
Minus 1 because it's a social argument, and there are enough social arguments.
After a first pass through the list, I had about a dozen I felt strongly enough that I wanted to vote for. Whittling it down to five was tough. Although a couple‚Äîgetting native file handles from fstreams &amp; static_vector‚Äîwere easy since they‚Äôre _long_ overdue.
I've just heard from someone else about this issue. I don't know why my clang is behaving differently, but you can fix this by annotating the constructor with \`\[\[clang::return\_typestate(unconsumed)\]\]\` [https://godbolt.org/z/2Ah\_cS](https://godbolt.org/z/2Ah_cS)
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1337r0.pdf
There needs the same process for removing old features...
I sometimes think of Herb as a wise father, so a part of me feels like this is meant as an indirect lesson in understanding how much work everything is, and don't take your features for granted young lad.
Less features, more small usability improvements. And please prefer small additions that cam incrementally be improved and extended over several standards.
I submitted * **P0645** Text Formatting * **P0707** Metaclasses: Generative C++ * **P0709** Zero-overhead deterministic exceptions: Throwing values * **P1371** Pattern Matching * **P1709** Graph Data Structures
Thanks for clearing that up, I'm no lawyer either, but it looks all good [one can at least claim to be of good faith, I would say].
Does reflection/ generation really allow you to inject such coffee into the calling context?
Over-generalization is the bane of c++
Single (canonical) implementations have it much easier because all discussion's are ultimately grounded in patches. Your feature works or it doesn't, and what's left over bikeshedding (can't go wrong with pink). If you're producing a multi implementation, multi stakeholder, standard language, specified in English languagese, things get much more speculative. What's easy in msvc isn't what's easy in gcc, and what Microsoft wants is not always what Google wants. Yet everyone's supposed to be able to agree on some English? Those other languages also give weaker guarantees on backwards compatibility -- let alone other language compatibility (C). Mostly because C++ is so widely used -- by your bank... and your airplane... that breaking compatibility is a billion dollar dilemma. Moving fast and breaking things is a luxury afforded to unimportant software. C++ has a harder problem to solve, and simply letting it be a free for all of semi-anonymous community commentary would exacerbate the problem by orders of magnitude. The thing is there's already a avenue to participate, and I constantly am disappointed to see the vast majority refuse to use it. It's sitting right here looking you in the face: committee members are here and now asking for legitimate actionable feed back that amounts to real work, and the response feels tepid. Most of the time when I'm in reddit and I offer to relay commentary from reddit posters they become blithe and dismissive, even combative, and then disappear back into the ether. Look at committee members in this "room". They're interested in expanding the accessibility to the process. Herb is asking for survey results. Take advantage! There might be some real work involved though.
It'll scale with greater community participation in filtering out or improving papers. This here is the first step -- sadly it turns out this is work...
The find symbol or file feature is unpaired AFAIK, thanks to its fuzzy mode.
Well, it seems to be a MFC - Microsoft Foundation Classes code using Visual Studio Solution/MSBuild as building system. So, you need at least Visual Studio community edition to compile it.
Hey, thanks for the response! I downloaded Visual studio community 2019 and I was reading the help webpage for it. But it was all for really simple examples. I have no background in C++ so I don't know how to translate the simple example to what this is. Can you point me towards something that can show me how to compile using Visual Studio?
Try opening the meshes.sln file from the root of the project. Then find option for building the solution. (I don't have the environment handy now so I can't give exact instructions.)
It seems that you need to install MFC Microsoft Foundation Classes. I am not sure if it comes bundled with Visual Studio community edition. Well, if you have all the dependencies needed to build the project. You just need to open it on Visual Studio and click at build project in the menu. If this application uses 3D stuff, it is likely that you also need to install DirectX or OpenGL libraries. There are lots of videos showing how to compile on Visual Studio, search for "compile build C++ project visual studio IDE" &amp;#x200B; Here one that I found: [https://www.youtube.com/watch?v=YOLN-t09-tM](https://www.youtube.com/watch?v=YOLN-t09-tM)
My recipe: Conan + CMake + Conan Cmake Script + QTCreator. Conan fetches all dependencies you need, builds them on demand storing the object-codes locally, once they are compiled they can be reused on many different projects saving time and disk space. C++ package managers built as CMake scripts falls short as they cannot use packages that does not use CMake as building system and they will not be able to handle a package using GNU autotools.
Have you gotten to arrays, vectors, for loops, while loops yet?
&gt; MFC - Microsoft Foundation Classes biiiigg oof
Thank you! I am just installing the required libraries as it gave me an error when I tried to build
Thank you! They are installing now. After I build will I be able to save it as a .exe I can just double click to run?
For me : * P0707 - metaclasses * N4028 - standard ABI * P1371 - pattern matching * P1221 - parametric expressions * P0709 - zero-overhead deterministic exceptions
Make a class. Think about why classes need to have constructors and destructors.
uhh, what is a class?
im close
Yes, it will build an executable .exe file and/or shared libraries \*.dll's files. After building you can copy it alongside the DLLs and use it. Good luck.
Read up how to push_back elements into a vector and how for loops work. Then 1) Read two numbers n and m from the user 2) Create a vector 3) Loop from 0 to n - 1 with i being the current index 4) push_back into the vector i * m 5) print out the elements in the vector This is is just something you can do on top of my mind, there are probably more interesting things out there but this is not a bad start. Feel free to dm me if you have any questions or want follow up problems.
Make a program which takes number of hours worked, and hourly wages, and computes total wages earned. If they worked overtime, they get paid 1.5x their normal rate for anything over 40hrs.
Yup it's there. Thanks for all the help! This is likely now out of the realm of compiling this to get it to work, but when I run the program as intended and import a file that it claims to support, it seems like my display drivers crash and my screens stop working. I have to hard reset my computer to get them back on. Any idea if this is an issue with how I did the compiling? Or is it specific to this code and I'm out of luck?
Why don‚Äôt you have a crack at making Hangman
Do you mean this proposal? [https://github.com/cplusplus/papers/issues/373](https://github.com/cplusplus/papers/issues/373)
\&gt; it seems like my display drivers crash and my screens stop working. I have never had any issue like this. &amp;#x200B; \&gt; Any idea if this is an issue with how I did the compiling? It has nothing to with the compiling, no program is supposed to crash the display driver. You can try to build it on another Windows Machine. One thing that sucks on Windows is that when it crashes, it does not give any almost clue to users about what happened. If you are running Windows 10, it shows a blue screen with a QR code and an error message that you can use to search on google or any other search engine.
actually i kinda like this idea
I usually recommend https://www.codingame.com/start. Enjoy the problems!
You will probably be confused my explanation, so I would recommend checking out a beginner's tutorial on object oriented programming. Classes are one of the most important features of C++, in fact, the language used to be called "C with classes". A class is a "blueprint" which you define, that can be used to create multiple objects . For instance, if you were making a game and decided to add ten enemies by defining variables (such as name, health, etc) for each enemy, it would soon get very messy and difficult to use. Classes can define the "blueprint" to be used to create new enemy objects. These objects store the data for each enemy.
would i use int or double
Edit: This code uses OpenGL, so it may seem something related to the video card driver. An OpenGL installation is also required to build it.
Hm, I also have an error message pop up sometimes telling me it's trying to write to memory 0x0000000000000000 and asks me to try and debug. Then my screens go black, no blue screen at all. I will try it on a different machine in the morning as well
Yes, but wrapping is often not what you want and making it defined could hide a lot of bugs because compilers, sanitizers and other tools would not be able to tell you about it. That said, I would like to be able to write *a + b - c* without having to worry about the order as long as the end result fits in the resulting type.
# Abstract [P1754](https://wg21.link/p1754), or *Rename concepts to standard\_case for C++20, while we still can* is a proposal with a single, abundantly clear goal outlined in its name: to change the naming convention for all standard concepts from `PascalCase` to `snake_case`. Examples in P1754 are sadly lacking: it would have been nice to see an algorithm or two with the differences displayed side-by-side. I was curious about what it would look like, so I decided to contrast the two using the library that‚Äôs benefited from concepts the most: our algorithms library.
This code uses OpenGL, so it may seem something related to the video card driver. So, try updating the Video Card. An OpenGL installation is also required to build it. In this search: [https://github.com/agentmorris/MeshTools/search?utf8=%E2%9C%93&amp;q=gl\*&amp;type=](https://github.com/agentmorris/MeshTools/search?utf8=%E2%9C%93&amp;q=gl*&amp;type=) it is possible to see many OpenGL functions used by the project.
Ok that gives me a bit of hope! The machine I'm using right now is a desktop with a GTX 1070 in it. I'll try a machine with an Intel integrated card tomorrow as the program is not meant to be intensive. If it built properly that means I have OpenGL installed already correct?
I like gitkraken, I made my manager to buy one for every team member. lol
Try with `double` first. Once you have that working the way you like, try with `int`, and see how it works. See what difference it has and if you can still get it to work the way you like.
Yes, but it may not build if you don't have OpenGL library installed and it does not come pre-installed with Visual Studio or Windows.
A great source of tasks can be found on competitive programming platforms such as: Open.kattis.com Hackerrank.com Sort by difficulty and choose some of the easier ones.
The `BaseImpl` and `Base&lt;T&gt;` are completely irrelevant in this code. Same as `OtherBaseImpl` and `OtherBase&lt;T&gt;`. The The Consumer class works literally identical as: class Consumer { public: BaseImpl base; OtherBaseImpl other_base; void run() { base.doSomething(); other_base.doSomethingElse(); } }; And it has nothing to do with compile time polymorphism, because there is no overloading of functions or classes at all. A more clear example of compile time polymorphism would be something like this: class dog { public: void say() { cout &lt;&lt; "woof" &lt;&lt; endl; } }; class cat { public: void say() { cout &lt;&lt; "meow" &lt;&lt; endl; } }; template&lt;class petType&gt; void call_pet() { petType p; p.say(); } int main() { call_pet&lt;dog&gt;(); call_pet&lt;cat&gt;(); return 0; } In the example the same function name '`say`' is called, but they'll run different functions because of compile time polymorphism.
Ok, I'll keep trying to get this to work. You've been extremely helpful thank you! If I get a successful run I'll be sure to update you.
Write a function that takes an `int` as input and draws a diamond using semicolons where the width of the diamond is twice the input. First make the diamond hollow then filled.
&gt; There's an index: https://wg21.link/index.txt That is a fifteen thousand line text document.
&gt; Spinning off a thread is still a lot more visible How come? A call to `std::async` inside a function isn't more visible than co_* word. I do agree with the comparison to threads. The implementer must decide between taking the parameters by value or warn the callers by naming convention (blahAsync) or documentation.
\#include &lt;iostream&gt; \#include &lt;string&gt; int main() { int h =0; double p =0; double o =0; double e =0; std::cout &lt;&lt; "enter number of hours worked\\n"; std::cin &gt;&gt; h; std::cout &lt;&lt; "enter your hourly pay\\n"; std::cin &gt;&gt; p; if(h&gt;40){ o = h-40; } //pay rate e =h\*p+(o\*p)\*1.5; std::cout &lt;&lt; e &lt;&lt; " is how much you made!"; }
i did it
FUCKING SEMICOLINS
What are you even talking about...?
Ah I see! So only the actual consumer class is templated and you can pass whatever types you want as template arguments as long as they implement a method with the correct signature. That's much simpler, thanks!
I use Clang &amp; Visual Studio on Windows and I can say there is a huge improvement. It's no more a pain in the ass to install. The only thing missing is proper documentation. You have to use MSVC style options or '-Xclang -CLANG\_STYLE\_OPT', but the linking is done by MSBuild so it brings tons of confusion. Actually, at the moment, the problem is more to find cross-platform compiler options than to write cross-platform code, which is straightforward using Clang on every platform.
There's a GitHub issues list: https://github.com/cplusplus/papers/issues?page=1&amp;q=is%3Aissue+is%3Aopen+-label%3Ac%2B%2B20+-label%3Ainfo+sort%3Acreated-desc&amp;utf8=%E2%9C%93
Not the previous poster either, but I like Rust's names for them (`Box` and `Rc`/`Arc`, respectively).
Core Coroutines: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1063r2.pdf Unifying Coroutines TS and Core Coroutines: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1342r0.pdf Coroutine TS + Core Coroutines: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1362r0.pdf
Why is it a terrible idea? When using streams there won't be any hidden cost. It is simply the cost of streams. Right now using streams makes formatting stuff (especially for lots of variables) really unreadable. Consider: std::cout &lt;&lt; "Two numbers: (" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; "), A string: \\"" &lt;&lt; s &lt;&lt; "\\"\\n"; Adding syntactic sugar: std::cout &lt;&lt; f"Two numbers: ({x}, {y}), A string: \\"{s}\\"\\n"; It is unsurprising and simple. There are no lifetimes to consider (everything is evaluated as-needed like streams) and it solves an actual problem people are having. You want to introduce more problems and complexity so it will be easier to use your feature incorrectly.
Just submitted: * P1682 `std::to_underlying` for enumerations * P0051 C++ generic overload function * P1206 `ranges::to` * P0849 auto(x) * P0847 Deducing `this`
In general ctrl shift b will build.
Great job! Now see if you can modify your program to include double overtime. Includes extra case for any time over 50hrs gets payed at 2x rate.
I don't think the committee is the bottle neck. The intrinsic complexity of c++ + backwards compatibility is. For every new feature must be designed in a way that - It doesn't break (too much) existing code - It meshes well with other aspects of the language - Is friendly to beginners - Satisfies all the various stake holders There is an intrinsic limit of how much change you can absorb into a complex language under those constraints without shipping something completely broken and without getting feedback from production. That is not to say that the standardization process itself could not be improved in particular situations, where the design of a feature gets discussed for a week and then, after a couple of months, the same set of arguments gets debated again - just with different people - is a problem.
interested as well
Actually, signed integers are more well-defined for C++20. A paper by JF Bastian, IIRC, defined them as two's-complement and changed some operations that are currently UB to be well defined.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cc75rl/new_to_coding/etl4fnj/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cc6un7/mechanical_engineer_trying_to_compile_code_to_use/etl4h3s/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!remove
OP, A human moderator (u/STL) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cc7nx0/clang_power_tools_mandatory_loging_seriously_now/etl4hsp/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
With VS2017 you can use the [LLVM Compiler Toolchain plugin]( https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.llvm-toolchain&amp;ssr=false), which allows you to use lld (and llvm-lib) as well (i.e. the whole tool-chain, required for using LTO). As mentioned on the plugin page, it does not support VS2019 [without having VS2017 installed]. I've reported [this](https://lists.llvm.org/pipermail/cfe-dev/2019-May/062402.html), but to no avail. I've also tried to fix the plugin, but did not succeed. I knew built-in support was coming [to VS2019], so I did not pursue it any further.
I was using VAX under VS2005\\2008\\2010\\2013(?) for nearly ten years, both hobby environment and work environment, it was giving huge and irreplaceable functionality those ancient days, though with poor performance.I have tried Resharper C++ under 2015/2017 sometimes but its buggy and lagging UI makes the wonderful modern VS experience gone. the most painful part is config syncing on different PCs, ugh.. I don't use them at least two years already, and find that none of them is actually needed for me, and licence are really expensive.
N4028 wasn't on the list unfortunately on the list, or I would have also voted on it.
huh, I thought that the list was https://wg21.link/index.txt
According to the survey itself, it's this: https://github.com/cplusplus/papers/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+is%3Aopen+-label%3Ac%2B%2B20+-label%3Ainfo+sort%3Acreated-desc
* /include for public headers * /src for source files and private headers #include "filename" or #include "something/filename" depends on project. Sometimes it makes sense, sometimes it doesn't.
I think just putting the papers in a list and let people vote is something easy to do and it would already give the committee valuable feedback. Ideally some continuous voting should be integrated on isocpp.org. Of course the committee is not expected to follow what people vote for but it gives them inspiration what is in demand and what's not. Let the community help with the process scalability. Thanks to Herb for trying this out for the first time.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/technologyaddicted] [\[ \] Clang\/LLVM Support for MSBuild Projects | C++ Team Blog](https://www.reddit.com/r/TechnologyAddicted/comments/cc8hpk/clangllvm_support_for_msbuild_projects_c_team_blog/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I guess the idea is that it would have bloated the interface a bit. Personally I wouldn't agree and I sometimes write generic functions that work with plain (templated) containers. But ranges and views are coming http://ericniebler.com/2018/12/05/standard-ranges/ so your issue would probably be resolved by them.
I found this answer: [https://softwareengineering.stackexchange.com/a/231351](https://softwareengineering.stackexchange.com/a/231351)
I am late again in the party. What sucks about Qt Quick QML is that the control flow is set up on the QML side. To use any C++ class with QML, it needs to inherit QObject. The event handler setting wit C++11 lambda is no longer possible. &amp;#x200B; QObject::connect(&amp;Widget, &amp;Widget::Method, []{ ... event handler ... }); Another problem is that QTCreator designer for QML is still buggy and not so responsive as the QtWidgets designer and sometimes it even crash when dealing with QML UI. With QtWidgets one can build the form entirely on the designer and load it at runtime from the from XML file. All the main code needs is to locate them by name and set up the event handler. The only advantage of QML is the deployment to mobile platforms.
The new "ranges" algorithms will allow you to do this. [https://en.cppreference.com/w/cpp/algorithm/ranges](https://en.cppreference.com/w/cpp/algorithm/ranges)
Ranges in C++2x fixes this.
I believe there is a Stanford course something like 106B (not sure if I got the course code correct) teaches the class in C++ but the concepts are primarily language-agnostic. They have one course that teaches basics of programming using Java and then the next is C++. Although it‚Äôs definitely not a comprehensive approach to C++ since universities tend to teach the principles of CS/Software Engineering, it might be what you‚Äôre looking for. There is also PluralSight if you don‚Äôt mind the cost of it. There are C++ courses on EDX as well like the ones from DartmouthX.
There are only four papers in those 300 that matters in my domain (constexpr cmath, constexpr numeric, rational, linear-algebra types). I guess your domain is over-represented in the list to make it difficult for you?
Fount it on youtube. Latest ones are by Marty Steep. Thanks.
Five things that should happen in C++23 (ranked by personally preferred priority): * Networking * Coroutine * Zero-overhead exception * Reflection * Pattern Matching
STL algorithms are designed to work on a pair of iterators which defines a range of data that meets certain requirements. Ranges improve that by using Concepts. Also, without Concepts you'll regret using a mere container parameter: if you put a non-container or wrong container there - you'll get pages of pages of error which can take you a while to figure our what happened.
[P0267R9](https://wg21.link/p0267r9) A Proposal to Add 2D Graphics Rendering and Display to C++ Please, don't. Just don't. This 248-pages monster is probably larger than the remaining 299 papers alltogether.
What you are suggesting won't fix the problem (the first one won't work with constants, which is one of the few cases where this helper actually does something useful, and the second one will ruin the perf). I'm afraid the only cure for this pattern is the indiscriminate orbital bombardment. Unfortunately, people keep reinventing "helpers" like this, because apparently no one likes to type the standard pattern "if (auto it = m.find(k); it != m.end())".
I always thought it was to remain compatible / transparent with the same operation using pointers, like this: std::sort(array\_ptr, array\_ptr + size) Never looked up though if that's really one of the reasons. But in this case you could afterwards change your array into a std::vector and the code would still compile and run.
That's it thanks
``` src/ inc/ privinc/ stubs/ test/ ``` This is how I typically organize projects (alternatively sometimes instead of privinc i use inc/details folder)
I think core coroutines are already withdrawn as there was a problem to implement it. It's explained in one of the Gor's papers. Coroutines TS are the way to go. I just hope there is enough time to polish all details like ugly keywords or compatibility with Eric's senders &amp; receivers.
Personally, I always preferred Pascal-style camel case for types and meta types, simply because it immediately recognizable. I also disagree that underscores make it more readable, but I guess that‚Äôs subjective. At the same time, C++ has been using lower-case for types and so I completely agree with proposal authors that standard concepts should be lower-case as well.
&gt; Instead of choosing an IDE, I'll be talking to our coordinator and probably make plans to push this to JavaScript... JavaScript normally means JavaScript + HTML + CSS and this isn't a clean introduction to programming imo. I'd much prefer that kids learned something like Python where there's much less noise to put them off with.
You might want to add examples with the `some_concept auto T` syntax.
Sorry for the posting again, the (removed) post in the morning was so bad that I organized it again. Will be glad to hear from you :)
&gt; If you can access identifier names at compile time That's what seems far-fetched to me. You basically want an API that takes a string and returns the entity in the closest scope with that name, if any. Sounds doable, but haven't seen anything like this in the Reflection TS.
I have actually never used std::async, only std thread and pthreads directly. So I might have to retract that statement.
Exactly. And that‚Äôs why it‚Äôs called ‚Äúcompile time‚Äù; because you have actually **two** different implementations of the temple class/function in the final compiled binary. The compiler just remap the call_pet&lt;dog&gt; &amp; call_pet&lt;cat&gt; to two different internal symbols, say, __call_pet__dog and __call_pet__cat, and each symbol represent one version of the implementation. In other words, the function call is already predetermined when compiling. The **runtime** polymorphism is based on virtual inheritance mechanism of C++. The real function to be call is determined when the instance of class is created, using a function mapping table attached to the instance. So there is no predetermined link in the executable binaries.
&gt; Why is it a terrible idea? I already replied to this. You are tightly coupling the language feature to a particular library type. What if you want to use your custom stream that uses a different operator? What if you want to assign the interpolated literal to a `QString`? --- &gt; It is unsurprising and simple. There are no lifetimes to consider It would be exactly the same with my proposal. No lifetimes to consider in that case, as the full expression is resolved immediately. --- &gt; and it solves an actual problem people are having. My proposal solves that problem, and more problems that your suggestion doesn't. --- &gt; You want to introduce more problems and complexity so it will be easier to use your feature incorrectly. The complexity is there for the reasons I've mentioned above. Possibility of misuse is real, with any other useful C++ feature. A safe-to-use feature that only solves a particular narrow problem is a feature that no one will use.
Actually, ~over~-generalization is what makes C++ thrive.
It's not really related at all. The main problem is that virtually all software in the 1990s and early 2000s ran on 32-bit operating systems/CPUs, so they expect 32-bit values to wrap. But on a 64-bit CPU, that should not happen. So C++ has to have a kludge for 64-bit systems that breaks the rules so that code written for 32-bit can be recompiled on 64-bit without breaking.
I am not against this, but you have to motivate why this is better than my current approach. I have some thoughts here: https://old.reddit.com/r/cpp/comments/cc2j0w/rfc_early_draft_of_interpolated_literals_proposal/etk5ldx/ --- &gt; If it inherits from std::tuple, then the std::get protocol would work, so reflection would be possible. You would be able to use my proposal to put stuff into a tuple and reflect on it if you want. I don't really see the point. --- &gt; makes it easy to add overloads It is trivial to add an overload in my proposal: void foo(InterpolatedLiteral auto myInterpolatedLiteral); --- &gt; a new constructor could be added to std::string [...] or a new overload could be added to the fmt library You could do the same with my proposal.
&gt; You would be able to use my proposal to put stuff into a tuple I don't see how. You would need to somehow pass type information across `f` invocations.
It's not about the latest C++, but I enjoyed this one. https://www.coursera.org/learn/c-plus-plus-a
1) not the right sub 2) at least post your approach, nobody will solve your homework for you!
You are correct, I was thinking about creating a tail of seen elements and passing it forward as an argument, but didn't realize that the `f` invocations are not chained with each other. I will think about this.
One possibility is to invoke `f` once, e.g. f(literal_tag{}, "The result is "); f(expression_tag{}, _get_result); f(literal_tag{}, "\n"); becomes f(literal{"The result is "}, expr{_get_result}, literal{"\n"});
That would work, though It's one step away from just putting them in a tuple.
These are not very difficult. Think of the logical operations which happen with each step, then Google the required constructs needed to express it in Cpp.
basically you're saying it's too hard to use raw tools. of course this is not true at all. it's dead simple. if anything it's easier when things don't work because you can see exactly what happened and debug it. it's hard to debug "linker error retry with -v for invocation" when you just pressed a button
you don't need an ide. use the command line.
My point is that I don't see the benefit in putting them in a tuple by default. I definitely want to allow it to be possible, but a function call seems more lightweight and conceptually simpler to me.
I mean, they would essentially be collected into a struct anyway, there is no benefit to not providing std::get protocol on it. Now, we could go the way of JavaScript template literals, i.e. instead of fixed `f` prefix, allow prefixing by any callable, which is immediately invoked when the interpolated literal expression itself is evaluated e.g: some_func"The result is {get_result()}\n" desugars to some_func(literal{"The result is "}, expr{_get_result}, literal{"\n"}); Then it would make sense, and also dodge the lifetime issues by giving the function control to do whatever it wants about that.
&gt; robust Tests? (especially since there are no visible atomics in the code, but I didn't spend too much time reading it) &gt; easy-to-use Why is the public interface buried under a pile of internal details, such as an incorrect hand-written replacement for [std::lower_bound](https://en.cppreference.com/w/cpp/algorithm/lower_bound)? &gt; fast Benchmarks? And why is the word "fast" there if the thing doesn't seem to be O(1) even for small allocations? What's the deal with stuff like this? //ensure we don't take too long trying to allocate, only search the first 10 blocks!! unsigned i = 0; for(auto it = end_basic_list&lt;memblock*&gt;(blockfreespace) - 1; it != begin_basic_list&lt;memblock*&gt;(blockfreespace) - 1 &amp;&amp; i &lt; 10; --it, ++i) { &gt; low fragmentation Demonstration please? Comparisons to tcmalloc and other well-known allocators?
This smells of homework question
I think this is good, though. They have been taught HTML + CSS in their previous school year, and a lot of them showed a good understanding of these technologies.
And it has the titles in one place so you can ctrl-f them. The difference is it's not limited in scope to this single meeting, so the mailing is more fit for this survey, but I'd say the index is worth a mention because it's quite useful in general.
&gt; I mean, they would essentially be collected into a struct anyway, there is no benefit to not providing std::get protocol on it. The most common use case scenario for interpolation literals is printing. You don't need to collect the elements for that for that. With the single function invocation: std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, InterpolatedLiteral auto il) { il([&amp;os](const auto&amp;... xs){ (os &lt;&lt; ... &lt;&lt; xs); }; return os; } std::string&amp; operator+=(std::string&amp; s, InterpolatedLiteral auto il) { il([&amp;s](const auto&amp;... xs){ (os += ... += il); }; return s; } If it used a tuple, you would have to use `std::apply` or some other unpacking mechanism. --- &gt; Then it would make sense That looks interesting, but it doesn't seem like it could nicely integrate with existing facilities such as `&lt;iostream&gt;`.
I am not saying it's too hard. What I am saying is to focus on teaching them how to do something cool rather them teaching them all the boiler plate and lower level stuff. You can go pretty far and build rather large project using Visual Studio Solution management without knowing how it works under the hood. If you have multiple projects, you can easily select the build order and dependency in the UI. Also, at a beginner level, I don't they will end up writing a software big enough to warrant linking with big external libraries and stuff like that. In the same vein, I wouldn't teach them raw arrays and stuff like that. Go straight into using vector, standard algorithm, string and higher level stuff so they can more easily write cool stuff like games. If programming still interests them afterwards, then they can go and learn everything else. To quote my other comment: &gt;Starting at too low level is how you end up pushing people away from programming IMO. &gt; &gt;When you first start to program, you want to make games, web sites, and other cool stuff. It's by easily allowing that that you can interest people in the craft. Of course, if they pursue learning the craft, they will eventually have to understand what the hell is happening at a lower level but at first, show them how fun and easy it can be to make something cool. &gt; &gt;Take two beginners, one in Python, the other in C++. By the nature of both these language, in a few weeks, the Python one could easily be taught how to create a simple game with a UI. The C++ one will still be making console app with endless segfault because "he needs to know how raw pointers and memory works before moving further". Stop teaching C, stop starting at the very low level and C++ can be a fun starting language.
Pairs of iterators make it easy to work on parts of containers. Splitting algorithm from container was a key part of the genius of the STL; compare with other language container libraries. Even something as simple as "treat C array as a container" is hard in C++98 C++. Today making subrange types is easy; when the STL was designed, far less so. The additions.of C++11/14/17 and soon 20 have made subranges continuously easier to work with.
Anybody managed to get this thing to compile multiple files in parallel. Both this preview build and the 3rd party LLVM Compiler Toolchain plugin compile everything one file at a time. Every online resource just repeats that parallelization is matter of toolchain, not compiler, so no support for MSVC peculiar way of parallelizing build is planned for clang-cl. Now I have tried the official LLVM support for MSVS and it is also not parallel... this is a bit disappointing for me :(.
Because the API is explicitly iterator-based instead of collection-based?
Mostly like the @ronchain 's answer. I saw some projects which uses `external` for the 3rd party libraries.
Look up `std::begin` :)
also a student who doesn't know how to communicate their issue with said question. And also probably isn't wearing enough deodorant.
Iterators are a bit more flexible, that way you can sort only a range from the underlying container
Then write it
I **really** want a Boaty McBoatface proposal for C++. Something like the not-actually-a-terrible-idea proposals you write for April 1st Tony. Except, bigger, grander, and even more actually a good idea. And named something better than "Templatey McVirtualFinal". Like a proposal which proposes a complete source-compatible C++ v2.0 derived from Nim, and the compiler would automagically parse each C++ v1.x and v2.x function based on inspection of the C++ language version used. (bats ball back to Tony ...)
A library implementation of P1095 formulation of P0709 can be found at https://www.boost.org/doc/libs/1_70_0/libs/outcome/doc/html/experimental.html
This whole thing is to be discussed at SG16 Unicode on Wed I think. What isn't entirely clear in the standard is that all Unicode operations upon filesystem paths apply at the level **before** the syscall taking the path. The syscall taking the path receives, and only receives, an array of bits with unspecified meaning and interpretation. We need to clarify the wording within the standard to make it clearer to end users that this is the case. Too many folk think that Unicode filesystem paths are interpreted as Unicode by the kernel, which is entirely understandable from the current standardese.
The current proposal is to leave Coroutines open ended enough that most of Core Coroutines can be grafted in for 23. I learned this the hard way this week, when I found that none of the existing Coroutines implementations are anything like up to date with the current TS.
I really hope this proposal goes through. It would be a shame to introduce a naming inconsistency for no reason.
!removehelp
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cc9fe8/i_need_c_or_cpp_program_for_below_question/etlidhm/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cc8yog/can_anybody_help_me_with_this/etliiry/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I focused on proposals that would (IMO) improve the language rather then fixing small things in the standard library (I don't really care much for standard library anyway): &amp;#x200B; P1371 - we simply need pattern matching, it makes so many things easier [P1095R0](https://wg21.link/p1095r0) \- fixing exceptions. I prefer this to P0709 because I don't I think that std::error is too limiting. Any type should be throwable. P0593 - we need this for standard-comforting high-performance data structures. But I think its already coming in C++20? P0957R1 - this is a bit weird one and I am not sure that I agree with the design presented by the paper, but I certainly agree with the idea. For the sake of sustainable design and performance, static and dynamic dispatch have to be be decoupled, which means making vtables first order citizens ‚Äî this way or the other
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cc8yog/can_anybody_help_me_with_this/etliodg/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I'm not familiar with the Avro APIs, but it looks like they also have `avro::StreamWriter`. There might be an even simpler way, but it seems like you could just use that to write to a `stringstream` and skip the file.
I was trolling. There is a proposal to make signed-integers better defined. The proposal is longer than the entire grammar spec for the Python programming language.
I just made a macro called ALL that would resolve to begin, end. It works pretty well.
&gt; The most common use case scenario for interpolation literals is printing. You don't need to collect the elements for that for that What I mean is that `li` is already such a struct. Providing tuple-like interface on it costs nothing. You can provide the `operator()` as well, but it basically duplicates `std::apply` at that point. &gt; That looks interesting, but it doesn't seem like it could nicely integrate with existing facilities such as &lt;iostream&gt; A `some_func` can be written that does construct a struct like you propose, with `operator&lt;&lt;` overloaded to stream out its members.
This here really made me wonder: unique_generator&lt;char&gt; explode(const std::string&amp; s) { return [s]() -&gt; unique_generator&lt;char&gt; { for (char ch : s) { co_yield ch; } }(); } If we cannot access the stuff we captured by value then why bother accepting async lambdas with non-empty closures at all? Turns out, there are different kinds of coroutines. AFAIU, the return type (in this case: `unique_generator&lt;char&gt;`) controls whether the coroutine is immediately suspended or eagerly executes until the first "obvious" suspension point. The above coroutine is immediately suspended so we don't get the chance to access `s` before it vanishes. I feel like attempting to access `s` should be a hard error at compilation time in this circumstance. Another kind of coroutine that eagerly executes until the first suspension point would be able to safely access such an `s` before the first suspension, right? So, what are we supposed to write instead? I guess, this would be fine, right? unique_generator&lt;char&gt; explode(const std::string&amp; s) { return [](auto s) -&gt; unique_generator&lt;char&gt; { for (char ch : s) { co_yield ch; } }(s); } And the following should work, too, right? unique_generator&lt;char&gt; explode(std::string s) { for (char ch : s) { co_yield ch; } } Right? Honestly, I'm disappointed ... but not surprized. C++ has a history of design choices that may have seemed good at the time but turned out to be unfortunate. Language design is hard. :(
I am not really able to use that class to get the encoding that I want, that might be just my lack of knowledge. My biggest issue is that I cant find any function that encodes my data to the same format as DataFileWriter does, which adds header data.
It's not new. Doing anything inside that for() loop, whether or not it is a coroutine, is going to cause a crash because the temporary is gone. I do agree that there should at least be some kind of loud warning but that's on the compilers instead of the spec.
Stroustrup talks about this in "The C++ Programming Language" IIRC: The standard library is generally meant to contain the most necessary and flexible solutions. In his mind, the stl can't make any assumptions about where the iterator is coming from. While the begin/end methods are used in the stl, a lot of third party code just doesn't provide iterators in that way. That said he also heavily encourages that if *you* need that abstraction, to go ahead and implement it. It's relatively easy to create a new template that does that, and then pass out on to the stl version automatically.
This is exactly what I was wondering, thanks for doing the research for me.
&gt; I was trolling. It was an excellent troll. Made me laugh and caught some fish.
An obvious enum advantage is not having to specify values for the initializers (ties in with the switch / case static-analysis advantage - the default 'iota' numbering scheme simplifies codegen for the switch statement). C++11 scoped enumerations addressed most of the disadvantages of C enumerations - enum ids don't have to pollute the namespace (the hassle of now having to qualify with the scope of a scoped enum may get fixed with the \`using enum\` proposal). Scoped enum ids don't implicitly convert to int And, allowing to specify a fixed underlying type fixes the portability problem of C enum having an unknown type. Scoped enums made the 'flag enum' use-case more difficult to code, for some extra type-safety. The C++ standard leaves it to the stdlib implementer whether to use enum for the BitmaskType requirement in things like std::ios\_base\_fmtflags. \`enum\_traits\` reveals that gcc's stdlibc++ does use an enum declaration: `enumio::enum_declaration&lt;std::ios_base::fmtflags, enumio::id_eq_hex, '\n'&gt;;` enum _Ios_Fmtflags {_S_ios_fmtflags_min=-0x7FFFFFFF-1, _S_boolalpha=0x1, _S_dec=0x2, _S_fixed=0x4, _S_hex=0x8, _S_internal=0x10, _S_left=0x20, _S_oct=0x40, _S_basefield=0x4A, _S_right=0x80, _S_adjustfield=0xB0, _S_scientific=0x100, _S_floatfield=0x104, _S_showbase=0x200, _S_showpoint=0x400, _S_showpos=0x800, _S_skipws=0x1000, _S_unitbuf=0x2000, _S_uppercase=0x4000, _S_ios_fmtflags_end=0x10000, _S_ios_fmtflags_max=0x7FFFFFFF} While Clang's libc++ uses named constants (not so easy to get by reflection). Using enumerations for such a set of related constants, even if it complicates the implementation, helps group them together in an explicit type.
&gt; But hasn't it gotten a little out of hand? No. Firstly they're proposals, not part of the language, and many (most?) of them will never be. Secondly, C++ basically has two choices, move with the times or never change. The latter is a pain and will guarantee that it slowly fades into obscurity. Would you really want to code with just C++98 features? I remember what it was like, and by the time 2011 rolled around, C++98 felt distinctly creaky. The former means adding features, and there's no way around that because C++ will never break compatibility (this is a huge feature IMO). This is the fate of all languages. Every so often someone wants to come up with a clean slate and designs a language that's just right for the year in which it's developed. Then time marches on and things the designers could never have known about arrive and they have the same choice as C++. The reason we see it with C++ is due to longevity and popularity. The thing is that features don't necessarily make the language more complicated day to day. Many of them are for library writers which means the day to day use of the language actually gets simpler.
No this is a tired old point. You can't remove features because you break code and that will fork the language.
Thanks for looking this up, I've also tried to make it work. As much as I like the idea of using clang, the 4x increased compile times make it not worth it for me.
Well, the idea is that you use for (auto s = foo(); char ch : bar(s)) { which isn't that bad. I do think adding a switch to force storing all intermediate prvalues until the end of the for loop could also be useful.
It is possible with ranges (`std::ranges::sort(vec);`). It is not possible with original STL because there would be a big problem to differentiate overloads, for example for sort: (Container&amp;) (Container&amp;, BinaryPredicate) (RandomAccessIterator, RandomAccessIterator) (RandomAccessIterator, RandomAccessIterator, BinaryPredicate) Multiple algorithms would get overloads which have the same amount of arguments. You can add some SFINAE to make it work but it is preferred to avoid it because: - error messages are very long - SFINAE is already used for some corner cases (see string constructor overloads) - is error-prone Ranges use concepts.
I'm always for when it comes to favouring standard snake_case naming convention but I doubt it will go through. Templates for a long time have been using PascalCase names and so it was naturally expected that concepts will do the same. But if I read this correct, only concept names are proposed to be changed and template type aliases will remain as they are.
&gt; Wrt Windows, it actually has no UTF-16 filesystem path input at all. It just consumes an array of bits, same as POSIX, just that the pointer is a `wchar_t *` instead of `char *` No, Windows paths are by default case-insensitive. Example in `cmd.exe` (though technically this doesn't prove anything because most every program adds its own quirks): [P:\temp] &gt; echo Just crush the berries with sugar &gt;bl√•b√¶rœÄ.txt [P:\temp] &gt; type Bl√Öb√ÜrŒ†.tXt Just crush the berries with sugar However, it's possible, but not advisable!, to get Posix-like behavior. Since most all Windows programs assume case insensitive paths, ordinary users may find it impossible to open or delete such files or folders. I.e. that's absolutely **not a good direction** for `std::filesystem::path`.
&gt; Just PLEASE do it. Hey, see my flair? I might add something like this to my TODO list of "single page articles dedicated to shortly present important problem" (next to strict aliasing violations and common C/C++ myths)
 std::vector&lt;int&gt; getData(); int main() { std::sort(ALL(getData())); // oops }
I have tested it extensively, works in my applications. If you find any faults please add them in the issues sections but so far it is fault free. All thread locking in the code is handled by std::mutex but can be substituted by writing your own internal allocator replacement for rc\_multi\_threaded\_internal\_allocator&lt;std::mutex, ....&gt; if needed. Yeah I should probably hide the internal details in an internal namespace, this was pointed out to me by another user. Actually I didn't know you could use std::lower\_bound as a replacement for binary search. You should stick to only the interfaces given on the README.md page. Or if you want to provider your own locks by replacing rc\_multi\_threaded\_internal\_allocator&lt;std::mutex, ....&gt; with your own version otherwise just use it as shown in README.md. &amp;#x200B; In terms of speed/big O. Best average and worst case are. Best O(log n) Average O(log n) Worst O(n log n) - with a bound on the worst case performance So no O(1) even for small allocation but O(1) when there is no fragmentation. Close to O(1) when low fragmentation. &amp;#x200B; //ensure we don't take too long trying to allocate, only search the first 10 blocks!! unsigned i = 0; for(auto it = end_basic_list&lt;memblock*&gt;(blockfreespace) - 1; it != begin_basic_list&lt;memblock*&gt;(blockfreespace) - 1 &amp;&amp; i &lt; 10; --it, ++i) { That part is pretty complicated, we have 1 to n memory blocks we could be allocating from (actually this is what gives the worst case performance O(n log n)) as we are searching through possibly n memory "pages" to satisfy the call. We are going backward through the pages, "--it" starting at the end of the memory blocks end\_basic\_list&lt;...&gt;(...). We only test the top 10 memory blocks (i &lt; 10) as so to bound the search time for an allocation. &amp;#x200B; I might do a compare to other allocators but I have other work to be getting on with. Just wait a few months/years and you may get a proper performance comparison. Or do one yourself. Sorry :P
This makes me kind of sad. I understand the motivation, but I was looking forward to some variety in identifiers. I've never been a fan of everything having the exact same `snake_case`, because having different things have different casing makes it easy to identify what kind of thing you're working with, and it avoids name clashes (e.g. class name vs function name).
It was not a big deal to abstract any containers and arrays with a [simple range wrapper](https://wandbox.org/permlink/ZNZb9ezOmaz36KWu) even in C++98, but... I guess the main reason - it was 25 years ago. Algorithms, containers and templates were complicated enough already for the C community.
Sorry, you are very wrong. What is defined as "case insensitive" varies according to locale, mount point configuration and a myriad of other settings. *This means each part of a path can have different unicode interpretation*. As Tom Honermann likes to point out, IBM z/OS has a native char encoding of EBCDIC. On such platforms, `std::filesystem::path` is thus always in some variant of EBCDIC, and possibly not the one actually configured in the system :) On Windows, there is an additional wrinkle to the above: directories can be invidually configured to have case insensitive comparison, or not. See https://devblogs.microsoft.com/commandline/per-directory-case-sensitivity-and-wsl/. Furthermore, Unicode illegal strings are completely valid path items, and can and do turn up on all platforms except for MacOS. On Windows, **any** binary character can be in a path item, including NUL and backslash. Win32 normally prevents you creating those, but with a library such as ... *cough* ... LLFIO, such abomination file names can be coped with, with some extra effort (and created, if you like to crash Windows Explorer whenever it opens said directories). Point is, filesystem paths are just blobs of bits, with unknown and arbitrary translation and interpretation entirely outside your control. Especially as different bits of a path may have completely different interpretation and translation e.g. a path may contain UTF-8, ANSI, EBCDIC, and UTF-16, each for a part between slashes (on POSIX). In my opinion, we in the C++ standard must accept that truth, and be less ambiguous than currently in the standardese regarding this.
Number 4 is fairly straight forward. Number 1 is mitigated by the fact that redeploys should be stupid easy once you have a container built. number 3 use vscode remote dev features. 5, use remote logging.
The SYCL standard requires kernel-interoperable classes fufill the [standard-layout](https://en.cppreference.com/w/cpp/named_req/StandardLayoutType) requirement. So yeah, that works fine in SYCL so long as all of the member variables in your CRTP instantiation are either in the parent or child class. You can work around it, but damn is it a PITA. They were almost certainly interested in requiring there existed no references to data which could be expected to only live in host-side memory in the class definition, i.e. + Has no virtual functions or virtual base classes + Has no (non-static non-constexpr) data members of reference type and hamfistedly applied the standard layout requirement.
your formatting may be OK on new reddit, but is disfunctional on old reddit. Please consider adjusting.
Some proposals are actually very trivial, it still amazes me that people ask for very simple things: - P1679 - `.contains()` for strings - ??? - `str.replace("foo", "bar")` - we have 10 overloads but none such (which is nontrivial to implement and pushes people to use regex_replace or custom string library) - [P1300](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1300r0.pdf) - some uniform way to describe module dependencies WITHOUT the need to scan source code (significantly impacts build times and tool complexity) - ??? - for-each for enums and `enum_val.to_string()` I like the idea of [P1040](https://wg21.link/p1040r3) `std::embed` but wondering how it would play with modules.
And AFAIK GNU team has no power or even will to implement it anyway.
There is no sane reason, why those overloads where not provided in addition (maybe with a different name like "sort_range`) other than the better being the enemy of the good: I guess no one wanted to invest the work of adding this simplification to the standard while the "ranges" library was on the horizon (will most likely be part of c++20)
*coughs*... trigraphs?
I want N4165 "Unified Call Syntax"!
In general I either use /include/projname/ for public headers and /src for source files, or same for public headers and /src/projname for source file. The second makes it easier to have stuff in subfolders depend on private headers in the parent folder, but also makes it easier to accedently expose private headers. Protip: recent cmake has PUBLIC_HEADER and PRIVATE_HEADER properties on targets, and install() knows how to install them. These props seem to initially have been for OSX frameworks, but they work fine everywhere. set_property(TARGET foo PROPERTY PUBLIC_HEADER foo.h bar.h) set_property(TARGET foo PROPERTY PRIVATE_HEADER baz.h) install(TARGETS foo PUBLIC_HEADER) ^^ note not tested, but something similar should work
I had assumed that the commenter I replied implicitly meant constants which have different explicitly declared non-sequentially-increasing values, like in the format flags example you cited. I don't see a significant difference between that and making a typedef and declaring a bunch of constants of that typedef. The iota aspect is def a big win in my eyes though, strong agree. For flags, I think we need another std type. I want to define flag names as a scoped enum, then use those as indexes into an integral bitmask. So the enum values are 1, 2, 3, etc. rather than 1, 2, 4, etc.
I don't see what any of those other than 3 has to do with docker, and not just server deployment. Maybe you can expand on your point
Those were my picks too, except Coroutines is already merged so I picked Executors instead. I mainly wan't standardized libraries for fundamental stuff (Networking) and features that enable a richer set of libraries (all the rest).
Tooling i think is slightly orthogonal - they could still diagnose overflow if they wanted to right even if it was well defined behaviour? It just means that the code would actually be valid and you wouldn't be at the mercy of the optimiser
Yeah this is a huge step. It means that signed overflow could have a defined result, because we now only have twos complement representation, which is awesome!
It's valuable to read about modules experience from other languages (Fortran) but I don't think that we have to resort to maintain some extra information about module dependencies. I just attended a talk of one committee member who is in favour of such system and he showed manually specifying dependencies would make makefiles 3x longer because of additional precompile step which is quite terrible. And if you want to use extra dependency files (probably as clang uses, never used it myself) I guarantee you modules as such would get unappealing to many people out there. Maintaining project or library dependencies in existing build scripts is enough work. I can't imagine I would ever want to maintain dependencies between modules other than what is already in the source code. The work should instead go into parsing the module header as fast as possible. In the worst case there should be a recommended setup described in Modules Ecosystem TS which would lead to a fast scanning without any extra information needed (for example with clear mapping between module name and file path if that helps).
Ok then try making a function first
PUBLIC_HEADER can't handle directories.
\&gt; This is misguided: the concept EqualityComparable goes way deeper than the named requirement EqualityComparable. &amp;#x200B; HOORAY! Yet another exam problem created by committee. Long live language lawyers. Seriously, why? &amp;#x200B; I looked through the article and found the motivation is not strong enough ...
It's not that it's bad, it's just that it's an illusion of security. It doesn't actually solve any problem - it just gives you a marginally more convenient syntax to fix it after you've run into it.
Nope, signed overflow is still UB. https://wg21.link/P0907r4#intro
Currently, signed overflow is undefined behaviour. This means that it is always a bug, so emitting a diagnostic for it is not a false positive. If you define signed overflow, some people will rely on the wrapped or whatever behaviour. Now, tools can't tell whether the overflow was intentional or unintentional. If they emit a diagnostic, there will be false positives, making the diagnostic barely useful.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Fixed, I think
The compiler will follows the ‚Äúas-if‚Äù rule. Beyond that it doesn‚Äôt guarantee to optimize anything (besides copy elision). You‚Äôd really have to examine the produced assembly to check, although I think newer clang/gcc has flags that will tell you about its optimization decisions. Typically, I‚Äôve seen an extra move in many cases of returning a tuple depending on the complexity of the type. If it‚Äôs just a POD then it‚Äôs directly placed in the return value iirc
I'm not familiar with the NRVO rules to this degree, but you can always check with a class that obeys the rule of five and "logs" each constructor/destructor invokation.
I should clarify: I'm asking if the compiler is even _permitted_ to do this (standard level question) - because the standard explicitly allowes to elide copies/moves with observable side effefts per NRVO. If the standard does not allow this case as well, the as-if rule doesn't apply (due to the side effects).
I guess it depends if you want to write something fun as you say or understand what you're writing. I think understanding is top
I agree with you -- hope this experiment develops further. Keep in mind ISO has requirements of their own, and we still need to follow their rules.
**Company:** [Disbelief](http://disbelief.com) **Type:** Full time **Description:** Disbelief is a game development studio focusing on contracting and consulting services. We‚Äôve worked with both AAA and independent studios to help their projects ship. Notable projects we‚Äôve worked on include Gears of War 4, Borderlands: The Handsome Collection, and Perception. At Disbelief we value work-life balance, and want to create an alternative to the crunch-culture prevalent in game development. We also believe strongly in investing in our talent and our team. Disbelief is a place to puzzle out the solutions to cutting-edge problems in graphics and engine programming, but also a place where people can grow their careers and skill sets as valued members of a stable and close knit team. Currently, we‚Äôre looking for a junior programmer. This opportunity is for a full-time position in Chicago, IL. Junior programmers at Disbelief are called on to develop and debug in a variety of areas from game play to core engine programming. You are expected to learn new systems and projects as you grow as a developer, with support and training from more senior members of the team. Most importantly, you will work to solve problems with the help of the team. We work with leading edge technologies to make them perform at the top of their capabilities, and we take pride in solving problems others can't. We believe a diverse team is a stronger team, and we encourage marginalized programmers to apply. *Key Responsibilities* * Clearly communicate your work to others * Debug code * Estimate task work * Consider performance when writing code * Document your code *Skills and Requirements* * BA/BS in Computer Science, or equivalent experience * Excellent communication skills, both verbal and written * Some type of systems programming in any language. * Good understanding of C++ * Knowledge of version control with P4, git, or equivalent **Location:** Chicago, IL **Remote:** No, but we do enjoy working from home up to two days a week, when project constraints allow. **Visa Sponsorship:** No **Technologies:** Most of our work is C++ of varying standards with a sprinkling of other languages as needed for tooling. We do a lot of graphics programming work, using shader languages and platform graphics APIs. Since we often are debugging the lower levels of systems, being able to read x64 or ARM assembly is useful. Primarily we work with Unreal Engine 4, but we also work with Unity and custom game engines. Our work uses rendering, physics, audio, VR, AR, and other APIs frequently. Our primary platforms are PC, Xbox One, PS4, Switch, and VR/AR devices. **Contact:** jobs@disbelief.com
**Company:** Disbelief **Type:** Full time **Description:** Disbelief is a game development studio focusing on contracting and consulting services. We‚Äôve worked with both AAA and independent studios to help their projects ship. Notable projects we‚Äôve worked on include Gears of War 4, Borderlands: The Handsome Collection, and Perception. At Disbelief we value work-life balance, and want to create an alternative to the crunch-culture prevalent in game development. We also believe strongly in investing in our talent and our team. Disbelief is a place to puzzle out the solutions to cutting-edge problems in graphics and engine programming, but also a place where people can grow their careers and skill sets as valued members of a stable and close knit team. Currently, we‚Äôre looking for a senior programmer. This opportunity is for a full-time position in Cambridge, MA or Chicago, IL. Senior programmers at Disbelief are leaders and developers in their project. You should be comfortable working independently and with a team to develop, test and integrate software into a larger codebase. A key responsibility is mentoring and guiding fellow programmers to improve. We believe a diverse team is a stronger team, and we encourage marginalized programmers to apply. *Key Responsibilities* * Clearly communicate your work to others * Mentor fellow programmers in and out of your team * Communicate with clients on team progress and problems as they arise * Debug code with precision * Estimate your and others work * Assess impact of issues on schedule * Diagnose and solve performance issues * Document your code * Study version histories and code documentation to solve present problems * Implement features in innovative ways *Skills and Requirements* * BA/BS or MS Degree in Computer Science, or equivalent experience * Excellent communication skills, both verbal and written * 3-5 years of experience in writing software in C++ * 5+ years in game development, or 10+ in a related industry * Experience working on a large code base * Experience with version control with P4, git, or equivalent * Experience with multi-threaded systems **Location:** Cambridge, MA or Chicago, IL **Remote:** No, but we do enjoy working from home up to two days a week, when project constraints allow. **Visa Sponsorship:** No **Technologies:** Most of our work is C++ of varying standards with a sprinkling of other languages as needed for tooling. We do a lot of graphics programming work, using shader languages and platform graphics APIs. Since we often are debugging the lower levels of systems, being able to read x64 or ARM assembly is useful. Primarily we work with Unreal Engine 4, but we also work with Unity and custom game engines. Our work uses rendering, physics, audio, VR, AR, and other APIs frequently. Our primary platforms are PC, Xbox One, PS4, Switch, and VR/AR devices. **Contact:** jobs@disbelief.com
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/ccetyz/dependency_on_opencv/etmfjbg/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Some things has been removed. `auto_ptr`, `random_shuffle`, `bind1st`, to mention a few.
EqualityComparable requires == to be an actual equivalence relation, i.e. x==x for all x, and x==y &amp;&amp; y==z implies x==z. The concept has no way to check that.
Yep, all of those things should be possible with your proposal! I was just working through the implications of using a tuple out loud, rather than comparing the two. Sorry if that was confusing! I personally find the use of the visitor pattern here really confusing. Compared to a baseline naive implementation where the interpolated string just evaluates to a std::string, having it instead be a callable object that needs to be passed a generic lambda to actually use it seems pretty complicated. Let me flip the question around - are there benefits to using a visitor pattern instead of a tuple that I'm not seeing? Also, I said tuple because it's the most concise way to express what I had in mind, but technically you could also implement this with an anonymous compiler-generated struct that implements the std::get protocol, and also has predictable names for the member variables. Then there's no library dependency, and you'd probably also have better throughput at build time versus using std::tuple. For example: struct __x { inline constexpr const char format_string[] = "The result is {}\n"; constexpr size_t size() { return 1; } decltype(get_result()) _1; }; With your proposal, there also doesn't seem to be an efficient way to pre-allocate a buffer of the correct size for the final string. Unless, was your intention that callers would do multiple passes through the interpolated string with different callbacks, and get the buffer length in the first pass?
Thanks for pointing out the coroutine situation. Also as networking is semi-blocked on executor I assume they are going in together. &gt;I mainly wan't standardized libraries for fundamental stuff (Networking) and features that enable a richer set of libraries (all the rest). Exactly what I was thinking.
You seem to be confusing multiple concepts. So (N)RVO happens on an object that you are returning from a function. return {data, check_state(data)}; Here `data` is not NRVOed. Why? Because it's not the object being returned! You need a `std::move` here. Your colleagues are right: `expected` inhibits NRVO, just like `optional` does BTW. Here: return {get_data(), some_state}; `get_data()` returns a prvalue, so the `data` in the result object is indeed move constructed. Also having a type that is expensive to move is a big no-no.
You have to work around that specific case trivially with a one liner occasionally, but I do the same thing with my `BEND` macro. Way easier to write, given how often begin and end come up vs generators like that.
I completely understand, but because the public of the class seems to be more high-school, I think the focus shouldn't be on the inner workings and more on making programming interesting so that they might see it as a potential career choice. That's my impression of the post anyway.
Reading the Raymond Chen‚Äôs blog, I am amazed at the depth of his knowledge. He writes about UI, kernel, multi threading, security, various CPU calling conventions, JavaScript, C#, and C++ including template meta programming.
The thing is, that nothing is working out of the box... Some of points I agree have some solutions. Regarding deployment time - it does not (in AWS). Regarding file system ('thin pool problem') - it also still not solved. Why should I spend time for "nice" technology when it brings more problems then value ? Good tech should work good out of the box. Without hacking and reading tons of docks.. I really made script that downloads my binary from storage and runs it. Natively. Using proper user. Using native syslog ecosystem. With core dumps enabled. And without surprises with runtime performance. Linux style. No hype - just pragmatic way. I think for scripting languages, that not compiling, docker seems helps (in some rare cases). But for binaries (compiling languages) - totally useless crap..
In case it's not entirely clear, the point of my comment is not "I want to use your allocator, please add this and that", it's more of a "dude, if you are going to advertise your pet project LIKE THIS, make sure that at least *some* of the properties you are promising is even remotely true, otherwise you look like a kid who wrote his first hello world and now considers himself a principal engineer and system architect." Just so you'll have some take-aways from this post: * When you are proposing an allocator, sensible people won't even consider cloning the repo (yet alone use it) unless you managed to remove **any doubt** that it can't possibly misbehave, even if 64 threads are constantly hammering it in most bizarre patterns for several months without a restart. BTW, [I have a certificate for you](https://blog.codinghorror.com/the-works-on-my-machine-certification-program/). * Our definitions of "fast" are very different. For the last 12-ish years proposing a non-thread-caching general purpose allocator is a bad joke (since good old nedmalloc, I'd say, but it's definitely not the first one). Without it there is simply nothing to talk about. After this matter is out of the way, people will start asking about the number of cache misses, contention for non-thread-local case, NUMA-awareness (where applicable) etc. A specialized allocator can be entirely lock-free (not counting potential implementation details of VirtualAlloc/mmap which you can't really control). A general-purpose one should be **almost** lock-free, mostly relying on infrequent atomics for communication with the shared state, and locking only when all hope is lost. * Since we were speaking different language, I'll re-phrase the question about the loop. It's not even about weird loops or magic constants, and definitely not about the syntax of the language, it's more of an "Are you out of your mind to traverse a freaking linked list like this in the allocator code? You know how much each cache miss will cost you, right? You know that you shouldn't expect that the allocator's internals will be in the cache, and if they **are** there, you are stealing the cache space from the actually useful parts of the program, right? **Right?**" Be humble about your beginner's projects, and it will greatly help you in your career.
I too like coffee a lot but at the point to inject it.
This is also required by the pre-C++20 named requirement EqualityComparable. AFAIK The most notable difference is that the concept `EqualityComparable` also requires the types to be *in*equality comparable, that is, `a != b` must be well-formed and consistent with `a == b`.
For the first case, I think you're right. i.e. the answer to question 1 is no. For the second case, I'm not sure. Here is how I interpret the rules: Think of the aggregate initialization as a copy constructor. The prvalue return type of `get_data()` is lifetime extended through the `const data_t&amp;` argument of the copy constructor, which is not(?) an operation that materialses the prvalue, and then the prvalue is moved - which materializes it while also eliding the move per guaranteed move elision. Also, regular RVO applies to the whole return statement which means the entire object is not moved. I'm not sure of this interpretation though, so take it with a grain of solt. Another clarification: In both cases the compiler has enough information to perform RVO/NRVO (it works by using the preallocated storage of the return value to store the RVOed/NRVOed during the function call) but does the standard forbid it in certain cases and why?
https://www.reactiongifs.us/wp-content/uploads/2016/08/path_I_cant_follow_star_wars.gif
There were many sane reasons when the STL was first proposed, each of which slowly melted away. And now we will have ranges. (But there were definitely a few years there where the sane reasons were gone, but we still didn't have the convenience functions)
&gt; Think of the aggregate initialization as a copy constructor. I don't follow. It's more like an implicit constructor whose parameters are every member object of the aggregate. &gt; which is not(?) an operation that materialses the prvalue it does materialize the temporary, since the reference has to refer to an object, which a prvalue is not. &gt; Also, regular RVO applies to the whole return statement which means the entire object is not moved. jup. &gt; but does the standard forbid it in certain cases and why? Well only under certain conditions is NRVO allowed soI guess the other ones are forbidden :) But yeah, it's forbidden for cases where the storage can't be effectively reused, just like in your example since it has to construct a new result object, the old `data` isn't inside that storage generally. So it has to be moved.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cc840x/online_lectures_on_c/etmoz54/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt;I don't follow. It's more like an implicit constructor whose parameters are every member object of the aggregate. No, it's not like an implicit constructor, and there is no copy or move: [https://gcc.godbolt.org/z/8LC0zl](https://gcc.godbolt.org/z/8LC0zl)
won't link so no big oops. C++ is full of much more insidious oopses e.g. sort(a.begin(), a1.end());
&gt; Sorry, you are very wrong. Possibly, but you fail to point out how. Yes, you can have Posix semantics in Windows and I mentioned that. I also mentioned why one should generally **not do that**. It leads to horrendous problems. --- &gt; we in the C++ standard must accept that truth, and be less ambiguous than currently in the standardese regarding this You're IMO focusing on a much too low level of abstraction. That usually creates needless complexity.
I don't disagree. That's why the "more like". :)
Ok, my point was that `data` in `calc2()` is not move/copy constructed, but created in place in returned object, and so effectively it is NRVOed.
Ooooh God, that is so true. Silly me, thanks :)
To start you clearly have not read the code. It is not a link list for starters, there are no linked lists for exactly the reasons you state. Cache misses. I don't expect it to compete too well with some of the bigger more battle tested memory allocators like Hoard, ptmalloc, jemalloc, mimalloc etc... But will be pretty surprised if it gets somewhere close. Just faster than malloc/realloc/free will work for my case. I maybe should dial it back a bit but until we have some real metrics neither of us are in a position to argue the numbers on this. As for beginner, do you think this is the best code I have ever written? It is a useful piece of code that I think might be useful to those that need it not the best thing I or others have written but good enough for free on the internet. That is all I'm will to argue on the matter.
&gt; This 248-pages monster is probably larger than the remaining 299 papers alltogether. Actually there are about 3,700 pages of papers in the pre-Cologne mailing.* Not counting the copy of the draft standard in each mailing. * according to File Explorer &gt; Select All &gt; deselect N4820 &gt; right-click &gt; Convert to PDF (some are HTML or TXT).... 2 min later, 3737 pages using that renderer
:) There are multiple reasons for this survey. The overt one I mentioned is a real and sincere reason. You just put your finger on another.
1. That version could only operate on entire containers, whose interface provides a begin and an end. This is a special case of a special case, even if it's the most common. 2. This version imposes an additional requirement, not just on the iterator interface, but the type passed in. Its an 'artificial' requirement--algorithms work generally on ranges of elements, not types conforming to elements the standard container interface. 3. This would not work for ranges of elements not wrapped in a type with begin and end information. For example, c-style arrays. 4. Its possible when these algorithms were designed the standard committee already had its eye on ranges. If they added the overload you want, it wouldve made it very unpleasant for everyone to implement the ranges versions of the algorithms as another overload. Rather than give us one crappy overload for a special case, it was better to hold off until the much more powerful ranges library was delivered, which provides the ability to compose algorithms as a part of a single expression (sort(v) | filter(is_even)...). However since theyre sticking them into a separate namespace it probably wouldnt have been a big deal aside from zealous users of namespace using declarations getting stung occasionally.
&gt; There were many sane reasons when the STL was first proposed, each of which slowly melted away. Such as? I mean except limited bandwidth of how much can be put into the standard in a finite amount of time of course.
Very nice! All usability improvements to use Clang from within VS are very welcome!
Several good answers on that question
Any particular reason, why you are not using templates for that?
And what would have stopped the original STL to use different names (e.g. sort, sort_range)?
My inexperience with templates I suppose. How could I make a template to generically solve all these cases? Even for the `BEND` case, I'm not sure how a template would help reduce the visual clutter of begin/end but I'd be delighted to find out!
Yes, there will be sampling bias. However, (a) my readers are pretty quick to be skeptical of my proposals and have a pretty broad view, and (b) note that we're having this discussion on /r/cpp which is "not on Herb's blog" (this was expected). So I think the sampling bias is more toward "people who read about C++ standardization online and respond to surveys" which is also probably nonrepresentative of all C++ users but it's who can readily ask... then we can interpret the results based on understanding that, weighting whether N is sufficiently large to compensate, correlation with other surveys (e.g., the common keywords in the general write-in responses to the 2019 C++ developer survey question "if you could change one thing about any part of C++" -- this survey's question is more specific than that, but there is overlap and I do intend to try correlating it with that which will help validate whether we're getting consistent signal).
I may be wrong, but nowadays I think the agreement is that the STL should contain those abstractions. The reason is not just about education or avoiding to write the nth erase-remove_if wrapper, but the fact that the STL implementations are getting more used around the world (for several reasons: new features, new containers, quality of the implementations...). And third-party containers may also provide the proper interface anyway.
Eh? That's the exact same oops, but much more obvious because `a` and `a1` are not the same. Using a dumb macro hides the fact that `getData()` is evaluated twice and so there are two different containers. It won't link because `getData()` is defined elsewhere. Use some imagination. If it was defined, it would link, and you'd have a bug.
I aim for maintainable code that is reasonably easy to read, not code that is easier to write. The code above looks like it was written by an animal. You sicken me.
&gt; Compared to a baseline naive implementation where the interpolated string just evaluates to a std::string That is not acceptable, because not everyone wants or needs std::string. Some people have third-party string libraries. Some people cannot use dynamic allocation. Some people want to directly stream to an ostream without creating a string first. --- &gt; are there benefits to using a visitor pattern instead of a tuple that I'm not seeing? Yes, using a visitor (or a variadic function call, as I have shown in the comments here), is simpler and better than using a tuple for multiple reasons: 1. Compile-time dependency on the &lt;tuple&gt; header. This can affect compile-times significantly, especially if std::tuple is not used anywhere else and if the literals are long. 2. The tuple is more complicated than a function call. To transform a variadic function call in a tuple, all you need to do is invoke a constructor. To unpack a tuple in a variadic function call, you need to use metaprogramming machinery like std::apply. --- &gt; anonymous compiler-generated struct that implements the std::get protocol This makes more sense to me than using std::tuple, but I don't see how it is better than a function call. Again, it's more complicated. Now you're relying on member variable names instead of a function call where people can decide the names of the arguments for themselves, or use a variadic pack. --- &gt; With your proposal, there also doesn't seem to be an efficient way to pre-allocate a buffer of the correct size for the final string. As you mentioned, you can do multiple passes. The variadic version I posted here in the comments is even nicer for that, and allows you to do this in a single pass.
Quite possible. The standards committee has been working hard to make c++ "more modern". But like anything else in c++, often the emphasis on being backwards compatible can make that a mess. That doesn't change the reasoning behind the current design though :)
I see where you're coming from, since it's something you're not used to. I'm sure if I preferred writing stuff out, I'd feel the same way. Since I wrote the code, I can fully read and write it, but maybe it's harder for someone else. Hope you enjoy reading and writing your own code the most!
For beginners starting with C++ they should start with a normal text editor. Ive heard too many stories of students who are unable to program in environments in which they dont have access to an IDE.
Only a minority of C++ developers know what even a C++ proposal is or have even read a single one. It is true that the subset of those that read your blog from time to time will know about what proposals are and may have read some, but it is likely that they simply remember major features without knowing the fine details (which are what individual papers are usually about). And the same subset will likely biased towards your proposals ;)
I saw enough. If the names of your methods are misleading, and the reader can't trust words they see on the screen, that definitely a big red flag to think about. Ok, so apparently your basic list has nothing to do with lists. Does it change anything? Not really, because for each pointer in your vector replacement you fetch a memblock's "byteremain" right in the first line of memblock::internal_malloc. The pattern of misses is irregular, the autoprefetch won't help you, and you don't do the manual prefetch. That's more or less the same performance that you would get from a linked list (with a fainting hope that if LTO will inline the call, OOO might give your next fetch a measurable head start compared to a fully dependent read you would get from a linked list). But whatever floats your boat, man. Good luck with this thing.
Great post, love the explanation of thought process to find optimization possibilities. Perhaps in the future include/describe missteps and red herrings in more detail and how you recognized and reconciled them. Thank you!
`sort_range` is `std::ranges::sort` so ... we actually have a different name now
If you look at certain overload sets in the STL (e.g. equal) they already contain such patterns. This ends up avoiding ambiguity due to partial ordering of function templates (a C++98 feature!). For example, (RanIt, RanIt) is more specialized than (Container&amp;, BiPred). When you have two ranits, they're both viable, and (RanIt, RanIt) is preferred. When you have a container and bipred, (RanIt, RanIt) isn't viable (they aren't the same type), so (Container&amp;, BiPred) wins alone. That is, "the overloads would be ambiguous" has never been a real issue for range algorithms, AFAICT.
What you're doing is deeply misguided, and ignores the C++ community's decades of experience with the evils of macros. Not all macros are evil, but unnecessary macros are, and this is absolutely an example of unnecessary macros. (As helper function templates, they would be annoying but not nearly as problematic.) Fun fact: As maintainers of libstdc++ and MSVC's STL (respectively), Wakely and I are used to seeing a near-infinite variety of STL use and misuse. This is an 8 out of 10 on the misuse horror scale in my opinion.
Asynchronous programming with + no heap allocation + no type erasure + no synchronization + no ref counting + no indirect function calls FUCK YES
Could you break down (or point me in a direction where I can find it myself) why? I can't imagine an import defining their own BEND macro, but maybe they could. It doesn't reduce readability at all for me, the only person reading the code. My editor unwraps the macro if I do ever forget. I'm sure there is a reason I shouldn't be, but I'm not familiar with it yet.
Sure, but that could have been written std::sort(std::make_range(array_per, array_ptr+size)) for some appropriate definition of `make_range`. (Probably was the reason, though.)
&gt; The compiler will follows the ‚Äúas-if‚Äù rule. Beyond that it doesn‚Äôt guarantee to optimize anything (besides copy elision) (N)RVO is a notable exception to the "as if" rule.
True. I‚Äôm not sure what I meant there ü§î.
&gt; often the emphasis on being backwards compatible can male that a mess. But C++ has function overloading, so it could easily provide both functions declarations, the iterator one and a vector one, and a lot more.
&gt; if you need that abstraction, to go ahead and implement it. It's relatively easy to create a new template that does that And this is the arrogance that isn't helping C++ one tiny bit.
Saying "hamfistedly" isn't *totally* fair. The motivation is to ensure that the type can be copied from the host to the device (and vice-versa). [There's a sample](https://github.com/codeplaysoftware/computecpp-sdk/blob/master/samples/ivka.cpp) in the ComputeCpp SDK that shows what sorts of things can be used as kernel arguments (things which are, as you say, standard-layout and trivially-copyable). I feel I should say I work at Codeplay, and I use our SYCL implementation but I don't work on it at the moment.
I just gotta say, it always amazes me to see you down voted. You're polite, and your comments are filled with information, and yet sometimes they seem to sit at -1 / -2 without a response for no reason at all.
/u/jwakely gave it on the first response. With: #define FIND(where, what)std::find(where.begin(), where.end(), what) consider the following code: std::vector&lt;int&gt; makeOneTwoThree() { return std::vector&lt;int&gt; { 1, 2, 3 }; } int main { return FIND(makeOneTwoThree(), 2); } One of the well known problems of macros is that, unlike functions, the arguments are evaluated each time they appear, because they use simple token pasting. Rewritting FIND as a template: template&lt;typename TCollection, typename TElement&gt; auto FIND(TCollection collection, TElement element) { return std::find(collection.begin(), collection, element); } Fixes that problem. Macros are also notoriously difficult to debug properly, unlike functions. If you throw exceptions with __FILE__ and __LINE__ (as in common), the numbers are less precise than you'd like. Your code also just has _dialect_. Dialect is fine and sometimes necessary, but we want to avoid unnecessary dialecting, because it makes your code very difficult to read for somebody who is unfamiliar with it. I once worked in a codebase that had: #define MAKEOBJECT(x) new x This sort of thing turns every C++ codebase into obscure code that only the project maintainers can read. When the macro isn't saving you much (all of your macros except possible FIND and FIND_IF), just write vanilla C++. Static analysis tools will do a better job, other maintainers will be able to read it, and it won't look like FORTRAN garbage from the 60s.
What's so "lol" about making your manager buy your team members a copy of gitkraken?
I don't think it's arrogance, it looks more like pragmatism. Ranges are coming, so clearly there's agreement that this is an issue that should be fixed, but they're not out yet.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/ccjxnr/learning_c_or_c_as_a_beginner_programmer/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Lol @ Odin's laugh at the end
&gt; But like anything else in c++, often the emphasis on being backwards compatible can make that a mess. I'm increasingly feeling C++ is at least two languages trapped in the body of one language. I'm not even sure if that is a complaint, its just that if someone says 'I write C++' I'm not even sure what language they *really* write.
No.
You are not wrong. Part of the core issue/benefit with c++ is it was designed to be backwards compatible with c. On the surface this meant you could compile all those fancy c libraries directly into c++, without changing a thing. However it also meant that by default all "advanced" features (RAII for example) in c++ are opt into, rather then opt out. Like everything in programming there are tradeoffs to this decision, so it's neither right nor wrong, but it is the reason it sometimes feels like like two small kids hiding in a trench coat.
This isn't going to be of any practical help, but in theory C++ 20 could do this with a slight syntax adjustment which moves the message into a template parameter, e.g. ``` throw MyException&lt;"Error case: some"&gt;(... other args ...) ``` It'd look something like this: https://gcc.godbolt.org/z/_AiQEh No compiler supports class type NTTPs well enough to support this yet.
Yeah. Part of me wishes it were possible for C++ to finally split off, into a language that's more like a C-but-better, and one that's more the templated nightmare world I have come to know in C++. Especially because I feel a lot of people have strong feeling about which of the children in the trenchcoat is the *real* heir to the throne.
And with a bit more magic you could move the string back into the normal argument list with a UDL suffix on it, e.g. ``` throw MyException(__FILE__, __LINE__, "Error case: some"_fixstr); ```
This definitely seems like one of those cases where the gain of accomplishing this would be marginal compared to everything else in that chain of events. The popular alternative is to use [error codes](https://en.cppreference.com/w/cpp/error/error_code), usually represented as an error category and code enum combo to avoid collisions, which represent pre-defined error conditions, and then just store that with file and line number. The downside is that it limits your errors to just those defined messages and you can't format in custom info.
Because you didn't initialize it.
1) indent 4 spaces to format code 2) this is prime r/cpp_questions material 3) you answered your own question
scope is not part of an expression's type
i[3] and i[5] are junk values...and i[6] is an out of bounds memory access.
Why didnt index 3 and index 6 have a junk value then?
&gt;int i[6]; &gt;cout &lt;&lt; i[6] &lt;&lt; endl; What a madman
Why did for i[3] display 0 then?
I did it on purpose. Trying to understand it
[Undefined behavior](https://en.wikipedia.org/wiki/Undefined_behavior)
I‚Äôm guessing the compiler used a simd instruction to assign values to all those values at once, and just stuck a zero where the value for 3 would be.
If I understand you right, you intentionally wrote out the contents of something that wasn‚Äôt initialized and you are wondering why it isn‚Äôt random junk. When things are uninitialized they are exactly that. They may already be 0, or the might not. Sometimes compilers take mercy upon you and zero out memory. Either way, it is not something you should be doing and expecting good things to happen.
Because the memory location *happened* to have 0 in it. It could have just as easily been any other value, because you didn't initialize it to anything.
Yes it was on purpose. Thank you so much
Thank you
You‚Äôre trying to reverse engineer compiler decisions about code that does not require the compiler to produce any defined behavior?
By throwing an exception you officially revoke your "perverse obsession with performance" club membership. I'm sorry. Please leave your badge at the reception. Even Itanium ABI "zero-cost" exceptions are only zero-cost to have (assuming you don't care about the overall code size), but most certainly not zero-cost to use. They are quite useful for situations that "should never happen normally." If you see such operations in the profiler, and, more importantly, some internal buffer allocation of the error message is also visible, there two most likely explanations for that are: 1. Something is seriously wrong, and you should probably dive behind cover before your computer explodes. 2. You are mistakenly using exceptions instead of normal return values for scenarios that happen in your code very often under perfectly normal circumstances. Consider returning enums, std::optional, std::variant, etc. I hope that one day we'll get super-fast and actually sane [herbceptions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r1.pdf), and life will become good. Before then, **if you actually need all the perf. you can get**, consider either reserving exceptions for "the sky is falling" scenarios, or disabling them in the compiler altogether (and that would be a pretty bad advice if you don't actually need this, since it will make your life quite a bit more difficult).
0 is a junk value, too. It just happens to be a very common junk value, and the one you were hoping it would be. On a different computer, with a different compiler, on a different day, it might be something else completely. Though, keep in mind that undefined behavior can lead to more than just printing junk values. Optimizers can do very strange things sometimes.
By "global scope", I think you mean "static lifetime". You say you want to avoid allocating memory, but you must realize that string.append will allocate more memory for the string as needed. Also, you should treat exceptions as just that: exceptional. Don't worry about optimizing your error cases.
And that's why rust was created ;)
Ah, I see what you mean about using a template, wrapping the std::find with a template. Makes great sense. &gt;Your code also just has dialect. Dialect is fine and sometimes necessary, but we want to avoid unnecessary dialecting, because it makes your code very difficult to read for somebody who is unfamiliar with it. That's not a problem for me, since I'm working alone, but I can appreciate the impact it would have on other people since they'd have to spend more time learning the code than otherwise would have. Thanks for the detailed answer!
&gt; By throwing an exception you officially revoke your "perverse obsession with performance" club membership. I'm sorry. Please leave your badge at the reception. It's a bit more complicated if we take into account hard real-time systems. There you don't care about average case or even amortized average - all you care about is worst case scenario and if your worst case will meet the deadline with 100% guarantee. That means `std::vector::push_back()` isn't "amortized O(1)", it's O(n). Now what's the cost of throwing an exception in the worst case, apart from "big"? Well, it's non-deterministic, so you can't ever be certain it will finish in time. In conclusion, sometimes you care about performance in the error case, because you care about the absolute worst case and for those systems current C++ exception model is unexceptable.
Type: Contract, Lead/Principle Software Engineer Location: Remote, Las Vegas Description: C++ specialized software engineer with almost 20 years experience. Also knowledgeable in automation technologies. Technologies: C++(all versions), virtualization (docker, kvm), Linux, gcc, clang, bash, etc... Contact me here via PM. I contract myself through my company: Strange Crew, Ltd. I've currently have a full time client, but am on the lookout for future projects and for side jobs; maybe someone needs a few extra man hours or something. &amp;#x200B; I give discounts for projects I feel advance the human condition in some important way--completely subjective but open source, education, science, medicine and things of that sort are the general idea.
I think you'll find a static-only message to be quite a limitation. Support for additional context/parameters will be quite desirable. We use Qt, which uses copy-on-write strings and provide a 'QStringLiteral' construct for low-overhead construction from string literals. That approach gives us performant handling of string literals, without sacrificing flexibility. You could implement a similar approach. I should mention that QString is an awesome string class (from an interface perspective). Far better than c++ string abstractions imho.
Definitely this. In my experience, the overhead of an exception *vastly* exceeds the cost of string operations/allocations. Exceptions are fantastic for errors and other exceptional cases, but definitely don't expect real time performance if you're throwing thousands a frame.
Maybe would have over complicated the API. I can‚Äôt think of many practical use cases, vs using `top` and then `pop`.
I love your questions. So many people are downvoting you, but it seems like you are playing Mad Scientist with C++
OK, I hear you - exceptions aren't fast. One of my coworkers has a notion that exception ctors shouldn't allocate. They say that when an exception ctor allocates, in low memory situation, this allocation will fail, leading to a non-graceful shutdown of the process. I normally try to just avoid thinking about memory issues, because they're a pain - but I don't actually have a coherent response to what my coworker is saying. I want to throw error description strings like I showed. I understand that I could use error codes and make a map of error codes to descriptions, but this is like 3x as much code and only the devs read the error descriptions, so I'd rather not. In an attempt to satisfy both goals (no allocation and strings), my coworker wrote an exception class: class MyException{ public: char filename[2000]; int line; char message[4000]; } And strcpy-d the message into the buffer. Having an exception objects this big caused problems with one of the major compilers. Is it possible for me to achieve my goal? I want: - allocation free exceptions - string data exceptions - safe ctor.
What about making a priority queue with a move-only value type?
I mean it depends on how bad you want it. If you're willing to jump through hoops like this you can: #include &lt;iostream&gt; struct BaseException { const char * file; int line; const char * msg; }; template &lt;char const * const file, int line, char const ** const msg&gt; struct MyException : BaseException { MyException() : BaseException{file, line, *msg} {} }; const char* msg0; constexpr static char filename[] = __FILE__; auto RunSomeCode() -&gt; void { msg0 = "hubub"; if (true) throw MyException&lt;filename, __LINE__, &amp;msg0&gt;(); } auto main() -&gt; int { try{ RunSomeCode(); } catch(BaseException const &amp; e) { std::cout &lt;&lt; e.file &lt;&lt; e.line &lt;&lt; e.msg &lt;&lt; "\n"; } return 0; }
Tying error codes to file/line seems... off, because the code moves often whereas error conditions don't.
It isn't exactly an "oversight" when the design predates move semantics by more than a decade.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cck8fr/junk_value_not_zero/etnscxg/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Not in the typesystem, but you could write a macro which passes arguments forward as MyException(PARAM1 "", PARAM2 "", PARAM3 ""). I think I've seen this in Lua to ensure correct use of string literals as parameters.
Every day my rust is catching up with my C++ with the intent to replace it asap. I don't think that I have ever deliberately replaced one language with another simply because I was sick of the people who "run" it and the culture that pervades it. I have C++'d since 91.
Have you told your coworker that MyException and its 6k of buffers has to be allocated somewhere? (Not sure what the standard says about stack vs heap)
&gt; No this is a tired old point. You can't remove features because you break code and that will fork the language. No, your point is tired and old. There is so much legacy code out there that wont get compiled by anything newer than C++03 anyway... those companies wont change no matter what. C++ will not survive as a language if it gets cluttered year after year.
If you have no spare 100 bytes of memory for error message then it's better to fail fast unless you're writing a really low-level code. There is no guarantee that your graceful shutdown will work in such condition.
Here's an idea that I think somewhat approximates what you're looking for. Treat direct usage of `MyException::MyException`as an internal implementation detail (enforced by convention, here I put it in a namespace called `internal`). Then expose it via a macro that relies on adjacent string literal concatenation. Here's a sketch of what it would roughly look like. #include &lt;string&gt; namespace internal { struct MyException { MyException(const char* full_message) : full_message(full_message) {} const char* full_message; }; } // namespace internal #define INTERNAL_TO_STRING_INNER(x) #x #define INTERNAL_TO_STRING(x) INTERNAL_TO_STRING_INNER(x) #define MY_EXCEPTION(message) \ ::internal::MyException(__FILE__ ":" INTERNAL_TO_STRING(__LINE__) " " message) int main(int argc, const char** argv) { throw MY_EXCEPTION("message"); const char* no_longer_a_string_literal = ""; std::string std_string = ""; // MY_EXCEPTION(no_longer_a_string_literal); // MY_EXCEPTION(std_string); } It breaks down a bit if you start pushing on it too hard, like invoking the macro like `MY_EXCEPTION(+ 1234);`, but hopefully those kind of usages errors are blatant enough s.t. they aren't too much of a problem.
Because thats the definition of a queue. If you need different behavior either change the way elements are prioritized or use a different data structure... More details and maybe I can give a more helpful answer.
I'm not sure why you are singling out exceptions, as there isn't *any* operation in C++ that is deterministic, or that has a hard real-time guarantee. The best you can hope for is that operations are stable: that they have the same runtime performance on each run. This is no different for exceptions though.
&gt;They say that when an exception ctor allocates, in low memory situation, this allocation will fail, leading to a non-graceful shutdown of the process. Don't worry about that. Apparently the new zero-overhead herbception mechanism everyone is raving about (without even having seen how well it will perform) will also bring us automatic and unavoidable abort-on-OOM, so any control we might have had over dealing with low memory situations will be taken away and replaced by non-graceful shutdown anyway. We get this because some people feel exceptions have too much overhead, and if we abort on OOM we can get rid of the `std::bad_alloc` exception. That in turn means most of STL can be made `noexcept`, so people that don't use STL today "because exceptions" can finally start to use it. The one thing I don't get is this: if herbceptions are really zero overhead, why is there still a need to remove exceptions from STL? Surely we could get a zero-overhead `bad_alloc` thrown in case of OOM?
the standard doesn't use the terms stack and heap, but on Windows at least, the exception object is allocated on the stack - so the allocation of the object occurs before the exception is thrown. this is actually "the problem" so to speak with my coworkers solution - using large exception objects blows up your stack space, even if the objects aren't thrown.
While that may be true for applications, I'm not sure it applies to a transaction based data pipeline. When a transaction exceeds memory usage, it should throw std::bad_alloc and thereby trigger the dtors which de-allocate the memory for the transaction. In this way, a pipeline can process most transactions in parallel sharing resources, saving the expensive transaction to be run serially at the end with exclusive use of resources.
Making \`pop\` return an \`optional&lt;T&gt;\`.
Your exception of limited bandwidth \*is\* the reason. So much time was spent on Concepts pre-C++11 and then ripping them out that we're still catching up. Factor in the development of Ranges, Modules, and all of the features that made it in to 11, 14, 17, plus anything else that went into the TSes and there's your answer.
The problem of individual path segments having differing Unicode interpretation affects POSIX equally to Windows. Imagine a utf-8 file system mounted inside a Latin1 file system mounted inside a ucs-16 file system for example, each with different handling of unrepresentable characters. Per mount case insensitivity is very much possible on POSIX too. &gt; You're IMO focusing on a much too low level of abstraction My concern is correctness. Right now the standard says "implementation defined" for all path interpretation, and that there is exactly one character type for a "native encoding" path. That vagueness made sense when Filesystem was first standardised, but now we have much more implementation experience, and I'll be arguing for strengthening the guarantees in the standard in order to improve portability and correctness. Right now lots of code appears to be portable between Windows and POSIX, but falls over badly on non 7 bit characters. I dislike non obvious brokenness. It also annoys me when standard library code falls over like the Windows Explorer does when fed valid but unusual paths. We should do better than that. &gt; That usually creates needless complexity. Sometimes one is merely displacing complexity to worse places. Filesystem's `directory_iterator` is an excellent example of that in action. Looks simple, actually creates lots of complexity everywhere using it to work around its severe shortcomings.
The uses I can think of all involve emplacing in the queue, using it directly via top, then popping. That‚Äôs why I asked for a use case an example.
Yes but they updated it with emplace. It‚Äôs not like they haven‚Äôt had opportunities to update it.
Ignoring that this is not a good design, you can kind of do it. Wrap your global in: template &lt;typename T&gt; struct Global : T {}; Then define it as: Global&lt;char *&gt; str; Then your ctor can be: template &lt;typename T&gt; Ctor::Ctor(Global&lt;T&gt; str) {} ---------------- One alternative (that is very similar to what you're doing but still not the most elegent imo) is to make an exception type a global struct that has a line number and all the information you want. You can then set the global object and throw it. Do the concatenation right before you print/serialize the error. --------- Or just use a std string....
edit: another way allocate a big array in thread local space. use placement new to allocate and then do a runtime check that the address is in the array. beware this will probably not be any faster
`__builtin_constant_p`
https://stackoverflow.com/questions/20149471/move-out-element-of-std-priority-queue-in-c11
That's a nice and simple IDE, but I built it this morning and it definitely isn't simple to setup, especially for beginners.
Use a \`vector\` with \`push\_heap\` and \`pop\_heap\`. You can do whatever you want with the elements vector as the \`push\_heap\`/\`pop\_heap\` preconditions are satisfied when you call them.
Is partial ordering still in the language? Never read about this on cppreference
It is not wrong to wish that exceptions not allocate memory dynamically. Not for performance reasons though. There is no perfect solution, but your templated ctor is as good as it gets.
The problem is not bloating the interface, it's arity. There are two versions of `sort` today: - `std::sort(begin, end)` - `std::sort(begin, end, comparator)` If you add the container version, then suddenly you have a problem with the 2-arguments version: - `std::sort(begin, end)` - `std::sort(vec, comparator)` Which overload should you pick in which case? You quickly get into SFINAE galore, and so the decision was taken to wait for concepts (and ranges). --- *Of course, in hindsight, the error was not using ranges from the get go, with a quick `make_range(begin, end)` for the case where you have two iterators. Everything is easier in hindsight...*
C++ doesn't let you express the lifetime of pointers or references, in opposition to other languages.
Out of memory is one of those conditions that shouldn't be handled at this level and so you shouldn't bother worrying about. There are cases where the allocator might be able to reclaim memory from somewhere, but that should be handled by the allocator, and maybe a special signal to the application, but not through the general exception mechanism. Why? Because OOM is really really special, and generally means death. It's also nearly impossible to actually detect on systems that have virtual address space. Did you know that on Linux you can crash due to out of memory long after your application has made all of its allocations?
[removed]
Wasn't emplace added as part of C++11, when move was also first introduced?
You have to write your constructor starting with capital letter as the class name Player instead of player
Please watch Herbs talk on the difference between ‚Äúun/handleable‚Äù exceptions. Specifically in a low memory situation you just can‚Äôt do anything sensible. It should just be ::terminate(). Anyway, gcc/clang has a nice extension for static strings. Using attribute((format)) and then you‚Äôll get a warning for non-static compile time param. Still what everyone else said is right.
You can emplace any time you like, but you can never move out. priority_queue is a Hotel California for move-only types. Same goes for std::set for that matter.
A pop\_value() function would have been nice.
Real time systems disable exceptions in the compiler. Even if we are not talking about life-and-death areas, almost all console games you saw in your life until the last few years (before the indie/Unity boom) are written in C++ with exceptions disabled. Enabling them is often not even a developer's choice, it can be a platform limitation. Same is true for the majority of AAA PC titles, although we have some deviants in that area. Trying to save some pocket change by removing an allocation from something as slow as exception is like ordering five triple-meat double-sauce XXL burgers with a cup of diet soda. Sure, it's healthier, but the heart failure is still gonna get you before your 50s.
Thanks AppleBeam, you are clearly an expert in performance of memory managers. I know who I need to talk to if I need any advice in the future.
Can you explain some more about what's going on in your first block of code? It's not clear to me how it relates to dependent types, other than that it uses non-type template parameters.
It's not really that difficult to avoid in practice. Just assign it to a variable. You would have to do that to sort it anyway. With macros highlighted a different color, I have never had any confusion. Pragmatically it is a good way to keep things simple and readable.
Right. But stroustrup's idea was "where do you stop?". For the STL the thought is to provide only the absolute necessities (in his eyes). But I personally agree with you.
I don't think it is dumb at all since I have gotten a lot of good out of it. It is just a shortcut for typing out begin and end, it isn't meant to hide anything or act like a function. The few macros that I use, I use because of something specific to being a macro, which usually just means cleaning up something verbose in the same scope.
The example class that you wrote illustrates some interesting details. There are, again, two distinct possibilities: 1. Your colleague is a moron. File name string has a static storage duration, so you don't need to copy it. 2. Your colleague is not a moron, because you are writing something weird (possibly with plugin support or something like that) and he keeps in mind **that one case** where throwing the exception unloads a DLL during the stack unwind (because, dunno, you load them with RAII objects or something like that), and the pointer to the file name becomes dangling. Problem is: this probably won't work anyway, because regardless of which ABI you are using, someone has to destroy the exception object afterwards. This certainly won't work if the exception class is defined in the library that is being unloaded, and it may not work in all the other cases (not entirely sure if we'll keep referencing some code from the place where the exception was thrown, you'll have to ask some ABI experts for that). Your original question tries to ask the wrong thing then. Even if you are throwing MyException("this is a literal", ...), for this case the literal itself will become unloaded. So, all-in-all, most likely we have the case 1, and your colleague is a moron. You have my condolences.
&gt;Same goes for std::set for that matter. In C++17 you can "extract" a node handle that you can move the value from. std::set&lt;T&gt; s = ...; T x = std::move(s.extract(s.begin()).value());
div() takes as its second argument a (dependent) type that is guaranteed to be non-zero. Since we‚Äôre talking about input, it means an input monad that either asks for input repeatedly until it satisfies the predicate, or returns an optional. It‚Äôs just a proof of concept, potentially you can parametrize the input source for generality (even by something constexpr, why not) and make more GuardModes for finer handling of incorrect input. The point is, you just have to make sure that GuardModes are bug-free, and you can use them universally to enforce contracts at compile time.
The main problem I see is that you can‚Äôt prove, for example, that (n &lt; 10) from (n &lt; 5) without making a derived class for each number (on second thought, maybe this can work though some template magic?). Does anyone know a solution or a bypass?
Not everything has to have every damned thing.
More compile-time guarantees is never a bad thing. Humans aren‚Äôt good at not making stupid mistakes.
Ah I was wondering what it be called here. Extract sounds nice (popmove didn‚Äôt have a very nice ring)
This looks very promising and well thought out. If you need help, I could look at the Windows port. Did I miss something or is there no link to a source repo yet?
I'm not the author, but you can reach the repo on [github](https://github.com/cycfi/elemental).
You want to accomplish that users only use literals, which implies that the message has to be known at compile time, which in turn means you should be using a different interface. Just use an enum with all the possible error conditions instead. If you really want to use strings you can use a wrapper object: class ExceptionReason { const char* m_reason; ExceptionReason(const char* reason) : m_reason(reason) { } public: static ExceptionReason reason1() { return ‚Äúsome reason‚Äù; } static ExceptionReason reason2() { return ‚Äúanother reason‚Äù; } }; And use this as an argument to your exception.
Whilst I also am very intrigued by dependent types, I'm not sure it's the kind of thing that will be in C++ for the forseeable future. It would seem to require sweeping changes to the entire type system. The closest you could get would be to represent the transforms with explicit new types - so you transform b into some `non_zero` struct which has some guards to ensure the invariant.
We could really use some fast-track branch where proposals are merged once approved and pre cpp11 compatibility is not guaranteed =(
That is exactly one reason - not many. But yes, not having the time is of course a valid answer everytime someone is asking "Why isn't X in the standard".
I have thought about something like this too. I think it would be best as a static analysis tool rather then a language proposal.
Agreed. C++ really needs to fork at this point, a lot of evolutionary baggage thrown away, and a new base camp set up. Instead of spending so much time trying to hack stuff into a language that doesn't fundamentally support it, I'd argue for putting that time into C+++.
Is there a general facility for this with ISO standards?
I like encoding known properties in types, but C++'s typesystem is also not really suitable for proving invariants. Case in point: See your example with a slight modification in line 50: https://godbolt.org/z/na1In8 Or from the article you've linked. Let's try to create a correct append function for std::array's: https://godbolt.org/z/xbpTdv Well, we cannot prove that the values are correct at compile time (in e.g. Coq we could prove it), but hey, at least we know at compile time that append returns arrays of the correct size just by looking at its signature. Except that there is a function with the exact same signature which does not return an array (https://godbolt.org/z/ffpu7f).
How smooth is it as compared to the native theme,?
A promising GUI library without an awful license! I'm excited.
Do you guys hire contractors?
Looks promising. The code style looks a bit dubious, though. In particular, I noticed both prefix and postfix underscores are used for variable names. E.g.: _dirty = dirty_;
Glorified goto doesn‚Äôt count :D
It sounds like you are encouraging that they take on a high risk of breaking one of the core expectations of C++, which is that it remain backward-compatible. Let's not do this. Standards should be reserved for things that we can confidently say won't break anything, given reasonable analysis. If you want bleeding edge experimental features then you should be able to use an experimental compiler or library to do it.
False premise. By this logic, C++ should be scrapped and built from scratch - an unsafe foundation is stll unsafe. Moreover, Dependent Types are hardly worth the bother for Compile time guarantees. Focus on Linear/Affine types then - more ROI, more safety. Stuff like this is simply mental masturbation, as if C++ was not already an over-complicated beast.
I disagree, at this point c++ has so much cruft in it that is holding back the language, much like user space facing code in the Linux kernel. If we can abandon it then the language itself can be drastically improved.
I suppose the best solution would be a Typescript-esque thingy that transpiles to some standard of C++.
Stuff like this is simply experimentation. A properly designed programming language does not yet exist, but languages like C++, Rust, Haskell and Idris are all approaching perfection from different sides. Maybe one of the latter three will get there (they at least don‚Äôt have C++‚Äôs legacy), maybe someone will apply all the accumulated experience and build something from scratch yet again, but there‚Äôs no reason not to experiment with whatever tools we have, not to push the boundaries. And C++ is only overcomplicated if you count the stuff you‚Äôre not supposed to use.
Good insight about slips in software development. It has been my experience as well, that as soon as start going for "one more feature" , you not only get behind the schedule, but the quality suffers, since the feature may break existing code, and it was not yet properly tested. I am glad the committee has found the way to be more productive with the language, and it shows. The most problems with c++ are the years of legacy, which complicate new features, not the process of adding them.
Looks like it uses cairo for text.
Well, if C++20 contracts actually end up working like this, it will be better. I doubt we can express all contracts through templates like in the first code snippet.
Yep. See https://en.cppreference.com/w/cpp/language/function_template#Function_template_overloading where it says ‚ÄúWhen the same function template specialization matches more than one overloaded function template (this often results from template argument deduction), partial ordering of overloaded function templates is performed to select the best match.‚Äù
I like to imagine it‚Äôs misclicks on mobile.
But the exception object is allocated on the stack, and if you run out of stack space then the process will crash anyway. So they haven't really solved the problem.
What about releasing C++ standard more often like every year? Same philosophy: ship what is ready; but instead of waiting for another 3 years cycle for an almost finished feature, we would wait only for another year.
I can think of two possible solutions. First, there's a trick that I've seen used to guarantee that a string is a string literal, using a UDL: https://godbolt.org/z/uoSTBm The fact that the string_literal constructor is private, and only accessible from the UDL, means that it can only be constructed with a string literal. That gets you the guarantee you want, but only for constant strings. If you want to have strings that are defined at runtime, another option is for the exception class to have some statically-scoped (possibly thread-local) storage of its own, and copy the message into that in the constructor. Something like this: class MyException { static char s_msg[1000]; public: MyException(const char *msg) { strncpy(s_msg, msg, _countof(s_msg)); } };
Contractors who commit to long term full time, yes
Consider: - they only meet twice a year, - the final meeting before an IS is entirely focused on shipping the IS, - it usually takes multiple revisions of every consequential paper to present, polish, tweak, and refine the wording for the standard. Consequently, nothing would get done.
&gt; If we can abandon it then the language itself can be drastically improved. AFAICS many people agree on this generally. But they can't seem to reach a consensus on _which_ features need to be abandoned.
You get mostly the same issue if you replace exceptions with ```for(;;)``` except that side effect free infinite loops are UB in C++.
And of course we already have C++ without the backwards compatibility, it's called D and no one uses it. A hard break in C++ backwards compatibility would most likely kill the language
It'll be useless without an implementation and Implementation is hard since there is no single one.
I was definitely thinking with contracts. I would be very interested in any project like this.
Interestingly we have had Comeau C++ compiler back in the day for these purposes.
Not recently, but from early on in my career: it's effectively a code generator for C.
That's a new language -- not that there's anything wrong with that. Even today you can take the standards document and "fork" and call it your own. Good luck with the naming tho.
&gt;so perhaps we could call it co_cpp20. This meme continues to make me chuckle.
I don't know if it would kill the language. Industry would diverge from the standards body, refuse to adopt problematic standards, etc. HOWEVER it would waste a lot of people's time and money, and damage the community's reputation.
I continue to be amazed by Herb's ability to make complex issues seem crystal clear!
That is only a perspective of templates. Templates don‚Äôt capture the entire ‚Äúessence‚Äù of C++. To me the closing brace `}` is at least as much at the core of C++ as templates are.
I personally don't think C++ *has* a core or singular essence, so I don't think the question can be answered. A snarky answer might be "the C language" since that is what C++ was built on top of back in the beginning. Probably the best honest answer I could provide - thought I don't know that this counts as core/essence of the language - is to understand that templates are "type constructors" (as they're known in other languages) and not just classes/functions with a bunch of placeholders. In turn, this is why I get pedantic about saying "class template" instead of "templated class" and the like, as the latter implies that templates are just things-with-placeholders which is very incorrect. Type constructors are basically functions that operate on types instead of values. They take input and produce a type. Class templates (and by extension, alias templates) take some inputs (the template parameters) and produce a new type, just like a regular function takes some input values and produces a new return value. Likewise, a function template takes some template parameters and produces a new function. (The ability to auto-deduce function template parameters, and now class template parameters, makes these templates sometimes _look_ like they're just regular functions or classes, but that's just a convenient sugar that hides the actual mechanism.) We'd call `int abs(int)` an integer function, not a functioned integer. :) Thus we call `template&lt;class T&gt; class ex;` a class template, not a templated class. Its "templateness" is core to what it is and how it works, while the fact that it produces a class is more about how it is used. Likewise, for `int abs(int)`, the concept of "function" is core to what it is and how it works, while its return type of `int` is more about how it is used. I've found that getting people to think about this correctly not only makes template programming *significantly* easier for them to grok, it also helps them understand corner cases of the language. e.g., people who understand what templates fundamentally are never ask questions like "how do I make a function pointer to a function template" or "why can't I have a virtual member function template" or so on. Not just because they happen to have learned the specific answer, but because they can intuitively understand the answers and can extrapolate the consequences of a function template not actually being a function at all.
Well, yeah, the std::string approach is definitely not feasible. It's useful as a point of comparison, though - there's a point where the extra complexity of avoiding a heap allocation outweighs the cost of just doing the heap allocation. (And I'm also not saying that your proposal is at that point, I've just found that it's a useful technique for evaluating proposals in general.) I wonder if it comes down to what you're familiar with - if I had a stronger functional programming background, then treating an interpolated string as a higher-order function would probably feel more natural. &gt; To transform a variadic function call in a tuple, all you need to do is invoke a constructor. I didn't understand this part - does std::tuple have a constructor that takes a callable object, or something like that? &gt; The variadic version I posted here in the comments is even nicer for that, and allows you to do this in a single pass. Do you mean this one? https://www.reddit.com/r/cpp/comments/cc2j0w/rfc_early_draft_of_interpolated_literals_proposal/etlbmfi/ That implementation has a quadratic worst case, since you're using += for each element in the interpolated literal.
&gt; ### Are we sure that our quality now is better than when were on plan (1)? &gt; &gt; Yes. &gt; &gt; By objective metrics, notably national body comment volume and defect reports, C++14 and C++17 have been our most stable releases ever, each about 3-4¬¥ better on those metrics than C++98 or C++11. And the reason is because we ship regularly, and put big items into TS branches first (including full wording on how they integrate with the trunk standard) and merge them later when we know they‚Äôre more baked. I would emphasize the "big items". As mentioned, C++14 and C++17 were "minor" releases. It is not clear to me that the lesser number of defect reports for them is predictive that C++20 will generate less defect reports than C++11 did. C++20 will likely contains quite a few big features: module, concepts, constraints, coroutines, ... It seems harder to properly foresee the interactions of those features with the other features (and with each others), and thus more likely that a greater number of defect reports will come. Now, don't get me wrong, a higher number of defect reports is not necessarily a bad thing! I'd rather move forward with some wobbling than stay immobile. It does, though, make me wonder whether the "higher" quality is linked to the choice between options (1) and (2), or just a coincidence.
The introduction of a garbage collector was a really big break...
Compilers can (and do) have more frequent releases that include experimental features. Standards, better not.
I couldn't find the license, where is it?
I would really like to agree with you but I can't. Some new features certainly give headache to lot of us. Examples are std::future &amp; async story, initializer_list and CTAD. You can't excuse them with legacy
&gt;The license will remain permissive and liberal (currently MIT) Also at the top of all files.
That questions like this are nonsense.
What's wrong with CTAD?
Do you know nanogui [https://github.com/wjakob/nanogui](https://github.com/wjakob/nanogui)?
Looks nice, hope to hear more about how it stacks up compared to existing libraries.
That's unfortunate.
What‚Äôs up with this function argument style of putting the comma at the beginning of the line instead of the end? Is this a git workaround of some sort?
Wasn't std::async something that would have waited, if they haven't been so fixated on finally getting c++-11 out the door? I think the article indicated to me that something that wasn't ready would have been deferred 3 years, rather than be forced in to the standard because it had taken so many years already, and they just wanted it released!
To make it short. It's the edge cases and it's hard to get them behave correctly for all cases.
Indeed. If there is one thing I learned then that C++ is a Hydra. You think you understood one thing? Well until you realize there's more to it.
Aren't they meeting three times a year? Also, the committee works in stages. They are already discussing papers that will go into the standard in c++23 earliest, so I don't think it would be quite that bad. But still, I agree that a one year cycle would generate far too much overhead.
I used to use "\_" prefixes, but switched to suffixes "\_" - it avoids the needless bikeshedding around the fact that really the "\_" prefix is reserved for language/runtime/implementation...
Why is that? What are better alternatives?
It's for easy rearrangement of arguments using copy/paste. That's why I do it, at least.
&gt;the fact that really the "\_" prefix is reserved for language/runtime/implementation... Only if it preceeds an uppercase character.
Right, but better yet - just don't do it, no need to make people think, and go back to manuals and standards, just avoid it, and that's about it.
&gt; Tying error codes to file/line seems... off Ah, I probably misspoke with "store that with file and line number" my fault- the implication was intended to be "in the exception object" We would associate the error code with line and file at the location of the error. e.g. throw ErrorCodeException{ make_error_code(AppError::FailedToGetWindowContext), __FILE__, __LINE__ };
give the programmer free will and don't bound them by pointless restrictions
Yep, me too.
&gt; Also, note that since we went to (2), we‚Äôve also been shipping more work (as measured by big/medium/small feature counts) Have any big language features been introduced into the standard since c++11? &gt; No problem! We can just pull it. &gt; [...] &gt; We have actually done this before, with C++0x concepts. Concepts where pulled in the c++11 process which followed (1). Have any features been pulled in the new model? I'm not against having a fixed release schedule. I'm just saying the committee has yet to prove that they are actually able to introduce major, high quality language features into c++ in this model.
Slicing. &amp;#x200B; `class B {...};` `class D : public B {...};` `D d;` `B b;` `b = d; // doh!`
Cairo docs recommend using Pango.
See my other comment - this solution was in use for a while (with larger buffers) but these exception objects get allocated on the stack even if not thrown, and so large exception objects lead to excessive stack space usage / stack overflows.
In practice, you can catch stack overflows on Windows and Linux. However, you can't catch std::bad_alloc from inside an exception ctor (in practice or in theory) - it just calls std::terminate.
Sounds nice, but mac-only is a non-starter for me :(
Yes, this would work. In some ways, it's the best solution so far. Comparing the three solutions: * Just using a message is dangerous as described, requires changing the code in one place (exception call site) when adding a new exception. * using private ctor is safe, requires changing code in two places (exception call site, and new factory method) * using error codes is safe, requires changing code in three places (exception call site, error code enum, enum to string mapping).
I think you've missed some of the pertinent details. Using strcpy makes the class to be idiot-proof - any parameter that type checks show valid and defined behavior, regardless of whether it was statically allocated or dynamically allocated. If it's possible to restrict to statically allocated data in the type system, there would be no strcpy - my colleague added the strcpy because it does not seem to be possible to restrict to static allocated data in the type system.
Or global.
^(Please explain the joke...)
But how is that better than putting the comma at the end of the line stead of at the beginning?
I can't really think of any existing ones but I usually just write my own sdf and or bitmap text renderer, it's not very difficult - took me about a day I think.
Wish I could upvote the hell out of this comment!
&gt; does std::tuple have a constructor that takes a callable object
So you can swap with the last argument easier. Usually the first argument doesn't change position.
It's a reference to the coroutine syntax `co_await`, `co_yield`, and `co_return` - rather ugly names chosen for backwards compatibility reasons.
&gt; does std::tuple have a constructor that takes a callable object No, what I am saying is that it is trivial to do: auto tuplified = f"hello world {a} {b} {c}"( [](auto... xs){ return std::tuple{xs...}; }; Compared to: std::apply(target, f"hello world {a} {b} {c}".as_tuple()); The latter requires the use of std::apply, which is not a simple mechanism. The former is just a function call that returns a new tuple. --- &gt; That implementation has a quadratic worst case, since you're using += for each element in the interpolated literal. You're missing the point - that implementation is surely terrible, but the variadic interface allows you to do much better. E.g. std::string&amp; operator+=(std::string&amp; s, InterpolatedLiteral auto il) { il([&amp;s](const auto&amp;... xs) { s.reserve(calculate_size(xs) + ...); // 'calculate_size' attempts to do its best to figure out how // many characters would be required to stringify 'xs'. // For literals, it would return the number of characters. // For integers, it would return the number of digits. // And so on... (s.append(xs), ...); }; return s; }
AFAIK: Basically there were concerns with coroutines that the keywords you'd expect (await, return, yield) were already in use in various codebases, so defining those keywords to be used with coroutines would have caused backwards compatibility issues The solution they came up with is to prefix them with co\_, so now we have co\_await, co\_return and co\_yield Many people view this as unreasonably clunky and that introducing these keywords (which makes writing all future coroutine code more annoying than it needs to be) is silly Now we're just prefixing co\_ to everything because its fun
That everything in the end is just a bunch of bytes, and we are telling computer how to juggle them. And for all other tasks we are politely asking OS to do something. This is a very simple concept to grasp, which took me a few years.
That's why I marked it as `static`, so that the message is a global. It's essentially the technique of preallocating any buffers that you might need to use while handling OOM, but allocated in the BSS section to minimize the cost at runtime. The tradeoff is that you can only have one active exception (or one per thread if the array is in thread_local storage), so it may or may not be reasonable for your scenario.
This is something I really love about the nerd community. It's not uncommon for high-effort feedback from complete strangers with a common interest in honing each others technical ability, and contributing to the community at large. If you haven't thought about it already, this constructive feedback and the nature of your response gave me the thought of putting a link at the top of your article inviting people to put together a PR or raise an issue.
&gt;I'm not sure why you are singling out exceptions, as there isn't *any* operation in C++ that is deterministic What? Plenty of operations in c++ are just as deterministic as they are in c.
Oh. Ohhh! I get it now. I was stuck on the tag dispatch design that was in the original post, so I think I was misinterpreting a lot of stuff you were saying. Passing all of the fields in one call to a variadic function makes a ton more sense.
You could build an AST that represents the expression, and use properties like transitivity and the order of naturals to prove this kind of thing Ideally this would be done at compile time, so if you can prove that the condition that some type imposes implies some other, you can elide the check entirely.
My top 3 are all to do with letting me use more standard C++ in embedded systems. Metaclasses also excites me because it means we can do more stuff in libraries rather than as language features. * [P1105](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1105r1.html) Leaving no room for a lower-level language: A C++ Subset * [P0709](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0709r3.pdf) Zero-overhead Deterministic Exceptions * [P0829](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0829r4.html) Freestanding Proposal * [P0707]http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0707r4.pdf) Metaclasses
default_order_t was reverted for breaking ABI.
Can you provide some examples of persistent problems in the wild? (Excluding design limitations, like partial CTAD not existing yet.)
that's called linking to libClangDriver and friends :D
It's somewhat similar to what zig does. I would also consider Gnome world to implement essentially the same stratigy in C (GError).
you should give yourself flair :D
Here's one I heard from some people: CTAD can't be used generically because of the copy deduction candidate taking precedence over the initializer list constructor. std::vector v{t}; Different `T`s imply different `decltype(v)`? Nope. The `v`s are the same if `T1 = int` and `T2 = std::vector&lt;int&gt;`.
Yeah it's 3 meetings. &gt; But still, I agree that a one year cycle would generate far too much overhead. Yeah, ISO would not be happy. There must be some time for the NBs to accept the draft. That can't happen in a week.
Excellent. Thank you for all your work on this project.
&gt;I personally don't think C++ has a core or singular essence, so I don't think the question can be answered. &gt; &gt;A snarky answer might be "the C language" since that is what C++ was built on top of back in the beginning. There's the C core, the "C with classes" core (predominately featuring classes, as well as \`new\`, \`delete\`, operator overloading), the "modern C++" core (featuring RAII, smart pointers)...
This is a brilliantly lucid essay which directly addresses the subject of the title and provides perfectly balanced introduction, discussion and conclusions of the problem. And the upshot is absolutely right: make a plan **and stick to it**: release just what is ready every three years.
Why would the first arg switch places less with other args than the last arg?
Because it's usually the struct or class object that's being operated on. This is speaking from personal experience.
 **Type:** Part time/summertime remote work **Description:** I'm a C++ programmer, been using the language for almost 6 months, I have experience in writing source codes for console apps only. I know it's not much experience, but posting this just in case someone could use some help from me **Location:** Hungary **Technologies:** C++ **Contact:** DM me here on reddit
*The* C++ reflection library or *a* reflection library?
Maybe there's something I'm missing, but why don't they just coordinate over the Internet?! A great many endeavors these days do not require everyone being in the same physical room to make progress.
Especially these days
Fair enough, although I think that design choice leads to fewer surprises.
It's *the* only to provoke interest (and because I am the author). I think that's OK - people putting things in a certain way for them to get more publicity, otherwise, the page would have been titled "What I would like to share about my compile-time reflection library for C++ - refl-cpp" and it wouldn't be very tempting to click, because I am not Elon Musk. I am sorry you are bothered by that.
C++17 wasn't a minor release.
dynarray was pulled from C++14.
We all have day jobs. The face to face meetings force us to take a break from our day jobs and spend a focused week on ISO C++. Also, for consensus building, there's no substitute for face to face human interactions. A lot of important work gets done in one on one conversations in hallways, restaurants, and bars. A lot of work is done electronically. One of my study groups, SG15, has met 9 times via telecon since the last committee meeting in February. There's really no substitute for a face to face meeting.
The three spaces everywhere scares me
&gt; Referring to C++ as a language with only low-level, systems use cases in this day and age is erroneous, as well-written modern C++ code makes good use of abstractions provided by the standard library and very little unsafe, direct memory access. Perhaps monolithic software programmers in C would also benefit from reading this statement. Is the next series installment on how to statically link against both the C++ run-time **and** standard libraries in order to provide this safe memory access? Your understanding of programming is limited to application development, you should keep your statements in line with that reality.
&gt; The one thing I don't get is this: if herbceptions are really zero overhead, why is there still a need to remove exceptions from STL? Surely we could get a zero-overhead bad_alloc thrown in case of OOM? This is covered in [the specification](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf), page 29+ specifically.
should be fine, as long as you use cairo correctly.
You should have continued to use `_` as prefix. Statements made by clueless people is not "bikeshedding", it's just clueless people spewing out garbage. I've always thought that `anything_.looks_weird` (i.e., underscore followed by dot).
At work I do use MSVC, at home - I don't care - really either clang or gcc. This is from MSVC - https://docs.microsoft.com/en-us/cpp/cpp/identifiers-cpp ``` Use of two sequential underscore characters ( __ ) in an identifier, or a single leading underscore followed by a capital letter, is reserved for C++ implementations in all scopes. You should avoid using one leading underscore followed by a lowercase letter for names with file scope because of possible conflicts with current or future reserved identifiers. ``` so simply avoid the leading _, just forget about it... Now when I'm coding in Dart, I do use it, as this is how "private" works there.
&gt; Referring to C++ as a language with only low-level, systems use cases in this day and age is erroneous, as well-written modern C++ code makes good use of abstractions provided by the standard library and very little unsafe, direct memory access. Systems programmers must be competent with pointers and data object duration. It is a necessity of monolithic software development which encompasses operating system kernels, micro-controller and other real-time software systems, etc. as programmed in the C language. Your understanding of C++ programming is clearly limited to application development conventions in that language. You should keep your statements in line with that reality because you do a disservice to those of us who understand and convey to others that C++ should be thought of as multi-disciplinary programming language. Conventions for application programming should not be confused with conventions for systems programming even if the underlying language is the same. After all, many systems programmers don't even have a Standard C Library implementation available since the programmable processor they're programming isn't a host system, meaning it has no notion of standard input or output. These programmers use the C or C++ languages because writing complex software requires less effort in those languages than in Assembly and because modern optimizing compilers for these languages produce extremely efficient instruction code compared to when most systems programmers used Assembly.
I usually do that to get better diffs. Adding a parameter changes only adds a line, instead of changing one (adding a comma) **and** adding one.
Thanks, didn't know or was actually in the working draft.
Thanks. I know I didn't say it explicitly, but I was actually asking about (nontrivial) language features like space ship operator or even coroutines. Those are imho the "dangerous" ones.
If the clang parser/generator is stable this seems quite awesome.
That looks completely reasonable to me.
The `std::boyer_moore_searcher` was pulled from C++14, only on the accounts of unclear wording.
Thanks. I already clarified my post that I was asking about language features. I think those are the problematic ones. Did the searchers get actually pulled from the working draft or just not merged into it in the first place?
Members are not filescope though
&gt; I already clarified my post that I was asking about language features. And I had next to no sleep last night, so I skipped over that part. &gt; Did the searchers get actually pulled from the working draft or just not merged into it in the first place? They were in the WD up to the very last meeting. In the last C++14 meeting they got pulled. In the words of Marshal Clow: "I knew what I wanted to say, but nobody else did!" And that's about some detail that they noticed very late. He said he figured out the right wording to make things clear in the very first C++17 meeting and the searches were among the first, if not the first, C++17 features voted in.
Why thou? If you're going to transpile, use C instead, so that you can leverage existing compilers AND compile fast. Let's say that compile time is not one of C++ best feature.
That section doesn't make a coherent case for abort-on-OOM, it makes excuses. What's the actual argument there? "It's hard, it causes code to be generated, fuck it let's just abort" is just not a professional attitude to writing software.
Does the C standard actually make any guarantees on how deterministic operations are? Citation needed, I think...
Some of this dangling problems are caught by Visual Studio Static Analyzer (in background mode, putting squiggles on the offending lines). For example: ```c++ generator&lt;int&gt; f(const string &amp;s) { for (auto ch : s) co_yield ch; } void dangling_ref() { string s = "Hello\n"; for (auto ch : f("Hello\n")) // squiggles here: // Don't dererence a pointer that may be invalid at line (*) (*) putchar(ch); } void not_dangling_ref() { // no warning here string s = "Hello\n"; for (auto ch : f(s)) putchar(ch); } ``` Similarly, we are working to add checks for lifetimes related to lambda captures in coroutines.
You're awesome. It's such a cool tool I feel like I should link for anyone who doesn't grok the tool - https://www.youtube.com/watch?v=4_HL3PH4wDg
what should happen if the move constructor throws?
Check out littlevgl too.
&gt; That section doesn't make a coherent case for abort-on-OOM You're right. In section 4.3.3, it makes a case for: * Re-specify each language operation and standard library function that could throw `bad_alloc` today to have implementation-specified behavior, which each implementation specifies exactly one of the two following alternatives: (a) undefined behavior on systems that cannot detect heap exhaustion (e.g., Linux systems that overcommit); otherwise, (b) as today, call any installed `new_handler` else `terminate` by default, with the additional restriction that any installed `new_handler` must `terminate` (it can no longer return or throw). * For each standard function for which allocation is the only reportable error, make the function `noexcept`. (We expect this to result in making a large majority of functions in the standard library `noexcept`, including default and user-replaced ::operator new.) * For code that wants to handle heap allocation failures, provide explicit ‚Äútry to allocate‚Äù functions including the existing new(nothrow) 11 and try_ functions like those being proposed in [P0132R0] (e.g., bool vector&lt;T,A&gt;::try_reserve()).
What kind of license the library use?
C++ is all about RAII
Ah, I stand corrected. My fault for reading old mailings from the 2000s recently.
Harfbuzz
Is there a non-LGPL alternative to Pango?
Nice one! Really appreciate all the work you and your team put into it to make it such an awesome tool. But,...,vim mode pls?
I wasn‚Äôt bothered. I just thought this was a post about the reflection proposal at first and was confused at first. No need to read negative intent where there is none.
The significant language features imo are: C++14: generic lambdas, generalized constexpr, return type deduction for functions, variable templates C++17: `if constexpr`, structured bindings, CTAD, guaranteed copy elision, inline variables I don't know what you consider "big" but those are all very impactful. C++17 also has fold-expressions and `template &lt;auto&gt;`, which I would rank lower on impact scale than those above.
You can do T x = std::move(const_cast&lt;T&amp;&gt;(pq.top())); pq.pop(); This is safe.
I'd argue that this is a problem with initializer_list, not CTAD.
It's simply installed to the wrong folder and copy/pasting it manually works. Someone uploaded the fix as a new extension it looks, too
 #define await co_await #define yield co_yield SCNR
Huh? This was an explicit rule introduced only for CTAD. Could you elaborate?
The problem with D is not that it isn't backwards compatible.
There would have been no need to introduce it if initializer list weren't a thing. If we were adding initializer list to the language after CTAD and had to introduce the very same rule, you wouldn't be blaming CTAD for that, right?
Just strip that horrible keyword design. I've fine with C++20 without coroutines. Let implementers focus on modules/concepts/ranges.
Sutters disagrees with you: &gt; ### ‚Ä¶ and C++14 and C++17 were minor releases, and C++20 is major? &gt; &gt; Again, I think the right comparable is C++14+17+20 taken as a whole: That is our third 9-year cycle, but because we were on plan (2) we also shipped the parts that were ready at the 3- and 6-year points.
Do you mind sharing?
[llvm 2019](https:://marketplace.visualstudio.com/items?itemName=MarekAniola.mangh-llvm2019)
Compared to 11 and 20 it is
Yes, I'm aware.
Seeing the libs author does it have a shot at becoming a part of boost?
I don't like the rule yes, but CTAD and initializer lists can exist without it. You said you blamed initializer lists,; I don't blame CTAD at all.
What's the rationale between public/private headers? Ease of use? Compilation times?
Will I be able to do this with modules: #include &lt;windows.h&gt; module windows; export SendMessage; // actually this is a #define for function SendMessageW export WM_LBUTTONDOWN; // actually this is a #define for some internal value Because the module doesn't export all of windows.h, I expect: * There to be a beneficial effect on compile time. * all the non-exported symbols to be gone from intellisense. * the intellisense database to take up far less diskspace. In other words, will we be able to prune the vast majority of symbols from windows.h, at least for our own projects?
Didn't knew there is a dedicated to for that. Thank you for making code analysis more convenient!
[removed]
Your comment has been automatically removed because it appears to contain disrespectful profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/ccv6r5/compiler_explorer_now_has_an_execution_only_pane/etqyfuw/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
You mean you don't like the \`WIN32\_LEAN\_AND\_MEAN\` hack? What's not to love about [this interface design](https://stackoverflow.com/a/11040290/2296458)!
Doing that makes the compiler see the implementation of functions you are testing, which means the compiler can inline things and hide bugs.
The compiler can inline functions which are defined in headers even when tests are being written in separate sources in separate binaries. Boost and the STL are mostly header-only - millions of lines of C++ templates all in headers and all potentially inlined. This as a potential for hiding bugs is a really weak argument for not trying this.
That's like asking the rationale between public/private data members ‚Äì not everything is part of your public interface.
But you're not testing Boost or standard library, you're testing your own code, so separating your code's implementation and your tests in different TUs can save you from the "inlining hides a bug problem". And yes, my argument is invalidated if your own code is a header-only library.
From the "docs": &gt; The license will remain permissive and liberal (currently MIT).
If someone cares about the potential of inlining to hide bugs they should either annotate their codebase with some optional noinline macro (which I've never heard of anyone doing), or should build their tests without optimizations for that specific reason (which could be done for the production code too when the tests are there). And can you give an example of a bug which will be hidden by inlining? Isn't that a compiler bug? C++ unit tests aren't meant to catch compiler bugs but production code bugs.
In my use case, using the top element has the possibility of pushing a value that would replace it as top element. My main options at this point are (1) copy and pop the top element, or (2) move and pop the top element. I would prefer option 2.
&gt; only You quoted this word but seemed to have not read it... C++ is not a language with _only_ low-level, systems use cases ‚Äì this is an entirely accurate statement.
&gt; And can you give an example of a bug which will be hidden by inlining? Isn't that a compiler bug? C++ unit tests aren't meant to catch compiler bugs but production code bugs. I've heard of something like the following happening: void* f() { return malloc(HUGE_BLOCK); } If inlined, compiler could realize that you're just throwing away the return value, or just `free()`-ing the memory. Clang is pretty good in eliding throwaway allocation like this, so instead of getting a `bad_alloc`, your test throws nothing because it does nothing.
How does this compare to catch2? Do you have updated benchmarks?
I miss that Feature from rust, thanks. I‚Äôll check it out!
The benchmarks were last done with Catch2 version 2.3.0 - released almost 1 year go. [https://github.com/onqtam/doctest/blob/master/doc/markdown/benchmarks.md](https://github.com/onqtam/doctest/blob/master/doc/markdown/benchmarks.md) Here is what Catch vs Catch2 look like in terms of cost of including the header: [Catch](https://raw.githubusercontent.com/onqtam/doctest/4d6c8538fe198f3e1376287402bc0271e5d0541b/scripts/data/benchmarks/header.png) vs [Catch2](https://raw.githubusercontent.com/onqtam/doctest/169d4c8348f9e48b398d9da1e23a72d0e9064833/scripts/data/benchmarks/header.png) \- almost no change. &amp;#x200B; There was one attempt in Catch (inspired by doctest) regarding the compile time of asserts but it doesn't come close to what doctest is capable of doing (see "catch faster" in the benchmarks). Actually Catch could develop a set of asserts which are as fast for compilation as those of doctest, but reducing the compile time for including the header is almost impossible without a complete rewrite and the addition of some restrictions. &amp;#x200B; It takes me a few hours to run the benchmarks and generate the results so I tend to do that only on big releases when there have been substantial changes. I monitor all the development over there so in case anything comes up I might redo the benchmarks.
just because language X does it doesn't mean it's a good idea
hopefully there will be many such projects in the future. In my own [abandoned game engine](https://github.com/onqtam/game) I wrote the tests in separate ```&lt;component&gt;_tests.cpp``` files because I wanted to exclude them entirely from the build by some pattern if I wanted to. There should be more examples of mixing code and tests in other languages that have supported this for ages - this is just starting to enter the C++ sphere.
nor does it mean it's bad. We are C++ developers - C++ is a multi-paradigm language - we like having the choice how to shoot our own foot. I dislike languages that restrict me - such as GO or Java. There will be people who like this idea and indeed benefit from it.
&gt;instead of "templated class" and the like, as the latter implies that templates are just things-with-placeholders which is very incorrect. Wouldn't that mean a class instantiated from a template?
Not directly. Let's look at you code when macro gets expanded: export SendMessageW; export 0x1234abcd; The first line is really close, you need to export an alias: export using ::SendMessageW; The second line does not make sense. You cannot export a value. It need to be an entity. The best way would be to create a constexpr variable then export it: export constexpr auto LButtonDown = WM_LBUTTONDOWN; ---- Another way would be to just import the header as a legacy include, or simply include the header where you need it.
Rust *can* do it. But rust also gives you a way to write separate test files ala NUnit. I mean ‚Äúcargo test‚Äù is an actual command. Personally im not a fan of this because I feel it adds a lot of noise to your code. Unless you write these tests for documentation purposes.
It is a good idea. When standalone code moves unit tests move with it.
I wouldn't do it. Code is code. Tests are test. I see no particular reason to clump them together and just have to rebuild the tests every time I build the code. If you have enough tests to really get good coverage it would make for a very messy and fat bunch of files.
Well, yes, I understand, so is there a c++ example (in code, not writing) with doctest?
well all the examples in the "all\_features" folder of doctest are compiled into a single binary: [https://github.com/onqtam/doctest/tree/master/examples/all\_features](https://github.com/onqtam/doctest/tree/master/examples/all_features) And if you inspect the CMakeLists.txt you'll see that the same source files are used for another target which has DOCTEST\_CONFIG\_DISABLE defined - the idea is to test if everything in the examples compiles even if the tests should be removed. In your code instead of adding another CMake target you would perhaps expose a CMake option which defines this globally, or perhaps add it only to the Release config, or maybe create a new CMake config out of the Release config (and call it "production build") where this identifier would be defined. Does this answer your question?
&gt; all the non-exported symbols to be gone from intellisense They're already mostly gone if you use VisualAssist.
 &gt;we like having the choice how to shoot our own foot. Yes we do! Haha nice. Another thing is that we can try different options and choose the one that stood the test of time.
Thank you for the detailed reply. I am seriously considering your framework. Do I lose anything from catch?
My plan would be to only expose DOCTEST_CONFIG_DISABLE on Release builds, so tests would be compiled into a single binary on Debug. I really miss this feature from rust, I‚Äôll try it out later!
Hi, I'm the author. There are actually Linux and Windows ports. I am currently reworking those right now after some recent refactoring. It will be available again in due time. This will not be Mac-only forever.
well... yes - a few things: * doctest doesn't have matchers * doctest has only 2 reporters written at the moment - XML and a console one - there isn't a teamcity reporter for example * catch has integrated the nonius benchmarking library recently so you can write sections of code that benchmark code inside of your test cases * generators for data/property-driven testing &amp;#x200B; and maybe a few others, but all these are planned, and there are features which doctest has but Catch doesn't. &amp;#x200B; Here is the relevant part of the FAQ (I need to mention benchmarking there as lacking on the side of doctest): [https://github.com/onqtam/doctest/blob/master/doc/markdown/faq.md#how-is-doctest-different-from-catch](https://github.com/onqtam/doctest/blob/master/doc/markdown/faq.md#how-is-doctest-different-from-catch)
&gt; There to be a beneficial effect on compile time. Just as a sidenote and a reminder to everyone, you can bring the header compilation time to zero with [precompiled headers](https://en.wikipedia.org/wiki/Precompiled_header). The idea is that your compiler creates separate precompiled binary blobs from the headers, which can be linked directly, which in turn will then make your subsequent builds much faster. Otherwise you will be compiling the same headers over and over, and some of them can be quite big.
Hi, I'm the author. I've authored 3 Boost libraries already 1) Spirit 2) Fusion and 3) Phoenix. I am not sure I have the energy to submit another. Perhaps... if there's sufficient interest... It's interesting how my post got such a widespread reach in a few days. To be honest, I wasn‚Äôt ready to release this yet, not in this form, so the info is very preliminary, as noted in the introduction: "Let me tell you a bit about Photon (edit: renamed to Elements now)‚Ä¶ From my previous post about Ascend, some folks noticed its existence and actually found the github repository. The repository is rather underwhelming, I thought to myself, devoid of any documentation of any sort, other than a very terse description: ‚ÄúPhoton Micro GUI library‚Äù. I figured perhaps it‚Äôs good to post preliminary information about it, maybe starting with some history and basic architecture and design principles and code snippets. Just enough to give it a bit of justice that it deserves."
1) two sequential underscore characters e.g. __foo 2) a single leading underscore followed by a capital letter e.g. _Foo _foo and foo_ are both OK.
That's _instantiated_ or _fully specialized_. "Templated" is usually used by people to mean a class/whatever had been made a template, at least in every case I can recall taking to someone. If there's a lot of people using "templated" to mean instantiated, that just reinforces to me the importance of using clearer terminology to all stay on the same page. :)
This would probably be more appropriate in /r/cpp_questions or StackOverflow. However perhaps pybind11 suits your needs, it can integrate/run the python interpreter and python code from C++.
Sorry I didn‚Äôt realize I was posting on the wrong reddit, but thanks for the reply.
system("python script.py")? Not sure how much of a "good practice" this would be.
Good to hear. I'll give it a closer look once it runs on windows. Please write another post on reddit once you are done or answer here.
Here are some examples how this is being done in D - it is such a common practice that nobody even feels the need to talk about it and that's why we haven't heard of it... [https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d#L1109-L1121](https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d#L1109-L1121)
The D folks seem pretty happy with it: [https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d#L1109-L1121](https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d#L1109-L1121)
This one works: [https://github.com/pybind/pybind11](https://github.com/pybind/pybind11). And example on how to use matplotlib from C++ is (self-plug): [https://github.com/ThijsWithaar/matplotlib](https://github.com/ThijsWithaar/matplotlib)
If you're using LTO/LTCG, the compiler can do that between different translation units anyway.
I'm pretty sure it is not common practice to include tests in production code in most languages. Certainly not best practice.
or because D has a userbase of approximately 3 people
sure, and it's not common practice to write unit tests in C++... reducing the barrier for writing tests seems the way to go
&gt; The idea is that your compiler creates separate precompiled binary blobs from the headers, which can be linked directly They‚Äôre actually compiler memory snapshots (for MSVC, and I believe all other compilers); I wouldn‚Äôt characterize them as being able to be ‚Äúlinked directly‚Äù.
Awesome! Thanks I will check this out as soon as I get back home. I was starting to think that I would have to rewrite my backend.
This is different from the kind of doctest I see in [Python](https://docs.python.org/3/library/doctest.html) (among others). In these languages, doctest is a tool to extract and run testcase from in-source documentation (which corresponds to doxygen comment block in C++, or the like). It is a useful tool for verifying that the documentation is accurate and up-to-date. If we still need to write ugly macros for the test, then it's little different from regular unit tests. I mean, they are useful, but they are not the kind of doctest that I expect.
&gt; `const_cast` is not an acceptable answer, basically ever.
Interesting, thank you for the information. I always thought they were "something like object files, but not quite". I didn't know that they specifically were memory snapshots.
&gt;sure, and it's not common practice to write unit tests in C++... False
&gt;system("python script.py")? Not sure how much of a "good practice" this would be. It would be a "bad practice".
I agree that the name of choice wasn't such a good idea retrospectively... but naming is hard!
Looks less "natural", works identically, diffs much better. I avoided it for many years because of the first, but now that I'm using source control more heavily I'm beginning to transition. Especially with a codebase that's in a state of severe flux and expansion, it makes commits *much* easier to read.
TDD didn't originate in C++ land - we are lagging in many regards and testing is one of them.