&gt;But afaik this is undefined behaviour, so each compiler can behave differently. Yes, [nasal demons](http://catb.org/jargon/html/N/nasal-demons.html) on my machine.
Last time I checked, my impression was that what be basically complains about the fact that C++ is not like Java or C#. But hey, you can't have a cake and eat it, too. "being like Java and C#" are in direct conflict with the design goals of C++. C++ is about marrying high percormanfe with abstraction (which seems like contradicting goals but they are not). Example1: He complains about having to recompile some translation units when you change a class definition that is included in those translation units. Duh! C++ does not force an additional level of indirection on to you like other languages do. To be able to benifit from this we need to know more about a class (including its layout). Think of creating objects on a stack. If you WANT an additional level of indirection and deal with opague handles you can get it. But you have to say that explicitly. If you do, you can easily reduce the amount of needed recompilation once you change something. Problem solved (possibly at the cost of runtime overhead that is inherent in other languages). Example2: whining about the lack of garbage collection. Sorry, but this smells like the author does not appreciate what RAII (or better yet: scoped based resouce management, making objects responsible for managing other objects and/or resources and relying on the automatic memory for everything else) has to offer. Also, with garbage collection it is widely acknowledged that there is a speed/memory-use trade-off with garbage collection. You can get a program written in a garbage-collected language to save memory at the cost of performance. Or you keep it fast but it might require more memory since the garbage collector is not so quick to collect the trash. That's just bad. Better: Don't even produce garbage. RAII makes this a piece of cake. That ought to be enough for the moment. I can't stand re-reading the FQA and debunkung some garbage again every now when someone comes up with the idea to share a link to it...
Yes, really. This has nothing to do with operator precedence. In C/C++, [sequence points](http://en.wikipedia.org/wiki/Sequence_points) define when you can make assumptions about what side effects have or have not taken effect. The only sequence point in that statement is the entire expression itself. The compiler is free to evaluate the left and right-hand side of the assignment in either order. The result changes depending on the order of that evaluation. 
For example 1, he does not complain about what you claim he does. He states that the problem is having to recompile EVERYTHING, even though only one class has changed. When you change the definition of a class, you not only recompile that one class but everything that the class depends on. This is because C++ lacks a concept of modules. Obviously if you change a class Giraffe, you'd be expected to recompile it, due to layout, or the size might change or whatever... but why should you be required to recompile class Animal, and class Object, and class X, Y, Z even though classes Animal/Object/X/Y/Z never changed? If C++ has a module system you'd only need to rebuild things that changed. The problem he complains about is having to rebuild the thing that changed, and all the things that didn't change. Modern compilers do implement precompiled headers to alleviate the issue, but the issue would simply disappear if C++ provided modules as part of the language. And in fact there is a proposal to add a module system in the next C++ standard (the one after C++11). No where on that site does he complain about a lack of garbage collection, period. He even states that the lack of garbage collection is an acceptable design choice. His complaint was about how the lack of garbage collection doesn't play well with operator overloading and that the end result is some incredibly inefficient copying. This is a legitimate complaint, and one addressed by the new C++11 standard.
Before anyone argues with this, read about sequence points in C++, because AlternativeHistorian has it almost exactly right (technically there's two sequence points there, `j=0` and the rest of the OP's statement).
Let us look at two ambiguous, yet equally valid, run-throughs of this line of code (the point to made here are that there is no way to argue that either evaluation of the following is more right than the other, as this is undefined behavior): **Version 1** x[j]=j++; ^-- is evaluated first x[0]=j++; ^-- is evaluated now which becomes x[0]=0; // j=1 --- **Version 2** x[j]=j++; ^-- is evaluated first x[j]=0; // j=1 ^-- is evaluated now x[1]=0; // j=1
I almost never use pre-increment or post-increment *in* an expression. I just use it as short hand. Readability is too important to me.
Not easily, and it really isn't worth it unless they're running on very memory limited devices.
~~I am tempted to disagree - it is not a matter of [sequence points](http://en.wikipedia.org/wiki/Sequence_points), in this case it all boils down to operator precedence since~~ ~~x[j] = j++~~ ~~is an expression with 3 operators; of those **[]** has the highest precedence so it is evaluated first (and results in some lvalue); the operator **++** is evaluated next (and results in a rvalue - which in first step is 0); it also has a side-effect of incrementing j, but that is no longer relevant here since the lvalue is already evaluated; finally the **=** takes place, so x[0]=0;~~ ~~There are a number of references to something different in some other posts below, but that is different for one very good reason - a function-call (or similar) is having **same precedence** as **[]** - and indeed in such conditions it is undefined behavior, for instance in:~~ ~~x[j] = f(j++)~~ EDIT: OK, after looking again at the actual C++ standard and also reading http://c-faq.com/expr/evalorder1.html I have to concede - the standard is basically saying that *(except where noted) evaluations of operands of individual operators and of subexpressions of individual expressions are **unsequenced***!
I don't believe this is true; [precedence doesn't have very much to do with order of evaluation](http://c-faq.com/~scs/readings/precvsooe.960725.html). x[j] = j++ has four operations: (1) increment j, (2) store the result of the increment into j, (3) dereference x[j], and (4) copy the first value of j into x[j]. The *only* thing that is guaranteed is that the value of j before being incremented is the one that is assigned to the result of x[j]. It is *not* guaranteed that the result of the j-increment is stored into j either before or after x[j] is dereferenced. In other words, legal sequences include any permutation of (1), (2), (3), and (4), so long as (1) happens before (2) and (3) happens before (4). I could be wrong, though; sequence points aren't really my area of expertise.
The preprocessor is the correct way to do conditional compilation. Your particular situation may be solved by providing two separate libraries for users, one including the sub-library and one without it.
Well this: http://c-faq.com/expr/seqpoints.html convinced me, I was wrong. 
You can use a map to store keys and values (allowing you two different data types) or you can create a struct or class containing fields for as much data as you need and store those in a vector. I'd need to know more about what numbers they've given you and in what order they're listed to give you better advice.
He does a very good job of justifying his points. If you know of something in particular that he actually got wrong by all means point it out. People also forget the importance of providing criticism like this. A good chunk of the new C++ standard is the result of people criticizing how hard, fragile, and error prone much of the language is. The FQA isn't written by Joe Blow but by someone with quite a bit of knowledge about the intricacies of the language.
You should do your homework on your own.
If you wrote a Play class representing the individual plays, a vector&lt;Play&gt; could represent a drive. Or maybe you want a Drive class that has a member vector&lt;Play&gt; plays_.
This is why people use build systems like cmake or autoconf. The user doesn't have to fret with -DFOO options. They run the configure script or whatnot, and it checks to see if they have the library that provides the optional functionality, and modifies CPPFLAGS accordingly. 
I'm also doing an engineering project in programming... 
It's definitely undefined, due to a sequence point issue. This FAQ was linked by someone further down: [http://c-faq.com/expr/seqpoints.html](http://c-faq.com/expr/seqpoints.html)
Actually, surprisingly few people read the C++ FAQ. The average level of C++ knowledge and general technical competency would be much higher if most people read the C++ FAQ.
&gt; If you know of something in particular that he actually got wrong by all means point it out. Just glancing at a couple pages: Section 10.4: Painfully out of date. Delegating constructors are in the new standard, albeit implemented only by a couple compilers. But his advice is unhelpful and distracts from the main point the FAQ makes. 10.5: He seems either unaware of or deliberately glossing over allocators. All the standard containers have an allocator policy class parameter, and you can implement your precious stack allocation there. You don't have to re-implement the container from scratch, as he suggests. 10.6, again, is painfully out of date, but most of his reasons for not using initialization lists are complete bullshit if not otherwise unhelpful. He's complaining for complaining's sake. 10.8 seems to be "rebutted" only for the sake of completeness. Nothing he says here is of any real value. 10.9 in the FAQ discusses the cases where RVO is invoked, and the FQA spends four paragraphs lambasting the FAQ for even pointing out that there is a common optimization here. 10.10 might actually be helpful if it weren't written in such an angry tone. (The FAQ entry is too short and doesn't explain the issue well enough, but the FQA's version is written as if everyone's stupid for using C++ simply because `static`s aren't part of an object.) 10.18: The FQA author has no experience with Objective-C or Smalltalk, where this idiom is a normal part of the syntax, and complains loudly that this is both ugly and stupid. I could easily find heaps of programmers that think that style is *beautiful.* At this point, I'm sick of the FQA author's elitist bullshit. 11.2: Why *wouldn't* I want to depend on this behavior? It's sensible and predictable, and even useful. Again, the FQA's author is an elitist and wants you to know that. There's a lot more that I could point out where the FQA is deficient or outright maliciously wrong, but I get sick of his elitist bullshit way too quickly to go through it all.
Your question would probably be better received in r/learnprogramming. It would be refreshing to see an actual programming question in there as opposed to career advice or "I want to learn a language for whatever reason, tell me how to do it!" type questions. 
I've never actually used autoconf on a project of my own, but having run Gentoo for the last 6 months has convinced me that it does good things and that I should understand how it works.
&gt;understand how it works. Oh man. Good luck.
As I said, the recompiling issue is the price you pay for not having an implicit indirection forced onto you. You cannot solve this with a module system -- at least not completely. I hope it's clear what I mean by "implicit indirection". Check Java and C# where you cannot HOLD AN OBJECT DIRECTLY neither as data member nor on the stack. It's all references. In this case it should come with no surprize that you don't need to know the object's layout in order to hold a reference to it. In C++ you can have both. If you want indirection, you have to say so explicitly, though. As for garbage collection: He answers [16.4] with (quoting): "The virtues of new mentioned by the FAQ are not virtues, because constructors, destructors, and operator overloading are garbage (see what happens when you have no garbage collection?)..." The lack of garbage collection never struck me as something annoying with respect to operator overloading -- even before move semantics. Modern compilers can elide many of the unnecessary copies. Not every type is heavy-weight. There are other techniques that can be used. For example: reference-counted copy-on-write or expression templates.
cmake and automake and autoconf and scons and bjam and blah blah blah are the worst thing to happen to software build in decades. The lesson they've taught us is that deduction of dependencies, ie. magic, ought to be studiously avoided.
The issue is that you don't know whether j or j++ will be evaluated first. Operators don't tell you that.
Have a look at the Pimpl idiom AKA compiler-firewall idiom. [Link](http://www.gotw.ca/publications/mill05.htm). With it you should be able to make sure only users who actually use part of a library needs to include its definition. It reduced dependencies and compile time. Edit: Seriously. Its the clean way. The preprocessor is the ugly hacky 80s way.
Ah, classroom questions. Must be that time of the year.
Hi how do you build large projects? Do you just use make?
Yes, absolutely. Make with explicit rules. If your Makefile is so large it's difficult to comprehend, then that indicates a problem in your project structure or architecture, and the proper fix is to simplify (or split apart) your code.
It's unfortunate because it's almost as if you didn't read a thing I said and instead just went off on your own reply addressing none of my statements. C++ is a very complex language, and to ignore its blemishes and just be completely ignorant of them does no one any favor. It's exactly by pointing out the flaws as the FQA does which allows newer revisions of the language to improve. The recompilation issue is both well known and has both a proposal for a module system to correct (meaning you only recompile what has changed without having to recompile what has not changed), and has compiler specific work arounds, such as precompiled headers which do an okay job but unfortunately due to the nature of #ifdefs and the preprocessor do not resolve the issue entirely. The whole 'sufficiently smart compiler' being able to elide copies is to this day a myth, as compilers are unable to elide even basic string copying. You have obviously not tested the copy elision optimization, but that's fine because the author of the FQA has as well as many prominent members of the C++ community such as Dave Abrams (check out his blog C++Next). Copy on write semantics are also heavily discouraged, and the standard library, which used to use COW semantics in the past has gotten rid of them due to their very poor performance with multi-threaded code.
I read everything you both wrote and it's clear to me that you do not understand his replies at all. 
I can see that you've swallowed the FUD kool-aid of the FQA. C++ is not the perfect language, and there is much to be aware of, but he clearly is biased in the article. People here have told you this and you ignore it because you have an existing bias that is confirmed in your mind by the article.
It is also a good source of misinformation and misdirection. I doubt you can differentiate between the real information there and the ignorant bullshit.
What do you want to learn? If you've been through all these books and understood them, you should be able to do what you want with C++. Just reading for fun, or?
Well, none of the Meyers books talk about metaprogramming in general. So for sure that could be one to pick, but I don't know what are the topics of the other ones, how well written they are, or if they blend with Meyers's ones. That's why I'm asking from people that have read them. The final purpose, learn.
Think I'll keep looking here. I have almost read the exact same books and wish to better myself.
Everything you've said to me, I can say right back to you in a converse manner. It's easy to make a statement without providing any kind of justification.
Thanks for your contribution to this discussion, it was invaluable.
&gt; We see the benefit of the feature as outweighing the drawback of the additional size of a static EXE I rarely do Gui, so I don't even understand what it the benefit, So my exe is 1.5 Mgb bigger.
I would suggest picking up "Elements of Programming" by Alexander Stepanov (the guy who created the STL). 
I really liked [Object-Oriented Programming in C++](http://www.amazon.com/Object-Oriented-Programming-4th-Robert-Lafore/dp/0672323087) by Robert Lafore. It is pretty big, but it covers a lot really great topics about C/C++ It also covers a lot of programming paradigm, methodologies, and design patters. It might even cover (in-depth) data structures, when I get home I'll check on that last part.
I just finished the first five chapters of Matthew Austern's Generic Programming and the STL, and I was really impressed. The book has 16 chapters, but the first five chapters alone were worth the price for me. The other chapters seem more like a reference, not intended to be read straight through. I feel like the author does a great job of analyzing design decisions to illustrate good generic programming design. Funny thing is that I have had this book for a while, but read review after purchase that claimed it was more aimed at STL implementors. After finally getting around to spending some time with the book, I couldn't disagree more. I have watched several presentations on "C++ generic programming" and was left feeling like I was no closer to really understanding how to actually do C++ generic programming. After the first five chapters of this book, I don't just have a better grasp of generic programming, I have refactored code in my company's code base to actually leverage this knowledge. I have spent significant time with Exceptional C++, More Exceptional C++, Modern C++ Design, and C++ Template Metaprogramming. I wouldn't discourage you from reading any of these books eventually. But I definitely got more immediately applicable knowledge from "Generic Programming and the STL". 
The equality operator (==) is not the same as the assignment operator (=).
Such as where, exactly? Is there something missing from constexpr, or some feature that would vastly expand its capabilities? I haven't personally taken time to experiment with the feature myself.
man... I remember the days of doing programs like this no more. no, now I have to read fcking RFCs to make sure my implementation is up to spec
try reading an iso spec :O
I would but they want my nonexistent moneys. edit: and I wasn't really complaining about RFCs. The ones I've had to deal with are (obviously) dry as hell, but they were clearly written and informative. They did the job.
[C++ Templates: The Complete Guide](http://www.amazon.com/Templates-Complete-Guide-David-Vandevoorde/dp/0201734842/ref=pd_bxgy_b_img_c) is recommended for deepening your knowledge about templates.
I'd suggest kicking back a bit and waiting for the new books covering C++11 to come out. You already have a nice start but things will change with the new standard. For example something's you might do with template programming today has alternatives in the new C++. Books focused on specific areas of C++ are always of interest though. 
(More) Exceptional C++ is a good read. It's based on [GotW](http://www.gotw.ca/gotw/). But maybe after reading the Meyer books you want something with a bit different content. I'm not sure if Modern C++ Design is still considered Modern. Don't get me wrong, it is a good book. But traits based design isn't considered very modern any more and a lot of the things discussed in the book are available with somewhat different design from Boost. I don't know the book Professional C++. I haven't read C++ Template Metaprogramming. But I read some chapters. I think if you want to learn about metaprogramming and newer template tricks that's the right way to go. It was written by David Abrahams who is one of the major guys behind Boost.
Thanks a LOT for typing this out, this will help me a lot, and you've inspired me to try and refactor my program, also great that you gave me a simple make-example as this have been pretty much black box magic to me so far. I guess one of the things that had me confused is that you include the .h file, but not the cpp file. Always seemed to me that I couldn't control the order of how files are compiled unless I include the actual code and not just headers. So are all .h files read first to have everything "forward declared," so that each .cpp have a reference for functions and variables in all other parts of the program that included those headers? Define in .h, implement in .cpp? In that case it makes a lot of sense because I've been forward declaring some functions out of necessity, but didn't think that maybe that would all work it by itself out if I did h/cpp the right way from the start.
I strenuously object to this notion that you can quantify undefined behavior like this. He has a little table that claims that on Intel architectures, `i &lt;&lt; 33` will result in 4 when `i` equals 2. But this is completely wrong for modern compilers -- recent versions of gcc will simply discard this expression entirely and return unconditional 0, regardless of what `i` contained before the shift. And it is entirely justified in its decision to do so. You simply cannot rely on undefined behavior being anything. 
It's shit like this, C. 
constexpr is great! :D You can also do stuff like recursively defined compile time Fibonacci sequence! http://codepad.org/Ecs7iIsN
Copies of Draft versions are often free. You need the real thing if you are carefully assuring that you meet the exact wording of the final spec, but the draft is certainly good enough to use to make sure your personal understanding is close to reality. Draft specs are also good for learning how to read the somewhat formalized language they use. Oh wait, I didn't say *anything* on topic of the main post? oops! OP -- Did you edit your program after writing the article? The program at that link has no code at all to output the values after sorting, so on what basis do you say that "213 becomes 123"? First step in debugging is to observe, and that means either printing data (cout &lt;&lt; "num1 is " &lt;&lt; num1 &lt;&lt; endl) or observing it in the debugger. You are using Visual Studio -- have you learned how to use the debugger yet? If not, ask about it in class; if so, drop into the debugger and step through the code. The first thing to notice is that the bits of code you use to exchange values between two variables do not actually change the values of anything -- watch as you step over the "num1 == num2" line, for instance, that the value of num1 does not change. Of course, Sc4Freak (top-rated comment at the moment) already handed you the answer to that one. Use "num1 = num2" for much happiness. Long term, the debugger is going to be your best friend and your number one power tool. 
At least C has clear specification on what is undefined behavior, and how stuff is supposed to work.
Totally agree, further more is that there are so many of them so no one knows them all, everytime I get the source to a project I have so spend a good deal of time trying to figure out how to compile the damn thing. Make is absolutely the way to go.
Modern C++ Design is the only one on the list I've read but I can say that it is awesome - covers basic template metaprogramming, some patterns (implementing them generically) and custom memory management. One book that's not on your list that is definitely worth reading is [API design for C++](http://www.apibook.com/blog/). The stuff it teaches goes well beyond API design and large part of the API design bits can be applied to building application-internal interfaces, so reading it makes sense even if you don't write libraries. 
Undefined behavior is not "clear specification on how stuff is supposed to work".
Hopefully, the compilers will change, too. As it is, GCC is the only one with any substantive support. (Even MSVC lags quite a bit.)
Exactly. OP seems to be thinking of "unspecified behavior", is unaware of the difference, or wishes shifts full into that category instead. 
If you always use parens to group things, then you don't run into most of the problems in this article.
A bunch of the issues in the article is Operator Precedence and is WELL DOCUMENTED in C and C++. If you don't remember the operator precidence or just want to be on the safe side, then use more parens! Done! 
As in allowing all expressions/statements whose all arguments are constrxpr's. Instead there will be lots of fugly code that hacks around using recursion and ternary operator. Edit: the body of the consexpr function has to contain a single statement - return statement.
C++ Coding Standards by Sutter (C++ Committee Chair) and Alexandrescu (D creator) is a favorite of mine.
i &lt;&lt; somevariable and some variable = 33? The compiler can't optimise that.
1. Variables need to be _moved_ between functions, references are quicker as there is less memory copying going on. 2. A local variable is space reserved automatically for you. If you don't know how many items in your array at compile time, you can ask the operating system and it will give you memory, as in, tell you where you can store data, but you need a pointer to direct your code and data into it. 3. Because variables are copied, splitting the code that modifies an object up becomes really hard. You have to do `item.element = get_element_for_item(item)`, for every single element (member), rather than being able to say `set_a_bunch_of_variables_for_me(&amp;item);`
Your pastebin's expired. I'm not sure what the problem is, but I do have a couple quick suggestions for developing in unix when on a windows box. The most obvious being, get yourself a copy of virtualbox and install your favorite flavor of linux in a vm. Baring that, you may want to pickup the mingw compiler to build things natively in windows, or alternatively visual studio express edition (assuming your university doesn't supply a version for you to use). I'm not accusing cygwin of anything, it's just a package that feels like pulling teeth most days.
The links should be working now. the first two were the same one (cuz i'm an idiot) and both had an extra character tacked on the end. the first was a period and the second was a comma &gt;_&lt; anyway they should all work, i checked while being logged out of pastebin
&gt;Also, make sure you understand how to use pointers. story of my life. I'm learning C++ and that is the most frustrating thing ever :/
gdb, ddd, and printf (cout) are your friend.
So, if it is well documented, it is not undefined behavior. 
What does this guarantee have to do with v? v won't be a moved-from object. v is simply the target of an assignment.
thanks for this. I didn't think about creating new "contexpr datastructures", I was using only initializer_list (which is constexpr in GCC but not in the standard).
Does move assignment reduce capacity? 
Please tell me you don't manually specify each header as a dependency for each of your source files?
 SRC_FILES=\ foo.c \ bar.c \ SRC=$(addprefix src/, $(SRC_FILES)) HDR=$(addprefix include/, $(SRC_FILES:.c=.h) OBJ=$(addprefix bin/, $(SRC_FILES:.c=.o) TGT=my-dumb-binary all: $(TGT) $(TGT): $(OBJ) src/main.c $(CC) whatever -o $@ $^ bin/%.o: src/%.c include/%.h $(CC) -c whatever -o $@ $&lt;
Please don't ever do that, unless your projects are very small. If a source `foo.c` or a header file includes other headers than `foo.h`, your objects will not be recompiled appropriately, and you end up with a linked binary containing various inconsistent ideas of the layout of a data structure or the signature of a function. This is potential memory corruption every time you make a change to a header file, and you won't always be able to tell immediately. The result is that you end up with a workflow where you always `make clean &amp;&amp; make`, which is quite unfeasible for anything but very small projects.
If your dependency graph isn't flat, then yes, you need to encode that in the Makefile. There are a bunch of ways to accomplish that, but stating it explicitly is the only sane solution.
Some compilers will apply the pre/post-increment differently than others. In this expression, it might make it zero and increment after the WHOLE expression. Then again, on a different compiler it might treat it as x[j++] = j; Read up on the compiler you're using as, apparently, the C/C++ standards have no say about this behavior. Good programming practice dictates that you should apply increments before or after an expression, not inside.
&gt; Stick with STL containers and references [whoa careful there](http://stackoverflow.com/questions/7707842/stl-containers-with-reference-to-objects).
Do you come from Java? You're surely not a total noob, getting to pointers on your 3rd day. 2 places to use pointers: * To pass large structs / classes around, to functions. * To pass /back out of a function/ more than the ordinary return value. * 3! 3 places to use pointers! ... in collections. Not that you can't use whole struct / class objects, but collections often copy their members around (well mostly std::vector) and, you're putting things in and out, and it's cheaper to move or copy, pointers. But you must be pretty advanced, in a C++ class it's probably a few weeks before the class gets to pointers. So, for everyday beginner stuff (no deprecation meant), use ordinary values in ordinary variables. The anti-benefit of pointers is that they're not actually the value you want, you have to make one, and then point to it. And clean up later. It's extra work if you just want ordinary programming values. 
Well, have fun with that… That kind of complexity in your build system is just asking for trouble. You *will* waste your time trying to find nasty bugs in your code, which are actually caused by broken builds. Have you ever worked on a big project in C/C++? That is, 100+ source files, multiple architectural layers, potentially cross-platform?
&gt; Have you ever worked on a big project in C/C++? That is, 100+ source files, multiple architectural layers, potentially cross-platform? Every day. Six (or is it eight now?) platforms, dozens of moving parts. In fact, I'm the build manager. The only sane way to handle dependencies is explicitly specifying them. &gt; You *will* waste your time trying to find nasty bugs in your code, The thing is, I don't. I invest a little time setting up my inter-project dependencies, and ask my developers to treat Makefiles as first-class citizens, and the end result is I'm not fighting Automake when it's leaving autom4te.caches in my repository working dirs, or incorrectly deducing a class hierarchy, or not automatically finding some system dep on my ia64 build machine which exists, or blah blah blah. The time sunk fighting with "magic" is so many orders of magnitude larger than time invested in maintaining proper, simple Makefiles that it's not a contest.
Ah, right, so it's your job to manage the dependencies. &gt; The only sane way to handle dependencies is explicitly specifying them. Of course not. Automatic deduction of source/header dependencies works *just dandy* in most build systems. Sure, Autotools is one particularly painful chain of tools, but if your biggest problem is `automate.cache`, you don't have problems… There is zero magic involved in finding source/header dependencies, and you don't need Autotools for that. System/library dependencies are an *entirely* different matter, and should of course be specified explicitly. I have only been talking about mutable project files (headers). If you want to waste your time manually updating Makefiles all over the place every time a header file is changed, by all means, go ahead. But it *is* a waste of time, when there are very dependable tools available, which do your job perfectly, and which save frustration on the part of your developers, who will be spending time debugging code, when the "bug" is caused by a broken, arcane build process.
&gt; Of course not. Automatic deduction of source/header dependencies works just dandy in most build systems. I'm honestly open to recommendations. I certainly haven't found anything which fits that description.
Very interesting tutorials, easy introductions to the new threading APIs. To suit my taste, I play these at 1.50x speed in VLC so that he speaks at a normal rate :-)
I'm learning on my own... I thought about taking a C++ class at the local community college but thought better of it. After 5 years in school, I learned that (for me, at least) college is nothing more than learning something in an hour and then killing time for the next 3 classes while the rest of the class gets up to speed. 
No.
Look, it's quite the trivial task, and all major IDEs and build systems do it without issue. Visual Studio, Xcode, Autotools, CMake, qmake, bjam, scons, and so on. Most of them work completely identically, because they simply use `gcc -MM`. If you have come upon any bug in the header dependency generation code of any build system or IDE, I am both surprised and eager to hear about the specific case in which it fails. I would imagine the developers of that tool would be as interested.
Also No. Because it's not _so very_ hard to write C++, and in many cases it's worth it - if you get benchmarked against someone else where speed or memory consumption is important, you'll want to be in C++. I read some opinion that I took as credible that Google's MapReduce (the daddy of Hadoop) was about scaling, not about speed. And I think in M.R. you can call out to speed-sensitive processes anyway. But, I know little. I will say, that it's all about energy efficiency anymore, and that favors C++. 
You can probably re-write Hadoop in C++ and get better performance ( faster and more memory efficient). I doubt performance would be sufficient reason to undertake such an effort though. Large companies like IBM, Oracle even Microsoft have decided to contribute and build on Hadoop rather than re-write. It is just more economical to use an existing framework especially one that is sufficiently complex rather than write your own. Just as it would not make economic sense to re-write Windows / Linux in Java or C#. For theses reasons it is concealable that if opportunity arises to write a new operating system C and C++ may not the only potential candidates.
Well someone has - I don't know whether it's kept up but, there exists Sector/Sphere which of course claims it's faster. Probably it's because Hadoop has more of a supporting ecosystem, that people choose it. 
&gt; You can probably re-write Hadoop in C++ and get better performance ( faster and more memory efficient). It really depends on *where* your program is bound. In my experience, most of the tasks that you throw Map-Reduce at are *heavily* IO bound, so you're actually not likely to see a significant speedup from moving to C++. 
This. The dynamic optimization of Java might payoff, but then again having raw control over memory allocation/deallocation in C/C++ among other things might give better bang for the buck. Also, it depends on what compiler you're using.
Hadoop is a real mess to work with, though. Unless you have a team dedicated to take care of it, you will spend days in a maze of tricky configuration files, undocumented critical settings and nonexistent debugging tools. If something goes wrong you'll have to dig in tens of different log files and because it's written in java, you **will** have memory issues which can occur at any time for random reasons simply because the garbage collectors were never meant to handle the magnitude of allocations/deallocations which are very common in large jobs. The day somebody writes a decent mapreduce in C++ you'll see everybody walking away in gratitude from that horror.
int main() { return main(); } internal server error
I like the clarity in which this is presented. It seems all well thought out and it is quite easy to follow, given this fairly advanced topic. Thank you.
'C++ Coding Standards' by Sutter + Alexandrescu is sort of a digest of the 'Exceptional C++' series, with some extra. It does explain and argue, but not as much as the Exceptional C++ does (of course). 
Why don't you use regular expressions? #include &lt;regex&gt; Read up on how it works (a lot like in Perl, really) and you'll be flying.
Cool! I've never heard of this library before. Looking into it now, thanks!
I'm still a little confused. I think I found a plausible solution (after some modifying) in this: string seq = "foo@helloworld.com"; // I could modify this to look at the whole XML file instead of one string regex rgx("(.*)@(.*)"); // I could modify this to something like rgx("&lt;w:(.*)&lt;/w:"); I'm not quite sure. Obviously I have some more to learn smatch result; regex_search(seq, result, rgx); for(size_t i=0; i&lt;result.size(); ++i) { cout &lt;&lt; result[i] &lt;&lt; endl; }
Use an XML parser. The XML spec is quite complex (encodings, character entities, etc.) even if the syntax looks superficially simple. Do *not* use regular expressions to parse XML. There are several mature C++ XML parsers available, including [Apache Xerces](http://xerces.apache.org/xerces-c/).
Some have a different opinion. http://www.codinghorror.com/blog/2009/11/parsing-html-the-cthulhu-way.html But really, there are plenty of XML parsers out there. Expat if you like to do things the hard way. I'm sure others have used other libraries that are nicer. 
I would look around for an XML parser. Two that come to mind are [TinyXML](http://sourceforge.net/projects/tinyxml/) and [Xerces-C++](http://xerces.apache.org/xerces-c/). Xerces-C++ is a full-blown parser that follows the XML specification. I would recommend staying away from regular expressions for parsing XML documents.
Is there any particular reason you need to do this in C++? I'd be inclined to write a basic Python script for this sort of thing, since the language provides you with some basic XML parsing tools.
I actually heard of Xerces before, I'm surprised I didn't think of using it. It's still a little confusing, though. I installed Xerces on my Macbook, and browsed to the "bin" folder in order to test a sample. I entered "SAXPrint ~/Desktop/Untitled.xml" and it said command not found. However, when I do a directory listing, I can see the SAXPrint file. I have tried it with all the other samples too, but none run.
I could do it in any language, theoretically. I just know C++ a little better. I'm not a great programmer by any means, I've only dabbled in C++ and PHP. I've heard it's fairly easy using Perl or Python, but I have no idea how I would do this.
On Unix (including MacOS X), you have to either have the command's directory listed in the `PATH` environment variable, or you have to type the full path to the executable. So either this: ./bin/SAXPrint ~/Desktop/Untitled.xml or this: env PATH=$PATH:$PWD/bin SAXPrint ~/Desktop/Untitled.xml To save time, you can add the path to `PATH` permanently (for the current terminal session): export PATH=$PATH:$PWD/bin Now you can enter just: SAXPrint ~/Desktop/Untitled.xml and the shell will find the executable. I recommend picking up a book/manual on Unix. You're going to need if you will be compiling and testing stuff.
From your description and pseudocode, I think the larger issue is that you don't have an understanding of how to solve the problem mechanically, independent of the language you're trying to use. [/r/learnprogramming](/r/learnprogramming) might be a good place to ask for help. 
Yeah, you're probably right, although you weren't very rude explaining this to me ;) I've never had to do something like this, it's a random assignment in something we've never been taught, so I'm a little over my head. EDIT: I have been researching this and trying to wrap my head around these concepts all day and have made very little progress. I was hoping it would be simple.
You do something like: std::string seq = "&lt;w:r&gt;foo@helloworld.com&lt;/w:r&gt;blahblah&lt;w:r&gt;blah@helloworld.com&lt;/w:r&gt;"; std::regex rgx("&lt;w([.*]@[.*])&lt;/w"); std::smatch result; while(std::regex_search(seq, result, rgx)) { std::cout &lt;&lt; result[1] &lt;&lt; std::endl; // result[1] is the string inside () } I havent tested it but you get the idea.
Xerces is quite ugly. Very C like. I wish someone made a boost xml lib.
Start by reasoning from first principles, without any programming at all. In other words, for each thing we want to achieve, what are the steps required to get there? We would like, at some point, to match the substring "&lt;w:" somewhere in a file. What's a file? It's a stream of characters. We get access to the stream by opening the file. And what's a substring? It's a bounded array of characters. The string "&lt;w:" is really the character "&lt;" followed by "w" followed by ":". All right. So now we have two things, a stream and an array. How do we match them together? We could start by reading one character from the stream. We then compare that character to the first character in our array. Is it "&lt;"? If so, we can read another character from the stream, and check if it's the next character we want. If not, we need to read the next character from the stream and compare it to "&lt;" again. Once you get this far, and you reason about each step, you should be able to find the appropriate mechanism in C++ that you need to use. It's not going to be very easy, because you have the whole of C++ standing in your way. Even plain C would be simpler. If it were a language like Ruby or Python it would be much easier. As it stands, modern C++ requires that you are familiar with a lot of concepts (like classes/objects) before you can do even the simplest little thing. I recommend using the "C parts" of C++ (eg., arrays for the matching) rather than the more complex object-oriented stuff (strings, iterators) because otherwise you will have to learn a lot more background stuff just to accomplish those simple operations. Oh, and forget what I said earlier about not using an XML parser; this looks like some kind of assignment, so the idea is probably to write some simple parsing logic yourself, rather than reusing a library. (In a real-world app, using an XML parser is a must.)
Thank you for that. I never really saw the problem in this light before. I have worked extensively with classes and objects in C++ before, but it was years ago, and I'm very rusty. And yes, it is an assignment. However, we're not constrained to using any particular method. One of the students mentioned Xerces, and it is a viable solution. 
Programming is all about finding the logically correct steps to perform in order to reach a solution. It's like cooking, really, only with logic. I see novices struggle a lot because they don't *think* about the problem. They flounder because they suspect they probably need a loop, but they don't know quite why, or in what order stuff should happen. As a result, a lot of novices just try to throw stuff into the program, hoping it will work. Some languages are more forgiving than others, but C++ is unfortunately a particularly bad language for that kind of trial-by-error learning. Some people have a natural talent for subconsciously decomposing problems into a series of operations with little to no effort (I am lucky enough to be blessed with such a talent), whereas other people have to mentally reason their way towards solutions, which is much harder and time-consuming. Eventually you might find that your subconscious starts to help, but it might take a while. But yeah. Do it with baby steps. One piece of logic at a time. Try to think about where you are ("A") and where you need to go ("B"), and then figure out what is required to get there. Try to make the steps as small as you can. For simple problems such as these, try avoiding using libraries, at least if you want to to learn something. Actually, the kind of substring matching that you need to use here is pretty much a computer science chapter in itself. You can do it naively, or cleverly, using recursion and/or state machines and/or loops -- and it's a great way of illustrating how different algorithms can lead you down different paths towards the same goal. Good luck!
Could be that it doesn't have an executable permission. Try chmod +x and then ./SAXPrint ~/Desktop/Untitled.xml
TinyXML is more than adequate and with the addition of [TinyXML++](http://code.google.com/p/ticpp/) it becomes a lot more convenient.
I found this little gem when browsing the site: http://www.viva64.com/en/a/0050/ // spot the bug for (int i = 0; i &lt; n; i++) a[i] = 0;
[Here's](http://www.johndcook.com/cpp_regex.html) a pretty good C++ regex tut to get you started.
That's all in good humour, but I have written HTML parsers with regex quite effectively. By all means, use a pre-built parser to do the task, but usually the type of person who codes in C++ is not satisfied with a black box. They want to know what's running on the metal, to be as optimal as possible. Actually, you might find he'll roll his own parser and then benchmark it with several black boxes - that's just how we roll :)
What am I missing here?
Ok maybe you can call it more of a potential bug, but the problem is the value of i is converted to a value of ptrdiff_t type in a[i]. Think 32-bit vs 64-bit. To put it another way: // No one would write this without good reason for (short i = 0; i &lt; n; i++) a[i] = 0; 
TIL ... also would have helped me to actually read the article you linked :-)
And why is this a problem? I can only think of some imaginary architecture where sizeof(int) &gt; sizeof(ptrdiff_t) where this is problematic. But frankly im not sure such ordering is even legal. 
64-bit code under linux: I believe int is still 32-bit and ptrdiff_t is, of course, 64 bits. Now, in practice, you are rarely working at a scale where you would potentially overflow a signed 32-bit integer (2GB of chars, 8GB of 32-bit values) all at once. 
Edit: someone else beat me to it, but I wrote some code, might as well leave it here: #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;climits&gt; #include &lt;cstddef&gt; #include &lt;iomanip&gt; int main() { std::cout &lt;&lt; "Size of int: " &lt;&lt; sizeof (int) &lt;&lt; '\n'; std::cout &lt;&lt; "Size of ptrdiff_t: " &lt;&lt; sizeof (std::ptrdiff_t) &lt;&lt; '\n'; static std::ptrdiff_t const N = UINT_MAX+1ll; char *a = new char[N](); for(int i=0; i &lt; N; ++i) { a[i]=1; } std::cout &lt;&lt; "# of ones:" &lt;&lt; std::hex &lt;&lt; std::accumulate(a,a+N,0ll) &lt;&lt; '\n'; } /* $ g++ --version overrun.cpp &amp;&amp; ./a.out g++ (GCC) 4.6.1 20110908 (Red Hat 4.6.1-9) Size of int: 4 Size of ptrdiff_t: 8 Segmentation fault (core dumped) */ 
Oh, so you didn't actually mean 'a[i]' was bugged but the comparison. Makes sense now.
Are you doing something like: std::get&lt;1&gt;(t); What exactly do you mean by "it doesn't work"? Sample code?
Alright, so it's a tuple representing a date and time, and here's a method for the DateTime class; EDIT: for more info, he's the tuple class itself: //type definitions typedef double jdn_t; typedef long long year_t; typedef unsigned month_t; typedef unsigned day_t; typedef unsigned hour_t; typedef unsigned minute_t; typedef double second_t; //tuple typedef std::tuple&lt;year_t, month_t, day_t, hour_t, minute_t, second_t&gt; gregorian_t; inline year_t year( gregorian_t const&amp; gregorian ) { return std::get&lt;0&gt;( gregorian ); } inline month_t month( gregorian_t const&amp; gregorian ) { return std::get&lt;1&gt;( gregorian ); } inline day_t day( gregorian_t const&amp; gregorian ) { return std::get&lt;2&gt;( gregorian ); } inline hour_t hour( gregorian_t const&amp; gregorian ) { return std::get&lt;3&gt;( gregorian ); } inline minute_t minute( gregorian_t const&amp; gregorian ) { return std::get&lt;4&gt;( gregorian ); } inline second_t second( gregorian_t const&amp; gregorian ) { return std::get&lt;5&gt;( gregorian ); } and the getter method: year_t getYear( gregorian_t g ) { year_t y = std::get&lt;0&gt;(g); return y; }//end getYear()
What kind of error message are you getting?
Your main difficulty is in asking answerable questions. Hint: If you haven't posted a 10-20 line program that I can copy-paste, compile and see the problem, I'm not going to help.
compiles fine for me
resolved, sorry.
I was getting message that said no such type existed...it's resolved now.
Once simple but nitpicky thing is it's best to use [++i (preincrement) rather than i++ (postincrement)](http://discuss.fogcreek.com/joelonsoftware/default.asp?cmd=show&amp;ixPost=171881) when possible as the 2nd can create a copy of the object to use in the expression. In this case it will be optimized out by just about every compiler but for other types such as classes it might not be.
[Is it reasonable to use the prefix increment operator ++it instead of postfix operator it++ for iterators?](http://www.viva64.com/en/b/0093/)
Useful for debugging, handy to know. But I think the real thing to take away from that is avoid the hell out of iterators, I'm surprised their performance is so bad =/ 
For what it's worth I tried your measurement with deque and list too, vector's iterator being what it is. Results: MSVC 10, Windows 32-bit. std::list: prefix and postfix ++ were identical std::deque(now there's an iterator): prefix ++ : 80 seconds postfix++ : 128 seconds. Like you I must note I always write prefix ++. After all, what is ++i deep down in the nature of its essence? It is inc i, exactly what we want in a loop. 
There's a problem with VS2008's compiler: it does range checking of vector's iterators by default, even in release mode. No one will ever know why. The numbers are likely due to that. In VS2010 the numbers are, as expected in any sane compiler, all the same: no difference between indexed lookup, prefix or postfix++. Remember, vector's iterator was specifically designed to be a pointer typedef. When you see ++vectoriterator it's the same as ++somepointer. 
There is the list in sequence * Effective C++ * More Effective C++ * Effective STL * Exceptional C++ * C++ Template: The Complete Guide * Modern C++ Design: Generic Programming and Design Patterns Applied * C++ Template Metaprogramming * Advanced C++ Metaprogramming Don't do anything template until you have good foundation of "C with classes" and stl.
Im not quite sure whats going on with the hype around C++ lately, but really: a) C++ isn't going anywhere (as in, wont disappear suddenly) b) It probably wont become all that much more popular
In my book C++ is a language to build blocks for higher level languages to use. I did that with Matlab and now mostly Python. The competitor isn't Java or C#, these are users of blocks built with C++ just like Python is. Its competitor is at this is C. C is much loved for its simplicity and the beauty that derives from that. You can feel the Unix philosophy behind it. C just does what it needs to do, not more. All its pieces just fit beautifully together. C++ on the other hand can do what C does and a whole lot more. It is what you get when you tear down the walls of C's simplistic approach and put in features derived from higher level languages. It is a complex beast. This complexity is that the C++ haters are going on about. They have a point, to be frank. However, I can't bring myself to use C if I know I'm gonna need something that C++ just has built-in, like std::vector, std::map etc. . RAII is another thing I really feel in love with. I can't remember the last time when valgrind told me that I created a memory leak in C++. Despite of C++11 (r-value references are AWESOME [1]) , I think there is room for new languages that are C-ish, not "managed" (aka GCed) but have RAII and avoid the complexity and ugly pieces of C++ (templates and its error message come to mind). But right now and for at least the next 10 years, lots of new C++ code will be written, I bet. [1] [DrBartosz series on concurrency in C++11](http://www.reddit.com/user/DrBartosz)
I think he's right.
`auto i = begin(m);` Why is it `begin(m)` instead of `m.begin()` and why is the first one better?
because begin(m) can be added without having to modify whatever type m is (an array for example).
Why always use smart pointers? Are they thread safe now?
Huh?
It seems a magic using template specialization like `std::iterator_traits`.
I don't program a lot in C++ and it's been a while, but since it's quiet here, I'll throw a couple thoughts out. Basically, I think you're going to want to peek at the input stream (peek = look, but don't take); if it's a '$' character, you stop (which leaves it in the stream); if it's not, you pop it from the stream (incrementing your character counter). I don't think that sounds too hard despite my not using C++ a lot lately, but if that's not enough, shoot me a message.
It's almost that simple. '$' does *not* have a special function in C/C++, it's just a character. The trick here is to .peek() at the input stream without reading in the character. You'll also want to leave the character in the stream, so reading in full string is incorrect. This should get you on your way without giving you the answer: while(cin.peek() != '$') cin.ignore(); 
&gt; http://www.kernel.org/doc/man-pages/online/pages/man2/open.2.html FTFY (colon at end of URL)
.peek() yes... i just stumbled into that. I'm reading that chapter as we speak. It makes sense now
I like your description. I don't like asking for help to too experienced people because they get too technical at times and I have no idea what they're saying. You speak human! Thank you. I shall finish this assignment in a few minutes then 
You can add a specialization of begin() yourself, whereas the other way requires every container to implement begin().
zoom23 said it, example: class JoesCrazyClaas { // you think you get an iterator, bitch? Use the index Operator or I keel you! }; struct MyIteratorForJoesClass { JoesCrazyClaas &amp; jcc; int index; // can be negative, Joe is that crazy // CTor, operator++, operator*, ... }; MyIteratorForJoesClass begin(JoesCrazyClaas &amp; c) { return MyIteratorForJoesClass(c, c.GetFirstValidIndex()); } Bada-booo!
See this article: [How Non-Member Functions Improve Encapsulation](http://drdobbs.com/cpp/184401197)
C++ won't go anywhere soon. As to becoming even more popular remember who you are referencing here. If you are in the C++ business of course you are going to predict a rise in popularity. The question then becomes is anything happening that would In fact cause an expansion in the use of C++. I believe some of the referenced posts are valid, one just needs to look at iPhone, built mostly on Objective C by the way, compared to phones running Android. 
Free functions strike back...
Ah he talks of the global `begin` later, I missed that.
&gt; templates and its error message come to mind Honestly, the fault lies on the compilers, not the language itself. If I type "std::string", the compiler should remember that, and talk about std::string in its messages, not std::basic_string&lt;...&gt;. It would be possible (most of the time), but maybe not easy, and apparently not very high on g++'s todo list.
The long names are a minor problem. The real problem is that the error message you get are from deep down in the template library you are using. Skip to minute 52 in - [Bjarne Stroustrup on C++0x in 2007](http://video.google.com/videoplay?docid=-3478907067117491758) and listen up to minute 54 to see what I mean.
 auto i = find_if( begin(v), end(v), [=](int i) { return i &gt; x &amp;&amp; i &lt; y; } ); Can someone spell that for me please? Why [=] especially? And what will be the type of i? 
The `[=]` is to specify how to capture variables. You can either give a list, or give `=` to capture all variables in scope. You can also prepend variables in the list with `&amp;` to capture them by reference (the default is by value). So the lambda could equivalently have been defined: [x, y](int i) { return i &gt; x &amp;&amp; i &lt; y; } The type of `i` will be the return type of `find_if`, which is an iterator of the same type as `begin(v)`.
Thanks. C++ is getting rather large as a language. Seems like quite many new concepts being introduced in c++-11. 
It's true, there is a lot of new stuff. Ont he plus side, a good deal of the focus was on unifying the existing concepts, and providing more general wrappers. It's gotten to the point where C++ is almost two languages: Lower level "C With Classes", and higher level code based on the STL and such.
You can use an `ifstream` to read from a file just like you would use a `std::cin` to read from the keyboard. So if you would read from the user with int x; std::cin &gt;&gt; x; Then you could read from a file using std::ifstream in("filename.txt"); int x; in &gt;&gt; x; When you use an `ifstream`, it will skip over whitespace like spaces, tabs, and newlines, so you can just keep reading data one after another. You'll have to read each line of your file, and for each line decide (based on what you read) which averages need to be computed.
Ok, I think I may be understanding this. Are the 3rd and 4th columns the numbers you need to average? You should just be able to get those from the file... thusly: infile &gt;&gt; name &gt;&gt; cat &gt;&gt; x &gt;&gt; y; infile is your ifstream object, name is a string, cat is a char, x and y are doubles. Put that in a loop that loops until you're done reading from the file, add in your other logic to calculate the average and stuff, and you should be good to go.
i've already got it as infile &gt;&gt; name &gt;&gt; ad &gt;&gt; age &gt;&gt; score in a while loop, and then i echo it. and then put in cout &lt;&lt; name &lt;&lt; ad &lt;&lt; age &lt;&lt; score i need to find averages of people under and over 18, respectively. so i guess my "other logic to calculate the average and stuff" is what i'm having trouble with. 
I use that style for constants, but in general you'll find programmers will use different styles with different kinds of things so that they can visually see what's going on at a glance. For instance, if I see the following in my own code: int center = (SCREEN_WIDTH - width) / 2 + 1; I know that SCREEN_WIDTH is a constant defined using #define that will appear near the top of the source file.
No. CAPS_WITH_UNDERSCORES is typically reserved for macros. It became popular as a style for Windows code because Microsoft started using it back in about 1985 when people didn't know better. Because it's better to be consistent than it is to be right, Microsoft is still using that style to this day, decades later. They still use hungarian notation for the same reason, but it isn't a reason to use it in new, modern C++ code.
I've seen various naming conventions for structs, such as this: typedef struct foo_hdr_s { uint32 foo_bar; uint16 foo; } foo_hdr_t; In most cases, your company will have a style guide, so naming conventions will be decided for you. If you're working on some open source project, I would just try to match whatever existing naming conventions you observe. 
I have heard that it was for clarity. *FILE * files;* instead of *file * files;* or *File * Files;* Also when Microsoft used it, structs were typedef'd. So the capitals showed that it was being replaced like a macro. Perhaps it is a C idiom?
Hrm. If I were to rewrite FILE, I'd base it on my perception of common modern use: *File file;* But FILE is probably pretty old at this point--what it's based on seems to be from the early 70s.
This is not a forum to ask for help; it is a forum to share useful resources. If you'd like assistance in a programming problem, I'd suggest stackoverflow.com.
Well, my preference is pascal caps. So I would never write unix-style etc *uint32.* But I just don't like UInt32 or DWord, because it looks weird. So I just use UINT32 or DWORD for basic types like microsoft (btw they use #define not typedef!). But I never saw any reason to do it for structs (struct ButtonLayout { etc).
or /r/learnprogramming
C++ is currently relevant, and won't be anything but more relevant in the coming decades. C++11 has addressed many of the usability issues (from a programming perspective) and the most glaring performance issue of C++ unnecessary copying (via move semantics). C++, like C, remains a language to be used sparingly, by experts, and by those that know what they're doing. Writing in C++ (or C) does not inherently make your code "better" or "faster". Writing in either C or C++ can definitely do one thing: make your code inherently less safe. These languages trust that you know what you (the programmer) are doing. There's very little protection. Far less than languages such as Java, C#, Perl, Python or Ruby. As it often comes to: use the best tool for the job. Write a solution in a language that is most comfortable to you. If, and only if, you have performance issues, start optimizing routines. This may entail rewriting portions (or all) of an application in a lower-level language such as C or C++. Yes, C++ is relevant, and a skilled C++ developer can easily make +100K USD.
I only use that style for defines. 
Ok. Well, to calculate an average of a set of values, what do you need to keep track of? What do you need to know about those values?
It's from K&amp;R ...
Because they are evil
&gt; and a skilled C++ developer can easily make +100K USD. Outside of new york and cali, it isn't easy to crack 100K. Doable, but not easy.
This habit from legacy C has leaked over to `static const`s in C++ for many people. Only for integral constants, though, it seems. class Foo { static const uint32_t SCREEN_WIDTH = 1024; }; The purpose is the same.
so how about uint32_t as standard C has had them for the last 12 years, and C++ got them officially this year? Perhaps you'll be able to write more portable code...
Yep, I do that to, but for all consts, int or not.
Because I cannot stand *code_like_this( my_var );* And I dislike writing _t every time I want to use it.
I dislike naming variables like macros.
That's just creepy.
To answer your question: no, I would not use it. I prefer reading things via method calls and not overloaded operators. Such as: int i; i = binaryReader.ReadInt();
You should not be using macros in C++.
That is not true at all. They have their purpose like all things. INLINE uint32_t STDCALL Method( uint32_t * RESTRICT, uint32_t * RESTRICT ); __forceinline uint32_t __stdcall Method( uint32_t * __restrict, uint32_t * __restrict ); The first is far better to me, more readable, more portable.
Wow, definitely not. First, those aren't macros, those are just redefined symbols. Second, #2 is definitely better than #1, by any sane metric. Are you writing code for DSPs or something?
&gt;because Microsoft started using it back in about 1985 when people didn't know better. Yeah, half of windows programming can be summed up by this phrase. That and the saying "Those who fail to understand VMS are doomed to reimplement it.", a favorite of this guy I knew.
I agree. I once did a lot of operator overloading for a vector class in school. % was crossproduct etc. This really only made sense to me, since I rarely use the mod operator, but I would never use &lt; and &gt; for anything other than comparing.
Lol, that was my old post. Here is my current C++ rss list: *A Sense of Design http://codesynthesis.com/~boris/blog/feed/ *ACCU :: News Articles http://accu.org/index.php/articles?theme=rss *Alf on programming (mostly C++) http://alfps.wordpress.com/feed/ *Articles published in The C++ Source http://www.artima.com/cppsource/feeds/cppsource.rss *ASKLDJD http://askldjd.wordpress.com/feed/ *Boost News http://page2rss.com/rss/f4198a3c754477d7e1cfa44c378caf30 *Boost News http://www.boost.org/feed/news.rss *C++ http://www.reddit.com/r/cpp/.rss *C++ and more! http://msmvps.com/blogs/gdicanio/rss.aspx *C++ on a Friday http://blog.knatten.org/feed/ *C++ Soup! http://cplusplus-soup.com/feed/ *C++ Truths http://feeds.feedburner.com/CppTruths *C++0x FAQ http://page2rss.com/rss/54301b798f4a5b388770468a84336924 *C++Next http://cpp-next.com/feed/ *Channel 9 - Entries tagged with C++ http://channel9.msdn.com/Tags/c++/RSS *Corensic http://corensic.wordpress.com/feed/ *cplusplus.co.il http://cplusplus.co.il/feed/ *Dave Abrahams: Home Page http://daveabrahams.com/feed/ *Developer - Programming | C++ http://www.internet.com/xml/developer-programming-cpp.rss *DevX: Latest C++ Content http://services.devx.com/outgoing/cplusfeed.xml *Dr. Dobb's C/C++ Articles http://drdobbs.com/articles/cpp/rss *Dr.Dobb's Journal | Andrew Koenig Blog http://www.drdobbs.com/blog/main/movabletype/rss_andrewkoenig.xml *Dr.Dobb's Journal | Christopher Diggins Blog http://www.drdobbs.com/blog/main/movabletype/rss_chrisdiggins.xml *Dr.Dobb's Journal | Walter Bright Blog http://www.drdobbs.com/blog/main/movabletype/rss_walterbright.xml *EmptyCrate http://blog.emptycrate.com/node/feed *Geektalk http://olvemaudal.wordpress.com/feed/ *Generalities &amp; Details: Adventures in the High-tech Underbelly http://www.bluebytesoftware.com/blog/SyndicationService.asmx/GetRss *Gennaro Prota's Blog http://gennaroprota.wordpress.com/feed/ *Highscore - Programming http://en.highscore.de/feed.atom *C++0xFAQ.html http://page2rss.com/rss/ff31abc18d34b5bd4079daca8936b03c *Index of /jtc1/sc22/wg21/docs http://page2rss.com/rss/96a9189679ae460cf5dde4cafddbafe6 *InformIT :: C++ Reference Guide http://www.informit.com/guides/guide_rss.aspx?g=cplusplus *InformIT :: Danny Kalev http://www.informit.com/authors/authorblog_rss.aspx?a=e19aded6-574c-4c46-8511-101f9f0ed8f8 *ISO/IEC JTC1/SC22/WG21 - Papers 2011 http://page2rss.com/rss/821585e8b05eda103fcc1f5f8df4ace6 *ISO/IEC JTC1/SC22/WG21 - The C++ Standards Committee http://page2rss.com/rss/3a8a90409644d0cf8cf50930321a4f07 *Just Software Solutions Blog http://www.justsoftwaresolutions.co.uk/index.rss *Kate Gregory's Blog http://www.gregcons.com/KateBlog/SyndicationService.asmx/GetRss *Kenny Kerr http://kennykerr.ca/feed/ *Latest News from Danny Kalev http://dannykalev.sys-con.com/index.rss *litb's Blog http://bloglitb.blogspot.com/feeds/posts/default *Marc Gregoire's Blog http://www.nuonsoft.com/blog/feed/ *Nightly build http://slack.codemaniacs.com/blog/feed/ *Notorious .cpp http://mmocny.wordpress.com/feed/ *Ofek's Visual C++ stuff http://thetweaker.wordpress.com/feed/ *On Software and Languages http://ib-krajewski.blogspot.com/feeds/posts/default *Parallel Programming in Native Code http://blogs.msdn.com/b/nativeconcurrency/rss.aspx *Pizer's Weblog http://pizer.wordpress.com/feed/ *Simon Ask http://www.simonask.dk/rss.xml *slackito.com http://slackito.com/feed/ *Stroustrup: Interviews http://page2rss.com/rss/d9a1834e2449c3a591422809c77d164a *Stroustrup: Publications http://page2rss.com/rss/f3a5661e71b236859b9ec911da5a1085 *Sutter's Mill http://herbsutter.wordpress.com/feed/ *The C++ Programming Language http://c-plusplus.org/index.php?format=feed&amp;type=rss *The Moth http://feeds.feedburner.com/DanielMoth *The View from Aristeia http://scottmeyers.blogspot.com/feeds/posts/default *Thomas Becker's Articles on C++ http://page2rss.com/rss/3e7e56e39ece491ad5d7b491407c156c *Timo Heinäpurola http://geekswithblogs.net/raccoon_tim/Rss.aspx *Twitter / cppandbeyond http://twitter.com/statuses/user_timeline/131666570.rss *Twitter / herbsutter http://twitter.com/statuses/user_timeline/48935569.rss *Twitter / jeremysiek http://twitter.com/statuses/user_timeline/58605190.rss *Twitter / stroustrup http://twitter.com/statuses/user_timeline/77366044.rss *Visual C++ Team Blog http://blogs.msdn.com/b/vcblog/rss.aspx *Word Aligned http://feeds.wordaligned.org/wordaligned *Bartosz Milewski's Programming Cafe http://bartoszmilewski.wordpress.com/feed/
Is it "save" to list "C++ Reddit" on C++ Reddit? A web spider trying to crawl the internet might end up in a recursion!
Hmm. #2 is definitely not acceptable. First, #1 is portable, and #2 is not. __forceinline is Microsoft only. These are not language keywords, but compiler keywords. Second, __ is an ugly prefix, and I do not want it littered through my code. And it's from a portable game engine. 
I don't see how someone can say they didn't know better, because it adds clarity without forcing me to type _t over and over. 
Binary operations are not well defined in the standard, just a quick example what is the size of the int type? What order does the bytes should go? C++ does not define those thing, and in fact the standard tries to be agnostic of such detais.
how funny that herb sutter has a borat favicon.
By definition, if you're using Microsoft compiler directives and custom types, your code is not portable. There is no sense in adding an additional preprocessor layer of abstraction to attain the illusion of portability. Use standard C++ keywords like inline, types like uint32_t, and your problems go away.
Sigh. The keyword inline is useless, _stdcall is not portable, __restrict is not portable, and my integer types use #ifdef. // MSVC. #ifdef _MSC_VER #define INLINE __forceinline #define STDCALL __stdcall #define RESTRICT __restrict // GCC. #elif __GNUC__ #define INLINE __attribute__(( always_inline )) #define STDCALL __attribute__(( stdcall )) #define RESTRICT __restrict // ICC. #elif INTEL_COMPILER #define INLINE __forceinline #define STDCALL __stdcall #define RESTRICT restrict #endif 
I think you are trying to asses if the behavior is specified or not. http://blog.knatten.org/2011/10/28/the-difference-between-unspecified-and-undefined-behaviour/
Not so fast... if you compile this with g++ with -O2, the call to func is completely optimized away, and the result prints -1: $ g++ -O2 -Wall operator_tc.cc -S -o - -fno-exceptions -fno-asynchronous-unwind-tables | c++filt -p | sed -n '/main:/,/ret/p' main: subq $8, %rsp movl $.LC0, %esi movl std::cout, %edi call std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt; movl $-1, %esi movq %rax, %rdi call std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; movl $.LC1, %esi movq %rax, %rdi call std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt; xorl %eax, %eax addq $8, %rsp ret As written, `std::cout &lt;&lt; func(val) &lt;&lt; val &lt;&lt; "\n"` is a single expression, it is not a series of three function calls, therefore there are no sequence points except at the very end. The C++ standard in section 1.9.12 says: &gt; If a language construct is defined to produce an implicit call of a function, a use of the language construct is considered to be an expression for the purposes of this definition. To me, that implies that `a &lt;&lt; b` is not a function call, it's an expression. The fact that `operator&lt;&lt;()` might be overloaded doesn't change that fact. 
Technically, a const is not a variable — it's a constant. ;) Many of the same compile-time constraints apply to constants and macros, so it's not entirely ridiculous.
For non-POD consts, I tend to lean towards on-demand initialization, to avoid problems with static constructors. I.e., const Foo&amp; global_foo() { static const Foo* p = NULL; if (!p) p = new Foo; return *p; } Like singletons, except not single. :)
Agreed. I hate the operator-based stream I/O in C++. I literally smack any programmer I catch using it. Hard, on the side of the head.
Consider the bright side: the programmer of said crawler will learn not to be an idiot :D
Not talking about a standard, I'm talking about a code convention. Most people have to assume those things you mentioned when they write binary serializers, which they already do in great abundance. However, at least with regard to size and and byte order, I agree that this convention would have to define one in order to be consistent. In my version of this convention I use all the integer types from &lt;cstdint&gt; and use little-endian format.
Sure, but you already use &gt;&gt; and &lt;&lt; for i/o. How is &gt; and &lt; for binary i/o different?
I think thats debatable whether or not using the shift operator for i/o was a mistake in the first place, but now that decision is irreversible anyway and is now a convention. If our aim is consistency in our APIs, then having an operator i/o for ascii i/o and method calls or serializer factories for binary i/o is wildly inconsistent. My argument is that "If you are going to use &gt;&gt; and &lt;&lt; for your i/o anywhere in your program, which many people do because it is a convention, you might as well use &lt; and &gt; for your binary i/o. It is better to have two very similar api conventions then to have to wildly different ones"
This is fixed in recent gcc/gdb versions.
Yes. :-)
My gut feeling agree's with you. But how about that : std::ostream&amp; foo(int&amp; val) { val = 32; return std::cout; } int main() { int i = -1; foo(i) &lt;&lt; " the number is " &lt;&lt; i &lt;&lt; "\n"; } My guess is that this behavior is specified, for the function must be finished before the expression must be evaluated.
That's easily the most ridiculous thing I've read on the internet all month.
To counterbalance all these negative comments, I'd probably use it. I happen to like most of C++'s features, including overloaded operators --so long as they make sense (ie, I wouldn't overload '%' for crossproduct ;) . Therefore, since '&gt;&gt;' and '&lt;&lt;' are already standard for formatted stream insertion and extraction, I wouldn't oppose seeing '&gt;' or '&lt;'.
In C++ this idiom was inherited from C. The FILE example in particular is from stdio.h, which also defines fpos_t, and brings in va_list and size_t as well. The naming convention for FILE is different because it's meant to be an opaque type never directly allocated (heap or stack) by the user and with no direct access to members. Edit: The more common C idiom for typedefs is lowercase, and often suffixed with _t.
It is common to refer to everything defined using #define as a macro.
It still prints " the number is -1". g++ is smart enough to see that foo returns std::cout, and optimizes away the function call, resulting in the same generated code as above. In fact, it still prints -1 even if you reduce it down to just `foo(i).operator&lt;&lt;(i);` which is odd. I'm not prepared to language-lawyer this case but I would imagine that it has something to do with the fact that it's an operator and not a general method, and if you constructed a general chaining invocation like `foo(i).bar(i);` (where foo modifies 'i') that it would do as expected. 
The compiler is allowed to evaluate the sides of an operator in either order before processing the result of the operation. So it is within its rights to cache the original value of `i` before calling `foo` on it. The idea it that these evaluations happen "at the same time" and so either order is valid. What would you say if this occurred: const char * bar(int&amp; val) { // do something : val = -58; return "When messing with odd behavior, "; } int main() { int i = -1; foo(i) &lt;&lt; bar(i) &lt;&lt; func(i) &lt;&lt; i &lt;&lt; endl; } if function sets i to a different value, which value will be the one that "sticks"?
Have a look at [boost serialization library](http://www.boost.org/doc/libs/1_47_0/libs/serialization/doc/index.html).
Say that I know C++ in as far as classes, basic templates, and operators and doing a little bit of new 11 stuff: Where would I go for good little articles? I would self describe myself as around intermediate skill level with tons to learn.
Would you mind exporting this list to OPML for easier importing into our feeds? (instructions might be available [here](http://www.google.com/support/reader/bin/answer.py?hl=en&amp;answer=70572) if you use a common client)
&gt; I agree that this convention would have to define one in order to be consistent Oh, that's no problem; just insert manipulators! bin_file &lt; bin_io::int64 &lt; bin_io::big_endian &lt; 0xBEEF; Just kidding, this whole thing is a terrible idea.
I find Perl's pack/unpack to be the nicest bit-twiddling API to work with and would model something after that. http://perldoc.perl.org/perlpacktut.html
Here you go. http://www7.zippyshare.com/v/64279395/file.html Edit: Link updated
Something tells me you've read worse, but don't realize it.
Not quite thread safe, though. Gotta be careful of that.
Very true, but then again, what global variables really are. ;) I find it's a helpful approach to multithreaded programming to try to isolate tasks, so that they depend on nothing by their input. That usually includes avoiding any kind of global state dependency. Not always possible in practice, but I think it's a good rule of thumb.
Nice writeup, as usual by Herb, but I do take issue with 1 thing. I don't like his expression of pimpl because the member pimpl unique_ptr could be reseated accidentally to point to another impl. I prefer writing my Pimpl like this, using references: class widget { ... private: class impl; impl &amp;m_impl; }; widget::widget() : m_impl(*new impl) {} widget::~widget() { delete &amp;m_impl; }
**edit:** new link works. Thanks! nope: &lt;br /&gt; &lt;b&gt;Warning&lt;/b&gt;: fclose(): supplied argument is not a valid stream resource in &lt;b&gt;/srv/www/lighttpd/woofiles/includes/HTTPDownload.class.php&lt;/b&gt; on line &lt;b&gt;191&lt;/b&gt;&lt;br /&gt; Would you mind copy/pasting into a comment here or pastebin.com? Funky webservice is funky
Too long for reddit 1000 char limit. Uploaded to different share site. They are all a bit dodgy.
Shifting and streaming are not really that different. Shifting is done bit by bit, streaming is done byte by byte or object by object, but you're still only moving data forwards and backwards and in or out of objects,
Thread safe in C++11 though. Edit: well doh, would be if he _initialized_ 'p' to its proper value :/
Why not make it a static method of Foo?
Is the test for 'p' and the assignment of new Foo atomic in C++11, or something? I'm very interested in the explanation.
Initialization of 'p' is thread safe, hence my edit above. Edit: IOW this is thread safe in C++11 (though still leaks): const Foo&amp; global_foo() { static const Foo* p = new Foo; return *p; }
I'm in Chicago, and these sorts of jobs are plentiful. Personally, I had several open reqs this summer for just such a job, but could not find any qualified candidates to fill them (one interviewee I threw out after he didn't even know what a binary search tree was and couldn't answer any questions on it, even after I explained what it was). I also turned down a +100K job this summer in Seattle after my employer countered with 20% more than the offer. The jobs are out there - you just need to have a skill set employers want. It also helps to have good, well-placed contacts. Never sell short the power of networking. Neither the offer I turned down nor my current job have I gotten via headhunters. Both were through personal contacts.
Try Multimap::Multimap&amp; operator=(const Multimap&amp; m); void Multimap::addAssociation(int key, int value); void Multimap::setName(int key, const std::string&amp; name); The return types need to still come first - the full name of the functions are, e.g. `Multimap::setName`.
You've put the Multimap:: in the wrong spot. Multimap::Multimap basically means "use the Multimap that is defined inside the Multimap". The type isn't what's defined inside Multimap, it's the function. void MyClass::MyClassMethod() {} You may have seen Multimap::Multimap() {} There is no return type specified because this is a constructor -- one of a couple exceptional cases.
Why cant you use &lt;&lt; and &gt;&gt; on a new type? BinaryStream str; str &lt;&lt; 7; And define operator&lt;&lt;(BinaryStream&amp;, int) to do the binary transformation. You dont need a different operator; just use a different "stream" type (that doesnt even need to derive from any iostream object).
Why not indeed! That's what I usually do, actually. My code sample would just become lacking in brevity. :-)
I use that style for all global or file scope constants of any type in c/c++, #defines, and public enums in a class. It tells you right away that these are named values. If I go lower/mixed case, I'll prepend with g_ to give myself the immediate visual cue. 
How did you get it into vlc?
There is one good reason for which it has not been done before : &lt;&lt; and &gt;&gt; return the original type of the left operand, whereas &lt; and &gt; return booleans. Obviously, using a BinaryStream object with operator &lt;&lt; and &gt;&gt; would be much wiser.
not only that, but the library binary is like 30 megabytes, and the api requires not only template metaprogramming friend interface hacking, but less intuitive operator overloading AND virtual methods. It is QUITE bloated for a 'serialization convention'
And what happens when I want to send data over a network port hat uses the standard ostream interface? What happens when I want to use boost::bz2 compression in a stream? What happens when my company buys a library that uses std::stream interfaces on a custom encryption standard? The std::stream interface is the C++ standard for i/o, and it is widely used. This convention allows us to continue to use std::stream. I guess one possibility is a templated "binary_stream&lt;T&gt;" that taccepts a stream type at construction time, so one could write binary_stream(cout) &lt;&lt; thing would be acceptable as well, but to me that isn't that much different
I wish these weren't videos.
I am the author of [C++ on a Friday](http://blog.knatten.org/) which was mentioned above. You describe yourself roughly like the persona I have in mind when I write my posts. I also try to keep my articles short. Whether my articles are any good, I'll let others decide, but at least I match two out of your three criteria! :)
A few off the top of my head: * Why do you need a virtual destructor? * Describe the difference between public and private inheritance. * How would you construct a class that ensures it can only be allocated on the stack. * What STL classes would you use in a program that reads words from a file, one per line, and keeps a count of how many time each word appears. * When would you use static_cast? * Describe the RAII idiom. 
Now the main question becomes whether OP actually knows the answers :-P
Ask them to describe how virtual methods are usually implemented. What's a vtable? Who is responsible for setting the pointer to it? How is it allocated? Also questions about static global variables and how their constructors are invoked, and when.
* Describe briefly the last project you worked on that you were proud of; the problem, your solution, and why you chose it. It's intentionally non C++-centric. I'd take a smart but C++-inexperienced programmer over a knowledgeable but otherwise danger-to-the-codebase one any day. Const-correctness can be taught to a smart person, how to not make bone-headed design decisions cannot.
;-) * In cases where you dynamically allocate a class, but need to delete it via a pointer to one of its base classes. * public inheritance implies a "is-a" relationship. private inheritance implies a "has-a" relationship, though that relationship is usually much better expressed via composition. * std::string, std::map&lt;std::string, size_t&gt;, std::ifstream * to cast between different integer types or to cast between integer types and enumerations. * RAII is a name associated with the design practice of acquiring resources in a constructor and cleaning them up in the destructor. An example would be a 'lock' class with locks a mutex upon construction and unlocks the mutex at destruction. The benefit of RAII is that resources are automatically cleaned up in the presence of exceptions or early return statements. 
You missed one :-) &gt; How would you construct a class that ensures it can only be allocated on the stack. 
Doh! :) Declare operator new and operator new[] in the private section of the class. That would probably suffice, but I'd prefer to also declare operator delete and operator delete[] in the private section as well. 
I just right-clicked the video and used "copy URL" I think.
"Will you provide me a list of references?" I actually find testing of language skills to be pointless. There's no other professional job in existence that does skill testing questions. An interview is too short a time to get a sense of someone's skills. For one, context is too important. What's the focus of the job? What kind of things will you be doing with C++? The second thing that bothers me is that the interview environment is so alien to the real world. I don't program with a pencil and paper. I rely on the tools that I use in my ever day to day. I won't even write a B-Tree without looking it up first. So pointless. It's like asking a architect: "Here's a pencil. Now draw me a house..."
Another open-ended question: * How does C++ differ from your favorite non-C++ language (top 3 points)? Why do you think this is (ie. describe the trade-offs)?
::new So, it doesn't really work. I believe one way is to make constructors private and to force instantiation through a different method (Meyers, More Effective C++).
I'm not following your comment. What are you trying to say? 
Try it: #include &lt;iostream&gt; class Omega { public: Omega() { std::cout &lt;&lt; "Omega::Omega()" &lt;&lt; std::endl; } private: void* operator new(size_t); void operator delete(void*); }; int main() { Omega* instance = ::new Omega(); } One way would be to make all constructors private and then provide a static method such as *Class\* Class::GetInstance()* . This topic is approached in "More Effective C++" (2ndEd).
Wow. I thought that you couldn't call ::new if you had a class-based new defined. Thank you for enlightening me. &gt; One way would be to make all constructors private and then provide a static method such as Class* Class::GetInstance() This works well for singleton objects or for objects that you always want to allocate on the heap. But I don't see how this can be used to guarantee an object is allocated on the stack.
Shit, I seem to have gotten confused as to the original question. (I hate it when people use being tired as an excuse, but there you have it: I'm tired, it's late over here). From what I remember reading in Meyers' books, making sure objects are only allocated on the stack is not so easy, I'm not even sure it's actually (portably) possible. I believe this question is much trickier than the others treerex suggested, I wouldn't ask it in an interview.
What makes you so sure You can identify a smart but inexperienced programmer?
So, you're right, this isn't a good interview question. Well, with all that being said however, if I want to have a class that I don't want people to allocate on the heap, I'd still put the new, new[], delete, and delete[] operators in the private section (or use the C++11 feature "=delete") and put a comment there that the class is only to be stack allocated. It won't prevent someone from using ::new, but it will prevent people from using non-globally-scoped new. That will likely catch 90+% of the cases I believe. It's not perfect, but it is likely better than nothing. (Of course that could be debated.)
some more questions: * Describe the different function argument passing mechanisms (ie pass by...). * How would you implement a shared pointer? * Assume an empty class, what functions does it have? * Describe multiple inheritance.
&gt; How would you implement a shared pointer? I'm not very sure that question actually makes sense.
A technical interview is indeed a horribly inaccurate way of determining someone's skills and their fit for a job. But I don't have much faith in references either, because: * Obviously people cherry-pick the best boss they've had, and omit the one they punched. * I've had people who gave their friend-colleague at a place as a reference, and that person bigged-up their position wrt the referent. At least, in hindsight (having hired the person) that was the opinion I formed; short of having lawyers depose everyone involved as to who really worked for whom, it's impossible to know. * The legal position in many countries is such that people are reluctant to give bad references for fear of being sued for defamation. Rather radically, I worked one place where we were forbidden from giving references (good or bad), but only allowed to confirm the referent's employment, grade, and the broad nature of their duties. * Some people will give *good* references to employees they know are *bad*. Encouraging someone to quit and helping them out the door with a good reference is cheaper and easier than firing them. Or if a RIF is taking place, and they're canning the underperformers for a given work unit, the supervisor of that unit already feels like a colossal wanker (because coming it to work one day and telling ten people you've worked with for years, who you know are sole-breadwinners for their families, that they're immediately unemployed, is hard). So he'll do his best to get the RIFfed people new jobs, and if that means accentuating the positive he's happy to oblige. Don't get me wrong; I don't know of a magical alternative that *does* determine a decent candidate from a bad one. But if by "phone interview" ZMeson means "phone screen" (and you're just looking at the phone call to be a 10 minute check to make sure you're not wasting everyone's time by actually interviewing an inappropriate candidate) then a few technical questions of the type treerex mentioned aren't bad. In that case you'd mostly look for answers that show a basic understanding of the topic, rather than necessarily being right on each one. **Tangential story**: in my first job, they had me write a C programming test to which they subjected future candidates. It was really rather hard (and I think they didn't give people enough time to do it), so anyone who made a decent stab at it was acceptable. Every candidate the company hired for several years later sought me out to complain about the test (and particularly the question about trigraphs). But one guy was a recent Ph.D CS and he just *refused* to sit the test, saying his doctorate was evidence enough of his brilliance (it was an embedded engineering job, nothing fancy). The hired him anyway, and set him to work writing a debugger. When, after a week, he'd still failed to write the "hexdump range" function (which was to do the equivalent of hexdump -C) they realised the mistake they'd made. 
No mention of variable capturing (which, I guess, confuses a lot of people regarding the syntax). :/
&gt; But one guy was a recent Ph.D CS and he just refused to sit the test, saying his doctorate was evidence enough of his brilliance (it was an embedded engineering job, nothing fancy). The hired him anyway, and set him to work writing a debugger. Would your test have identified the fact that this PH.D didn't know how to write a debugger? Honestly, my answer to most interview questions is "I'd look it up. I wouldn't waste my company's time trying to re-invent the wheel." This is just confirmation bias. Anecdotal evidence isn't an effective means of defining a solution. Fundamentally, the interview process is just awkward. It's always going to be a bit of a crap shoot. I think one has to try and manage it differently. I recognise and accept that references are only going to be good references. IT's about selling yourself. The degree of praise and the description of the work is also a measure of someone's capability even if it's described in positive terms. "X is an amazing junior engineer. He's written server side software using X technologies etc. He takes direction well." tells me a lot. 
What makes you so sure You can do *anything*? It's a skill that takes practice and development. Google and most major successful tech companies hires for talent, not experience; why shouldn't you?
&gt; Would your test have identified the fact that this PH.D didn't know how to write a debugger? It would have identified that, when he said he was a very experienced C programmer, he was just plain lying. When, after a week of trying (with others help) he couldn't so much as print a char array.
Actually, I was under the impression that presenting the entire lambda syntax will be more confusing for a beginner than showing a few examples. 
I'm not sure how he would have gotten a PH.D.
Take your pick from [http://dev.fyicenter.com/interview/] particularly [http://dev.fyicenter.com/Interview-Questions/CPP-1/index.html] and [http://dev.fyicenter.com/Interview-Questions/CPP-2/index.html] From that list, I personally like people who self rate themselves at a 9 or 10 out of 10 in C++ having problems with: * What is a dangling pointer? (And what are 2 common ways to come across one) * What is meant by Stack unwinding? * What is the difference between a copy constructor and an overloaded assignment operator? * What is an explicit constructor? * What is return value optimization and what care do you need to take if it is enabled?
Isn't that the legend of Giotto drawing a perfect circle in order to get the job painting the Basilica of St. Francis of Assisi?
Makes for a great fable. Less useful in practical real-life terms. Who programs in a vacuum these days?
why wouldn't it make sense?
I always try to get the interviewee to explain stack unrolling when an exception is thrown, what sort of things will and will not have their destructor called, and what is at danger of being leaked. I also like to see if they understand the clone() idiom. They should understand the advantages and disadvantages of the different STL containers. A fun one is "explain to me what the static keyword does" and see how many different ones they get. They should absolutely know static member variables and methods, probably static local stack variables. If they understand what static does to free functions and global variables, big plus. I also like to throw in a couple of questions that are really not important to the average coder, just to see how far into the dark corners of the language they have gotten. Do they know what SFINAE is? I would still hire someone who has no idea, but answering that question shows they are well read in C++ topics. 
tricky is a great interview question... it exposes how someone thinks rather than how much they know (which is arguably more important)... But this is my naive opinion, which isn't backed up by any experience.
Those are not so great. I would ask them to tell you how "std::map" is implemented in the GNU version of the STL. Also, "how might you dump the contents of a said map in GDB?" "What is partial template specialization?" "Why might I want to avoid inheritance in lieu of template specialization?" "How can I control global static construction order in a C++ executable?" 
You're joking, right? 
Which is precisely my point: experienced != smart.
I've wanted to ask this one... something along the lines of: For a given pointer 'x', under what condition are these three equal? Is it possible to get three different results? reinterpret_cast&lt;X*&gt;(x); static_cast&lt;X*&gt;(x); dynamic_cast&lt;X*&gt;(x);
Picking 2 at random: &gt; 1) Write a program that ask for user input from 5 to 9 then calculate the average &gt; int main() { int MAX=4; int total =0; int average=0; int numb; cout&lt;&lt;"Please enter your input from 5 to 9"; cin&gt;&gt;numb; if((numb &lt;5)&amp;&amp;(numb&gt;9)) cout&lt;&lt;"please re type your input"; else for(i=0;i&lt;=MAX; i++) { total = total + numb; average= total /MAX; } cout&lt;&lt;"The average number is"&lt;&lt;average&lt;&lt;endl; return 0; } &gt; 2) What is the difference between an object and a class? &gt; &gt; Classes and objects are separate but related concepts. Every object belongs to a class and every class contains one or more related objects. - A Class is static. All of the attributes of a class are fixed before, during, and after the execution of a program. The attributes of a class don't change. - The class to which an object belongs is also (usually) static. If a particular object belongs to a certain class at the time that it is created then it almost certainly will still belong to that class right up until the time that it is destroyed. - An Object on the other hand has a limited lifespan. Objects are created and eventually destroyed. Also during that lifetime, the attributes of the object may undergo significant change. 
I've never been a fan of the "what's a vtable" question.. first, it gets asked a lot so they might be able to answer by memory, but second it's not really part of the standard -- technically. The static global variable is a great question. Another is to ask when a static local variable constructor happens; and to follow up by asking how it knows not to run a second time the next time the function runs.
As you say, you can use something like your binary_stream class. I'm not sure what using a new opeartor gains you other than novelty. Plus, &lt;&lt; and &lt; have different levels of precedence; I'm not sure if that could cause headaches somehow.
No questions here. Beside an ego challenge, what is the point of asking questions that folks can memorize? Would you really want to evaluate an artist based on the fact they can explain thoughts surrounding design concepts? Heck no! Send me a piece of concept art with a robot standing on a field of skeletons with a storm of lightning approaching! Send me code! Huge bonus points if they send you code to open source work they've done. I'm positive that you can spend less time with their code (without asking a single question) to see what they know... So, they're using those cool OOP concepts? How about STL? Oh, interesting, they're doing x, y and z here -- that could be far better... bam, ask them about this, i.e.: "So, walk me through how you decided to do x and y here?" "I see you did this last year. How would you do things differently if you were coding this today?" You should know the details of the job so if it requires some funky stuff outside of the realm of what they've shown you, but their code shows promise, send them off to code a solution to a specific problem. Evaluate folks on their ability to finish things. Taking something from concept to completion is worth it's weight in gold. Seeing passion for this stuff is huge. Save yourself time and avoid folks who have nothing to show. I don't care how awesome you sound- I want to see some completed stuff. 
ok, now call me
call you what?
Ah that worked nicely. Thanks.
If you add 4 spaces at the start of each line, reddit will treat it as code... for(int i = 0; i &lt; rows; i++){ for(int j = 0; j &lt; columns; j++) a[i][j] = ' '; } You can remember it by pressing "formatting help" at the lower right of the comment box.
I think you're right on this being a good interview question, but maybe not for a phone screen unless you've developed some good rapport earlier in the call or they've shown their stuff already. None of us came up with anything directly, but there was a decent discussion of possibilities. Of course introducing with some caveats might not be a bad idea: "Okay, this isn't really an everyday problem, but how would you..." Or give some other indication that you don't expect them to get it totally right.
row and col neew to be const for it to be used to make an array. You can instead just used vectors vector&lt;vector&lt;char&gt; &gt; a(rows, vector&lt;char&gt;(cols, ' '))
You can get rid of ::new by hiding ctors, but you still need a copy ctor something like this: #include &lt;iostream&gt; struct C { // Hopefully our compilers are smart enough to do copy-elision without move // semantics or we at least can get by with default copy and assign. static C create() { return C(); } // Copy and assign to see if they are elided (without hitting the assembly). C(C const&amp; that) { std::cout &lt;&lt; "C::C(C const&amp;)" &lt;&lt; std::endl; } C&amp; operator = (C const&amp; that) { std::cout &lt;&lt; "C::operator = ()" &lt;&lt; std::endl; return *this; } private: C() { std::cout &lt;&lt; "C::C()" &lt;&lt; std::endl; } }; int main() { //C* heap = new C(); // error: ‘C::C()’ is private within this context //C* heap = ::new C(); // error: ‘C::C()’ is private within this context C* heap = ::new C(C::create()); // Unfortunately, this still works. delete heap; C stack = C::create(); // This is fine. return 0; } This should only print two lines of "C::C()" if your compiler is nice. I haven't thought about this problem much before, but I have a strong feeling there isn't a good way to prevent heap allocation altogether without angering the universe. However, these approaches seem to be reasonably unobtrusive, and make heap allocation enough of a PITA to really discourage people who don't read documentation, or the code... Maybe not a good phone screen question without some caveats as in [my reply to spotta below](http://www.reddit.com/r/cpp/comments/lwlm1/what_are_good_phone_interview_questions_to_help/c2wcvny). Anyway...
 #include &lt;iostream&gt; int main(){ std::cout&lt;&lt;"This is awesome!"&lt;&lt;std::endl; return 0; } TIL this
Yeah, use a vector or a custom data structure. There's almost† no reason to be using raw arrays in C++. † scientific computing guys excepted
&gt; * How would you implement a shared pointer? Might be a bit weird to describe over the phone, wouldn't expect all the details. Good for a face-to-face. &gt; * Describe the different function argument passing mechanisms (ie pass by...). &gt; * Assume an empty class, what functions does it have? &gt; * Describe multiple inheritance. Good language law questions. The multiple inheritance could be pushed a little bit more too: "What are some problems that can arise when using it?" 
What exactly do you think it is that allows `cout &lt;&lt; i` to work if not operator overloading? Doesn't the fact that this is accomplished by defining a function named `operator&lt;&lt;()` seem like an indication that operator overloading is involved? Just because the overloading is happening in a compiler-provided header doesn't mean it's not still overloading. 
I find that great programmers are not defined by the programming language specs that they know by heart, but by their intimate knowledge of every step along the way, from high-level abstraction to hardware-level optimizations. Some of the greatest C++ programmers I've worked with still had to look up the rules for namespace resolution and the syntax for the more esoteric techniques around template metaprogramming, but knew immediately what the benefits and drawbacks of each technique was, both from a performance viewpoint and from a maintenance viewpoint. And let's face it, if performance wasn't a critical issue for you, you (hopefully) wouldn't be using C++ at all… ;)
And the C++ standard library implements that behavior **with operator overloading**. `a &lt;&lt; 1` means right shift 'a' by one bit. To change that behavior, the &lt;&lt; operator must be redefined (overloaded) to mean something else in the case where the LHS is a std::ostream. You seem to have some bizarre notion that it's only overloading if it happens in user code and not in library code, but this is completely false. The mechanism is the same (i.e. defining a function named `operator&lt;&lt;()`) whether it happens to be in some header named `iostream` or in user code. The difference is completely immaterial and indistinguishable to the compiler itself. 
You're problem is already solved but i want to correct a detail here so people that are unfamiliar with C++ don't get confused: There are no multidimensional arrays in C++. You have created an array of arrays. Please have this in mind when creating such structures. And (like ptrb said) it is often right to use higher data structures like std::vector instead of c-style arrays.
I would have real trouble parsing out the meaning (probably because English isn't my native language). (1) this has dual meaning (language vs. ABI), you clarified by the "pass by", but I wouldn't give this over phone (2) what do you mean by shared pointer? Are you asking about smart pointers? (3) functions? methods? purpose?
Seriously, unless this is a position on the GCC project, the first question is just completely useless.
If you think that this kind of knowledge is important to write high performance code, then you don't know C++ at all.
The counter has been thread-safe for a long time now -- in boost implementation (and thus in standard specification)
Go away, if you have nothing but trolling to contribute. Posts like these add nothing of value to the discussion.
static_cast is also to be used when casting between T\* and void\*.
&gt; Assume an empty class, what functions does it have? This is a tough question as it requires the understanding of PODs.
Look into the mirror and read your post. You are the one trolling. The whole idea on top of which C++ is built is that you don't need to know the implementation details. All you need to do is to use features when they are required and only when they are required. Of course there are exceptions in cases where some buggy compiler would implement some feature extremely ineffectively. Such cases are common, but definitely don't fall into the "should know to get a job" area.
Yes, you're right. There are apparently [a lot of other uses for static_cast](http://en.cppreference.com/w/cpp/language/static_cast) such as static down-casting. I don't know if I would be comfortable using it that way it most cases though. (I would prefer dynamic_cast for down-casting.) I suppose if guarantees were made via earlier checks, then I might choose static_cast instead of dynamic_cast if this were performance critical code and profiling showed that changing the cast game me the performance gains I needed. I need to learn about the other uses of static_cast. Looking it up has been a bit of an eye-opener.
Coming into this thread, adding nothing but "if you believe what you wrote is true, you know nothing about anything" is pretty much the definition of trolling — it's the apparently deliberate attempt to cause conflict by being both inflammatory, rude, and completely off topic. I would be worried about hiring someone who doesn't know what the cost of a virtual method call is. Inlining is one of the most important micro-optimizations that a compiler can make — knowing how to design an algorithm around it is the kind of knowledge you would expect from someone who is supposed to write performant code in C++. And no, I would *definitely* not hire a C++ programmer who didn't know this type of implementation details, or at least had an idea about what the common ways to implement it would be. Not because I have a particular hatred for virtual methods, but because it's important to know how and when to use them.
The best way to store a multidimension array is in a single array with a simple 2d interface. And the best way to implement arrays is with a vector. struct two_dime{ std::vector&lt;int&gt; arr; ::: int element_at(size_t i, size_t j){ return arr[i+j*i_sz]; } }; You'll need to fill in a few blanks. 
I teach C++, and yes I do show a simplified version of vtables to explain why virtual methods work the way they work. But not because it is required knowledge, but because late binding is easy to example through vtables. But this has nothing to do with the fact, that virtual method calls are slow. This implied by the fact, that virtual methods are dynamically bound. Plain callback will have a very similar performance cost (although plain callbacks should be faster).
&gt; what is the point of asking questions that folks can memorize? Because in C++, understanding basic concepts - which can be memorized - help write robust code that does not cause memory leaks (eg. knowledge of when to define a custom copy constructor) or undefined behaviour (eg. when to use delete[] and delete, when to use virtual destructor). That being said, C++ trivia should of course not be the only - not even the most important - criterion for selecting employees, but I believe these questions should still be asked.
So, returning to your original statement, I'm baffled that you would claim that knowledge about the cost of dynamic binding is somehow not important in designing high-performance code — or at least, that seemed to be the implication of your statement regarding my alleged complete ignorance about C++, based on my insistence that this knowledge *is* in fact important.
About "std::map" implementation? Not useless at all, if someone professes to have years of experience using g++. I ask it often. I know someone is lying if they tell me they have years of experience and don't know that, because it's very obvious what the implementation is as soon as you're looking at a stack (from a crawl, or within gdb). 
Just a few quotes from your posts: &gt; ...how virtual methods are usually implemented? &gt; How is it [vtable] allocated? &gt; ...from high-level abstraction to hardware-level optimizations. There is big difference between knowing the cost of basic design decisions and knowing the implementation details of low level C++ design. That is, there is big gap between knowing the cost of dynamic binding and knowing the implementation details of vtables. The first one is very important, the second one isn't.
 Don't listen to all the people telling you to use vectors. This is the simplest way to do this (use a 1d array): char board[row * col]; Then initialize all the elements with a simple for loop: for(int i = 0; i &lt; row * col; ++i) board[i] = ' '; Then access individual elements like this: board[y * col + x] Unoccupied spaces could be defined as ' ', and player occupied spaces could hold a value or character representing the player. Also: &gt; cpp newcomer... xcode Honestly, you might be better off just using a text editor and a command line at this point. Xcode and most other IDEs add far to much complication and abstraction to simple projects like this.
&gt; Another way to store a multidimension array... FTFY
A smart person won't know at all. If you want to figure out "smart", asking about const-correctness is close to the last thing I'd ask about. 
Yes, that's kinda my point. Technical minutia of C++ is barking up the wrong tree: find out if the person has lots of successful projects, good design sense, good communication skills, etc. before you start measuring C++-only criteria. In fact I would only bust out the detailed C++ knowledge if I had two similar candidates I needed to differentiate. That said, asking a few basic C++ questions as listed above is a good way to a) break the ice b) find out if the person is lying about having any C++ experience at all; what I wouldn't do is asked very intricate questions or make that my focus of the interview -- even on the phone.
&gt; **(it was an embedded engineering job, nothing fancy).** I don't know you, your experience or your background, so I need to give you the benefit of the doubt... I'm not sure if you're saying it was an embedded engineering job, therefore it follows that it was nothing fancy... Or are you saying that it was an embedded job, but it wasn't a very fancy (hard/challenging) job when regarded in the whole spectrum of embedded engineering. If you're saying "embedded" implies "not fancy", I'd love to have that discussion. A lot of enterprise DB guys / Java guys / Windows app developers -- *not saying you are any of these* -- think "embedded" means "blinky". The stuff I work is extremely complex, life-critical software. Multi-core, tons of threads, hard real-time, nested interrupts, device/hardware interfaces, chip errata, interfacing with analog electronics &amp; signal processing, etc. My temptation would be to look down on developers at a place like Facebook. Big deal, read somebody's account info, throw up some HTML, blah blah blah. But I realize that a) some very smart people work at Facebook (e.g., Andrei Alexandrescu), b) they probably have extremely challenging issues as far as performance, scalability, stability, etc... and c) I just don't have enough knowledge about the problem domain or the platform to make a judgement. 
If I wanted to know if they had C++ experience, I'd ask how "std::map" is implemented in the GNU STL. See my other post. If you claim years of C++ experience and don't know that, you're probably lying. 
Pretty much this. It alleviates a lot of the problems that come with multi-dimensional arrays in C++.
Because I believe "shared pointer" is a term used within the Boost C++ Libraries, and not a generic concept such as "smart pointer implementing reference counting". A fast/dumb pointer can be shared all you like.
Why the heck would someone rembember something like this? Why the heck would someone not use pretty printing for STL? Not to mention that exploring std::map using gdb/ddd does only show you the class layout not the implementation. Btw. the implementation is: &gt; Red-black tree class, designed for use in implementing STL associative containers (set, multiset, map, and multimap). The insertion and deletion algorithms are based on those in Cormen, Leiserson, and Rivest, Introduction to Algorithms (MIT Press, 1990), except that &gt; (1) the header cell is maintained with links not only to the root but also to the leftmost node of the tree, to enable constant time begin(), and to the rightmost node of the tree, to enable linear time performance when used with the generic set algorithms (set_union, etc.) &gt; (2) when a node being deleted has two children its successor node is relinked into its place, rather than copied, so that the only iterators invalidated are those referring to the deleted node.
Note that lambdas don't require explicit return type to be declared. Return type is deduced to be type of the expression if lambda contains only return statement. Otherwise it's deduced to be void. Parameter list is also only required if actually used.
Cool. TFA should have mentioned this.
&gt; What makes you so sure You can do anything? Well I have no answer to that. My question was rhetorical actually. I was trying to imply that figuring out whether someone is smart is a fairly difficult task in my opinion. Even trickier to do during an interview. &gt; why shouldn't you? I never claimed that one shouldn't, I was only expressing doubt that many recruiters have the ability to do so.
&gt; There is big difference between knowing the cost of basic design decisions and knowing the implementation details of low level C++ design. Huh? What is that difference? When you know the general implementation strategy for polymorphism in C++, the costs are kind of apparent — more importantly, the foundation for that knowledge must be good (for instance, the person must have a solid grasp of pointers, function pointers, code/data interdependence, etc.). &gt; The first one is very important, the second one isn't. You cannot know the actual cost of the dynamic binding without knowing at least one implementation strategy.
You don't need to tell me. Have you used gdb to look at cores from apps that use STL? 
Don't know why you're being downvoted, everything you're saying is correct.
That's kind of just an argument of semantics.
&gt;(1) this has dual meaning (language vs. ABI), you clarified by the "pass by", but I wouldn't give this over phone What I meant with the "pass by" question was "what are the different ways to pass a variable to a function". For example, Java uses pass by value-reference. &gt; (2) what do you mean by shared pointer? Are you asking about smart pointers? With shared pointers, I'm talking about pointers to dynamically allocated memory, to which you do not explicitly need to return to the heap. &gt; (3) functions? methods? purpose? This one is probably one of the more difficult ones. Honestly, I'd be surprised if somebody knew all of them.
I agree it's quite tricky, but really there's no other option. Google has come closest as anyone to studying and systematizing the recruiting and hiring process. They have 3 major means of acquiring talent: * Bring in a shit-tonne of candidates and pick the top X% available * Run Summer of Code and hire people from successful open source projects * Buy companies that make interesting products and reassign their people I have friends who have gone to Google via all of the above routes; most of us who are hiring do not have the scale to run the same operation, but we still need to hire people, so what are our options?
What's the answer you are expecting "it's a red-black tree"? Is that really all the criteria you need to decide? The bottom line is each question or form of test you can devise is only a kind of "probe" or experiment that tells you something very limited about your subject. If you want to answer the question "will this person be a good member of our team" you need a large array of very broad probes, the skill to interpret their results, and a means of collating that into some sort of boolean decision to make an offer. Everyone thinks they know how to hire, but more confident you are in your given system or technique chances are the worse you really are at it.
I thought the questions above were really good, so I tried to come up with some more core language ones. Definitely, multiple inheritance is one of those controversial things that people are usually vehemently opposed to, or strongly in support of. I might have to remember that one :).
(2) I still don't get what you mean by the "shared" part. (3) Uh? What all of them? All of what?
Yes, if someone doesn't know that, they clearly haven't spent a lot of time with g++ and gdb. I would only ask this of someone who "advertised" significant experience with those tools. 
upvote for xcode being bad. notepad++ is the shit but i don't think it runs on OSX so check out Sublime Text 2 http://www.sublimetext.com/2 Really, a text editor and the terminal are the best way to learn. IDEs throw a lot at you that you don't even know if you need yet.
The point is that "shared pointer" isn't a general concept. It requires the candidate to ask for clarification from the recruiter, only to be (probably) told about reference counting. So why do that, instead of asking about the generally accepted term in the first place. "How would you implement an archive*?" \* boost serialization
Well, as I see it, most of us don't require the talent that Google does. Would be nice to have - clearly, but then you also have to attract such talent (which most of us can't do in the first place).
No. Smacking a developer because they use the &lt;&lt; operators for stream I/O that have been de-facto standard for over a decade? Ridiculous.
By all means, if you don't require talent, go ahead an hire whomever you choose! But for the companies I have been involved in we have the luxury of choice, and whenever possible I use similar methods to Google and others, which include emphasis on problem solving or some other sort of exceptional skill over specific language law. If you're interested in hiring engineers, you should really look into how they do things.
that is correct, shared pointer is not a "general concept"
or simply: struct foo_hdr_t { uint32 foo_bar; uint16 foo; }; 
Yes. It's a bad feature of the language and many projects avoid it entirely. It is the NOT convention by any stretch of the imagination. 
as far as I know j++ increments j after the line is processed ++j for example would increment j before the line is preocessed same for j-- and --j
I always just use cin.getline. Does the job for me. I remember reading something about not to use cin.get() - can't remember what though.
when I type cin.getline it gives me an error: "a pointer to a bound function may only be used to call the function.
when I type cin.getline it gives me an error: "a pointer to a bound function may only be used to call the function.
Put a cin.ignore(255,'\n') right before the cin.get(). The cin &gt;&gt; operator you used previously does not flush the return '\n' (when you press enter after typing the number) from the IO buffer I believe. That ignore will discard the returns. Edit: cin.ignore() would even work I think; it defaults to discarding one EOF character which is what you need in this case Also, if you want this to be portable, you should change it to int main(void) and include ~~stdlib.h~~ cstdlib for the rand.
He means `cin.getline();`
also, BTW, use r/learnprogramming for this stuff. People don't seem to like seeing it here.
Use cin.ignore() before the cin.get() function to flush input, otherwise it'll get whatever is int he input stream, then end the program. Pretty sure
That's not Borat. That's just the way [he looks](http://en.gravatar.com/herbsutter). 
&gt;How would you construct a class that ensures it can only be allocated on the stack. What are the real-life situations where this would be needed? It seems to me like only a very badly designed class would need that. Anyway, the most obvious answer that comes to mind is: /*! *A class that does something fancy. *IMPORTANT: ALLOCATE ONLY ON THE STACK */ class bananaFactory {...}; How would that do in an interview? Am I being a smartass?
&gt; Also, if you want this to be portable, you should change it to int main(void) and include stdlib.h cstdlib for the rand. [Hmm.](http://faq.cprogramming.com/cgi-bin/smartfaq.cgi?id=1043284376&amp;answer=1044841143)
Some of the answers to the questions are just wrong. For example: &gt; What is the difference between Mutex and Binary semaphore? &gt; &gt; semaphore is used to synchronize processes. where as mutex is used to provide synchronization between threads running in the same process. 
Basically, don't use raw pointers at all in C++ unless you really, really know what you're doing. Use smart pointers from a library, and even these take smarts to use smartly. The main uses of pointers in C++ are 1) run-time polymorphism 2) passing functions to other functions 3) returning an expensive hunk of data out of a function 4) defining collections. 1. Run-time polymorphism is a feature of object-oriented programming. Let's say your program knows that circles and squares are shapes. If one part of your program defines some circles and squares which know how to draw themselves, and another part of your program has some shapes but doesn't know whether these are circles or squares, it can tell those shapes to draw themselves and they will correctly show up as circles and squares. 2. Sometimes an argument to a function is another function. This is especially useful when sorting data. Suppose you have a function which compares two letters by their lower-case equivalents. Pass this function to the sorting function when you want to sort several words of mixed case. Function pointer templates from the library are good to use for clarity, but if I'm not mistaken, you can safely use plain ol' raw pointers for functions if you want. Or, if your compiler is new enough, you can use a lambda instead. 3. Whenever you return a value from a C++ function, a copy of the value is created. (The original might or might not get destroyed depending on where in the program it was created.) If the value requires a large amount of memory or takes a lot of time to copy, you might want to return just a pointer to the value because the pointer is much smaller and easier to copy. But now you're in the world of manual memory management. Use a smart pointer, and use it smartly. Or, if suitable, use a new C++11 compiler with `move` semantics. 4. A collection is a group of data of the same type, such as a list of something or an array of something. For example, a `std::string` is an immutable collection of `char`s. It performs various pointer operations with an array of `char`s under the hood so that you don't have to. Use the collections from a library. Don't use arrays unless you really, really know what you're doing and you can't find a suitable collection from a library. 
I get the impression the OP would like something more advanced than a SAMS book from 2001. 
Use the decorator pattern. That's what Java's IO classes do. 
The page. Its a aspx.
&gt;A common misconception is that the same logic can be applied to main(). Well, it can't, main() is special, you should always follow the standard and define the return type as int. Are you supporting my statement with the article or saying he can use void main (which the article says not to)? 
&gt; For C++ &gt; &gt; The following are acceptable uses: &gt; &gt; int main ( int argc, char *argv[] ) &gt; int main () `(void)` is not something you should use. Use empty parentheses.
The int main () would definitely be the preferred syntax, but I was only correcting for compiling portability. I was trying to make as few changes to his code, but that's a good point. 8.3.5.4 : ...The parameter list (void) is equivalent to the empty parameter list... But yes; no reason to use it, and it's standard not to (they only allowed it in the standard for C compatibility).
No. The behavior is not undefined as such, but the order is *unspecified*. So it's up to the compiler to decide the evaluation order. In other words, the compiler might decide to evaluate the arguments back-to-front, so you end up with The value is -1 and then after that has been printed, `val` will be 32. Another way to say this in C terms, is that there is no synchronization point between calls to `operator&lt;&lt;`. :)
I guess the rationale is that the same method is used for serializing and deserializing objects, so using any stream operator would also be unintuitive, and then the `&lt;&lt;` and `&gt;&gt;` operators are conventionally only used for character streams. Other languages might choose to used `&lt;=&gt;` in that case, but that's not a defined operator in C++. :) I would probably have gone for something like `archive &lt;= object;`
I appreciate your response, but I *really* appreciate you listing an example of each use - it really cemented each point in my head. Kudos to you!
oh ok so?
&gt; What are the real-life situations where this would be needed? RAII. I want to be absolutely sure that someone doesn't take this class and put it on the heap, then forget to delete it, leaking some important resource. When working on embeddable systems this is important. &gt; How would that do in an interview? Not well, because the main point of the question is to probe your understanding of access control and allocation functions. &gt; Am I being a smartass? *That* would depend on your response to the question. If you flippantly dismiss it as stupid then I'd have a problem. If you thoughtfully asked questions about why you would want to do it and then thought of some approaches to doing it, even if you didn't get it, that would be a Good Thing. 
&gt;RAII. I want to be absolutely sure that someone doesn't take this class and put it on the heap, then forget to delete it, leaking some important resource. When working on embeddable systems this is important. How are you gonna make sure someone doesn't allocate something like int[2000] on the heap and forget to delete[] it? If someone can't keep track of his heap allocations he shouldn't be working with C/C++ in the first place. If you keep holding his hand like that he's never gonna learn anything and sooner or later he's going to screw up badly in a way you had not anticipated. C++ is not a language designed for babysitters. That's the way I look at it. I admit I don't have much experience with large scale / embedded projects, so maybe it's the experience that makes you look at things differently and I'm simply wrong. Anyway, I'd like to know the answer to this question. How do you construct such a class? I haven't seen any correct answer in other replies yet.
&gt; How are you gonna make sure someone doesn't allocate something like int[2000] on the heap and forget to delete[] it? If someone can't keep track of his heap allocations he shouldn't be working with C/C++ in the first place. This is an incredibly naive point of view. Sometimes you have to work with substandard programmers. Sometimes even gurus forget. If you can use the language to insulate yourself from mistakes, then you are an idiot not to do so. Leaving landmines around to "teach someone a lesson" is stupid, and I wouldn't want to work with anyone that has that point of view. 
Probably, I did say though that I use it for their questions, if I don't know the answers to the questions I give then I really shouldn't be asking it. How would I be able to evaluate an alternate wording of the answer, or something very close but not quite the answer?
&gt; I'd like to know the answer to this question. How do you construct such a class? I haven't seen any correct answer in other replies yet. Unfortunately since you can call `::new` you can't completely prevent it from happening. However, merely declaring operator new and operator new[] private in your class will make the compiler catch most, if not all, attempts to dynamically allocate these, which is good enough for me. If someone really wants to get around the encapsulation, they can, but they have to do it explicitly, and sure as hell better have a good reason. 
&gt;Note that lambdas don't require explicit return type to be declared. That's pretty slick!
&gt;This is an incredibly naive point of view. Sometimes you have to work with substandard programmers. Sometimes even gurus forget. If you can use the language to insulate yourself from mistakes, then you are an idiot not to do so. So you want to insulate yourself from mistakes by effectively disabling one of the core features of the language? You consider simply using that core feature is "leaving landmines"? Even if you really wanted to do that and get rid of heap allocation altogether by hiding operator new and new[] in every class used in your project, your "substandard programmer" can still fuck up by allocating PODs on the heap and leaking them and you can do nothing to stop him. The only thing you would accomplish is making programmers who know what they're doing angry. With all due respect, none of what you say makes sense. You sound like someone who just doesn't understand C++ and would rather be using Java instead.
I found The Design and Evolution of C++ to be very compelling. It's not a how-to, though.
Back up the bus. No where did I say I wanted to do away all together with heap allocation. What I said was that _in some situations_, such as RAII (where the whole intent of the idiom is to utilize the fact that stack objects are automatically cleaned up for you), it can be advantageous to use another language feature (declaring `new` to be private within the class) to prevent inadvertent, incorrect usage of the class. Your view seems to be that a comment should suffice, and if someone makes a mistake then they're stupid and should have read the comments. People are not infallible, and they will make mistakes. You say as much in your responses. &gt; The only thing you would accomplish is making programmers who know what they're doing angry. No, that's not what it does. What it does is statically (i.e., at compile time) enforce the expected usage pattern of the class and require the programmer to think about what they're doing. &gt; You sound like someone who just doesn't understand C++ and would rather be using Java instead. Whatever. I wrote my first C++ program in 1989, worked on Symantec's C++ compiler in the early 1990s (with Walter Bright), and have written code in C++ that has run on everything from TV set-top boxes to huge data centers. I think I understand the language quite well, actually. 
Ok, so it seems we just didn't understand each other. From you earlier post it seemed like you want to disallow heap allocation to prevent memory leaks. Instead you want to use it for classes that only make sense in the context of RAII, like a mutex locker or something like that. That surely does make sense. &gt;Whatever. I wrote my first C++ program in 1989, worked on Symantec's C++ compiler in the early 1990s (with Walter Bright), and have written code in C++ that has run on everything from TV set-top boxes to huge data centers. I think I understand the language quite well, actually. Glad you cleared that up. As you understand it's hard to deduce someone's qualifications by reading a few of his sentences. I hope you don't feel offended.
&gt; I hope you don't feel offended. Not in the least. Glad we could yell at each other and come to an mutual understanding. That's the best way! :-) 
What do you man by being "portable?" I'll have to try the code soon. My class just ended this week lol.
True for c++03 too ...
If you wanted this program to compile with a different compiler, you have to follow C++ standards. Some IDE's allow void main() and will include the stdlib by default, but you should use int main() and include the proper libraries.
Oh, okay. Yeah it was just an intro to c++ and we only worked on windows platform so my professor didn't cover compiling on other platforms except that code may our may not work on different platforms.
If you don't need resizability, using std::array (c++11) is often better.
Bahaha. Just the other day a bitter pal of mine was complaining that with the next iteration, C++ would just take straightup Python code. Looks like he's not alone in that dream/nightmare :D
If asking for help in this way is bad etiquette I'll happily remove the post.
There are cases where the type of a tern can't be resolved at compile time. Take http://ideone.com/LXZWs for example. You get a nonsensical error because neither my silly Int nor Double class can be converted to the other, despite the fact that they're both convertible to Number.
Well, Its not really very clear what you're asking for help with. Are you asking how to read from a file? How to get input from the keyboard? What does it mean for one part to line up with another part? 
He lost me at using two different template type parameters for the min function.
Mostly I just wanted someone to check if what I've done so far works okay. It should just ask for numbers than sort them right now. But It's okay, I went to the library picked up some books, and I think I'll just figure it out on my own for now.
If you use C++11, this is an example of how simply it could be done: #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() { multiset&lt;int&gt; numbers; int x; while (cin &gt;&gt; x) { numbers.insert(x); } for (int i : numbers) { cout &lt;&lt; i &lt;&lt; endl; } } 
Why would anybody want to ruin the glorious syntax of C++ with filthy Python syntax?
Yeah, change it to Multimap&amp; Multimap::operator=(const Multimap&amp; m) void Multimap::addAssociation(int key, int value) void Multimap::setName(int key, const std::string&amp; name)
I got a lot of help out of 'Practical C++ Programming'
How could C++, being defined by an ISO standard, ever support anything unofficially? What's in the standard document is what is supported, nothing else, and if it is then it can hardly be called unofficial. The fact that it seems to work in most - or even all - compilers doesn't mean squat.
Yep, what he should have said is "Anonymous Structs are an extension supported in these compilers: &lt;list&gt;. Here is how to use them." 
One other nice use for anonymous structs and anonymous unions together is that it can help tremendously with data layout. Consider this definition of a vector object. #include &lt;iostream&gt; using namespace std; union vec4 { double data[4]; struct {double x,y,z,w;} euler; struct {double r,g,b,a;} colors; vec4(double tx=0.0,double ty=0.0,double tz=0.0,double tw=0.0) { data[0]=tx;data[1]=ty;data[2]=tz;data[3]=tw; } }; ostream&amp; operator&lt;&lt;(ostream&amp; out,const vec4&amp; vin) { return out &lt;&lt; "{" &lt;&lt; vin.data[0] &lt;&lt; ',' &lt;&lt; vin.data[1] &lt;&lt; ',' &lt;&lt; vin.data[2] &lt;&lt; ',' &lt;&lt; vin.data[3] &lt;&lt; "}"; } int main() { vec4 v1(12.0,2.0); cout &lt;&lt; v1.colors.r &lt;&lt; endl; return 0; } You could turn that into a data object easily using anonymous structures in the union so that x-&gt;r-&gt;data[0] without any intermediate .colors specifier #include &lt;iostream&gt; using namespace std; union vec4 { double data[4]; struct {double x,y,z,w;}; struct {double r,g,b,a;}; vec4(double tx=0.0,double ty=0.0,double tz=0.0,double tw=0.0) { data[0]=tx;data[1]=ty;data[2]=tz;data[3]=tw; } }; ostream&amp; operator&lt;&lt;(ostream&amp; out,const vec4&amp; vin) { return out &lt;&lt; "{" &lt;&lt; vin.data[0] &lt;&lt; ',' &lt;&lt; vin.data[1] &lt;&lt; ',' &lt;&lt; vin.data[2] &lt;&lt; ',' &lt;&lt; vin.data[3] &lt;&lt; "}"; } int main() { vec4 v1(12.0,2.0); cout &lt;&lt; v1.r &lt;&lt; endl; return 0; }
Exactly. And to be fair he *kind of* says that, but it's such an often misunderstood issue that everyone writing anything on the subject should be much more careful to not muddy the waters further.
&gt; often makes what it’s doing *patently obvious* +1
Last year's one was a blast. You will be hard pressed to find such a concentration of C++ hackers in a single venue.
Yes, I guess that's true. But what would that really achieve other than unnecessarily obfuscate the meaning of the code?
Instead of #ifdef, use #if. And then use #ifndef to provide a reasonable default. Then users don't need to supply any macros in their build system (or in code before #include-ing your header) unless they want the advanced functionality.
convenience of notation. The above notation is much much better for programmers used to scientific programs and it simplifies data layout.
Keep at it. I don't know if you're required to use C++ style IO or not. If not, I always found it easier to use stdio libraries. In particular, fgets is great for reading lines out of a file.
Is there a difference between this in python: def min(x, y): return x if x &lt; y else y and this in c++: #define min(x,y) (x &lt; y ? x : y) Sure, macros are nasty, but nasty in the same way that python functions are normal, no?
You know what I mean *wink*
Ok. So think this through. You have char x; What's in there? We have no idea at this point. What *values* of x are you going to modify, or, what values are you going to modify?
Well, you know they have a "difference", that 'a' and 'A' are actually some numbers that we are using to represent letters. Question: If you have the number 'a', what do you have to do to it to get the number 'A'? Once you understand that, the other bit of knowledge is that the number sequence 'a', 'b', ... , 'z' is increasing by 1 each step. The number sequence 'A', 'B', ... , 'Z' is also increasing by 1 each step.
Okay, so when you say modify - i think i have to convert it into the ASCII dec? A=65 a=97 " char x: printf("Enter character \n"); scanf("%d", &amp;x); " I understand what I've done here so far, just unsure how to 'modify' it.
And that's where I'm struggling! I think i know the process: 'a' converted into ASCII dec reference, Dec reference +32, convert dec reference into ASCII figure 'A' ? but i don't know the syntax!?
&gt;I have a task to change the case of a letter using the char variable. I know it has something to do with ASCII, the difference between 'a' and 'A' being 32. That's a great observation! Now, with that in mind you can do a check to see if the letter is capital, or lowercase. if (x &gt; 90) // Letter is lower case. 90 is the value for 'z' { x -= 32; // Subtracts 32 from the value, making it the uppercase letter } else // letter is upper case { x += 32; // Adds 32 to the value of x, making it the lowercase letter } I'd of course check to make sure that the values are within the range of a valid character as well. *Edit check out netshroud's comment for an easier way of comparing!
You can also do: if (x &gt;= 'a' &amp;&amp; x &lt;= 'z') { /* ... */ } else if (x &gt;= 'A' &amp;&amp; x &lt;= 'Z') { /* ... */ } IIRC. Int-to-char comparison ftw.
A char literally is a number. All of these are equivalent / equal: 'm' + '[' 'm' + 91 109 + '[' 109 + 91 200 '╚' (if that displays, result of holding ALT and pressing keypad 2 0 0) ~~*edit: ignoring conversions between storage sizes (essentially, their maximum values), these are otherwise equivalent~~
This is great, I've learnt about if, else and understand it. When i enter a letter in console scanf("%d", &amp;x); does the compiler automatically know/collect the ascii dec value?
In short, yes. As you go on with programming you'll probably eventually realize that a char is a signed byte and yada yada, but for now just worry about yes
Sooo i can just treat these as integers, 'int'?
Come on folks, don't make this harder than it should be. #include &lt;cctype&gt; ... x = toupper(x); // or tolower() 
Okay okay okay! I think I've got it now, it's just that the output is still a number rather than the character. I suspect that this is due to the '%d' is there a different way of outputting the character instead? Edit: WOOOH! i searched the internet for more clues and changed '%d' to '%c' and it worked! Thanks to all that helped, upvotes for all!
For your purposes, very likely, yes. (A char can only represent 256 different values, while an int can (typically) represent 4 billion.)
Now if only there was a method that automatically checked the end and if there wasn't a period to place one. char *capper( const char *str ) { int i; static char temp[MAX_STRING_LENGTH]; i = strlen( str ); if( str[i-1] != '.' &amp;&amp; str[i-1] != '!' &amp;&amp; str[i-1] != '?' ) sprintf( temp, "%s.", capitalize( str ) ); else sprintf( temp, "%s", capitalize( str ) ); return temp; } /* * Returns an initial-capped string. */ char *capitalize( const char *str ) { static char strcap[MAX_STRING_LENGTH]; int i; for( i = 0; str[i] != '\0'; i++ ) strcap[i] = str[i]; strcap[i] = '\0'; strcap[0] = UPPER( strcap[0] ); return strcap; } Ahhh... the days of C. Wrote this for a MUD I played on because I was tired of poorly done formatting. 
As long as the compiler doesn't default to wchar. I hate it when that happens.
Hopefully, that MUD wasn't multi-threaded.
This little to do with the subject. If it is an entire string you want lowering then just use boost string algos. There as serveral for making strings lower case.
I'm not a major C++ programmer by any means but Aspen in the spring sounds very interesting. Sort of a cant loose adventure. This does sound like a good way to brush up on new technology. 
I'm asking you to think it through, and I'm trying to help you do that. Chars, in C/C++, are really just slightly fancy integers. You can add, subtract, multiply, divide, modulo them. So if your hangup is that you think you have to "convert" it to ASCII, you don't. char x; std::cout &lt;&lt; "Enter character" &lt;&lt; std::endl; std::cin &gt;&gt; x; std::cout &lt;&lt; std::endl &lt;&lt; (int) x &lt;&lt; std::endl; (Yes, I use the C++ iostream library. This is C++, not C). Anyway, if you add the line of code I added above, you'll have a program that takes a character from the user as input and outputs its ASCII value. No logic on your part needed. The (int) on the 4th line just tells the output operation to treat x like a number rather than a character. That help?
I would prefer to check *for* exceptions. INLINE CHAR ToLower( CHAR _cLetter ) { if ( _cLetter &lt; 'A' || _cLetter &gt; 'Z' ) { return _cLetter; } return _cLetter - ('A' - 'a'); }
?!?!
I sincerely hope not. We should all just switch to Python, life is easier with Python.
As a non-native English speaker, here's a suggestion: After you get this to work with regular chars, please take the time to learn about Unicode and Unicode libraries, that help you convert a string containing non-ASCII characters to uppercase. All too often do you see things like "FRANçOIS DERRIèRE" or "öZLEM YıLDıZ" or "SøREN KJærSGåRD" because American programmers forget that there is a non-ASCII world out there, and frankly, it looks silly. :-P
they're the same. Internally a char is just a number. To get the ascii value of a char just use a cast : char letter = 'a'; int ascii = (int) letter;
The easiest way is to do this: cout &lt;&lt; letter^32;
I would say your best bet is to stay away from c++ details and just get a good understanding of problem solving. Perhaps you could touch on some basics that hold true through practical application and not theory. Sometimes asking to give some examples of how they were able to use some well known design patterns in past projects. Give problems and ask how they could be solved in many ways and have the interviewee run through the pros and cons of each approach. I good developer should be able to pick up any language given some ramp time and depending on the measure of the team they are joining. What you really want to assess is how well the person works through problems and is able to identify flaws in designs. It should also help identify thinking patterns of the interviewee to you.
If I were to be pedantic, I would point out, that char is not specified to be signed or unsigned (it's up to the implementation). &gt;The three types char, signed char, and unsigned char are collectively called the character types. The implementation shall define char to have the same range, representation, and behavior as either signed char or unsigned char. -- (Standard section 6.2.5)
pseudo: char yourChar; int capDiff = 'A' - 'a'; yourChar = yourChar + capDiff;
I actually thought about this one right after I made my post and realized I wasn't necessarily correct, but decided to leave it. Thanks for quoting that though, as the answer I read off MSDN was: &gt;The C++ compiler treats variables of type char, signed char, and unsigned char as having different types. Variables of type char are promoted to int as if they are type signed char by default, unless the /J compilation option is used. In this case they are treated as type unsigned char and are promoted to int without sign extension. I didn't exactly like that too much though.
You write you are new to programming. A good introduction to C you can find at [r/carlhprogramming](http://www.reddit.com/r/carlhprogramming) Lesson about characters is [Lesson22](http://www.reddit.com/r/carlhprogramming/comments/9ow85/lesson_22_the_char_data_type_and_the_basics_of/)
More than likely why I made a note that I wrote that in C 6+ years ago. That had nothing to do OP. But the second function does what hes looking for.
I still dont fully understand what multi-threaded means, but I'm almost 100% positive that it wasn't.
You're using static variables in functions. That means, that this variable is exists only once in memory and stays there while the program is running. In a multi-threaded program, a everything can be executed at the very same time by multiple threads. Not only at function or line limit, but at instruction level. In your program, they would all share the static variable and without coordination, that can have horrible results. In the worst case, one thread could continue working on the result of capitalize in the belief, that this points to a zero-terminated string. If another thread is currently working on that and overwrote already all of the former string (because a longer string is capitalized) but did not yet write the final zero, the first thread will not only operate on the wrong string, but it could also be non-terminated which will make big trouble. 
I'm not gonna even attempt to claim I understood half of that. But its 4am I'll re-read once I've managed to get sleep. Though thank you for the explanation.
You're welcome. Maybe it's better to read the wikipedia pages for [Threads](http://en.wikipedia.org/wiki/Thread_\(computer_science\)) (tomorrow, not now!) than to start with my explanation. If you have questions, feel free to ask.
The C++ template engine is slowly but steadily turning into a functional programming language. Now all that is needed is constraints. 
It's been a functional programming language for a while now. "Modern C++ Design" has been published in 2001.
But it didn't have functional lists until c++0x. 
Do you mean "head:tail"-style lists? It's perfectly possible to implement them in C++98. It's actually the most interesting chapter of "Modern C++ Design". 
He should have made the whole text blink, in order to render it even less readable.
TL;DR?
[This](http://readable.tastefulwords.com/) helped quite a bit. (:
[This](http://readable.tastefulwords.com/) helped quite a bit. (:
TL;DR: * Author only discusses MS Visual Studio 2010 compiler. * There are different ways to implement try/catch in a compiler. * A 32 bit binary uses a method that is very fast. * A 64 bit binary uses a method that is almost instantaneous BUT catching an exception is slower than the 32 bit method. So make exceptions exceptional. * If you use the "Full Program Optimization" compiler setting, try/catch blocks can be outright removed by the compiler if it's determined that they will never be used. 
Yes, you can do head:tail lists in C++98, by using recursive templates. But it is ugly. Variadic template lists seem much closer syntaxwise to functional lists. You can even name the first parameter 'h' and the second one '...t'.
I would have like to have seen him change the declaration of the function to __declspec(noinline) void DoOther() throw(...) to see if that changed the compiler optimization.
I like the general idea (omg exceptions slow, isnt funny anymore), but nobody serious gives a fuck about synthetic 'benchmarks' that operate on 3 functions with exception handling put somewhere in them (plus there are no objects that actually care about exceptions being thrown ...). Say what you will but there is a penalty, at least for EH not based on so called 'zero cost exceptions'. The thing almost everybody misses is that you need to compare to something with equivalent feature-set, but writing moderately big program with exception handling once and another time with say, errors passed as return value with crapload of 'if' checking these values and acting accordingly isn't the definition of 'fun' it seems, so meaningful benchmarks are just unavailable. In all, pretty bad read. Also, form the quality of the page, i infer that author have _at least_ some academic background (for some reason, these pages always look like shit).
throw(...) is assumed if no specification is present.
&gt;The bottom line is that if you want to understand how your application performs, you had better use a performance measurement tool, or do your own performance measurement... There's a bunch of other bullshit in there, mostly the author gloating about how great he is and contradicting himself. Did you know he implemented the World's Fastest (Greatest) Memory Allocator, based upon a design done by someone else?
&gt;Also, form the quality of the page, i infer that author have at least some academic background (for some reason, these pages always look like shit). Yep. &gt;Dr. Newcomer received his Ph.D. in Computer Science from Carnegie-Mellon University, and spent several years on the CMU CS faculty. He was a founding scientist of the Software Engineering Institute (SEI) at CMU. He has nearly 47 years of experience in developing commercial, industrial, and research applications.
a: good points, I still tend to optimize like its 1975 myself, (6502 is a hell of a drug), and considering modern SLA techniques, should just get over it and write cleaner code. 2: In the embedded space, exceptions still suck. Not for the obvious reasons, but because they can cause a stack inversion in badly written code, where some handlers have to be present for any unhandled exceptions, for all higher stack frames, so deep call trees cost you in binary size. That being said, the cost/benefit ratio as things scale up on modern hardware, mean higher level languages like java actually become efficient again.
and so it is, perhaps just adding a throw inside the function would have been the ideal test.
Thank you kind sir! The only thing missing, is a way to toggle between versions of the page while on it, scrolled down!
The bit about sampling based profiling is just silly. Any sampling based profiler worth its salt doesn't just look at where you are, but the full call stack to see how you got there. That way you can identify that the damn thing is calling the allocator continuously. Also, I have yet to meet someone who advocates sampling based profiling who doesn't combine it with counters anyway... the idea of doing only one seems really odd.
I just run my shit through gperf and check to make sure that my program isn't spending 70% of its time in one function. And honestly, the best advice on exception performance I've ever heard was from that "Exception-Safe Coding" video that got posted a while back - he notes that just wrapping your code in try/catch won't make it run any slower, and that if an exception *does* get thrown, you shouldn't really be giving a crap about performance, because, you know, it's an exceptional situation.
Well if valgrind is reporting memcpy is being called, memcpy is being called. How could it report something that wasnt called? The rest of the stack seems fine. On line 561, memmove is being called. GCC optimizes memmove to memcpy when it can prove the source and dest do not overlap. In this case, it could be a bug in GCC or valgrind. Googling for *memmove optimizes to memcpy* returns some bug reports. Maybe that is the issue here. Or else gcc is optimizing correctly and valgrind does not understand this.
Or for more fun (c++98 or whatever) #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; numbers; int xx; while (cin &gt;&gt; xx) { numbers.push_back(xx); } std::sort(numbers.begin(), numbers.end()); std::copy(numbers.begin(), numbers.end(), std::ostream_iterator&lt;int&gt;("\n", std::cout)); return 0; }
&gt; i = strlen( str ); &gt; if( str[i-1] != '.' &amp;&amp; str[i-1] != '!' &amp;&amp; str[i-1] != '?' ) Aside from the few other problems, this one is particularly bad: if "str" is zero-length, this uses an invalid array index.
Well, they do overlap here. I did some more digging today and came up with [this bug report](https://bugs.kde.org/show_bug.cgi?id=278502) (which appears to be in some way isomorphic to [this one](https://bugs.kde.org/show_bug.cgi?id=275284)), that would explain the behaviour.
Ah so gcc is using a function *named* memcpy to do a memmove. That makes sense then - there would have been a world more hurt had this been an actual gcc bug!
Damn, that is a *killer* question. I consider myself decent with c++, and that would probably stop me in my tracks. Out of curiosity, what is the answer?
http://en.cppreference.com/w/Cppreference:Archives This is a wiki, and has an offline file.
You can download drafts of the ISO standards in pdf format [from their site.](http://www.open-std.org/jtc1/sc22/wg21/) These aren't the official standards as those require payment, but they're probably pretty close. 
Well I am not perfect, self learning is a bitch eh? But in its use I always know it will always have 1 character in it just not from with in the function.
You can download GCC/libstdc++ docs from [their website](http://gcc.gnu.org/onlinedocs/). MSDN library is also downloadable. 
I used wget to recursively fetch [this reference](http://www.cplusplus.com/reference/), works for me.
Happy Reddit birthday! I would argue for cppreference as they seem to be more up to date owing to their wiki nature.
The final draft of the c++0x standard was temporarily available there as well, and is/should-be identical to the finished standard. You can still find public copies of it -- look for n3290.pdf.
Yup I much prefer to see the std::ostream_iterator than an for loop even if it is a range based for loop.
Implement shared_ptr. &lt;-- not a good phone interview question. ;-) Example template: * Soft introductory get the person comfortable question. * Technical questions * Programming examples * Puzzles * HR-y style questions (what would you do if someone told you to implement a design you disagreed with? *Well, I'd walked out in disgust!?*; *I'd tell them they were an idiot!*, etc.)
Also the final published version of "iso 14882:2011" (C++11) is on Pirate Bay if your happy enough ignoring copyright laws. With that said the standards aren't the best reference. You could always look at picking up a dead tree book if that is offline enough for you. There is the "STL Pocket Reference" and "C++ Pocket Reference" books. Not sure how good they are though.
In my opinion that is an awful question: ask them about the _interface_ to std::map and how to accomplish common/uncommon tasks not implementation defined details. Although the performance requirements on std::map almost necessitate using an underlying balanced binary tree I'd rather know that they understand, for instance, why the erase method does not return an iterator, when to use insert vice operator[], etc., then to know that they're run gdb on a core dump and seen _Rb_tree.
Thanks! The URL, by the way, is http://exceptionsafecode.com ;) 
I didn't realize the 6502 went back to '75. I remember that was the CPU in my C64 but I had that around '84 I think. Edit: According to the 6502 wiki, the C64 had the 6510 processor and the C64 disk drive had a 6502 processor.
One possible way to coordinate being the use of a semaphore?
Yes, a semaphore would solve that problem. But it would be better to get rid of global variables and use dynamically allocated memory in the functions.
Is allocated memory stored in the thread control block or process control block?
The thread control block mainly stores where every thread has it's own stack. Dynamically allocated memory is located on the (shared) heap. All threads can access the same memory, but since every thread executes the function and therefore allocates "his own" memory, they operate on completely different memory regions. To get multi-threaded right, you just have to ensure, that threads never write to the same location or read a location during a write of another thread. So, let every thread operate on it's own memory and guard every operation on shared memory by OS supplied mechanisms like semaphores.
&gt; but since every thread executes the function and therefore allocates "his own" memory, they operate on completely different memory regions. That's the part I was unclear on. Thank you.
Things have changed a bit since then, but not necessarily in favor of virtual functions. - virtual calls involve access to possibly distant memory locations, increasing the chance of a cache miss, also known as "brick wall". - virtual function calls usually prevent optimizations to propagate. With global applicaiton knowledge, the optimizer has some options (switch on the possible types, rather than jump to memory location), but AFAIK this is rarely, if at all, implemented Still, most of the time, the cost doesn't matter, overall performance has gone up.
"Ok – this probably deserved it’s own post". Fail.
&gt;Yes, a semaphore would solve that problem. How? Putting a mutex anywhere in the shown code wouldnt do much. All clients need mutual exclusion on usage of function _and_ its return value. But yeah, proper solution wouldnt involve any locking, just making it take additional parameter for output buffer or allocating it on its own or probably mutating input string.
The python min function can handle comparing two different types, eg comparing the integer `3` with the double `4.2`. A min template function written with only one type param would not be able to handle that. Also, the return type needs to be known. Eg for an `int` and `double`, the return type should be `double`. That is what the `common_trait` class is for, given two types it will get the type that either can be converted to. 
y u no put spaces between your operators? -.-
Semaphores only in the shown code wouldn't solve the problem, right. Thanks for pointing that out. I didn't look at the code again, I just answered that question on a generic level. Multi-thread coordination for shared memory access using semaphores -&gt; Yes. In this case, a solution using semaphores would involve the caller, who would have to wrap the function call and final extraction of the result to somewhere else with a semaphore which is, admittedly, very awkward and really horrible style.
The C++ code looks amateurish at best, with inconsistent indentation, no headers documentation, functions implemented in the .h file for no real reason, no usage of initialization lists, brute-force coding like: if (proc=="quote"){return ((proc+" - not yet implemented!"));} else if(proc=="if"){return ((proc+" - not yet implemented!"));} else if(proc=="define"){return ((proc+" - not yet implemented!"));} else if(proc=="set!"){return ((proc+" - not yet implemented!"));} else if(proc=="if"){return ((proc+" - not yet implemented!"));} else if(proc=="lambda"){return ((proc+" - not yet implemented!"));} else if(proc=="begin"){return ((proc+" - not yet implemented!"));} I suppose it's not the author's main language -- it's a cool attempt, but I'm sure he would benefit from reading good C++ code and taking inspiration from it.
I've been (very occasionally and slowly) been working on a similar thing.. https://github.com/johnfredcee/lispp ..ultimately I want it to be embedabble in C++ games..
As a beginner in C++ myself I wonder: do you have any suggestions in that regard?
For a large code base it is a bad idea to keep a class declaration and the actual implementation in the header file. But when you have a 3-4 lines function there is no actual gain from splitting this in two files. I suppose it is a question of personal preference. The documentation is missing simply because this is a work in progress. The brute force code it is actually a dummy code that will be replaced in the next version of the code by an actual implementation. 
Try to use a very small screen, like a 13" Mac BookPro and keep two files open in vim with the screen splitted vertically ... You usually want to be able to see as much code as possible without scrolling or wrapping your lines.
Is there somewhere a written presentation with the main points of the video? it's very exhausting and time consuming to have to watch these long videos in order to get a few pages of information out. 
There is no standardized way to structure your C++ code, you could use the C++ Style Guide from Google: http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml 
Good to know!
Someone, somewhere is probably writing such code right now ;)
Interesting, *waits for homebrew to update*.
Ah, locale is in! Sweet.
About Microsoft: just look at the [GetMessage function](http://msdn.microsoft.com/en-us/library/windows/desktop/ms644936%28v=vs.85%29.aspx). &gt; Return value &gt;Type: BOOL &gt;If the function retrieves a message other than WM_QUIT, the return value is nonzero. &gt;If the function retrieves the WM_QUIT message, the return value is zero. &gt;If there is an error, the return value is -1. Yep, BOOL is an integer type (32 bits I suppose), not a boolean type. Compared to that, `#define TRUE '/'/'/'` seems perfectly fine to me.
You need to pass a third parameter to calcWeightLoss by reference (with the '&amp;' operator). Then, any changes to that parameter inside the call is reflected outside the scope of the function itself. **EDIT:** I didn't read your code completely, so I missed that you needed the first two parameters to remain the same.
Why not be a good samaritan and do it yourself?
Could someone put that in the sidebar, as there's nothing that suggests that. ('Discussion' could mean asking for help)
double weightLoss = 0.0; calcWeightLoss(weightBefore, weightAfter, weightLoss); ... void calcWeightLoss(double wBefore, double wAfter, double&amp; wLoss) { wLoss = wBefore - wAfter; }
Me too!
I am an electrical engineering student with five tests in the next two weeks.
Doesn't that mean you're looking for distractions? I mean, you're on reddit after all.
Thanks soo much...dont know how i didn't think of that.
#include &lt;iostream&gt; using namespace std; void calcWeightLoss(double, double, double&amp;); //NEW PARAM is a reference to a double. int main( ) { double weightBefore = 3.0; double weightAfter = 2.0; double weightLoss = 0.0; cout &lt;&lt; “Enter weight before training: “; cin &gt;&gt; weightBefore; cout &lt;&lt; “Enter weight after training: “; cin &gt;&gt; weightAfter; weightLoss = calcWeightLoss(weightBefore, weightAfter, weightLoss); // last argument gets _address_ of weight loss, not a copy of the value. cout &lt;&lt;"Weight loss: " &lt;&lt; weightLoss &lt;&lt; endl; //address passed in to function got changed. //system("pause"); return 0; } void calcWeightLoss(double wBefore, double wAfter, double&amp; weightLoss) { weightLoss = wBefore - wAfter; //set the parameter to a new value } I'm a noob myself, but something like that.
1. A virtual destructor isn't important for anyone who wants to build a subclass. If your base class constructor isn't virtual, their destructor won't run, leaving you with partially destructed objects. 2. Private inheritence means the only way to call base class members is from within the subclass itself. 3. Override the operator=() member function so that construction of the form x = new blah explodes? 4. std::dictionary, keyed on word with a value which is a count of each word seen. e.g. `std::dictionary&lt;&lt;string&gt;,&lt;int&gt; &gt; wordCounter;` ?? 5. When something a class uses explicit in it's constructor to prevent accidental implicit conversion? Template Metaprogramming? 6. RAII is a pattern for resource managing classes. In a nutshell, with a file, or with memory, you aquire the resource in an objects constructor and release it in the destructor. The pattern uses the benefit that destructors always run on objects declared on the stack, even if an exception is thrown between object creation and intended deletion of the object. So it's a pattern to maximise safety of resource holding.
What about overriding `operator=()` to prevent assignment of the newly constructed object or making that private?
Assume an empty class, what functions does it have? None. However if something tried to instantiate the object like this: `EmptyClass em();` the compiler would automatically generate a default constructor and destructor, both empty. Also, `EmptyClass em2 = em1;` or `EmptyClass(em2)` would cause the compiler to automatically generate a copy constructor and an assignment operator functions, both default (which is a shallow copy).
I get a compile error using it on gcc 4.6 with C++0x enabled on Ubuntu 11.10. lexical_cast seems to require boost.math.changesign, but boost.math.changesign doesn't seem to be available or properly included. Meh, I should probably stop using lexical_cast anyways, was never really a fan of it. Edit: I seem to be getting a whole lot of compiler errors with other stuff too, like ASIO and some other libraries that worked fine with 1.47.0. Oh well, I guess I'll be reverting back.
Sure: const std::string undefined[] = {"quote","if","define","set!","lambda","begin"}; for (int i = 0; i &lt; sizeof(undefined) / sizeof(undefined[0]); ++i) if (undefined[i] == proc) return proc + " - not yet implemented!"; Or using `algorithm`: const std::string undefined[] = {"quote", "if","define","set!","lambda","begin"}; if (std::count(undefined, undefined + sizeof(undefined) / sizeof(undefined[0]), proc) &gt; 0) return proc + " - not yet implemented!"; (Incidentally, "if" was listed twice, and there's no need for two layers of extra parentheses in the `return`)
I love Boost, it has great code in it, but they really do they make it hard to actually use in any moderately complex build system. If you don't use Visual Studio or Boost.Build or CMake you have an awful lot of work to do to get it to link reliably. I really don't get why there isn't better autotools support for it, the bug thread for pkg-config support is basically just "we can't decide how to name things so we haven't done this." Which is depressingly fail. 
I was thinking of "good C++ code [to take] inspiration from", but thanks ;)
I am a [library](http://codesynthesis.com/products/odb/) author. The problem with your request is that warnings "up there" (i.e., higher levels) are at best questionable and at worst utter nonsense. Such warnings can usually be fixed either by uglifying the source code (adding extra casts, unnecessary calls, etc) or by suppressing such warnings if the compiler supports this. Sometimes, however, it is simply impossible to get rid of a warning. The now famous example of this case is the "base class should be explicitly initialized in the copy constructor" warning in GCC: struct base { base (); base (const base&amp;); }; struct derived: base { derived (const derived&amp;) { } }; g++ -W -c test.cxx test.cxx: In copy constructor ‘derived::derived(const derived&amp;)’: test.cxx:9:3: warning: base class ‘struct base’ should be initialized in the copy constructor [-Wextra] While in this case it is easy to suppress by adding an explicit default constructor call, there are cases where this is not possible (for details see the [bug report](http://gcc.gnu.org/bugzilla/show_bug.cgi?id=11159) for this warning). There is also no mechanism in GCC prior to 4.6 to selectively suppress this warning.
Well, if you had used all those warning options, wouldn't you have seen the error too? By this I'm not saying the vendors are not at fault, but if you're trying to change what others do, you're in a losing game. Try to fix others' errors by yourself. That's all you can do really.
"Cases where this is not possible" are no excuse for not going as far as possible. Yes, a warning-free compile involves extra cost - but that's the difference between code that works and a real library. The point is not to silence the compiler, but to consider why this warning occurs, when it would be a problem and how to deal with that problem. &gt; Example: silencing warnings about potentially lossy assignments with a dumb cast because "they are no problem on this platform" is worse than leaving them in. Promote the warning to an error if the conversion is lossy, and prevent the warning when it's not. Yes, this is hard. No, my own code doesn't always meet these criteria. Attention to those details is one of the reasons we use libraries rather than slapping code together on our own.
I completely agree, I accept that there is some scope for some warnings at high warning levels, (like not initalizing bases, that only contain meta data, like some which are defined in the boost libraries). But for the most part, if something needs to be cast properly, and initialized in a certain order. Just do it. This is double try if it is template library and I can't compile with Werror. That is just frustrating. Finally I would go further to my biggest hate, it is not okay for a library to leave data on the heap after execution, even if it is just a 'singleton' (ie not an expanding leak). seriously just but all that junk in a smart pointer.
I cannot upvote this enough...
No, because if the library headers don't compile with warnings on then you have to either turn them off or be diligent about ignoring the right ones, which could cause you to miss warnings about your own code.
I'd say warnings are not too bad when you're compiling the library itself. Sqlite, for example, is uncompilable (gcc4 on x64) unless you disable all warnings, but since my own code is not involved, it's OK to disable the warnings. OTOH, warnings in the headers are definitely not acceptable. If you have warnings in headers, that means I will miss bad bugs in my own code -- either because I've had to disable warning output, or because the warnings in my code are lost in a sea of warnings I can't do shit about. I know it's not easy, and may complicate the code. However, it's better to have a library I can't read than a library I can't use.
I don't quite follow. What about it?
shared_ptr p(new Omega()); Don't need an "=".
Shadowing "aux" is uncool, too.
This should be request for compiler vendors: Allow to ignore warnings based on path from which it originates (yeah, its probably not a perfect solution). Really. I don't need to see that there is a signed/unsigned mismatch in library thats universally used and tested far better then my own code. 
Another [library](http://utfcpp.sourceforge.net/) author. I have only a limited number of compilers at my disposal, and for them I will get rid of all warnings. If you get a warning from my library when compiling it with IBM XL C/C++ on AIX, I am sorry but I can't help you.
The problem with treating warnings as errors is that warnings are NOT errors. Warnings are warnings, heuristics designed to make you aware that something you are doing may, or may not. Cause you problems in some (but not all) instances. They are added at the whim of the compiler vendors and are not specified in the language specification. What you are asking library writers to do is actually impossible, the list of possible warnings generated by compiling an otherwise legal program is unknowable.
While we're at it, please run your library's tests under `Electric Fence`, `valgrind` or equivalent.
or www.vim.org. You can use it on any platform.
That's all very well until you encounter a compiler that issues warnings for f(g(), h()) having undefined evaluation order...
 * quote: *"Cases where this is not possible" are no excuse for not going as far as possible.* * Does your compiler guarantee evaluation order for this?
Oh :) Good question. Personally I learned a lot from blog posts here and there, or even learning unusual languages like Haskell (really -- it makes you think differently and write better code, even in C++)... but I found the Qt library to be very inspiring as an example of good architecture and solid code. I really liked [this paper](http://www4.in.tum.de/~blanchet/api-design.pdf).
You can get rid of the first loop and temporary too: int main() { std::vector&lt;int&gt; numbers; std::copy(std::istream_iterator&lt;int&gt;(std::cin), std::istream_iterator&lt;int&gt;(), std::back_inserter(numbers)); std::sort(numbers.begin(), numbers.end()); std::copy(numbers.begin(), numbers.end(), std::ostream_iterator&lt;int&gt;("\n", std::cout)); return 0; } The first `copy` stops on any input that isn't a valid `int` or whitespace. Although this is IMO veering away from readability (adding `using` statements helps), and you lose a ton of control over handling the input. 
&gt; Still, most of the time, the cost doesn't matter, overall performance has gone up. That's why I always use Python running on an embedded JVM inside an emulator written in Javascript.
Yes! And if you can't get rid of all the valgrind / etc. messages for whatever reasons at least supply your users with some suppression rules
&gt; What say you /r/cpp? Would you use this trick yourselves? No. I would consider "out &lt; bin" to be a comparison (after all these years I think the interpretation is hard-coded in my prefrontal cortex), and I would have to be really careful when reading the code. Considering the potential for confusion on this, I would really hesitate to show code like this to my colleagues as well. If I needed to input/output binary very frequently, I would check on the implementation of std::hex and do something similar, so that I would have: std::ostringstream message; int i = 10; message &lt;&lt; std::hex &lt;&lt; i &lt;&lt; ";" &lt;&lt; my_io::bin &lt;&lt; i; // message should now contain "a;1010" If the current implementation of std::basic_???_stream doesn't support such extensibility (though as far as I know it should, through the use of [xalloc](http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.2/classstd_1_1ios__base.html#3faeb4739cfe621262ceef0aad98f0ea), iword and pword), I would create an ostream wrapper (templated for char type, traits and what-not) for this, along with the bin stream modifier, so that you could do: my_io::wrapped&lt;std::ostringstream&gt; message; int i = 10; message &lt;&lt; std::hex &lt;&lt; i &lt;&lt; ";" &lt;&lt; my_io::bin &lt;&lt; i; // message should now contain "a;1010".
One way to get rid of third-party library warnings is to use `-isystem` instead `-I` to specify its include paths. This way the library will be considered a system library and no warnings will be generated. (I have used this on one occasion to silence warnings about C-style casts in boost.)
I didn't believe you until I clicked the link and arrived on [CodeSynthesis](http://codesynthesis.com). I've dabbled with CodeSynthesis XSD in the past and I think it's really nice product with a high-quality codebase.
I wouldn't really recommend any books. The only C++ book I have is an old one that was given to me by a Business teacher in high school, and it helped me understand pointers, but that's all it really did. I learned everything else from the internet. C++ also wasn't my first language, I started with VB, then some HTML, then C#, Javascript, and PHP. Now I'm on to C/C++, and with experience in C#, it wasn't a huge transition. If you want to learn C++, I recommend doing some internet research. First you will want to understand HOW a computer works, this will be very helpful in writing effective code. Then you will want to learn to think logically in all aspects. Then you can learn how to write code. When I say "think logically" I don't mean "Someone hit me, therefore they must not like me," I mean that you need to be able to look at a statement like "This is not not a bad sentence" and conclude that it IS a bad sentence based on the canceling "not"s. Edit: I realized that someone may take the first sentence the wrong way. I'm not recommending AGAINST books, I just don't have any books to recommend. Books are great, reliable sources of information, but the internet has a lot of good stuff as well.
1. [The C programming language](http://cm.bell-labs.com/cm/cs/cbook/) (Kernighan &amp; Ritchie) 2. [The C++ programming language](http://www2.research.att.com/~bs/3rd.html) (Stroustrup) Those are the bibles.
There are a ton of books on C++. Most of them are probably pretty good. There are also a ton of good resources online. Here's what I can recommend: most books on c++ or any programming languages for that matter read the same way. They're divided into sections or chapters explaining a certain aspect of the language. They then go deeper and deeper into depth about that certain aspect. Far deeper than is relevant or useful than for someone with only a minor understanding of the language. The best way to read one of these books is to read through each chapter, and really only worry about getting a feel for the subject. "Peel the onlon" is a good way to think about it. Once you've gotten a feel for the language, you can review each chapter more in depth, and get a better understanding of the finer points that they explain. Make sure to try running your own code based on what you are learning. When it comes to programming, you really learn the best by doing, making mistakes, and correcting those mistakes.
What do you mean by complete beginner? Complete beginner to C++, but with background in Python or Java, or complete beginner to programming in general?
High quality C++ books: http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list 
Please dont learn C before C++. Like the saying goes. The worst person to learn C++ is a C programmer. Bad habits are hard to kill. I suggest Stroustrup's [new C++](http://www2.research.att.com/~bs/programming.html) book for beginners. It teaches C++ the right way. STL first and a bit of C last. 
I wish they supported Visual C++ 11 Developer Preview. I have tried and failed to hack the build files myself, I know it can be done though as people have done it.
The original poster should read this list. An excellent find. For the beginner I have a preference for Accelerated C++ myself. However &lt;&lt;&lt; this is big, many of these books will quickly become outdated with the arrival of the new C++ standard. So I would not invest in the reference class books right now. Further I'd keep an open mind when using the books recommended for beginners. What is considered good code will likely shift a bit from what is acceptable today. Obviously one needs to know the older techniques so you do need to understand C++ in the current context. So I'm not saying don't use the current texts, just understand that things are changing. 
agreed read The C++ programming Language then read the K&amp;R book because it is a classic and perfect example of how to write a programming book. And also elegant C code.
The C++ programming language by Stroustrup is excellent.
&gt; [do] some internet research I think that's very difficult when you don't know a subject. Where should s/he begin? Some links are always helpful, and this resource always looked reasonable to me: http://www.doc.ic.ac.uk/~wjk/C++Intro/ I'd add (I personally think) that it's important to learn in a non-Windows environment (eg. Ubuntu running in a VM). Every time I see system("pause"); a little bit of my heart dies, and bad(|terrible) habits are easy to pick up.
The C++Programming Language is not a beginner book IMO. 
Going through Accelerated C++ right now although I'm a second year CS undergrad, only on the third chapter but should I be looking for a book which may target more experienced programmers? Enjoying the book so far.
It might be a good reference, but not really a book to learn the language.
&gt; Most of them are probably pretty good. Nope. Most of them are downright awful, written by C programmers who think they program in C++.
The one book that'll teach you C++ properly (despite being quite old) is Accelerated C++, by Koenig and Moo. Short, to the point, and it doesn't try to teach you C.
I'm don't really agree that AC++ is aimed at beginners (though it certainly can be used effectively by them). I think it is recommended so often because it proposes a really well structured, self reinforcing path through some of the most common idioms in C++, and does so in a concise manner. Experience levels will dictate how fast you move through the material, but it's all stuff you'll need to see sooner or later. tl;dr: r 
C++ Programming Language, a huge book that nobody except compiler designers need to read. Get a copy of C++ Primer.
Good enough book to learn the basics in a non-scary manner. But the exercises suck! The exercises do not re-enforce lessons learned. Try supplementing with Problem Solving with C++ by Walter Savitch if you google around you'll find PDF copies around.
Complete beginner in general. No background in coding whatsoever. 
Stroustrup hisself considered this very form originally but rejected it in favour of the shift operator forms we know and love, for precisely the excellent reasons given by other commenters. This is documented in one of his many writings on the early history of the language, sorry cannot provide citation.
Awesome, thanks. Going through it now. Came across a lot of links that gave a list of "recommended" books I guess, but I missed this one apparently. Thanks.
Yeah, I understand that C++ is constantly being updated so I have no real issue with being behind slightly. Just trying to get grips on the entire thing first before I worry with being up-to-date on it, if that's possible anyways.
&gt; The worst person to learn C++ is a C programmer. Meh, this is a rather empty statement. Also, I suggest a significant proportion of world's C++ experts learnt C first. :-P More like, the worst person to learn X is a person who mindlessly applies the principles they learnt from Y when using X. More useful advice is: Program idiomatically in the language you're using. A beginner programmer, like OP, could learn many valuable things from K&amp;R. Including why Stroustrup felt compelled to create C++ and gain insight into its idiosyncracies. ... also, it's beautifully short ... the book and the language.
I'd consider it a beginner's book: It's fun, after reading **Accelerated C++**, and **Exceptional C++** to go back through **Accelerated C++** again, and see which of the examples in the book are not exception safe, or would have problems in a multi-threaded environment.
I haven't found this in my experience, for the most part, most small things that make C++03 easier (like scoped_ptr and shared_ptr) are header only so there is no issue with linking, and the heavier libraries can be added like an other include (I am using just straight make files on Linux with gcc)
Don't start with C++, you only end up confused. Start with something simpler: C#, Java, Pascal... Once you get the hang on programing and feel comfortable then you can move to C++. It's a very powerful language but it will be too much for a beginner.
&gt; Don't start with C++, you only end up confused. . .it will be too much for a beginner I'd say that depends heavily on the person but agree, in general, it is easier to start with a higher level language. I happen to think starting with C++ is fine so long as the learner doesn't get completely caught up in the language itself and focuses on the concepts.
+1 for entertainment value.
I totally disagree. I started with C, switched to C++ without much ado. The concepts of basic programming are obvious in those languages. Variables, functions, control flow. And it's great to have an idea about what's going on under the hood (memory allocation, pointers, types).
I learned my C++ with Deitel &amp; Deitel 2nd Ed, not sure how it compares to other books, but it's what we used at my uni back when C++ just became an ISO standard. It seems quite comprehensive for the beginner.
I'm not sure what you disagree with. I started with C++ and agree with everything you said, none of which is incompatible with what I said before.
Yeah sorry, meant to reply one level up.
 const Item&amp; getItem(size_t index) const { return items[index]; } or const Item&amp; operator[](size_t index) const { return items[index]; }
They call them access methods, OP.
Thanks a lot, got it to work.
Note that this kind of access isn't threadsafe.
This is what I thought too. Is there a threadsafe way to do this or am I better off using thread locks?
The program is single threaded.
Yes, it currently is and probably will be but since this is just a practice project, I might as well try out some new things like making the class threadsafe.
I'm not sure what a thread lock is. In general, a threadsafe version of this method looks like (pseudocode) Item /* copy! */ getItem(size_t index) const { scoped_lock_class synchronization_object(member_mutex); return items.at(index); } but it changes the semantics, now returning items by value.
Thanks. The example you showed was pretty much what I meant with a thread lock. Guess it's the only way to do it then.
Sure. Good luck. For the record, I used a mutex and a scoped mutex lock idiom. Combining a mutex with a condition variable gives you what's known as a monitor. Helpful to use the correct terminology (in my experience).
Thanks. Still quite new to C++ so I'm not that familiar with the correct terminology yet.
\#define private public
This always comes up in many C++ discussions. It is simply not valid C++ to define a macro with the same name as a keyword.
&gt; It is simply not valid C++ to define a macro with the same name as a keyword. There's a decent discussion of this issue [here](http://stackoverflow.com/questions/2726204/c-preprocessor-define-ing-a-keyword-is-it-standards-conforming), but the short answer is that it's generally considered legal to use most reserved words as preprocessor tokens in this way, because "reserved words" aren't a concept that is defined until later stages of compilation. Generally, the preprocessor has very limited knowledge of C++. It mostly just substitutes text however you ask it to, provided you stick to the grammar governing the preprocessor directives themselves. Note that C++0x appears to perhaps tighten the restrictions down somewhat (at least there's a bit of confusion around it), but as of now, it seems to be legal to #define private public, and every compiler I've ever tried it on has accepted it (not that that makes it technically legal).
The short answer is actually that it's invalid C++. Yes I know there are a lot of people on the Internet who post that it's valid and may give some obscure or clever reasons as to why it's okay to redefine reserved words however the C++ standard makes it absolutely clear that it is undefined behavior as follows: 2. A translation unit shall not #define or #undef names lexically identical to keywords. It's probably one of the simplest and most straight forward sentences you'll find in what is otherwise a complex and mess of a standard. The list of keywords can be found in section 2 of the standard, and yes private, public and protected are listed.
If you're worrying about concurrency in C++, check out [this series](http://www.corensic.com/Learn/Resources/ConcurrencyTutorialPartOne.aspx), which provides an introduction using the new standard.
Also note that if there is only a single function or class that needs access to the internals of your class, you can use the "friend" declaration to give them access to it (and nobody else).
Are you asking why there's nothing like the gem command for C/C++? The reason is that the C/C++ environment is much harsher, with much more variation and diversity. With most scripting languages, pretty much all you have to do to install a module is put the source files in some directory. Maybe there is more if the module includes native extensions, but usually it's just a matter of unpacking files somewhere. C/C++ is much more involved. For one thing, there are numerous compilers and they all support different dialects/extensions and have different command line options. As a result, there are a variety of build systems -- a plain Makefile, a Visual Studio .dsp file, autoconf/automake/libtool, cmake, home grown scripts, etc. A given package can support one or more build methods at any time. There is no way to automate this. With scripting languages there is often just the one implementation, so you don't have to worry about supporting different vendors' options. Secondly, library dependencies are not explicit except when voluntary schemes like `pkg-config` are used. Sometimes dependencies are required, sometimes they are optional, i.e. the functionality will just be disabled if the library is not installed. There is no way to automate this in a general way, it really requires human intervention. Thirdly, with scripting languages you don't have to care about ABIs or library flavors. With C/C++ you have to ensure that everything you're combining into the final application was built in an ABI compatible way. For C++, different compilers are rarely compatible, so you need to know what compiler was used to build the libraries you're linking against. And some C++ compilers change their ABIs between versions, which means it's not enough that it was just the same compiler, now you have to ensure the same version. And likewise for 32 bit / 64 bit, and so on. Fourth, C/C++ code needs to be ported to different platforms. Linux/Windows/OS X provide wildly different native APIs, and the parts that do overlap are pretty minimal (i.e. ANSI C.) Even on platforms that are similar, such as different flavors of \*nix, there are vast differences of what APIs are available depending on software versions and what's installed. You rarely have to ask what platforms a scripting language module works with, unless it's something like bindings for one of those platform-specific APIs. No so with C/C++. Code that was only written for and tested with one platform needs to be ported to work on another, and that can be a non-trivial amount of work. In summary, one of the main reasons for using a scripting language in the first place is that it's a homogenous environment and it abstracts away a lot of this platform-dependent stuff. Installing modules is just unpacking files in the right place. Not so for C/C++, where there are many details and they all matter. 
This kind of stuff is welcomed over at [/r/reviewmycode](http://www.reddit.com/r/reviewmycode)!
I would make sure that you are getting taught properly, it is more than likely you are being taught C with classes or native Java. ensure that you are familiar with the STL, smart pointers, std algorithms, and some of boost. Read the FAQ, play around with templates.
http://projecteuler.net/
This is not very helpful. What you basically said is "learn a bunch of things and learn them properly". What the OP needs is an actual project, where he/she can build an actual program. I don't know what the OP's interests are, but here is something that I did early on in my programming career that I had fun with: build a very simple clone of the game Breakout (brick breaker, whatever you want to call it). It doesn't have to be fancy. Go search google for some beginners tutorials for getting started with libSDL, or OpenGL with GLUT. They should get you up and running with some boiler-plate code for creating a window on your screen, and accepting mouse or keyboard input. Next, draw some shapes on the screen. Learn how to use timers for animation, so you can make things move around on the screen. Next, think about how to detect when two shapes touch each other, so you can make the ball bounce away when it hits something. Keep going, you can make it as simple or as complicated as you want. In the process, you can use a lot of different tools/libraries if you want. Maybe you want your game's "levels" (basically just the data store of which bricks are on the screen and in which location) to be stored in a STL::vector or STL::list. Congrats, you're now becoming familiar with the STL. Want to start messing around with Boost? Maybe you have your game levels described in a text file, and you use Boost's file I/O and string parsing libraries to be able to read it and use it inside your game. If you want to start thinking about good object oriented design principles, there will also be some challenges for how to design the game logic, level descriptions, and display code, in a way that would be clean and allow for extensibility in the future. If this sounds like fun, feel free to PM me, and I can probably give you some more specifics and maybe even some example code to get started. I would recommend just picking a small project like this, go to town on it, and most importantly have fun! Don't be afraid of doing something "wrong", don't be afraid to make mistakes.
&gt;I am currently going to school for computer programming and am in a c++ class, also currently. It seems that not only are you in a class, but in a race condition as well, you should make sure you are acquiring locks properly. But as is mentioned, project euler is an excellent way to learn, as it provides little programming puzzles of gradually increasing difficulty. As you do the problems, try looking through tutorials for various language features and libraries and incorporating them into a solution. This is a good way to learn how some language features can be helpful and at other times be bad to use.
I always found that games make for fun learning projects. One of my favorite projects for beginners is to make a 2D (top down) maze style game using text to represent the map and the player. Print out a 20x20 (or whatever size floats your boat) grid of characters where '#' characters represent impassible walls, and spaces or '.' characters represent empty passable spaces. Draw the player in place of one of the passable characters as a + sign, or some other distinct character. Every time the player presses an arrow key, check and see if the adjacent grid square is a passable square. If so, update the player's position and reprint the 20x20 map with the + sign in the new position. What makes this project great is you can get more and more advanced with it as you progress: * Come up with an initial victory condition. Maybe if the player moves from a starting square to a ending square on the map, he wins * Maybe you can add some monsters (^ characters or something) which will kill the player if they land on the same square. Every time you reprint the map update the monster positions so that they try to move into the player's square. * If you want to get more advanced, build in a loop that will keep printing the map and let the monsters update position even if the player hasn't pressed a key * Maybe you want to add more levels so that when the player reaches the end point on the map, a new map loads * Maybe you want to make the map bigger than 20x20 characters, but you only want to display 20x20 characters of the map at a time and simply change what portion of the larger map is printed as the player moves around * Maybe you want the player to be able to shoot some kind of projectile (maybe a '@' character) at the monsters * And so on... The point is, the base concept is simple and you can grow on it and make it as complex as you want. The more you add, the more skills you will learn.
Project Euler is always recommended to beginners here, but I don't know if it's always a good place to start for people. Project Euler is just a bunch of math puzzles (some of them can even be solved with just pencil and paper). When you're done, you've figured out that the answer to the question is 473958, but you may or may not have actually learned anything about programming or software design principles in the process.
Find something that supports your other interests. You do have other interests right. For example if you go hiking, a database of interesting locations or if you are into astronomy a satellite tracker. It is far easier to keep after a personal project if you can involve things that are fun or relaxing to you. In this respect it is surprising how many of these projects end up working out really well as apps for portable devices. As a side note I have to agree with one of the other posters here make sure you are in a quality computer science course! To many programs teach a language, usually badly, instead of teaching the science. Realize though that comp Sci programs always start out right at the beginning assuming the student knows little. If you have prior knowledge the first quarters or so will be a snap. It has to be that way as each student comes with a different background. Volunteer work can be a good experience too. You may not have the skill sets yet for that, but almost any knowledge can be put to use. In any event it is a good way to network with people trying to do positive things in the community. Usually these people are in a position of influence which can be useful in your career later down the road. 
He is a beginner, so I figured that getting him interested in the puzzle aspect of it isn't a bad way to get familiar with the components of c++. I honestly don't know what the right way to teach is though, it seems that most people have something they want to make, a game for example, that they aim for.
Why didn't you make it a class? Seems like an obvious thing to do in both C++ and python. I don't think everything always needs to be a class, but I think it would be clearer than using all those global variables in this case.
What's the difference? There's nothing else in the file than the solver, so making the whole thing a class would be like packing a box in another box. Also, there's no actual class operations involved, such as inheritance or polymorphism.
What's the problem?
I disagree, starting down a project path with a bad style can mean that you are not only drumming a the wrong technique, but also starting something which you will have to continue with. Furthermore C++ is not the kind of language in which get pushed into doing the right way the more you do it. More often then not you become good at a bad style. For example there are more than a few libraries written in Java like C++. It is worth learning the correct modern C++ idioms and design philosophy before making any large (&gt;1 week) projects. once you have the basics down, (iterators, streams, std::containers, std::algorithms) then you can start on larger projects which will perfect your technique.
This makes my brain vomit... :P
You should try to learn proper C++ first. Your code looks like a C code, not a C++ one
Well how about a struct then (even though these are functionally the same thing in C++)? You'd make it a struct or a class because it's a set of data that you're doing operations on. It may be a box within a box, but that's fine, it's just for organization. It's the same reason you made square_logic a function even though it's only called in one place. Looking more closely at the code, I think it's not bad, especially if you're just learning C++. Some more, minor tips: * Use bool for booleans * Use std::pair or pass by reference to return two values from a function * I may be misunderstanding the algorithm, but I don't know why you only check_obvious at the beginning rather than inside the main loop. Placement of some numbers may make others "obvious". * I'm not clear exactly how you're implementing the backtracking, but I think a std::stack would be a more intuitive data structure for this purpose than the static array + index you're using.
&gt;Use bool for booleans The arrays containing booleans are *bool*, so is the variable *blocked*. What'd I miss? &gt;Use std::pair or pass by reference to return two values from a function Oh, okay. Didn't find a replacement for tuples at the time. &gt;I may be misunderstanding the algorithm, but I don't know why you only check_obvious at the beginning rather than inside the main loop. Placement of some numbers may make others "obvious". It is already inside the main loop, and I'm already checking it several times (namely, until there are no obvious tiles). while(check_obvious()&gt;0) { cout&lt;&lt;"found placements with no choice"&lt;&lt;'\n'; } It's probably not very C++ to execute a function as the condition for a loop, so I guess that's what's confusing you. &gt;I'm not clear exactly how you're implementing the backtracking, but I think a std::stack would be a more intuitive data structure for this purpose than the static array + index you're using. Will do. Right now I'm just saving sequences of number/y-offset/x-offset in *storage*, then hopping back and forth by 3, depending on whether I'm reading from or writing to it.
Not compact, not elegant, and it doesn't even work properly.
You should post a (presumably) compact elegant python version and see if someone can match it.
&gt; The arrays containing booleans are bool, so is the variable blocked. What'd I miss? Sorry, I should have said that. The return type on a few functions could be bool: check_square, check_fill, check_neighbors.... &gt; It is already inside the main loop, and I'm already checking it several times (namely, until there are no obvious tiles). Right, but why stop there? As I understand it, square_logic also fills in spaces. After filling in a space, another space that was previously un-obvious can become obvious. I was thinking something like this: while(!check_fill()) { while(check_obvious()&gt;0) { cout&lt;&lt;"found placements with no choice"&lt;&lt;'\n'; } square_logic(); } It's perfectly fine to use a function in a while condition. Don't change that. The thing that's typically given as advice is that functions should _return a value_ or _cause a side effect_ but not both. You've got a number of functions that cause a side effect and return a bool saying whether they succeeded, and that's a fairly common and reasonable exception to this rule of thumb. But things are generally a little more intuitive when you do one or the other with a single function.
&gt;Sorry, I should have said that. The return type on a few functions could be bool: check_square, check_fill, check_neighbors.... Ah, right. I should've figured that out since I'm already using functions like booleans, for example in while(!check_fill()) { square_logic(); } &gt;As I understand it, square_logic also fills in spaces. After filling in a space, another space that was previously un-obvious can become obvious. That's embarrassing, seems like I only thought it half-way through. That change makes it a bit more efficient, but it still can't find a complete solution for the example board. Nevertheless, I'm not touching this program again. 
I just don't want the OP to be discouraged by posts like this. Do you have any specific advice? You talk about not going starting down a long project path with "bad style". Can you help explain to the OP what you mean by bad versus good style in C++? Don't discourage the OP by getting him into a confusing "chicken and egg" problem, where he's hesitant to start a project because he doesn't want to write bad code, but he doesn't know how to write "good" code because he hasn't worked on very many programming projects.
Here's mine, which I just wrote to test my Algorithm X implementation: def algox(subsets, items = None): if items is None: items = set().union(*subsets) x = min(items, key = lambda z: sum(z in s for s in subsets)) for s0 in subsets: if x not in s0: continue nitems = items - set(s0) if not nitems: return (s0,) nsubsets = tuple(s for s in subsets if set(s0).isdisjoint(s)) a = algox(nsubsets, nitems) if a: return (s0,) + a return None grid0 = "..91....4.3.9..7......4.....64....3.3..576..1.8....59.....6......7..2.4.6....19.." print grid0 sq = {} # Dictionary of all possible squares and their corresponding constraints rcs = list((r, c, str(s)) for c in range(9) for r in range(9) for s in range(1,10)) sq = dict(((r, c, s), ((0, r, c), (1, r, s), (2, c, s), (3, r/3, c/3, s))) for r, c, s in rcs) # Remove squares that conflict with the squares on the given grid takens = [(r,c,s) for (r,c,s) in sq if grid0[9*r+c] == s] tcons = set(sum((sq[t] for t in takens), ())) sq = dict((s, cons) for s, cons in sq.iteritems() if tcons.isdisjoint(cons)) a = algox(sq.values()) # Solve grid = list(grid0) for (r, c, s), cons in sq.iteritems(): if cons in a: grid[9*r + c] = s print "".join(grid) 
Sorry, you suck at C++ and that's evidence of what?
Like you said a struct is a class they're essentially the same thing. Box within a box I agree (within the simple confines of this example). This isn't why he didn't finish it. The reasons you give I don't think are the reasons he didn't finish it. Does the OP even know why he didn't finish it? 
So is this a GCC extension? Or a part of C++x11 that is being implemented/supported in GCC 4.7?
So how would it look like when written in proper C++? 
You'll really have to clarify your question but it sounds like you need to use nested functions and recursion, perhaps adjusting the logic so that a condition is set in order to return the boolean at the desired time. But I'm not really sure what you are asking.
Can add bonus file IO learning by creating the maps in text files and then reading them in when loading too.
I just reread what i wrote and i understand your confusion haha. Well the first function was given to us. User inputs two numbers and after all the cout n cin's, the end is return boolfunct=mysecondfunction. So that jumps to the next function. Im supposed to check if the function is valid using a boolean then return that to the first function. (Not main) to return the boolean expression from the first function to main. Thats the part i dont understand. In my second function, i have an if statement and it returns true or false to the first function but i dont see how i can return that boolean to main from there...
He might also be looking for coroutines. There are two ways I want to answer this: * C++ doesn't really have the features you want it to have in order to implement the solution you would like to have. You're going to have to write it a different way. * explain why goto was considered harmful
When you call a function that returns a value, like "bar" in this example: void foo() { cout &lt;&lt; "before bar" &lt;&lt; endl; int a = bar(); cout &lt;&lt; "after bar" &lt;&lt; endl; } When bar() returns, control goes back to just after where it was called. So in this example, the code would print "before bar", then call bar(), then print "after bar". If this doesn't make sense, I suggest you read more about what happens when you call a function.
That makes sense. I see....... so the fact that my function is looping means im probably doing something else wrong....
This article seems very useful, particularly for someone like me who is moderately comfortable with C++98 and knows the general idea of the features in C++11. It'll take me a little while to get what's going on, but so far it's interesting.
Connection Tools allows you to create an application in a module-oriented way. The way to do this is by defining Modules using an easy XML format, and a Application that makes the Modules comunicate between each other. The Application is also defined in XML. Once you've defined those, two tools will generate C++ code that you can use to build the actual application. The generated code is non-intrusive, that is, you "use" the code, but you do not write over it. So this means no reverse engineering of any kind.
In your example if someone did return something=foo() at the end of the bar() function it wouldnt start at the beginin printing before bar? I know the point was the opposite but even though my functions looping, when i do cout's before and after my function, i cant read the afterparts meaning its starting at the beg of the function instead of where it left off Sorry for th dumb questions n thx for your help in advance
I am also fairly new to C++ and had to make up my own projects. I'm currently working on a blackjack program which has been both very fun and informative. 
Take a look at http://ryppl.org/ project which aims to solve similar similar goals
You need to understand the concept of the "call stack". Imagine your functions are each printed on its own sheet of paper. A program always picks out the sheet called "main" first, lays it on the desk, and starts reading. Whenever main calls another function, it is going to put one of those yellow stickies with an arrow on it pointing right at the place where the function was called so that it doesn't lose its place, it knows exactly where to return to when it is done with the other page. So if "foo" was called, the program picks up the sheet with foo on it, lays it on top of "main" and begins reading. If foo calls "bar", it does a new sticky arrow in foo, picks up page bar and starts reading. If "bar" calls "foo" again, what happens? It doesn't dig "foo" out of the pile! It prints out a brand new copy of the page. It is important to note that all of the local variables in each of the two "foo" pages are separate and can different values in them. myNumber in the bottom foo might be 3 but in the top foo it might be 5, It is like the values were written in pencil on the page. So if you have foo call bar, then bar call foo, then foo call bar, then bar call foo, and so on... what happens? Eventually the stack of paper reaches to the ceiling, and the person reading the program gives up and throws it all away. It is known as a "stack overflow". The proper way to take the top sheet of paper off and return to back where the sticky arrow was placed on the page below is with the "return" statement. You can return a value, so that where your function was called gets replaced with the value you return. Or some functions don't return values, they just do their thing and then finish with just plain "return". The program will end when main returns (or I should say "the bottom copy of main" just in case someone called main again, and put another copy of it on the stack) There are times when it makes sense for a function to keep calling itself. It has to have some sort of "do I call myself again, or am I done?" inside it to eventually stop stacking up copies of itself. 
thank you for that.
We'll have to be careful in implementing these concepts. This stuff lookslike a compiler nightmare. One big reason to toss c++ is compilation speed, I don't see how this is going to help.
I also highly recommend making games as a good way to learn!
You'll be fine. :) Modern compilers do fine with code like this (which isn't complicated at all, from a compiler's perspective, especially not compared to some of the gems you find in libraries like Boost).
I am just learning some of the power of C++, from somebody who hated C++ for a rather long time: The things I have started using in it are amazing. Compilation speed is not bad in any reasonable way, and certainly not a reason to throw it out. A good example of something you can do, and some of this works with C++98: Linear regression on stdin containing two numbers on the input representing each x and y. #include &lt;ostream&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;numeric&gt; #include &lt;iterator&gt; #include &lt;iomanip&gt; using namespace std; struct point { double x; double y; point() : x(0.0), y(0.0) {}; point(const double &amp;_x, const double &amp;_y) : x(_x), y(_y) {}}; istream&amp; operator &gt;&gt;(istream &amp;is, point&amp;obj) { is &gt;&gt; obj.x &gt;&gt; obj.y; return is; } ostream&amp; operator &lt;&lt;(ostream &amp;os, point&amp;obj) { os &lt;&lt; "(" &lt;&lt; obj.x &lt;&lt; ", " &lt;&lt; obj.y &lt;&lt; ")"; return os; } struct partial_sums { double x, y, x2, y2, xy; unsigned n; partial_sums() : x(0), y(0), x2(0), y2(0), xy(0), n(0) { } partial_sums(partial_sums &amp;&amp;a) = default; partial_sums(const partial_sums &amp;a) = default; partial_sums(partial_sums const&amp; a, point const&amp; p) : x(a.x+p.x), y(a.y+p.y), x2(a.x2 + pow(p.x, 2)), y2(a.y2 + pow(p.y, 2)), xy(a.xy+(p.x*p.y)), n(a.n+1) { } partial_sums&amp; operator =(const partial_sums&amp; a) = default; partial_sums&amp; operator =(partial_sums&amp;&amp;) = default; partial_sums operator+(const point &amp;b) const { return partial_sums(*this,b); } }; int main(int argc, char**argv) { partial_sums sum = accumulate( istream_iterator&lt;point&gt;(cin), istream_iterator&lt;point&gt;(), partial_sums() ); double r = (sum.n*sum.xy - sum.x*sum.y ) / sqrt( (sum.n*sum.x2 - pow(sum.x, 2)) * (sum.n*sum.y2 - pow(sum.y, 2))); double a = (sum.y*sum.x2 - sum.x * sum.xy) / (sum.n * sum.x2 - pow(sum.x, 2)); double b = (sum.n * sum.xy - sum.x*sum.y) / (sum.n * sum.x2 - pow(sum.x, 2)); cout &lt;&lt; "sum(x): " &lt;&lt; sum.x &lt;&lt; endl; cout &lt;&lt; "r = " &lt;&lt; r &lt;&lt; endl; cout &lt;&lt; "y' = " &lt;&lt; setprecision(4) &lt;&lt; a &lt;&lt; " + " &lt;&lt; setprecision(4) &lt;&lt; b &lt;&lt; "x" &lt;&lt; endl; } 
It seems that, while some of the new features can increase compile times (e.g. const expressions), they can also help optimize compile times. For instance, with proper variadic templates, we don't have to resort to template hacks that obfuscate the code and result in lots of extra template instantiations. And those same const expressions might be easier on the compiler than equivalent template meta-programming.
 return (boolfunct() == mysecondfunction());
WHITESPACE! USE IT! This kind of nonsense will make any C++ programmer want to vomit: &gt; if (free&lt;low_free&amp;&amp;free&gt;0){ ...as it looks too much to the eye like a template parameter. How can you even sleep at night writing something that horrid? 
Here is a recursive solution. Nice and neat. void hanoi(std::string start, std::string end, std::string extra, int height){ if(height &lt;= 0) return; //move everything except the bottom to the temp hanoi(start, extra, end, height - 1); //end is the extra, extra is the end std::cout &lt;&lt; "Move from " &lt;&lt; start &lt;&lt; " to " &lt;&lt; end &lt;&lt; std::endl; hanoi(extra, end, start, height - 1); //move everything from extra to the end return; } 
The mathematical abstraction is a graph. In practise: Write a class that represents a state of the game. An object of this state class will identify the node of the search graph. You may need to compare two state objects w.r.t. equivalence and/or ordering (for sets and maps). A generic graph search algorithm needs to know how many neighbours a node has and how to reach them. So, write functions which -- given a state object -- give you the number of possible moves and the resulting state objects. A* also needs a heuristic function that computes a lower bound on the "remaining cost" (number of moves). For this function you could simply count the number of tower tiles that are not yet in their final position. I think it's okay to treat the state class as a "value class". This should make programming easier. So, a state object would be just a copyable description of the graph's node rather than the node itself. But keep in mind to pass references to const whenever it makes sense to save unnecessary copying. Maybe you can even use the state class as a key type for a std::set, std::map or std::priority_queue within your A* implementation. 
I will be reading this article many times I suspect. Maybe it is the end of a 12 hour day but I had to stop alf way through. 
Transactional Memory is not part of C++11. It is a separate specification (which is still being worked on) that applies to C and C++. Though I believe there was a lot of "cross-pollination" between TM and C/C++ memory model and atomics.
The huge monolithic `eval`-function is imho quite ugly. I would refactor it into smaller functions, and maybe replace the large if-else structure with a jump table or similar construct.
Unless I'm missing something, isn't the convenience function for making std::tuple objects called std::make_tuple, and std::make_pair only makes std::pair objects?
Does anyone know if gcc 4.7 supports the variadic template version of user-defined literals?
[This page](http://gcc.gnu.org/projects/cxx0x.html) says it implements them without any caveats.
This is a pretty cool feature, especially combined with constexpr, which will allow most of these things to be computed at compile time. An error message like this could have saved NASA $200M: In statement 'mars_climate_orbiter.apply_thrust(100lbf);' error: no matching function for call to 'MarsClimateOrbiter::apply_thrust(FootPounds&amp;)' candidate is: void MarsClimateOrbiter::apply_thrust(const Newtons&amp;) 
I am the author of the article and I've corrected the silly error of having writting make_pair() at the start instead of make_tuple. (Sorry about that but thanks to those that pointed it out!) :-)
slightly more c++-y for you. uses recursion, and a class (woohoo classes). probably could be better though. note it doesn't have a validity checker for the input, so an impossible board will cause it to check all possible boards, taking a long time indeed. class Board { public: Board(std::string const &amp; start):m_Board(start) { assert(m_Board.size()==9*9); } void Solve() { Solve1(0); } void Display() { for(int i=0;i&lt;9;++i) { for(int j=0;j&lt;9;++j) { std::cout &lt;&lt; m_Board[i*9+j] &lt;&lt; ","; } std::cout &lt;&lt; "\n"; } std::cout &lt;&lt; "\n"; } private: int RCAt(int x, int y) { return m_Board[y*9+x]-'0';; }; int SAt(int x, int y) { return m_Board[(((y/3*9)+x)/3) * 9 + (y%3)*3+(x%3)] - '0';; }; bool Available(int test, int pos) { int x=pos %9; int y= pos/9; for(int i=0;i&lt;9;++i) { if(RCAt(i,y)==test-'0' || RCAt(x,i)==test-'0' || SAt(i,(((y/3*9)+x)/3))==test-'0') { return false; } } return true; } bool Solve1(int x) { if(x&gt;80)// hit the end of the recursion, return true; { return true; } else if(m_Board[x]&lt;'1' || m_Board[x] &gt; '9') // if the board location is not fixed { for(int test = '1';test &lt;= '9';++test) // try each number { if(Available(test,x)) // do simple local availability test before recursing with guess ( take this out and watch the algorithm slow down imensly, but it woud still work.) { m_Board[x]=test; if( Solve1(x+1)) // try the next positon { return true; // if solve returns true, we have filled all the board and it is valid } } m_Board[x]=' '; //clear guess location,(saves a bit of work in the available function ) } } else // if the position is known, recurse to next position { return Solve1(x+1); } return false; } private: std::string m_Board; }; int _tmain(int argc, _TCHAR* argv[]) { Board b(" 43926" " " " " "4 6 " " " "9 54612" "3 51" "2895 7" " "); b.Display(); b.Solve(); b.Display(); return 0; } 
Is there anything more annoying than the word "automagically". It suggests pride in one's ignorance. I cringe whenever I come across it, especially in the *discipline* of programming.
The SVN trunk does build in VS11; the only rub I encountered was that once you've run the bootstrap bit, you need to edit the little .jam file that's produced in the top level directory (I forget its name and don't have the tree in front of me) to change the msvc line to read "msvc : 11.0 ;" so that it names things correctly.
&gt; Warning: Once std::move(variable_name) is invoked on a variable, that variable cannot be used again. If such variables are used, the results are implementation defined and could easily crash the program. Effectively, when you use std::move() are you surrendering control of that variable’s state to another variable. This is not entirely correct. After std::move(variable_name), variable_name is still a valid object. It's just that its value may have changed. 
I agree with your sentiment. Not with your grammar, though: 'code' is uncountable in this sense. 'A code' refers to either a single symbol or a symbol language, while source code consists of a specific permutation of symbols that can be interpreted.
Thank you everyone for the suggestions! I'm sure I can get something going now. Kinda looks like I'll be looking into making a game myself. They seem to work nicely.
Thanks for the pointers! I think I'm going to start something like this today!
^ This. I'm basically in that stage already and am looking to get out of it. But the discussion that started here could lead into some more helpful tips for sure, if, like he said, you could be more clear on "good" and "bad" styles 
Correct and my mistake. I have fixed the wording to be, "Warning: Once std::move(variable_name) is invoked on a variable and its owned contents has been moved, that variable should only used as as a “zeroed-out” or “empty” object (whatever that means for that type). Effectively, when you use std::move() know that the ownership of that variable’s state may be transferred (i.e., moved) to another variable since std::move() makes that variable become an rvalue."
I like it. It suggests the computer will "Do What I Mean".
4.7.0-20111119 does.
Why not use "automatically". It's not only a real word, but it's the best description of what is happening. There is no magic in programming, everything works the way it was written to work, and everything is perfectly explainable. Once you start using automagically you can really use it to describe anything in programming. Garbage collection reclaims memory automagically, a function is called automagically, two floats are multiplied automagically.
I agree. Everybody writes bad code at one point in their development as a programmer. It is the only way to learn the "best" way to do things. Best for the OP to just pick a fun project and go for it. Of course it wouldn't hurt to try and pick up good habits along the way.
[It will also be streamed online](http://channel9.msdn.com/Events/GoingNative/GoingNative-2012) for those who can't attend but are interested. 
Using templates &amp; dimensional analysis would have also prevented the problem at compile time. Technique has been around since mid-90s, if not earlier.
Like the idea of this.
Aww something wrong with the video ? I get this : Video not found or access denied: https://s3.amazonaws.com/corensicmedia/videos/9-Condition.mp4
Works fine for me.
I'm going. See y'all there.
Can't be there (unless by some miracle I get a job at Microsoft in Seattle), but I will surely watch the live stream.
This is fantastic and is exactly what we need these days. Now I just hope nothing crops up on those two days. 
Thinking about this. 
I wouldn't mind fully conforming compilers as well :)
This is very nice series and a good introduction to C++ concurrency. A good mix of code and speech so you don't get lost. 
It's probably my work proxy. I'll try from home.
&gt; I believe I read somewhere that literal names not starting with an underscore are reserved by the C++ standard. If you know definitively or otherwise, kindly let me know. :-) From the N3291 draft/17.6.4.3.5: Literal suffix identifiers that do not start with an underscore are reserved for future standardization. 
So, basically, the suffix id must start with an underscore, followed by a digit or a lower-case letter, right?
I would say "should" instead of "must" but otherwise concur.
I started to implement this very thing the other day but got stuck. Now I see why!
Why is it necessary to use template metaprogramming? Why couldn't you do it with a for loop, like this: constexpr unsigned long long operator "" _binary(const char* str, std::size_t len) { unsigned long long t = 0; for (size_t i = len-1; i &gt;= 0; --i) { t &lt;&lt;= 1; if (str[i] == '1') t |= 1; else if (str[i] != '0') // somehow generate error... } return t; } (probably contains errors; i just typed it out here)
That's an invalid constexpr because it contains more than a return statement. If you want the conversion to be done at compile time for efficiency, then you need to use constexprs or template meta-programming (or both).
Well that's the technical C++ reason, but there is a far more fundamental question there. Why can't what criticalsection wrote be evaluated at compile time in principle? Why does one need to hijack C++ templates to write this kind of code using a syntax it was not designed for, instead of using ordinary C++ syntax with some specifier indicating that the function should be evaluated at compile time?
&gt;Why can't what criticalsection wrote be evaluated at compile time in principle? Probably they didn't have enough time to do that, hence only half-assed solution. Cant see any other reason why would they do that.
Afaik, variables are always lvalues.
It's not half-assed... The easiest way to enforce a zero-side effect function is to force it to be a one-line return statement. Otherwise we would have to do a lot more introspection to ensure that the code actually CAN be done at compile time. constexprs are "generalized constant expressions" and should be treated as such. EDIT: There is another enforcement I forgot about. A constexpr function can only call other constexpr functions as well, to again enforce the fact that the return value is indeed a side-effect free compile-time constant (when supplied with constant arguments, of course. Runtime arguments will result in a runtime computation.)
An unnamed variable is treated as an rvalue. For example, given some type Foo, simply writing Foo() will create an unnamed variable and that will be treated as an rvalue. Compiler generated temporaries also fit into the same category. The C++11 standard lvalue and rvalue notions are broken up into a small taxonomy to make the semantics clear in all cases. On a practical, easy-to-think-of level, perhaps it could be loosely summarized as: if a variable has a name, then think of it as an lvalue (and you'll need to use std::move() to make it an rvalue); if it does not have a name, then think of it as being an rvalue.
Anybody get the feeling that compile time literals will become one of those tiny little features that become very popular? Of course use in entirely different ways by everyone. 
'Variable' is defined by C++ standard to be: 6 A variable is introduced by the declaration of a reference other than a non-static data member or of an object. The variable’s name denotes the reference or object. Hence, its always na lvalue (afaik). Edit: above is nitpicking. Im really arguing with this: Foo f; Foo b = std::move(f); //'f' doesnt stop being lvalue, 'f' is always an lvalue I read your post as suggesting otherwise which for me sounds confusing. 
It is half-assed. Just having return statement doesn't buy you much 'in general'. There is no more introspection needed by allowing multiple statements (other then making compiler 'run' more statements then just one). Having multiple statements doesn't break any of what you said - it just makes the code more readable. It probably doesn't make it any more complicated for compiler too, as you can emulate 'if' with ternary and loops with recursion. It has to execute it anyways and see if the recursive loop is terminating. Edit: it would require some more editorial work though, as they would need to say that only constexpr variables are ok, that loop bounds need to be constexpr, that int 'i' - the loop counter is ok then, etc. Imo, they just went with what could be specified quicker to push it into current standard.
Aside: The definition does not say it is an lvalue or any other type of value (e.g., glvalue, xvalue, rvalue, or prvalue). (I am not arguing, just noting.) Foo f; // Will be treated as an lvalue by the compiler Foo&amp;&amp; r = Foo(); // Foo() has no name so will be treated as an rvalue, thus the declaration is permitted Foo b = std::move(f); // Returns an rvalue reference of f, f itself is still an lvalue. // The purpose of the above line is to allow f's contents to be moved into b. // If moved, f will have "no" content and will likely need to be reinitialized... f = somevalue; // is possible if op=() is defined and legal What is and is not an lvalue or an rvalue (in C++11) is in the [basic.lval] section of the standard. It is this section that defines whether or not something is or is not, can be or cannot be, etc. an lvalue or otherwise (along with some other sections mentioned in [basic.lval]). Most would probably find the refined notions of lvalue and rvalue in C++11 a bit pedantic, so I referred to such in a simpler way. On a practical everyday level, I think is it reasonable for a programmer to consider any instance of a type (named or not) to be a variable (be it intentional or temporary). The question then becomes when is such treated as an rvalue versus an lvalue. I think and it appears to be a good rule of thumb (so far) that a variable without a name will be treated as an rvalue and anything with a name will be an lvalue --by default (i.e., without using std::move(), etc.). I've not rigorously gone through all cases to determine if such is always true in every case though.
go back to your toy language
More than a feeling IMHO! I think they will be used in numerous creative ways that will make code more readable and typesafe. (If it is not more readable, I can't see sane C++ programmers adopting it.) Perhaps it will start the moving away of C-style hard-coding (arrays of "cryptic"/"magic") values in C++ code and move it towards human-readable values using literals that produce those "cryptic"/"magic" values instead? It will also help with programs that need to tie scalars with units to ensure that they are being properly handled and converted (e.g., for things like what Boost.Units addresses). This hopefully (as such libraries are built) will prevent many problems like Mars probes burning up upon entry, rockets flying into the sea, medical machines giving radiation overdoses, etc.
The reason pure functions are only allowed is to minimize the amount of "you can't do this, but you can do this" type scenarios. Instead of saying a lot of things like "you can loop, but your bounds must be constant, but your index doesn't need to be" (how else can you do i++?) It's more simple to just use recursion then, instead of create those kinds of arbitrary rules. Also, how about while loops then? They're basically the same as for-loops, but the bounds aren't as simple to specify. Do we disallow while and do loops, but allow fors? I personally think that restricting constexpr functions to being pure functions was a very smart move because it's overall easier to understand, easier for compilers to implement, and for everything you will want to compute at compile time (basic expressions, simple recursive formulas) you don't lose any power at all.
Its only smart if you need to optimize for standard document simplification. Looking at [D feature set regarding this](http://www.d-programming-language.org/function.html#interpretation) makes C++ constexpr look just sad. Its still great that they managed to put it in in whatever form.
What do we think of the idea of "throwaway" compile code? Like you'll have pieces of your program that get compiled and run just to assist compilation of the main program, then never linked to the a.out.
1) ODBC (a portable C API). You will need the mysql connector for ODBC from MySQL's download site. 2) mysqlclient C api (in the MySQL distribution) 3) Wrapped C API in C++ (http://mysqlcppapi.sourceforge.net/) Personally I'd probably use ODBC for portability. Using the MySQL specific APIs will lock you to that database. I had a longer post but my proxy ate it.
&gt; Using the MySQL specific APIs will lock you to that database. You'll find that most of the time, if you want to use the database for anything more than a key-value store, you'll end up using MySQL-specific SQL code anyway.
You know, Google might help you here. http://www.google.com/search?q=C%2B%2B+library+MySQL&amp;btnG=Search&amp;hl=en&amp;source=hp http://www.google.com/search?q=C%2B%2B+MySQL&amp;btnG=Search&amp;hl=en&amp;source=hp
You may also want to consider using an ORM implementation to save C++ classes into the MySQL database instead of using a low-level API to manually execute SQL queries and handle/convert results. For example, [ODB](http://www.codesynthesis.com/products/odb/) will manage connection(s) to MySQL for you and automatically convert the data between the database representation and C++ objects. It will also keep your code database-portable so that you can switch to another database if needed. 
To expand on this, there are multiple practical problems with ODBC: 1. It only provides a common interface for connecting to the database and executing the queries. While ODBC also provides some escape sequences for commonly used but non-portable SQL constructs like JOINs, any non-trivial query you will most likely have to code using the native SQL dialect. This is especially true of the DDL statements. So, in essence, ODBC solves only half of the problem, namely the database API portability. It doesn't address the other half very well, which is SQL portability. 2. ODBC does not always expose finer-grained aspects of the database API which can become important if you want to achieve good performance. Some examples, in case of MySQL, include the result set caching control (MySQL can buffer the whole result in client's memory or it can stream the result from the server one row at a time), as well as the ability to retrieve the last AUTO_INCREMENT value without a separate query. 3. A lot of the driver implementations are quite poor with many corner cases not being handled properly. In fact, you get the feeling that the ODBC driver is often treated as a second-class citizen compared to the native C API. I believe that's also the reason why most mainstream scripting languages (Perl, Python, Ruby, etc), use the native C APIs instead of ODBC to implement database access. The only exception here is the Microsoft SQL Server, for which ODBC seems to the standard native API. When we started working on [ODB](http://www.codesynthesis.com/products/odb/) (a C++ ORM), we considered using ODBC, but because of these issues, decided to instead use the lowest-level, native C API for each database. This allowed us to reduce the extra overhead invariably incurred by a wrapper API such as ODBC and to provide the most efficient implementation for each database. 
I have used pqxx in the past. As a bonus you get a nicer RDBMS too :)
Just use the MySQL native C API. It's fairly straightforward, and you won't end up juggling several layers of library trying to figure out what's going on. http://dev.mysql.com/doc/refman/5.5/en/c.html
&gt; You'll find that most of the time, if you want to use the database for anything more than a key-value store, you'll end up using MySQL-specific SQL code anyway. I don't.
I have found by far the best way to connect to a data base is with SOCI, the reason I like it because it doesn't require an intermediary compilation step like ODB. Further more it is written STL style C++ and it compatible with streams and iterator. Would recommend this over ODBC calls any day of the week.
[ODB](http://www.codesynthesis.com/products/odb/) and [SOCI](http://soci.sourceforge.net/) are quite different. SOCI is a C++ interface for executing SQL queries and handling their results. In other words, you still write your application in terms of database-specific SQL queries. ODB, on the other hand, is an ORM. It allows you to store C++ classes in a relational database without having to write any SQL. It also has a query language, but it an object query language, not SQL (thought you can drop down to SQL in ODB, if necessary).
The OP never asked for ORM nor did he mention using anything other than MySQL. That said soki it does provide some very good methods of extracting objects from a database results set. For example I have this in my code. sql &lt;&lt; "SELECT count(ID) FROM users", soci::into(count); users.reserve(count); soci::rowset&lt;distrib::user&gt; rs = (sql.prepare &lt;&lt; "SELECT u.ID, u.FULLNAME, u.AGENTID, s.name " "FROM users as u LEFT JOIN devices as s " "ON u.device_id=s.id"); std::copy(rs.begin(), rs.end(), std::back_inserter(users));
You may also want to try Poco library ::Data classes for doing this. Clean API, backends for both mysql and sqlite.
When ever I see Poco I like the look of the code and interfaces, but there docs are so dry, very little in the of examples and walk throughs. Unlike, say the way boost documents things. With Quick starts an tutorials. They just make learning the basics considerable quicker, especially when they use the interaction objects model.
One way to do it is to cast whichever char you're trying to convert into an int. This will give you its index on the ASCII table. [Here](http://www.cpptutor.com/imgs/ascii_table.gif) you can find an ascii table. Once you have its index, add or subtract 32, depending on which way you're converting. Then cast back to a char to get the char of the new index.
I believe you omitted quite a bit of code that actually extracts the ID, FULLNAME, AGENTID, and name into the user class. Code that you have to write by hand. This, however is a *complete* version of the same example using ODB: #pragma db view table("users" = "u") table("devices" = "s": "u.device_id=s.id") struct user { #pragma db column("u.ID") unsigned long id; #pragma db column("u.FULLNAME") std::string full_name; #pragma db column("u.AGENTID") unsigned long agent_id; #pragma db column("s.name") std::string device_name; }; odb::result&lt;user&gt; r = db.query&lt;user&gt; (); std::vector&lt;user&gt; users; users.reserve (r.size ()); std::copy(r.begin (), r.end (), std::back_inserter (users)); Note also that this code uses ODB for "table" access. If the users and devices tables were mapped to C++ classes, then the code would be even more concise, without any of the column names as string literals, etc.
I'll bite. Why is this a bad feature of C++? I was always under the impression that the &lt;&lt; and &gt;&gt; operators made a lot of sense for streams as they gave the impression of the streams "flowing" in and out .
Why do both sides of the operator have to say the same thing? int i; i = binaryReader.ReadInt(); vs int i; binaryReader &gt;&gt; i; What is `i` going to do? Go turn into a string?
1) The same operator is used for bit shifting. 2) Odd, illogical string formatting. 3) Hard to tell what code is being called. ... and then there's the general aesthetic of it. It's ugly.
P.S. John Carmack [Tweet](https://twitter.com/#!/ID_AA_Carmack/status/141217295816081408): We did not run any static analysis on the Doom 3 source, doing so is an excellent project for anyone looking at it!
Do any of these manifest as bugs in the actual game?
Possibly. There probably are people who experienced random crashes as with nearly every game. Commercial games are tested to be reasonably stable and playable, but the point of static analysis is that it helps to find these problems. 
To poke the elephant: * How many warnings you got in total, * how long does it take you (as an experienced PVSer) to pick out some interesting ones * how many of the warnings would be as "obviously interesting", i.e. fit for inclusion?
Number of warning: Level 1: 85. Level 2: 37. Level 3: 812 (a lot, but they are not interesting, and usually they can not watch) I do not know how many of these errors found. I finished studying the report, when chose 10 alerts for this article. I'm not familiar with the project and study hard all the warnings. A total analysis of the project, view errors, writing this article, and publication, I spent about one day. 
Thanks for the feedback! This looks, at the very least, managable. I always enjoy these posts, a strange mix of staring at other peoples mistakes and things that can be done better. I asked because the biggest hurdle (probably) is convincing people to let a static alalysis tool loose a large code base that has never seen such a thing. I presume that's routine for you now, but posting some such stats with each project might help. 
Sorry I wasn't intending to mislead with my code snip it but rather show how well soci integrates with C++ ideology.
The way I would write it, if I had the time :S, I would ditch some of those mutli arrays for vectors (probably wrap vectors in to matrices), encapsulated data orinated sections into classes. For example output() would be a friend stream operator or class which encapsulates the board, which in term would probably have a matrix of tiles or something. Breaking the problem down. I would give the code some breathing room, i know python encourages the use every line stuff and creates dense blocks, but C++ is a much richer language and it just becomes to much.
Why not make a map (associative array) with each key being the names and then their values being a reference (a pointer) to arrays with all the information you need.
It sounds like your instructor has something specific in mind when telling you to "use hierarchies." In absence of any knowledge about what you guys have talked about in class, I will assume that the teacher is simply looking for a hierarchical orginization of your data. (http://en.wikipedia.org/wiki/Hierarchical_model) Think about this: if you're tracking 1000 different people in your database, there may be a large number of people who are exactly the same height. Rather than storing a height value for every person, you can store the height "5 feet, 11 inches" in your database just once and have the 300 people who are 5'11" all reference that one value. You will end up with a "master list" of all the heights you need to represent (i.e. 5'0", 5'1", 5'3", 5'7", ...). Note that if nobody in your database is 5'2" then that value doesn't necessarily need to be tracked in the master list. In order to average values for everyone, you will need to traverse that hierarchy that you've set up. So, for each name, you will need to follow the reference from that name to your master list of heights to figure out what the height is for that person in order to compute an average. Let me know if you need some extra clarification. Also, if you have time before the assignment is due, you can always ask your instructor to clarify what he or she is looking for :). Also, note that you may be getting downvotes since this isn't a strongly C++ specific question. It may have been more appropriate to post to /r/compsci to understand the theory behind data hierarchy, and then to post here if you had a specific problem with your C++ implementation. Either way I hope this helps you get on track :).
So, given their definition of _binary, what is the difference between 11011110101011011011111011101111_binary and "11011110101011011011111011101111"_binary?
I don't get the within. Doesn't that just assign parent to the input parameter within that new scope?
&gt; Using the MySQL specific APIs will lock you to that database. Not with a good design and autotools might be your friend. The relevant section in my Makefile.am says: if POSTGRESQL libdal_la_SOURCES += ${SRCDIR}/dal/Postgres.cpp endif POSTGRESQL if MYSQL libdal_la_SOURCES += ${SRCDIR}/dal/MySQL.cpp endif MYSQL I have no complains. 
True C++ and you'd do it all with template expressions at compile time. ;-)
If you want real help you will need to post source. That said, I assume circle is derived from shape. When you did *s though, it is only a shape, not a circle. What you want to accomplish can be resolved with a virtual function in shape that is implemented in the derived classes. 
Things like VARIANT in COM would be very unwieldy without this pattern. 
yes, circle etc derive from shape. Would it be a virtual operator overload? And i've used static_cast&lt;circle&gt; prior to this line such that: if(cin &gt;&gt; static_cast&lt; circle* &gt;(s)) { s-&gt;draw(); std::cout &lt;&lt; std::endl; } And when calling **(*s).draw()** instead of the line in question it uses the draw() from the derived class correctly.
This might help you http://stackoverflow.com/questions/4571611/virtual-operator Good luck!
yeah, well what I wanted to do is just call the c.draw() when you use oprator&lt;&lt; and i've done it for circle, rectangle and triangle using the object by reference as shown above (and below) std::ostream &amp; operator &lt;&lt; (std::ostream&amp; os, const circle &amp; c) and that works fine, it's just the pointer bit gives me errors, which i should have probably had specified in the first place, oh well here it is: main.cc|141|error: no match for ‘operator&lt;&lt;’ in ‘std::cout &lt;&lt; * s’
Here's full source for this main() as suggested. #include &lt; vector&gt; #include &lt; list&gt; #include &lt; iostream&gt; #include "shape.h" #include "circle.h" #include "rectangle.h" #include "triangle.h" #include "shape-utils.h" using namespace std; int main(void) { circle c; rectangle r; triangle t; c.draw(); r.draw(); t.draw(); cerr &lt;&lt; "OK-1\n"; vector&lt;shape *&gt; vs; list&lt;shape *&gt; ls; vs.push_back( &amp;c ); vs.push_back( &amp;r ); vs.push_back( &amp;t ); draw_all_vec(vs); cout.flush(); cerr &lt;&lt; "OK-2-a\n"; draw_all(vs); cout.flush(); cerr &lt;&lt; "OK-2-b\n"; ls.push_back( &amp;c ); ls.push_back( &amp;r ); ls.push_back( &amp;t ); draw_all(ls); cout.flush(); cerr &lt;&lt; "OK-3\n"; draw_all_seq_inside(vs, r); cout.flush(); cerr &lt;&lt; "OK-4 \n"; draw_all_seq_inside2(vs, r); cout.flush(); cerr &lt;&lt; "OK-5\n"; cout.flush(); cerr &lt;&lt; "OK-5-b\n"; shape *s = (shape *) 0; // Read some shape from standard input &amp; store it in s cout &lt;&lt; "Give some input here\n"; cout.flush(); string _change = "shape:"; string _shape; if(cin &gt;&gt; _change &amp;&amp; _change == "shape:") { std::cout &lt;&lt; "&lt;&lt;CHANGE: "; if(cin &gt;&gt; _shape) { if(_shape == "rectangle") { std::cout &lt;&lt; "RECTANGLE&gt;&gt;\n"; s = &amp;r; if(cin &gt;&gt; static_cast&lt;rectangle*&gt;(s)) { s-&gt;draw(); std::cout &lt;&lt; std::endl; } } else if(_shape == "circle") { std::cout &lt;&lt; "CIRCLE&gt;&gt;\n"; s = &amp;c; if(cin &gt;&gt; static_cast&lt;circle*&gt;(s)) { s-&gt;draw(); std::cout &lt;&lt; std::endl; } } else if(_shape == "triangle") { std::cout &lt;&lt; "TRIANGLE&gt;&gt;\n"; s = &amp;t; if(cin &gt;&gt; static_cast&lt;triangle*&gt;(s)) { s-&gt;draw(); std::cout &lt;&lt; std::endl; } } } } else { cout &lt;&lt; "Invalid. Use 'change circle ...' etc."&lt;&lt;endl; } if (s) { //(*s).draw(); //this draws cout &lt;&lt; (*s) &lt;&lt; '\n'; //this doesn't } else if (! cin.bad()) { cout &lt;&lt; "Read reached EOF\n"; } else { cout &lt;&lt; "Read failed\n"; } c.rotate(90); r.rotate(90); t.rotate(90); cout &lt;&lt; c &lt;&lt; endl &lt;&lt; r &lt;&lt; endl &lt;&lt; t &lt;&lt; endl; cout.flush(); cerr &lt;&lt; "OK-6\n"; return 0; } 
As adzm said, a circle is a shape but a shape is *not* a circle. (It *might* be, but it might also be a triangle, or a rhombus. So you can't use an object of type shape when you need one of type circle.) In other words, you've got it backwards: operator&lt;&lt; should be dealing with the more *general* type of "shape", so that it can handle any type of shape, triangle, rhombus, circle, line. By relying on virtual shape::draw(). --- I still think it is weird that shape::draw() does not use the ostream. I assume your draw function makes ascii art. What if I open a text file as a ofstream and say "my_ofstream &lt;&lt; (*s);" ? (ofstream is a specific type of ostream, much like circle is a specific type of shape -- that's why what I want to do is possible, to use the same code for different things without changing the operator&lt;&lt; code). Will you still print it to cout? Why not print it to the ostream that is given? -- that is "probably why" the ostream argument is there at all.
No. Stop. Do not listen to anyone else. Use [soci](http://soci.sourceforge.net/) I think it's sort of on track to join Boost at some point. It's damn good.
I'm not sure if you got your answer or not but something like this should be sufficient std::ostream &amp; operator &lt;&lt; (std::ostream&amp; os, const shape* s) { return os &lt;&lt; s-&gt;draw(); // assuming draw is a virtual method } A constant reference parameter would work just as well.
"Throwaway" is not perhaps the best term to use: all code takes one form and converts it to another form (be it at compile-time or run-time). Once one gets the answer, then the code could be said to be "throwaway" (as it is not needed anymore to compute that answer). With C++ template metaprogramming (C++ TMP), one is specifically transforming code from one form to another (typically, much more efficient and more tedious/longer-to-write) form. With the _binary literal example, this allows a programmer to use a more readable form of expressing a number in a program where it makes more sense to write 10111110_binary instead of 0xBE in a given context. Another example: an engineer/scientist may want to write 23.23_km * 12.31_miles. With such as literals turning such into numbers associated with their units, one can ensure that units are more likely being properly handled/treated within code.
I have a few comments on your code. Firstly, most of the time ANY cast points to a problem you should be avoiding. Secondly, you are assigning s to a shape(c, r,t) then casting it back to read it in. Why not just: if(cin &gt;&gt; *r) { r-&gt;draw(); std::cout &lt;&lt; std::endl; } In answer to your original question, generally streaming operators act on reference to objects rather than pointers, so use ** s &gt;&gt; *r ** to get an object rather than trying to make a stream operator use a pointer. 
New
I totally agree, firstly your need for a pointer, is a good one (polymorphism). However the stream operator for a pointer should print out the address of the pointed value because that is it's value. You should define a stream operator (as others have said) for each of the child class if necessary. dereference the pointer to print. something like friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const shape&amp; shape_) { os &lt;&lt; shape_.value1 //... ... return os; } ::: typedef typename std::vector&lt;shape*&gt;::iterator shape_p_it; for(shape_p_it sit=ls.begin(); sit=ls.end(); ++sit) std::cout&lt;&lt;&amp;(*sit)&lt;&lt;'\n'; or in c++11 for(shape *sp : ls) std::cout &lt;&lt; *sp &lt;&lt; '\n'; also a quick trick you can try, instead for draw all you should be able to so #include &lt;algorithm&gt; //draw all shapes std::for_each(ls.begin(), ls.end(), &amp;shape::draw);
&gt; A constant reference parameter would ~~work just as well~~ be the more correct way to implement it. FTFY
 std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const shape &amp;s) { s.draw(); return os; } ... os &lt;&lt; *s &lt;&lt; "\n"; (Provided of course you have made an actual `s` between the `shape *s = 0;` line and above).
&gt; C++ is a much richer language Wut? I mean, I like C++ as much as anyone, but I think pretending that C++ has much more expressive power than Python is a little over the top.
Why is that? Because it overloads the generic pointer version, or something else? I'm more inclined to go with the pointer version as it doesn't require the user to dereference first.
Is it necessary to use std::move when returning object from function? I thought it is not but he is using it everywhere.
Because it violates the principle of least surprise, even though it is fewer keystrokes. Think about it: what would happen with this code? int b=10; int *a=&amp;b; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; *a &lt;&lt; endl; Therefore, what would you expect to happen with this code? Shape b; Shape* a=&amp;b; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; *a &lt;&lt; endl; 
You've should try cppDB: (From their website) : CppDB is an SQL connectivity library that is designed to provide platform and Database independent connectivity API similarly to what JDBC, ODBC and other connectivity libraries do. This library is developed as part of CppCMS Project - the C++ Web Development Framework. CppDB was designed with following goals in the mind: Performance is the primary goal - make fastest possible SQL connectivity as possible Transparent connection pooling support Transparent prepared statements caching Dynamic DB modules loading and optional static linking Full and high priority support of FOSS RDBMS: MySQL, PostgreSQL, Sqlite3 Support as many RDBMSs as possible via cppdb-odbc bridge Simplicity in use Locale safety Support of both explicit verbose API and brief and nice syntactic sugar
I think this thing has been updated since the other day.
I have that exact problem (a little worse because it's a/v AND an application whitelisting program). I don't have any workaround except to re-try the build. Your idea is pretty good though, imo. edit: Just found and built the workaround, thanks :)
Glad it worked. It still seems sloppy though.
It is, but because it's a file system problem and because of the way mt.exe handles that in this case, the only solution is to get a new mt.exe. Since MS has basically said they're not going to fix the issue because it's due to external tools, I don't really see another option. edit: (Unless you want to not embed the manifests and ship them alongside the .dlls, but that idea got shot down where I work...)
Ahh, I see. Thanks.
At a cursory glance I don't see anything obviously wrong. I'd need to see the actual error message outputted (by I'm assuming MSVC). &gt; On a side note, are there any libraries that already do this? Plenty. Check out [wxWidgets](http://www.wxwidgets.org/), which has a permissive license. The Windows API is a huge, hard-to-tame beast. Frankly a few classes won't cover most of what you need to do. I don't recommend trying to write a Windows API wrapper on your own.
Would you post the exact errors you are getting?
&gt; On a side note, are there any libraries that already do this? MFC and WTL are the big ones. There are of course also widget libraries like Qt and such. 
Oddly, I'm not receiving them anymore. However, it was as simple as this: &gt; *WindowClass::WindowClass(WNDPROC procedure, char const *className, HINSTANCE hInstance)* multiple definition Where what's in italics could be replaced with any of the class functions, as it was happening with all of them. It's not word for word, as I'm not getting the error anymore, but very similar to that.
Odd, since I posted this, I re-compiled the program and am now only getting this error (and I am using Dev-C++): &gt; [Linker error] undefined reference to `_Z15WindowProcedureP6HWND__jjl@16' And I would have to assume this was because I have not defined WindowsProcedure yet, even though I declared it. Thanks for the link to wxWidgets! That was very helpful.
WTL is the closest to what you're suggesting. It's actually what Google Chrome uses. I would stay far away from MFC. Things like Qt, Gtk, and wxWidgets go way beyond wrapping the windows API and actually abstract it away (which can be good, it just depends on what you're after). 
&gt; Dev-C++ Don't use Dev-C++. There are tons of better C++ IDEs out there. If you're a student, [Visual Studio 2010 Professional](https://www.dreamspark.com/default.aspx) is free. If not, then get [Visual Studio 2010 Express](http://www.microsoft.com/visualstudio/en-us/products/2010-editions/express).
I've tried Visual Studio for C++ development and hated it. The intellisense rarely worked. I just never saw any difference between the two other than how it was presented to you. What other IDEs would you recommend?
codelite, code::blocks, eclipse, netbeans. if you ask me you can use devcpp if it works, just make sure it's the unofficial updated version mentioned on Wikipedia. the official is half a decade old. 
If in doubt, a "Rebuild All" sometimes fixes things (especially linker issues) with MSVC (and maybe your Dev-C++ as well). That said, linker errors (even outputted by other compilers, it's not just an MSVC thing) can be daunting to newer programmers. I think that's because it occurs after the "YAY! it compiled!" stage. Reality is, they're pretty easy to trace - you've got something that is declared, used, but not defined, and the linker (correctly) complains. The key is understanding that the linker is different than the compiler, and understanding the purpose of both. In all seriousness though, there may be a bit more of a "getting started curve" (compiling, etc), but do try wxWidgets. It's well supported and widely used with a license that permits use in commercial software. I also tried to write wrappers around WinAPI many moons ago, it was mostly a waste of time. As a bonus, wxWidgets is cross-platform so you can compile your software for OSX and Unix-ey environments (GTK) without too much hassle.
With wxWidgets, you can get the HWND for a window, which means you can do pretty much anything. Unless you want something to be cross-platform of course.
Check out Qt Creator. The C++ code completion is actually pretty good.
And as a bonus, Qt is *the* best library for building GUIs. No more pig disgusting HWND or WPARAM!
You're not applying A\* here, though. :)
If you do strictly Windows programming, I suggest you try http://sourceforge.net/projects/win32-framework/ . A very well-organized library, with a cool developer who responds and fixes problems very quickly.
MFC has a bad reputation. It's not very pretty but it gets the job done for small to medium business apps that are desktop-centric. The downside is that MFC doesn't come close to eliminating the Win32 learning curve, it just kind of spackles over it. You'll need to be fairly fluent with the Win32 api before you can accomplish anything and you'll need to have at least a passing familiarity with COM before you can accomplish anything of value. Once you're familiar with Win32 and COM, MFC is a breeze. 
Managed C++ and WinForms or WPF? You're still using [Win32](http://social.msdn.microsoft.com/Forums/en-US/wpf/thread/6b97a6de-0480-4339-8ed0-cb7cdb27bd83/) under the hood as far as I can tell. 
That is a linker error, not a compiler error. You wont find the problem or solution in code. It means you have included a header file, but you have not included the lib that goes with it. Like some other guy said ... when on windows just learn to use Visual Studio like everyone else. When you are new you want to walk down a path well-trodden, as most problems you will face have been faced by others before and you can google their solutions.
what is the output of type gcc ? And why would you compile as root by the way?!
Please try: which gcc 
`type` is better than `which` in all circumstances because it is a shell builtin and can tell you whether the command is a shell builtin, alias, or function (and will print the expansion of such.) `which` being an external program can only search `PATH`, and `type` does that anyway if the command is not a builtin/alias/function. 
It says: root# type gcc gcc is hashed (/usr/bin/gcc) More info: gcc version 4.2.4 (Ubuntu 4.2.4-1ubuntu4) running on Ubuntu 8.04.3 LTS
There is something fucked with your system. I don't agree with Rhombold: "which" is sometimes more useful, as it doesn't interact with the shell layer of abstraction. Try $ which gcc And then maybe $ `which gcc` -o test test.c or $ make test
How about type ld ? It would seem that somebody made a script by that name that runs `ls -al | grep ^d`, but that is also the name of the linker, so when gcc tries to link your program it runs this thing instead. 
It says: root# `which gcc` -o test test.c drwxr-xr-x 2 ganesha ganesha 4096 Dec 4 09:30 . drwxr-xr-x 16 george george 4096 Jul 17 08:29 .. root# make test cc test.c -o test drwxr-xr-x 2 ganesha ganesha 4096 Dec 4 09:30 . drwxr-xr-x 16 george george 4096 Jul 17 08:29 .. Edit: I found it - it was a problem with my "ld". I didn't know that thing existed before now. I overloaded it with an alias to ls -al | grep \^d and then forgot about it. Thanks
BINGO!!! That was it. I overloaded ld with a personal script. Thank you everyone!!! I was scared my server got a rootkit or smth. It was just a clumsy thing I did a few days ago.
The Boost library provides higher-level, platform-independent abstractions which are easier to use with C++ than using the API's directly, e.g, the *asio* and *thread* sub-libraries. [This book](http://basepath.com/aup/) is a classic if you want to understand the low-level concepts and API's for UNIX. 
Thank you for the clarification!
http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html 
&gt; I have looked up some socket programming tutorials and they don't seem to help out much. Perhaps it might be useful to tell us what tutorials you have *looked up* and how they failed to help out.. *much*. Otherwise, how can we be expected to provide something *better* for you. Excellent places to learn something worth learning usually require commitment on your part. Since you are looking for tutorials rather than books, I'm guessing that's not really something you are ready to do (commit). You are also asking about something the C++ standard says nothing about (socket programming). In consequence, you should also say some things about your target operating system(s). If you want to stay away from system calls, I guess having a look at boost and Qt can't hurt. The documentation is freely accessible.
A TCP socket is much like a file, except that you read what the other writes and the other reads what you write. There are no "write lengths" that you see on the other side, it's just a stream of bytes. I'm going to be using the Windows function names here, but the Unix ones are closely related and very similar. First, you create a socket. SOCKET sock = socket(); This is now an idle socket. It does nothing. It's like a file handle that doesn't have a file yet. You can now choose to either use it as a server socket (listening for connections) or as a client socket (connecting to somebody else). If you choose the latter (easiest): connect(sock, some_address, sizeof(some_address)); The address you pass to connect is of a special address type called a "struct sockaddr". For now, just know that this is how you connect. When this returns, you have a connected socket and you can recv/send on them like you would read/write a file. To make the other half, you have other calls to make: bind(sock, some_address, sizeof(some_address)); This tells it where to listen. The address is in the same logical format as for connect, which will follow below. Now that it's got a port and optionally an IP address to listen on, you tell it to register with the OS to start receiving connections: listen(sock); This does nothing, other than tell the OS to redirect active connection requests to this socket. They don't do anything really yet, until you start accepting those connections somehow: SOCKET client = accept(sock); This accepts one connection from the queue (or blocks until there is one) and then returns its socket. Note that each client gets its own socket and that you don't use the listen socket for any active read/write communications. You can then recv/send on this socket, like you would with a connect()ed socket. For any of them, when you're done call closesocket() on them. This signals to the other side that you're done and that no more data will be coming. Now, the address thing. The interfaces were created a *long* time ago and back then there wasn't any actual "classes" or "inheritance". They still used it for this though. There are two structs you would typically be using: struct sockaddr * // this is the type that both connect and bind expect struct sockaddr_in // this is the type you want to create to put in so, to create a socket, you would use for example: struct sockaddr_in local_addr, bind_addr; inet_pton(AF_INET, "127.0.0.1", &amp;local_addr.sin_addr); local_addr.sin_port = htons(some_port); local_addr.sin_family = AF_INET; bind_addr.sin_addr.s_addr = htonl(INADDR_ANY); bind_addr.sin_port = htons(1285); bind_addr.sin_family = AF_INET; The first is specific, so you can use it to bind or connect. It will only bind on the network interface that has that IP address or it will connect to that address. The second is aspecific, in that it has INADDR_ANY as target IP address. That means it can't be used to connect, but can be used to bind. If you use it to bind, it'll listen on all network interfaces on that port.
You don't need to compile as root.
Why is gcc using an ld from PATH rather than the one in say /usr/bin? From http://gcc.gnu.org/faq.html#gas &gt; GCC searches the PATH for an assembler and a linker, but it only does so after searching a directory list hard-coded in the GCC executables. Since, on most platforms, the hard-coded list includes directories in which the system assembler and linker can be found ...
Sorry it was about 3AM when I wrote that post. I am looking for cross-platform, but since I am just trying to learn, Linux\GNU is really what I am working on. Your assumption is wrong, I am highly committed and when I said tutorials I just figured book recommendations would come along with the responses. Too be quite honest, I cannot recall which tutorials I looked up. Thanks for pointing out my mistakes. 
Thank you so much, that was very helpful. 
Thanks I didn't even know this existed, I will check it out.
I recommend using POSIX API. Compatibility: Microsoft took original IP implementation from BSD (Berkeley). Berkeley IP API eventually involved in POSIX API. Nearly all unix based operating systems are mostly POSIX-compliant today. So in other words, use POSIX socket and it will work almost everywhere (with only minor changes for MS which can be solved with CPP - predprocessor - macros) You have manual pages in unix based operating systems. You can open them using man command. eg. **man 7 ip** If you don't have unix based OS, you can get them online. For example: http://www.kernel.org/doc/man-pages/online/pages/man7/ip.7.html You have manual page for every function you need. They are just awesome. The link I gave you above describes IP protocol API, so in other words, how to use sockets and other functions to communicate over internet. I recommend you learning POSIX api so you learn how everything works. When you learn API, you'll then easily use any other higher-level abstraction, like Boost for example.
Getting a useful start is usually the hardest. Most of the docs assume you know just this bit, but getting it is near impossible. Know though that all I've written should just about get your first socket app up &amp; running. It is IPv4 specific (there's another sockaddr_in6 for ipv6 stuff) and some of the calls are not entirely clean. Important stuff you'll probably leave out in the near future and then mess up: - Endian ness (htons, htonl above); all network is typically big-endian so if you mess this up you'll not be able to connect. Port 1285 is my personal test port because you can't mess it up - 0x0505 hex is still 0x0505 if you swap both halves. - Forgetting to close ports - Not realising that when you're handling one port, you're typically not running accept() but you are still listen()ing, so connection requests will queue up. Of course, when you get a bit further it's best to use a Boost abstraction (or another one that works well), or to write your own. You still need to understand these parts :-) Shortlist of functions: - Server: socket, bind, listen, { accept } closesocket - Connected client: (accept) recv/send, closesocket - Connecting to server: socket, connect, recv/send, closesocket Unix replacement functions for some (in Unix it's closer to a file, so some functions are shared with the file handling code: - recv -&gt; read - send -&gt; write - closesocket -&gt; close For the rest they're *identical*. Up to WinXP even the implementation was shared. Oh, and there's WSAStartup you need to call on Windows before any socket function will work. I keep forgetting that myself as well.
It's not necessarily a tutorial... Have you looked at [ØMQ](http://www.zeromq.org/)? It's a concurrent socket library that is [available for many languages.](https://github.com/imatix/zguide/tree/master/examples/) 
Check out the pocoproject library, i knew nothing about network code and this helped big time. c++.
Keep in mind that you may have already have a binary named 'test' on the system. root# which test /bin/test Depending on how your $PATH is configured, you may not be running what you think you are...
Some of the best advice another engineer ever gave me was "never compile with the same environment you use for interactive shell work". By that he meant wrap the compile in a script that does an **env -** to completely eradicate the environment, and then you set only the explicit things the build absolutely needs. Then it calls make (or ant or whatever) and that is coded with full paths for binaries like gcc. So you have a team-wide concept of how the system is built, and you're much less susceptible to problems due to aliases, different stuff in PATH, different order of stuff in PATH, another mad stuff. I've seen scripts that also check mount and verify that network mounted volumes, from which tools or resources from the build are taken, are the agreed upon ones for everyone. You can get into endless problems where one person in a team is building with a different version of a compiler, or library, or other tool, than others, so bugs that appear in one compile don't appear in another. By being really careful and explicit about what's involved in building a project, you avoid a lot of voodoo.
The first sentence is correct, the second is not. Perhaps it's outdated, perhaps distros patch this out, perhaps it only applies in the context of systems where there's both a vendor `ld` and GNU `ld`, like Solaris. On my Ubuntu test system, `gcc -print-search-dirs` lists these directories under `programs:` $ gcc -print-search-dirs | perl -nE 'say join "\n", split ":", $1 if /^programs:\s*=(.*)$/' /usr/lib/gcc/x86_64-linux-gnu/4.6.1/ /usr/lib/gcc/x86_64-linux-gnu/4.6.1/ /usr/lib/gcc/x86_64-linux-gnu/ /usr/lib/gcc/x86_64-linux-gnu/4.6.1/ /usr/lib/gcc/x86_64-linux-gnu/ /usr/lib/gcc/x86_64-linux-gnu/4.6.1/../../../../x86_64-linux-gnu/bin/x86_64-linux-gnu/4.6.1/ /usr/lib/gcc/x86_64-linux-gnu/4.6.1/../../../../x86_64-linux-gnu/bin/x86_64-linux-gnu/ /usr/lib/gcc/x86_64-linux-gnu/4.6.1/../../../../x86_64-linux-gnu/bin/ There's no `/usr/x86_64-linux-gnu` on this system so the last three are nonexistent. And there's no `ld` in either of the first two. We can verify this by tracing the filename-related syscalls that gcc makes while linking: $ PATH="/notexist:$PATH" strace -qfe trace=file gcc hello.o -o hello 2&gt;&amp;1 | grep '/ld"' [pid 1763] stat("/usr/lib/gcc/x86_64-linux-gnu/4.6.1/ld", 0x7fffb73de950) = -1 ENOENT (No such file or directory) [pid 1763] stat("/usr/lib/gcc/x86_64-linux-gnu/4.6.1/ld", 0x7fffb73de950) = -1 ENOENT (No such file or directory) [pid 1763] stat("/usr/lib/gcc/x86_64-linux-gnu/ld", 0x7fffb73de950) = -1 ENOENT (No such file or directory) [pid 1763] stat("/usr/lib/gcc/x86_64-linux-gnu/4.6.1/ld", 0x7fffb73de950) = -1 ENOENT (No such file or directory) [pid 1763] stat("/usr/lib/gcc/x86_64-linux-gnu/ld", 0x7fffb73de950) = -1 ENOENT (No such file or directory) [pid 1763] stat("/notexist/ld", 0x7fffb73de950) = -1 ENOENT (No such file or directory) [pid 1763] stat("/usr/lib/lightdm/lightdm/ld", 0x7fffb73de950) = -1 ENOENT (No such file or directory) [pid 1763] stat("/usr/local/sbin/ld", 0x7fffb73de950) = -1 ENOENT (No such file or directory) [pid 1763] stat("/usr/local/bin/ld", 0x7fffb73de950) = -1 ENOENT (No such file or directory) [pid 1763] stat("/usr/sbin/ld", 0x7fffb73de950) = -1 ENOENT (No such file or directory) [pid 1763] stat("/usr/bin/ld", {st_mode=S_IFREG|0755, st_size=838664, ...}) = 0 [pid 1763] access("/usr/bin/ld", X_OK) = 0 [pid 1764] execve("/usr/bin/ld", ["/usr/bin/ld", "--build-id", "--no-add-needed", "--as-needed", "--eh-frame-hdr", "-m", "elf_x86_64", "--hash-style=gnu", "-dynamic-linker", "/lib64/ld-linux-x86-64.so.2", "-z", "relro", "-o", "hello", "/usr/lib/gcc/x86_64-linux-gnu/4."..., "/usr/lib/gcc/x86_64-linux-gnu/4."..., ...], [/* 49 vars */]) = 0 I put `/nonexist` at the front of PATH so that we can see where it stops looking at the built-in list and starts checking PATH. And indeed, that's just what it does, eventually finding it in `/usr/bin/` which it got from PATH. So if OPs `ld` script was in PATH ahead of `/usr/bin`, it would certainly be found first. 
Once you are comfortable with sockets, check out inetd.
This was my guess too. I went through this same thing maybe 20 years ago. Since then I never put "." in my PATH and never use the word "test" for an executable. To OP, happy hacking ganesh.
 man 2 socket connect bind listen accept send recv
 $ strace nc -q 1 www.reddit.com 80 &lt;&lt;&lt; $'GET / HTTP/1.1\nHost: www.reddit.com\n' ... socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 3 connect(3, {sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr("184.51.159.196")}, 16) = 0 read(0, "GET / HTTP/1.1\nHost: www.reddit."..., 8192) = 37 write(3, "GET / HTTP/1.1\nHost: www.reddit."..., 37) = 37 read(0, "", 8192) = 0 close(0) = 0 read(3, "HTTP/1.1 200 OK\r\nContent-Type: t"..., 8192) = 1448 write(1, "HTTP/1.1 200 OK\r\nContent-Type: t"..., 1448) = 1448 ...
recv and send work just fine on sockets in unix. The only difference is the "flag" parameter to recv and send. When passing 0, the functions are identical. However, to maintain an air of portability, you should continue to use send/recv even if you are using no flags.
I was skeptical of eclipse with the C++ plugin, but I really like it now. It's just a shame it's such a resource hog. codeblocks is great, but I had a few wrinkles with it at first that I managed to iron out. Just my unofficial opinion.
I am assuming you are something of a novice-intermediate programmer. If that is the case, I would stay away from ASIO. It uses a very abstract model with heavy use of function pointers, design patterns, and templates to do its thing. Personally I feel that learning the basic posix socket API isn't that hard, and you should just learn that before boost. You will have to learn a bit of multithreaded programming to write "real" production grade applications.
I've watched a really good talk on youtube about the new C++11 features and seen that wikipedia page of new features that is floating around before I started reading Accelerated C++ two months ago, and as a result, I have been able to spot things I know are outdated, namely `for (i = vec.begin(); i &lt; vec.end(); i++)` and using private functions where the new "delete" keyword can be used instead (e.g. copy constructors etc). So, my advice is read those videos of the C++11 even though they are aimed at just showing the changes to those already experienced in C++ so you can mentally flag obsolete chapters when reading through the book.
I am not too sure what level I am, but I know how to use pointers, I know several design patterns and templates. I work very well with abstract models. Thanks for the advice!
Can depend on the shell. on zsh which is a builtin and will correctly identify builtins. (zsh)# which which which: shell built-in command (zsh)# which type type: shell built-in command # bash hegemon@ender:~$ which which /usr/bin/which hegemon@ender:~$ witch type hegemon@ender:~$ Of course *'type'* can let you know which which is which ☺
This is how Windows became so dominant in the ninties. VB, Access and programmable platforms, drop and drop. They live to make programming as easy as possible which is why they have such a wide range of languages from C# to F# to Visual FoxPro. But they are a major C++ user. Windows, Microsoft Office and a lot of their other tools are all written in C++.
It's syntactic shorthand. I think it's okay if you only use it where it is appropriate. So this is bad: auto x = y; // x could be anything. no way to tell and this is good: auto x = myRandomObject.toStdString(); // x clearly a std::string, function name documents this statement. auto y = new QLabel("Name: "); // y points to a QLabel. 
I have no idea how I mangled that title so badly and failed to notice...
Really? Makes perfect sense.
Check the time stamp on this thread. 
oh.. its old... so?
I'm less inclined to dredge up old arguments. Suffice to say that it would surprise me to find a PHD in Comp Sci who didn't know how to program.
Ah fair enough. But I can see ithappening because I know of one incident. But that was more that the guy was fairly mentally questionable. Still. had a comp/math phd
This library (ØMQ) is excellent so far, am using it in Open Transactions: https://github.com/FellowTraveler/Open-Transactions/wiki
Huh. Honestly, I've found the online Boost reference to be very good, and I haven't even ever really considered needing more. So I don't really see the point of this book.
You can delete it, and resubmit with an extra REST parameter at the end (like "&amp;second_try=true"), to keep Reddit from recognizing it as the same one. 
Unless my eyes are deceiving me, the description says it has &gt;250 examples from 38 Boost libraries in 262 pages! It could be an exception, but, I find myself asking how much of the book isn't source code? I've not seen this book so I cannot say anything about it --but the page count + &gt;250 examples for 38 libraries would concern me. If you are new to Boost, the Boost docs plus the wealth of examples that come with Boost (that far too many overlook) are probably the best way to begin to explore Boost. Also most of the Boost libraries have a 5-minute Tutorial page that gives you a clear idea what the library is for as well. Also, all/nearly all of the code presented in the docs is provided in the examples directory as working code. (If you are looking for the example programs look in the html/libs directory for them.)
Some of the boost modules are rather sparsely documented, although it is still one of the best-documented libraries out there, commercial or non.
You can [preview the book here](http://en.highscore.de/cpp/boost/index.html). After a cursory scan, it looks like a good reference to get up and running quickly with the various parts of the boost library, although you'll have to turn to the documentation on the site for more details. Kind of like a basic recipe book for boost.
out of curiosity, why would it not be usable as a buffer for C interop? 
For op[]: &gt; Returns: *(begin() + pos) if pos &lt; size(), otherwise a reference to an object of type T with value charT(); the referenced value shall not be modified. I'm not sure about `.data()` in the final version but most people interpret the above for &amp;str[pos] giving you a modifiable `char*`. 
I mean, for passing to C functions that store data in the provided buffer. Like, string s(1023, '\0'); int len = strftime(s.data(), s.size() + 1, "%y%m", time); if (len &gt; 0) { s.resize(len); return s; } This is not a valid C++03 code, strictly speaking, even if you add a `const_cast` to remove the const qualifier from the value returned by `data()`, because the standard is purposefully vague enough to allow the implementation to store the string as, say, a balanced tree of chunks, and return a pointer to the temporary array with reconstructed contiguous value. ~~That they dropped the const modifier from the data()~~ (*edit:* I had a hallucination!) and demanded for it to work in constant time strongly suggests that they had exactly the "pass a buffer to a C function" scenario in mind. But then there's that remark. I would've understood just demanding that `c_str()` works in constant time, so that you can have copy-on-write strings which still look more or less like what you'd expect. But why remove the const qualifier from the `data()` and then explicitly forbid to modify the values there anyway? This doesn't make any sense, I hope that they've removed it from the final standard.
I know this is ugly/bad, but since it is guaranteed to be contiguous, why cant you do &amp;s[0]?
That's a rather weird wording as well, though I can at least interpret it to mean that "the referenced value" denotes only the case of `pos == size()`. The problem is, it gives you a modifiable `char&amp;` (not `char*`) and does not allow you direct access to other characters at nearby addresses, like, to `*(&amp;(s[0]) + 1)` -- ~~you can do that, but the standard doesn't say that it's valid~~ *edit*: it actually says that it would be a valid pointer, sorry. I'm still not quite sure you're allowed to write to it. Btw, the C++03 description of `operator[]` is even weirder: *"If pos &lt; size(), returns data()[pos]. Otherwise, if pos == size(), the const version returns charT(). Otherwise, the behavior is undefined."* -- but there it says explicitly and without any ambiguity, specifically about the return value of `data()`: *"The program shall not alter any of the values stored in the character array."* Oh well.
Well, I can. I'm also guaranteed that `.data()` gives me exactly the same value, so I probably can just use that. But I find it extremely weird that there's that remark in the description of `.data()`, that I'm not allowed to alter any of the values stored there.
The best rationale that I can think of is that it allows for greater flexibility in implementation. Optimizations that would not be possible if the user of std::string were able to directly modify the contents include Copy on Write and Small String Optimization. It also violates the principle of encapsulation. Member data should never be directly modifiable externally (note I said should, not shall).
Yes it is confusing, although the common argument is that for `str[pos] = whatever` to work, `*(&amp;str[0] + pos) = whatever` *must* work as well because a reference must be returned for the former to work (I'm not sure if an Expression Template is actually validly returned there...oi).
If you need a buffer for C-interop, use std::vector&lt;char&gt;.
But then I would have to convert it to a string, that's inefficient!
Or there might be a possibility that the non-const version of the `operator[]` could do _something important_ besides returning the reference, while `.data()` for some reason doesn't do it, and all they say about the addresses of the returned objects being exactly equal doesn't contradict it! **EDIT**: In fact, that's exactly what GCC 4.6.1 implementation does o\_O
The problem with using a std::string as a buffer is that a std::string keeps track of the length. If the C library function copies a shorter string (putting a null terminator in the middle of the buffer), then the std::string will return an incorrect value for std::string::length() and std::string::size(). This can really screw you up elsewhere.
C library functions usually return the length (to which you then should resize your string) and guarantee that there are no nuls inside. To put it another way: if don't trust the C function to do the right thing and therefore use a `vector&lt;char&gt;`, how exactly are you going to convert it to a string? If you use the `string(const char *)` constructor then you risk a buffer overrun if the function forgot to add the NUL terminator, if you use the `string(const char *, size_t n)`, then it would happily copy all the embedded nuls.
&gt; C library functions usually return the length (to which you then should resize your string) and guarantee that there are no nuls inside. Some do. You suggested using std::string as a buffer which is a really broad statement. &gt; If you use the string(const char *) constructor then you risk a buffer overrun if the function forgot to add the NUL terminator push_back() a null terminator prior to conversion. 
If a function might fill the buffer with data containing null characters (for example, `read()`), then you should use the length it returned. If you want to convert the data to string (what could possibly go wrong with that?)
If the buffer contains null characters in the middle, then std::string is a really bad container. That's why std::vector would be better for things like read(). That was my original suggestion.
&gt;Does anyone here have access to the final standard, is that still there? I do. 21.4.7.1 (3) The program shall not alter any of the values stored in the character array. &gt; What gives? OK so why do you even want to use std::string as a buffer for C libraries? If your C lib returns a const char* you can easily dump it into std::string because most implementations will have a COW implementation that makes accessing this cheap, unless you actually want to modify the string, in which case it makes it automatic to copy it somewhere and do so. If your C lib expects you to allocate everything for it, then what's wrong with std::vector&lt;char&gt;? You can do a lot of the same stuff with it using things from std::algorithms and again the COW implementations of std::string make dumping it into that nice and cheap. I suppose it might possible to shoe-horn in a method in which a std::string to take ownership of a std::vector&lt;char&gt; somehow the standard mostly seems to avoid having entire containers become invalid in potentially unpredictable situations. They'd probably be non-trivial locking overhead in std::vector to protect it from getting randomly ganked by roaming gangs of std::strings in multi-threaded apps for example.
&gt; If the buffer contains null characters in the middle, then std::string is a really bad container. std::string::end() is the sentinel not NUL. std::string is fine with NUL inputs unless you use it's NUL terminated sequence support incorrectly. 
&gt; If your C lib returns a const char* you can easily dump it into std::string because most implementations will have a COW implementation that makes accessing this cheap, unless you actually want to modify the string, in which case it makes it automatic to copy it somewhere and do so. Even a COW string (which multicores are making impractical) will have to copy a `const char*` because it has no control over the lifetime of the `const char*` and has no control of when a write happens there in order to know to copy. A `std::string` is self contained, remember. &gt; OK so why do you even want to use std::string as a buffer for C libraries? Wanting to do this makes sense to me. You have a `std::string` you're working with and, at some point, you want to efficiently pass that string to a function that takes a `char*`. This is unlikely to happen much in pure C++ code but the real world is messy. As far as my reading of the standard, it is not guaranteed, but more than likely that passing &amp;s[0] to said function is safe.
&gt; If your C lib returns a const char* you can easily dump it into std::string because most implementations will have a COW implementation that makes accessing this cheap, unless you actually want to modify the string, in which case it makes it automatic to copy it somewhere and do so. I don't think COW works that way. It works only between cooperating classes. When you construct a string from a `const char*` or a `const vector&lt;char&gt;`, you still have to make a copy immediately because nothing guarantees you that the source will remain unchanged (or even alive) for the duration of your lifetime. Non-const references are convertible to const-references, so constness only demands guarantees from the user, without providing any. So that's why I want to use the string as a buffer immediately, without any intermediaries. Anyway, thank you, I finally did what I should have started with: looked into the GCC headers. First of all, I discovered that the lack of const on `.data()` was my hallucination :(. Then, they do indeed use COW, do allocate a new buffer in the non-const `operator[]` (if the current is shared), but do not do it in `.data()`. So I guess I should use &amp;s[0] then. I can almost convince myself that with new contiguousness requirements it should be guaranteed to work.
While this is true, C functions don't normally return "strings" with null characters in the middle. A general rule of thumb for C++ is if you need a buffer, use std::vector. If you need a string, use std::basic_string. Yes, there is no good way to have a C function construct a std::string for you (or any other C++ object for that matter). If you are really, really concerned about performance and you know your STL implementation will correctly support the use of std::string in this way, and you're not concerned about portability, then you can do the following: std::string s(maxSize, '\0'); int charsPrinted = snprintf(&amp;s[0], s.size(), "pi = %f", 3.141592653589); if (charsPrinted &lt; 0) { handle_error(); } else { s.resize(static_cast&lt;size_t&gt;(charsPrinted)); } // s will on many systems be what you expect. 
Take a look at [Ace](http://www.cs.wustl.edu/~schmidt/ACE.html)
&gt;If your C lib returns a const char* you can easily dump it into std::string because most implementations will have a COW implementation that makes accessing this cheap, unless you actually want to modify the string, in which case it makes it automatic to copy it somewhere and do so. MSVC and GCC both moved away from COW strings loooong ago. Instead they both favor the small string optimization instead which typically benchmarks a lot better for most use cases.
&gt;User guide #include &lt;mutex.h&gt; ... cpptask::Mutex guard; ... { cpptask::ScopedLock(&amp;guard); // synchronized work ... } Ouch.
The specification for `operator[]` really has changed. The previous version you mentioned (relying on `data()`) was broken on const correctness grounds. I reported that many years ago on `comp.std.c++`, a formal defect report resulted, and it looks like the fix has worked its way into C++11. There is no need for interpretation with the new version mentioned by sausagefeet above, because both `operator[]` and `begin()` have both const and non-const versions, so everything can be consistent either way.
Cold startup for any WPF app seems to average around 10 seconds on a recent computer, ugh.
Create your own C++ class that does what you want string.data() to do and pass the string in to that and pass that around? snprintf( emulate_c_string_char_star_but_really_i_am_a_cplusplus_class( some_std_string ), some_std_string.size(), "You're absolutely mental" ) Override operator* ... done. Edit: PS This is complete nonsense.
&gt; Evernote 4 is a major departure from Evernote 3.5 in every way. I hate it when developers do a complete rewrite and just bump the version number.
what do you prefer they did? give it a new name and lose all brand recognition?
You'd expect with the amount of ram you've got these days they would leave those drawing libs just sitting in memory waiting to be called...
I agree -- what other solution is there? Doing it any other way would just cause confusion in my opinion. To the end user, rewriting an application doesn't mean much so long as it performs the same tasks.
I guess I'd call it "Evernote Native," deprecate the old version, quickly ramp up the version numbers as you reach feature-parity and then drop the "Native" from the name. If they're *at* feature parity and everything works well enough I don't see a problem with skipping a few steps, though. Why worry what it's built on if it's the same but faster, less memory-hungry and with fewer dependencies?
&gt;If they're at feature parity and everything works well enough I can see your logic there and definitely agree with that. Not knowing the application I'm not sure where it's at in comparison to the 3.5/.NET version, but you're definitely right. Until it meets the features of the current release, branch it off while building and slap a beta tag on it or something.
"something important" ??? This has me all very confused. I thought I new strings well enough, but now I have to figure out what all the little differences between data() c_str() and operator[](0) are.
&gt; Why worry what it's built on if it's the same but faster, less memory-hungry and with fewer dependencies? Because 3.5 was awful and getting worse. They needed to publicize the change to make it clear they'd really knocked the issues on the head. And they really, really did an excellent job on it.
I believe GCC will use different implementations depending on various circumstances but haven't dug through the code enough to confirm that. The GCC documentation still claims that std::string has copy-on-write behaviour at least some of the time. 
There is absolutely no reason to be finding factors and then getting prime factors from those. If prime factors are all you want just do this: // get input and store to number ... // put prime factors in primeFactor if(1 &lt; number) { quotient = number; unsigned long current = 2; while(current &lt; quotient) { if(quotient % current == 0) { primeFactor.push_back(current); quotient /= current; } else if(current == 2) current = 3; else current += 2; } primeFactor.push_back(current); } // display results ... That will give you all the prime factors of any number without having all that redundancy. You could also probably print out the prime factors as you find them for greater efficiency. On an unrelated note, I noticed some of your loops look like this: for (int j=0; j&lt;=primeFactor.size()-1; j++) {...} When they could simply be like this: for (int j=0; j&lt;primeFactor.size(); j++) {...}
In my opinion it's borderline dishonest. A jump from 3.5 to 4.0 implies an incremental improvement, but you've actually started over from scratch. All we know is that you tried to replicate/improve the feature set. Since the new product is not mature, there will be bugs and issues that you wouldn't expect in a 4.0 release.
TinyEarl has basically solved your problem, but I'll also point you toward [memoization](http://en.wikipedia.org/wiki/Memoization). It's essentially caching the results of your `ChkPrime` function for future calls so you don't have to recompute `ChkPrime(n)` when you've already computed it before.
You are right, my statements about COW are entirely wrong :) &gt; This is unlikely to happen much in pure C++ code but the real world is messy. As far as my reading of the standard, it is not guaranteed, but more than likely that passing &amp;s[0] to said function is safe. I think it's safe (i.e. you won't segfault) for the function to write to that array up to s.capacity() bytes but it's not entirely obvious how to then provide the string with the new size information. After the C code writes into that buffer, s.size() will still have the old value. s.resize(new_size) isn't safe, because it's probably only going to copy up to s.size() out of the old buffer. s.reserve(new_size) won't change s.size(). So that means you have to make sure s.size() is right *before* you call into the C library and that's not always possible. Some sort C &lt;-&gt; C++ compatibility layer that had access to the internals of std::string etc to fix everything up would probably be a useful addendum to the standard somewhere.
&gt;There is absolutely no reason to be finding factors and then getting prime factors from those. I wanted that feature. Thanks for the *for* tip! Edit: I'll probably remove the factor vector part just to try your method.
Yeah, I need to fix that. Should be easy.
I'm not sure I'm good enough to do this.
Perhaps "Evernote NG" 1.0 would be a more appropriate version.
&gt; This is unlikely to happen much in pure C++ code but the real world is messy. Nah, in properly written C++ code, you do not need to ever use C string functions.
IMHO Incremental Improvement does not only mean new features. If the software loads faster, runs faster, and works batter (lower memory footprint etc...) than thats a tangible change That is worthy of major version bump. about your second point, that is true but that can also be solved by a lengthy Beta testing and good QA. 
Too bad it's not open source.
One optimization: you could replace the loop condition while(current &lt; quotient) with while(current*current &lt;= quotient). This makes the running time O(sqrt(n)) instead of O(n).
&gt; I wanted that feature. Even if you want to print all the factors instead of just the prime factors, it would still be better to do things the other way: First find only the prime factors and then generate all their combinations to get all the factors. This is much faster because to find the prime factors you only need to test numbers at most sqrt(n) whereas for all factors you need to go up to n/2.
It's actually not that hard. It would look something like this (untested): // Typedef for convenience (saves some typing) typedef std::map&lt;unsigned long, bool&gt; ChkPrimeMap; // Global map that will memoize ChkPrime results ChkPrimeMap prime_map; bool ChkPrime (unsigned long number) { // See if the result has already been computed ChkPrimeMap::iterator iter = prime_map.find(number); if (iter != prime_map.end()) { return iter.second; } // It hasn't, normal ChkPrime logic goes here bool result = ... // Store the result in the map before returning it prime_map[number] = result; return result; } 
GCC uses copy-on-write (COW) strings, which means that they basically incorporate something like a `shared_ptr`, each actual string buffer has a reference counter, each time you copy a string, nothing actually gets copied but the reference counter increases, the string destructor decreases the reference counter and deallocates the buffer if there are no more references. Plus, of course, before each operation that will or can change the buffer contents, the string creates its own copy of the buffer if it was shared. So, the non-const `operator[]` does this check, while neither `c_str()` nor `data()` don't.
The big performance killer I see in your code is your vector, you are just pushing back blindly into to. The worst case for this is that it has to reinitialize and copy across all the elements each time your push back. To make this is more efficient you can reserve memory, this way when you push back it uses the already allocated memory. I would choose a high maximum estimate of the number of items that will fill the container. factor.reserve(number/2); factor.reserve(number/4); now you have at least number/2 elements you can push back before requiring to reallocate. These aren't performance improvements as such, but it is good practices to use angle braces for library code ie #include &lt;vector&gt; Also although for a project of this size you generally should avoid importing a namespace. Finally there is a C++ idiom for printing every values in a container. #include &lt;iterator&gt; ... //print all factors std::copy(factor.begin(), factor.end(), std::ostream_iterator&lt;double&gt;(std::cout, " ")); 
Now that is a saving!
&gt; s.resize(new_size) isn't safe, because it's probably only going to copy up to s.size() That's why instead of `s.reserve(1024)` you do `s.resize(1024, '\0')`, problem solved!
Pushing to a vector is actually quite a fast operation and it is guaranteed to work in amortized constant time. The number of factors is usually quite low anyway so a few push_back calls aren't going to be the bottleneck.
True enough, but since he can easily get a pretty good estimate of the size required, there is no reason not to use that estimate when initializing the container. 
Cold startup means they need to be loaded. With lots of RAM they probably stay there after.
You are right, though number/2 is certainly not a good estimate for the number of factors. There are O(log n) prime factors of n, so allocating that much might is enough. I' not sure whats a good bound for the number of all factors but you can easily calculate the exact number once you know the prime factors.
Did you see some problem here? What did you mean? 
lolwut
ScopedLock is most probably a simple RAII class. Above is creating a temporary ScopedLock, which means that 'guard' is locked only at the statement where the temporary is defined - '//synchronized work' comment is then, in fact, outside critical section. Unfortunately there is not way in C++ (afaik) to guard against this bug.
I know, but I was more indicating a surprise that they aren't loaded at OS boot, at least some of the OS windows have to be touching them at some point or another. Unless that stuff is still running on the native code window libraries.
If you're looking for a more optimal algorithm in general, see http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes. 
That doesn't mean you won't be interfacing with some C library that plays with strings.
I haven't seen any C libraries that **modify** C strings.
Better to compare current to sqrt(quotient) rather than compute current*current each time through the loop.
what UI library are they using now then? plain win32 api? or some native wrapper like QT or GTK? didnt find anything about it on the article.
WTL
I agree. It's a very nice client and I would love to see how parts of it work. Since they give it away, I'm not sure why they don't open source it.
Exactly, especially since they essentially sell an online service, I don't think the code is really critical to them. They could always add a "non-commercial" clause to their license if they really fear the competition.
&gt; at least some of the OS windows have to be touching them at some point or another I don't think that any core OS functionality is .NET/WPF in Windows (up until 8, which might have some).
I don't understand what you are trying to say here. C libraries manipulate C strings all the time, it's not unheard of having to interface to a library written in C from C++.
there's plenty of open source projects at sourceforge, you should have no problem finding something interesting...
&gt; my C/C++ skills. First piece of advice: choose. C and C++ are widely different, and if you try to program in C++ like you'd program in C, you'll fail miserably.
What "C/C++ skills" do you currently have?
Thanks, i see now. It's a typing mistake I've fixed it. 
just take a random problem or an idea and work on it. What is important is that you code and work on something and keep at it. Anything goes: a simple game, graphics demo, compiler, web crawler, calculator, file packer, line counter, ...
Guess I am not sure. It has been since like 2006 and we were using DirectX 9c in one of the classes. We touched on everything from data structures to AI.
I suppose you're right that the two are widely different. I guess that I would lean way more towards C++ then instead of C. I suspected we mostly discussed the differences between the two languages. However did have one class were it was all assembly, that was certainly different.
I do something like that in my ChkPrime function
Is this faster?
Good idea! Thanks!
I don't know what the high estimate actually is I aren't going to think about it. Wasting a little bit of memory to improve speed is fine by me especially for primitive types. Different platforms have different qualities of STL implementation, reserve before push is always going to be faster
From my point of view (C++ programmer), C and assembly are not very different. Anyway, I've got a feeling that you don't really know C++. I recommend Accelerated C++, by Koenig and Moo. Very good book, short and to the point. Take the test: have a look at the [GotW](http://www.gotw.ca/gotw/). (Hint: Start at the bottom.) If it speaks to you, you're ready to read Exceptional C++; if it looks too complicated, then Accelerated C++ is your best bet.
This is a classic example of doing something wrong because of pre-/misconceptions about what is slow and what isn't. `std::string` is not guaranteed to be suitable for backward compatibility with C libraries, but it doesn't matter, because `memcpy` really isn't as slow as you think it is. Of course it would be better to just stick with either C strings or `std::string`, but when you can't, don't worry about it. Unless of course you have specific profiling data suggesting that string conversion is indeed a bottleneck in your application — if that is the case, I would strongly suggest that you either use a C++ library that supports `std::string`, or roll your own string class that *does* provide the memory layout guarantees that C strings require. :)
I don't really know how namespace works. I just know it has something to do with cout/cin.
Yes, it's the same big-O, but faster by a constant.
It's more of an aesthetic issue, really. C++ is supposed to not have unnecessary runtime costs, at all, except for those you've decided to inflict upon yourself. I understand that creating a string from a `vector&lt;char&gt;` is really, really, cheap. Really. But it is still unpleasant, aesthetically. It's unnecessary. It goes against the C++ ethos. Anyway, after doing my homework so to speak I've become reasonably sure that using &amp;s[0] would work on all relevant implementations and is _guaranteed_ to work on all C++11-conformant implementations. I'm not entirely sure, but I can't imagine how any sane implementation could break it.
I agree with what you said but number/2 might not be small; factoring is fast enough that we could well calculate the factors of numbers of order 10^12, but at least my machine doesn't have that much memory. As I said, the standard requires push_back to work relatively fast, and the number of calls to it will be very small compared to the number of other operations we are going to do so optimizing it will probably not make any noticeable difference. (Though I agree that it's better to reserve anyway if we know how much space we are going to need but just wanted to point out that we might waste more than just 'a little bit' of memory.)
big-O?
Thanks for the advice on the books. Not sure about the breadth of my knowledge of C++. I understand that it is it a bit old and probably rusty. And the site you linked might have some advanced topics. But the program I went through looks like it covered a lot of the concepts mentioned. I will review them again in detail. The program ended with two different projects of a 3 and 7 person team completed a game in 2 and 5 months respectively.
[Yup](http://en.wikipedia.org/wiki/Big_O_notation).
No problem. This is really one of the places where C++ could use some compile time reflection. It's always an error to have a temporary of ScopedLock type.
Thing is, I'm not sure what language you actually learned. Unfortunately, some teachers teach C while pretending to teach C++. Basically, if you use `delete` a lot (or if you use `delete[]` or `free`), you probably haven't really learned C++.
As someone who's used C++ and only seen some "C-style" code very rarely, can you quickly explain how they're so different?
The lack of aesthetics is not in the hoops you jump through to achieve interoperability with C, but in the fact that you need it. :) Prefer a pure C++ implementation instead. If that is completely impossible, copying *will do fine*. I would personally prefer using the API in the way it was intended, if it is a C API: With pure C strings, and then delay converting to `std::string` until the latest possible time. Perhaps wrapping it in a custom `StringBuffer` class. &gt; I'm not entirely sure, but I can't imagine how any sane implementation could break it. The internal representation of `std::string` is not guaranteed to be zero-terminated! This means that passing `&amp;s[0]` to a C library function expecting a zero-terminated string is bound to break mysteriously. Remember that that's the worst kind of breakage. :P It is perfectly reasonable to imagine a "sane" implementation that doesn't guarantee zero termination — several optimizations can be implemented if there is not an internal zero-termination requirement.
A namespace is a context in which code is grouped. For example everything publicly accessible in the standard library is in the std namespace (of it's children) and everything in the boost library is in boost. using namespace whatever; merges together the current namespace and the on you are using. instead use: std::cin &gt;&gt; i; std::cout &lt;&lt; i; std::vector&lt;int&gt; v(i); or specifically the element you want to use using std::vector; and so on.
I should point out this really won't have an affect on performance (or at least it is unlikely too) but it is considered good practice.
Well perhaps, if you envision push your machine in terms of memory I think using a deque might be a better idea anyway. But for performance a reserved vector would still beat it and I am fairly sure just pushing back would to be noticeably slower.
Yea that is the trouble. It was a mixture of both. when we were programming for the ps2 it only accepted C style so we have to use delete/free. Programming our game project I was fairly certain it was C++, but now you have me questioning things.
Well, of course, there's the obvious: object-oriented programming is far more natural in C++ than it is in C. But mainly, a C++ compiler takes care of a lot of stuff for you. `-` Resource allocation, of course. You never have to release memory, or close a file, manually. The compiler does that for you. More importantly, it means you don't have to keep track of the memory you allocate. Take this code for example: string f (string a, string b) { string const ba= b + a; g(); string const ab= a + b; h(); return ab; } int main() { cout &lt;&lt; f ("Hello ", "World!") &lt;&lt; "\n"; } You can be sure that the memory allocated in `f()` will be released properly, even if `g()` or `h()` throws an exception. And you know the exact moment where it's released (Which is not so important for memory, but far more for files, sockets, mutexes, etc.) That also means that memory leaks, buffer overflows, etc., don't exist in C++. `-` Type inference. Just compare C's `qsort` and C++'s `std::sort`. Basically, in C, you have to give up on the type system, and go back to assembly-style raw memory (a.k.a. `void*`). In C++, you keep the types, and thus the type-checking by the compiler. And between templates and `auto`, you don't even need to type the type names explicitely if you don't want to. ----------- Edit: Also, arrays and strings are first-class objects. 
[TV Tropes has a page describing that kind of programming](http://tvtropes.org/pmwiki/pmwiki.php/Main/EldritchAbomination).
&gt; The internal representation of std::string is not guaranteed to be zero-terminated! Even in C++11? They don't say it explicitly (and I would much rather prefer a standard that states the goals explicitly, really), but it _seems_ that they do require storing that terminating NUL in the string data. &gt; I would personally prefer using the API in the way it was intended, if it is a C API: With pure C strings What could possibly go wrong if I use std::string as a buffer for `read`? I mean, I know what could go wrong, C-style logging. I can deal with that. What else?
I don't think this is correct. Of course C++ can have memory leaks. You can allocate something with the new operator and forget to delete it later. What you're talking about is that the destructor of the string class in the STL takes care of freeing the underlying buffer holding your string for you. That's different than the C++ standard supporting some sort of automatic memory release. Also, C is a very strongly typed language. Sure it supports void*, but that doesn't mean that that is all you have. You don't have to give up on the type system. What?!
Look at some of the libraries in the Boost project. If you can figure out how they work, you'll have learned a lot about C++. 
Many C++ programs need only have one instance of the `delete` operator in the entire program (and usually that can come from a/the standard library in the form of `std::shared_ptr`).
The most obvious difference is classes. You can (and some people do) do object oriented programming in C (through the use of structs and function pointers mainly), but in C++ you'd use the language features to do that. Errors are a big one. C can manifest exception-like behavior with the longjmp and setjmp facilities, but C++ exceptions are a bit easier to use. As a result, C code uses global variables to set error state or special return values. This makes it a lot more onerous to properly handle exceptional events. Templates and operator overloading means you can do stuff like have a generic sort function (as C++ does) that doesn't require two void pointers and a comparator, as C does. This leads to greater ease of inlining by the compiler, for instance, which can be an efficiency gain. The use of templates makes it a lot easier to support a whole different sort of programming than you get with standard C. C++ constructor/destructor semantics means you can use RAII as a means of resource control, to help prevent deadlock for instance. C doesn't have the means to use this resource control mechanism. There are a lot more differences than what I just named, but that's a start. Of course, C is _almost_ a subset of C++, so most valid C program's could be compiled with little to no modification with a C++ compiler, so in that sense there's almost no difference. The thing is, if you are writing C++ in that mindset, it's not idiomatic C++, it's C. There are cases where you might want to write in what is effectively C, plus function overloading, or C but with templates though. Not every project needs every feature of C++, or even most of its features, but the more of the features you use, the less it looks like C.
You do tend to use more void pointers and the like in C than C++, but when I write C the compiler gives me plenty of help with type checking. Memory and other resource leaks are possible in C++. You can mitigate it with certain programming practices, but it's definitely something one has to be vigilant about. Memory leaks are even possible with GC languages like Java if you keep references around longer than you need to. 
Try the challenges on http://osix.net or http://projecteuler.net - there are other languages more suitable for some challenges than C/C++ but still doable and you'll learn a lot. I'd perhaps advise learning C first, since C++ builds heavily (REALLY heavily) on top of it, but others might disagree with that.
Different is probably the wrong word. While not a complete superset of C, C++ has most of what C has to offer. It also adds a massive set of additions for programming paradigms for which C is not well suited, and if you don't learn to think in terms of those paradigms you'll likely end up misusing the extensions to write really bad code. Since C++ has far more implicit behavior, if you don't understand a large portion of the language additions you'll never be able to predict what someone else's code will do so you won't be successful in maintaining or extending that code. As a tangent, I'd suggest finding a "theory of programming languages" course (online?) which will give you better insight into structured programming, procedural programming, object oriented programming, generic programming, functional programming, logic programming, etc... You'll get insight into how to solve problems in completely different ways, and how a range of languages make certain approaches easier or more difficult (assuming it's a good course which forces you to write code in a number of languages!) As another tangent, the only reason to use either of these languages is performance, and both are far more complex than most of their users realize (I could easily write a quiz on C that no more than 1 in 1000 people at my company could ace.) If you don't know what's going on under the hood to exploit the performance aspects of these languages you're simply causing yourself and those who will suffer maintaining your code excessive grief.
[Effective C++](http://www.amazon.com/Effective-Specific-Improve-Programs-Designs/dp/0321334876/ref=pd_bxgy_b_img_b)
Start your own small project - something of your interests. Fuck someone else's open source project. Fuck lame book exercises - books are for looking back into when you can't figure something out (but check StackOverflow first!). As for the project - pick something small, but something a little cool to make up for the small. I would suggest creating your own library, something that can exercise your design skills, take advantage of templates, etc. Preferably, something you could use later on. What about a debug rendering library? Something to allow you to render debug 3D graphics (say rendering them with SDL), you could provide basic primitive types, translucency, rendering text at 3d locations. Calls would have a lifetime, etc. Or maybe you would want to create a simple vector library with common linear algebra options - experience with vector unit programming. What about procedural content library - procedural landscapes, procedural dungeons, street layouts.
&gt; Even in C++11? They don't say it explicitly (and I would much rather prefer a standard that states the goals explicitly, really), but it seems that they do require storing that terminating NUL in the string data. Where? All references I can find state that `.c_str()` is required to return a zero-terminated string, while `.data()` is not. &gt; What could possibly go wrong if I use std::string as a buffer for read? I mean, I know what could go wrong, C-style logging. I can deal with that. What else? Everything mentioned in this thread, for instance? Look into `fstream` and friends instead of `read`.
&gt; C is a very strongly typed language. Here's an exercise for you: write the equivalent of `std::sort`, i.e. a general-purpose sorting function, with strong typing, in C.
I always say C/C++. Personally, I like procedural programming a little more, do I write code as if it is C, but I'm usually writing C# or C++ programs. If you're someone who leans more towards C++, I would say to just say C++ plain and simple, but if you are like me, and you write procedurally, and sometimes OOP, then it is valid, I believe, to say C/C++. Essentially, C++ is just C with Classes.
I believe I have a sense from this and some of your other postings why you did not find a games programming job or programming job in general. It really sounds like the program you where involved in suck, and that is putting it mildly. Worthless is another kind way to describe it. The problem as I see it is this, how was it possible to get through the program and not know the differences between C/C++. Further any credible program would have strived to teach you to properly program in C++ and kept the system specifics in another class. From what you have stated they didn't even try to do this. As to C++ being rusty, nothing could be further from the truth. In fact we have a brand new standard. C++ is not one of those brand spanking new scripting languages but it is a powerful compilable language to engineer software around. Accelerated C++, already mentioned in this thread, is one of my favorite get me started books so do read that. However keep this in the back of your head, we have a new standard, repeating we have a new standard. I say this because what is considered good C++ practice will change significantly. Be prepared to adapt to the new functionality that will soon be widely supported in compilers. If you are about to learn to properly programming in C++ do so in a way that incorporates the latest techniques. By the time you get proficient, a year or two, programming to the new features will be common. At the moment though there are few texts to reference with respect to the new standard so Accelerated C++ is a good place to start. 
&gt; Where? http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf The part about c_str() and data(): &gt; Returns: A pointer p such that `p + i == &amp;operator[](i)` for each i in `[0,size()]`. Note that the range is inclusive. Which, as far as I understand, means that the terminating zero must be stored in the same array (despite the description of the `operator[]` itself being elusive to the point where it seems to allow returning a reference to the sentinel stored elsewhere when `index == size()` is passed). &gt; Everything mentioned in this thread, for instance? Huh? I don't see anything about the actual dangers of having embedded nulls in an std::string. &gt; Look into fstream and friends instead of read Yes, sure. But there still are a lot of C-only APIs out there.
If you want to start writing in strong C++, use gcc with the following flags: -Wno-variadic-macros -Wuninitialized -Wcast-align -Wredundant-decls -Wno-unknown-pragmas -fdata-sections -ffunction-sections -pedantic -Wextra -Weffc++ -Wno-long-long -Wold-style-cast -Wstrict-overflow -Woverloaded-virtual -Wsign-promo -Wabi -Wmissing-declarations -Wall -Werror These are the flags that I insist on at my company. The above will warn on loads of c-style coding and won't compile until you fix all warnings. It will also stop various errors such as uninitialised variables, incorrect sign casting, dead code, etc. If you want to go slightly more strict, use the above with clang instead of gcc. The only time you will run into problems is when you try to use the above flags with third party libraries. But usually, fixing the library's headers isn't much work.
&gt; The ideas I do seem to have are so massive that no one person could take them on. Make something simple first. Think basics like chess, othello, solitaire, etc. You will learn a great deal making simple games. Even a veteran game developer will stare at a project like a deer in headlights if the scope is too large. The odds are you will need an artist eventually. Programmer art will only go so far. Don't be afraid to collaborate. There are plenty of websites with art for sale. The same goes for game music and sound effects. Look at what's already available. There are projects such as [irrlicht](http://irrlicht.sourceforge.net/), [ogre](http://www.ogre3d.org/), [love2d](http://love2d.org/), [gamemaker](http://www.yoyogames.com/make), etc. Commercial engines such as [Unreal](http://udk.com/) are also available with [licenses suitable for indy development](http://udn.epicgames.com/Three/DevelopmentKitFAQ.html#Licensing). Install unreal tournament 3 and try making a new map or weapon. 
&gt; Note that the range is inclusive. Which, as far as I understand, means that the terminating zero must be stored in the same array (despite the description of the operator[] itself being elusive to the point where it seems to allow returning a reference to the sentinel stored elsewhere when index == size() is passed). No. One might easily imagine a string implementation, where the trailing zero is not added before `c_str()` is called. This could be beneficial in a string implementation that does copy-on-write for substrings. (Yes, I realize `std::string::c_str()` is marked `const`, but for certain interpretations, and given the availability of the `mutable` keyword, this is still no guarantee for the data layout!) &gt; Yes, sure. But there still are a lot of C-only APIs out there. Don't use them with C++ classes. You are basically asking for trouble. If you're using a C library, use it the C way, or don't use it at all, if you want to be safe. There is *no reason whatsoever* to use `std::string` as a thin wrapper for C strings. If you *do* need a thin wrapper for C strings, *write your own class* that guarantees the same behavior as is expected from C strings. I.e. `str.length() == strlen(str.data())`, and with transparent memory management.
&gt;C++ is just C with Classes.. ...templates, exceptions, references, extra libraries and keywords.
Note: long long is a C++11 type now, so the flag -wno-long-long should probably be removed from this list. Other than that I agree 100%: these flags will help you to write clean C++.
The key thing to know here is that the header files don't get compiled. They get included in the .cpp files, which are compiled, but the headers don't get compiled. Think of a header file that gets inserted into the .cpp file at the point where it says `#include "header.h"`. For that reason, it does not make sense to include your .cpp file in the header file. Also for this reason as well the header files should never contain anything that's dependent on stuff in the cpp files. In fact, if you use the header files for making only function declarations and class definitions, the header files will not contain anything that would depend on the cpp file.
You seem to have it the wrong way round. The xxx.cpp file should #include the header (xxx.h) file, usually as the first include in the file (this ensures the header file includes any other header files it requires). The header should also define an include guard to prevent it being included multiple times. E.g. (xxx.h) #ifndef XXX_H_GUARD #define XXX_H_GUARD #include &lt;string&gt; class Xxx {std::string name;}; #endif (xxx.cpp) #include "xxx.h" // xxx stuff. 
&gt; No. One might easily imagine a string implementation, where the trailing zero is not added before c_str() is called. This could be beneficial in a string implementation that does copy-on-write for substrings. This is an interesting point. And scary, too, because if true, it would mean that accessing elements via `*(&amp;s[0] + i)` can backfire too. On the other hand, there's the requirement 24.4.1.6, which says that pointers, references and iterators referring to the elements can't be invalidated by const member methods, which seems to prevent that kind of stuff. On the third hand, I'm not sure how the part about the non-const operator[] allows even the basic COW though (it's not important for what I'm trying to do by itself, but might mean that I misunderstand something). Note that the C++2003 also specifically included `c_str` and `data` in the list of functions which may invalidate iterators, here there's no such requirement. &gt; If you're using a C library, use it the C way, or don't use it at all, if you want to be safe. There is no reason whatsoever to use std::string as a thin wrapper for C strings. I don't understand how I should do that in practice. Suppose I want to call `snprintf` or `strftime`. I want the result as an std::string, I don't want to continue working with it as with a C string, I don't want to use std::string as any kind of a thin wrapper over the C string, I don't want to use any kind of custom wrapper. I just want the function to store its result in my damn string. I'm guaranteed that there wouldn't be any embedded nulls (though I'm yet to see any argument about what possibly could go wrong about them), these functions do not depend on the existence zero-termination of the buffer even. Yes, I can use a temporary buffer, but why should I have to? It seems very un-C++, and I don't understand what's the point of adding the contiguousness requirement in the new standard then.
The only safe and correct way to use `snprintf` or `strftime` with `std::string` is code similar to this: std::string foo(const char* format, size_t max, const va_list&amp; ap) { char buffer[max+1]; vsnprintf(buffer, max, format, ap); buffer[max] = '\0'; return std::string(buffer); } But the important argument here is this: *You shouldn't have to use `snprintf`!* Instead, it is almost always better to use `std::stringstream` and friends.