I still try to learn C++11 features, is it something wrong me? 
I migrated less than 2 weeks ago the boost.serialization code for a personal project (a cards game) that uses serialization with a server + 4 players to connect. I wanted the server to run in a raspberry pi and clients to communicate with each other (Mac for now, later will be phones also). It took me a couple of hours to migrate to cereal to use the portable binary format. It gave me, literally, zero problems and run at first try in my raspberry after the migration.
Oh god, please no. If this ends up running QML, it's probably getting the world record of "most useless abstractions in a single program". I've already got enough webpages needing JavaScript to show up and awful electron apps, this is the same.
Building it now! Woo! I'm really excited to start experimenting with the beast library.
Ah alright, I get you. I agree. It's still definitely a work in progress.
Modern C++ is making game development a more portable and performant. I guess we will see lots of advancements in the next decade.
Nothing wrong at all, especially if your company hasn't yet moved towards the adoption of C++11 and beyond. Just keep a wary eye out for those C++11 features which have already been deprecated.
&gt; has pre-conditions as well, but these aren't any different from the pre-conditions in the rest of the std::vector interface. push_back is much more idiot proof than calling copy with vector iterator dest. In fact beside infinite loop and OOMing it IDK how to abuse push_back. But I understand that sometimes it is too expensive to bother to clear the vector and that sometimes you work with APIs that want int* pointer as output so you need .data ... 
The reflection proposals look particularly interesting.
std::parallel / concepts / std::filesystem ... I built a couple of game engines from scratch and everything seems to be going on the right direction ! 
I have not been keeping up to date with c++17 and I just skimmed the part about structured bindings. There's lots of code examples, which I strongly favor, and a lot of niche uses and edge cases are explained as well. I would say it's like reading the good responses here on Reddit, or the good stack overflow answers about language features. So far, I think it will be well worth it. 
&gt; push_back is much more idiot proof than calling copy with vector iterator dest. Copy doesn't pushback, the alternative to `ranges::copy(src, begin(dst))` is to 1) use an indexed range-for loop (probably the easiest one that's hard to screw up but newbies find it hard to discover), 2) use `zip` (safe, but newbies find this hard), 3) use indices and `operator[]` (unsafe, but newbies love this), 4) use `at` (safe, but newbies find it hard to discover)
I'm not sure how a bloated web page and other bad practices make a different bloated approach any better. You seem to be saying 'it might give people a bad experience, but so do other websites so it's ok'
Agreed on icache, decoding is afair &lt;1 cycle so shouldn't affect latency. Whether a function is inlined or not, there isn't any flag setting unless there's an explicit flag setting instruction, like `test` or `cmp`. One small thing I didn't consider though, is that you can then immediately use ZF with`setne` to grab the actual bool value. See https://godbolt.org/g/m11m6G. If the optional is not already in a register, then you have a load and it becomes a cmp (with complex addressing) either way I think.
Something like "Setting the world on fire with if-constexpr"
It's not bloated if you're actually getting good functionality for your bytes. Compare downloading an entire application with tons of functionality for 10 MB vs. a single page of a newspaper.
Then they don't show in the debugger
Euh... What would be polling? Don't get it...
We've experienced the same issues with Boost.property_tree and it's error handling. Some platforms would error when you try to convert some type to another that wasn't valid and others would crash.
I dont know what happened... 
On a scale of 1-10, how dead is the parallel graph library? I really want to make use of it, but the documentation is so awful/incomplete and examples non-existent that I'm on the border of having to write my own. 
&gt; You're repeating advice that is more appropriate for game ~designers~ (/r/gamedev crowd) That's a valid point. Perhaps I didn't fully consider which subreddit I was in before posting.
Interesting. By the way, I think you've written a good post, and I wasn't trying to criticize it, it was simply my gut reaction to the title :)
https://twitter.com/NBCNews/status/942799506692853760
There's no need for a warning, as it doesn't compile unless you use `/Zc:forScope-`. Which I hope nobody has been using this decade.
No, DOS didn't have any escapes (because it didn't allow spaces in path names). When long file names were added (which allow spaces) the excessively complex escape behavior had to be added to make most existing uses work without breaking old stuff.
Sure zero overhead is impossible. But memory allocation is so much bigger than zero it isnnl't funny. For most uses of split, memory allocation is not needed.
I meant if you do: for (int i =0; i&lt;5;i++){ } int i =100; // warning: int i would mean redeclaration of a variable in VC6. 
&gt; push_back doesn't solve the same problem, how is it even an alternative? I was thinking about the case when you want to copy exact the amount of elements as your dest has size. Obviously if you need to overwrite first 7 and leave next 32 elements untouched then clear() + push_backs is not equivalent. 
It hasn't been updated anytime recently. Boost graph library itself hasn't been updated since 1.55, although it works quite well, so I don't know that it needs a ton of updates.
The serial graph library is popular enough and properly documented that it's not a barrier. He parallel one, on the other hand, I'm not really sure how it's formally in boost given that it's outright missing documentation pages. 
Thank you for the sentiment. I am removing this post as off-topic.
Again, I don't see how a terrible use of data in a bloated web page makes another bloated web page ok. 10MB for an app might be better than 10MB for a newspaper page, but it's still WAY more than necessary. All of Juce is around 2MB, FLTK is around 100KB, and those are cross platform libraries. 10MB is a tremendous amount of instructions, there is no way it is necessary, and forcing it on to users still seems like a good way to get locked in to giving a bad experience.
Have you thought about any multi-threading? Or is the game single-threaded only? For me it seems like a design choice you have to make right from the start.
For small sizes I suspect this does come down mostly to the standard preventing efficient implementations of `unordered_set`, but for large sizes it's probably mostly because of [The Myth of RAM](http://www.ilikebigbits.com/blog/2014/4/21/the-myth-of-ram-part-i), an argument that we should treat random access as being O(√n). Thus `remove_dups_set` should be thought of as O(n√n) and `remove_dups_sort`, due to its linear traversal of memory, as O(n log n).
If you have complex signal handling logic it can be beneficial to handle it centrally and just have a `should_i_be_running` flag in the threads (particularly if you might want to manipulate that flag for multiple reasons). As with most code, there's many ways to skin this cat, but I don't think my proposed way is bad, or uncommon.
I have a dedicated thread for loading assets in the background, so I'm able to stream sections of the level in chunks, or load the next level while the current is being played. I also think of the audio mixer as running in its own "thread", although technically it's the OS invoking a callback on an arbitrary thread. The audio mixer is the only place I really make use of lock-free programming, since I want to avoid blocking the audio thread or hitting the memory allocator from it. The main game loop is currently single-threaded. Simulation updates and rendering are performed as discrete steps. I prefer old-fashioned optimizations: make it run quickly on the CPU you have. If I ever find a need to parallelize something (which I doubt for Hop Out), I'll handle it at that time. I don't think it needs to affect the entire engine from the beginning. It can be introduced iteratively like anything else.
Never. It is like reaching Nirvana -- can be done only by one person. Me. :D
Qualified to do what? Someone could be qualified to implement applications using C++, but not qualified to implement the standard library. Amusingly, I sometimes feel like I meet the latter, but not the former!
&gt; If I ever find a need to parallelize something (which I doubt for Hop Out), I'll handle it at that time. I don't think it needs to affect the entire engine from the beginning. It can be introduced iteratively like many other things. Yes and no. The paradigms required to effectively use multiple cores are quite different to those of single-threaded code, e.g. a task graph system. This can be pretty hard to retrofit in a codebase which has been designed from the beginning to run on one thread. I would agree with /u/Honsik that this is something that ought to be considered from the start. Considering that mobile devices are getting more and more cores these days, I'd say that a game engine targetting them ought to have this as one of its top 5 goals.
To be fair, wouldn't the first one perform multiple heap allocations due to using an intermediate `unordered_set&lt;T&gt;` container and the returned `vector&lt;T&gt;`, whereas the second one would perform copy elision (or even better, use the original `vector&lt;T&gt;` if it was an rvalue)?
Do you have any kind of rendering API abstraction, or are you just targetting OpenGL at the moment (which makes sense for a cross-platform framework)? Rendering API neutrality is always a big pain, particularly with even the shader languages being different.
&gt; as soon as you start gaining confidence in the language I read a comment or post that makes me go "lol wut?". That never stops. &gt; I have no intention on becoming a master of C++ Of which there are what, like a dozen on Earth? I'm not one, for sure. I'm with /u/millenix ... there's no single epoch at which you become "qualified". It's all relative to what you're trying to do, and there are many different things one could do with C++.
&gt; In your opinion, what are the base qualification/understandings that someone must possess before being able to label them self as a qualified C++ developer? Qualified _for what_ ? The hard parts of software development have next to nothing to do with the language being used. :)
&gt; Thus I've come to the realize that I have no intention on becoming a master of C++, but would rather be someone who has enough understanding of the language to write safe, robust, and manageable code. My short (10y) experience has been that any time I got comfortable writing C++ on the application I was working on, I moved on to a more complicated application, either functionally (distributed) or technically (multi-threaded, high-throughput, low-latency, ...). Is it possible to write safe C++ applications? Maybe in the most dead-simple applications, though even then... Is it possible to write great C++ applications? I believe so. Even in technically complex applications, I've generally managed to "only" debug a hard UB issue once every month/other month; though each time it may cost a day or more to get to the root of the issue. The price to pay to get the performance we seek, I suppose. The good news is that as tooling gets better (I love sanitizers), it has become easier and easier to detect UB bugs before they hit production; though some still manage to slip through the cracks, data-races being my particular nemesis. As for "mastery". Meh. There are dozens upon dozens of niche situations in which the Standard defies intuition, but honestly you rarely ever meet them on a daily basis so there's little point in learning them by heart.
There's a nascent API, but only OpenGL ES 2.0 is implemented at the moment.
I have a bit of a punk attitude about this -- spent many years debugging and optimizing task graphs in my career and take much pride in not having them for now :)
Is that just a nostalgia for simpler times though? :) I think any gamedev veteran (I've got 20+ years now) would begrudgingly concede that we just have no choice these days but to exploit concurrency to the hilt for all but the simplest titles. Of course, you can already make life simpler for yourself if you feel that multithreading is inevitable in the future by writing your code in a certain way (preferring pure functions, avoiding global state, etc etc). But I fight with a codebase whose legacy is very much in the single-threaded tradition, and every day I wish that it had been designed from the ground up with multiple cores in mind!
No.
It's hard to get to the point where you never WTF when *reading* code. There's just so many ways to write code, and if you don't follow good practices there's a lot of edge cases in C++. It's much easier to learn good practices and follow them, which will allow you to write good code. But it will not allow you to anticipate the weird behavior of other peoples' code if it ignores those practices. You improve in that with time, but I doubt anyone ever gets to 100%. As far as writing code goes, and reading code roughly compatible with the style you write, you do eventually reach a point where you can read/write application code, even with some TMP stuff like enable_if, or tag dispatch, etc, and it all seems reasonably straightforward. For most people, this is really the highest level you need, and anything beyond this is probably less useful to your career then spending more time understanding your domain really well. You need to be able to quickly write application code that expresses what you want, without any scary UB, leaks, easy-to-misuse interface, etc. Domain knowledge + general software engineering understanding (modularity, separation of concerns, reuse, testability, etc) play huge roles here, at least as large as pure C++ knowledge. I think after that is the level where you get a deeper understanding, and you can write pretty generic code, e.g. be involved with your company's utility/"augmented STL", or something like that. You can at least understand the considerations in highly, highly generic code like the standard library or boost, but it would be difficult to write it without falling afoul of some corner case. Then, obviously there is the level of the STL (and some other libraries, some but perhaps not all boost libraries). This requires really knowing the core language at an incredibly level (at least from what I've seen). These are the kind of people who, when they encounter a compiler bug, are *really* confident they have encountered a compiler bug (i.e. they trust their understanding of the spec over the compiler's). Most of us mere mortals may know a trivial compiler bug, but in most cases I still have to ask on SO, and often I've been wrong. It would be a mistake to belive that pure C++ knowledge is the axis along which software engineers in C++ are sorted. Some people know the standard line and verse, but don't have a good understanding of when things get inlined. Some people know how to implement allocator aware standard data structures, but may not actually know how to write a fast allocator (for the record I know how to do neither of these things). * For examples of what I mean, consider something like programmers who do things like have multiple `++`, on the same variable, in the same statement. I honestly don't remember when this leads to UB or not, and what exactly the result would be, because I never write code this way, I've never seen a good reason to write code this way, and if I'm reviewing code you write this way, I will not sign off on it. So that could easily make me WTF. But it's never an issue when writing code because I'll just avoid it, and I'll try to make sure that my team's codebase never contains such code, so it rarely comes up.
Excellent. Thanks!
I feel your pain. My little mobile game is not very CPU intensive and I'd like to sustain 60fps on iPhone 6 which is only dual core. So I just don't have these problems....... for now at least.
Beast is great, I ported our http services to it (the out of tree version) a few months ago; it's really straightforward to get something that has decent performance and integrates well. It's worth starting by adapting the examples to get a hang of the concepts. 
The answer to your question is relative to one's perspective. If you are interviewing for a job, then each employer will deem those qualifications differently. It all depends on who you ask. There is no standard defined.
&gt;because as soon as you start gaining confidence in the language I read a comment or post that makes me go "lol wut?". It really can knock down your confidence level in thinking you understand the language I write C++ for 15 years and it happens to me *all the time*. After feeling frustrated for years, I just don't care about it anymore. I try to write my code the best I can, I'm always open to learn, and I'm happy.
pmr allocators!
I think when Bjarne's SO knows your voice on the phone, then maybe.
They usually start out looking really good and either make leaps that are just stupid. Variables can be integers... 5 minutes later: a variadic template can be laplaced into a tensor node with vector traits. Or 5 days later. Two variables can be added and the value stored in a third variable. Of course one of the huge things that most videos do is fill time. 40 minute videos will be filled up with file operations, or they will cover the entire breadth of ML. Doesn't matter, they must stick to 40 minutes (or whatever size they chose) come hell or high-water. 
If I wanted to learn a Hindi accent I would move to India. Udemy sucks donkey balls.
&gt; Note about the new Visual Studio release Visual Studio 15.5 was released too late for us to test this release with it. Good that they put this note in, at least we know right away. But it is a bit of an excuse, as the 15.5 Preview has been around for a long time, with ample opportunity to test.
Testing is done by volunteers; no one volunteered to test it. There's nothing to criticize here IMO.
Fair enough
[dlib](http://dlib.net/ml.html) is an Open-Source machine learning library. My opinion is to use Python. Numpy has C bindings and is basically C code which is fast. Keras can use the Tensorflow backend which lets you train the Neural Networks on GPUs. In my experience, the time it would take to implement and train a Neural Network in C++ is heavily cut back by simply using Keras. If you need more precision then actually use Tensorflow. Even more, Python is basically the industry standard when it comes to Data Science (along with R). Yes, it may not be compiled and statically checked, but it offers easy readability and usability along with high abstraction which is very much needed when dealing with mathematical concepts.
There's multiple ways of doing something like that. None of them are really all that recommended. You could cgi-bin it, use something like Wt, roll your own http server from scratch and hand-roll html in strings in your C++ code, use a templating engine (many bad choices there... maybe this https://github.com/rep-movsd/see-phit ). You could do an SDL program and compile with emscripten if you're really masochistic. and so on. What did you have in mind? Like a javascript terminal emulator that runs console apps?
Put 4 spaces in front of each line to format code for Reddit. /r/cpp_questions if you have a question (and don't forget to actually ask it).
Read the beginner's guide about formatting. Markdown is interpreting your C++ syntax as markdown, and it's not turning out well.
dnn, tiny-dnn, fast-dnn
Yes, you can do this. If your goal is to learn how to write network services, you can write your own program that opens a server socket, listens for connections on port 80, receives messages from clients, parses the messages as HTTP requests, and returns content (probably encoded as HTML) as HTTP responses. However, all of that is common to every website in the world. So, rather than writing everything from scratch, if you want to make your content available, you use an HTTP server (for example, Apache HTTPD). Probably the simplest way to provide dynamic content is called the "Common Gateway Interface", or CGI. The way CGI works is really similar to command-line applications, because it's basically the HTTP server calling command-line applications. 
&gt; hand-roll html in strings in your C++ code That's what I've done on a number of occasions. Do it a few times and you get the hang of it. HTML is (at least usually) plain text, which you can generate with ordinary `std::cout` statements. [Here's a lengthy example](http://tamivox.org/eugene/octonion480/table_2.html) from abstract algebra.
It is the best code I've ever seen
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7kpz3b/how_you_like_my_code/drgcshe/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7kq658/c_to_website/drgcu17/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Reflection is nice, but if you need to load a lot of assets, I'm not sure you can afford the cost that reflection will cause. It will have to be used sparingly.
For serialization, if you can make your class allocator-aware, you can use a local allocator that will put everything together, and you can just copy memory directly. If you need to serialize a lot of data, it's much faster than exporting to JSON or other text-based systems. The obvious downside is that you will break things if you change your class structure. If you have to support polymorphism, it is a bit trickier but you can replace the vtable with an enum to know which class you're dealing with. Obviously you're going into implementation-defined behaviour (or maybe even UB), but it's easy to Unit Test it and you aren't going to support very exotic compilers anyway most likely.
It will have ore content that the emoji movie at least.
So are you saying I can keep my program in C++ on Xcode and write a line that’ll transfer data from a website that people input the info into?
Woohoo :)
Wow, you would think you could do a simple Yaml-&gt;JSON conversion then plug the result into OP's parser. Maybe I'm missing something though.
And yet the STL allows for invisible deep copies of massive containers.
I just don't know how to program in html. I want to have a spreadsheet, be able to give a website link out that people can fill out. I want the input into that website to go into my spreadsheet and be sorted. 
This is a primary use case of why we need reflection and code injection badly.
Well, this should be reflection "on-demand", that is why the proposals are about static type reflection (not runtime). So you can generate on demand and be still under control, the same ways there are techniques to reduce code bloat in templates, such as code hoisting.
congrats!
Thanks, Jason!
Static time reflection is great, but it can be insufficient if you need to load previous versions, you end up at the article pointed out having plenty of copies of your important function.
Can someone help me to explain why call the lock.unlock() before process(task)? 
A worker unlocks during task processing, to allow other workers to process tasks, or for another thread to set `running = false`.
Yeah, is this a part of threadpool implementation? I'm very interesting, can you share the complete source code for me to study. Thanks.
I wonder if I can build it for iOS with boost context enabled. I was having that problem which was a showstopper for porting something I have to iphone bc I am using asio + coroutines for a client.
That's a good attitude to have, but reflection is used in UE4, so it's clearly a workable solution even on large-scale projects.
It's quite simplified from a real thread pool implementation. Reality adds complexity. For example, when `running` is cleared, these workers may keep processing tasks until the queue is empty, or they may exit immediately. In a real thread pool, you want to guarantee one of those behaviors. The thread pools I'm using are proprietary, but you can find open source implementations online. I highly recommend the book [C++ Concurrency in Action](https://www.manning.com/books/c-plus-plus-concurrency-in-action-second-edition) for learning more about C++ threading facilities. It has many thread pool examples. The second edition is releasing soon, updated for C++14/17. It appears you can already access all chapters of the second edition.
Thank you so much for your sharing and recommendation!
I'd be interested in a faster graph library as well, currently using A* but we do have some big graphs that can become a problem.
Are you saying there is no automated CI for Boost? 
So what actually happens if you build it with 15.5? Compile fail, sub optimal use of features but ok or no practical problems?
And it looks lovely, by the way! So nice to see a 60fps game running on a streamlined, custom engine. Best of luck!
&gt; wrt .at() I disagree with using this, What do you disagree with? I just said that its safe and it works, but that is not discoverable for newbies. I don't use at or ranges::at much either.
I believe this is undefined behaviour: static constexpr std::size_t BufferSize = 64; std::aligned_storage_t&lt;BufferSize&gt; m_storage; inline concept_t&amp; get() { return *reinterpret_cast&lt;concept_t*&gt;(&amp;m_storage); } inline const concept_t&amp; get() const { return *reinterpret_cast&lt;const concept_t*&gt;(&amp;m_storage); } Accessing your `concept` pointer through `reinterpret_cast` violates the strict aliasing rule. I think you have to store a pointer along with your `aligned_storage` to get around that or use a soluation as proposed [in this SO question](https://stackoverflow.com/questions/39477443/small-object-stack-storage-strict-aliasing-rule-and-undefined-behavior) I say this because I really want to use it the way you do, but I feel like I'm not allowed to and I was disappointed a lot when i figured that out.
I find it funny when people give up on a programming language due to those moments, and go off to learn a "better language", not realizing they're still going to have to learn new stuff anyway.
For me: knowing how to use C++ to design good (not perfect) types and to write good (not perfect) functions. Relative to the domain you want to work in. 
Where is it used?
I don't get template &lt;typename... T&gt; ostream &amp;operator&lt;&lt;(ostream &amp;out, Tuple&lt;T...&gt; t) { auto v = {(out &lt;&lt; static_cast&lt;T&gt;(t) &lt;&lt; '\n', 0)...}; (void)v; return out; } Why not just `return out &lt;&lt; Get&lt;T&gt;(t) &lt;&lt; ... &lt;&lt; '\n';`? template &lt;typename... T&gt; constexpr size_t index_of(...) { static_assert(sizeof...(T) == 0); return -1; } What's the purpose of this thing? Also, why use C's `...` here?
Practical+Teoretical language knowledge for sure: RAII, templates, const-correctness, move semantics, etc + some theory/practice for the field you are working in.
[You clearly have a very different definition of "very good" than I do.](https://www.reddit.com/r/cpp/comments/6wi39p/c17_stl_cookbook_book_review/dm8cdol/)
For the first one, because at the time, I hadn't implemented Get&lt;T&gt;(t), and I haven't gotten around to trying fold expressions. I went with the familiar to get something working. For the second one, it's for the overload resolution. The way I managed to get the bucket search working was to have `index_of` that could convert the `Tuple` to the underlying type of the bucket for the given string size. So in the case where the string isn't in the `Tuple` because it doesn't even contain a string of that size, the `...` overload gets chosen and we can get an index of -1.
Everywhere! They have to use their own pre-processor to generate the reflection data (as it's not yet a feature of C++) but reflection is used for everything from allowing editing of object properties in the editor to object serialization to network replication.
How does this work? How does the code under test end up calling the mock instead of the global function? Is this performing some kind of hooking? Is it portable?
Explaining the `index_of` a bit more: So it starts off with this: template &lt;typename... T, size_t... N, typename U, size_t M&gt; constexpr size_t index_of(Tuple&lt;cexprstr&lt;T, N&gt;...&gt; t, cexprstr&lt;U, M&gt; c) {...} The `Tuple` is derived from `cexprstr&lt;T, N&gt;...`. To find `c` in `t`, first you have to find the `cexprstr&lt;T,N&gt;` where T is a `cexprstr` of size `M`. Which then calls `index_of(c, t)`. Yes, it's quite ridiculous calling `index_of` merely to switch the arguments around. But the purpose was to resolve to this version of `index_of` (which should be called something else): template &lt;typename T, size_t N&gt; constexpr size_t index_of(T t, cexprstr&lt;T, N&gt; c) {...} `t` is now the string we want to find. The switching of the arguments was necessary for this hack because `T` then gets deduced first, which fixes the type of `c`. If the `Tuple` is derived from the type of `c`, then this is chosen. Otherwise, it's a substitution failure, meaning the string isn't in the `Tuple` because the `Tuple` doesn't even have a string of that size. In this case, the `index_of(...)` gets chosen.
Fair point. I sometimes come across legacy code or mixed ones so seeing stuff like template &lt;typename T&gt; using observer_ptr = T*; In unknown code base tells me clearly if there are any raw owning pointers or not.
That's an ugly solution. Better write something like `std::get`. And if you go with C++17 `if constexpr`, go with fold expressions too.
`index_of` is the low level implementation. You don't call that directly. If you look at the test file, there are a bunch of examples of `sometuple["some string"]` which returns the index. There is also a `get` which you supply the index as the template argument to get the string. So what you say already exists. I can't very well go implementing `get` with another `get`. Somewhere along the line, it has to be ugly. And yes I'll get around to fold expressions.
This. Many people consider themselves „C++ programmer“ or „Java programmer“ or whatever. But that’s basically self-degradation. You are an engineer capable of solving complex problems of a specific domain (like game development)
You have to join the child threads anyway...
 void threadfunc() { while(runningFuture.waitFor(std::chrono::seconds(1) == std::future_status_deferred) { while(workExists()) {doWork();} } } This sort of thing is what you're talking about, right? It's polling the future. Don't be fooled by the function being called 'wait_for()', there's very little difference between that and void threadfunc() { while(runningFlag) { while(workExists()) {doWork();} std::this_thread::sleep_for(std::chrono::seconds(1)); } }
Just a warning message. Which is really annoying.
Who knew about the upcoming Boost release? Only those who subscribed via mail? Why not to notify here with something like: &gt; Hey, we are going to release a new Boost version! However there are some untested compilers, like A, B, C, D. &gt; Does anyone want to run our tests against them? Download this, run that, follow here, report there. I expect a lot of people who'd help with it. 
For linear algebra: [Eigen](http://eigen.tuxfamily.org), for machine learning [tensorflow](https://www.tensorflow.org/)
15.5 seems broke some constexpr-if statement, and constexpr-if in lambda simply doesn't work, both branches are inited.
you listed it as alternative. I said it is bad alternative, in other words I would not list it under alternatives
It creates dummy classes and global function wrappers around them. No hooks are used and it's 100% portable. Take a look at the code: MOCK_GLOBAL_FUNC2(sum2, int(int, int)); // &lt;-- create a mock function TEST(SummizerTestGlobal2, CanSumGlobal2) // &lt;-- define a test { EXPECT_GLOBAL_CALL(sum2, sum2(1, 2)).Times(1); // &lt;-- define mock function behavior sum2(1, 2); // &lt;-- here we call our mock function } This isn't possible with only Gmock. Guys at Goggle decided that mock functions must be class methods.
Sure, but to replace the implementation with the mock you still need to use some kind of preprocessor trick, otherwise you get redefinition errors. 
yes, and?
So in code like: runningFuture.wait(); for(auto&amp; t : childThreads) {t.join();} waiting on the future is redundant, because you're still waiting on the termination mechanism for the child threads. May as well just join the children and have whatever cancellation mechanism you've got pass through to the children, surely?
Of course there is http://www.boost.org/development/tests/develop/developer/summary.html 
It depends on the code you want to test. In my case WinApi functions were dynamically imported by library name and function name so it was easy to replace real function pointers with mock function pointers.
I'm surprised that Asio upgraded to version 1.11.0. Not only does [the website](http://think-async.com/) still consider that the "development release" (with 1.10.6 being the "stable release"), but that also makes a ton of changes that I thought were still in flux: I've seen quite a few revisions in the standardization committee postings after 1.11.0 was released.
No, not that. It's suboptimal. I made example else-thread; that example is exactly the kind of code (some) platforms allow. 
If you are looking for a modern, properly configured and concise cmake template without relying on any package manager such as conan/bazel, try https://github.com/acdemiralp/cmake_templates . It could have made your life much easier.
Shouldn't the working title be C++17, The (In)Complete Guide?
There's no way to express WaitForMultipleObjects directly in standard C++, and the closest equivalent /still/ doesn't contain a std::future (it's a std::condition_variable, std::mutex, and a bool, as shown (here)[https://www.reddit.com/r/cpp/comments/7kc1em/c11_how_to_stop_or_terminate_a_thread/dreqky3/]). So sure, you can do that, but you still wouldn't be using std::future to do it. Because why would you do that? 
There is the C++ Core Guidelines, which say exactly what /u/STL said. 
Ha! Excellent, every time I read about the design of futures in Rust (zero cost, composable, inlineable) I was hoping that some kind soul will translate this design to C++. I'll definitely try it, thanks!
The problem comes in cases like a signal handler, where the signal will only be delivered to one thread. In that case it's better to have your main thread handle the signal and flag the children to stop. To achieve this you may want to use a future, cv etc to let the main thread know the signal was received.
The problem is C++ that has no good safe alternative for this.
What bug was that?
deduction guidelines should burn in hell those are my 2 cents, but I am not a compiler person
&gt; Guys at Goggle decided that mock functions must be class methods. No offense, but that sounds like you are implying that Google devs are stupid because of this, when in reality they didn't decide this arbitrarily. The only portable way to do dynamic dispatch (without boilerplate) in C++ is through virtual functions. As you pointed out, yours is a very special case where you already have function pointers bound at runtime and your code calls WinAPI through those pointers. So you have the ability to replace them with ease. This is a special use-case that doesn't really make sense to support in a library (indeed, no mocking libraries do this AFAIK).
And who is responsible for keeping it green? Volunteers?
I tried to build boost.context for arm in iOS and cannot with bjam. I was using the script here: https://github.com/danoli3/ofxiOSBoost It is not the script but an internal problem in boost what prevents it from building for iphone boost.context. Here there is a reply from stackoverflow on how to do it, though I did it I lost those changes before: https://stackoverflow.com/questions/26668858/how-to-build-boost-1-56-0-boostcontext-for-iphone-arm I was wondering if it is fixed in the build system in boost directly so that I can download 1.66 and try. 
What's wrong with them?
Would you care explaining? As a library writter as well, I go out of my way to treat templates as implementation details as much as humanly possible. Having to create a bunch of boilerplate simlar to this is really annoying: template&lt;typename T&gt; struct name {}; template &lt;typename T&gt; name&lt;T&gt; make_name(T const&amp;); 
&gt; a message that had a break in it What does break mean in this context?
Google TensorFlow is open source. 
If somebody will pay you to program in C++. :) There are different levels of knowledge of C++ and many people that earn money in C++ are not experts in entire C++ but in the domain where they work. And you should not consider r/ cpp as some measure of cpp skills. People that hang around here are enthusiasts that like C++(yes it is bizarre that somebody can love C++) so it is understandable that they know obscure stuff like ODR used and how template overload resolution works... Good news is that you do not need to be expert to use C++, you just need to be willing to learn "good practice tips" and for that you can just follow some blogs/cppcon videos. No need to memorize the Holy Standard.
Boost.ASIO/AFIO and Networking TS are there, why don't we use them instead?
I like tiny-dnn, and I used it for some experiments in one of my projects, but unfortunately, it doesn't support training on GPU yet.
I tried reading mp11 docs and all the &lt; &gt; gave me headache... :P Is this library useful for normal people or is it just for library developers?
Behavioural/binary break, e.g. changing a class member container type
Yes, that was mu understanding, but was kinda hoping it was possible but I didn't see it 😀
They have strong verbosity
LOL - library developers are not "normal" people?
We recently ditched `property_tree` in favor of in-house implementation too. It seems that it is not even actively maintained.
https://stackoverflow.com/questions/43043397/can-one-use-parameter-value-directly-not-its-type-but-value-itself-in-trailing
&gt; LOL - library developers are not "normal" people? They are half-gods... three quarter gods if the mastered SFINAE ;) But seriously... I checked out brigand and Hana in the past and not even once I thought: Aha, this is what I was waiting for! I assume mp11 is same... but I wonder. :)
Well yes I imagine so. Maybe some devs are sponsored but probably most people involved are volunteers
We are talking about different things. A mock library creates dummy functions. It doesn't care how you will replace real functions with mock ones. Gmock goes C++ way and requires you to use class methods. While this is a good and correct approach sometimes you need to mock a global function (how about testing C interface with callback functions?). By the way I'm not calling Google devs stupid. They just force you to use class methods that is not always possible or desirable. There is even a question about global functions in their [FAQ](https://github.com/google/googlemock/blob/master/googlemock/docs/FrequentlyAskedQuestions.md#my-code-calls-a-staticglobal-function--can-i-mock-it).
I'm surprised that the Nowide library is not part of this release, since it has been accepted before the Beast library. Maybe it is because of the 2 major issues specified [here](https://lists.boost.org/boost-announce/2017/06/0516.php). Not a big deal since I just have to extract the Nowide archive in my boost directory and build boost to have it, but it would be better to have an official version. 
Check out the Clang sanitizers, clang-tidy and clang-format for a few great tools.
Everyone already knows how to write a loop. It should **not** look like this: nTimes(10).andThen([&amp;loop] (int i) {}).drop(); Normal loop look like this: for (int i = 0; i &lt; 10; ++i) {} [Here](https://wandbox.org/permlink/peqL4n50rr2MdOEX) is your "minimun example" written in normal C++. 
There are as always the free options like Clang and Valgring or the paid ones likes PVS-Studio And of course activate the flags on the compiler to make it more sensible to all stuff
valgrind, gprof, compiling with -fsanitize=address and -fsanitize=undefined when testing, clang has a static analyzer (though that's become a lot more of a pain to use lately).
&gt; performance profiling I would normally turn to gprof and to be perfectly honest probably some visualization tool built on top of that because I'm lazy. cachegrind _is_ nice, but like you said it's about cache miss counting, not time. It's a different metric that's also worth watching, IMO. &gt; static analysis Definitely look into the clang tools, as /u/IAmCodeMachine mentioned. cppclean is kind of meh... but could be worth using (it's free afterall). As /u/JuanAG mentioned, there's PVS-Studio if you're willing to pay for a proprietary tool. I actually hadn't noticed they made a Linux version, that's pretty cool. https://medium.com/@Coder_HarryLee/pvs-studio-for-linux-93df12a23abe But the first step in static analysis should always be cranking your warnings through the roof and tracking them (e.g. the Warnings plugin if you use Jenkins). gcc &amp; clang in particular - the warnings are a lot more thorough and useful than you may remember. At a bare minimum I'd start with -Wall -Wextra -Wpedantic -Wconversion , but if you're really going head-first clang provides a -Weverything option. include-what-you-use exists, as well. &gt; And any other tools As /u/JuanAG mentioned, the sanitizers. Both clang &amp; gcc provide some - no reason not to use both. Along a similar vein, the standard libraries (I think all the major ones?) have a checked version - compile with a certain -D and suddenly dereferencing an invalid iterator will point you to exactly the line of code where that happened. Since you've used cachegrind, I have to assume you've used memcheck. Keep doing that - solid stuff. I recommend lcov for test coverage. It's actually just a processor for the output of gcov, but again... I'm lazy when it comes to reading reports. lcov makes things a nice set of http pages where you can drill down to see which lines got executed etc..
For performance, start with Brandon Gregg's page: http://www.brendangregg.com/linuxperf.html If you want to go further (shameless plug): try out ppt: https://github.com/lally/libmet/ 
The example and your code are very different and not really equivalent. Looks like you'd have to use packaged_task with fibers to get something a bit closer and even then you lose the easy composition and other advantages you get with a stream interface.
C++'s ability to model high level abstraction is at least as good as Python's, and I would say better. The biggest problem with C++ is that people teach C and call it C++. So it has this reputation for being low level and difficult, which isn't right. Normal C++ is super high level, just as high level as Python. Plenty of times even higher level, for instance, how common is metaprogramming in Python? I see way more metaprogramming in C++ than I do in the Python code I encounter. There is so much confusion on this topic. For instance, I regularly encounter people who say things to me like "C++ is hard, who has time to remember to free memory?" which is obviously a remark on C and not C++, since C++ has totally automatic resource management. My point here is that this "everything is python and C++ is hard attitude" is harmful because it discourages people new to programming from learning about things beyond Python, which is most of computer science. For one thing, most of the python libraries that people actually use are written in C++ (or C). Why is that? If you only know Python then you are fundamentally not able to take part in that kind of creative activity. You get restricted to being a consumer of these magic libraries other people make, but you yourself can't make. That's bad. There is this reddit echo chamber where people who have jobs that encourage them to post their work on the internet, predominantly students, especially grad students, constantly post about the stuff they are doing in Python. Meanwhile, the silent majority of working engineers don't say anything. Since Python is a language specifically targeted at people learning to program it ends up heavily overrepresented. So yes, Python is popular among grad students and people just getting into programming for sure. But most of the people I know in industry use C++ (or even java). So when you get into real applications, at least the kinds of things I see, it's C++ rather than Python. In my opinion, Pyhton is the new matlab. Which is great. Having a free open source language like Python that people can use to learn programming and easily jump into things like machine learning is super. But no one should be getting the impression that that's all there is to learn about programming or that everything that isn't an interpreted language is super hard or low level, because that's just not the case. Learning C++ is well worth the time and if you really learn it you wouldn't say that Python is somehow easier to use. 
Like others have said &gt; valgrind &gt; [linux-perf-tools](https://stackoverflow.com/a/14674931/795574) &gt; [KDAB hotstop](https://github.com/KDAB/hotspot/) &gt; [ASAN](https://tsdgeos.blogspot.fr/2014/03/asan-and-gcc-how-to-get-line-numbers-in.html) 
If you told me "just copy the data to vec" I wouldn't think of `push_back`; I would think of `assign` and probably write "vec = range;".
My only gripe is that one cannot call a macro function with a templated argument that has commas. They are a nice tool to have when you need it
&gt; If you told me "just copy the data to vec" I wouldn't think of push_back; I would think of assign and probably write "vec = range;". OK, then I accept that copy(a,b) is not obvious. :) BTW IDK if MSFT will get angry if you reply to this, so first check if it is ok, but do you have plans to have range-v3 working in VS2017 or is it planned only for VSNext(VS 2019 I assume).
So you don't have a source for that?
&gt; Which is why these micro-optimizations are of dubious value. Not when they're being applied to standard library implementations.
&gt; Dropbox's json11 That looks similar to [Facebook's folly](https://github.com/facebook/folly) library (in particular, [folly::dynamic](https://github.com/facebook/folly/blob/master/folly/docs/Dynamic.md)).
asan, tsan, valgrind, and [pprof](https://github.com/google/pprof).
&gt; Learning C++ is well worth the time and if you really learn it you wouldn't say that Python is somehow easier to use. I gave my plus point for the last part, I like it so much. Bad tutorials and books, ignorant teachers (esp. pre Modern C++ days) played much part in making C++ seem hard! I had to relearn at some point, glad I did.
What are the advantages of this over something more widely used such as [RxCpp](https://github.com/Reactive-Extensions/RxCpp)?
The problem is that people are still, say, allocating arrays with `int* array = new int[SIZE]`, and complain about having to manage the memory on their own. They fail to understand that C++ has RAII, which means that one could almost write pretty much any program without ever worrying about memory management, by using the STL containers and smart pointers. Even if one did need to use good ol' aked pointers, a class is all they need to manage the lifetime of their objects. On top of this, people are constantly reinventing the wheel. If you need to find the maximum of a collection of items, there's no need for you to try hard to remember the algorithm you learned during your first year at college, you just need to use `std::max_element`. This is, of course, a very basic case, but the standard library and its header `&lt;algorithm&gt;` expose lots of functionalities that people forget about too often.
Oh, you mean like how `vector&lt;bool&gt;` is not of dubious value when applied to standard library implementations?
Static Analyzer: [PVS-Studio](https://www.viva64.com/en/pvs-studio/) I swear by it.
Why do you resort to a strawman _so quickly_? `vector&lt;bool&gt;` specialization is not something I endorse, no.
It's not a strawman. It's a reductio ad absurdum.
&gt; std::max_element constexpr everything in C++17!
It's a logical fallacy and a waste of time. Great job, good argument!
&gt; but the standard library and its header &lt;algorithm&gt; expose lots of functionalities that people forget about too often. ...lots of functionalities people never learn in the first place let alone forgetting 'em.
I implemented deduction-guides for the STL in VS 2017 15.6 (enabled for Clang only at the moment) and found them to be nice and useful. For unordered_meow the guides are extremely spammy but that's unordered_meow's fault.
You must feel so proud micro-optimizing your life over these things.
One thing that people didn't mention (arguably not what you ask for), is try using QTcreator instead of Clion. It's []foss nowadays](https://github.com/qt-creator/qt-creator) and the gdb wrapper it has is amazingly easy to use (+ it "easily" integrates with most build systems). 
* check out [performance tools](https://github.com/MattPD/cpplinks/blob/master/performance.tools.md) -- including benchmarking libraries, and pmu-tools (a _fantastic_ choice for Intel platforms!) + Linux perf for Qt developers - Milian Wolff - QtCon 2016 https://www.youtube.com/watch?v=L4NClVxqdMw + Processor Counter Monitor (PCM) - https://github.com/opcm/pcm -- other than Linux, also works on Windows, Mac OS X, FreeBSD, and DragonFlyBSD + http://www.brendangregg.com/linuxperf.html, http://www.brendangregg.com/perf.html, http://sandsoftwaresound.net/perf/perf-tutorial-hot-spots/, http://sandsoftwaresound.net/perf/perf-tut-count-hw-events/, http://sandsoftwaresound.net/perf/perf-tut-profile-hw-events/ * Sanitizers (AddressSanitizer, ThreadSanitizer, MemorySanitizer, more) -- which go hand-in-hand with fuzzers (american fuzzy lop (afl-fuzz) http://lcamtuf.coredump.cx/afl/ and libFuzzer stand out in particular): + https://github.com/google/sanitizers + https://github.com/google/sanitizers/wiki + C++ Weekly - Ep 84 - C++ Sanitizers: https://www.youtube.com/watch?v=MB6NPkB4YVs + Address and Thread Sanitizers in GCC - https://developers.redhat.com/blog/2014/12/02/address-and-thread-sanitizers-gcc/ + https://oscarforner.com/2016/07/13/Clang_sanitizers + C++ Weekly - Ep 85 - Fuzz Testing https://www.youtube.com/watch?v=gO0KBoqkOoU + "Modern fuzzing of C/C++ Projects" workshop https://github.com/Dor1s/libfuzzer-workshop + Fuzz Smarter Not Harder: An afl-fuzz Primer - https://www.youtube.com/watch?v=29RbO5bftwo + libFuzzer – a library for coverage-guided fuzz testing. http://llvm.org/docs/LibFuzzer.html, http://tutorial.libFuzzer.info + RamFuzz - A fuzzer for individual method parameters - https://github.com/dekimir/RamFuzz + Materials from Fuzzing With AFL workshop - https://github.com/ThalesIgnite/afl-training + CppCon 2017: Kostya Serebryany “Fuzz or lose” - https://www.youtube.com/watch?v=k-Cv8Q3zWNQ, https://github.com/CppCon/CppCon2017/tree/master/Demos/Fuzz%20Or%20Lose 
I'm not familiar with that, but are you aware of any other MPI distributed graph libraries?
&gt; Having to create a bunch of boilerplate simlar to this is really annoying That boiler plate is annoying but trivial to add. Deduction guidelines by itself are not the problem, the problem is that when using concept to constrain constructors combining them with deduction guidelines is painful and error prone.
Definitely not as I know very little of how Boost is run. But like all Free Software projects run without a primary company backing it wouldn't you assume the people involved are volunteers unless shown otherwise? I mean like Linux I'm sure there are plenty of Boost devs who has their work sponsored by their employer.
Thanks for sharing! Here is the direct link, save you a click: https://www.udemy.com/unrealengine-cpp
There is a release calendar on their website and the releases are pretty regular. Advertising is great and all, and it's important for Free Software to be welcoming to new devs. But at the end of the day things are done by people who show up.
The differences from the C version of designated initializer means that the C++ version is pretty useless for compatibility unless one deliberately sticks to the intersection of C and C++. If you're going to do that anyway then you don't need this feature in the first place.
&gt; clang-format While clang-format allows for many formatting styles there is definitely a strong demand that your coding style is their coding style. That is a bit of a dick move on their part. 
Have you even used clang-format? There are a ton of options that I'm sure will let up letting you create your own unique style.
You didn't mention free and while free and preferably open source is my goto Coverity is da bomb.
Easy: When you feel so comfortable with the language you actually miss the features of C++ when coding in some other language. 
Yeah it can be opinionated but for anything more than a one person project I'd argue that consistency beats individual preference.
I'm a vim user nowadays but God did I love qtcreator in my first years as a cpp developer. In fact the only time I use it today is to debug something with gdb. Fantastic piece of software.
A small typo: the compiler feature table is named `C++03/11/14 Core Language Features` but it seems it also has the c++17 features.
That's intentional, although admittedly somewhat confusing. There's an internal header row saying "C++17 Core Language Features". I was imitating GCC's old feature tables for C++11 which had extra header rows like this for C++11's concurrency and C99 features.
Another option besides compiler and IDE is that vcpkg itself can be the entity introducing /external:* switches for the libraries it added
ah, indeed, I mistook the row for another feature row. sorry for the noise!
Asio no http 
&gt; First, that boiler plate is not necessary for constructors that don't need deduction guidelines. Agree. &gt; Second, that boiler plate is annoying but trivial to add. Agree. &gt; IMO they are not worth it. I could have lived with sometimes needing to write make_ constructors, or specifying a template's types, or ideally, just improving type deduction to make them unnecessary. I strongly disagree. I think it's crazy that we have to create `make_` functions. Not only is it "boilerplate" code, but the user also has to know about it. ("Oh to create an `std::string` I just use c-strings but to create an `std::tuple` I need to use `std::make_tuple()`? Why??") And making them specify the template types is just as bad. (and rather difficult if it's a lambda ;) But yeah I don't understand why type deduction couldn't just be improved by saying the constructor uses the same deduction rules as free functions.
So, Beast, which integrates with Asio/Networking TS pretty nicely.
Is there any implementation changes for experimental features? (modules, coroutines...) It's very hard to track if anything have been fixed for them.
&gt; But yeah I don't understand why type deduction couldn't just be improved by saying the constructor uses the same deduction rules as free functions. That's exactly what happened! Implicit guides are generated via such rules and they work for simple classes (e.g. `Pair&lt;A, B&gt;` with a `Pair(const A&amp;, const B&amp;)` constructor). Explicit guides are needed when constructors are templated. For example, `Pair(X&amp;&amp;, Y&amp;&amp;)` is templated on `X` and `Y`, which aren't linked to `A` and `B`. You need a guide to say "deduce Pair&lt;decay_t&lt;X&gt;, decay_t&lt;Y&gt;&gt;` here. (And that guide is very simple, because it can be written `Pair(T, U)` taking by value, even though the constructor doesn't.) Another example is when you have constructors from iterators. `Vector(InIt, InIt)` needs to generate `Vector&lt;iterator_traits&lt;InIt&gt;::value_type&gt;` which cannot possibly happen implicitly, so a guide needs to say how to do it.
There have been bugfixes, but I don't have a changelog.
I agree with everything you just said and I too love C++ and all the features it has (`smart_ptrs`, move semantics, STL containers, etc.). However, I will still stand by my point that using Python is faster to code and share. For example, something so simple as loading a csv dataset, calculating the correlation matrix and then plotting it, is done in Python in a few lines, while in C++ you don't have anything *already done* and might take dozens/hundred more. My opinion is that you might use C++ for things such as a regular expression parser, making the basic data structures for matrices, etc. On the other hand, Python libraries and Python itself encapsulate all of this for the Data Analyst to use. So while both of them are used in one way or the other, the Data Analysts will use Python as the frontend. Even more, most **Applied Mathematicians** and **Staticians** use Python because it is a language they are okay with. Not everyone knows about move constructors or concepts, only C++ developers are blessed/cursed with this knowledge. A lot of (Applied) Mathematicians I know think programming is using Mathematica, while few other do know C++ but because they ended up working as Software Engineers in a very specific area. So Python is sort of the in between common language that Software Engineers and Mathematicians can communicate with. Bearing in mind I agree with, &gt;Learning C++ is well worth the time and if you really learn it you wouldn't say that Python is somehow easier to use I also think a lot of people in different fields don't have the background you have in Computer Science and it results convenient to use Python because it is so simple. In conclusion, I think Python is a very good "common language" for people of all fields to learn which suits Data Analysis perfectly because it is undoubtedly a combination of CS, Maths and Statistics. 
Yeah .. And boost develop is on Asio 1.12. Confusion at its best ! There is actually an issue opened on GitHub but the author hasn't answered yet: https://github.com/chriskohlhoff/asio/issues/272
Boost is so widespread though and lots of people, companies, researchers, institutions, etc. depend on it. So there is a kind of responsibility on the Boost project actually.
What? No, what I'm saying (probably /u/5225225 too) is that we'd like to use YAML in projects. For example, for configuration files. It has some things JSON doesn't have. For example: Comments! That's really important for configs. So what you're saying now is that I should include a YAML-&gt;JSON converter inside the project, convert these YAML configs to JSON (and everytime someone changes something in the config), and then read them with a JSON parser. No thanks, that's not a workflow I would ever want to impose on any of my users. What we need is a header-only, modern C++ YAML parser.
Not everything in YAML maps into JSON, either cleanly or at all. It is quite a complex format. And the difficulty of a YAML-&gt;JSON parser would be greater than the difficulty of a YAML parser itself.
Ludicrous – what part of "volunteer effort" is ambiguous? Their only responsibility is to accurately represent which platforms the code has actually been tested on (which is why merely silencing this _warning_, not error, would be absolutely the wrong thing to do). No volunteers are any more "responsible" to commit hardware and resources to vet further platforms than you are; interested parties are surely invited to contribute as fits their needs (and many do). Demanding that other people volunteer more is backwards thinking.
Waiting for `&lt;filesystem&gt;` here :( VS has already got it more or less (TR1 implementation), please finally update to the C++17 `&lt;filesystem&gt;`. I think MS said this requires break in binary compatibility, wasn't 15.5 or 15.6 supposed to allow that? Hope to see it soon :-) It's also kind of amazing how long it takes you guys to get range-v3 to compile (ericniebler/range-v3, not the MS fork). But I am sure you guys are doing the best you all can :-O Or does it maybe compile yet? Other than that really amazing work from the whole team, I'm a very happy VS2017 user! Wouldn't take any other IDE &amp; compiler as my main dev setup. Thanks!
&gt; What we need is a header-only, modern C++ YAML parser. What about sqlite3's model, where it is shipped as just one fuck-off-massive C file that you build into a library and link just like any other file? Means you don't need to recompile that code on any changes to your main code, and it's easy enough to build. Granted, I mainly use C instead of C++, but adding sqlite3 to a project was like 4 lines in a makefile, if that.
A warning message that includes explicit instructions on how to silence it. ;-]
Nothing in 15.x is going to be ABI breaking. That said we may investigate implementing at least some of what got standardized in an ABI compatible way -- no promises :)
&gt; Waiting for &lt;filesystem&gt; here It's on our list - just 5 more STL features to go. &gt; VS has already got it more or less (TR1 implementation) Specifically, we overhauled our Filesystem V2 (TR2 era) implementation to Filesystem V3 (TS era) in VS 2015 with additional bugfixes in the 2017 series. We need another overhaul to Filesystem V4 (C++17 Standard) before declaring completeness. &gt; I think MS said this requires break in binary compatibility, wasn't 15.5 or 15.6 supposed to allow that? The 2017 release series will preserve bincompat. However, we now believe we can implement this in a compatible manner, following the same technique we're using to ship `&lt;memory_resource&gt;` in 15.6. (We're adding new DLLs alongside msvcp140.dll.) This is possible because the namespace for Filesystem is changing. &gt; It's also kind of amazing how long it takes you guys to get range-v3 to compile (ericniebler/range-v3, not the MS fork). Yeah. As that code assumes the presence of a conforming compiler, it doesn't tolerate anything less than nearly perfect conformance. The compiler front-end team is making progress, but it won't show up immediately. In contrast, the STL is written in the other direction - we tentatively take advantage of new features as they become available, reporting bugs and adding workarounds as we go. That's why there was a delay between variable templates shipping in VS 2015.2 and being used within the STL's implementation in VS 2017 15.5.
Isn't the TR1 version in a different namespace?
Try learning some category theory, which is essentially the mathematics of things that compose. CT is to software architecture what calculus is to mechanical engineering. Once you do, no amount of metaprogramming will be enough to express your thoughts precisely.
It seems that Beast's author does not want to implement Easy-to-use HttpClient, https://github.com/chyh1990/futures_cpp/blob/master/examples/client_test.cpp#L14 https://github.com/boostorg/beast/blob/develop/example/http/client/sync/http_client_sync.cpp#L51 Comparing the two seems to be the first one is the idiom of most programming languages HttpClient 
libc++ (6.0) no &lt;filesystem&gt; now, and libstdc++ 8.0 trunk has &lt;filesystem&gt; now?? https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/filesystem We need msvc 20 ABI breaking version. &lt;filesystem&gt; +1 
The ABI issue is that implementing it correctly requires calling new Windows APIs, which we generally can't do from the standard headers (we can't include Windows.h and we don't own the declarations of those things); and we can't add new exports from msvcp140.dll to expose the functionality because we allow app-local deployment of that thing. For example the current version totally mishandles symlinks (that is, it doesn't support symlinks or junctions at all) so we'd need new exports for all the interactions with those.
I think Beast is low-level HTTP/1 WebSocket library, The HttpClient and HttpServer can be implemented using Beast. Sorry , I feel that using beast is more troublesome, and it is simpler to use Asio (Non Boost)+ [picohttppparser](https://github.com/h2o/picohttpparser) to implement httpserver and httpclient. I feel good about this library, at least HttpClient.
It's not like C++ doesn't have lots of libraries that offer these features. They aren't part of the C++ standard, but they aren't part of the base python package from python.org either. You have to install them, and then you have them. That's true for both C++ and Python. The only thing Python has going for it here, which is a big deal I admit, is a decent package manager. If C++ had a package manager I think most of these kinds of arguments would evaporate. Also, staticians are one thing. I think it's totally reasonable to expect people in that kind of career to use Mathematica or R. But I have a general gripe, born of working with people who fancy themselves engineers and builders of computer systems, but who only know languages like Python, R, or Matlab. The notion that you can just go program big computer systems without needing to know CS, or really have studied programming or software engineering, is a real opinion that is widespread and leads to bad outcomes. I've spent way too much of my career untangling the mess created by such people. What makes it really irritating is that they are well meaning and really don't realize anything is wrong. If only it was clear that there is *more about programming that is useful to know* they would probably work harder to understand their craft.
I just wish there were more line-splitting options.
Just started using this last night, funnily enough! Had a few teething problems - I think the docs should at least mention deserializing _into_ STL containers, not just serializing out. I had to go through the issues list to find someone talking about how `operator=` was ambiguous for `std::vector` in this case, so I had to use `get&lt;decltype(myVector)&gt;()`. Also; what do you think differs between this and Cereal in JSON mode? I much preferred your documentation on the Github page though, hence my choice :)
Curious. How naughty are those unordered felines from implementer point of view? Does it have something to do with their long template parameter list?
`unordered_map` needs 8 guides taking up 80 editor lines (only somewhat bloated by our formatting). One example: template&lt;class _Iter, class _Hasher = hash&lt;_Guide_key_t&lt;_Iter&gt;&gt;, class _Keyeq = equal_to&lt;_Guide_key_t&lt;_Iter&gt;&gt;, class _Alloc = allocator&lt;_Guide_pair_t&lt;_Iter&gt;&gt;, enable_if_t&lt;conjunction_v&lt; _Is_iterator&lt;_Iter&gt;, _Is_hasher&lt;_Hasher&gt;, negation&lt;_Is_allocator&lt;_Keyeq&gt;&gt;, _Is_allocator&lt;_Alloc&gt; &gt;, int&gt; = 0&gt; unordered_map(_Iter, _Iter, _Guide_size_type_t&lt;_Alloc&gt; = 0, _Hasher = _Hasher(), _Keyeq = _Keyeq(), _Alloc = _Alloc()) -&gt; unordered_map&lt;_Guide_key_t&lt;_Iter&gt;, _Guide_val_t&lt;_Iter&gt;, _Hasher, _Keyeq, _Alloc&gt;; The main source of the nastiness is the need to extensively constrain the guides.
Don't forget about leveraging all the work I did to rid Win32 of MAX_PATH! As far as I recall, you guys said that posed an ABI issue as well...
Same problem vis a vis adding exports. At the moment fixed-size MAX_PATH buffers are passed over the DLL boundary. :( I apologize on behalf of my predecessors :/ ``` _FS_DLL void *__CLRCALL_PURE_OR_CDECL _Open_dir(wchar_t (&amp;)[_MAX_FILESYS_NAME], const wchar_t *, int&amp;, file_type&amp;); _FS_DLL wchar_t *__CLRCALL_PURE_OR_CDECL _Read_dir(wchar_t (&amp;)[_MAX_FILESYS_NAME], void *, file_type&amp;); _FS_DLL void __CLRCALL_PURE_OR_CDECL _Close_dir(void *); _FS_DLL bool __CLRCALL_PURE_OR_CDECL _Current_get(wchar_t (&amp;)[_MAX_FILESYS_NAME]); _FS_DLL bool __CLRCALL_PURE_OR_CDECL _Current_set(const wchar_t *); _FS_DLL wchar_t *__CLRCALL_PURE_OR_CDECL _Symlink_get(wchar_t (&amp;)[_MAX_FILESYS_NAME], const wchar_t *); _FS_DLL wchar_t *__CLRCALL_PURE_OR_CDECL _Temp_get(wchar_t (&amp;)[_MAX_FILESYS_NAME]); ```
The main ‘unless otherwise specified’ is when you’re adding a template specialisation of an existing std function for one of your own types. 
I know about it, but it follows the same logic as STL, I don't see the extra user friendliness. Perhaps I'm wrong. Anyway, I'll stick to STL, it's enough for me for the time being. :)
That's great! I see it even works on class template constructor templates, so long as the class template type can be deduced from the arguments, which is sweet. (Maybe it's just me, but I seem to take lambdas and parameter packs a lot in constructors, for... reasons) &gt; Another example is when you have constructors from iterators. Vector(InIt, InIt) needs to generate Vector&lt;iterator_traits&lt;InIt&gt;::value_type&gt; which cannot possibly happen implicitly, so a guide needs to say how to do it. That one makes sense to me, because it's not the same type as the passed-in one.
You could please open an issue at https://github.com/nlohmann/json/issues/new with the example that did now work?
c_sort, StrSplit, StrJoin...
If you think you're qualified, you are unqualified. If you think you're unqualified, you might be qualified.
Why http://fmtlib.net is missing?
Everyone already knows how to write a variable declaration. It should **not** look like this: auto foo{bar()}; Normal declaration look like this: progress::is::bad::mega_super_giga_container&lt;please::dont::attempt::different::techniques::better::yet::write::assembly_t&gt; foo(bar()); 
This library is about non-preemptive multitasking. My message is about non-preemptive multitasking. I bet you had no idea. But let's call this "progress".
&gt; not really equivalent at all They both do the same thing. &gt; Something a bit fancier will be even uglier with `shared_ptr`'s and `enable_shared_from_this`'s all over the place.
so those companies should volunteer to test also?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/7l05vd/newbie_looking_for_help_with_user_defined_input/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Is Karma actually fast (compared to naive loop and stringstream implementation)? Asking because Spirit didn't impress me with its speed last I used it.
I can not believe there is a company which earns from making Excel/PP plugins. Is MS Office that bad or think-cell features so brilliant?
This is an example: https://github.com/CaseyCarter/cmcstl2/pull/118 Deduction guidelines + concepts / SFINAE is one of the most common problems when writing generic code.
&gt; which cannot possibly happen implicitly It does happen implicitly in Rust, Haskell, and many other languages, so saying that this is "impossible" is a long shot.
And that's the kind of crap I don't like and why I rewrote all of the build scripts for it in a different way, one that works for iOS and macOS.
&gt; (though that's become a lot more of a pain to use lately) please elaborate
Indeed. erase, remove, del, kill in different libraries - sure - could possibly all mean the same/similar operation. But if saw erase and remove in the same library - let alone the same class - I would on the contrary assume different operations. Also erase is an unusual name for a method. While remove and del are often used, erase as a method name would make me assume that it is an unusual operations or is needed to distinguish from remove. The sane assumption is to assume a difference and then be annoyed if it turns out to be a redundant synonym - if that were the case.
When they pay you
Just remember: wrap the binary fold in parenthesis
&gt; This is useful for example for writing SQL requests in your code, because they can sometimes be more readable if wrapped over several lines. I hope no one does that.
&gt; This is useful for example for writing SQL requests in your code, because they can sometimes be more readable if wrapped over several lines. I hope no one does that.
Is it public? :)
Why are volunteers required to test the core platforms when continuous integration could do a much more effective job?
Why not? Because of the need too append ' ' at the end/beginning of each string?
In my experience, Spirit was quite fast. 
Depends on what you want to do with graphs. If partitioning, there are ptScotch and ParMetis
I find MP11 relatively simple and approchably-documented for a metaprogramming library. See also Peter Dimov's blog posts [here](http://pdimov.com/cpp2/simple_cxx11_metaprogramming.html) and [here](http://pdimov.com/cpp2/simple_cxx11_metaprogramming_2.html)
I am an engineer capable of solving overly complex problem that were originally reasonable ones before passing through the marketing department, how do I qualify? :)
I'm not opposed to purchasing tools, but I'm a single developer and what I'm working on isn't always going to be OSS. I found the following [website](https://www.synopsys.com/software-integrity/resources/datasheets/coverity.html), but I'm not seeing anywhere to actually see the cost or purchase the tool. This tells me they have a sales team and this is not something that individual developers are going to be able to afford. I looked at several others as well: klockwork, codesonar, and parasoft, and they all appear to suffer from the same thing. so for now I'm going to go with free tools as I don't think it's going to be a reasonable price for a single license of any of these tools since what I'm doing is mostly for fun. Which is too bad, I'm a big fan of paying for quality, but in this case I don't think it's worth it. Although if you disagree and have an idea on pricing I'd love to hear your thoughts. 
Great job! But why does it take so long for MSVC to implement Two-phase name lookup?
wow. It's going to take me a bit to work through all of these, thank you for being so thorough.
It should be noted that it also contains a vim-like mode. It's not as customisable as vim, but as someone who uses atom most of the time (the C++ plugin are shite), it's a wonderful tool to have when I need to jump into a C++ project.
The only thing that really keeps me from purchasing it is that you lose the ability to use the software if you don't renew the license. I'm really not a fan of that model. I think Jetbrains has a much more reasonable model for recurring payments.
thanks, I'll take a look at these.
Also useful: - Tools for tracing syscalls and libc library calls: `strace` and `ltrace` - Alternative memory allocators: `tcmalloc` (and whole [gperftools](https://github.com/gperftools/gperftools), which includes a memory profiler), and [jemalloc](http://jemalloc.net/)
thanks for all the info. It's going to take me a little bit, but I'm going to work through everything. I did add a ton of warnings to gcc and was able to catch a few issues, so that was super helpful.
thanks, I'm going to read through these as soon as I can. hopefully in the next week but it all depends on how the holidays go :)
thanks, I'll check these out.
Slightly OT, but I'd love it if fmt got standardized so it can get compile time warnings for misspecified format specifiers. I know recently some TMP solution was developed, but I don't believe it's cross platform currently (and probably slow).
You should never insert values for SQL statement variables using string manipulation. It leads to SQL injection attacks. Instead, you should be using the "parameter" system to resolve values, so that they get correctly formatted and normalised by the engine.
I do love the discussion that's taking place... but I also wonder if anyone wants to talk about the original topic please? :'c
I requested a license, they wouldn't give me one even though I was ready for payment. So I just made a tool to add/remove their header for the free version. Still amazing tool, but idk why they don't want to sell their software. I am a company of 1-3 people, and wanted to use PVS-Studio for us. They promptly told us that they would not offer any "enterprise" versions, and to use the free version. Yeah, running my tool takes about 10m to run through all the thousands of source/header files. One of those "shut up and take my money" situations.
Don't use linked lists! :) See the video from Bjarne himself: https://www.youtube.com/watch?v=YQs6IC-vgmo
https://github.com/VedantParanjape/LinkedList-/blob/master/LinkedList.hpp#L190: &gt; exit(0); Seriously?
Why what's wrong with that? My teacher does that all the time !! Anyways, What's the alternative ?
I agree, but please talk with ANSI committee as they have a &lt;list&gt; library in stl which uses linked list. And one more thing, please also talk with the education board to remove it from syllabus,as Bjarne said so.
&gt;Guaranteed copy elision VS 2017 15.6 finally
This leaks like a sieve. Since you're only new, it's good to get good memory management practices ingrained early. Basically don't ever use raw "new" unless you know what you're doing. And for the love of god, never call `exit()` from within a library.
std::list for double direction list and std::forward_list for single direction list. 
&gt; My teacher does that all the time This might explain some of the problems with your code, though for the sake of everyone in that class I hope you've just misunderstood when (and more importantly when *not*) to use it.
Sometimes, these videos are more trouble than they're worth.
Ask your teacher about failing gracefully (code, not your grades!)
Done, i wont call exit (), will do some research on it and slam the teacher for wrong knowledge What are the alternatives of new, in this situation, what other thing can i use to avoid new in this program
Personally i would use 'new' here, but remember that you need to 'delete' memory allocated with 'new'. In many cases it it better to use std::shared_ptr/unique_ptr/weak_ptr instead of 'new'. You can find them and other useful functions here: http://en.cppreference.com/w/cpp/header/memory
1. You should be using `std::unique_ptr&lt;&gt;` or at least `std::shared_ptr&lt;&gt;` to make sure you're not leaking memory like crazy (which you currently are) While i'm at it, here's a few more things: 2. in `T&amp; LinkedList&lt;T&gt;::operator[](int Location)`, you're dereferencing a potentially invalid pointer, because it only gets assigned inside a conditional. What's worse is because you're not initializing the pointer to `nullptr` it could point anywhere, making it very hard to debug when things go wrong 3. You're enforcing the template parameter to have an `ostream&amp; operator &lt;&lt;` to be defined. If i use my own data type with this linked list without defining that operator it won't compile (this is caused by your `show_all`) method. There's a few other things but that should give you some things to look at. Keep it up, things will click eventually. 
If you didn't already know, a preliminary proposal has been submitted: http://fmtlib.net/Text%20Formatting.html I don't have any insider knowledge, but based on the post history of /u/aearphen it looks like it was generally positively received. 
Oh shit guys, wait dont see the code, its the old one, and its wrong, i have updated the code, please check it out again. Sorry!!! github link: https://github.com/VedantParanjape/LinkedList-
You are still leaking memory. I would recommend you to get familiar with tools like valgrind, or AddressSanitizers LeakCheck.
Clang's behaviour is an issue with how they handle trailing return types. It has nothing to do with deduction guides: [example](https://godbolt.org/g/CVW6EU). Deduction guides are just anonymous auto returning functions with no body. [other example that is invalid C++](https://godbolt.org/g/Kw6Uz2) until C++2a (lambdas in unevaluated context).
Thanks, i will surely learn all the new concepts that you all mentioned, and update the code in the next build.
Well, please check out /r/CodeReview and ask politely if someone gives you a detailed review. In general the code has *a lot* of flaws and insufficiencies. - No dtor - leaks memory - pass by value, unnecessary copies - not initializer lists - ... Just quickly skimmed the code.
Thanks, i will put it on code review
CI isn't free on the scale that Boost needs it; who's volunteering to pay, exactly?
Yes, although I need to update them for 1.66.0 (it's currently targeting 1.64.0): https://github.com/Orphis/boost-cmake 
I'm working on the second revision and hope to present it in Jacksonville. Already addressed much of the feedback, most importantly about the feasibility of compile-time format string processing (which resulted in http://zverovich.net/2017/11/05/compile-time-format-strings.html).
&gt; **More formatting features:** the formatting possibilities of Boost Format are much richer. For example, amongst many other things, they include the reordering of the contents passed: Minor point - `printf` can also reorder its arguments. For example printf("%1$c%2$s%1$c", '-', "____"); outputs -____-
 node* n; //pointer pointing to newly created node node* t; Members `n` is not needed. You should not put a temporary inside a class. `LinkedList&lt;T&gt;::LinkedList()` should use initalization syntax or default value inside class definition, not function body. `LinkedList&lt;T&gt;::createnode(T data)` copies intead of taking `const T&amp;`. Similarly with `add(T data)`. There is also lacking `emplace(T&amp;&amp;)` overload. `add()` has duplicated size increment. Move it outside `if`. `T&amp; LinkedList&lt;T&gt;::operator[](int location)`. Counter should be of unsigned type (namely `std::size_t`). There is no point in negative index, and it will only cause compilation warnings. And lastly (apart from leaks) there is no support for iterators.
Actually i dont know what is initialization synta or iterators, can you point me to some resource to learn the same in detail
How is template argument an unevaluated context?
that's the POSIX printf, rather than the standard C printf though.
yes, I'm aware of the example (I posted one exactly the same in the second paragraph!) - but I'm not seeing any concrete evidence as to whether this behaviour is correct or not. MSVC actually follows the same interpretation that clang does, leaving GCC the odd one out of the 'big 3'. Skim reading the standard didn't lead me to believe one way or another either. I'm looking for hard evidence not just 'clang's behaviour is an issue...' Where's the evidence to back up that statement?
https://isocpp.org/get-started
That's completely off-base. std::string sql = "SELECT * FROM tbl1 t1 " "INNER JOIN tbl1 t2 " " ON t1.id = t2.t1_id " "WHERE t1.name = @name"; this is a perfectly reasonable sql string that is more readable in a broken up format and does not suffer from sql injection attacks. edit: formatting is crap due to non-monospace fonts on view, but you get the point.
Excuse me, but why are those signatures so weird? Is there a reason for them to use references-to-arrays?
That is a question that only you have the answer, not only the stuff on wich work on (web, compiler, games engines,...) plus the size of the project, there are really big and mediun, if you try to help Firefox or any other huge project the task you will face will be debug bugs and fix it, again, you should try to decide and focus on a set of projects, after that at least us as a comunity could help you make a good choice
why no love for raw string literals ? std::string sql = R"_( SELECT * FROM tbl1 t1 INNER JOIN tbl1 t2 ON t1.id = t2.t1_id WHERE t1.name = @name )_";
You haven't really written C++ if you don't know what iterators are. SO has tons of these questions. Most things you don't know already have answers on SO. ___ Initializations syntax: class Foo { public: Foo(int x); private: const int x; } Foo::Foo(int x) : x(x) { } Try to do it in the function body. It's impossible. That's the only way to initialize const members.
Maybe it is right, but im gonna have to stick with what's taught in the highschool course, i will buy a good book, and read from it during college. I wont be rewarded marks if i dont follow what my teacher says.
because it's orthogonal to the point that was being made... The real question is why go for the one-upmanship when it clearly adds nothing to the discussion? Don't answer that, I don't care.
1.64 is more than enough for me. I will give it a try when I have some time. Thank you very much!
I'm sorry, but that's what I said... In fact you've used the parameter system that I mentioned in your reply with '@name'.
I am using meson as my current build system. Maybe I will take a look for a conversion. But only maybe... lol. Would be good if I can integrate boost as a wrap file in meson but it must be a ton of work. Any information or caveats on how to build the libs? I will inspect the source code anyway and compare. Thanks for your hard work again!
Marks are worthless if they teach you wrong. I have similar problems and it's currently on the point of discussions with co-teacher of the subject. If this won't help I will write an official list. I'm sure my university does not want to let outside an information that some teachers not only teach wrong, but impose bad habits and write garbage code by themselves. ___ About your problem: Give this to the teacher. It will not compile. Brace initialization is the only valid syntax for const members and non-trivial ctors. I can bring multiple other examples where compiler will force to write it. class Foo { public: Foo(int x); private: const int x; }; // Foo::Foo(int x) : x(x) { } // the only valid way Foo::Foo(int arg) { x = arg; } // this is not possible int main() { }
/r/gameideas I can bring you libraries.
`invalid use of incomplete type` that's the error
Most importantly, make sure you `delete` anything you `new` -- this is why you need a destructor. There is plenty of room for improvement as others have mentioned, but I understand needing to work within your course. Don't get discouraged! C++ is a big language that has changed tremendously over the years. Check out the /r/cpp_questions as well as CodeReview in the future. 
If you don't pass arrays as references, they decay to pointers and the size of the array is no longer checked. For example: void f(char [256]); // it's actually the same as void f(char*), the size is ignored void g(char (&amp;)[256]); void h() { char badbuf[128]; f(badbuf); // compiles ok, badbuf decayed to a pointer! g(badbuf); // compile error, array size mismatch! } 
I'm also interested in projects to work on -- http://webEbenezer.net/about.html
&gt; Visa Sponsorship: Yes How come that another posting of MSVC job in this thread says that they (you) are unable to sponsor visas?
Thanks, i will surely check out /r/cpp_questions, actually last time i had asked this question, i got replies that why are using dtor, the data will get cleared after exit, so i didnt add dtor But i will make sure that i will use shared _ptr and dtor for the next build
you may not care but everything on the internet is read by beginners ; everything written should always strive to give the best way to do something. Internet is a giant wiki.
I would assume it is to help static analysis tools. 
No one is disputing what you said, only that it is entirely irrelevant to this discussion and is misleading people into thinking that breaking up a string literal to multiple lines somehow causes SQL injection attacks.
&gt; and we can't add new exports from msvcp140.dll to expose the functionality because we allow app-local deployment of that thing Can you explain why adding *new* symbols is a problem?
&gt; Internship with an insurance company this summer [Awww, you are the guy in the middle.](https://i.pinimg.com/originals/56/e3/ea/56e3ea40a6a9c0eb11930e857c394199.jpg) Quite sure coding hardly will be hardly an issue, but you will realize there is a lot of shit you need to learn to deal with that crap. 
Ah! I totally misunderstood the reply. When the poster indicated wrapping strings in quotes, I thought s/he was talking about generating an SQL statement inline. Sorry for the noise!
A lot of information here. Is this opportunity still available? And also, what would be my responsibilities if I pursue this?
I've never coded a game before! I'm not afraid of the logic and stuff, I just don't know how to start lol (like getting the libraries, what platform to use, etc..) . If I decided to go down the this route, would you mind helping me get started? 
haha lowkey that picture is hella accurate. What are some example things that'd id need to learn to deal with the shits? 
Quite proud of this video tutorial I made back in 2013: https://www.youtube.com/watch?v=_4K3tsKa1Uc
If that were really the goal one would think you would have: a) used the more generally used default delimiter of nothing rather than '_', or b) explained the usage of delimiters, and c) linked to documentation for further reading. but what do I know...
I think that writing out plainly "raw string literals" is enough, considering that a google search for "raw string literals" yields more than enough reference data in the first results to help oneself learn about what it is and how it works.
weird because I think the article in question also mentioned raw string literals and if just mentioning them was enough then you would have thought you would be satisfied with an article that went more in-depth than your reply did. That's the problem with one-upmanship. When you get called on it you start getting nonsensical trying to defend it.
... I don't see the point ? I come to reddit mostly for comments and doubt I'm alone in this. 
you didn't read the article. well that explains a lot.
Yes, it's still available. You would have to provide leadership in terms of a project. I'll join your project if you provide some vision and are willing to use my software in the project.
You could port my CMake files to Meson if you wanted. It's pretty straightforward to do, at least if you don't require all the modules. The trick for context is to have unified assembly files where you can do the platform and architecture selection directly with the preprocessor instead of doing the work in the build system. Most preprocessors will have the information available there for you to use, it's a shame not to use it! It makes it possible to do multi-arch builds directly targeting real devices or the simulator automatically. They have that for macOS already, I just wonder why they don't do that for iOS or combine it with the other platform files upstream.
A lot of the suggestions below have to do with your destructor/cleanup issues. Honestly it's a bit tricky to get that right. Are you to follow the rule of 3? 5? 7? I would recommend keeping all of that noise encapsulated in one class, and let other classes concentrate on other things. For example this class should only be concerned with the listiness, and so I would strongly encourage you to check out `std::unique_ptr&lt;node&gt; next;`. Then there's no cleanup issue at all (don't even write a destructor) since it's handled by the pointer type (which would cause next to be deleted if it's not null, and that object will delete it's next, etc.). I would recommend initializing members at their point of declaration when feasible (as I believe it is in every case here), so you know you can't possibly get it wrong. That's less necessary if you switch to unique_ptr (it initializes to nullptr if you don't specify, which is what you want anyhow) but you could/should still do std::unique_ptr&lt;node&gt; head = {};//The = {} is redundant, only useful if you think being super explicit is cool, in this case explicitly initializing to default. int size_ll = 0; And then actually you have no need to write a default constructor, either. If you want to state to the compiler a default constructor is expected, that's what `LinkedList() = default;` is for. It would be nice if you didn't automatically assume T is cheap to copy. For example if I call add it copies it just to call add, then copies it again for createNode, then it gets copied again inside createNode. Since you're creating a container I think it would be nice for callers (and potentially generic algorithms) to stick to naming conventions found in the standard containers. You basically did this for size (though it typically returns a larger unsigned type, like size_t), but add() would be push_back(), del() would be erase(), and you should definitely provide begin() and end(). Also all the element access functions (like your operator[], begin(), end(), at(), front(), back()) should have const overloads so if you have a const container you can still look at it (but get T const&amp;). In particular, what you're really doing here is implementing forward_list, so check out its interface (including the nested typedefs!) http://en.cppreference.com/w/cpp/container/forward_list By the way, it's unusual to provide index lookups into a container where such implementation is linear time. Conversely, one of the major cool things about a list is splice, which you did not provide. What do you mean that it doesn't work with char? This program worked fine for me: #include "LinkedList.hpp" #include &lt;iostream&gt; int main() { LinkedList&lt;char&gt; l; char c; while ( std::cin &gt;&gt; c &amp;&amp; c != 'q' ) { l.add( c ); } std::cout &lt;&lt; std::endl; for ( auto i = 0; i &lt; l.size(); ++i ) { std::cout.put( l[i] ); } std::cout &lt;&lt; std::endl; } 
Bedides focusing on the game, what you need is: - system event handling (mouse, keyoard etc) - 2D/3D Graphics - Audio (optional if it's a small game) - Network - I would not recommend it though for the first game My choices are - [SFML](https://www.sfml-dev.org) for 2D (add SFGUI and Thor for more convenience) - [Magnum](http://magnum.graphics/features/) for 3D Both libraries are multiplatform. SFML is very easy to start and has very well-written tutorials. [Example short program](https://www.sfml-dev.org/documentation/2.4.2/). I have written 2 sample games based on this library - [Solitaire](https://bitbucket.org/Xeverous/solitaire/src) and [Minesweeper](https://bitbucket.org/Xeverous/minesweeper/src) (this one was for studies and has full Doxygen comments). Both are C++14. Magnum offers a lot more but it's much bigger and has more steep learning curve. I'm currently learning it. 
You might first take a look at [this Reddit discussion](https://www.reddit.com/r/cpp/comments/6zjub9/msvc_now_has_partial_twophase_name_lookup/) or the [VCBlog post on two phase name lookup in MSVC](https://blogs.msdn.microsoft.com/vcblog/2017/09/11/two-phase-name-lookup-support-comes-to-msvc/). Each has a pretty good explanation of why it's taken so long to get most of two-phase implemented in our 35+ year-old compiler. If you have any questions that aren't answered in those links, please ask!
Happy to please! But it *is* a C++17 feature. It hasn't been that long that we've lacked support for it.
I think it's meant to replace void*. Enforcing the use of explicit casts when accessing a container that can hold different kinds of data makes sense to me.
Ah that makes sense. Still, I would've designed the API to use pointer+length or `array_view`. Seems weird to be using some weird upper limit. But I dont know anything about Windows, so I might just be the stupid one here :)
Let the developers know what you would like to see!
It enforces a memory allocation though (excluding any small buffer optimization)
Well isn’t it possible to have a local buffer with size =max(T1,...,Tn) ?
That is beautiful. I can say with confidence, I am never going back to ostreams or printf.
I have used types like std::any in maps from int to anything. The calling code knows that id 0 is associated with a string, id 57 with a short, and id 99 with some struct I wrote. The code that owns the storage doesn't need to know the type this way.
It's not useless in concept, though I personally would deeply question the quality of any code relying upon it without strong evidence that it's _really_ the only viable approach. The general gist is that `std::any` allows passing ownership of arbitrary values across boundaries that don't know about those types. Your code might know about type `Foo` but need to produce it in one function, pass it to some third-party library, and then expect that library to later pass it back into your application. From your applications' perspective the value will only ever be a `Foo` and never anything else, but from the library's perspective it _could_ literally be anything. For instance - and I'm not claiming this is a good idea, just an example - a very generic delayed event queue system could be constructed. The queue would support event of any type with no requirement for any base type, it will store events for some time, and then dispatch those events to any registered consumers. Because the queue holds onto the event it must take ownership of the data and because there can be zero, one, or many consumers for an event the queue cannot rely on consumers themselves destroying the event object; this in turn means the queue must know how to destroy the event object, but there's no required base type so the queue has no way to know _how_ to destroy any particular event object. Because the queue support events of arbitrary types it has no way to filter which consumers receive which events, so it has to hand every event to every consumer when it's dispatched, meaning that the consumers themselves must have a way of checking that the type of event before processing it. Such a queue would possibly be best implemented via `std::any`. Producers would push a `std::any` to the queue which would in turn hand a `std::any const&amp;` to each consumer when dispatched. Each consumer knows how to process events of certain types and so it would query the provided `std::any` to see it matches a known type, and process it if so. After each consumer has received the event object, the queue would then let the `std::any` destructor deal with cleaning up the actual object. For further illustration, a C implementation of this pattern would need three pieces of data for each event: a `void*` to the event data itself, a `void(*)(void*)` function pointer for freeing the event data after it's been dispatched, and a type tag of some kind. And that's basically what `std::any` is under the hood.
It only possible if you know size of **any** type (i.e. not possible). If you have finite list of types look to std::variant.
Right sorry, I confused it with std::variant. My bad
I don't get what you mean. With `void*`, you can allocate whatever on the stack and pass a pointer top it with zero overhead, at the cost of being type unsafe. `any` more or less required by design a heap allocation. Thus, `any` is not a replacement for `void*`. If a function that is part of your API takes a `any`, then you are implicitly stating that a call to such a function always (again, ignoring SBO) involves a heap allocation.
Excellent work, C++ has been in need of a standard Boyer Moore substring search function for a while. I would love to see this extended to multiple substring search, such as that developed by KMP, or perhaps even my own implementation of Aho-Corasick, which has favourable properties over KMP (O(m+n) complexity, O(m) memory complexity). https://github.com/cjgdev/aho_corasick
Somewhat off-topic... std::string stringInQuote = R"(This is a "string" and a second line)"; I assume the literal contents of this string is (practically speaking) unspecified depending on the text editor you are using? I.e. '\n' vs '\r\n'... 
 #define malkovich auto
Because we allow app local deployment: Let's say we have printDriver.dll and program.exe. Program.exe does app-local deployment of msvcp140.dll, and printDriver.dll uses the redist. And let's say printDriver.dll was compiled with the updated msvcp140.dll with more symbols. When you launch program.exe, since app-local "wins" the old copy of msvcp140.dll is loaded into the process. Then the user clicks print, printDriver.dll tries to enter the process, and then crashes the process because exports it wants aren't present in the copy of msvcp140.dll currently loaded. It looks like printDriver.dll is at fault for crashing the process even though program.exe did the more suspect thing of deploying app-locally. This is why we tried to prohibit app-local deployment in 2015.
Because my predecessor wanted to cause me pain?
Implementations are encouraged to use SBO. If you really don't want memory allocations, then create `std::any` with `T*` instead of `T` and almost surely the buffer will be big enough for a pointer. SBO is not a guarantee though I expect libstdc++, libc++, and MSVC to have it at least.
checking it out rn. thanks yo!
this is perfect! thanks for the help yo!
Amusing, but this isn't r/ProgrammerHumor.
Confirmed!
Implementing linked lists with `std::unique_ptr` is a fun exercise, if nothing else. You get a good feel for how to use them. Double linked lists as well (the reverse link is a raw pointer). But a word of caution: the automatically-generated destructor is disappointing. It has to be implemented as a recursive call to destroy each node, and optimizers can't get ride of this (it's not tail recursive, for one thing). With a very large linked list, that's a really bad thing. So I'm not sure it's the right solution in production code. But then again, linked lists are rarely the right solution to anything.
&gt; This is why we tried to prohibit app-local deployment in 2015. So I guess the outcome is that it has not been prohibited? It looks like this problem could occur again and again, do you have any plan to address this whole class of issue? 
&gt; So I guess the outcome is that it has not been prohibited? Backlash was too high, yes. &gt;do you have any plan to address this whole class of issue? Open to suggestions :)
No, it's guaranteed to be '\n': http://eel.is/c++draft/lex.string#4 (This is technically a non-binding note but I'm assuming it is specified indirectly somewhere else)
I've set that up for our production codebase and it's absolutely lovely.
I've been using an `any` type for some kind of Entity Component System. The way to use it effectively, I find, is *not* to expose the use of `any` to the interface. `any` is an implementation detail. You use it to store anything inside a container, and if need be, refer to the object via some `id type`. However, the external interface should accept the types as they are, only using any for type-erasure. And when recovering it, you don't give the `any` back to the user. In some cases, you don't even have to recover the object externally. Hence why I use it in an Entity Component System. I access these objects (entities) via properties (components), so there is no notion of casting in the external interface. Sean Parent's talk "Inheritance is the Base Class of All Evil" shows a neat design pattern based around type erasure as an implementation detail without forcing the external API to expose it.
Apart from cutting the DLL in pieces with updates that can somehow supplement too old app-local base ones, I have no idea. I'm not even sure the DLL plumbing would permit to implement that easily... Good luck! :D 
**Company:** [RaySearch Laboratories](https://www.raysearchlabs.com) **Type:** Full time **Description:** RaySearch is a technology company with a difference - our software is a vital weapon in the ongoing battle against cancer. We help save lives through innovative software for radiation therapy, which is one of the most important forms of cancer treatment. Our success has led to rapid growth and we are therefore looking for talented software developers. RaySearch believes in investing in its people. We offer outstanding staff benefits and excellent career development opportunities in a flexible and stimulating environment. We prioritize knowledge-sharing, creativity and collaboration, and you will work together with some of the most talented and highly educated people in the industry. You will work in a modern office environment with access to the latest hardware and tools. We encourage a healthy work-life balance and have created a strong social culture, with regular events and activities for employees. RaySearch is committed to equal opportunities. We value diversity and are dedicated to preventing discrimination. [About RaySearch Laboratories](https://www.raysearchlabs.com/About-RaySearch) **Role** We are recruiting skilled C++ developers to join our development department. Our development department is organized in agile teams with physicists, algorithm developers, application developers and test specialists, all dedicated to designing and evolving cutting-edge medical software. Developers generally participate in all steps of the development process, including analysis, architecture, design, implementation and testing. We recruit for full-time positions based at our head office in central Stockholm. **Education &amp; Experience** * MSc in engineering physics, computational science, or similar. * 3-10 years of experience in an academic or industry environment. * Strong programming skills, especially in C++, modern C++ and architecture. * Strong algorithm skills preferably including parallel computations on CPU and/or GPU. * CUDA skills are meriting, but not required. * Specialized knowledge in physics or algorithm development is required for the respective competence groups. * Software development in C#/.NET is meriting. **Location:** Stockholm, Sweden. Fluency in English is required. Fluency in Swedish is a strong advantage. **Remote:** No **Visa Sponsorship:** No **Technologies:** * Parallel algorithms both on CPU and GPU. * CUDA experience very much appreciated (we currently rely on C++Amp). * C++11/C++14, will adopt C++17. * Visual Studio (currently Visual C++ 2017), boost, google test with visual studio integration, ReSharper C++ &amp; C#. * The algorithms are implemented in C++ and the application layers in C#/.NET, under Windows, for Windows. Scripting in Python. **Contact:** To apply, email your letter, CV and transcript of records including course listing with grades to work@raysearchlabs.com, subject "reddit c++". Questions are asked to the same address. More information and positions, in Stockholm and elsewhere: [RaySearch Laboratories Career and other open positions](https://www.raysearchlabs.com/career), [RaySearch Laboratories at Stack Overflow](https://stackoverflow.com/jobs/companies/raysearch-laboratories). 
/u/foonathan is right, it's `\n`. The standard guarantees that all newlines in the code are mapped to what is called the *new-line* character of the *basic source character set* [[lex.charset]/1](http://eel.is/c++draft/lex.charset#1): &gt;Physical source file characters are mapped, in an implementation-defined manner, to the basic source character set (introducing new-line characters for end-of-line indicators) if necessary. [[lex.phases]/1.1](http://eel.is/c++draft/lex.phases#1.1) These "basic source characters" don't necessarily correspond directly to the codepoints used in your source file (not even ASCII or Unicode), but the standard guarantees that you end up with *new-line* regardless of your newline format. Luckily, *new-line* is exactly equivalent to `\n` - you can see the mapping from escape sequences in [Table 8 in [lex.ccon]](http://eel.is/c++draft/lex.ccon#tab:escape.sequences). 
I used it pretty heavily in a Lua runtime I wrote. It was a useful tool in making the glue layer mostly transparent to both sides while maintaining type safety. 
&gt; zero cost, composable, inlineable AFAIK, /u/14ned had exactly that in AFIO v1; I don't know if they survived into v2 or ended up in a separate library or whatnot... Niall?
My point with the second example was that Clang is lazy and doesn't discriminate between constexpr value and non-type parameters ones (which is non-compliant until 2a). Therefor it's likely invalid. Otherwise its UB.
No discussion of `string_view`?
&gt; Backlash was too high, yes. What were the specific reasons given? Was this a "we'll always need this forever and ever and ever" or a "not right now but who knows maybe later someday" ?
string_view is great, but being immutable makes it hard to use for building strings
I love you
&gt; You should never insert values for SQL statement variables using string manipulation. It leads to SQL injection attacks. Your sentence as written is quite wrong. You're missing a key point - it's string manipulation _of user-entered data_ that is the security hole. 
I have been hit by this but worked around it by changing the code which is of course not always feasible if it's third party libraries. Otherwise it's also annoying that override is not supported for those macros. There is a [5 year](https://github.com/google/googletest/issues/533) old still open bug report about that.
I thought manifest-based redirection was supposed to address this scenario: if a newer version of the DLL was globally installed it would supercede the app-local installation. That way, you could still do app-local to use the DLL without requiring system-level installation, but retrograde overrides wouldn't occur unless specifically forced. There were lots of problems with the way CRT manifests worked, but IMO they were fixable. Better tooling for managing and diagnosing manifest binding issues would have gone along way vs. what we had at the time (strings -a *.lib | grep CRT). 
True, but under the covers string storage is immutable too! 
Looks like the latest video is three years old.
It is pretty fast and will easily beat stringstream and a naive implementation at least on integer formatting (http://zverovich.net/2013/09/07/integer-to-string-conversion-in-cplusplus.html).
with c++17, string::data() returns non-const char*
Boost peer review said no synchronisation nor resource management in V2. So we have neither, it's on the end user. That turns out to be quite handy in fact, it "just works" with the Coroutines TS for example. And we do of course design to make it easy on the end user to manage lifetime.
Uh, so do you still have your zero-cost futures code available or not..?
Yeah, but it's only guaranteed during the lifetime of that call.
Yeah, but it's only guaranteed during the lifetime of that call. &gt; The pointer obtained from data() may be invalidated by: &gt; Passing a non-const reference to the string to any standard library function, or Calling non-const member functions on the string, excluding operator[](), at(), front(), back(), begin(), end(), rbegin(), rend(). &gt; 1) Modifying the character array accessed through the const overload of data has **undefined behavior.** &gt; 2) Modifying the past-the-end null terminator stored at data()+size() has undefined behavior. 
Interesting, although if I ever saw something like that I'd probably tell the author they're writing in the wrong language. (As I'm sure would you!) &gt;a C implementation of this pattern But (again, I know you aren't advocating it) the very fact this pattern is expressible in C should give one pause; polymorphism and type safety needn't be at odds. (Stray thought: Was C's `void*`/callback polymorphism the reason so many 80's and 90's programming languages chose dynamic typing?)
https://stackoverflow.com/questions/38835747/type-erasing-type-erasure-any-questions So here we extend an any (which is a copy/move wrapped `void*`) with an arbitrary set of additional operations to be type erased. Now I can create a queue of printables: constexpr auto print = any_method&lt;void(std::ostream&amp;)&gt;([](auto&amp;&amp;self, std::ostream&amp;os{os&lt;&lt;self;}); using printable=super_any&lt;&amp;print&gt;; using print_queue=std::deque&lt;printable&gt;; I can queue up log messages, pass between threads, decide later if I want to log, etc. I could write key-data storage that supports serialization and deserialization, through distributed deserializers registered at runtime and serializers type erased into the anys. Consumers of the keys would have to know whay is in them. 
absolutely, it's the biggest drawback
Damn that sounds like great material for C++ beginner!
&gt; adding sqlite3 to a project was like 4 lines in a makefile, if that. Yea - on Windows, Linux, macOS, iOS, and Android, right? Sorry for being a bit sarcastic here - I couldn't help it ;-) I appreciate your message! In contrast to that, `#include "nlohmann/json.hpp` works on _all_ of these, without requiring any build system, package manager, fiddling with any paths, any `.a`, `.so`, `.lib` or whatever files, without building anything on any platform in fact. So no, what you propose is far from a solution. At least as long as C++ gets a `pip install XYZ` that will work on any platform, which won't be any time soon.
&gt; but it's only guaranteed during the lifetime of that call that's not what it says though. the pointer is valid until you call other std functions that could mutate the string (because they could make it reallocate the buffer, for example). and the case of undefined behavior that you highlighted is talking about the other overload of data() that returns const char*
Ah. You're right. Still a lot of baggage and asterisks to remember. I would immediately flag modifying a string's buffer in a code review as it reduces maintainability. It also doesn't address the concatenation problem. Is there a situation where modifying a character directly in this fashion is advantageous?
&gt; Is there a situation where modifying a character directly in this fashion is advantageous? not so much for single characters (you can already do that through operator[]), but useful for things like passing to c apis that want char*, or wrapping in another mutable buffer type like boost::asio::buffer()
I needed it tho :V
Except it comes with a cost, so it doesn't really replace `void*`. It's really like an owning `void*` that also gains the ability to be copied and moved. It's not the the `void*` is copied, but the contents are.
It's in source control history, but otherwise gone. Thing is, futures are never zero cost. They require at least one atomic as they must synchronise threads. For some SCM filesystem algorithms that's actually a huge relative cost, and AFIO V2 is built for just around the corner SCM applications. Some members of WG21 are actively pondering how an iostreams v2 which works well on SCM might look. But it's a post 2025 thing, long way out yet, mainly because it's very hard to create a consensus for decisions regarding such new technology. But don't worry, key members of the committee want this to happen, so it's just a question of time and patience.
Thanks I was not familiar with it
Regarding the future of futures, I think Bryce has some strong opinions on that. I can say my non allocating futures were about twice as fast as allocating futures. I think it safe to say they're as fast as you can do if you want to keep arbitrary continuations and a non intrusive design. So there's not much left in there without cutting features or radically imposing learning curve on end users.
std::array&lt;int, 10&gt;
Lots of other comments answer your question so I'll leave this annecdote; as I've become a more experienced programmer I've removed the thought process from my head of "I don't understand this so it must be useless/can be removed/why does it exist". My own ignorance or inexperience is not a valid reason for thinking something is useless. Over time, I've found myself in interesting situations trying to solve a problem, and realising that the best solution is to use feature X that I read about way back but at the time didn't know how to use it. Don't get me wrong; never stop asking *why*, just don't go around and say "this is useless" when you have no idea why someone else may need it or how they're using it.
Alternatively for a dynamic array you can use [std::vector](http://en.cppreference.com/w/cpp/container/vector), with fun algos such as [std::accumulate](http://en.cppreference.com/w/cpp/algorithm/accumulate).
You can iterate over every item of a container (like std::vector or std::array or a low level array) with: for (const auto &amp;i : foo) { // Do stuff with I } 
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7l68yz/c_programmer_here_whats_the_c_way_for_arrays/drjvtv8/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
For arrays whose size is known at compile time, use [`std::array`](http://en.cppreference.com/w/cpp/container/array). It's essentially just a wrapper around a (stack allocated) C array + size, but with the conveniences of being a standard container. You can read more about the benefits of std::array over a C array at [its cppreference page](http://en.cppreference.com/w/cpp/container/array). If you need a variable-length array, use [`std::vector`](http://en.cppreference.com/w/cpp/container/vector)(if you need a dynamic fixed size array, still use `std::vector`). It's generally implemented by having an internal heap-allocated array and creating a new, larger array and copying elements over when more space is needed (though this is in no way guaranteed by the standard). It does, however, guarantee amortized constant time insertion of elements (note the "amortized", though it's unlikely to be a problem in the vast majority of scenarios). std::vector has a few quirks/caveats - it will not decrease in size when you remove elements unless you call `shrink_to_fit()`. Also, pointers/references to `std::vector` elements could become invalidated upon resizing. There's also the abomination that is `std::vector&lt;bool&gt;`, but I won't get into that.
I'll give a very concrete, specific example. Let's say you have some interface: class Learner { virtual void learn(Input x, Output y) = 0; virtual Output predict(Input x) = 0; virtual ~Learner() = 0; }; Great. We write some implementations of this: SvmLearner, NeuralNetLearner, etc. Now, let's say that we want to be able to create a different learner, based on runtime configuration. This is a well known problem in runtime polymorphism. The solution is a factory. A very simple factory could look like this: unique_ptr&lt;Learner&gt; makeLearner(const string&amp; learner_type) { if (learner_type == "svm") return make_unique&lt;SvmLearner&gt;(); ... } So far, so good. Why `any`? Well, the learners probably are not default constructible. And SVM learner might need a choice of kernel and parameters for that kernel, a Neural Net learner might need the the network architecture (the types of neurons and their connectivity structure). But, each constructor will have a different signature. How can we pass these types through our factory? Well, we have to totally type erase the arguments. One way to do that is to simply have every constructor take an `unordered_map&lt;string, any&gt;`. Each constructor expects certain types at certain key names, for example one constructor might internally do `m_foo = any_cast&lt;double&gt;(arg.get("foo"));`. So the factor will look like: using ConfigType = unordered_map&lt;string, any&gt;; unique_ptr&lt;Learner&gt; makeLearner(const string&amp; learner_type, ConfigType conf) { if (learner_type == "svm") return make_unique&lt;SvmLearner&gt;(std::move(conf)); ... } This map of course would be constructed from the config as well. Such a structure can represent fairly arbitrary things in a reasonable. You can imagine reading many config structures into it (like json), but it lets you remain agnostic to a particular serialization and implement that logic separately.
Yeah, I believe he works at Apple now. 
Happy to please! 
Thanks for bringing this up. I was working on my own version of this a while back and I haven't had a chance to get back to it. I think I left off with support for a function taking just the piece of data. I had some ideas for arbitrary parameter lists and return type without needing to specify them explicitly. One idea was reflection, of course, but there were some less... production-safe ideas to get around that. Didn't have the time to explore them fully. Where I left it, the usage was something like this: struct CallMe { using result_type = int; template&lt;typename T&gt; int operator()(T data) const { ... } }; super_any&lt;CallMe /* add more as needed */&gt; a{5}; std::cout &lt;&lt; a.call&lt;CallMe&gt;(); // prints whatever int was returned It's interesting comparing and seeing how you introduced `any_method` to deal with this. I think my crazier ideas for "figuring out" parameter and return types would be unaffected by that change and it does have a nice feel to it. My thing also supported a `a.call(callable)` form, which could be handy with no-boilerplate support of existing code and lambdas if those ideas work out. One thing I've found useful to include, at least for my purposes, is a construction requirement. For example, the ability to specify a `printable` that can hold only integral values. Or an `expression` type where you can call `eval`, etc. and hold only AST expression types. That simply makes the type less likely to hold something you didn't plan for while leaving the door open to new types that satisfy that requirement.
Others have answered it in various ways, but here's a slightly different rationale (maybe): When we start out as C++ developers we're taught that when we need to hold things in containers that we only know the types of at run time or can be different types inside the same container, to use inheritance - i.e., use abstract base classes that our container knows about/holds, and make the users of the container derive from the base for their specific types. But then later on we sometimes discover that using inheritance to solve these types of issues becomes annoying in practice. Requiring all other developers using your container library to derive from a base class just to store some opaque state is often overkill, and puts more burden on the user of the container. This might become more obvious in a bigger company code base. For example one group writes a network connection library, another uses that in a generic UI app library, and the third finally uses that in a specific app. The specific app guys would like to store some app-specific state per connection - maybe a client identifier number, or a string cookie, or whatever. Storing it in the connection object makes some sense. Would you rather have the connection lib expose some base class that has to be derived by the app-specific code just to store an integer/string/whatever, or would you rather just let them store the exact thing they want without having to go learn about some connection library they're indirectly using? Of course this isn't a "use `std::any` all the time" type thing - it's just another tool in the toolbox, which makes sense in some cases but not all or even most.
"String manipulation" involves actual manipulation; what does this code (which performs simple assignment) have to do with anything..?
You can't "get nonsensical" if you never made sense in the first place.
With one proviso: what constitutes an end of line indicator in the source code is implementation defined, so an implementer could define their end of line indicator as something entirely different, and ignore new-lines you insert. Theoretically, their end of line indicator corresponding to what you expect is a quality of implementation issue. Realistically, of course it's not an issue at all.
Seems to me you've missed a few possibilities that can be quite useful. For simple string concatenation, using `std::string`'s `operator+` or `operator+=` can be somewhat inefficient--unlike `std::vector`, `std::string` does *not* guarantee geometric growth, so growing a string in bits and pieces can have quadratic complexity. There are a couple of ways to ensure against that. One is to use a `std::vector&lt;char&gt;` as an intermediary, since it doe guarantee geometric growth. Another, that can be preferable at times is to use an approach similar to template metaprogramming, where you create a class that overloads `operator+` to just store something to refer to each input, and then overload `operator std::string` to measure all the inputs, reserve enough space, and copy all the data into that space at once. I included such code in [an answer on Stack Overflow](https://stackoverflow.com/a/47806884/179910) fairly recently. As far as reading an entire file into a string goes, there are a couple of approaches. The one you've noted (`temp &lt;&lt; stream.rdbuf();` ) works well for small files, but (at least in most implementations I've seen) slows substantially when reading large files. For large files, you're typically *much* better off using code on this general order: std::string s4; file.seekg(0, std::ios::end); s4.resize(file.tellg()); file.seekg(0, std::ios::beg); file.read(&amp;s4[0], s4.length()); By my measurements, for an 8 megabyte file this improves speed by a factor of around 3 to 4 (and for larger files, expect the factor to be larger as well). Although you can't do it in entirely portable C++, I think I'd be remiss if I didn't at least mention one other possibility: just memory map the file. For POSIX/Linux, you'd do this with `mmap`. For Windows, `CreateFileMapping` and `MapViewOfFile`. At least in my experience, this performs extremely well on Linux, but not nearly so well on Windows.
We have our own internal::any that we have been using for JSON parsing library. It makes sense to have type safety in places where one endpoint is targeted to be very generic.
This is very impressive, but I must say syntax is ugly as hell... I could live with c/p the implementation in the header somewhere and not looking at it ever again ;), but unfortunately even user code is ugly...
As a help post, this is off-topic. I'm going to approve it because it's collected some useful feedback, and by writing code you've demonstrated much more initiative than most questions, so I'm feeling unusually lenient about the rules.
I'm still on VS 2015, but I'm probably going to be switching soon, and I can't wait to start playing with C++ 17 features. Thanks for the update. Also, as an aside, the MSVC team has really been making some great strides in the past few years. I've been impressed with the refactoring work on your compiler and commitment to getting new language and library features implemented. As someone who has been using Visual C++ for a long time, and has who has seen very pronounced periods of stagnation during that time, I really appreciate the energy of the current team!
Thanks ☺
I'd deeply argue that JSON libraries should use a `variant`-like... er, variant, since the types are well known to all layers. Even systems relying on reflection to marshal arbitrary types require additional metadata than that carried in `any`. Which is largely why I dislike `any` in practice. It's exceptionally rare to _truly_ have zero constraints on the type of a value and zero needs for additional metadata.
&gt; JSON grrrrrrr 
Qt uses `QVariant` which is similar to `any` in its model/view implementation of functions which are passing data. I don't know the exact reasons for that decision but imo it simplifies the interface of classes you need to implement, makes easier to create proxy models, so you have to forward values only from one function. Sometimes it provides more info on values returned by user, like instead of text user returns `int` and you can use it for sorting or something like that. Though the latter functionality is not exactly easy to do with raw `std::any`. Additionaly any sort of overhead it may create mostly irrelevant when it comes to UI. The other thought about `QVariant` and `any` is that sometimes having `std::variant` of 20 types is just too much and you'd be better off with `any`.
Thanks! And if you hadn't heard, while it's best to compile everything consistently with the latest release, the 2015 and 2017 release series are binary-compatible, so you don't need to rebuild all of your separately compiled dependencies in a single blast.
Unfortunate that the article does not mention pkg-config, which has been the defacto standard for external dependencies on Linux et al for over 15 years now. Does Bazel not support it at all?
Well, it is certainly advanced, but the main message besides the actual talk is: **Meeting C++ talks are coming**, Jens mentioned yesterday that, after some initial hickups in the process, he is about to upload the others over the next days/weeks. That's a nice christmas gift, thanks Jens! :)
I agree that it is rare. But in many situations, especially as you write code, it can be practical and easy to pick up. It is like having a few constraints in templates u know and do not specify vs having to do a concept-based library upfront. It gives pragmatic flexibility IMHO in many situations.
What about Rust's cargo system? I at first found it kind of annoying how you had to use it for fucking everything as the stdlib is tiny, but the ability to lock your dependencies to a specific hash with the Cargo.lock is kind of nice. And unlike pip install, it's not global and can handle multiple projects with different versions of a dependency.
I think this is the gist of it. Going for the semantics, `std::any` is runtime interface to types. It gives a very "weak" interface: copy and move. I fell that OP thinks `std::any` is not useful because of how the standard doesn't provide a method for augmenting of this interface (what you have shown here). Compare this to `std::variant`, where visiting allows the user to define this interface easily.
I have used it to simulate templated virtual functions.
At least they look like member function pointers: ugly, but consistent with C++. ;)
`any_method` fell out of earlier iterations to make this work with variant: making it work with a raw variant is easy (no super required). 
- companies with abnormal coding styles and forced unreadable formatting - no code review + people who push tons of sphagetti - hypocrite code reviewer who won't accept certain line breaks - tasks without description - no documentation/wiki - other people to busy to help you
I use a custom any in some message passing infrastructure. Essentially, the idea is that the core system responsible for routing and passing messages doesn't need to know what types of messages exist (i.e., there's no global enum listing all possible types). Anybody can declare a new message by simply defining a new type (i.e., a new enum or a struct). It's type safe: the sender constructs an instance of a specific type, and the recipient must know the type of the message it wants to receive and spell it out in the equivalent of `any_cast` (but the plumbing inbetween doesn't). It's a bit more expensive than a `std::variant`, but I've found the flexibility to be worth it. That part of the infrastructure hasn't shown up in the profiler as of yet, either.
I wondered if there was no video from Meeting C++ this year. I am certainly looking forward to hear these talks, not the least Seans long talk. 
Yes, I received the videos of the main track last week, and now finally can start rendering videos... ... also there was an issue with the videos, which took some time fixing by the company. There is still one little issue with one keynote, haven't yet had the time to see how bad it actually is... The first videos are the secret lightning talks, as I get to play around with the video editor, and if I screw up, its just a few minutes of rendering instead an hour or more. I'll let you vote on whos next to be published on twitter: https://twitter.com/meetingcpp/status/943644293885059077 Keynotes are then next, then the normal lightning talks, then talks.
Disclaimer: I didn't read the code. You don't need to use shared_ptr, since a list owns the data inside it. unique_ptr has no runtime cost (nor memory, nor extra computation) compare to raw pointer, whereas shared_ptr add a reference counter. Furthermore, you can have ownership problems where you use incorrectly shared_ptr. You should always ask yourself which entity is responsible for the lifetime of your resource.
Actually i didnt get what you are telling to do? Can you elaborate a bit ?
&gt; The price to pay to get the performance we seek, I suppose. I'm obligated to insert a reference to Rust here :D
Maybe when you also start learning lots of other languages. However, knowing all the details of C++ is mostly irrelevant. It is the general principle that are useful. The details are mostly for compiler and STL (or equivalent level libraries) authors. 
&gt; But i will make sure that i will use shared _ptr and dtor for the next build You shouldn't use shared_ptr unless you have to share the ownership. If you need ownership and pointer sematic, use unique_ptr. Is it clearer?
Three points : 1. I didn't understand what was the motivation to port your build system from CMake to Bazel? 2. Why did you choose Bazel and did you consider other build systems? Meson is quite good in my opinion (although it seems its IDE integration does suffer from some [bugs or bad architecture!](https://bugreports.qt.io/browse/QTCREATORBUG-18117?focusedCommentId=375062&amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-375062) ). GN is awesome but sadly chromium team does not like releasing stuff for outside. Pants, Buck, and others. Did you consider them? 3. Did you search about your dependency at all? Because with simple googling I just find this : [grpc/c-ares-bazel-build!](https://github.com/grpc/grpc/tree/master/third_party/cares). I dont use bazel. I don't like it either. (for many reason, first one is it requires to install jre). But it seems most for libraries there is bazel file already in use in famous projects.
My understanding is he wants to be able to inject flags into dependencies too. and as far as I understand pkg-config is only for shared/static library already compiled.
Any can be written to have a buffer of N bytes internally. When it comes to allocate, if it requires N or fewer bytes, then it can call placement new on the buffer, otherwise it can make a call to new. Here's a sketch struct ValueBase { virtual ~ValueBase(){} }; template&lt;class C&gt; struct ValueHolder: public ValueBase { C val; ValueHolder(const C&amp; c) :val(c) {} }; class Any { static constexpr int N=4; ValueBase* val = nullptr; unsigned char bytes[N]; void del() { if(static_cast&lt;void*&gt;(val) == static_cast&lt;void*&gt;(bytes)) val-&gt;~ValueBase(); else delete val; val = nullptr; } public: template&lt;class C&gt; void set(const C&amp; c) { del(); if(sizeof(C) &lt;= N) val = new(bytes)ValueHolder&lt;C&gt;(c); else val = new ValueHolder&lt;C&gt;(c); } template&lt;class C&gt; const C&amp; get() { const ValueHolder&lt;C&gt;&amp; v= dynamic_cast&lt;const ValueHolder&lt;C&gt;&amp;&gt;(*val); return v.val; } ~Any() { del(); } }; 
Although it is not distributed, but I suggest you should take look at this too : https://ogdf.github.io
Yes, it is 👍👍👍
If only we had constexpr-persistence for function parameters. I wrote a proof-of-concept string formatter that uses the standard ```format(...)``` syntax but pre-computes any constexpr capable data, generating 'optimal' run-time code (executing the pre-determined formatting rule during string construction, with all other parts generated at compile-time). It uses a gratuitous amount of macros and only accepts a finite number of arguments (also because macros), but it's completely standard C++. With constexpr function parameters I could remove the macros and boilerplate, and allow fully variadic arguments. profiling of the cost on compile times is something I have yet to do however ;)
Yeah, that's what I meant by small buffer optimisation, but not everything you would want to use `any` for, of course, is made up of 4 or 8 bytes.
I don't have any clue about Rust, but I think it doesn't matter too much if it's something like `homebrew`, `pip`, `npm`, `cargo`, ..., as long as it is for C++, works on any platform, and is an "official" solution (best backed by isocpp), so that there is a large incentive for everybody to use it.
I second this. I used to avoid visual studio like the plague since they had such poor support for ISO C++ in the past. Now I'm using 2017 at work and I'm happy as a clam. Every once in a while I run the platform-independent portions of my code through clang and gcc, and more often than not by a long shot, it just works on all three with zero changes. Keep up the great work, gang! You've made me a fan!
Not so clear: apparently, no class template argument deduction even in 15.6?
For heap profiling, check out my heaptrack tool, cf.: https://www.kdab.com/heaptrack-v1-0-0-release/ and https://github.com/KDE/heaptrack
[removed]
This sounds interesting. Would you be able to share an example?
In my mind, there are few usecases where `std::any` is tempting, but the overhead of a memory allocation would be a problem. Code that needs to "sneak" unknown types through the type system is rarely code that is performance critical, but that might just be my personal experience.
In my system, checks could be as simple as auto requires_integral = any_method&lt;void()&gt;([](auto&amp;&amp; x){ static_assert( std::is_integral&lt;std::decay_t&lt;decltype(x)&gt;&gt;{} ); }); then super_any&lt;&amp;requires_integral&gt; cannot be constructed from anything that isn't integral. It does waste a spot on the vtable. ;) If you really dislike specifying signature, our any methods could instead of being of type ((T,Args)-&gt;R) of type (Args-&gt;(T-&gt;R)). That would still require specifying return type I suppose.
I don't really follow the point. You can make the buffer larger than 4 or 8 of course on the grounds that most things you're likely to want are under N bytes on the stack. Any (unlike void*) is owning, so it manages memory for you. If you want a non-owning one, you can pretty easily write an AnyPointer for the rare case that you want to be able to pass something around without any reference to the memory manager. Or if you're feeling especially bold, AnyPointerManaged which can take a custom deleter allowing you to have no deleter if you're taking a pointer to stack allocated data. I think the use case for those is rare enough that I can see why they are not in the standard library. 
Also time to vote on which one should be next: https://twitter.com/meetingcpp/status/943865987455160320
Right, I have so far found not even a single use case or `any` in my codebases. Most places where one would think any is useful are better suited by abstract base classes anyways.
Manually clumping and writing out the static asserts sort of sucks. Ideally we'd want to do that once. So you'd create some construct that both aggregates the test and the diagnostic error message. If we could pass C-style strings as template arguments: template&lt;template&lt;class...&gt;class Test, const char* message&gt; struct requirement { template&lt;class...Ts&gt; static constexpr auto test() { return is_detected&lt;Test, Ts...&gt;{}; } template&lt;class...Ts&gt; static constexpr void diagnose() { static_assert( test&lt;Ts...&gt;(), message ); } }; Then aggregate these: template&lt;class...Rs&gt; struct requirements { template&lt;class...Ts&gt; static constexpr auto test() { return std::integral_constant&lt;bool, Rs::test&lt;Ts...&gt;() &amp;&amp; ... &gt;{}; } template&lt;class...Ts&gt; static constexpr void diagnose() { ( void(Rs::diagnose&lt;Ts...&gt;()), ... ); } }; // TODO: add SFINAE detection that R1 and R2 are actually requirements. template&lt;class R1, class R2&gt; constexpr requirements&lt;R1, R2&gt; operator&amp;&amp;( R1, R2 ) { return {}; } Now we can take our individual requirements and collect them together as objects and do algebra on them. But not sure, short of macros, how to embed the error message into them in a nice way. 
So what would I use one of these task templates for? The talk didn't really make that clear at all.
I never figured out if Lakos is genius or just a guy who realized he can earn a lot of easy money by spamming buzzwords... In my defense his talks usually do not fit into 1 hour and are full of buzzwords :P 
Afaik he has 7 degrees in different fields, so he does know a lot.
Can HLSL code be compiled to some kind of bytecode intermediary like SPIR-V? I've only ever used OpenGL (barley) and Vulkan (mostly), so I have no idea what the ecosystem is like for DirectX. I would hope so, because SPIR-V is really great for tons of reasons. Not the least of which is ease of distribution and no more using the driver's GLSL compiler. Not sure if that's handled with some UE4 intemediary, though? Dunno. I'm self-loathing enough that I (try to) write my own rendering systems using Vulkan and haven't tried a game engine yet. 
&gt; Afaik he has 7 degrees in different fields, so he does know a lot. Well... Smart people can miss the point sometimes... But this talk got has my endorsement, cool example and decent advice.
Hey Billy - you responded to a bug report I made ages ago about an error in `std::packaged_task` that made it non-moveable when I was using it for [this](https://gist.github.com/fuchstraumer/50da1dd0d9abe8487599d5d5388ddc1e). At the time, you were saying this would be part of the next ABI-breaking changes but no words when. Any possible update on an ETA? Its not critical and I'm not upset, but gosh would it be useful to have for dispatching things like transfer jobs in my Vulkan renderer/scene-kit :) /u/STL also mentioned releasing new dlls alongside current ones, might that occur for this? Regardless, as many have mentioned big shout out to the current VS team. You're all great, though I'm maybe biased given my aunt works on the VS team ;p
How is that a drawback? Isn't the point of a view to not change the state of the thing it views?
Thank you! It's all due to your aunt's great work! ABI-breaking changes will not come until we increment the toolset's major version from 14.xx. There is not an ETA for that. 
&gt; Thank you! It's all due to your aunt's great work! In hindsight, it's probably too easy to figure out who I'm referring to haha. Makes sense, and no fuss. ABI-breaking stuff is always a tricky thing to release, especially given how widespread usage of MSVC is :)
This was probably written by C developers around 10+ years ago. Not many developers understood the concept of what we nowadays call "modern C++" 5, 10, 15, 20 years ago, and even today there is so much "C compiled with a C++ compiler" and "C with classes" written every day.
 Yes HLSL has had pre-compiled shaders since forever. You can handle it yourself using the d3d compiler, I would imagine that UE4 does this. I think d3d drivers will often store a cache of compiled shaders on top of this. The issues that used to(still?) plague GLSL with slow shader compilation and compile time errors because of driver changes don't exist in D3D world.
What does the "secret" part of "Secret Lightning Talk" mean? What's different from normal lightning talks? They don't seem so _secret_. ;)
&gt; I would imagine that UE4 does this. It does.
Hi FbF_, This is due to a bug in the compiler as reported in the following link. Its fix will be released in VS2017 15.6 preview 2 and VS2017 15.5.3. https://developercommunity.visualstudio.com/content/problem/163751/vs2017-155-c-compiler-generates-incorrect-code.html In the meantime, you can enclose the affected function with #pragma optimize("", off) and #pragma optimize("", on) as a temporary workaround. Also, for future reference, I encourage you to report any suspected compiler bugs through the following website which we actively monitor. https://developercommunity.visualstudio.com/spaces/62/index.html Thanks, Rui Zhang Microsoft Visual C++ Team
The biggest drawback of a `const` variable is you can't change it. /s
Its about utilising the Small Object Optimisation (SOO) to avoid a lot of potential allocation calls. The task wrapper is part of the concurrency[1] library at stlab. It is a library which provides a splittable future type with continuations. Now each continuation gets stored into some shared state as such a function wrapper. An executor might store those tasks too. If you construct a graph of execution this might grow quite fast and such the amount of continuations stored might grow fast. Thats where small object optimisation comes into play. Sean makes a point of how to utilise "his" way of polymorphism to achieve this optimisation. Does this answer your question? [1] - https://github.com/stlab/libraries/blob/master/stlab/concurrency/task.hpp
That these are special, and not announced to the audience. They are treated as being secret during the conference, and hence not much is known about these :P
MSVC's compiler front-end (C1XX) won't support class template argument deduction (CTAD) in 15.6. However, 15.6's STL will support CTAD when compiled with Clang 5, as I mentioned in the post. I implemented all of the library's deduction-guides and tested almost all of the library's class templates with CTAD to ensure that the implicit guides work (and aren't harmed by typedefs or constructor shenanigans). This thorough testing discovered two bugs in Clang and one issue in the Standard, all reported. It's historically unusual for MSVC's STL to provide more features when it isn't being compiled with C1XX, but working this way made sense. Now, C1XX can implement CTAD and immediately run it through the STL's tests for that feature, finding all of the weird corner cases immediately. This is a dramatic acceleration of our usual dev loop (where the compiler implements a feature, then the STL takes advantage of it, then we find/reduce/report compiler bugs, then they're fixed, then we remove STL workarounds) and will help bring CTAD to you faster. Note that our STL also activates features for C1XX before Clang. For example, `has_unique_object_representations` was implemented in C1XX first, but is unavailable in Clang 5. When I [reported this](https://bugs.llvm.org/show_bug.cgi?id=34942) to Clang's devs, I provided our moderately detailed test cases (originally written by Billy or Casey), which helped the Clang dev Erich Keane implement it faster, although he discovered even more subtle cases that had to be implemented and that weren't covered by our tests.
Definitely, thanks for the explanation!
I've been using this flag to investigate compile times on our large codebase... very informative! But, I've run into a case where when I comment out a section of code in a given function, the compile time of that function increases ... if I put the code back in ... the compile time decreases. Can anyone explain how this might be? In this example, the function goes from 4s to 2s with the extra code compiled in. I have tried #if 0 to remove the code as well as snipping it out entirely with the same results.
It's meant to be an implementation of something like `std::function` but with small object optimization. It's main point is about a general technique of small object optimization. The phrase "small object optimization" was a very clear aim of the talk.
Direct3D _only_ supports binary shaders and to my knowledge has only _ever_ supported that, either via the older DXBC format or the newer LLVM-IR-derived DXIL format. Compiling HLSL is done by a completely separate `d3dcompiler` library (or the DXIL `dxcompiler` library) or the command-line frontends thereof. Neither the tool nor the library were intended for use at runtime in released products. I think technically also `d3dcompiler` isn't/wasn't distributed with the D3D Runtime redist, and Store apps were originally blocked entirely from loading `d3dcompiler` for instance. Direct3D also provides the binary cache API just like Vulkan for the hardware-specific compiled versions of shaders produced after loading the IR bytecode. Vulkan is in so many ways "just" Direct3D 12 with some different spellings, which in turn makes Vulkan a lot more similar to earlier Direct3D versions than OpenGL ever was.
I just switched from Cereal to JSON for Modern C++. One big difference between the two is that Cereal is pretty strict about mapping C++ objects and JSON objects. JfMC++ gives you much more flexibility about how your C++ objects serialize/deserialize. Cereal also has this over-wrought framework for handling unique pointers to polymorphic types. JfMC++ doesn't have this but it is pretty easy to roll your own using virtual methods.
So they're short, functional, undeclared talks? Should be called "Lambda Talks".
&gt; Direct3D only supports binary shaders and to my knowledge has only ever supported that, either via the older DXBC format or the newer LLVM-IR-derived DXIL format. Hunh, that's really nice then! Avoids the issues that OpenGL has due to no support for that completely. if cross-platform wasn't such a core requirement for me, I'd have probably tried DirectX by now tbh. The lack of runtime stuff is sorta odd, though. I'm working on enabling runtime shader editing and recompiling (using inotify), along with dynamically generating much of the pipeline data required per shader at runtime (or loading it from cached data, if it has already been created once). its not essential by any means, but it is really nice to be able to fix shader bugs in realtime
Could have done without the first 1 min 55 sec
&gt; The lack of runtime stuff is sorta odd, though. I'm working on enabling runtime shader editing and recompiling The pipeline stuff you're mentioning is a developer feature and not something you'd expect end users to require, so redistribution of the compiler shouldn't be a huge problem. That said, I _think_ the redistribution stuff has all been pretty heavily relaxed for some time now. The UWP Store has allowed `d3dcompiler` for a while now and I think either `d3dcompiler` is in the runtime redist now or can be freely redistributed on its own; I'm not entirely sure but there's certainly plenty of apps that allow users to mess around HLSL without requiring the DXSDK to be installed. I wouldn't take anything I'm saying about this for a given though; I could be all kinds of wrong. :)
Pretty sure both. 
I can't believe how well you summed up everything that was wrong with my last job.
mine too :)
I know John. He's a smart guy.
I'll double-check with the management. My statement was based solely on the fact that Microsoft in general sponsors work visas.
What do you mean by easy money and spamming buzzwords? It was a good talk.
Was part of the talk, so I couldn't really make a cut there... ... also it was important to Sean to say this. And its the beauty of video that you can skip ahead...
Although replacing `enable_if` with `static_assert` is not a good idea since the template is no longer constrained, but it can be used diagnose why a type does not fulfill the type. The same thing can be done with `TICK_TRAIT_CHECK` which will show which trait failed in a big hierarchy. This allows you to do something similiar, for example: TICK_TRAIT(nested_result_type) { template&lt;class T&gt; auto require(const T&amp; x) -&gt; valid&lt; typename T::result_type &gt;; }; TICK_TRAIT(static_set_limit) { template&lt;class T&gt; auto require(const T&amp; x) -&gt; valid&lt; decltype(T::set_limit(1)) &gt;; }; TICK_TRAIT(get_result) { template&lt;class T&gt; auto require(T&amp;&amp; x) -&gt; valid&lt; decltype(x.get_result()) &gt;; }; TICK_TRAIT(noexcept_get_result) { template&lt;class T&gt; auto require(T&amp;&amp; x) -&gt; valid&lt; is_true_c&lt;noexcept(x.get_result())&gt; &gt;; }; TICK_TRAIT(get_result_return_type) { template&lt;class T&gt; auto require(T&amp;&amp; x) -&gt; valid&lt; has_type&lt;decltype(x.get_result()), typename T::result_type const&amp;&gt; &gt;; }; TICK_TRAIT(is_acceptable, nested_result_type&lt;_&gt;, static_set_limit&lt;_&gt;, get_result&lt;_&gt;, noexcept_get_result&lt;_&gt;, get_result_return_type&lt;_&gt; ) {}; And then doing `TICK_TRAIT_CHECK(is_acceptable&lt;X&gt;)` will output this: error: implicit instantiation of undefined template 'tick::TRAIT_CHECK_FAILURE&lt;get_result_return_type&lt;X&gt;, is_acceptable&lt;X&gt; &gt;' Which tells which traits failed in the hierarchy, explicitly `get_result_return_type&lt;X&gt;`. I guess this could be extended to allow custom messages. A better approach would just be to improve compilers to report the substitution failure directly, so such workarounds are not needed.
There's been a ton of SPIR-V related commits over the past 3 months to the new DXIL based compiler on github at least (https://github.com/Microsoft/DirectXShaderCompiler/commits/master). Maybe a common SPIR-V output representation is coming? I don't know why their team is being so quiet about the new compiler though. Like does it offer better compile times, better code generation, better interop etc. etc. They can really garner interest if the above are all 'yes'. AFAIK, not even epic has integrated this new codebase though but if more folks start talking about any good aspects, that change may happen sooner than later?
The new compiler is exclusively for HLSL2016+ and SM6+ to DXIL/SPIRV. It only works with Win10 Creator's Update, and only with very recent drivers.
12 minute talk by Lakos. So I'm guessing about 100 slides? 
You can memory map the file in a portable way by opening it as binary, checking the size (as you did) and reading everything into a buffer. As an added bonus, you can even choose how this memory is allocated.
And it's also its biggest feature, except that it might be a lie because something else could change it.
I have no idea, actually. There are a ton of women in VS. I know merely half of them by name. 
Your argument is inconsistent: if you can pass a void*, then you can create an any to a T* and avoid the allocation, but gain type safety. Where any really shines though is if you need to also pass ownership along, which implies an allocation anyway. 
My argument is consistent. SBO is no silver bullet unless you restrict yourself to very small objects. void* has no safety of itself. My point is that there is no way in standard C++ aside void* of having a non owning handle to anything.
&gt; Other than its weird syntax Understatement of the century. CMAKE as a DSL is an abomination and it's not without consequence. It's littered with weird edge cases and so much legacy that it's hard to have a clean CMAKE build system for project of any complexity. Not saying that's enough of a reason to switch if it's working for you, esp since it's more-or-less the defacto standard, but "weird syntax" just doesn't do it justice.
I found the first 2 minutes almost more important than the rest of the talk, and I'm very happy Sean acknowledged the issue and /u/meetingcpp kept it in.
Btw, the link you provided says that the job is no longer available.
Also thought about Qt. In a lot of cases I would argue `std::any` is code smell, but for passing around model/view data I haven't been able to think of an alternative that doesn't blow up the complexity of the code so I like it there.
He also mentions at the end (at around 7:10) that he checked the implementation of Clang's and Visual Studio's `std::function` and he used his technique to optimize both STLs to save one pointer member and the corresponding dereference IIUC. This would benefit all of us in the future for free, we don't have to change our code, just using newer compilers/STL would be enough. Not sure if the STLs can actually be fixed due to it being potentially ABI-incompatible. Maybe /u/STL or /u/mtclow could answer this.
All I see is a collection of the most popular threads from /r/cpp recently. Do they offer anything else for someone who checks this subreddit daily? 
Well, std::function already does small object optimization...
It actually turned out that the way he presented it is using an UB. Saving this pointer and casting the storage to concept* is not guaranteed to work (but will most of the time). There will be an errata .
That would be completely non-binary-compatible, we can’t change representations except in highly limited ways that don’t affect the bits that are stored.
People are getting hyper sensitive over the use of a simple word like "guys". What's next: "what do you people of all heritage, gender identity, sexual preference etc. think?".
Interesting, but you have to take care of casting exception in constructors then.
Reddit swallowed my asterisks, I meant to say if you can handle a void pointer, you can also handle a T pointer, which will certainly fit in SBO since any needs to hold at least a pointer anyway. So, if you want to guarantee avoiding an allocation, and can manage the lifetime yourself, create an any to a T pointer. 
I mean, you can try "folks", "ya'll", or other gender neutral references.
I deal with hundreds of thousands of json messages per second. Some of the fields have to be converted to, for example, uppercase. I lose the effeciency of string_view because I can't change the string it references, and so have to use std::string which then involves using the heap and copying
Thanks
Of course you can use that as well. But I find it kinda ridiculous when casually *and in good faith* using "guys" when addressing an audience is being considered as discriminatory or exclusionary against females. 
They are declared. Just not named.
Why? Do you somehow think that saying "guys" is being an active participant in bettering our industry for females and other underrepresented minorities? I'm not going to say it's intentionally worsening it, but by claiming to say it "in good faith" you're implying that. At best it's a neutral thing, as you said, it's a casual colloquialism. No one is hyper sensitive over this. They are at worst, sensitive to it. It is unfortunate that we use such gendered language, particularly when there's such a large discrepancy. So yeah, sometimes folks will comment on it, very rarely are they aggressive about it, and rarer still whipped up into a fervor over it (as I assume a "hyper sensitive" person might be). Is it really so much to ask to change some of our language so we can make the community more welcoming, even if simply in the perception of others? Does it really harm us to throw away terms like "guys"? I find it kinda ridiculous people cling to language so much. 
For people who want to avoid raw loops and do not want pathetic performance of std::accumulate: you can use google Abseil StrJoin. If you do not believe me I could just tell you that you deserve slow code for not believing me, but I am such a nice person and will link to short [article](https://medium.com/@gaussnoise/why-google-abseil-is-cooler-than-it-looks-and-what-it-can-teach-us-about-c-libraries-in-general-ec9bbda48941) I wrote about this.(before this article was written so it is not a cheap attempt to get clicks of this cool article)
I think that’s a bit of an overstatement on your part. As I see it, the issues with cmake is its desire to be backwards compatible to 2.6 (released in May 2008!). So I agree that the legacy components drag it down. That said, using a modern version of CMake allows an intuitive model for dependencies and properties. However, the old functions are still hanging around, which makes it confusing. For example, 90% of the time you want target_include_directories, not include_directories, but if you google how to set include directories in CMake, you won’t even be aware of the first option, because all the top results are StackOverflow answers from 2012 before target_include_directories was available. One thing that CMake does do poorly is documentation, which assumes everywhere a general familiarity with the system and syntax (it doesn’t help that Google always brings you to the 3.0 documyation page). More examples and background info would go a long way to improving ease of use
I find the use of the | operator a bit confusing. How exactly does this improve error handling?
So why enforce any in a public API? I still see no useful merits of it, as the OP states.
Because then one gets the type safety that a void pointer lacks. 
I've been perusing some of the older issues and came across some awesome awesome articles like the following: http://donw.io/post/reflection-cpp-1/
Rainers argues, that it does not make sense anymore to publish C++ books in the traditional way, as it does not fit the needs of our community, and that publishers don't really understand it either. But if you go the route of self publishing, books still can be written for C++ and sell successfully. But the margins aren't good enough to this over a publisher. Also, I've seen from multiple other C++ authors similar statements, going for self publishing is a major trend in this important niche of our community.
I find that the gdb integration in QtCreator often fails in unpredictable ways forcing me to use the gdb tui.
But that's not what an API taking any says. Such an API says "give me whatever and I will take ownership of it, even if a memory allocation might be involved." May I ask, why? Really, why do we need this at all? It is extremely rare that you might want to pass around an object whose only purpose is to beat the type system, which intermediates can't introspect transparently. Even Python has transparentways to manipulate objects of any kind, something `std::any` is unable to do. Not to mention something is obviously not right with beating the type system in the first place.
cpp-netlib? 
I do not get it
Perhaps the joke is that a decent description of `static` requires a lot more space than approximately one inch. On the other hand, perhaps this was simply a typographical formatting error.
Also [Leanpub](https://leanpub.com/) is a great platform and the founder Peter Armstrong is extremely helpful and responsive to their community.
yes, that was the "joke". for curious static has many different meanings that some will claim all make sense if you know the true spirit of C++ but I disagree... anyways there is a nice SO Q with a lot of nice A for details. https://stackoverflow.com/questions/15235526/the-static-keyword-and-its-various-uses-in-c 
You shitpost a lot.
&gt; But that's not what an API taking any says. Such an API says "give me whatever and I will take ownership of it, even if a memory allocation might be involved." I think you misunderstand. It says, "pass this thing through here transparently." Not necessarily anything to do with ownership, only if you want that feature by passing a value type is ownership implied. &gt; May I ask, why? Really, why do we need this at all? It is extremely rare that you might want to pass around an object whose only purpose is to beat the type system, which intermediates can't introspect transparently. Even Python has transparentways to manipulate objects of any kind, something std::any is unable to do. Not to mention something is obviously not right with beating the type system in the first place. Type erasure of this kind is extremely common. Other languages do it by forcing everything to derive from a common object, or just being dynamically typed. Anytime you have used inheritance and passed around base class references, you are "defeating the type system", in your words. Any provides a similar mechanism but doesn't force the types to be related, which often times they're not, but are forced to be due to limitations in the language that make it such that that's the only way to pass objects though a particular interface. Whenever you've seen people bubble virtual functions up to base classes from derived classes, or insert an unnecessary class into a hierarchy, it's possible that the problem would have been better solved using an any object. Have you ever needed a template virtual function, and then jumped through hoops of base classes and ownership issues because you couldn't have one? Next time, reach for any. Question: What do you mean by "which intermediates can't introspect transparently." You can absolutely ask any if it contains an object of a particular type. if(Foo* f = any_cast&lt;Foo&gt;(&amp;foo)) cout &lt;&lt; *f; else if(Boo* b = any_cast&lt;Boo&gt;(&amp;boo)) cout &lt;&lt; *b; But, you want more than that, like "any-on-steroids", check out the Boost.TypeErasure library, which provides a mechanism to provide arbitrary interfaces on objects without requiring a type hierarchy, similar to the python feature you are talking about. 
Nobody give C++ talks to make money. John gives very down to earth talks and he doesn't seem to care for trendy stuff. I guess what you see as buzzwords is just... appropriate vocabulary.
I think Java actually gets it right. You wouldn't need to import `Impl` unless you use the name `ImplDetails`. The compiler of course sees `ImplDetails`. But I don't know how cleanly this approach would be with ADL 🤔.
C++ always needs to know enough about a class' contents to be able to allocate space for it. If you make ImplDetails a pointer, it knows how big a pointer is, and won't have to worry about how big ImplDetails itself is.
Ah now I need to explain what I meant, and it will look I am attacking Lakos... so to be clear IDK if his talks are good because I got bored at minute 10 out od 150 minute talk. That aside giving talks makes you money. Not directly but being a known C++ expert gives you access to better jobs and if you are like really famous you can be used for [recruiting](https://twitter.com/antoniogm/status/775479454415986689). 
Sure, the compiler needs to know. But why should the module author or consumer need to worry about that? The compiler could transparently sort that out as I pointed out in the post.
Isn't this the kind of stuff modules were supposed to fix? Why does implementation details have to be visible to the consumer?
Doesn't Java always suffer extra indirection from treating everything as a pointer? 
You could move the `ImplDetails` class to another module and import it in your `MyModule` module. The `ImplDetails` class won't be exposed to the user of `MyModule`. If your build system is able to hide modules from another, then it would really be private. However it's quite puzzling why the compiler cound not do something similar within the interface of a module.
What compiler is this? 
Yes, but then it can’t be used as an instance variable in an exported class (exports can only be in the module interface)
It’s my understanding of the TS. I don’t think any compiler implements it proper yet.
Uh? I'm sure you can. As far as I know, I can do this: module M; import std.vector; export struct foo { std::vector&lt;int&gt; vec; }; Importing the module `M` won't make `std::vector` visible, yet it's a member of `foo`.
In that case, importers of `M` won’t be able to construct a `foo` without first importing `std.vector`.
Composition seems like the most common usage of |
cpp-netlib is a good library，but it’s not active at the moment, accumulating a lot of issues. It's hard to make an HTTP library that everyone is satisfied with. The reason is also a momentary inexplicable
True, but John Lakos reached the “known C++ expert” level by publishing a book 20 years ago... About recruiting, the funny thing is that I was at C++Now a couple of years ago and John was trying to recruit people and keeping notes of who he talked to. I guess he needed to justify to his boss the budget to send him to the conference. :)
Not at all relevant to modules but it depends on how good the VM is.
Even if struct `foo` look like that? struct foo { foo(int i) : vec(10, i) {} private: std::vector&lt;int&gt; vec; };
Yep, I think the user of `foo` will still need explicit visibility of `std::vector` by using one of the 3 methods in the post
My understanding is that your understanding is incorrect. I've also tested this with the big three and while Clang does complain, both GCC and MSVC do not require re-export. Also, may I suggest that in the future you pose posts like this as questions rather than authoritative-sounding statements (but while omitting any source). There is enough FUD about Modules TS as it is.
you might like this one, I forgot to mention it: https://www.scss.tcd.ie/~andersan/projects/live/triNNity.html
I tested it with MSVC too. It doesn’t require the re-export because it re-exports everything without being asked. E.g. in this code, the consumer will have access to `ImplDetails` which is clearly incorrect.
Yes, you are correct about VC, good point. Still I believe your understanding of the spec is incorrect. And from the three compilers I would trust GCC to get things right where Modules TS is concerened.
It is relavent to this discussion because adding an indirection would solve the complier error.
Yes, me too, because from being neutral towards such people I start to despise them. It is always about their feelings, their experiences, their ideology, it doesn't matter how perfect the talk is or how well the ideas were presented, they will find something to complain about. E.g. for a while it was "required" to have equal men and women representation in slides, like a John and a Jane and figures of men and women as actors, but as now PC police is even more vigilant and non-forgiving presenters start to use robots, animals etc. meaning non-humans entities just to be "safe". Or when in books it was common that developers were addressed as "he", then authors were recommended to have equal "he" and "she" used, with current developments I don't even know how authors will be able to write a book that will get at least a passing grade from PC police.
I honestly wouldn't believe any implementation, since they all state that they're highly experimental. Do you have a source for why you think this is incorrect?
the type of customer who chooses app-local deployment over redist based is usually the type of customer who wants complete and total control over their application. 
Wait, last I looked (which was a while ago), `private` data wasn't exported over module boundaries beyond size information?
&gt; Do you have a source for why you think this is incorrect? It is my understanding of the spec: modules achieve their function using *name visibility*: if a C++ entity is exported from a module and you import said module, then this entity's name is visible in your translation unit. That is, you can refer to it. This has no effect on what compiler sees (it seems everything). So, in your case, since your code does not refer to `ImplDetails`, there is no need to import its module. The fact that the compiler needs to see it, for example, when synthesizing the default constructor is compiler's business.
You do not need to re-export `Impl`, nor do you need to do any of the "3 options" you listed. Your compiler may ask you to specify where or how to find the binary module interface for `Impl` though.
Modules don't do automatic "pimpl", nor should they do that, IMSHO. This is still C++. The actual issue as originally reported, I suspect, is that the compiler needs to find where the binary artifact for `Impl` is.
/r/cpp_questions btw Your statement is true. class Foo; // class (forward) declaration (incomplete type) class Foo { /* ... */ }; // class definition
From the man himself, thanks for clarifying. Apologies for spreading misinformation. I'll delete this post before it does anymore damage.
okay thanks for link and confirmation. Will remove my post since this is not the right sub. 
That is correct. Modules don't do automatic "pimpl", nor should they do that IMNSHO. This is C++.
Hmm, I am not sure I understand. The problem here, if I understand the original report correctly, is that the compiler needs a way to know whether the `Impl` is stashed so it can reconstruct `MyClass` correctly. The original poster listed 3 options, but none of them is required.
Hmm, please send a repro my way (my initials at microsoft dot com) so I can look into it.
/u/berium is correct. The issue in the original report, as I understand it, is that the compiler needs to be told where to find `Impl` for its own internal business.
No, that is not the spec nor the intent.
That is not correct.
At the point where the VM optimizes, isn't that equivalent to link time optimization?
It isn't neither a zero cost abstraction nor the only way to solve this problem (if it is a real problem).
Please, do not delete it if that is something that is OK with you. Errare humanum est. We all learn from mistakes.
After the talk, did anyone ask Phil Nash what the benefits of his command line parser were over Boost's `program_options`? The boost one has a lot of features, including being able to get options from a config file not just command line, and positional argument handling, etc. (it also takes a few more lines of code to use the boost one, but not many) I'm just curious if he didn't use the boost one for some specific reason, that could be a suggested enhancement for boost.
[This is mentioned in the FAQ.](http://mesonbuild.com/FAQ.html#why-is-meson-not-just-a-python-module-so-i-could-code-my-build-setup-in-python)
Sorry, I’m not sure if I can undelete this. I do have one question about the implications of this. What about a class with a public data member whose type has internal linkage? Surely that can’t be allowed since then it’d be accessible from another module? Edit: according to the spec, an entity can’t be exported if its type involves an entity with internal linkage. Does a data member count as being “involved”?
One of the points raised against build systems for C++ is that starting a new project is difficult for newcomers. For comparison with Rust you just do `cargo init &lt;something&gt;` and get going. To alleviate this problem Meson [now has a pending PR](https://github.com/mesonbuild/meson/pull/2822) to add the same functionality. Creating a new project from scratch is only a question of running this: meson init --name=projname There's also a shared library project with a test executable, pkg-config generation and the works: meson init --type=library --language=cpp --name=mylib --version=0.2 The MR currently only has sample projects in C. We'll add C++ ones before merging.
Well, some small concessions in language might seem trite, or annoying, to you, but it does make a difference for people. I know folks who've been assaulted, harassed, and put down both in big tech companies and just out in the world just due to their gender. They like to feel included, and these are small things we can do as a group to make them feel that way. But hey, I guess your embarrassment or being bothered by being asked to change some things should come first, wouldn't want the "PC police" to overstep their bounds. 
There is a lack of common sense here. &gt; I know folks who've been assaulted, harassed, and put down both in big tech companies and just out in the world just due to their gender. This is terrible, and as a community our focus should be preventing instances of abuse from happening and reporting perpetrators. --- &gt; They like to feel included, and these are small things we can do as a group to make them feel that way. If someone feels excluded when "guys" is used to refer to a group of people, there is an underlying issue with that person that must be addressed. The problem here is not the word itself. Anyone can be offended by anything - everyone needs to **use common sense** in both directions: * Avoid using terms that are obviously non-inclusive or discriminatory. * Realize that most people in the world are not trying to exclude you. There is a huge difference between using "guys" to refer to a group of people and posting a job advertisement that says "no white males" *(or any other gender/race)*. Let's start using common sense and addressing behaviors that intend to exclude people instead of getting pissed off at innocent trifles. 
I can't seem to find him on reddit to summon, but Catch2 is just a header only library right? Doesn't seem to depend on boost. They likely just didn't want to add the dependency.
Given the point was to include this in his testing library Catch, he probably didn't want to introduce a dependency on Boost. BTW, if anyone needs a lightweight, super simple-to-use C++ testing library, Catch2 is really fantastic. Just drop a header in and write your tests - simple as that.
Interesting. The SPIRV stuff isn't surprising though, there's been lots of drive throughout microsoft to use more open-source products and support more open-source projects it seems.
/u/philsquared
I agree there's a difference, I would give you orders of magnitude of difference. However I don't agree that it's a problem with that person, or some lack of common sense. It's a very clear micro aggression that we as a society, and the users of this language have come to use "guys" in such a way. The problem with trying to tell these people, and it's not just a few, that "Realize that most people in the world are not trying to exclude you.", is they don't see that. They live real experiences where that is simply not true, or doesn't seem to be true. This, among other things, is something we can do as a community to make those people feel like they are included, that we're trying to make things better for them. I don't agree that _only_ intent matters. I think in many ways we all have learning to do in this regard, and it will make things better,
Thanks!
If you use Linux, become active in Qt and KDE development. Subscribe to KDE mailing lists and ask how to get involved. Start compiling KDE applications yourself. Try to understand the build setup with cmake. Send patches to improve little things. If you do this, you will learn a lot and eventually become quite good in C++ and in organizing large projects. In addition, you will likely meet a lot of friendly developers.
Ahh, makes sense.
I'm not Phil, but I think Clara API it's incomparably better than boost.po and there is really no hope of making the latter as expressive as the former. Besides, as the others have already mentioned, Clara is header-only and while this can be an advantage or a drawback in general, a command line arguments parsing library should ideally be header-only as it's almost invariably only going to be used once in each program, so you don't gain anything by compiling it separately.
I appreciate the amount of work put into this, I really do, but I can't help not feeling great about including a half megabyte 15000 loc behemoth. This header-only trend truly bothers me. At some point, for any non-trivial c++ project, some kind of build system and some kind of dependency management have to be introduced. At that point header only brings very little to the table, and does it at significant cost of longer compilation times. Setting up a build system is more or less one-off thing. Long compilation times are not. It's for a reason that big projects (like chromium, webkit, etc) have strict rules about what can go in headers and use templates sparingly. I learned the hard way to be frugal with my headers as well. In our project there is 850 loc header file for variant type and the json parser/writer header itself is less than 45 loc. Another 125 loc for message pack header and 20 loc for plist.
Consider the | operator as the "pipe" operator (like in Bash or Powershell), and it makes a lot more sense to overload it to represent composition. I don't think the point of this is to improve error handling necessarily, but to provide more extensibility, like giving the user the ability to easily add their own command-line handlers. The | operator is just syntactic sugar to minimize boilerplate code and clutter that a more traditional function-based API would require. When reading that long list of arguments in Catch, it seems very clear to me what the *intent* of the code is, even if the underlying mechanism is slightly less obvious. 
I agree, using | for composition, either as in the case here or range composition or piping feels super intuitive and makes the code and intent much clearer.
I thought "guys", like "dudes", had become gender neutral again these days like its original meaning? Not a native speaker though 
[removed]
Your comment has been automatically removed because it appears to contain profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/7l3la3/sean_parent_secret_lightning_talks_meeting_c_2017/drn06rz/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
[removed]
Your comment has been automatically removed because it appears to contain profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/7l3la3/sean_parent_secret_lightning_talks_meeting_c_2017/drn0c8u/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Straight from the dictionary: &gt; guy: person —used in plural to refer to the members of a group regardless of sex Using a word as it is defined is not a microaggression; making people feel guilty for speaking correctly _is_ a microaggression. This has to be the dumbest argument I've ever seen in this subreddit. (Now censored because we adults apparently can't use "naughty words". /s)
[removed]
I have no idea what I'm doing to piss off the automod bot, but I am literally just pasting the definition of the word "guy" here. Apparently even the dictionary needs censoring now... Oh, and using words properly is not a "microaggression", FFS.
Correct. Catch2 (like Catch 1.x) is header-only, with no third-party dependencies.
The main reason has been covered (no third-party dependencies). However I should say, having used boost PO a couple of times, I've never been a fan of its interface, and quite liked the idea of doing something different. I should also point out that Clara does positional arguments, too. Overall there are still some missing features (mandatory opts/ args, handling of std::optional, config files and environment variables, to name but a few). This is just a start - but the first step was obviously to support what Catch already needed.
Thanks!
No. This is about visibility of names. The compiler can know the implementation and calculate sizes accordingly and yet not expose the name to the code doing the importing.
While the statement is correct, it's not relevant. The compiler can know everything about `ImplDetails` and yet not expose the *name* to the importing code. If everything were `public`: ImplDetails i; // compiler error - I don't know what ImplDetails is decltype(thing.impl) i; // i has type ImplDetails, its definition is known Objects are still composed. Compiler knows everything. The difference is that the *name* just isn't exposed to you. There is no need for a pointer redirection or "automatic pimpl".
Nice! Yeah once someone mentioned it was a header-only without boost, it made perfect sense.
For clarification, it has been used as a gender neutral for some time. I'm from the US, so I've certainly used it, and still use it as a gender neutral. I, like Sean, am trying to stop due to concerns about it's history of sometimes being gendered and being connected to the noun version (just, "guy") which is not gender neutral.
&gt; Oh, and using words properly is not a "microaggression", FFS. A word can be defined a particular way that still bothers people. Sean himself mentioned that he was well within the definition to use it as such. While "guy" and "guys" has been and is used as a gender neutral, it's also been used a a gender specific term, and many people view it as such, regardless of the definition b. If slowly removing the gender neutral version from my speech fosters a more inclusive environment for the people I work with, well I'm willing to make the sacrifice, micro aggression or not.
&gt; While "guy" and "guys" has been and is used as a gender neutral, it's also been used a a gender specific term, and many people view it as such These people are wrong, and making an issue out of words being used correctly is _them_ being "microaggressive". Why is the offended person automatically right? Idiots can get offended, too, and it really doesn't bother me much! EDIT: Lastly, no offense, but there's no point for me to continue down this thread; you've been polite and presented your case well, but I won't be convinced that _this_ level of political-correctness is in any way healthy, for anyone. :-]
Except its missing a significant number of features when compared to other frameworks.
Yes, "lightweight" typically means "fewer features". Catch fills a niche for projects with more straightforward testing requirements. 
Is that really a problem? As a reader I'd appreciate a visible cue if an algorithm starts to resize my container and invalidates iterators.
All to print an integer. Sometimes I think my job is boring...
That's what canonicalized forms are for.
I would expect newcomers to mostly make do without elaborate build systems. Your first projects are likely to be single-file, and can be compiled by hand, or using a trivial makefile. I'd argue that _all_ of the existing build systems are too elaborate and too confusing for newcomers anyway. Hell, I'm still terrified of cmake, and I've been using C++ since 1994 or so - mostly using (s)make, although for the majority of builds I do, Visual Studio does just fine. Since you are a build system developer, I gotta ask: have you ever considered configuring builds using an MMI? Thirty years of research into having graphical interfaces has revealed that people find it much easier to click on options they can see, rather than learn yet another obtuse and no doubt Turing-complete language and then pray to God that it will somehow do what they want. 
Thanks! I have literally been microbenchmarking our internal logging/printing code just last week.
It doesn't particularly care about constructors at that point; it's not trying to call the constructor, it's just allocating memory and assigning the values as provided in the aggregate initialization list without any logic or function calls. Aggregates, afaik, exist for system designs where objects don't express ownership over anything and don't need RAII. I can't seem to find much information about the history of aggregates, but their initialization lists have been around since well before C++ was standardized. It could very well be legacy design clogging up the current standard that they don't want to remove and break code, or it might have a use in another field. The easiest workaround if you ever needed this would probably be to make an empty private constructor (which reads better imo) or privately inherit from an empty base class **EDIT:** Any tips from the negative votes? n_n' I was answering their question about the rationale behind this... Which involves the designs aggregates are intended for and how they skip constructors. I really don't understand the votes? o.O &gt; This is quite surprising for me. What is the rationale behind this?
 struct Foo { Foo() = delete; }; Foo bar{}; // works Foo baz; // fails I agree. This is a bit surprising. I would have to read up on the rules for aggregate initialization and see what the difference is when using explicit initialization via '{}'.
discussed in other answers, but basically I almost never use copy in a way you describe(beside iterator invalidation). In other words almost always I copy from container a to container b using "natural" insertion point of container b and not .insert(b.begin(), ...)
funny story, tnx for sharing...
&gt; Yes, me too, because from being neutral towards such people I start to despise them. I agree, just remember not to generalize. Such people usually present themselves as fighters for X, Y and Z groups of people so it is easy for our brains to associate them with X, Y and Z groups of people while obviously not everybody who is X, Y and/or Z gave right to that individual to represent/"fight for" them. 
&gt; There is a lack of common sense here. Most SJW come from colleges where any "hate"(opposing views) are blocked(including riots to prevent speakers from visiting and firing people for "hate"). This makes them sure they are right and willing to attack any "Hitlers" they encounter, sometimes including physical violence. So my advice to everybody is: Do not try to rationalize or argue with them, you will just be called racist, sexist, they will try to get you blocked from conferences and fired. If you do not believe me read the "hate" for which Damore was fired(not the news articles, read the original).
maybe SG14 inline function can become a good friend of yours? :P https://github.com/WG21-SG14/SG14/blob/master/SG14/inplace_function.h
Thanks for the feedback. In fact, we are working toward splitting the header (https://github.com/nlohmann/json/pull/700), but we did not finish this for the 3.0.0 release. We hope that this not only allows for selective inclusion of only the required parts, but also to separate those parts that do not rely on template parameters to allow to compile parts once and for all. What library are you referring to? I would like to have a look whether we can learn something from 45 LOC of parser/serializer.
What happens if you explicitly delete the initializer list constructor? 
According to http://en.cppreference.com/w/cpp/language/aggregate_initialization, this is an example of allowed aggregate initialisation. If you don't like it, the page also provides a wide range of options to suppress it (like adding a private data member or any user-defined constructor). C++, just when you think you understand... So apparently we have _another_, additional type of constructor: the aggregate constructor, which is default generated, but works with slightly different rules from other default-generated constructors. struct Foo { Foo() = delete; }; Foo foo1; // fails: default constructor deleted Foo foo2{}; // fine: aggregate initialisation Foo foo3(); // fine: function declaration(!) struct Bar { Bar() = delete; Bar(int) {} int x; }; Bar bar1; // fails: default constructor deleted Bar bar2{}; // fails: user-supplied constructor suppresses aggregate Bar bar3(); // fine: function declaration(!) Bar bar4{1}; // fine: user-supplied constructor Bar bar5(1); // fine: user-supplied constructor struct Baz { Baz() = delete; Baz(int) = delete; int x; }; Baz baz1; // fails: default constructor deleted Baz baz2{}; // fine: aggregate initialisation Baz baz3(); // fine: function declaration(!) Baz baz4{1}; // fine: aggregate initialisation Baz baz5(1); // fails: constructor deleted It all makes perfect sense, but at the same time it makes me glad I'm not actually teaching C++... 
For linear algebra I thing blaze is now cutting better. The interface is much cleaner, intuitive than blaze
Thanks, I'll bookmark it for evaluation.
So can you use that to give decent error messages in static asserts in templates? For example something like template&lt;typename T&gt; void something(){ static_assert(std::is_base_of_v&lt;int,T&gt;,constexprstring(nameof(T)) " is not base of int") }
Aggregate initialization does not use a constructor, it initializes each member based on the list you provided
There is no "aggregate constructor". The members are initialized by the list without any constructor being involved.
On which version of which compiler did this work? I wouldnt be surprised eg if it worked this way in gcc 4.9 and not later versions.
I dont think its correct or helpful to say aggregates skip constructors. I can have a struct containing strings and vectors and initialize it in aggregate initialization and the ctors get called fine no problem. I think several of the sentences in ur post basically conflate POD and aggregate. I'd hazard a guess thats why you got downvote.
Yea thats the language lawyer / standard way of describing the situation but afaik they could have written the standard to talk about default generated aggregate ctors like johannes is saying, and the language would be indistinguishable. And it might be easier to teach it that way even. Historically pod structs are aggregates and are c compatible and dont have ctors because c doesnt have ctors. So thats the argument against describing it that way. But if you dont want to teach c, only c++ in and of itself, idk it seems reasonable to me. Except that most books and sources will use the standards terms.
&gt; But there's clearly no point in the compiler team implementing a warning that everybody suppresses. Jackass. If you're going to break a bunch of code with an optimization, figure out how to make a good warning. I'm sure this optimization broke a great many people, think how many hours went into finding and fixing these bugs. `refresh(&amp;frameCounts[i]);` breaks the function, but `refresh(frameCounts+i);` would be fine.
It's bad though, IMHO. Aggregate initialization gets disabled as soon as any constructor at all is defined, and for good reason. Now if I *explicitly delete* the implicit default constructor, I *doubly* don't want you to be able to aggregate-initialize your way around that. A class with an explicitly deleted default constructor and no other constructors should be a zero type.
That's why I used the word "apparently".
&gt; I would expect newcomers to mostly make do without elaborate build systems. Your first projects are likely to be single-file, and can be compiled by hand using a trivial makefile. The newcomers these days are, on average, not going to run compile commands by hand. Nor should they. A simple command line tool to generate and build is already a stretch for many and they'd prefer just click things on an IDE until they get comfortable with things. Also, Makefiles are not "simple". Never been, never have. They are a morass of byzantine syntax, obscure corner cases and terribleness. Even though many people have worked on them for a long time, understand them and can make them work, they are not "simple". Especially for newcomers. &gt; have you ever considered configuring builds using an MMI? This was a thing I considered at the very beginning. The idea would have been to have binary database of sorts that would not be edited directly but with command line options such as `buildtool --add-source foo.c --to-target myexe`. The problem is that since build definitions are complex (build X if we have dependencies Y, Z and W but not G and the platform is Windows), describing all the things with command line options or the like is even more complex than with a DSL. Still, it is an interesting question and would probably make a good research project for someone. That being said we do planned to add a rewriter, much like Clang based refactoring tools for C++, to do these sorts of operations from the command line. There is some code for this in trunk already but it's currently a bit broken. &gt; learn yet another obtuse and no doubt Turing-complete language The Meson build definition language is not Turing-complete by design. It will never be Turing-complete. If anyone finds a way to cheat and make it Turing complete, this will be considered a bug and fixed. 
To be fair, the author did explain why they chose not to use a warning. Because it's such a common optimization, there would be tons of false positives... 
Doesn't that make it more important to have the warning though? If you break my code, please, please, tell me about it. Even if it means I have to fix my code.
I'm not saying I disagree, but you won't see warnings of this in any other compiler I'm familiar with either. And that's probably for a good reason. Also, if I recall correctly, there was a Linux kernel security bug with this exact optimization few years ago.
I said "by hand, _or_ using a trivial makefile". Don't quote me and then selectively leave a single word out that changes the meaning of what I said. A newcomer is likely to just type something like "g++ -c main.c" to get an executable. Once he gets tired of that, he is likely to automate that with either a bash script or possibly a makefile, which is probably around 5 lines long. And of course if he is using Visual Studio this whole thing never comes up in the first place. Whether or not makefiles are simple is up for debate. They are, however, not any more complex than any of the other build systems we have! You need to sit down and learn a new language - and not a trivial one either. That language comes with a mountain of terminology, which if you are lucky, the build system author actually explains somewhere. As for how an MMI could work, check out Visual Studio. It certainly has room for improvement, but it lets you put together a project in fairly short order, _without_ having to learn another language. 
Catch makes it very difficult to test polymorphic code.
&gt; Doesn't that make it more important to have the warning though? No, if 99.99% of the code is correct. It's like having a warning on all signed integer arithmetic, because of potential overflow. This case, however, should probably be caught by static analyzers.
&gt; Don't quote me and then selectively leave a single word out that changes the meaning of what I said. This was a copypaste error on my part. Sorry. &gt; A newcomer is likely to just type something like "g++ -c main.c" to get an executable. Your definition of a newcomer seems to indicate a person who is already fluent in command lines, compilers, files. They also need to work out by themselves that the command you wrote does _not_ create an executable. Only an object file, because it has `-c`. In contrast we use the term newcomer to mean people to who are uncomfortable with the command line in general and compilation in particular. &gt;[Makefiles] are, however, not any more complex than any of the other build systems we have! Well let's see. For example here is a sample makefile from [this page](https://spin.atomicobject.com/2016/08/26/makefile-c-projects/) with a heading of "A Super-Simple Makefile for Medium-Sized C/C++ Projects": TARGET_EXEC ?= a.out BUILD_DIR ?= ./build SRC_DIRS ?= ./src SRCS := $(shell find $(SRC_DIRS) -name *.cpp -or -name *.c -or -name *.s) OBJS := $(SRCS:%=$(BUILD_DIR)/%.o) DEPS := $(OBJS:.o=.d) INC_DIRS := $(shell find $(SRC_DIRS) -type d) INC_FLAGS := $(addprefix -I,$(INC_DIRS)) CPPFLAGS ?= $(INC_FLAGS) -MMD -MP $(BUILD_DIR)/$(TARGET_EXEC): $(OBJS) $(CC) $(OBJS) -o $@ $(LDFLAGS) # assembly $(BUILD_DIR)/%.s.o: %.s $(MKDIR_P) $(dir $@) $(AS) $(ASFLAGS) -c $&lt; -o $@ # c source $(BUILD_DIR)/%.c.o: %.c $(MKDIR_P) $(dir $@) $(CC) $(CPPFLAGS) $(CFLAGS) -c $&lt; -o $@ # c++ source $(BUILD_DIR)/%.cpp.o: %.cpp $(MKDIR_P) $(dir $@) $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $&lt; -o $@ .PHONY: clean clean: $(RM) -r $(BUILD_DIR) -include $(DEPS) MKDIR_P ?= mkdir -p And here is a roughly equivalent snippet in Meson (it does not do globbing): project('myproj', 'c', 'cpp') inc_dirs = include_directories('src') executable('myprog', 'src/source1.c', 'src/source2.cpp', 'src/asmsource.s', include_directories : inc_dirs) Whether or not one of these is much simpler than the other is a question each person needs to decide for themselves. &gt; As for how an MMI could work, check out Visual Studio. Visual Studio's MMI only solves the very simple problem of compiling source code for one platform with one compiler without flexibility in project options. This is fairly easy to do. Extending it to big flexible cross platform projects is very hard. And it should be noted that VS serializes its build definition to an XML file which is a kind of a DSL.
&gt; `refresh(&amp;frameCounts[i]);` breaks the function, but `refresh(frameCounts+i);` would be fine. But `frameCounts` is of a user-defined type. It's very unlikely that `frameCounts+i`would compile.
Aggregate initialization is enabled only for aggregates. Having a user-provided constructor means the class isn't an aggregate. But defining a constructor as `= default` or `= delete` doesn't count as being user-provided. This is a somewhat useful feature for the code in the question, as it means you can't create an instance of the struct with uninitialized members. (The defaulted default constructor performs no initialization for built-in types and some others). You can only create an instance by aggregate initialization which necessarily initializes all non-static data members. There's other ways you can make the class a non-aggregate. I would prefer if there was a keyword for this rather than it depending on the properties of the class (the definition of which changes in every standard). Not sure what you mean by "zero type". 
Initializer list of what? (`std::initializer_list` is a template that must have a parameter)
Blaze seems to require calls to lapack, like gemv(). That looks like a step back from Eigen's expression template, where y = a*x + b is a valid statement.
It have been proposed in several ways before but always repelled because it's like trying to standardize a particular implementation when the problem is more to be able to express intent. Anyway look for the SG7 discussion group (and the Proposal one too) on isoccp.org and search for "AST" for more about this.
I'm not deep in this topic, but isn't that basically what the gcc toolsuite did? Each front end compiler like g++, gcc, gcj, gnat just emits the same AST that is then what is compiled to machine code?
The main issue is with self-appointed representatives that speak on behalf of specific groups and gained enough influence to adjust things to their liking. E.g. a lot of women find it counter-productive to scare women about IT being heavily sexist and unwelcoming for women and minorities, thus more women will not find IT to be as appealing which in turn will result in people that spread these ideas to keep their narrative (which is essentially their main occupation). At the same time most women don't want to be assigned to some group or to be public spokespersons on specific issues and these "fighters" know that very well and even if someone speaks out they are quickly silenced or shamed for going against their own interests. Big corporations are even more susceptible to the pressure given their size and reputation, the "Google Memo" is a very good indication of how much power these ideologies hold over ("we welcome any ideas as long as we agree with them"). Wilfrid Laurier University controversy is another very good example of how these ideas are infiltrated and how we got here.
I was referring to our in-house framework. The parser is of course not 45loc, the 45loc refers to header size. You can see the header here. https://pastebin.com/BJL9Hb3g (Value is a variant type (that can also hold map, list or a boxed type). It's hardly anything special, although it does support serialization/deserialization of custom boxed value types. Still, the implementation is hidden and does not result in parser code being compiled over and over again. The actual parsing is done by sajson, but that's more or less implementation detail.
&gt; For instance - and I'm not claiming this is a good idea, just an example - a very generic delayed event queue system could be constructed. He. As soon as `&lt;any&gt;` came about, [I did literally just that](https://github.com/thierryseegers/event_channel/commit/15365b791c52c5f25e96f27d3b638a69c3829ba5#diff-34be2adf1a1f08894ea3a1fc21fcb374) in exactly the context you describe. 
See https://github.com/GabrielDosReis/ipr for something akin to your suggestion. I am hoping against hope that all compilers consistently use something which is similar to this for modules. I believe Gabriel has been pushing for this but have not seen any reaction from the Clang or GCC developers.
 I don't know anything about that, but it might depend on how high level it is. Something like webasm is an AST, but it would lose a significant amount of the information in a C++ program - the decisions of what to do with all the extra information would already have been made. 
She also have a [lightning talk](https://www.youtube.com/watch?v=ARosL9xrozk) in the same event, worth sharing more than this one. But I guess that lightning talk maybe off topic in r/cpp.
&gt; Your definition of a newcomer seems to indicate a person who is already fluent in command lines, compilers, files. If you are on Linux that's not unreasonable. The shell is unavoidable anyway, and a simple hello world style example (including how to build it) can be found online easily enough. Anyway, we can argue about this for a long time, but I feel that build systems in general are too complex and require too much arcane knowledge, all in the name of being too generic. I also feel that newcomers aren't served well by that. If you built something into your buildsystem that makes things easier, well done, it can only help. I'm still wondering why we need build systems at all though ;-) This is something Visual Studio gets right: you can set up and maintain a project using a simple MMI, without too much difficulty, and build it with a single keystroke. All the underlying details of how that actually happens are irrelevant. Is its expressive power too limited? It seems to do pretty much what it is intended to do, which is compile complex C++ systems. It _will_ let you select from multiple compilers, and define different build modes (i.e. different options), and as far as I know it even supports building on Linux now although I haven't used this myself. And it lets you do all that without ever having to read a manual. I'm not saying its perfect, but it is this kind of ease of use that we should be aiming for. I like your simple example, but I'd much rather not even have to learn this. And I'm sure that must be doubly true for a beginner, who already has more than enough on his plate with the language itself. 
I'm hoping Herb Sutter's metaclasses will eventually make it in
Well it is hard to achieve this with normal constructors: &gt; Baz baz4{1}; // fine: aggregate initialisation &gt; Baz baz5(1); // fails: constructor deleted Also I don't think the following can be done with constructors (from [\[class.temporary\]/6](http://eel.is/c++draft/class.temporary#6)): &gt; struct S { &gt; const int&amp; m; &gt; }; &gt; const S&amp; s = S{1}; // both S and int temporaries have lifetime of s (You can say that the hypothetical "aggregate ctors" are special and thus can behave differently from ordinary constructors, but I personally don't think that will be easier to understand than just adhering to the standard.)
The solution for the small object optimization presented in this talk relies on undefined behavior. A detailed explanation of the issue and a proper solution can be found here: http://stlab.cc/tips/small-object-optimizations.html 
Something that I don’t see recommended very often is enabling debug mode in libstdc++ (if you are using GCC): https://gcc.gnu.org/onlinedocs/libstdc++/manual/debug_mode.html. This is debug mode on the gnu std library, not the compiler! The name is kind of confusing. There’s a lot more info in that link but basically debug mode checks all preconditions dictated by the standard so it can help to track some bugs that even sanitizers would miss. For example, indexing a vector past-the-end but still falling in the reserved for growth memory area. There are no invalid memory accesses here because the vector owns the memory region, but it’s still a (nasty!) bug. Enabling debug mode boils down to passing a macro definition in the compiler command line. In my CI pipeline I just added an extra debug build with gcc and this macro defined.
Indeed, this sort of optimisation is terrifying.
I did not downvote you but what I do not like is that your post starts explaining it as if it is "normal" feature of the language. In fact it is ugly and confusing because "average" developers see deleted constructor and think that struct can not be constructed. Without exaggeration I would be surprised ifmore than 60-70% professional C++ devs even know what aggregate init is. So I think the proper answer would be: people wanted agg init and deleted constructors, never thought of this case or did not care or did not think of a way to fix it in a consistent way so we have this abomination corner case in the language. tl;dr you are technically correct and explain it using language rules but it misses the point of the question that is in my view: WTF is this a sane language design? A: it is not :P, this is Cpparta! :P 
I went ahead and bought the book to check it out and report back... (Btw, I definitely made sure to pay more than just the suggested donation, Nicolai Josuttis being the author and all.) I can confirm that "C++17: The Complete Guide", is an excellent resource and that it comes as described on the site.
Replying here too... I went ahead and bought the book to check it out and report back... (Btw, I definitely made sure to pay more than just the suggested donation, Nicolai Josuttis being the author and all.) I can confirm that "C++17: The Complete Guide", is an excellent resource and that it comes as described on the site.
I think Bjarne Stroustrup was hinting towards something like this. I do not remember what he said exactly and in which setting it was. He was at least hinting that he would like to see some form of intermediate representation of C++. (Maybe the question was if there is a chance for a nicer syntax for C++ and he said it might be possible if there was such an IR.)
Or, you know, you could just avoid writing code that relies on undefined behaviour.
Compilers would probably just have to walk it and convert it to another (internal) AST-like format, so I don't know how much you'd gain.
I just read the full thread here regarding my apology at the start of this talk. The fact that it has sparked heated discussion is a strong indication it was necessary. Some background; before giving this talk I discussed the issue and my response with several individuals, men and women. Several of the women said they were not offended by my use of "guys" - but several said they cringed when I said it, all of them noticed it. None of the guys were even aware of it, but nearly all thought that "guys" was not gender neutral. Keep in mind this talk was given in Germany and the audience were largely not native English speakers. The fact that "guys" has become a gender neutral term when used in the second person was a subtlety that was missed by many. I did not feel like the complaint I received was in any way an aggression (micro or not), and the individual accepted my personal apology at the time - and that could have been the end of it. I chose to make it public because I thought it was important. If Jens had cut my opening remarks from this video I would have been offended. I've been fortunate enough to work with amazing people during my career and made many lifelong friends. They are a very diverse group. Men and women, straight and gay, black and white, atheist and religious, and any number of shades in between from countries all over the planet. I've witnessed some of the hate, both blatant and subtle, and heard their stories. I understand that such hate can leave one to feel excluded. When we cut smart people with diverse views out of the conversation it is a loss to the profession. I want everyone to feel welcome and included at any conference where I speak and to feel like they can approach me with questions or comments or conversation. I owe my career to such encounters and it is clear that as a profession we can do better. 
The solution seems too complicated. If `divmod` gives the digits backwards, then don't do that! Here's a kernel of a solution that produces digits in-order the first time. No lookup table or hardware division. The strategy is to put BCD digits in the high-order four bits of a 64-bit register. It works for 0…1899855399. Extending it to higher numbers, and replacing the first loop with a `clz`, are left as an exercise to the reader. It differs from common `itoa` in that it returns a pointer to the end of string instead of writing NUL. This is more suitable for logging. constexpr std::uint64_t unit = std::uint64_t{1} &lt;&lt; 60; constexpr std::uint64_t prescale = unit / std::uint64_t(1.e9); char * itoa( std::uint32_t n, char * out ) { std::uint64_t frac = n * prescale + prescale; int i = 0; while ( i != 9 &amp;&amp; frac &lt; unit ) { ++ i; frac *= 10; } while ( i != 10 ) { ++ i; * out ++ = '0' + frac / unit; frac %= unit; frac *= 10; } return out; } 
Optimization of undefined behavior isn't terrifying - undefined behavior is, well, undefined. The correct solution to stop writing code that exhibits undefined behavior.
The ability to write macros that can manipulate this AST would be a big plus.
You make that sound so easy.
I suppose that's bad phrasing on my part. I should probably clarify that it skips the aggregate class's constructors, not all constructors Entirely my fault and definitely warranted. Will update my post n_n'
Yep https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html
You could look at it: https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html
I mean there are zero instances of that type. Like void. As far as the standard goes, of course, you're right. I just think a class with a deleted default constructor shouldn't be aggregate-initializable even if that would have to be a special rule. An explicit keyword to *enable* aggregate initialization would be swell, but you know how it is with C++ and backward compatibility. It wouldn't retroactively apply to existing aggregates.
It is a normal feature, though. Aggregate initialization exists separately from construction as another form of instantiation. I agree that with the introduction of initializer lists it becomes confusing beyond belief, but for the former designs it made some sense. They definitely did not forget about it, as the [proposal papers](http://www.stroustrup.com/N1919-initializer_lists.pdf) for initializer lists specifically say that they wanted a consistent initialization form with aggregates. Whether or not that's good design currently- I did not comment on in the other post, so if anyone did dv for that: I'm not on the standards committee and had no hand in developing any of this.. n_n' I agree that it's confusing in contemporary `C++`. I can imagine aggregates being important for performance-critical embedded systems where the overhead of a function call makes more of a difference, so to explicitly avoid the constructor call and minimize manual value assigns they provided aggregates. Granted, the compiler could have done the same thing based on pure field initialization list constructors, so this is all conjecture and I have no real idea what discussions lead to its introduction. ¯\\\_(ツ)_/¯ And the standards committee has made clear that they want to *avoid* making standards changes that could break older code bases, so the aggregate initialization remains. I do wish they would, at least, make aggregates more explicit to avoid this issue. Maybe in the current proposal for `C++20`, with the introduction of better metaprogramming or attribute tags we'll see an `[[aggregate]]` tag for class definitions, so it's not implicitly assumed. **EDIT:** Added a link to the proposal paper for initializer lists
The compiler shouldn't even try to compile that code. The point is that programmers are not aware when they stray into UB territory
I enjoyed the talk and some good points made. Note, it's 2h long; I suggest watching it at 1.25× speed.
&gt;The compiler shouldn't even try to compile that code. Why not? What would you rather have it do instead? The best solution to this problem is to use a static analyzer and/or use the undefined behavior santizer. &gt;Programmers are not aware when they stray into UB territory Again, use a static analyzer and undefined behavior sanitizer. Also, null references aren't exactly an obscure form of undefined behavior - I'd expect most C++ developers to be aware of it.
Personally, i would have it error. The problem here is that the programmer thought they were doing the right thing, but the compiler knew better and did its own thing. Do you know how much decent static analysers cost?
Indeed, with modules, most compilers (if not all) with have to store internal representations on disk in one form or the other. It would be a shame if N compilers on the same platform were to store totally incompatible and non-interoperable N intermediate form for modules. I strongly believe that the IPR does a very good job at that, in addition to informing the semantics model for the Module TS. I would love to see it developed further by the community (not necessarily the committee).
&gt;Personally, I would have it error. I fail to see what the error here is. The compiler removed redundant code based on a provably* true assumption (references are non-null). This is the basis for lots of compiler optimizations. By violating the language contracts, you forfeit the right to predictable behavior by default. If you want it, there are tools like the undefined behavior sanitizer that will do it. Use them. &gt;Do you know how much static analyzers cost? There are free static analyzers out there that are sufficient for your hobby projects. Besides, in most cases, this will be caught by any half-decent test suite and is easily diagnosed if you test with undefined behavior sanitizer. If your code is complex enough that you can't catch it in testing or with a free static analyzer, you can afford a paid static analyzer. The bottom line is that this code is not invalid according to the C++ standard, and therefore an error would, IMO, be inappropriate. A warning would be fine but, as the article says, would generate too many false positives to be useful in practice. Even basic testing with the appropriate sanitizers should easily catch this issue. In fact, the moment your code starts breaking when optimization is turned on, suspect the correctness of your code, not the compiler. *EDIT: provably, not probably
With the undefined behavior sanitizer and a decent test suite, it almost is.
&gt;there was a Linux kernel security bug with this exact optimization a few years ago Unlikely, though it may have been a similar issue. C++ is not permitted in the Linux kernel codebase and C doesn't have references.
I might do this. Thanks stranger!
&gt;As for ASM, again it depends on who's assembler you use That's...not how it works. Assemblers directly convert written assembly to hex - you could probably write a basic one in an afternoon. When it comes to assembly, you dictate precisely what instructions the CPU executes; the performance is entirely in your hands.
That's one long dependency chain, though. The article's version is twice the throughput. 
GIMPLE is very low level. gcc people have been pulling as much FE specific stuff as they can out of it. Even the link time optimization which streams stuff wasn't high level enough. Nate wrote a streamer by hand. Check https://gcc.gnu.org/wiki/cxx-modules for progress. fwiw i think there a lot of communication among modules implementors.
She's awesome. I like her talks on explaining how to teach CPP and aid those around you, which imho can be rather beneficial in numerous situations, despite the simplicity of some of her talks.
Do you have a link to that sanitizer?
Check project out: https://github.com/mudlet/mudlet - it's a MUD games client, made with C++11 and modern Qt.
In that example, it would not assert even if the value of the constexpr string is not equal to the base of T, so it is of limited use. But you can use it to trigger static asserts for values and value templates. For example, I have a JNI library in which you can declare method signatures beforehand, and then a templated function would be able to check whether the method was declared. // jMethod is a template function that converts a function signature into a Java-style method signature. constexpr Enum method_signature = {{jMethod&lt;jboolean(HashSet, String)&gt;("contains")}}; // HashSet::signature and String::signature are constexpr strings . . . template&lt;typename... Args&gt; jboolean contains(Args &amp;&amp;...args) { static_assert(method_signature[jMethod&lt;jboolean(decay_t&lt;Args&gt;...)&gt;("contains")] != -1, "Method signature not declared"); // Perform jni-&gt;call(...); }
:eyeroll: so if the assembler only supports a limited dialect and does not have a method to hard-code hex for unknown commands (some do), then my comment stands.
I think you misunderstood me. (or I'm misunderstanding what you are saying) I want to do a static assert with a message that is dependent on a template parameter. Not the assert itself. Would your constexpr string enable that? 
https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html
Apples to oranges. Does moving two bytes from a lookup table actually take less instructions? I doubt it. The inner loop in this solution is [multiply by 10,{ [shift 60, add ‘0’, push digit], bitand, increment counter &amp; branch}]. Curly braces signify independent, parallel operations. 
" It turns out that approximating log10 is hard, and we gave up ;)" It is actually quite easy, just not obvious: https://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10 Other than that nice article, a bit long, but I really appreciate you taking the time to talk about the byte size of the functions and LUT.
Fair enough. I use both, because sometimes I refuse a buffer and sometimes not. Admittedly, when using the buffer semantics, more often than not, it happens through an indirection (something like a gsl::span) so it wouldn't be a problem, but to be honest, I think this is one of the few cases, where a bit more verbosity would be advantageous.
That's not always an option though, I think the real solution is to know when you are using undefined behaviour and to mitigate the effects however you can. The fact is every time you write code that dereferences a pointer, or adds signed integers, you are introducing the possibility for undefined behaviour. You may even be relying on a certain implementation's behaviour (see pretty much every emulator ever written).
It's like the tricky difference between std::vector&lt;int&gt; v(2, 3); and std::vector&lt;int&gt; v{2, 3};
Great talk, just (yes, "just", I said it) one remark about the `IsOdd`-example: I'd prefer ``` bool IsOdd(int x) { return ( x % 2 ) == 1; } ``` rather than the cast as this is IMHO immediately obvious even without knowing about how casting an integer to a boolean works, it's shorter and expresses what is actually going on semantically. 
Nice, too bad clang can't handle Windows headers (last I checked).
No, I think `static_assert` only accepts string literals. constexpr strings still wouldn't count as a string literal.
Ironically, you literally started the talk with "So you guys know me..." - not sure if that was done on purpose. Interestingly, "guys" can also offend men. I once wrote an email where I was addressing "our OPs-guys", and they are all men so no gender-related issue here. One of them was still really pissed as he, being German, didn't know the word and typed it into an online-translator. It was translated to "Typen" or "Kerle", which is not very positive in German. That might happen if people focus too much on a single word without context. (Depending on the context, even "Typ" or "Kerl" can be very positive). The lessons here are: Language is complicated, people are complicated, I can't read other people's mind, and context matters. Personally, I try to relax and remind myself that most people don't want to offend or exclude me (in my case not gender-related, but there are other issues that make me feel excluded every once in a while). Only when I feel like the other person actually intends to do so, I think about taking action. To me, intend is the important thing to focus on. Finding out who is deliberately excluding people, and to take action against those people, is way more important than grinding the small things and only make myself as well as people that had no bad intentions unhappy.
Those sanitizers are also available for GCC. Here, have some read:https://github.com/google/sanitizers/wiki
neither... it is just that there is so much users of Excel/PP that having a extremely small % of the userbase pay you 200$/year you can make a lot of money. So my guess is they found a niche market that was ignored/too small for MSFT to target.
I agree, it's arguably clearer. It's an explicit logical comparison, rather than knowing how an integer is cast to a boolean (be it explicit with `static_cast`or implicit, leaving as is) 
Your code is slower and, yes, takes more instructions. That's all that really matters in the end, except for understanding why.
Might want to make it so it doesn't text super ultra mega large files like the entirety of dear imgui.
Thank you, I really appreciate the insight. When I do the next run, I will keep that in mind. 
ALL code is significantly less pleasant to review without syntax highlighting.
For primitive functions we want speed, hence we want to avoid division: constexpr bool IsOdd(int x) { return static_cast&lt;bool&gt;(x &amp; 1); } 
Since we are getting designators in C++20 for structure initialisation, one might wonder if that same mechanism couldn't be used to designate formal parameters as well. I.e. std::vector&lt;int&gt; v (.list = {2, 3}); std::vector&lt;int&gt; v (.count=2, .value=3); 
Weirdly, I've met developers that turn off syntax highlighting in their editors. I'm not sure if they're expecting to be ready for coding on a desert island or what...
What about negative numbers?
I doubt this. Very few standard library classes have exposed certain member names. Too much work to do
Formatting, comments and fewer levels of deeply nested code and variable access makes the code more readable to me
"Human understandability" sounds like the ability to understand humans, not the ability of humans to understand.
If your compiler actually generates a division for `x % 2`, file a bug.
Writing header files is annoying.
In terms of standard library: Unicode support. The lack of such a fundamental library is kind of an embarrassment. But at the same time, we don't even have a string split. As for the language itself, it's held back by the fact that it's 30+ years old, and some of the decisions made back then are nearly impossible to change without doing a half-ass job or just starting over with a new programming language. It makes features like constexpr feel tagged-on, instead of an integral part of the language. You can see the same struggle with things like modules, concepts, metaclasses, etc. Things that should be added when a language is made, not afterwards. In the perfect world we would just start from scratch, but you can't just throw away and replace decades work.
&gt; half ass-job *** ^(Bleep-bloop, I'm a bot. This comment was inspired by )^[xkcd#37](https://xkcd.com/37)
To see why I am right about optimizations, compare: https://godbolt.org/g/FmJbC5 with https://godbolt.org/g/bDpNAo 
I work with a large C++ code-base and these are the things that bother me most: 1) No "interface" keyword: all modern languages have the concept of an "interface". In C++ you must use pure-virtual base classes to emulate this. When you don't pay attention these might degrade over time (data members are added; default implementations of methods; ...). Additionally, when you use interface inheritance (IFoo inherits from IBase) you can't inherit the IBase implementation of a base class. You need to write forwarding implementations which is just boiler plate code. 2) Compile/Link-Times: the archaic way of using other classes (by including their definition textually) just doesn't scale. You must pay a lot of attention to your source code layout to prevent unnecessarily long compile times. Templates also have their way of slowing/bloating your compilation. 3) Asynchronous programming: yes, this will probably be resolved by coroutines. But today asynchronous programming is a PITA with nested callback hell. 4) STL: this is surely a matter of taste. For me the API of the STL is often just weird and non-intuitive. Trivial string handling stuff is just missing, you need to rely on additional libraries like Boost. 5) Headers + Cpps: declaring &amp; implementation of methods is very repetitive. Without a good IDE this sucks. In the end I must say that C++11 improved development a lot, especially lambdas. It still is fun occasionally :-) 
You're right. Can you file a bug please?
With regards to point 1, you can actually have reusable implementations of the interfaces with template chaining, ATL style.
Header files are a bit annoying, but have never been a serious impediment to my getting work done. Build systems and package managers on the other hand, those have been. I don't even mind the behavior of `#include`, but the difficulty of incorporating a third-party package is just insane. Automatic coercion between floats and integers has bitten me way too many times in the midst of a huge formula (I write code that does astronomy/physics). Rust takes the opposite approach and simply refuses to coerce at all. I don't think that's the ideal approach either; my code ends up looking worse. The inability to arbitrarily overload `operator[]` is a significant impediment to having sane-looking array manipulation code. I want to index into multidimensional arrays, but doing so (with `operator()`) looks way different than indexing into a `std::vector`.
Have you benchmarked or checked the instruction sequences of anything? You're quite certain, eh?
Lack of concepts. 
Except when you are making a header-only library.
Setting up a build environment, adding third party libraries, like pulling teeth.
On a language level, having both overloading and implicit conversions. I suspect most of C++'s incidental complexity would not be there if C++ had at most one of those. 
Yes, I spent quite a while benchmarking this stuff.
The [https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/](metaclasses proposal) makes it trivial to implement your own interface keyword: https://godbolt.org/g/Uzw5iJ
No syntax highlighting and a very tiny window don't make me want to review any of them.
The gazillion ways of assignment. Also copy/move constructor problems because of differences in user defined yada yada. I mean, if I delete the move constructor, I expect it to not be a better candidate than a non deleted copy constructor... 
&gt; inability to arbitrarily overload operator[] is a significant impediment That's at the top of my list. Is there a reason we can't do this?
Wouldn't you rather that every library was as easy to consume as header-only libraries?
&gt; 1) No "interface" keyword: all modern languages have the concept of an "interface". And in all of these languages, it is utterly useless. I mean, look at Java where you can now have function implementations in your interfaces.
The preference of adding power to existing language features, instead of adding new language features. For example, look at what language improvements over the last 10 years were necessary to make std::variant work. But what if we had just added first class type sums instead?
Template metaprogramming is ridiculously verbose and complicated. It's great to have a Turing-complete language for defining types at compile time, but it could be so much better in every way.
The fact that every time there is a proposal accepted in a given standard, it is getting fixes and amendments the next ten years. I mean, seriously, when they made lambdas in C++11, did really no-one think that having them : 1. Generalized so that you could have more than a single return with everything in it 2. Accepting *this by value 3. Getting template parameters etc etc... would be good to have from the get-go ? And I'm pretty sure it's going to be the same with `auto&amp; [decomposing, expressions]`... there's going to be rectifications and fixed missing behaviours up until C++30. Also, the fact that "good ideas" from proposals don't propagate to the rest of the language. We got `[] (auto) { }` so why didn't normal functions get auto parameters too ? It just makes the language less coherent and more special-case-ish for absolutely zero gains. We got transparent comparators for std::map / std::set, why not transparent `hash` &amp;&amp; `equal_to` for unordered_set / _map ? Why can't there be templates in function-local classes ? 
Expand? I'm new to C++
Not to mention that if it is just for inheritance, it doesn't solve templates, though that also resolves itself through compiler errors specifying which functions are missing. 
The biggest strength and weakness of C++ is it's legacy. Weakness because new C++ features (modules, for example) are constantly fighting with the old implementations. Strength because it has provided C++ with a large amount of backwards compatibility. You can be fairly reasonably assured that new C++ won't break old code.
Really? It's one thing I like, clean separation of interface and implementation. Except when it isn't (templates, inline methods).
People have been trying to improve this for quite some time. There was the Concepts proposals for C++0x, which ended up being abandoned. There is now the Concepts Lite TS, with hopes that it is merged in the C++20 standard. If people succeed doing this, template metaprogramming might become better.
Copy. A copy action should be explicitly initiated by the user, but in C++, copy is everywhere – you just don't see them :D
separating interface and implementation is bad. 1. By using it your making your program harder to optimize for the compiler. 2. Wasting time writing two times the same thing. 3. You make your interface harder to change. 4. Will be killed by modules.
- Implicit conversions - Compile times - Macros - Build/package system - Error messages
But your code is broken. You will get wrong results for negative inputs. ((-1) % 2) == -1 ((-1) &amp; 1) == 1 If you use (x % 2) != 0, you will see that it gets optimized in the same was as the bitwise operation. 
Not enough undefined behavior
I don't disable syntax highlighting but I certainly tone it down a bit. I never liked the recent trends of neon colours for everything. I actually quite like a more monotone style at the moment. If anyone knows of some nice mono-colour themes let me know :)
(emphasis mine) &gt; **Except** where it has been declared for a class (13.5.5), the subscript operator [] is interpreted in such a way that E1[E2] is identical to *((E1)+(E2)). Then in 13.5.5: &gt; operator[] shall be a non-static member function with exactly one parameter. As far as I can tell, the standard gives no justification for this stipulation on classes overloading the operator.
Concepts are a way to place requirements on template parameters so they can provide better error messages and handle the use cases of things like `enable_if` more straightforwardly.
&gt;By using it your making your program harder to optimize for the compiler. This is the main problem with C++'s header/impl separation, yes. &gt;Wasting time writing two times the same thing. Not really, my IDE writes the boilerplate for me. &gt;You make your interface harder to change. I don't get this one? Interfaces shouldn't be changing anyway, and I don't see why separation of concerns makes this any harder. &gt;Will be killed by modules. And it can't come soon enough. 
But he meant it makes it easier to read for humans
All the legacy C stuff. 
They will be part of C++ 20
No default and sane build system/packager. Currently getting started with c++ without prior 'programming fu' can be ... off-putting. Meson/Qbs and their friends are definitely a step in the right direction, so that's a plus :]
Don’t forget that template meta programming is a kind of exploit. In other words, template weren’t designed for that. But constexpr will fix most of it.
the pre-processor without a doubt. that thing exacts its price every day by slowing down builds and making every single C++ programmer less productive regardless of skill.
Didn't D try to do just that?
Wait what? What happened there?
There's always someone
Allowing multiple arguments creates parsing ambiguity with the comma operator.
Most of them can be reduced to "legacy/syntax quirks from C days". But then again, C++ most likely wouldn't be there it is today without being 99% C compatible.
Thankfully, much less so than in C++ of a decade ago.
Isn't p here the path being appended? It then makes perfect sense - "a" + "/b" = "a/b". No need to add extra slash separator between a and b.
Poor serialization support. I'm trying to address that by automating the creation of serialization functions -- https://github.com/Ebenezer-group/onwards
So much this. I regularly watch C++ conference videos, and there's always one speaker that makes fun of C++ programmers wanting to be in control and invent everything themselves. No! I *want* to use libraries, it's just a massive build and deployment hell, especially when you're dealing with cross compilation (I work on linux ARM and PPC systems). Lately it has become slightly better as more projects use CMake, but I still wouldn't call it a painless experience, and I don't think CMake is the definite answer. Yes, writing that text parser myself *was* easier than getting that library to compile on my platform. No, I'm not proud of that.
&gt; with hopes that it is merged in the C++20 standard It was already merged last month.
I like vim's desert theme on a dark background.
It's C and legacy. As C++ can only change by adding, any antiquated design from C and previous versions will remain. One of the worst offenders for me is how parsing in handled in C++ (prototyping instead of definition pre-parsing, requiring "template", "typename" in template definition, etc...). The only solution would be if C++ had an alternative front-end (exactly same internal representation but with a modern parser; simplified syntax and compatible with legacy C++ only through import statement a la go import("C")). That will never happen though. 
&gt; They will be part of C++ 20 They are part of C++20. :)
I used TMP and variadic templates to generate compile-time classes for a virtual machine. Coming up with the concept I wanted to implement took all of 30 seconds. Actually figuring out the syntax to get it to work took me six days, and it's ugly as hell.
&gt; this effectively means that any absolute paths on unix/linux/mac will by default never have the path::preferred_separator added. `p` is the argument, `*this*` is what you call append on. 
Ever since I took a job working in C#, I started making *all* my C++ classes header-only. So much easier to work with (unless you need static data, but you can work around that via templates).
&gt; In what case would appending path::preferred_separator to a path turn it from relative to absolute? That question is the first thing shown in the example on the page you linked.
If your using an IDE then the IDE can produce the prototype for you. It made sense in the 90s for corporations to ask this but not a world where Js, Java and C# are so widespread.
Great, thank you!
Or Rust.
They didn't fail, but came close
I highly recommend you to check out Conan. They recently released their [1.0.0 beta version](https://github.com/conan-io/conan/releases). It's not painless but it is much easier than what you normally have to go through.
This is a bad idea if your projects have a significant number of classes. Build times would be horrible.
What removes the ambiguity in a function call?
I disagree. If it's so easier why is it absent from all modern programming languages ? With most IDE you can hide the body of any declaration. But even if you don't have an IDE to *understand* what a definition does without its body is often difficult. It's easier to skip a bunch of lines according to their indentation than to go back and forth between multiple source files.
Not if you use a precompiled header.
Hooray for modern compilers!
Backward compatibility. Windows.h. Please let me use C++11 😫
The world is constantly evolving -- any attempt to "redo" a large system to "get it right" is going to freeze the assumptions about the world at the time, so that by the time the "new version" solidifies there's already something people are wishing they could "go back and fix". Remember WinAPI was supposed to fix everything wrong with posix and make it more "rational" and "user friendly" -- and now it mostly stands out as simply being "not posix".
String manipulation. Any time you want to do anything more complicated than take a substring you have to write it yourself or pull in something like Boost. Trim, Split/Toikenize, Upper/lowercase, Case-insensitive comparision, etc. - perhaps none of these are awful to write yourself, but whenever I need one of them (which is often enough) it always makes me wish I was using any other language.
constexpr will only solve value metaprogramming but not type ones. We can use now lambda in unevaluated contexts which might help but isn't pretty either: template&lt;IsFnConcept T&gt; using fn_args = decltype([]&lt;class R, class... Args&gt;(R(*)(Args...)){ return std::tuple&lt;Args...&gt;{}; }((std::add_pointer_t&lt;T&gt;)nullptr));
C++ isn't the only language that does something similar. ocaml, for example, has interface files with the signatures of all functions and types and such to be exported from a source file. Of course, in that case the compiler generates them if you don't write them.
I agree type manipulation won’t be much better (although you can achieve a lot of it with constexpr too, think overloads!). But at least part of the meta programming will be adressed 
You can still separate out inline or template definitions. Put them below the class definition (either directly or #include them from elsewhere).
Or they find out why it was fone a certain way in the first place
Getting started with compiling and build.
&gt; what language improvements over the last 10 years were necessary to make std::variant work Actually what? Does it require any language-level magic?
At the same time Java programmers ask to have this great feature. They have no feature for conditional compilation
What's wrong with posix?
&gt; when you use interface inheritance (IFoo inherits from IBase) you can't inherit the IBase implementation of a base class. You need to write forwarding implementations which is just boiler plate code. I don't get it. Virtual functions will work always on the lowest level implemented. Example pls
What is it with these deleted descriptions and users? Are mods doing this? Or is it their own doing?
&gt; comma operator Yet another ancient idea that has created way more issues than the number of lines of code it has been used in.
If you implement (or default) a copy constructor and delete the move constructor, the deleted move constructor is seen as a better match during overload resolution. And thus, compilation will fail, even though a perfectly well working copy constructor is available. As soon as you remove the explicit deletion of the move constructor it compiles as expected. Such bullshit. 
Complexity. It could be reasoned that C++ is the most complex programming language ever created.
Conditional compilation should happen at the syntactic, not lexical level. There is no C preprocessor, since it doesn't understand the C language, but a generalized text copy paster.
Part of me wishes that c++ would bite the bullet and do a python-3.0-esque move. I say this with no legacy code in c++ that predates c++11. But imagine the progress if we let pre-c++11 exist as a separate language, almost like c.
Using utf8 only in the code (wih import/export translators) helps some but the core library support is definitely poor.
We need more of those!
Yeah, you are probably right I guess
You mean something like D?
I suppose it could be rationalized that there might exist a case where you want to disallow moving but not automatically fall back to copying. With the current rules you can do that *and* you can allow the fallback (remove the explicitly deleted move ctor like you noted). However, with the "obvious" rules you wouldnt be able to express the former. Actually, forcing copies to be explicit might actually be useful in the case of very large objects....
VHDL can do it too, but I doubt anyone actually does (unless they have more than one `architecture` definition, which is also quite rare (though it shouldn't be, IMO)). Since its based on Ada, I bet that can too.
If I was forced to pick which of those to remove, it's be implicit conversions. And even then I'd ask if implicit conversions had to be marked as such (ie, we'd have an `implicit` keyword, but not an `explicit` one). Overloaded functions are just too useful when doing generic programming. 
Except `stdio.h`. Unless you also fix `iostreams` too.
I hope the manip functions get standardized after we get ranges. The arguments against standardizing them are valid, but I think ranges will go along way to solving those problems. 
Except you have to declare state which is inherently an implementation detail, so not even possible to do.
Yes, if it were possible it would be good to ditch pointers and all the old legacy C stuff. If you needed to do anything low level then it would have to be in a separate C library. That would not only make the language cleaner and more robust, it would be a massive cultural improvement, in that people wouldn’t be able to write half-assed C++.
The preprocessor understands C at least a little, doesn't it? Otherwise how does it know to skip macros inside of string literals?
Except you have to declare state which is inherently an implementation detail, so not even possible to do.
Really? Sure, it *can* cause problems, but has anyone *actually* been bitten by it?? I honestly would like to see an example of it screwing things up...
Compilation Units. When you get a problem in a large project because you have inadvertently included something twice or in the wrong order - gawd help you.
Then what's the usecase of defining a copy ctor but being unable to call it? What's the point of it then?
&gt;int_n_t : there should be a way to say "this array of N bytes should be treated as a number." Can you elaborate some more? Are you talking about having a built in "big number"? &gt;templates: can't templates be generalized by reflexion ? After all, isn't having template arguments just a way to query information on the type of the parameters that were passed to the function ? That's just one use case for templates. Another common example is something like this: template &lt;unsigned num_rows, unsigned num_columns, bool row_major = true&gt; class Matrix { ... } template &lt;unsigned num, bool columnar = true&gt; class Vector { ... } Throw in some operator overloads and you've got the start of a very powerful linear algebra library. (see Eigen3 for more)
I think `auto` and improvements to lambdas were necessary to make the visitor pattern what it is today (which is still not the pattern matching we want).
The people coding... C++ is an amazing language but too many people are using it without enough knowledge and produce crappy code. This is not a begginer's language and should be learned with coaching from an experienced programmer.
This and this. C++11 14 17, each time I'm waiting for modules, hoping it would make things simpler.
Build time. Pre compiled headers are not the standard, and building times suffer. I wish modules would solve this.
It's not the greatest fix but you can work around that and get nearly what people want... struct ivec3{x,y,z}; struct demo{ type&amp; operator[](const ivec3&amp; inds); } demo d; d[{1,2,3}]; I mean it is kinda shitty but its still at least visually closer... 
In a lot of situations code review is all done on diffs as well. You are not just reviewing the final code you are reviewing what has changed along with a description of what &amp; why from the diff message.
Its the [diamond inheritance problem](https://en.m.wikipedia.org/wiki/Multiple_inheritance). Basically, it can become ambiguous which method is expected. And when that's not ambiguous, you still have the problem of which vtable holds the function pointer. 
Ahh, indeed. But do we need then forwaring functions? Can't it be done via `using Base::func();`?
The build system. 
You can call it, you just have to be explicit about it. Could prevent accidental copies, which could be "bad" if the object is expensive to copy. 
Unfortunately, I don't know. I've been lucky enough to never have ran into the problem. 
One of the best talks at code::dive 2017!
Even correctly saying "that woman" can be bad, as Bill Clinton no doubt will confirm :)
+1
Constexpr is definitely a step in the right direction, but I really miss Lisp macros whenever I use C++.
You are linking to the TS version. The specification in the C++17 version is [massively different](http://en.cppreference.com/w/cpp/filesystem/path/append). The current model is basically "the path you'll get when you type `p` with `*this` as the starting directory".
There is nothing good about header files. If you want separation between definition and implementation you can just implement outside your class definition block. However you are going to have to deal with redundant work, each time you update methods you have to go the the definition, find the signature and change it 100% accordingly. I do not like to repeat code --at all. You can do that in header files too, hence header-only libraries exist. What you can't do, however, is stop the compiler from redundant compilation of header files.
You know something is wrong with the product when you blame the users for using it wrong.
The small window in particular makes it a useless exercise. Nothing looks good in that small a view.
I'd like to know more about this.
Re directional common sense: I think one of the characteristics of people in technology is that they tend to have a direct and unfiltered communication style where it is assumed that the **receiver** applies all necessary social filtering. For technical topics, it is commonly understood that a sender's criticism is directed at the topic (bad code etc.) so receivers don't need to apply much personal filtering at all. So life is good and efficient. For non-technical topics, it is much more ambiguous whether unfiltered communication is directed at the topic or the person. So people on the receiving end get offended, roughly proportional to their sensitivity / insecurity. In these cases, it might be a good idea for the **sender** to apply a modicum of social filtering. If the audience likes "folks" instead of "guys", so be it. It can be learned. I guess if someone would address the audience as "gals", I might experience the same mild levels of discomfort as women when hearing "guys". I still find it kinda overly sensitive to approach a speaker about it, though.
I've seen plenty of beginners accidentally throw a comma in a for loop, and I even saw it slip through a code review once. I think compiler warnings about this kind of stuff have gotten a lot better, though
From a big, big, big step back...I think the biggest weakness is that making catastrophic mistakes which are difficult to debug is easy. We learn to be careful with pointers. And even if you aren't, there are tools to help you know when and where an invalid memory access happened. But none of us know all of the undefined behavior.
Pardon my pessimism. Even if C++ adopts modules, I wonder how managing external dependencies will be. I highly doubt you will be able to add Qt5 to your project with just `packagemanager --add-lib "https://github.com/qt/qt5" ---branch="5.10"` Look at the newer generation package managers like [nimble](https://github.com/nim-lang/nimble#nimble-install), they can already do that. Never going to happen with C++. At least you are finally(!) free from writing header files.
Syntax highlighting!? Lol
Not a perfect solution though. For example, if you change the implementation of a function in your library, say to add an assert for debugging, boom, now your pch is invalid and everything has to re compile, even if 90% of the usages don't touch that function. If that function were in a cop instead, the incremental build would be super fast. There's no perfect solution right now, but personally I prefer libraries that export as done single .h and one single .cpp, then it's pretty easy to just toss it in your source directory somewhere. Of course, complex dependencies can ruin that picture pretty quick too
This is pretty much the case for all code reviews
It's extremely complex. And the standard library is very poor in functionality.
I have an intentionally toned-down (but not mono-color) [VSCode theme](https://marketplace.visualstudio.com/items?itemName=dodheim.fade-theme).
1. Slow compile times 2. Lack of a consistent ABI. If I throw an exception or allocate memory from 1 DLL, I should be able to catch or de-allocate in another DLL built with another compiler. Right now it's impossible to know for sure if my middleware DLL is going to play nicely with other people's code.
By saying that you can't have comma operators at the top level there. But `a[1,2]` for some array/pointer `a` was already valid C. Compatibility and all that...
C
[Interesting layout](https://i.imgur.com/Ra4jlPq.png) for a study concerned with understandability, presumably including readability...
At least if we change the rule (heresy, I know), there will be a proper compiler warning on account of having too many arguments all of a sudden. And I do imagine that it wouldn't bother too many people; the comma operator is pretty unusual.
This is why there was a TS. ;-]
It's difficult to learn and the payoff doesn't apply to individuals and/or small projects. You can get up and running way quicker in other languages and the disadvantages of not choosing c++ will not show for years into the lifecycle of the "output". I know some c, am subscribed because I eventually want to learn c++, but I haven't gotten very far yet. And there is all this amazing stuff you can do without it...
I can take or leave syntax highlighting as long as it's not an obnoxious color scheme. (Auto complete, now... that I hate.)
Files, and the associated mess known as "header files", as well as the ODR. Why isn't my entire program structure (all the definitions, all the namespaces, all the classes, all the functions, all the globals, etc.) stored in a database, which is visible throughout the program so we never have to worry about forward declarations, include order, extern declarations, or (and especially) parsing the same bloody thing over and over and over and over. The ODR would be gone: an entry in the database would achieve the same thing except that it would be tool-enforced at all times. Modules are a nice attempt at this, but it is clear that automatically generating such a database from header files has not been the success some of us were hoping for. Instead the database should be treated as we treat source code today, and it should be something that we maintain constantly as we program, using a special "database editor" in our IDE that lets us add or modify definitions. Compilation would be a matter of loading the database _once_, and then dealing only with the actual text of the functions themselves. I bet that would be one hell of a lot faster than anything we have today. 
Unlike what you say, the version (x &amp; 1) works for negative number. static_cast&lt;bool&gt;(-1 &amp; 1); -&gt; true static_cast&lt;bool&gt;(-2 &amp; 1); -&gt; false Concerning the compiler optimization, you are right concerning CLang and GCC, but not Visual Studio.
Agreed
Then why not try the [finished version](https://github.com/potswa/quick_decimal). I don't have a proper harness on hand, but a loop from zero to 2^32 -1 completed at an average of 34 cycles per iteration. I didn't try timing the previous paste because it was, as mentioned, incomplete. (Also paging u/mttd :) .)
In this case I need to generate types, not values, but constexpr is a freakin' godsend.
The whole system for including and linking seems really inefficient and programmer-unfriendly. There's gotta be a better way.
With my test harness, which uses random integers generated in a roughly exponential fashion as uniform(rng) &gt;&gt; (uniform(rng) &amp; 0b11111) I get 57 cycles inverse throughput vs. the article's 30 and 62 cycles latency vs. the article's 50. Using random integers generated uniformly as uniform(rng) I get 46 cycles inverse throughput vs. the article's 22 and 53 cycles latency vs. the article's 41. Throughput is measured with a carried dependency on the return value but not the output, to simulate the common case of output to a buffer. Latency is measured by making the following input to the function depend minimally on the previous output. Interestingly, you get a high IPC but have a high instruction count: 140 in the second test, which is 14 per character.
No, but it has pointers, which cannot be dereferenced if null, so if the compiler sees a null check after derefeencing the pointer, then it can remove the check. 
linkage is still a pain. headers can quickly become compile time worst enemy. and finally it's biggest strength and weakness at the same time is legacy. It's amazing that we can still support older stuff but it's dragging some stuff down. 
The preprocessor happens right after the tokenization step, but before (basically) everything else. It understands C tokens, but nothing higher-level than that.
Conan really made my job a thousand times easier. I highly recommend it.
you consider that Ocaml is a modern language ?
Thanks for the measurements! The IPC and instruction count are unsurprising. There's plenty of ILP as I described before, and the multiply by 10 compiles to a couple additions which boosts that statistic. These benchmarks are heavy on big numbers, and my code already knows exactly how many digits are in the final loop before it enters. So it looks like there's some more speed to be had in using divide-and-conquer with SIMD/scalar-SIMD as the (currently) faster solutions do. Maybe I can find more time for this later… My wife is upset that I'm "working" right now :)
C++++
&gt;Java programmers ask to have this great feature They do? That's news to this Java programmer. Most of my colleagues are blissfully unaware of the C/C++ world, including the preprocessor
It's not blaming the user. Like a lot of things, you need to be taught by people better than you so you can be as efficient as you can. Wannabe programmers are not very good with c++ because it's very powerful and you actually need to know what you're doing. 
&gt; WinAPI was supposed to fix everything wrong with posix Haha what?
It's anything but. You either have to put private members in the header (i.e. no separation of I&amp;I), or use pImpl or other such techniques that are both cumbersome at development-time, and incur runtime cost. 
&gt;It's not blaming the user. You literally opened your first comment with "The people coding"
Curious, how is C++ so powerful?
I really like the metaclasses proposal and it makes me glad that `interface` wasn't added as a keyword into the language. But I'm not to sure about adding the `&lt;=&gt;` operator as it is specified and would like it to be added just as a simple operator and it's intended behaviour to be implemented using metaclasses.
Yeah, it's so obscure people don't often get bitten by it. Still a language wart that shouldn't exist.
I doubt it would make it into `std`, but it could be part of `std2`.
Not familiar with D...was that the intent?
C++20 will have modules... we can dream, right? 
The problem is if you also have `class IBar : public IBase;` and with have multiple inheritance you will have 2 instances of it, `IFoo::IBase` and `IBar::IBase` so you have to disambiguate which `IBase::func();` you are using. Using virtual inheritance "solves" this problem at the cost of a more indirect vtable so there is a vtable for `IBase` that is referenced from the vtables of `IFoo` and `IBar`. It's arguable which is better, having a larger vtable with duplication or a smaller vtable with more indirection.
Oh my Lord this is so real, I came to c++ from rust and python which both have awesome package managers so it has made working with c++ at a more complex level kind of hard. 
&gt; use it to "reimplement" C++ from scratch I'd love to be able to use this to do some cool things such as custom defined if blocks, like this for a map class. map.if_exists(auto&amp; val : "key") { //val is set to the value in "key" } else { //val is not declared } also note the use of a `:` delimiter. Right now if I wanted something such as this I would need to use a couple lambdas and it would have the closing function and semicolon, and I would need to overload it to have an else block or not.
Poor balm in 2017.
Having new features from a fairly recent C++ standard implemented willy-nilly. You start up the latest XCode and wonder will they have your favourite C++17 bit implemented; and if they do will it take weird parameters to get it to work. Then you move your platform independent code to a new platform and wonder all over again. This is different than just the common complaint of setting up the built environment but actually wondering if you can. For instance which platforms can I get the std::Any to work without more work than is required to finish ITER?
I should be able to write a native cpp program as easy as I can write a c# program without using Qt. The closest I can find is a 17 year old version of Borland using VCL components. I want a form builder and predefined components that have properties I can change in the IDE. I can write quick applications this way. 
D does a lot 
I am becoming sold rust is the future 
With those requirements I'm going to recommend Visual Studio 6. I believe it's pretty much the only thing that ran smoothly on PCs with so little RAM. It was also fast (probably faster than the IDEs and compilers of today). The C++ version it supported was 98-ish. If you want a recommendation for a modern C++ version I'm going to suggest upping the amount of RAM.
[I'm trying](https://github.com/rodrigocfd/winlamb).
Then you click "unpleasant to review"
It's a lot easier to get a feature in when the scope is kept small. Every little addition to lambdas and structured bindings has a slew of discussion and considerations behind it. Trying to handle everything in the initial proposal makes it a lot easier for the entire thing to be left out because a small part didn't gain concensus. Look at what happened to Concepts, where particular parts blocked separate, useful parts (like `requires`) from going in. It took quite a while for it to get where it is today, with parts of it merged and the contentious parts looking at further work.
Well, if he does away with the IDE requirement, vim can probably do the trick. Even emacs if configured properly. With auto-completion and all.
Rant below That new work is being done ON the language and IN it. I work on a c++ codebase where the architect hates templates (which I view as c++'s biggest weapon), is afraid of enabling c++11 support, and is ok with makefiles that require make clean &amp;&amp; make cycles all the time. While those things annoy me and are things I'd like to fix, the syntax of this language is noise (while perl is "straight noise"), and with each new release you get to deal with the pain of half-implemented "fully baked" ideas. I still don't know what "Concepts" are. Lambda syntax is atrocious. It seems like the ideas to replace header files are still incomplete. Just lately I discovered that on a relatively recent linux distro, libc is not threadsafe unless -DLIBC_REENTRANT (or the like) is littered into every makefile. Maybe that last one isn't necessarily c++'s fault, but since it affects code that makes use of syscalls, you can't avoid it. Not to mention initializer lists, const (where tf does it go this time?), references, lvalue rvalue, all three sets of braces, copy constructors, now move constructors/semantics, a different language for macros, casting, all the new pointers. All this makes for subpar tooling support. It takes a commercial effort to provide a sane IDE (Visual Studio). I say these as c++ is the first language I learned and use for real work. ~~But lisp is truly what makes programming great again. Its older than c++ but still somehow doesn't suffer from these problems.~~ The language needs to be frozen once enough work can be done to guarantee a sane point of future ABI compatibility at which point a brand new language needs to emerge (as in, "what does it take to make it so that future runtimes have everything they need to interface with already compiled code") With the ABI fully specified, any new language can make use of existing libraries. Then we will truly be free.
i use devc++ with tdmgcc5.1, it runs good, but afterall it doesnot have autocomplete
Of course, on the other hand, the question can be put also: here's a nickel kid and go get yourself a real computer. To just have such requirements from IDEs and compilers, when (for more RAM and CPU) the offer so much it is not reasonable.
I find it useful for abusing in single statements situations. 
My RAM: 2Gb processor: AMD 1.65Ghz Anyways, i still use dev-c++, it runs good for my extent of C++ knowledge( high school level). Anyways to add autocomplete to it? 
I think they're working on it.
Turbo C++ 3.0
Lol....😂😂😂😂
I don't really see an inherent problem with that unless you are trying to prevent exposing your internal libraries to the outside world (trying to not include the world). If you need to do that you can use PIMPL. It's also very possible I'm too stuck in the C++ world to know of a better solution.
I'm starting to disable syntax highlighting more and more
Visual Studio Code is probably your best bet with the C++ plugin, install Clang or GCC as your compiler and you're golden.
They also mention that you should avoid writing projects that make this necessary in the first place. The best encoding for numbers is binary if you don't need an human to look at it.
The lack of a standard, stable ABI, and implicit pass by reference syntax in function calls. Especially the ABI though, it actually discouraged me from choosing C++ for my next library. 
CMake is what I use to diminish that issue.
Right, but that shouldn't be necessity in the first place. It is often a half baked non-solution to some other language limitation.
I strictly write header only code and my compile times have increased substantially compared to having each header file have its own translation unit. Every application consists of one single translation unit, `main.cpp`. In the past I would have say X translation units, and if I made a change to one single header file common to all translation units then that would require recompiling all X translation units. Now, I can make any change I want and it just requires rebuilding `main.cpp`. And with the use of precompiled headers it's basically a no-brainer.
What about protocolbuffers? Flatbuffers?
Most of the time, it makes for the fastest and most efficient code. It's usually the de facto language for real time applications. 
does gcc have an up to date implementation?
gotcha. I missed that because the gcc implementation of this library wasn't adding the separator properly and nothing else in that list was explaining why. I guess maybe gcc's implementation is non-conforming? Or atleast the implementation I have. regardless, I'm just going to keep my utility functions that way I don't have to deal with it.
Yes, and I can ask you if you've seen stupid code in your life, in any language and your answer would be yes. But you wouldn't blame the language for it. My point is that c++ is a broad language with a lot of control over the hardware, which if manipulated incorrectly would make shitty code.
Unicode is bad in all languages...
D is more about expressiveness than being close to bare metal. For example, garbage collection is technically optional but the D standard library uses it so not really.
Inline is a compiler suggestion, not a certainty.
alignment, hand-crafted alignment
qtcreator
Off-topic for the cpp subreddit. Please consider another subreddit.
Um... yes, but what does that have to do with anything?
Are you stupid? If you don't know how to use something and you're too stupid to learn how to use it correctly, then don't blame the product. Fucking tool
Guy commented about separation of inline declaration, but inline is useless. Compiler will inline what's useful...
It’s not useless, it’s a suggestion. And if you don’t put the definition in the header file like we’re talking about here, it won’t get inlined at all (outside of the source file it’s implemented in). 
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7lzawf/which_is_the_best_c_ide_and_compiler/drqd1ka/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Slow compile time 
You should check [`build2`](https://build2.org) and [cppget.org](https://cppget.org). It is still work in progress and the number of packages is small (but there is more in [staging](https://stage.build2.org)) but if you want to see what it will feel like to use together with C++ modules, check this [lightning talk]https://www.youtube.com/watch?v=PxFrhYAYF3M) from CppCon 2017.
Not only that, but getting the whole c++ community gravitating towards one build system is like herding cats.
Aren't there some metaprogramming techniques that turn type problems into value problems? I think Boost.Hana takes it to the nth degree for clarity and compile speed.
What are modules?
I see nothing wrong with sticking to C compatible C++. To call this type of programming half-assed is extremely ignorant. Linus Torvalds shares a similar view (see lkml rant), and he might be one of the most influential computer programmers to ever live.
Cargo is simply amazing. Rust has some a great job. C++ language developers seem like they can conquer a lot. I wouldn't put it past them to come up with a great solution.
Not sure if you are serious, but in case you are, first half of this CppCon 2017 [talk](https://youtu.be/E8EbDcLQAoc) is a practical introduction to C++ Modules TS.
&gt; It's a lot easier to get a feature in when the scope is kept small. And I think that it's a bad calculation. An overarching goal should be to make the language itself smaller and more general, not to add droves of special cases.
yes, that's the kind of thing that would be cool to do :p 
Completely serious. Thanks. I'll watch this in the morning!
I know, I'm not sure how I could implement that, if I could figure it out I'd look into writing a proposal for it. I feel this example alone would be a weak, but justified rational for it, so I'd look for a more general approach before I'd feel confident.
OOP
If you care about speed, you can still replace the cast to boolean with an actual comparison to get a truth-value, right? Plus if you want to code to be as expressive as possible: a) You are not modifying the argument, add `const`. b) You never throw an exception, mark the function `noexcept`. Hence: constexpr bool IsOdd( const int x ) noexcept { return ( x &amp; 1 ) == 1; } 
argumentum ad verecundiam
The ability to attract “general public”? I c++ always has it’s profile setup for high-end users and it sometimes formidable for new programmers. Although efforts have been made to make c++ seem to be more user friendly, it’s complexity can never be changed.
It's break the evolution
This is highly a windows problem though. Linux has it much simpler, given the package management and things like makefiles.
My favorite description of C++: C++ is like making an octopus by stitching extra legs to a dog.
It's much worse on Windows, but it's still a big problem on Linux/Unix systems. 
Nope. I thought this, too, but it doesn't work.
Sounds interesting, I'll look that up. But "ATL style" also sounds like something that isn't good to the eye :)
++C
Conan is nice but as most community-managed package managers it relies on the package recipe author's work. You might find it an even greater pain if the recipe didn't handle all the options/system configurations you're going to need (and you might have to fix it yourself).
Why do you think it's useless? I also hate this tendency now to soften up the definition of an interface just for the sake of not breaking existing code. But this doesn't make the concept of an interface useless. Even MS implemented a special "__interface" keyword for their COM-Stuff. Go does it nicely with implicitly implementing interfaces.
I find it so trivial. Two steps, compile file then link. You can do it by hand, you can build you own build system and there are several flavours of doing it - pick your favorite. 
I know this proposal and I partially like it. But I don't want to implement my own interface keyword, there should be one defined in the language (or at least in the STL).
This!
This has even less point. Better just standarize designators for current STL than make a second one
I want to write "pip install module_name" in c++
The ideas brought forward by Rust are the future. C++ is implementing them.
What exactly is the difference between those rules and the final rule on a unix/linux system? An example that is, where the two are different. Because I don't see one.
In no particular order: 1) header files. While it's cool to be able to write a compile-time interface and then select the appropriate implementation file, it certainly slows down compilation incredibly, and it is quite difficult and time-consuming to hand-craft the code in such a way that it doesn't make compilation slow. C++ compilers should cache all header compilations by default, as an intermediate cure until modules come. 2) lots of things missing from the standard library, including string manipulation routines, networking (which is actually a standard), serialization, event management etc. Thank god we have boost. 3) lack of compile-time introspection of structures/stack frames. This is so useful not only for serialization but also for writing a quality precise tracing garbage collector, which most big c++ apps could easily afford. Smart pointers are nice, but they also require more attention than gc, in order to avoid reference cycles, and also have quite a performance penalty over a gc. 4) lack of api for dll management. Yes, boost has it, thank you again boost. 5) that the language puts performance first, safety second. For example, variables should be initialized by default unless explicitly set to not be so, array bounds should be checked by default unless explicitly set to not be so, classes should have virtual destructors unless set to not be so etc. 6) the wrong defaults extend to copy-move constructors-assignment operators. Why should a class that has raw pointers not have copy-move constructors/assignment operators deleted by default? it should be that pointers should explicitly be copied/moved. There probably may be more, but I am off to the Christmas table for now. Merry Christmas to every one!
Rust sacrifices much abilities in the compile-time metaprogramming department, though.
I think it would be awesome to have a C++ parser and lexer as part of the standard library; that would allow any compliant standard implementation to parse C++ on its own
The old Borland is called Rad Studio, and it's very easy to make GUI aps with it, especially with some of the TMS third party components.
Another option that uses comma operator: https://godbolt.org/g/DxNE5m int main() { N_dim_array&lt;5, 7&gt; arr; arr[3_i, 2_j] = 4; return arr[3_i, 2_j]; } 
STL sucks. They give us the power to control every little detail, but they forget to give us easy short functions for the functionality that is used 99% of the time.
Ah, the C++ apologists, get triggered so easily. It matters not how [defective](https://yosefk.com/c++fqa/defective.html) it is, these people will always keep blaming the users. C++ is programming language, [not a religious cult that you have to defend with the cost of your life](https://yosefk.com/c++fqa/picture.html).
Pardon me if I'm wrong, but you seem to be appreciating GCC more than the language itself here, and if implementation performance is your tool to measure power, I doubt idiomatic C++ is any faster than C99. 
It's not like it's necessary, but it can allow you to type less code because no need for extra brackets. Though I guess that now since we have lambdas, there's probably no need for the comma operator there either.
`std` won't be changed in a significant way that could break too much existing code. `std2` is there to allow major breaking changes to make the design superior. For example, it's too late to use signed integers for `size_t`, but `std2` could use them because it doesn't have to conform to the existing API.
Inline is absolutely not useless. a.h: inline void stuff() { } a.cpp #include "a.h" b.cpp #include "a.h" here inline is the difference between "software compiles" and "software does not compile"
&gt; Interfaces shouldn't be changing anyway, I envy people living in fantasy magical unicorn land like you :p 
Build pipeline and standard library. The next one is need for sfinae abuse but the `requires` superseeds it