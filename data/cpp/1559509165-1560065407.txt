I kind of agree with you, but the question is who would do it? The C++ committee is a group of volunteers who work on what they/their employer want(s). It's a fact nothing happens without somebody writing a paper, which I already learned can take quite a bit of time. I've had a lot of positive feedback and suggestions on my initial proposal, for example by [u/jwakely](https://old.reddit.com/user/jwakely). These people like the proposal to move forward, but fixing this specific issue is not the highest on their priority list. So I think if we as C++ developers like to have a better C++ standard we should try to be more active and give our constructive feedback when proposal are being proposed instead of after they are accepted. &amp;#x200B; Fixing issues can be more difficult than it seems. I thought I had a rather sound proposal until u/-abigail pointed out a list&lt;char&gt; could be used as input for a regex. Something I personally would find very odd to do, but it is valid. Until I have a solution for this issue I think my proposal has a no chance to be accepted by the committee since parts of my changes would cause valid code to become undefined behaviour. (Not that I would even try to propose the current version, now that I am aware of this issue.
So a serious bug then, not an optimisation issue.. I've never had the necessity to force inline but I'm interested in this bug though. Keep me updated if you want to!
But how much undefined behavior scenarios do these things have and how likely is a less experience developer to understand and avoid them?
Thanks also for your feedback on the initial version. I hope to have a final version soon, but I first need to find a solution for the list&lt;char&gt; issue u/-abigail pointed out.
Nice one Like the podcast as a casual c++ coder (occasional work-related projects). My last full-time C++ was not pleasant, but it was the era of early 00's
`volatile` doesn't ensure that the write ever makes it to other CPUs. Just use `&lt;atomic&gt;` and do it right in the first place.
THIS
Right, that's exactly how you should ask for the length of the native representation. Adding a new member function called something like "native_length()" which just returns that doesn't seem like a good use of anybody's time.
Yup. `volatile` makes no guarantees about consistency between different views of the abstract machine (threads). To be fair, atomics *also* use `volatile`, generally, but they *also* make stronger guarantees in regards to barriers and making sure that writes get propagated. `volatile` has a specific use-case (one that I use quite a bit in OS development and in MCU work). It just doesn't cover all the requirements for multithreading. `volatile` basically states that the value is the given variable is outside of the purview of the abstract machine. It doesn't provide any strict guarantees about memory barriers, making sure writes are propagated, and such. It just basically says that 'reads and writes must actually happen'.
The write will be visible to other cores; the problem is "when" it is visible not "if" it will be written (the write is guaranteed). std::atomic is more about how compiler is allowed to re-arrange code around access to the variable and guarantees that the order will hold when the code is executed by the microarchitecture; for example, x86 can lock the bus with a "bus lock" prefix that holds execution until the value has propagated. This makes atomic memory access "less efficient" than non-atomic which is unrestricted and can fetch whatever value is currently visible to that core.
Only having the conversion to string_view for sub_match&lt;T*&gt; and sub_match specialisations with basic_string and basic_string_view iterators seems acceptable to me. The thing I'm most interested in is being able to compare a sub_match to a string_view, which doesn't require contiguous iterators. By the way, adding a new typedef to regex_traits seems like a bad idea. Any custom regex traits classes become invalidated by that change because they can no longer meet the requirements to be used with std::basic_regex. I suggest not adding it to the traits, and just define it unconditionally as basic_string_view&lt;value_type&gt;. It doesn't seem helpful to allow traits to define custom string view types.
Awesome! It would also be nice to check if there are improvements with exponential backoff (suggested by the Intel optimization manual too, example 2-2) see https://github.com/GameTechDev/GTS-GamesTaskScheduler/blob/master/source/gts/include/gts/platform/Thread.h#L235 for implementation helper
Try out Allegro 2D. It is a great 2D graphics library. https://liballeg.org/
constexpr is a semantic thing. It indicates to the compiler that an expression can be used where a compile time constant is required. E.g. if you have an integer template parameter, you can only use a constexpr function there. The language rules are such that a non-constexpr functions' return couldn't be used there. But optimization proceeds regardless of language rules. Compilers will happily propagate information known at compile time as far as possible, whether or not it is constexpr. e.g.: https://gcc.godbolt.org/z/AKFv6s. And conversely, constexpr doesn't *guarantee* compile time evaluation. It just means that the expression is usable where a constant expression is required. There are some cases where it may help a bit with optimization, and of course it can help you leverage more templates more easily which can improve performance. But generally it's not a huge thing performance wise. The biggest example of constexpr impacting performance reliably I know of is probably not what you would expect; it's actually static locals. constexpr constructor (and arguments) is the requirement to do static initialization. Without this, you initialize the first time control passes through, so you need a thread safe guard variable, etc.
&gt; The write will be visible to other cores; the problem is "when" it is visible not "if" it will be written (the write is guaranteed). Citation needed. The standard says something like "should do it in a reasonable amount of time", but doesn't put any strict requirement.
A new programmer can completely avoid silent undefined behavior with the right compile flags.
Need a `this_type` or `self_type` as well. Also, I want a `return_type`.
https://meta.wikimedia.org/wiki/Cunningham%27s_Law
It seems WinUI is alive, but I'd bet against UWP. Even the roadmap you linked says \&gt; WinUI 3 will greatly expand the scope of WinUI to include the full UI platform, which will now be fully decoupled from the UWP SDK If Win32 is supposed to die then it doesn't make sense to backport WinUI for Win32, but they do, so they probably also are aware that UWP is not going to work out.
It is, but it's more of an application framework than a 2D graphics library.
You may find [\[P0847\]](https://wg21.link/P0847) to be quite interesting. It enables this and more.
http://isvolatileusefulwiththreads.in/cplusplus/ has some links to explanations. As o11c said, instead of trying to find a case where it might work, sort of, maybe, sometimes, just use atomics to do it right in the first place.
Thanks for this. It is a small consolation to me at least that even if I stirred the soup the wrong way with my comment I at least have learnt something new today! Thanks again.
I have the same experience. Inline the tiny bottleneck functions that show up in your callgraphs.
Thank you. Looks really interesting, but from a perspective of teaching the language to new programmers add self would be much easier than explicitly passing it as a first parameter to the method.
I don't see this being added, because \*this does the job, and they HATE adding new keywords (even if it's not reserved, how do you deal with member variables named 'self'?) &amp;#x200B; &gt;You can not assign to self . this has a special rule that makes it a prvalue, but self does not need any exceptions because references are not assignable. isn't 'this' of type (possibly const/volatile) T\* const, so it \_can't\_ be assigned to?
Also, see the silly dance I had to do in std::deque to cope with the old requirements, which was removed by this patch: https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=0cde8d2e7e33a0bc0c0056d3b62adf82e95d6ce3 That is not necessary now that the standard says you can't change your allocator's state after move. It would also be unnecessary if containers copied allocators and never moved them, but the spec has said that allocators get moved since C++11. All that's really needed is that they propagate correctly, which I think could be done via copies instead of moves.
Git and vscode handle multiple git repositories if you use git sub modules.
I think that is an implementation detail because \`this\` is specifically mentioned as a prvalue in the C++11 standard.
&gt;volatile doesn't ensure that the write ever makes it to other CPUs. Can you back that one up? &gt;Access to volatile objects are evaluated strictly according to the rules of the abstract machine. &gt;[intro.abstract] &gt;Reading an object designated by a volatile glvalue (8.2.1), modifying an object, calling a library I/O function, or calling a function that does any of those operations are all side effects, which are changes in the state of the execution environment. &gt;[basic.exec] [intro.execution] &gt;Just use &lt;atomic&gt; and do it right in the first place. I should have been clearer: This question is not about whether one should default to using `std::atomic` (one should). **This question is whether there is 1 legal use-case for `volatile` outside the realm of hardware access.**
Was there an error in what I wrote? It's as valid information as I have.. please do point the error and everyone benefits. I can think of only one special case: register write.. but that is not C++ standard related so didn't think would apply here so didn't mention it.
Qt's widgets are built on top of the QPainter/QPaintDevice subsystem which is a fairly comprehensive (and pretty nice) 2D drawing/painting framework.
You can't assign to a prvalue pointer.
SFML does what it says on the tin and is reasonably popular. The only other one I would bother evaluating is Qt.
&gt;Does that mean stateful allocators effectively can't be moved in C++20 and have to be copied instead? It effectively means that moving an allocator just be equivalent to copying it. In theory you could still move state that does not participate in equality comparisons, because the requirement is only that a moved allocator still compares equal to the same things. For example, an allocator with a per-object freelist could transfer the freelist when moved, as long as the freelist doesn't affect equality. But in practice, for most allocators, it means moving should be equivalent to copying (and so you might not want a move constructor at all).
No. &gt; `self` does not need any exceptions because references are not assignable. No? You would need a rule to disallow `self = {};` for example. Also how is that an advantage? &gt; `this` is a special pointer that must point to a valid object however other pointers are not required to do so. No that's wrong. Every pointer must point to a valid object. References have the same dangling problem if you're referring to that. &gt; `return self` instead of `return *this` from assignment operators looks cleaner I don't agree but fine. &gt; Using raw pointers in C++ is usually discouraged No, *owning* raw pointers are discouraged. Nothing wrong with using pointers.
Oh, thank for pointing that out. I changed the wording to "You can not change the pointer of \`self\`". Maybe you can suggest a better wording?
Edit: also, don't assume this only applies when compiling in C++20 mode. Both libstdc++ and libc++ apply defect resolutions like this unconditionally, for all modes. For libstdc++ in particular, we've already removed the code that was there to cope with allocators that changed after a move. That code is gone, even if you compile with -std=c++11.
Well signal handlers are a thing too. The standard only requires `volatile sigatomic_t` to work, but most implementations extend that to all register-or-smaller types, and there are a lot of programs that rely on that so future implementations are likely to do the same (but beware, `volatile int64_t` is not safe for signal handlers on 32-bit platforms). But other than those 2 cases, there is *no* use of volatile. 4.7.1 lays this out pretty clearly.
as far as i remember, on microcontrollers volatile makes sure that the value of the variable can be changed in an interrupt handler without having the problem that a function could use a cached value
When I try to loop through the variant, all element's address are changed. I have researched it. It looks like the variant's own issue.
References would probably have been more appropriate, but I think that the cost of changing this now outweighs the benefits of self over this.
Yes - outside of the purview of the abstract machine - ergo, the program cannot make assumptions about a `volatile`'s value or assignment.
 decltype(this) decltype(someFunc()) I think these two lines do what you’re looking for.
Ok, now give me a way to use the former in static contexts, and the latter in function - ambiguous contexts like macros so the arguments don't have to be manually propogated.
What do you mean? decltype isn’t a runtime operation; it’s similar to sizeof in that it gives information at compile-time. Not sure what you mean again. Are you saying you want it to deduce what overload to use without supplementing the arguments to the function?
Start with a flat array of strings in a single tu. Then have an array of pointers to strings in the original array. The entries of this array are sorted per tu in the entire project. Then have an array of pointers into this array. This is because the same string can be referenced in a single tu many times.
There is no `this` in a static method or class member assignment. Ergo, `decltype(this)` cannot be used in those contexts. class foo { decltype(this) *ptr_to_other = nullptr; static int bar() { return decltype(this)::static_member; } ... };
Oh also I should mention that string pooling used different mechanisms. Some implementations of compilers are more aggressive about coalescing partial substrings and again you have to be careful if your program relies on address stability. Unless you really know your optimization flags for all compilers and all build targets, I’m going to say relying on any specific behavior from a given compiler is untenable.
There is no `this` in a static method or class member assignment. Ergo, `decltype(this)` cannot be used in those contexts. class foo { decltype(this) *ptr_to_other = nullptr; static int bar() { return decltype(this)::static_member; } ... }; Neither of those will compile. I have no idea why you brought up runtime operations. &gt; Not sure what you mean again. Are you saying you want it to deduce what overload to use without supplementing the arguments to the function? Correct. Within a function, it is already known to the compiler what the provided argument types are. It is redundant to have to supply them *again* to derive the function's return type, and not always practical, particularly if you're using macros to try to handle automatic logging or tracing.
Ahh, I see. I was thinking you maybe had a size field or something, when I'm just using a null terminated array of pointers to null terminated strings.
I now see what you mean, and I agree both are unideal situations.
Ah yea for string literals embedded nulls aren’t a problem so often sizes and stuff get optimized in at compile time and you don’t need to incur the memory overhead.
There's nothing stopping you from using modern C++ atop the Raylib API. It's definitely the most fun graphics lib for C or C++ around. Other great graphics libraries like bgfx, Magnum, or nanovg are also good but aren't really aiming for that "toolkit to play around with" angle like I assume you get with your javascript stuff.
This seems like an "it would be nice" proposal at best. And it's talking as if it makes the language simpler. But note that the old "this" still has to be available so now you have two mechanisms that you will have to teach people. Imo this would be a complication of the language itself that doesn't solve any real problems. I'm not a fan
In your example the issue is that you assume both thread are eventually going to see the update of the other. It might not happen. However, there is a multi-threading application to volatile: using custom hardware register to send signals through dedicated communication channels. Typically, let's say you have a special register in which writing actually push in a FIFO, and reading is forbidden. And on the other side, reading pop from a FIFO and writing is forbidden. Atomic won't guarantee your writes or reads are not collapsed into fewer ones, that's going to create an issue. And this is an ultra light and ultra high bandwidth IPC. But this is indeed completely hardware dependant. You might still want atomic volatiles to synchronize the rest of the code with regard to those accesses.
I assume what OP meant is the calling syntax, although the implicit conversion to the result type is fragile.
I think you're better off just refactoring the function into helper functions and classes with longFunc itself just calling those rather than trying to use such tricks. `auto` wouldn't work, like others pointed out, but function pointers and std::function would probably break too.
FLTK is 2D I think.
Yup
I'm 99% sure all you're actually looking for is this: `typedef self this;`
I’ve been using SFML for a few years now and I highly recommend it. The API is very polished and easy to work with, the documentation is great, and there’s a good community with lots of resources out there.
Nope
Any 32-bit operation on the registers will zero out the top 32 bits. AMD got it right there, too bad Intel didn't do the same thing for the top 16 bits of the 32 bit register, which currently makes 16 bit loads pretty much useless.
How is this better than changing it to: Result longFunc(Arg1T arg1, Arg2T arg) { return longFuncImpl( arg1, arg2 ); } private: Result longFuncImpl(Arg1T arg1, Arg2T arg) { //... }
You cannot change the pointer of `this` either. The distinction you're making doesn't exist.
No, typedef is used for types, not keywords.
See http://www.drdobbs.com/parallel/volatile-vs-volatile/212701484
And in circumstances where the documentation isn't very detailed, the code itself is nice and clean to read, and easy to disambiguate. I like that it intelligently uses OOP as a tool, but doesn't build up huge trees of classes. I've done a few things a little more off the beaten track, and they still weren't hard to figure out. There were a couple projects where I wanted to generate my own waveforms, and either stream them in as generated, or store them in a buffer and play back on repeat. SFML put a nice interface on top of my audio generation code.
Agreed. Borland really messed it up.
The diagram in the thumbnail is hilarious. Adding reflection and metaclasses is going to manually reduce how much students have to learn? Only if they're starting a new code base from scratch and not using any libraries. Otherwise you need it all.
Got something: https://github.com/tringi/x32-abi-windows
&gt;Using raw pointers in C++ is usually discouraged (references are preferred). this could encourage programmers to use pointers instead of references. Using _owning_ raw pointers is discouraged. "Viewing" pointers are perfectly fine, and often the right tool to use (e.g. whenever you need to rebind the thing you're looking at). The semantics of `this` make it a lot closer to a "viewing" pointer than an "owning" pointer, e.g., you should never have to write something like "delete this", which is almost (always?) universally a bad idea anyway. So IMO `this` is fine.
I sympathize. I, too, want to make CMake easier to learn and use for beginners (like me). I think a tool like this is the wrong approach, for a few reasons: - If a newcomer adopts xmake because it's easier, then outgrows the capabilities of xmake and has to switch to CMake, or if they start working on another project that is using CMake (there are many), did xmake get them any closer to learning CMake? - There is a cost to switching tools. CMake is the de facto standard right now, and a new tool needs to demonstrate a major advantage to justify the switching cost. Does xmake offer enough? Maybe it does, but I don't think this article demonstrates it. My preferred approach is to make CMake better. The good news is that they've demonstrated a willingness to introduce new ways of doing things and to deprecate and remove old ways.
I'm still curious if the PreferredToolArchitecture=arm64 that I've add to environment variables on my Snapdragon laptop will actually make a difference.
&gt; My preferred approach is to make CMake better. The good news is that they've demonstrated a willingness to introduce new ways of doing things and to deprecate and remove old ways. Absolutely. CMake has changed so much that if you follow an old tutorial or an old Stackoverflow post you're in for a load of hurt. It's like comparing C to C++. For everything else there is Meson and Bazel.
`volatile` is competely useless for multithreading from a purist, ivory tower point of view, in which the C++ abstract machine is all there is. But then again, there are no language-level constructs in C++ which are useful for multithreading from this point of view either. You cannot write safe, well-defined multithreaded code in C++ without using implementation-specific extensions, or STL libraries. `&lt;atomic&gt;`, `&lt;mutex&gt;` etc. do provide standard, portable means of writing multithreaded code in C++ at the library level. However, those headers themselves cannot actually be written in standard C++. If you want to write your own synchronization primitives, you'll probably find you'll need `volatile`, *in addition to implementation-specific features* (memory barrier intrinsics etc.). Whether anyone should actually bother implementing their own synchronization primitives is another question...
If you're functions are so long you need to break it down in weird ways, maybe it's time to refactor them into reusable code.
This. There's no need for this kind of hack if you produce clean, reusable code.
So if I use `volatile` because I want to write to a memory mapped device, ...it might never actually get written there?
These days, memory-mapped I/O goes through a *much* different path (ignoring caches, etc) than RAM accesses.
changed from *what*?
Yes, when you have a volatile variable.
Fine. `#define self this`
You can also run \`xmake project -k cmakelists\` to convert xmake.lua to cmakelists.txt.
With all the wisdom of c++ experts teaching how to write "strongly typed" code the way CMake uses strings for everything baffles me. CMake has a strong argument for having its own scripting language but in reality this only applies to a tiny microcosm of cases where using existing scripting tools is unacceptable. At any rate I think the problem lies beyond the language used and revolves around the underlying model. Would it not be possible to design a schema ( like an XML schema ) for a meta build system? Then the actual scripts / tools / magic black box used to declare, compile, run, update, integrate with ides etc would not matter so much? I use CMake for many things besides actually compiling i.e. generating visual studio or eclipse projects for debugging, dependency and include analysis, automating code gen and test tasks and packaging projects. It presents a model of the program deployment, dependencies, compilation steps from which these tasks can be implemented. The model is the key not the implementation, someone just needs to extract the model into an XML schema or other portable type system and then it could even be specified as a recommended approach perhaps?
I haven't minded them before, but the May 23rd episode had me skipping several minutes.
CMake is good and all but it’s far from perfect. I see this programatic way to describe projects to be quite good, at least it’s elegantly extendable.
Computer Architecture, but u gonna learn that in your college anyway
&gt; Using raw pointers in C++ is usually discouraged No it's not. This perception pisses me off so much.
That's still not doing what the proposal says.
True, through supported by all major compilers using vendor-specific extensions (`__restrict` is supported by GCC, Clang, and MSVC). I suppose you can also "emulate" `restrict` in C by wrapping your pointer targets in incompatible, distinct types. ``` void foo(Restrict&lt;char, 1&gt;* a, Restrict&lt;char, 2&gt;* b) { // convert a and b to char* // 1 and 2 are just tags causing the compiler to generate // incompatible instantiations of the Restrict utility class. } ``` But yeah, don't do that. :-)
I am using a big "mother" linked list to store different types of a linked list. When I try to loop the mother link list and loop its linked list, all address of linked lists is changed. Or you can call they are changed to variant type, so it has a new address. How it is still changed.
Gaming isn't necessarily the shallow end of the pool to be learning to swim. It might be worth doing some easier bits first. That way you can plow through them and not get precious about them. That'll let you learn more faster in the beginning and move on. Assume you are going to do things wrong at first, so don't put in a huge amount of time building a cathedral of wrongness at this point probably.
I once encountered a bug in some code where someone had (unintentionally) done exactly that... they had a zero-size derived class, and a function that took a base class (array) pointer and a derived class (array) pointer and a length, and filtered the contents of the derived array. There was an aliased use case that had some... interesting problems. It was a horrific piece of code to begin with, but when I realized what had actually happened...
Are you working on c++ again?
Don’t change the podcast format Rob, the balance is perfect. Your guests always get a chance to talk fully about their subject matter and I love how you get them involved in the news articles to give a point of view. Keep up the good work.
I think it's important to understand that the C++ Standard Library is actually part of the standard. You can implement `std::atomic` using non-portable compiler intrinsics, or inline assembly, and yes, `volatile`, but there isn't any reason to do so - any conforming C++ compiler must provide `std::atomic` etc. The C++ language without the standard library also doesn't support any memory allocation routines, or file I/O, etc. In practice, C++ is inseparable from its standard library.
Very true. It depends on context. A general function like `stoi` may be used in contexts where every string really is a valid integer almost all the time, or it may be used in contexts where you are validating user input over a network protocol (so throwing an exception is a DoS attack vector). Generic error handling, adaptable to all use cases, is an unsolved problem in library code.
I like Sublime Text 3 + makefile + LSP + clangd + clang-tidy + SublimGDB + vaarious other plugins. Or tmux + nvim + gdb + makefile + clang stuff.
Having a declarative build system is desirable, but there is a reason why all build systems implement imperative constructs. Builds are complicated, C++ builds are especially so. Most moderately complex projects end up needing those constructs, Translating those to e.g. XML doesn’t remove the complexity, just makes it way uglier. If your build is simple, it will be simple to express is CMake as well.
Sure, but that misses the point of OP's question. I don't think 99.999% of C++ programmers should ever be using `volatile` for anything to do with multithreading, but I do think there's a tendency to completely shut down discussion of what it actually means in favor of telling people who ask about it to just use `std::atomic`.
Yeah, absolutely. The explanation [here](https://en.cppreference.com/w/cpp/language/cv) is very good, though, and should answer basically all questions. :-)
Skia is great but you have to face a constantly changing API, yet another buildsystem (damnit Google, please use CMake), and other quirks like having to build it with clang-cl for best performance on Windows.
Google tries this with Gyp, and it was rather ugly. The replacement, GN, uses an imperative syntax but with a non-Turing-complete DSL so you still get some backend flexibility. Meson does something similar.
&gt;only if bytes are 8 bit This is the wrong sort of qualifier to be adding when explaining pointer size to a newcomer.
Try your hand in OpenGL, Vulkan( really difficult to learn and write but fast), Direct3D among others.
I normally see open source codebases and it seems like Meson is becoming very popular. I use it on all my projects as well. Is it just confirmation bias?
&gt; My preferred approach is to make CMake better. The good news is that they've demonstrated a willingness to introduce new ways of doing things and to deprecate and remove old ways. this is not in tension with the development/adoption of xmake. to the extent that xmake implements a subset of cmake functionality, interoperability between them is straightforward.
Most open source software still uses autotools or cmake (cmake mostly for C++), but Meson made the smart choice of lobbying to get adopted by GNOME, so the rest of the “free desktop” stack is following suit.
In a practical sense, this behaves the same whether the \`volatile\` qualifier is added or not. That might just be luck, but presumably the compiler is not allowed to start optimising out the \`cin\` and \`cout\` calls because they have side-effects. &amp;#x200B; In regard to atomicity, you don't have a problem here because one thread writes a set value and the other one only reads, and a bool is a single word that the CPU can write at once. \`volatile\` would not save you if you had multiple threads performing dependent writes and reads (e.g. increments) or had a complex structure that required multiple CPU operations to update (e.g. a vector).
I’m into SFML for c++ as it’s a library for 2d animation graphics, audio, and even networking. I too had to understand oop, syntaxes, and the dreaded pointers and how memory allocation works. I’m coming from full stack web development so this was a very interesting study. What I do now is port JavaScript html5 canvas animations to SFML c++. But start from there and then move on to Unity / c#. That is my next goal!
I would do nothing with basic enums. The class enums, however, it would be very nice if the "enum switch" tag ensured I could be using them as if a namespace is used. "switch(color) { case Color::Red:" is sufficiently wordy when colors are important that "enum switch(color) { case Red:" would be nice. That said, "default" should be kept since doing nothing for some input is such a common use-case.
For me I wouldn't use any build system xml based...
X language is faster (mostly java and C people like to say), and that the compiler can always compile your code flawlessly.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bw7z2g/please_help_me_choose_a_c_book/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
A reference to a derefferenced this?
Flexible Array Members are far more likely to be an issue that VLAs. VLAs are hardly ever used, but FAM are used all the time.
WinUI uses UWP, they are the one and the same. They aren't backporting WinUI to Win32, they are making UWP APIs available outside the store sandbox. It is still the same set of API that got introduced with Windows 8 and are continuously being improved. Bare bones Win32 has hardly improved since Window 7.
Don't most compilers disable inlining in debug mode for that reason? E.g. to still be able to create a full stack trace.
Yep, I meant it can be a way to explain why it's considered bad to inline the function in debug.
&gt; xmake &gt; &gt; target("test") set_kind("binary") &gt; add_files("src/main.c") &gt; &gt; cmake &gt; &gt; add_executable(test "") &gt; target_sources(test PRIVATE src/main.c) more likely: add_executable(test src/main.c) I like the fact that xmake can use globbing expression directly in `add_files` though. Most important for me though: 1) Is there any integration for IDEs (I.e. can I get code completion when using qtcreator, VSCode or similar? 2) What it's the advantage compared to other modern build tools (e.g. meson, build2)? Its not like we don't already have tools that are (at least arguably) better than cmake.
In theory [a.k.a as far as iso standard is concerned), accessing a non-atomic variable from two threads without a synchronization and if at least one of them is a write, you have UB at your hand. End of story. In practice, this has worked for decades, will likely continue to work for quite some time to come and you actually have a decent chance that your toolchain deliberately supports this. The question that remains is: Why would you use it, if atomics provide you with a much cleaner way to accomplish the same.
Cairo is pretty good.
The address of the object inside the variant will of course be different from the address of the object that you assigned to the variant, because they are different objects. If you want the variant to refer to the original object you could instead store pointers in the variant (but make sure they don't end up dangling).
Looks like the lambda isn't vectorized like the other for loop. Further analysis showed that it has to do with \`cnt\` and \`g\` getting captured vs pass-by-value. [https://godbolt.org/z/bM\_XA4](https://godbolt.org/z/bM_XA4)
Makes sense. Thanks for looking into it.
Pretty much, yes. There is no question, that - everything else being equal - having smaller pointers is beneficial for performance, but between the 32 and 64 bit versions not everything else is equal (different instruction set, different ABI, different security mechanisms, different amounts of address space available and genuinely different code paths). So for a concrete app, the only perf argument I'm willing to accept are actual benchmarks that show " The 32 bit version of the toolchain compiled this set of projects X% faster/slower on average and Y% in extreme cases (maybe even with the opposite direction).
I have no idea, how it would makes sense, yet.
&gt; add_executable(test src/main.c) We can also write `target("test", {kind = "binary", files = "src/main.c"})` &gt; Is there any integration for IDEs (I.e. can I get code completion when using qtcreator, VSCode or similar? There are xmake-vscode, xmake-sublime, xmake-idea (idea,clion,android studio) and xmake-vim IDE plugins. &gt; What it's the advantage compared to other modern build tools (e.g. meson, build2)? Its not like we don't already have tools that are (at least arguably) better than cmake. xmake has the builtin remote package manager and repository. ```lua add_requires("libuv master", "ffmpeg", "zlib 1.20.*") add_requires("tbox &gt;1.6.1", {optional = true, debug = true}) target("test") set_kind("shared") add_files("src/*.c") add_packages("libuv", "ffmpeg", "tbox", "zlib") ```
Calm down. That something "pisses you off" is not a good argument.
Does anyone really think it is?
&gt; There are xmake-vscode, xmake-sublime, xmake-idea (idea,clion,android studio) and xmake-vim IDE plugins. Very nice. Thanks &gt; xmake has the builtin remote package manager and repository b2 has one too, but truth be told, I have zero interest in using/relying on yet another package management solution. I'm not complaining, as xmake supports conan and vcpkg - just saying it isn't a compelling reason for me. Thanks again
I think QPainter is the simplest you can find. You can also use canvas 2d in QML.
CMake is very burdensome to use. It seems simple for very simple projects. What if you want something like precompiled headers? You need a third party module ([Cotire](https://github.com/sakra/cotire)) which is 4,000 lines of stuff. With Meson? [Piece of cake](http://mesonbuild.com/Precompiled-headers.html).
You'd be surprised how many do.
It's c. But really does tick the "simple API" box!
The honest answer: there are none. SFML and Qt are closest to what you are looking for, but they do not use cutting-edge C++, which was your requirement.
That's what I meant by "makes sense" :)
What I'd really like to hear is some initiative to cinditionally *disable* features. Since we'll be having modules shortly, we could have smth like module-wide attributes. Or epochs. I'd be really glad if I could get rid of default-ints, variable vs function declaration (and related most-vexing-parse rule), typedef vs using, typename vs class in templates, class vs struct...
I hear it a lot, despite how many times its refuted.
Not actively, but I’m always open to discussion.
&gt;My preferred approach is to make CMake better. The good news is that they've demonstrated a willingness to introduce new ways of doing things and to deprecate and remove old ways. I'm interested. Can you give any examples?
There are plenty of languages where the object is passed explicitly; including python.
For C++ questions, answers, help, and advice see r/cpp_questions or StackOverflow. Although not to waste time, for my own simple text adventure game i used a linked graph. https://www.geeksforgeeks.org/graph-and-its-representations/
Thanks! Note taken. :)
I had to compile ~20 libraries lately for a project, and most of them used CMake, a few used autotools, one or two didn't have build rules, and none of them used Meson. It might be used for newer projects, but all the bigger open-source libraries I had to deal with still used CMake.
Yes. I'm working on some CMake modules: https://github.com/thejohnfreeman/cmake-future/tree/develop and a tool that tries to make working with a CMake project easier (kind of like the xmake CLI, but on top of CMake configuration files as they are): https://github.com/thejohnfreeman/cupcake
Trchnically incorrect. Which is the best kind of incorrect.
I am not certain what language the above is; it sure isn't C++, despite superficial similarity.
I'm not sure what your problem here is exactly; my best guess is that you don't believe that the write would be observable so I will address that. 1.9/6: "The observable behavior of the abstract machine is its sequence of reads and writes to volatile data and calls to library I/O functions." 1.9/8: "The least requirements on a conforming implementation are: — Access to volatile objects are evaluated strictly according to the rules of the abstract machine." Non-volatile reads and writes are not considered observable. The compiler may remove them under the "as if" rule (store to load forwarding, for example). volatile reads and writes are considered observable, and so must be emitted exactly as the C++ abstract machine would have executed them.
I didn't get the impression from reading OP that xmake implements a subset of CMake functionality. Is that true?
What would you replace it with?
Looks to scale just as well as the OP's mpmc; these two leave the other alternatives to eat dust. The latency is a bit higher but throughput is great on both OP and moodycamel's. I used it on 96 core Xeon rig and it was never a bottleneck; the workload was, as it should be. Did Moodycamel kidnap your cat or something? :D
Example how I handle C++ member variables via forced self-reference: ///////////////////////////////////////////////////////////////////////////// class FactoryDeliveryNote final { public: FactoryDeliveryNote(); private: auto queryRoutes () -&gt; void; auto updateRoutes (Json&amp;) -&gt; void; auto updateRoute () -&gt; void; auto updateRouteOrders (Json&amp;) -&gt; void; auto updateTraffic () -&gt; void; auto stateColorOf (universal const&amp;) -&gt; UiColor; auto printWaybill () -&gt; void; struct Self final { UiFrame frame {}; UiLabel title { "Factory delivery note" }; UiImage logo {}; UiLine hline {}; UiGraph traffic {}; UiButton query { "Query" }; UiEdit route {}; UiGrid routes {}; UiWebView waybill {}; UiLine fline {}; UiChoice orders {}; UiButton print { "Print" }; UiButton close { "Close" }; UiLabel status {}; struct final { int total {}; int count {}; } average; } self; }; ///////////////////////////////////////////////////////////////////////////// auto FactoryDeliveryNote::updateRouteOrders(Json&amp; routeOrders) -&gt; void { auto routeNumber = routeOrders.textOf(ns::routenumber); auto pickingPct = routeOrders.textOf(ns::pickingpct); auto timestamp = nowAs(YMDhms); auto name = format("%_Waybill_%", timestamp, routeNumber); self.orders += format("Route % - % \\%", routeNumber, pickingPct); self.orders.tag(0, ns::name) = moveOf(name); auto handleItem = [this, &amp;timestamp](Json::Object&amp; item) { auto order = universalOf(item); auto index = self.orders.size(); auto&amp; svgs = self.orders.tag(0, ns::data); auto svg = UiBase64::decodeOf(order[ns::data]); auto name = format("%_Waybill_%", timestamp, order.orderNumber); self.orders += format("Order % (%) - % \\%", order.orderNumber, index, order.pickingPct); svgs += svg; self.orders.tag(index, ns::name) = moveOf(name); self.orders.tag(index, ns::data) = moveOf(svg); }; routeOrders.arrayOf(ns::orders).forEach(handleItem); self.waybill.content(self.orders.tag(0, ns::data)); } /////////////////////////////////////////////////////////////////////////////
&gt; Eventually, done becomes true. volatile does not guarantee that the other threads will ever see the change.
Not my opinion, but you often hear new languages being advertised as C++ killers. Also you get the "insert this year's chosen Prodigy" being the C++ killer because "insert something irrelevant" feature, because it had a burst of adoption for hobby projects that year and some bloggers are too blinded with shiny pearl syndrome to see the faults. Don't get me wrong, there's certain things other languages do way better, but you need to get a lot of things right to be able to stand up to an established language like C++. Which is why I've heard this C++ is dead/dying for the last 20 years now almost. Seeing we're still having this discussion, it's been a really bad prediction so far.
Sorry 3 decades TOO late.
Bazel does this with [Starlark](https://docs.bazel.build/versions/master/skylark/language.html) which is also used by Buck, Pants &amp; [Please](please.build) and is very similar to the language used by Gyp/GN. In general Bazel’s story for things other than compilation is stronger because the core is really a dependency based DAG, with the ability to strongly isolate each step to keep things hermetic. From that you can get distributed execute and caching for all steps of your pipeline. The abstract angle is weaker for Starlark because every build system that uses it has slightly different rules for each language. It is a lot easier though to port between systems using Starlark because they generally are all philosophically the same and encourage more regular and easier to build project structures in general.
&gt;because "insert something irrelevant" feature In all honesty sometimes it's actually `because "insert something relevant" feature` but as you note: it takes more then just one thing to replace an established language. Which arguably only got better through the years :P
Yeah you're right. It's a bit dismissive to say it's always an irrelevant feature. Sometimes a new language can do a whole lot of things right, it's just hard to fight an entrenched language like C++ that has so many libraries and good things going for it at this point. That and it's easier to find good senior devs for a language that has been around for a couple of decades, and businesses value predictable stability. Investing in a new language is risky, no support libraries, and having to trust stability with no history to show for it.
I was recommended and I liked C++ Primer 5th edition which is good for beginners, but it also teaches a lot of modern stuff. Good read
Did you check how many lines of code in Meson it takes to implement the PCH feature too before throwing big scary numbers around? &amp;#x200B; It doesn't matter how many lines a 3rd party library has. The only thing that matters is its API and ease of use.
True, and very annoying. At least for cmake projects VS2019 finally defaults to x64.
Sorry for that, but it was literally the first Google result for "C++ books" - (both logged in and incognito). https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list It's extremely easy to find good information about C++ books. The site I linked has books for beginners like you. Just don't forget that practice is not less important than reading. :)
Most people would like Rust to replace C and C++. But I guess reality is a bit different from a wild dream.
I pretty firmly believe that there's almost no point in making a new project in C/C++ in 2019 unless you need a very specific feature or compatibility (such as better SIMD support, the ability to program microchips which is generally harder in Rust, or interoperability with something like the ROS ecosystem). For almost all intents and purposes, Rust just outclasses C++. Does that mean it's killing C++ or that C++ is dying? I wouldn't say that, just like I wouldn't say Java is dying just because Kotlin largely outclasses it. But it's not a meaningless factor, so I don't think it's ludicrous or stupid to phrase this same sentiment as "Rust is a C++-killer". The *language design* of Rust is simply more informed and updated, and the *language* is pretty much a unilateral improvements. The stuff that C++ can provide that Rust can't is mostly unrelated to either language and only related to the fact that C++ has 30+ years of ecosystem and compiler development.
The standard requires that reads and writes to volatile happen in the same order as they would happen in the abstract machine. But &amp;#x200B; 1. It doesn't say anything about the result of a read 2. If there is no synchronization between two threads, then there is no defined order between the volatile accesses on the different threads in the first place. But all that is beside the point. You have two unsynchronized accesses to the same memory location and one fo them is a write. That makes it UB as far as the standard is concerned.
How do you propose comparing a queue with a task scheduler?
Depends on the domain. Game development, GPGPU, Fintech, OS drivers and so on, yes it is thriving. GUI development, the war is lost to managed languages. At most it gets used for the composition layer and performance critical widgets.
I do, in what concerns GUI development in particular. Even Qt is incresingly embracing more QML into their stack. In what concerns OS vendors, Microsoft is the exception pushing for C++ as the foundation of UWP, and even there, most components get consumed from .NET, PWAs and React Native.
Well the default mode is without any optimizations at all, so naturally also no inlining. Though you can control that separately. And compilers can emit debug info that describes this inlining properly, at least in theory.
Shoulnd't that raise [https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-4-c4714?view=vs-2019](https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-4-c4714?view=vs-2019)?
I think it is fair to say, that relative to the total amount of software development c++'s importance does diminish. That doesn't mean there are actually fewer c++ programmers or fewer lines of c++ coded written than 10/20 years ago, simply, because there is much more software develoment going on now than back then, but the impression I get in my tiny universe is that the "market share" gets smaller - especially when looking at new projects.
not by magic either: the program has to call ioremap\_nocache / pgprot\_noncached / etc
&gt;The stuff that C++ can provide that Rust can't is mostly unrelated to either language and only related to the fact that C++ has 30+ years of ecosystem and compiler development. That's nothing to sneeze at. Rust surely has faults on top of its shortcomings, but they simply haven't been discovered or loudly advertised because it hasn't been used enough by enough people/projects. &gt;I pretty firmly believe that there's almost no point in making a new project in C/C++ in 2019 unless you need a very specific feature or compatibility There's no point picking any language in particular unless you need specific features. Requirements are rarely told to me up front, so picking a language that can do just about anything such as C++ makes the most sense. There's also a good community around it, and it's an ISO standardized language not owned by any corporation. On top of all those benefits it has the best performance around for virtually every task you can program for conventional computer hardware.
The biggest gripe I have with cmake is that it makes stuff that's silly simple in almost all other make tools suddenly turn extremely complex. For example, suppose that you have a compiler you wish to add, and that compiler isn't gcc nor anything that has command line like any other compiler. Well, guess what: you have to either write intermediate scripts that expose your compiler to cmake as if it was gcc or something of its ilk, or you have to modify the generator code to support your compiler. And not just "any" generator code: all generator code that cmake has. It's ridiculous, really. Shit that's trivial in plain old gnu make can be a week-longth endeavor in cmake. Heck, I have a project where I just wrote a ninja file by hand, because getting cmake to generate one the way I wanted it to be generated was turning in a month-long endeavor. Cmake is used by a lot of people who have no idea what a pile of dung it is in some respects. It's very nice source code and quite understandable, but in spite of it they managed parts of it to be ugly hacks. Ugly, inflexible, yet surely easy to understand and modify. But then, who the fuck wants to recompile their build tool twice a week just to work around its deficiencies?
I think you are absolutely correct. There are very very few features (including the new ones Herb talks about) that will completely subsume the functionality of an existing one (using vs typedef is one of the very few rare cases I can think of). Especially because c++ is never (well, not in the next two decades at least) going to remove the existing features. &amp;#x200B; So, while writing c++ code may become simpler, understanding the language and all possible interactions one feature can have with other parts of the language is going to get more complex.
Autotools is a steaming pile of shit, though. Nobody knows how to use it and everyone copy-pastes other already half-broken and non-idiomatic ways of using it. We use a bunch of gnu tools internally and needed them to be built along everything else: I re-wrote a lot of GNU world's build tools in cmake. It also makes it much easier to tweak, since you can just open the project under most any IDE. Autotools support under most IDEs is lackluster at best, if there even is any. The reason for that is that autotools are a mess that nobody can use properly (if there even is anyone out there who can truly be considered an unspoiled authority on the sobject). And thus consuming autotools scripts for IDE use is a fool's errand.
I thought Qt is implemented w/C++
It's been long since precompiled headers made much sense, isn't it? Not if you have an actual infrastructure to get your builds done.
&gt; That's nothing to sneeze at. I'm not sneezing at it. In fact, I'm the one that brought it up. =) &gt; Rust surely has faults on top of its shortcomings, but they simply haven't been discovered or loudly advertised because it hasn't been used enough by enough people/projects. I think this is a fairly biased perspective. Of course there are drawbacks, but the pros of Rust just as a general purpose language (higher levels of abstraction provided by things like enums with data, the borrow checker, traits...) are so huge that anything that remains undiscovered simply can't be worse than the negatives of losing those things (or else it would have been discovered by now). &gt; There's no point picking any language in particular unless you need specific features. Requirements are rarely told to me up front, so picking a language that can do just about anything such as C++ makes the most sense. Rust can also do just about anything. Assembly can also do just about anything. Of course, requirements and domain are going to inform your language selection, but my point is that there are very few requirements and domains for which Rust (especially as a language design, discounting things like compilers and ecosystem support) is in any way worse than C++. &gt; On top of all those benefits it has the best performance around for virtually every task you can program for conventional computer hardware. Unless you're relying on automatic SIMD for tons of operations, Rust clocks the usual benchmarks in around C++. I don't really think there's any evidence that C++ is consistently faster, and in fact I think I've seen more benchmarks where Rust beats C++ than the reverse. When you just look at things like `Option`, `Mutex`, `Result`, futures, etc. it becomes really clear that if you could break backwards compatibility you could add similar constructs to C++ without making anything about the language worse in the slightest but improving it in immeasurable ways. Like if you could *just* add pattern matching and sum types with associated data (named variants, essentially), it would be very hard to argue there would be any drawbacks, while it would be very easy to argue it's very useful. This is how I feel about something like 90%+ of the features that Rust has that C++ does not. It's a pretty unambiguous leap forward. ---- &gt; There's also a good community around it, and it's an ISO standardized language not owned by any corporation. As an aside, because I'm really much less confident about this than the above, I tend to find the Rust community much more accessible. There's more of an onus to do things like answer questions helpfully or write flashy new blog posts, whereas in C++ it seems mostly like it's mostly geared towards people who are basically new to programming generally. Comparing /r/cpp to /r/rust for example, I find the Rust subreddit to be much friendlier and have much more new content and discussion on a daily basis. That's of course because Rust is moving much faster for many reasons, but this is concretely really beneficial if you're having an issue or want to discuss a design. I feel like a much better Rust programmer than a C++ programmer because the Rust community is so active in teaching and documentation. Rustdoc is hugely beneficial and just behaves so much more sanely than any comparable system in C++, and it being language-wide and having a ubiquitous package manager just means you can get, learn, and debug any arbitrary third party library in a very streamlined, organized process. Even just comparing sites like cppreference to the Rust book or standard library reference really clearly indicates to me that Rust's community is more effective at communicating shared knowledge. Additionally, I don't think it's fair to say Rust is not standardized or that it's owned by a corporation. Mozilla certainly plays a huge part, but Rust is a community driven language. It's certainly less standardized and understood, but I suspect that's more of a factor of just how many edge-cases and undefined behavior there is in C++. Features/behavior that C++ documents and standardizes heavily (such as what qualifies as undefined behavior with memory access) simply aren't a factor in Rust. Having unexpected behavior that's documented is less beneficial than not having the unexpected behavior in the first place. I would say Rust could probably be documented better, but so far my experience with Rust documentation and community has been vastly superior than the same with C++.
C++ isn't dying, but let's be honest here. C++ can be used for practically everything except client-side web development (not counting compilers and C++ frameworks that spit out JS). However, these days it's not widely used outside of problem areas where it brings some unique advantage(s) to compensate for its difficulties. It's certainly not the default choice for random applications anymore. I personally think it should be used more than it is, but I doubt we will see much change in usage any time soon.
It's not very modern in terms of latest C++ standards, but [Anti-grain Geometry](https://en.wikipedia.org/wiki/Anti-Grain_Geometry) is one of the nicest libraries I've come across.
IMO Rust seems to get the most credit as a possible C and/or C++ replacement because it innovates AND gets used in the real world. Nothing against languages like Crystal, Nim, etc, but I don't know companies using them.
Instead of a nested map, use `map&lt;pair&lt;int, int&gt;, string&gt;`.
The write to `done` might never go out of the L1 cache of the CPU where`main` ran =&gt; thread never sees that it changed. The CPU cache coherency us a bitch. **Must... use... atomics.** (Note: the example will work on x86/x64).
Does it also happen without LTCG? If no, does it happen with a unity build?
That looks exactly what I need. Thanks.
Instead, it is getting more and more non-replaceable. Almost all other languages can be easily replaced by at least one language in it's field of strangth. What c/c++ is good at for the last 20 years are mostly still what it's good at and will be that way for the next 20 years without a doubt. This is the best part of learning c/c++
It is. However many of the new features are only exposed via QML, with the perfomance critical parts in C++. If you want to write pure C++ in Qt, you are bound to the deployment scenarios of Qt C++ Widgets, which means desktop. The remaining deployment scenarios make mostly use of QML or more recently Python first, and C++ second as development approach. If you check the Qt blog, a common complain is how to balance back to C++.
I... wouldn't?
Not if you are doing Windows builds. Precompiled headers save quite a bit of time when done with MSVC (the improvements are rarely noticeable with gcc though).
Basic, Pascal and Ada come to mind. https://www.mikroe.com/mikrobasic-avr https://www.mikroe.com/mikropascal-avr https://sourceforge.net/p/avr-ada/wiki/Home/
I agree. Simple projects and common tasks should be easy, with absolute minimal boilerplate. Customizations should be possible, but not difficult. There's emerging documentation (talks and articles) on [best practices](https://github.com/onqtam/awesome-cmake). I'm working on some [CMake modules](https://github.com/thejohnfreeman/cmake-future/tree/develop) trying to encapsulate those practices; a [tool](https://github.com/thejohnfreeman/cupcake) with a CLI like xmake but built on existing CMake files; and some [patches](https://gitlab.kitware.com/cmake/cmake/merge_requests?scope=all&amp;utf8=%E2%9C%93&amp;state=all&amp;author_username=thejohnfreeman) to CMake. Have you considered upstreaming your improvements to CMake?
feature removed in C11
&gt; checked Boost 1.70 and there are over 22,000 files with trailing white space WTF, don't they do git diff or what?
New projects are moving away from C++ more and more. I’m a bit of a C++ zealot but I couldn’t say I think I’d use it if I were starting a new project at work.
Lots of people say that for specifically 2D, https://www.godotengine.org/ is nicer to work in than Unity3D.
I had one (quite ignorant) teacher who said/believed that `const` is a problem in C++ design that only causes more compilation warnings.
I think the biggest thing going for C++ is its ecosystem, mature behavior, and access to developers. That’s something that can’t be replaced in a few years, and so what I meant is I don’t think anyone thinks those things can easily be replaced.
It has a few implementations of thread safe queues here https://github.com/GameTechDev/GTS-GamesTaskScheduler/tree/master/source/gts/include/gts/containers/parallel
WebAssembly means that C++ can now be used on the client-side BTW. Some compilers just spit out JavaScript, yes, but v8 has a native WebAssembly compiler.
&gt;I pretty firmly believe that there's almost no point in making a new project in C/C++ in 2019 unless you need a very specific feature or compatibility Lol, what OS drivers are written in C++?
Lol, what OS drivers are being written in real C++?
Second going the book route. Websites are good for tips and discussion of specific topics, but it takes a good book to really put things in context and, preferably, have exercises to practice what you've learned. I know there are tutor websites out there, but I place my trust in books I have read and know to be quality material.
This. C++ is the best choice for WASM deployment, bar none.
macOS, Windows, GenodeOS, IBM i, Android, Arm mbed, ...
NetBeans’ C++ plugin is still for NetBeans 8. The current version doesn’t support it.
As a game developer, the idea of C++ dying is fairly laughable at this point.
These queues are essentially the same ring buffer with a different spinlock. The spinlocks may be interesting though.
It now uses `pause` instruction. Benchmarks confirmed an improvement in latencies.
Rust has 1st class WASM support.
And? C++ has the committee behind it.
You keep missing the big point: "strictly according to the rules of the abstract machine" does not involve write becoming visible to other threads.
My main gripe with SFML is lack of constexpr support, for instance no constexpr constructor for `Vector2f`.
Emscripten?
To be fair, for some of those 20 years, it was dying. Java and .NET had their heyday in the same period of time that C++ was a bit stagnant, was kind of a perfect storm for awhile there. I gave up on it until C++11 arrived and i saw some real forward progress.
Even though I agree that `this` should have been changed to a reference back when they got introduced, I think it's fine in the end. Adding another way to do the same thing doesn't sound like a good idea. I'd rather see an `inherited` or `overridden` keyword instead so that we can write: overridden(foo, bar); instead of the slightly error-prone: MyBase::someFunc(foo, bar);
I like Rust, I really like it... but the ecosystem is still tiny and immature compared to C++, and that's a pretty good reason to still start a project in C++ today. If you need a GUI which will perform number crunching, for example, well in C++ you can just us QT and implement the number crunching in the same language and release a single binary. In Rust... good luck?
&gt; Tooling is a huge factor in adoption and even Rust struggles with this when compared to more mature C++ tooling. And ecosystem. The Rust ecosystem is quite immature still, and plenty of problem domains are just bare fields with a handful of pioneers trying things out.
I don't know rust at all. What are some things that C++ does better than rust?
Back at you: And? Is this the only argument for why "C++ is the best choice for WASM deployment, *bar none*."?
I would say SFML or Magnum, check if they can do what you'd like to do. Can recommend them both. The author of Magnum is also active here in this sub and very responsive.
Well, depends, but so far I'd say the greatest advantage of C++ is that is a quite well known language that has been popular for decades, and so, as a result, it has been refined over the years, unlike Rust, which is still a pretty young programming language compared to C++. Also, C++, as an inherent perk of its age, has lots and lots of libraries available for it (same goes for C). C++ also has evolved to somehow fortify its memory unsafety inherited from C (smart pointers are an example). Also, some people complain about some compilation issues with Rust (I don't know details). Many usually try to persuade developers to port certain programs to Rust, and, although I greatly appreciate Rust, it's not really time for it to take over. Maybe it won't ever take over, just coexist, who knows. Time will tell.
Java was always a big pile of poo. The great innovation it gave the world was virtual machine byte-code which made it potentially good for writing applications which ran inside web browsers running on disparate real-machine architectures. Unfortunately that was the limit of its applicability, and it didn't actually do the virtual byte-code very well (all modern scripting languages do it better today). I've never for the love of God understood why so much Java ended up server-side. It seems like it was always a corporate decision made by nincompoops.
Sure. I think GUI development is surprisingly lacking in particular, but I would classify that as a compatibility issue, and in 2019 I think it's a pretty niche issue. I don't see many new desktop applications being written in C++ anymore (or in anything anymore, more appropriately). However, I do agree that this area and a couple of similar areas are surprisingly limited in Rust at the moment owing to a lack of maturity in the ecosystem (which isn't entirely fair, considering C is the official way to use many windowing systems. it's more about momentum than it is about maturity in this case). The problem with talking about C++ maturity is that the mere existence of libraries does not mean you just automatically get the functionality of these libraries. So while it's true that C++ has some great GUI libraries, the build tools for C++ are very cumbersome and often don't interoperate properly. So you'll spend a few hours just learning how to get Qt to compile and integrating that build system with the build systems required by any other dependency you use for number crunching. Most of these libraries require system installed libraries, so now you need to write and maintain a Dockerfile with all of the system-level dependencies just so you can deploy without having to manually install dependencies. So there's a lot of manual/one-off labor you need to do just to pull in the dependency, and then you need to actually integrate the code. Every library has its own conception of what it likes to use for lists or vectors, and some libraries require that you shuffle your data into their particular shape, so you need to write and maintain conversions. Use of the standard library interfaces or data structures is not ubiquitous, and a lot of code is written in extremely different styles and with different historical relics. Some libraries use snake_case and some use camelCase. Some libraries expose namespaces and classes, while some libraries expose macros and C-style global functions with static storage. `#include` doesn't tell you *what* you're including, so if you use identifiers that aren't namespaced well, you have to just casually know where the identifier comes from. IDE support can mitigate some of these issues, but it's a really messy and unavoidable situation. So, yes, libraries for graphics exist. Thousands of libraries for any given topic have been written and poorly documented across the internet's vast array of C++ code repositories, and this, in a sense, is "maturity". But I'm not really convinced it's a kind of maturity that helps in applications, and I really don't think throwing our hands up in the air and saying "C++ ain't going nowhere. We dug our grave and we'll lie in it." is the proper response to the temporary lack of desktop GUI frameworks, a category of libraries that is getting less necessary over time. Even where a desktop GUI is mandatory, I find myself unlikely to choose C++ over Java, C#, or a number of other popular solutions for cross-platform desktop GUIs. So while I might not be picking Rust for this task, I also might not be picking C++.
The biggest thing going for C++ is that it is multi-paradigm and as fast as the fastest thing there is (with the possible exception of hand-written assembly).
Java performs very well server side. Java in the browser was the least useful innovation to come out of the Java era. The idea that scripting languages are better than the JVM is nonsensical. Almost every notable benchmark and the sheer number of languages that target the JVM being my evidence.
You're right, it is 2019. so let's stop calling UTF-16 "wide character".
&gt; Java performs very well server side. Not as well as C++. &gt; Java in the browser was the least useful innovation to come out of the Java era. Agreed. But it was the target market in the early days. &gt; The idea that scripting languages are better than the JVM is nonsensical. Almost every notable benchmark and the sheer number of languages that target the JVM being my evidence. Your opinion. I respect that.
This article compares the really, really common tasks, which in my opinion, are pretty much the same in either tool. I can add a prebuild/postbuild command easily, I can create a binary and add sources or compile definitions, and sometimes the syntax is a bit strange (is whitespace important in XMake? why do I need to use \`endif()\` instead of brackets in CMake?), but the examples are really, really similar. &amp;#x200B; Personally, I prefer to see how a complex task is handled by each tool to fully comprehend its capabilities, or a mention if it isn't possible. For an example, stating that XMake has an integrated package repository is great, but that's a single example. Things I really prefer to see compared: &amp;#x200B; 1. Creating an executable and a static library, and linking them together \* I find it really awesome that in CMake you set per-target properties with a visibility, and simply using \`target\_link\_libraries\` "brings in" the properties you need from the dependent library, such as defined and include directories. What's the idiomatic XMake way to do this? 2. Handling external libraries from the web/pre-built libraries (libX.a/X.lib) \* CMake supports \`ExternalProject\_Add\` and \`IMPORTED\` libraries, which seems superior to the similar method in the last XMake example of the "Custom script" section, but I have no idea if that's the idiomatic XMake way to clone a git projects. 3. Integrating an external library which also works with the same tool \* Is integrating an external CMake project is easy? What about XMake? This seems like one of the most important factors in choosing a build-tool, and it's a shame it wasn't mentioned 4. Integration with IDEs \* Sadly, C and C++ projects seem to lack standard structure, which makes it harder for IDEs to correctly analyze your code. CMake support to generate VS/Eclipse projects helps, and this post makes me wonder how it works with XMake &amp;#x200B; To summarize, I really like the idea of this post, but I feel that the provided examples are too minimal to fully convince me to choose one tool over the other for any of my projects.
As opposed to?
&gt; Not as well as C++. https://www.techempower.com/benchmarks/#section=data-r17&amp;hw=ph&amp;test=json C++ does not appear before Java on any of those benchmarks, and JVM languages regularly appear multiple times in the top spots. For IO heavy loads with lots of concurrency, the JVM seems to perform better than C++. And most traditional server loads are just that. Web servers and databases dominated by IO.
&gt; What if you want something like precompiled headers? You don't need Cotire for precompiled headers (it does much more). All you need is add the PCH as dependency of a project's source files and add a forced include file. You can do that with a 10-30 lines CMake function, depending on how fancy you want it.
&gt; Thousands of libraries for any given topic have been written and poorly documented across the internet's vast array of C++ code repositories, and this, in a sense, is "maturity". But I'm not really convinced it's a kind of maturity that helps in applications I feel lucky everyday for working on low-level applications meaning that I do not need to integrate 3rd-party C++ code ;)
Yeah, it's definitely easier. I have actually worked on some Rust embedded stuff and I think you'd be surprised how much third-party libraries can help with low-level applications as well. Things like very space-efficient data structures might be a useful thing to pull in, right? Right now, I don't know of a super quick way to pull in a small vector like Rust's `smallvec` to C++, but that's a useful addition to low-level applications. Same with something like `byteorder`. Having easy build and integration tools means you can change the way you program by leaning on existing tools rather than reinventing the wheel. That's why I say C++'s maturity doesn't matter that much. Ripgrep notably leans heavily on the regex crate, for example, and without Rust's regex crate's performance, ripgrep wouldn't be the fastest finder, but that code is common and extremely accessible to anyone who writes Rust and has internet access.
So aside from being very entrenched and having lots of libraries available to it, c++ itself doesn't offer any superior functionality, expressibility, or power (meta-programming like templates) over rust?
As former C++ dev, doing Java and .NET, only touching C++ when they need some extra help, both platforms are doing pretty well, I would say. In fact, check Modern C++ in Windows post from Kenny Kerr, about how despite the fact that UWP is built on C++, it only gets used from managed languages. Likewise, even though several layers of Android are written in C++, it is dealt as the unwelcome cousin that appears unvited to the party, where Android J++ and Kotlin have all the fun. Or Apple platforms, where it gets a little role to play as side actor on device drivers, Metal shading language and LLVM stack, with Objective-C and Swift being what actually matter to Apple developers. Surely there are domains where it reigns supreme, as I mentioned on other threads, but we should also acknowledge that it lost its spot on desktop/mobile computing as it once had.
can we stop calling UCS-2 "UTF-16" as well then while we're at it?
Why would you convert utf-8 to wide?
Any CPU bound task is fair game for C++. Nothing really gives you the same level of control over memory utilization/layout and code generation that C++ does -- at least not with the high level language constructs around it.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bwaaod/learning_c/epx0zee/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Well, the size of bytes should have been explained much earlier. After all, it's in one of the very first paragraphs in the standard.
Thanks, didn't know that. Did they remove it to be closer to C++?
C++ still is more featureful for compile time programming, although that is being chipped away by Rust.
Disgusting; this just looks like Java and lacks any of C++'s character.
No. It was removed because it was not secure. It's very easy to get stack corruption etc bugs Ofc major compilers support it as an extension, including C++
UTF-16 was always crap, probably why Microsoft chose to standardize on it. UTF-32, where UTF-8 was a special case arising naturally from a variable-length encoding of UTF-32, would have been the right choice.
Depends what you mean by superior functionality. Indeed, C++ has template meta programming, which is really powerful, and lots of improvements, especially from C++11 onwards, which really modernised C++. Most of the times, the reason we choose certain languages is composed of multiple factors, and functionalities are just a part of it. Of course, C++ has really a ton of features we often even forget about (among the tons of features it has, it is hard to remember everything), so we could say it is a bit more comprehensive than Rust. Still, I wouldn't go on and say that one has to be objectively better than the other. Many languages are born with pretty similar features, but popularity is what makes people improve them. No one would really continuously add features to a programming language that is barely used. Bottom line is, C++ is a seasoned veteran, Rust is a promising youngster. Time will tell what will happen, although I don't see how a language like C++ could one day just vanish completely in favor of Rust.
C++ dying? LMAO
Sounds false. Maybe this compiler doesn't know something because its stupid but it certainly CAN know that the values don't change during the loop. Even if we ignore the fact that this is a small program that can be analyzed completely, the compiler sees that the loop doesn't change the relevant variables. So they can only be changed by some other code. In another thread. (There are no "interesting" or "dangerous" calls inside the loop. The log is basically an intrinsic for any modern compiler.) But since the relevant variables aren't atomic or protected by locks etc. changing them in a other thread is UB and the compiler doesn't have to handle it "correctly". In particular, it may assume they don't change.
Just going to drop [this](http://utf8everywhere.org/) here... In particular the last section, where it deals with winapi.
As much as I love cmake, I hate it's syntaxe. It is really not pretty to look at from my point of view.
Library itself does not care about if it's UTF-16 or UTF-32 - it's detected at run-time. I guess unicode support can be implemented even by application itself (e.g. implement UTF-32 on windows), but then it's bound to which basic library function you need to reimplement (e.g. C's wcslen, wcscpy, or C++'s std::wstring). But I'm still kinda curious whether if in UTF-16 you get one character in more than 2 bytes - and how windows api functions works with that kind of characters...
that's very basic function which is needed almost everywhere ?
You're right, if you go swimming deeper into languages, localization - then you need rather heavy library for that purpose - but even for very basic application with basic unicode support my library will work as fine as other heavy libraries. One approach is just take existing unicode library (e.g. boost locale) can cross compile on all os's, but that is still bound on which features needs to be supported.
Nope. I've seen it have pretty massive (20-40%) compile-time reduction in both MSVC and Clang builds in the last few years. It does depend on the project, though.
&gt;&gt;Java performs very well server side. &gt;Not as well as C++. While probably true in the majority of cases, it's also more or less irrelevant. Machines have sped up and increased memory to the point that nobody will know or care what language you use to write your backend.
UTF-16 does have 4 byte wide "characters" (codepoints actually). Look up "surrogate pairs".
If you are just traversing, use a plain old pointer (or better still write an iterator). As you've pointed out, it's not owning, so don't use an owning smart pointer.
I would have said OpenAL is the smartest choice. Many companies are reluctant to use LGPL based software, often because of uninformed lawyers or other misunderstandings. May I ask why OpenAL / LGPL is not an option? PS: There are also solutions like fmod, but you need to pay for it when using a commercial version.
You've given us zero useful details, but... none of the above, use raw pointers. Smart pointers are about _ownership_ (even `weak_ptr`). Raw pointers are still very valid constructs for non-owning cases.
why not a regular `T*`, there's nothing wrong with using pointers for non owning cases. &amp;#x200B; `unique_ptr` and `shared_ptr` should generally be used for ownership, with `weak_ptr` to break cycles of `shared_ptr`. For any non owning case where your value can be null or iterators over contiguous memory, `T*` is ideal. There's a bit more in the [GSL](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rr-owner) about this.
But reflection is runtime right? While this is compile-time.
I used to use C++ long ago. I am trying to catch-up with the C++ community with the latest specification C++17. Here's the current program that I am writing with an objective to master the latest pointer constructs in c++17 spec: struct ListNode { int val; unique_ptr&lt;ListNode&gt; next; ListNode(int x) : val(x), next(nullptr) {} }; class Solution { public: unique_ptr&lt;ListNode&gt; addTwoNumbers(unique_ptr&lt;ListNode&gt; l1, unique_ptr&lt;ListNode&gt; l2) { unique_ptr&lt;ListNode&gt; result(nullptr); int carry= 0; /* * I need p1 to traverse l1, p2 to traverse l2 and pr to keep track of last ListNode * in result. My current objective is to master the usage of unique_ptr, shared_ptr and * weak_ptr constructs of latest C++ spec. */ while(p1-&gt;next != nullptr &amp;&amp; p2-&gt;next != nullptr) { int sum = carry + p1-&gt;val + p2-&gt;val; carry = sum % 10; sum = sum / 10; unique_ptr&lt;ListNode&gt; curr(new ListNode(sum)); if(result == nullptr) { result = curr; pr = result; } else { pr-&gt;next = curr; pr = curr; } } return result; } }; Please point me in the right direction.
Nope, there is no proposal for runtime reflection and really, I'm pretty sure no one wants that :) A runtime solution would not be C++-y
This question is part of the argument for a construct like std::experimental::observer_ptr (name very much pending IMO), which is in the library fundamentals TS, so you can be clear about ownership. Such a pointer could also be used as a parameter so functions that don’t care about ownership could take unique_ptrs, shared_ptrs, and raw pointers easily.
You're right, there's no reason for that. &amp;#x200B; Oh, wait... There's an OS that uses wchar\_t-strings for everything and has about 80-90% of the desktop market share.
It's 2019 so the status quo is: \`char8\_t\` is a raw integral value of UTF-8 code unit. \`char16\_t\` is a raw integral value of UTF-16 code unit. \`char32\_t\` is a raw integral value of UTF-32 code unit, Unicode code point and Unicode scalar value. \`char\` and \`wchar\_t\`... pretend they don't exist. We teach people not to use raw owning pointers, C arrays, etc. So we also must teach people to never use \`char\` or \`wchar\_t\`.
To call any of the Windows API functions, for one thing.
So is the recommended way to use linked data structures is to use plain old pointers? What's the use for these latest pointer constructs like unique_ptr, shared_ptr and weak_ptr then? What's the recommended way to use linked list? STL library?
That's so cool. Looks like we don't want to use plain pointers in C++ anymore.
I used work for Symbian, it definitely wasn't real C++. CleanupStack::PopAndDestroy()
For this to work the way you want it, everything has to be a shared_ptr.
I used to work for Nokia, it was C++ code compiled with a C++ compiler. Having to use a specific set of patterns known as Symbian C++, doesn't make it less C++.
Ada, Modula-3, Delphi, D, Rust, Swift are all fair game at it. As much as I like C++, my polyglot background doesn't blind me to other alternatives.
That's where I wasn't sure if I was doing the right thing. So I should get a raw pointer from my unique pointer by using this method of unique_ptr : std::unique_ptr&lt;T,Deleter&gt;::get . Right?
Are you asking?
Well explained; everyone got it?
What it's so great about the c++ eco system? Virtually every other language has better dependency management and many, many other languages have much better tooling (usually because the language is simpler) and are easier to teach. Also, I don't have the impression that the set of libraries that is available for c++ is more extensive than for other languages. Due to the package management story it is probably even worse. I think the only thing in the c++ eco system that really goes for it is sheer inertia. The address huge c++ projects out there that are not going to be rewritten in a different language any time soon.
I admire your answer. :D
What will happen if you search in string, take text, replace it, etc ? Probably a lot of magic.... :D
I just discovered at Google IO 2019 talk about ChromeOS, that all new native pieces are written in Rust, for what it is worth. Also Microsoft, with its big C++ support, makes use of Rust on their IoT Azure stack.
Give up. You are in r/cpp and no matter what arguments, benchmarks or other facts you bring up, no one wants to hear that their baby might not be the best and brightest (or in this case fastest). Add an aside, I find it really surprising, how much the performance of c++ is always praised, if you consider that standard c++ only allows you to access a tiny fraction of the processing power if modern systems, which mostly resides in simd, multithreading, and most importantly GPUs. I really joke that executors are going to change that.
There is indeed quite a hype for Rust, and I'd say it's well deserved. Mozilla also uses Rust, and there is already an OS written in Rust.
I was always wondering why linux decided to use char\* for UTF-8 strings, but there is major idea in it - ASCII is a sub-set of UTF-8 - so whatever ascii string you have you can assume it's UTF-8 and convert it to wide. But internally cutf library uses `uchar8_t` to simplify all high bit detection operations - and even what you provide `char*` \- it's treated as `uchar8_t*` buffer. Plain ascii is `char`, utf-8 starts where `char` ends - that's high bit of char type (negative char value).
The game engine is BSD and it would be preferable not to have a hard dependency with LGPL code.
Yes. Keep in mind that shared_ptr and unique_ptr are not replacements for raw pointers. They exist for solving the ownership problem. unique_ptr is the (only/unique) owner of the pointer to the object and it will delete the object when it itself gets deleted. Because it is unique, you can not copy unique_ptr. With shared_ptr multiple shared_ptr can own the object and the object will be deleted when the last shared_ptr that owns it gets deleted.
The "correct" thing to do here is to implement an iterator type, which should not own your data structure, so the way to implement it should probably be by wrapping a raw pointer. &amp;#x200B; If that feels like too much bloat, a regular old raw pointer should do. but keep in mind that if you implement an iterator, you can use STL algorithms over your container.
The "nested inline markup" limitation of reStructuredText really irks me when it comes to hyperlinking `monospace` text, and while [the FAQ](http://docutils.sourceforge.net/FAQ.html#is-nested-inline-markup-possible) suggests it's "on the to-do list", the author of rST has said elsewhere (and I'm too lazy to dig it up right now) that he's never going to add it, he hates the idea, and everyone else is stupid for wanting it. I really hate his attitude on the issue. Seems like it would be easier to add directives to Markdown, which I believe has a bigger community at this point.
What string? `std::string` or `std::wstring`? In that case, it's your responsibility to not split a codepoint in half. As far as C++ is concerned... good luck. This, combined with endianess issues and massively bigger size compared to UTF-8 is the reason why UTF-16 is universally a terrible choice. It is essentially the worst of both worlds (UTF-8 and UTF-32) - needing a lot of space while still having variable codepoint length.
I was looking for the VS extension mentioned in the podcast that can look at object lifetimes. One of the features was finding changes to a collection that was being iterated over. Anyone know what extension was being referenced?
isvolatileusefulwiththreads.in/cplusplus
Observable doesn't mean someone else won't beat your write in propagation, yeah. That's the sequencing, synchronization and timing bit I was talking about the atomic guarantees. As I said in the first place, the difference is timing (=when) not "if". The write WILL be visible to other threads - the question is WHEN. If it is too late, you can argue it's not visible, so let me ask if that is your case here? If it is, then you could have deducted it from my first response where I explained the guarantees atomic brings into the visibility.
I'm sorry that I have also holy gift to write disgusting english, not only C++. &amp;#x200B; My example main purpose was not try to show that I actually like Java naming conventions. What I tried to show was that I like m\_-prefix free private member variables and self-references, if it means that I cannot reference member variables without self-point notation and that I can force self-point notation when I partially simulate self-reference using 'struct Self {...} self;' wrapper (and it is usable at least in application level code - in library level code self-wrapping is not always so easy thing). &amp;#x200B; My example code is part of my C++ / Oracle SQL version with user response time average about 30 milliseconds versus originally C# / Entity Framework (ORM) / SQL Server Reporting services (SSRS) / Oracle PL/SQL version with user response time about 30 seconds. &amp;#x200B; I hope that acceptable user response time is still one of C++'s characteristic.
It depends on the use case. In our project, we use (asio) callbacks for latency sensitive operations (e.g., milliseconds-accurate measurements) and continuations for all other operations (e.g., uploading data when they're ready).
I take your advice as my next activity in the process of my new wave of learning C++. Just finished implementing a successfully running algorithms for sum of two numbers: ```c++,tabs=4 #include &lt;iostream&gt; #include &lt;memory&gt; using namespace std; struct ListNode { int val; unique_ptr&lt;ListNode&gt; next; ListNode(int x) : val(x), next(nullptr) {} }; class Solution { public: unique_ptr&lt;ListNode&gt; addTwoNumbers(unique_ptr&lt;ListNode&gt; l1, unique_ptr&lt;ListNode&gt; l2) { ListNode* result=nullptr; int carry= 0; ListNode* p1 = l1.get(); ListNode* p2 = l2.get(); ListNode* p1_p = nullptr; ListNode* p2_p = nullptr; ListNode* pr = nullptr; while(p1 != nullptr &amp;&amp; p2 != nullptr) { int sum = carry + p1-&gt;val + p2-&gt;val; carry = sum / 10; sum = sum % 10; cout &lt;&lt; "Sum:" &lt;&lt; sum &lt;&lt; endl; if(! result) { cout &lt;&lt; "Code came here" &lt;&lt; endl; result = new ListNode(sum); pr = result; } else { pr-&gt;next = unique_ptr&lt;ListNode&gt; (new ListNode(sum)); pr = (pr-&gt;next).get(); } p1_p = p1; p1 = p1-&gt;next.get(); p2_p = p2; p2 = p2-&gt;next.get(); } ListNode* p = p1?p1:p2; if(p == nullptr) { pr-&gt;next = unique_ptr&lt;ListNode&gt; (new ListNode(carry)); pr = pr-&gt;next.get(); }else{ while(p != nullptr) { int sum = carry + pr-&gt;val; carry = sum / 10; sum = sum % 10; pr-&gt;next = unique_ptr&lt;ListNode&gt; (new ListNode(sum)); p = p-&gt;next.get(); } } return unique_ptr&lt;ListNode&gt;(result); } }; int main() { Solution sol = Solution(); unique_ptr&lt;ListNode&gt; result = sol.addTwoNumbers( unique_ptr&lt;ListNode&gt; (new ListNode(9)), unique_ptr&lt;ListNode&gt; (new ListNode(8)) ); if(result == nullptr) { cout&lt;&lt;"Result is a nullptr"&lt;&lt;endl; } else { ListNode* p = result.get(); while(p!=nullptr) { cout&lt;&lt;p-&gt;val&lt;&lt;endl; p = p-&gt;next.get(); } } } ```
One big thing that C++ has and Rust hasn't got yet in an official release is non-type template parameters. This actually makes C++ templates a more functional language than Haskell and friends :-)
&gt;Chill out it’s not even 2020 `cl /std:c++latest /experimental:module ...` is for 2019. And 16.x does have a modularized STL package, too.
&gt; C++ does not appear before Java on any of those benchmarks https://www.techempower.com/benchmarks/#section=data-r17&amp;hw=ph&amp;test=plaintext
Thanks! this is very helpful to my "feeling post". I will try, even though I am a newbie.
&gt; The standard library isn't modularized yet. It is. 1. Install the "Microsoft.VisualStudio.Component.VC.Modules.x86.x64" package. 2. Make sure the compiler finds it (e.g. in my customized setup I use `/module:stdIfcDir %YOUR_STD_IFC_DIR%` for CL.) 3. Then `import std.core; int main(){ cout&lt;&lt;"Modularized STL! :-o";}` builds and works just fine.
Should you just use the windows API conversion functions then? Using the CP_UTF8 code page?
&gt;Unless you're relying on automatic SIMD for tons of operations, Rust clocks the usual benchmarks in around C++. I don't really think there's any evidence that C++ is consistently faster, and in fact I think I've seen more benchmarks where Rust beats C++ than the reverse. It also happens to be the case that C benchmarks faster than C++, even for the exact same programs. (I'm not sure why this is, but it's a well-known fact) Maybe, there was room for optimization? Benchmarks can be big lies sometimes. You will have to be more specific than that. &gt;When you just look at things like Option, Mutex, Result, futures, etc. it becomes really clear that if you could break backwards compatibility you could add similar constructs to C++ without making anything about the language worse in the slightest but improving it in immeasurable ways. What do you mean? C++ has those.
I just want to say regardless of one's views on what language they prefer for newer projects, I think what you've written is fair and well reasoned. I wish I could use both though languages though. With a rock-solid C++ bindgen, C++/Rust would become unstoppable.
This may be a good starting point, despite being kinda old. (Note: I didn't specifically follow this one, because I found it only after figuring it out myself from bits and pieces scattered all over the net.) https://devblogs.microsoft.com/cppblog/cpp-modules-in-visual-studio-2017/#sl-modules
&gt;is is required for module support I believe. &amp;#x200B; Visual Studio sure does, and has been for a surprisingly long time actually. See the details in the other comments.
What about 32-bit kittens? And real-mode kittens?
functions that don't care about ownership can just take raw pointers, full stop. what problem is this solving again? &amp;#x200B; doing my own research - according to cppreference - *"It is intended as a near drop-in replacement for raw pointer types, with the advantage that, as a vocabulary type, it indicates its intended use without need for detailed analysis by code readers."* .... so ..... it's actually not for what you're saying - raw pointers are precisely there already for what you talk about that. Rather, the only gain of something like observer\_ptr would be to be clear that you're doing with it what you precisely what you should anyway be doing with raw pointers, which if you understand this already, you realise is really thus not necessary, unless for example, if your code-base might be full of legacy code using raw pointers in other (non modern c++) ways, and you thus need to specify clearly where you're actually using raw pointers for what raw pointers are now only supposed to be used for, vs other parts of your codebase that could be using them for say ownership in some legacy way .... but again, whatever ones thoughts on the usefulness of such a type for that purpose, that's not the purpose you were suggesting, so it's good to clarify that here.
this is the kind of misunderstanding that I corrected with my reply to parent .... plain pointers have a specific use in modern C++ .... yes, you could make a new type to also be used for that same purpose and make your code more verbose .... or, you could just learn modern C++ and understand what plain pointers are to be used for and not used for.
To be fair to Microsoft, when they were writing NT Unicode was brand new, and they (Unicode) made the dumb decision to think that 65536 codepoints should be enough for anyone, and it wasn't.
&gt; What's the use for these latest pointer constructs like unique\_ptr, shared\_ptr and weak\_ptr then? I use unique\_ptr some, but I like [using raw pointers](https://stackoverflow.com/questions/38780596/how-to-handle-constructors-that-must-acquire-multiple-resources-in-an-exception). So far I haven't used shared\_ptr. &gt; What's the recommended way to use linked list? STL library? I don't use linked lists often. People try to use vector or arrays when they can. Boost has some interesting containers. foonathan does also -- [https://github.com/foonathan/array](https://github.com/foonathan/array)
&gt; I was always wondering why linux decided to use char* for UTF-8 strings Because C does not have char8_t yet, it's coming with C2x.
&gt; I find it really awesome that in CMake you set per-target properties with a visibility, and simply using You can see https://github.com/xmake-io/xmake/issues/368 ```lua target("xxx_lib") set_kind("static") add_files("src/*.c") add_includedirs("include", {public = true}) target("test") set_kind("binary") add_files("main.c") add_deps("xxx_lib") ``` &gt; CMake supports ExternalProject_Add and IMPORTED libraries, which seems superior to the similar method in the last XMake example of the "Custom script" section, but I have no idea if that's the idiomatic XMake way to clone a git projects. xmake can set `includes("external_project")` to import other external project. &gt; Is integrating an external CMake project is easy? What about XMake? This seems like one of the most important factors in choosing a build-tool, and it's a shame it wasn't mentioned There are xmake-vscode, xmake-sublime, xmake-idea (idea,clion,android studio) and xmake-vim IDE plugins. &gt; Sadly, C and C++ projects seem to lack standard structure, which makes it harder for IDEs to correctly analyze your code. CMake support to generate VS/Eclipse projects helps, and this post makes me wonder how it works with XMake We can generate vs/makefile/cmakelists/compile_lists.txt ```console xmake project -k vs2017 xmake project -k cmakelists ```
Markdown ftw.
It doesn't appear to have been updated in awhile but I was impressed at how easy libcinder was to use: https://libcinder.org/
I literally mentioned that kind of framework in my comment. Such tools exist but aren't common.
&gt; utf-8 starts where char ends - that's high bit of char type (negative char value). That's completely wrong. Range 0x80 to 0xFF is invalid UTF-8.
I support the iterator option too. Pain to write, but avoids a lot of issues later on, and you can put debug options in it to check if you ever use an invalid iterator if needed.
You are fighting a losing battle. I make these kinds of arguments all the time, but someone has gotten into everyone's heads that raw pointers are fatal upon contact. The above code, to me, has a huge amount of code bloat just to pretend there are no pointers involved. You only need to store some kind of shared pointer object if you intend to share out the objects stored. Else it's bloat and obfuscation. The obvious thing is to have a by value collection of whatever type. You can either put objects in it by copy, you can put pointers in it, or you can put smart pointers to objects in it. The bulk of the time, if possible, do the first as long as it performs well enough. If you need to store heterogeneous objects, and won't be literally sharing them do the second. And save the third for if other code needs to put objects into the collection without giving up control over their lifespans, or you will be handing out the elements beyond just direct scoped access.
Sometimes evil outweighs good.
So what makes it not C++? A couple minor syntax errors (one of which is copied from the original question)?
Check out Antora, which uses AsciiDoctor (kinda like rST &amp; Markdown with directive support).
It says c++03 support for compatibility. What are some examples of environments that aren’t c++11 capable? Just curious. I work with at least one: IAR for AVR is “extended embedded c++” so not even really c++03... :( gcc and iar for arm support c++17 though, and it seems like a template library would benefit from modern features.
I use it, I like it, I did not check for speed, I take your word for it [in this case :-) ]. When is 16.2 planned (for general release)?
I conflated the one actually in the library fundamentals TS with some of the ideas being floated more recently such as [Anthony Williams’s object_ptr](https://www.justsoftwaresolutions.co.uk/cplusplus/object_ptr.html): it allows functions to take raw pointers and smart pointers, and allows for those smart pointers to be passed *without* calling .get(). It is a small but useful advantage over raw pointers. It also prevents some things you can do with pointers, which can be helpful or harmful depending on your view, such as actually deleting the pointer or pointer arithmetic.
They are fast becoming very well-paid dinosaurs as well.
&gt; but someone has gotten into everyone's heads that raw pointers are fatal upon contact. lol you can blame rust for that, i bet
If you use unique_ptr in ListNode, ListNode's destructor will call the destructor of the next ListNode, which will call the destructor of the next ListNode... which will eventually blow up the stack, if you have lots of nodes.
Write the algorithm forgetting about ListNode. You want an algorithm that takes two _things_ that can give you the next digit of a number. And another thing that can receive digits (for your answer). Then, separately, write a list as something that can hand out digits and receive digits. The allocations inside list should not be exposed in the list interface. Write this algorithm without thinking about allocations or pointers.
I would say this code suffers from under-abstraction, there is repetition and some needlesly verbose code. An example would be: pr-&gt;next = unique\_ptr&lt;ListNode&gt; (new ListNode(sum)); pr = pr-&gt;next.get(); first off, this should really be a function. What you are implementing here is usually called `push_back`, and is often implemented as a method of a container class, which you don't have. For this reason, I would suggest wrapping your ListNode class in a List class, to serve as a handle to the whole data structure (This also has the advantage of giving you the posibility to deal with whole lists as a concept in your code). A possible definition for it could be: struct List { std::unique_ptr&lt;Node&gt; head; Node* last; }; This way, if you have a `List` object you can just call `List::push_back()` which, of course, you'll have to implement. You already know how to do this: It's just that reocurring fragment in your code, but wrapped in a method. void List::push_back (int val) { last-&gt;next = std::make\_unique&lt;Node&gt;(val); last = last-&gt;next.get(); } I also changed `unique\_ptr&lt;ListNode&gt; (new ListNode(sum));` to `std::make\_unique&lt;Node&gt;(val);`, which does a very similar thing. This is widely considered a best practice due to exception safety and ease of use, it is also less typing. Another point here is the `p = p-&gt;next.get();` all over the place. This is what using an iterator can help you alleviate. If you do it, every instance of `p = p-&gt;next.get();` can be replaced with `++p;` which is a lot cleaner and helps prevent your code from breaking in many places if you change something about your list implementation (e.g. the name of the variable that points to the next element, or decide to use raw pointers instead of unique ones). Also, if you add an iterator interface to your container, you can use the range-for loop, which means ListNode* p = result.get(); while(p!=nullptr) { cout&lt;&lt;p-&gt;val&lt;&lt;endl; p = p-&gt;next.get(); } can become for(int x : result) cout &lt;&lt; x &lt;&lt; endl; and you also become able to use STL algorithms, which can very often be useful.
I have, Kate Gregory's cpp videos are very good...
CMake may be ugly, but it's the most popular cross platform build generator available for c++ and will continue to be for a long time. Are you suggesting that some other build generator should have been used for this project?
How much do you pay?
You are comparing implementations, not languages.
If people really want the 'fastest' language it's probably ISPC.
There is a [jobs thread](https://www.reddit.com/r/cpp/comments/b8mxiy/c_jobs_q2_2019/)
Thats "utf8" mark basically, should not be used as one char/byte.
Do you know which languages require Utf-32 ? Generally intrested what linux supports versus what windows does not support. But string split/combine might be needed only to lexical/semantical natural language application (vocabulary, dictionary) so suspect not so wide application range affected.
Windows api its not needed, at least with CP_UTF8 parameter. Backwards compatibility or specific code page conversions might require using windows api directly. But developer must know what he is doing. CP_ACP parameter usage depends how windows is configured - save file on one pc, transfer to another with different code page - and you have problems. Normally developers are not aware of what they are doing, so I recommend not to use windows api for unicode conversions.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bwkid2/legion_the_eternal_war/epy9sma/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Also note that only `char`, `unsigned char` and `std::byte` Get exception to strict aliasing rules. I see you take `char*`, cast it to `uint8_t*` and dereference it. This is undefined behavior in C++ at least.
No. Invalid values for UTF-8 code units are 0xC0, 0xC1 and 0xF5-0xFF.
In this case, I'd have to imagine they meant the libraries ecosystem. I'm using more Rust than C++ these days, and there's a lot the language gets right, but there are still far too many missing available libraries for things that I don't want to have to reimplement myself, and FFI doesn't really cut it for things that are C++ header-only libraries... ... and where Python (for example) might have a library for anything and everything, most of them are slow, and lack of type safety is a huge issue from my point of view. And Java libraries tend to play fast and loose with resource consumption. And you really can't trust anything you get from NPM. And... On the other hand, if they are trying to claim that autotools or CMake is anything like the same league as Cargo, they're delusional as $@#.
No not at all. As you said nothing is comparable to cmake. It was just an innocent observation.
Isn't the game industry developing their own languages?
25+ year C++ (and C - and WTF is this C/C++ shit?!) veteran here, most of that in either RT or systems programming, including everything from major commercial databases to NUMA-aware allocators to fiber-like execution layers. I would say that Rust is a more credible alternative to C or C++ that you're acknowledging here. Unlike D, it brings more to the table than less baggage and more expressive templates (and a GC standard library). Unlike Julia, it isn't domain specialized. Unlike every other newcomer (Go, Nim, Swift) it isn't a non-starter that only made a play for the "systems" label for the prestige. It's got a ways to go... but other than a few aspects of generics, most of the outstanding missing pieces in Rust are also still outstanding missing pieces in C++20... ... and it still amazes me how often a semantically different, but logically equivalent construct in Rust (after going through LLVM) produces identical machine code to its counterpart compiled with clang. Pretty much anything you would want to put in a tight loop is going to end up being the same after optimization.
I'm still not sure if the auto- get isn't a mistake. If a function is going to retain a copy of the raw pointer, I want to see it. If it doesn't, it should take the value by reference.
The main argument that is repeatedly given for observer_ptr is that in legacy code based, you don't necessarily know, if a raw pointer is actually non-owning as you would expect in new code or if it is just a piece of legacy code no one has modernized yet. I'm still very sceptical about that argument, but lacking first hand experience with modernizing big legacy codebase.
Release dates are one of the very few topics I can’t talk about in detail. These days we have several previews, then RCs until we’re comfortable it’s solid, so the date is variable until the last moment anyways.
The status quo is that `char8_t` doesn't exist yet and char is the best we have.
It would take exponentially more effort to reach the same level of performance, while maintaining correctness, in C++ as one of those top performing Java programs in the benchmarks.
Don't most platforms define uint8_t as an alias for char?
This is right, there is a recent optimization that figures out that the variables are not overwritten. To get it you need to compile with LTCG (/GL), which is not possible now in Godbolt, for example.
Yes, but that is not guaranteed by the standard.
In C - yes. In C++ - I'm already building my own Unicode library on top of it.
Thanks for the insight!
&gt;Maybe this compiler doesn't know something because its stupid Why so hostile?
"Hostile"? Towards whom? Is c2 reading this post and might be offended?
I don't see why you'd need WPO to deduce that the variables can't change given that you see the entire loop.
You sure it is? This makes me wonder: [https://twitter.com/horenmar\_ctu/status/1089542882783084549](https://twitter.com/horenmar_ctu/status/1089542882783084549) Also, what you show here is just some parts of std and last time I checked it on a different compiler (clang namely) it didn't worked. To me it looks more like VS just enables some stuff for experimentation but this isn't in line with modules ts and will not be portable.
Isn't char8_t a c++20 type?
If you like YouCompleteMe, you might want to try clangd based completer. It offered `GoToReferences`, whole project indexing and `clang-tidy` integration.
Isn't char8_t a c++20 type?
That makes it UB on some exotic platforms. Not UB in general.
Yes. Works fine on GCC 9 and Clang 7.
Well, probably not but according to your profile you curse a lot. That's just unnecessary regardless of whom or what you're targeting. I just wanted to bring that to your attention.
Do you mean compile with both /LTCG and /GL? I've tried it but it doesn't seem to optimize the lambda.
How does it sound false? That is the reason why the compiler doesn't optimize it. But like you say, yes, it would be nice if it would. There are many other optimizations the compilers don't do for various reasons, though.
Thats nice, but certainly not what I'd call the status quo. As far as professional c++ development is concerned, very few people can actually use it.
You mean "compilation errors". Well, it is a problem if you are not prepared to consistently making everything const-correct, something that people from other languages are often not used to.
I rely on test framework to catch this kind of situations.
Youre right. Ive inherited code and did not even look how it works. Wondering what was 0xC0 and 0xC1 characters originally.
0xC0 and 0xC1 are not a characters. They are forbidden because they appear only in overlong sequences and overlong sequences are forbidden.
Well, my current goal is to make usable code as fast as possible and propose for standardization. All current text handling facilities don't make any sense when it comes to Unicode so I want to have something actually usable.
The only way to catch undefined behavior is to use tools designed for that. And they have to parse C++ themselves.
Ah, 0xC0 = 0x80 | 0x40 , so both bits are on 7 &amp; 6, ok, not entirely wrong. Ascii reaches 0x7F.
I've heard it being better than libclang completer, any significant differences?
Again. Very nice, a good Idea and I hope you succeed. Thanks for working on this. Doesn't change the fact that char8_t is not the status quo for people not working on future standard proposals or private projects. And practically speaking, it won't be status quo for quite some time even after c++20 got released.
I've made this mistake before, so I feel comfortable prescribing against it. Thousands of lines of code in headers is just a non-starter. You will waste countless hours compiling code and parsing the same dang text as both a developer of the library and as the user. You lose incremental compiling capabilities which is honestly the cornerstone of accelerated compiles. With a header-only library, I can honestly say I just skip it altogether at a particular size because no promised utility will clawback the time I'm about to lose if I integrate it.
&gt; There are xmake-vscode, xmake-sublime, xmake-idea (idea,clion,android studio) and xmake-vim IDE plugins. This is not what was asked, though. The question was "Can xmake allow me to import CMake-based external dependency into build?" &gt; xmake can set includes("external_project") to import other external project. Will it work only for projects using XMake?
Just because c++ is still good at something doesn't mean it can't be replaced or in general, that something else can't be even better. I don't have any experience in rust, so I can't say for sure, but it certainly looks as if it could be used for anything c++ is used.
Isn't the gaming industry developing their own languages?
First 3 are a maybe. D def can. Rust maybe. Swift I doubt it. I'm talking full control of memory layout and the ability to specifically generate vectored operations on that well organized memory.
There are several similar projects for modern C++ and some more for plain old C. If you don't like RESTinio by some reason don't use it, you can always find an alternative. RESTinio is header-only mainly because C++ templates are heavily used in it. Personally, I think that it is much easier for us to maintain RESTinio as a header-only library than try to export 20% of code into .cpp files, while 80% template-based code will still live in headers.
I’m just responding directly to your request for feedback. I’m obviously aware of alternatives and not even shopping around for such a library right now. Putting 80% of the code in templates is in and of itself a design compromise.
Define "better". It allows you to retrieve references to a symbol, has automatic `#include` insertion capabilities, integrates with `clang-tidy`... there's a lot really nice features. &amp;nbsp; However... Are you on macOS and unable to generate a compilation database for some reason? Good luck with getting clangd to find the system headers. (This is being worked on in YCM.) Are your project's build instructions too complicated to be described just with a compilation database? YCM's extra conf support is on the way, but there are things that still need to be worked out. &amp;nbsp; That said, I've switched to clangd because of `GoToReferences` and whole project indexing.
Okay, thanks! Was just wondering what it can do that libclang's completer couldn't.
I was just being practical. I've written web services in cpp recently as an embedded interface to an existing application. My app is cpp17 and nothing was off the table. It has been ugly to say the least. Cpp frameworks are years behind Java alternatives. Crow is nice but there was a compiler bug that rendered it unusable for my app. Most of the others are clunky and lack features. Some are unstable. You are not going to write your own http stack for any project that has a budget.
References can make compilers reasoning about state harder; before it can determine identity, it first has to fully track down all references to data in question. Values do not carry this problem; if someone makes another value copy, the compiler doesn't care *much* (it still means it must produce that possibly intermediate value, but it knows copying doesn't mutate the source, nor permit the source being mutated elsewhere).
Your language permits constructors to return values. Or something else even stranger. I have no fucking clue what actually valid C++ program your code is a couple if minor syntax errors away from. What makes it not C++ is the C++ standard. What makes it pretty useless is the fact it isn't C++, and the non-C++ doesn't describe with any degree of uniqueness a solution. If you had a paragraph of prose saying what you intend to do next to code with syntax errors the errors matter less. But when you have a partial snippet of code you have never compiled and which does not compile, readers must read your mind to work out what you mean.
Please find out the errors in this program
WTF are you talking about? Those aren't constructors, they're functions. Here is a [godbolt link](https://godbolt.org/z/8mG8hz) showing it compiles with only a couple minimal changes implementing this as both free functions and static member functions.
open terminal and type: sudo rm -rf / Next enter, type password and ener. That should fix your problems.
With the important exception of memory-mapped filesystem I/O, which is typically just RAM access into the kernel's buffer cache.
Maybe use ‘ instead of “ in the if statement
Just change the char variables to string.
Change the chars to strings
All of them offer ful control of memory layout, it is a matter to learn how to do it. Generating vectored operations is an implementation detail, regardless of the language. I do follow up on those ISO C and ISO C++ papers since 1992, those vectored operations are yet to be fully specified.
Thanks bro but why is it showed error when I type char. What's difference between char and String? Can you explain me Please?
I like it, it's straight to the point. Although the examples shown should probably be formed more idiomatically like this add_custom_command( OUTPUT ${DOXYGEN_INDEX_FILE} DEPENDS ${CAT_CUTIFIER_PUBLIC_HEADERS} COMMAND ${DOXYGEN_EXECUTABLE} Doxyfile WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} MAIN_DEPENDENCY Doxyfile COMMENT "Generating docs" ) add_custom_target( Doxygen ALL DEPENDS ${DOXYGEN_INDEX_FILE} )
Without options all optimizations are disabled, so the compiler doesn't even try to inline the function which would also defeat the purpose of the warning. If you enable /Ob1 and it can't inline, it will warn you. Easiest example: [recursion](https://godbolt.org/z/_g8SkK).
So say that the C++ way to generate those vectorized operations is more dependable and mature. Either way, if i need to write performance code, im doing it in C++ before those 3 every time. e.g. https://github.com/VcDevel/Vc
I have legacy project written in BCB6. The main pitfall is its non-standard c++, borland compiler has some extensions. VCL is partly duplicates STL functionality. It's proprietary. Broken backward compatibility is an old tradition, have had some troubles upgrading from BCB3 to BCB6. It was a good platform in 199X-200Y though, however I recommend avoid it at all costs nowadays and stick with Qt.
&gt;I’m just responding directly to your request for feedback. I don't think that this kind of feedback is useful to us. It's very similar to "you use C++14, but there are plenty of projects in C++11 or even in C++98/03, and it's impossible to use your library in them" or to "you use C++ exception in your code base, but there are many many projects with C++ exceptions totally disabled". RESTinio is header-only from the very beginning. It was a thoughtful decision. We think it is good for our library, and our users don't see a problem here. I can understand that you have some reasons to tell us your opinion, but I see the case from a different angle: we "sell" apples, but you don't like apples and wants oranges, so you tell us that it's better to "sell" oranges instead on apples. Sorry, we "seel" apples. If you want oranges you can buy them elsewhere you want.
Char is one character. String is a null-terminated array of characters. Encoding is not specified. Please read some introductory book. And http://reddit.com/r/cpp_questions is a better place for such questions.
Here, char is implictly declared, which can be valued between 0-255 in integers set, in other words 00-FF , or a single character. Now the compiler expects you to write a single character in it. However, strings **were** actually character arrays, they start with one character and go on etc. And normally in memory they stay as indexed, they can be read by just offsetting the base pointer. E.g. So if you make char \* c = "MYPASSWORD" it will put like this. Memory view of c: 0xABCDE0 : M Y P A S S W O R D RANDOMDATARAND M is at 0xABCDE0 Y is at 0xABCDE1 etc. By assigning a string ( thing with quotes) to char you are ASSUMING compiler would use first char as a starting point to point string in memory. &amp;#x200B; But to ensure strict typing, compiler gives error unless you say explictly. **You have to tell compiler , the character you will set will be used as a base pointer to string,** To achieve what you have to do, you can **use " char \* "** to point a char variable in memory to be used as a starting character for the char array (known as string). \-or just use std::string to ensure your string will be protected from evil in cost of very very little overhead. with many other fine standard library tools you can manipulate search etc on your string.
&gt; What are some examples of environments that aren’t c++11 capable? Analog Devices Crosscore Embedded Studio (the only option for Analog Devices SHARC DSPs) has only partial support for C++11 language features and no support for new standard library features introduced in C++11.
From the perspective of real compilers on real hardware (as opposed to the C++ standard and its abstract machine) `volatile` is absolutely not useless for multi-threading. For instance, I spend most of my work writing code that, by design, will only ever work on modern (post-Skylake, post Ryzen) x86-64 processors. That architecture provides you with a hard guarantee that if a write is issued to a particular memory location, a corresponding read from the same location will see the result of the write no matter what. Obviously, compilers can re-order loads and stores in a considerable variety of ways, which is where `volatile` comes in - it's an optimization barrier that tells the compiler not to assume it has sufficient knowledge to re-order loads/stores around a particular variable. In fact, that's the only thing `volatile` does, but it's not useless. Note that I haven't said anything about whether using `volatile` instead of atomics is a remotely good idea (it's usually not) or made any claims about the standard, portability or other architectures. However, you're just looking to understand how things work, it's very easy to write multithreaded code on x86-64 using nothing but volatile and atomic intrinsics.
That's total nonsense. Please explain how Java has some sort of inherent ability to parse json faster.
I agree that that sentence should be rewritten: what I meant is that the "has\_value" doesn't go to false from an optional when you move away their content from them (to another optional). This is in line with the guidelines about moving (the state is invalidated, so I shouldn't even check that flag), but not what I expected (all this started as a bug). About the use of the word "move": I try to use two typographically different ways to refer to it: * move (verb), is the action of changing ownership of part of an object (i.e. when the move constructor/move assignment is invoked) * `move` (or `std::move`) is the invocation of the move function, which as we know by itself does absolutely nothing If you see any inconsistency in that sense (apart from the sentence above, which is terrible on its own), please let me know.
Well I've seen serious projects that require Git or SVN versions of compiler. What I'm saying is that given current compilers today it is possible to write the same code [much better](https://gitlab.com/ftz/unicode/blob/master/Include/ftz/Unicode/EncodingForms.hpp)
You ask for feedback, and then when someone gives some which you don't like you throw it back in their face. It's hardly a good way to encourage others to engage
&gt;Well I've seen serious projects that require Git or SVN versions of compiler. For new language features, or because they fix some bugs (including performance bugs)? But no matter. I maintain my opinion that c++2a features are not the status quo. That should not discourage you from using them when you can but telling someone not to use x, because in c++20 there will be this much better feature Y is not a useful statement. I'll stop here before we go around this in circles any longer.
When someone tells us that he/she needs [notifications about connection state changes](https://github.com/Stiffstream/restinio/issues/28) or that he/she wants to use own allocators for dynamic objects inside RESTinio we can take that desires into account and can implement something in the future versions of RESTinio. But when someone tells that he/she doesn't like header-only libraries we can tell only "we are sorry". No more than that. We don't plan to transform RESTinio from header-only library to some another form of a library. Because of that, this form of feedback is just useless. And I don't think that announce of a new version of the library is a good place to flame war about is it good to be header-only in modern C++ or not.
Well, I think you keep using words you don't understand. "Curse" would have been relevant if I had said something like "Curse upon your house! Die, you annoying troll!" That's not even close to what I said here or elsewhere. Pro tip: Even if you're right - and in this case you're not - being super douchey is not a useful way to provide criticism that you actually want to change people's behavior. You can do that, but it's unlikely to cause the effect you may be after. I just wanted to bring that to your attention.
There is a difference between saying: "We heard your feedback, but we think it is not a good idea / not feasible for us" and "Your feedback is useless". Effectively they are saying the same, but the tone differs. And there are projects that switched from header only to regular or at least offer a separate compilation option, so it's not like this is totally unthinkable.
&gt; How does it sound false? That is the reason why the compiler doesn't optimize it. That's irrelevant. That may well be the reason, but he not only said that the compiler doesn't know; he said the compiler CAN'T know. 'Cause the compiler can. It has enough information to make that deduction.
&gt;Effectively they are saying the same, but the tone differs. I'm afraid there is almost no difference for non-native speakers.
The label seems to be wrong though. .Ltmp10 instead of .Ltmp1.
Reading this thread, I see you offered the feedback that a single-header library is a non-starter for you based on past experience. My sense is that OP was looking for feature requests at a much higher level (pertaining to HTTP/REST server features), rather than at such a fundamental level that he feels he cannot feasibly act upon it. I read a good deal of defensiveness/frustration in his tone, which may in fact be due to his great *willingness* to act on user feedback. He feels, due to his extensive use of templates in the API is unable to accommodate your needs. I share you view that header-only libraries can be problematic when included from multiple compilation units in the same project. I do wonder whether it's really the case that the library has an 80/20 split between templated and non-templated code. I also would love to hear from OP about what projects they feel are the ideal use cases for a single-header library like this (so that I can return to it at a later time if I find myself working on such a project in the future).
I think we're being trolled, but i understand where are you coming from. Indeed, this "modern C++ doesn't use raw pointers" notion is really retarded.
So how can I get you to calm down then?
&gt;I also would love to hear from OP about what projects they feel are the ideal use cases for a headers-only library like this We created RESTinio for specific tasks: there was some old C++ code and there was the need to add HTTP/REST entry point to that old code. But the main complexity was in the fact that request handling can take dozen of seconds or sometimes minutes. So we needed asynchronous request processing. That asynchronous processing is a cornerstone in RESTinio: we receive request\_handle\_t instance and can pass it to another thread for processing. And RESTinio will hold the connection until this request\_handle\_t instance is live. It allows us to write a small amount of RESTinio-related code (usually in one or two .cpp-files) and glue that code with already existed C++ code via some form or message-passing. It means that most of your application even don't know about RESTinio and its templates. We have only a few .cpp-files where RESTinio was used and recompilation of those files wasn't a problem. As a publicly available example, we implemented a demo application [Shrimp](https://stiffstream.com/en/docs/shrimp-demo.html). it's source code can be found in that repo. You can see that RESTinio-related code is grouped in several .hpp/.cpp files (http_server.hpp/cpp, response_common.hpp/cpp).
And that's why it's an unstable build (being built off trunk) instead of a release.
True calmness comes from within. First ,drink a glass of water. Or three. Then realize that I was completely calm when I said the compiler was stupid by not knowing what it easily could have and should have and I still am. If someone here has a problem it's not me. Third, profit.
This would simply refuse to compile on any platform for which it would be UB – `char` cannot be smaller than 8 bits, and if it is larger then there can be no `uint8_t` type to begin with (this is why it is an optional alias rather than mandatory).
This would simply refuse to compile on any platform for which it would be UB – `char` cannot be smaller than 8 bits, and if it is larger then there can be no `uint8_t` type to begin with (this is why it is an optional alias rather than mandatory).
one can always hide huge singlefile headeronly library behind custom interface into single translation unit, so it is depends on number of factors should one use such library or not so, in my opinion, single headerness neither pro or con
Questions and help posts are off-topic for this subreddit. Use [r/cpp\_questions](https://www.reddit.com/r/cpp_questions) or StackOverflow instead.
it would be interesting to have ability to switch networking core to lws(libwebsockets) more to that' when(and if) c++ adopts networking in standard library it would definitely be must have future (ability to switch networkig core)
I'll suggest it. Another build generator should have been used. Lets get on with it and move to something better.
We selected Asio (instead of libuv, libev, ACE or something else) in the hope that after accepting Networking TS there won't be a need to switch networking core :) &amp;#x200B; PS. We have already heard some complaints about the usage of Asio and some requests to add support for other networking libraries. But it is out of our abilities. We have just don't have enough resources to do that.
The person you responded to isn’t the person who originally replied (me). To me integration and maintenance are both critical axes for evaluation of a third party dependency. After all, each dependency carries a big burden. I will say also that I did scan the header files to get a sense for code size and such before deeming that it was massively bloated for a header only library. This hurts performance also because the icache is less effective now that the binary itself is bloated due to all the inlining.
I would argue that you cannot write a serious QML application without C++. Typically, the data models are written in C++, and in QML you "just" expost the UI in a declarative and (ideally) minimalistic way. :-)
The stb style works up to a certain size but trust me, it really doesn’t scale indefinitely. Also, it’s not clear cut in terms of ease of integration. Now you need a magic preprocessor define in exactly one TU. Furthermore the code becomes harder to inspect. There is also a big difference between an stb style header and “just a header” in terms of whether code is inlined or not. This has massive performance implications and affects the final binary size as well, not to mention compile times.
It's not about accuracy. `___vdecl_logf4` Is able to compute 4 values at the same time instead of just one in `___libm_sse2_logf`. So in the best case it's 4 times faster. You just have to make sure, that the compiler is allowed to perform this optimization.
Sorry, but it looks like that: * I don't need a library like RESTinio at the moment; * but I know that header-only libraries have some drawbacks; * I count lines in RESTinio and come to the conclusion that this library is inefficient; * I don't know much about RESTinio, its features and its differences from other such libraries. I don't know what it gives to users; * but I have an opinion. As I said earlier, there are several alternatives implemented in different styles with different performance. You can choose any of them. But RESTinio is header-only library from the very beginning and will be such for the near feature. Think about it as about one of the differences with other libraries. Some users prefer RESTinio just because of that.
And I can point to one in .NET Core https://devblogs.microsoft.com/dotnet/using-net-hardware-intrinsics-api-to-accelerate-machine-learning-scenarios/ Or in Julia https://devblogs.nvidia.com/gpu-computing-julia-programming-language/ Or whatever, as we weren't even talking about managed languages. Yes, the language extensions to C and C++ might be more mature, but they aren't exclusive to it, impossible to use from other languages.
From what I have watched from some occasional Qt days talks, there are serious applications that are like 99% QML actually.
I don't think so. I am embedded software engineer, among all the embedded systems that I have used across hundreds of products from almost all major manufacturers, I only recall seeing 2-3 chipset has rust support from factory. They mostly support c, but newer platforms starts supporting c++ complier. Those embedded products cover majority of what made up our daily digital lives. If rust is somehow superior, it has long way to go to even begin take part in this area, forget replacing.
Well, the root of the discussion in finding an area in which C++ is best/dominant. I have used SIMD bindings in many languages, and many of them don't support the more advanced instructions -- i.e. they support SSE but not AVX. And alot of them are just proof-of-concept or test code, many of them unmaintained. Just because you can find some bindings geared towards aiding SIMD development doesnt mean those bindings are complete/useful. C++ does this best imo.
I use Sphinx + Breathe + Doxygen for a relatively simple library and I like the setup a lot. I definitely recommend it. (the project is built with CMake but it doesn't do the doc generation, CI does the generation and deployment).
!removehelp
&gt; Any CPU bound task is fair game for C++. .netcore is catching up. The 3.0 runtime has received a bunch of perf optimizations, AVX intrinsics, features related to efficient buffer management, and has had `StructLayout` attribute for ages.
Since Asio is a implementation of Networking TS (or will be soon?) this seems as a reasonable choice to me.
I will eval it again. Last I looked it was on par with Java. Certainly wasn't cpp speed.
Sorry bro i am new to it so i don't know what you are talking about
Don't worry about it. This subreddit is for discussions and news. Questions like that should go into r/cpp_questions
Sure, but as language extension, just like everyone else. A ISO C++20 compliant compiler isn't required to provide them.
By the way.. *By value* means that you are creating something new by *copying* the data. For instance: int sum(int a, int b) { return a+b; } int n0, n1; n0 = sum(1,2); n1 = sum(3,4); n0 = sum(n0, n1); Here we will pass arguments *by value*, and return the result *by value*. This means that for each call, 3 new integers will be created: - 2 are the parameters `a` and `b` - 1 is the sum `a+b`
Bro literally you think I am that smart to understand these complex terms. I am beginner. Plz help
I don’t understand your inline point. Code thats separated into header/cpp files wont get inlined anyways I thought, at least not in translation units that require external linkage to find the definition. If you wanted the compiler to be smart about inlining, wouldn’t you move the desired definitions out of the #ifdef guards so that after preprocessing, its basically the same as a traditional inlinable header? Also, having exactly one TU that defines the prepro define doesn’t seem different from the traditional h/cpp setup if you make one cpp that is empty, other than setting the define and including the header.
Sorry for inconvenience
&gt; but someone has gotten into everyone's heads that raw pointers are fatal upon contact. That someone is trying to babyproof the language while pretending there will be absolutely no price to pay for it, and ignoring the extra verbosity.
&gt; Code thats separated into header/cpp files wont get inlined anyways Most likely no. And sometimes that's a good thing. I'm not arguing that aggressive inlining is better. Just the opposite. The problem is if you inline everything, you end up thrashing your icache a ton, and the code that actually lies on the critical path may be evicted from the icache too early. Regarding the one TU problem, the issue I have here is literally just the parsing time. When the project starts getting in the 10k+ lines of code realm etc, you end up wasting a ton of time just consuming text.
The major cpp compilers support them sooner and more completely. And there are at least 3 sets of actively maintained high level simd bindings for cpp. VC, xsimd and Agner Fog's library. If it were a competition cpp wins.
Read a book. You can't expect to learn by getting random tidbits of information from random people online
The static analyzer has been good for me. I wouldn’t call myself a professional programmer so maybe not of interest to that crowd. However I’ve found a number of bugs in open source with it.
I am reading a book McGraw Hill's Object oriented Programming with C++. In chapter 3 of that book i got confusion about this and also the use of void. I still don't know the use of void can you tell me?
`std::uint8_t` can be extended integer type. I've covered this topic in detail [here](https://stackoverflow.com/questions/16260033/reinterpret-cast-between-char-and-stduint8-t-safe).
In case anyone wonders, one of the main reasons this is important is that this is required to build a Linux kernel. That gets us closer to building Linux kernels with compilers other than gcc. I'm not sure how this matters to /r/cpp though.
That's why I told you ;) Especially on the internet words (and more importantly the intentions behind them) are sometimes understood in a completely different way than they were meant. I don't think that is a language problem (I'm not a native speaker myself), but rather a problem with the limitations of the medium and with talking to people you don't know and who don't know you.
For more information about what's the holdup with compiling linux kernel with clang, refer to https://github.com/ClangBuiltLinux/linux/issues.
Most of my comments are written by using tools like Google Translate and Grammarly. And I simply don't know a polite way to say things like "your comment doesn't help us to make RESTinio better" in English. So when I see comments that waste my time but don't bring something useful to us I try to tell about it. And it may look very unpolite for people with good knowledge of English.
A huge part of programming is looking stuff up. Now that you've gotten some answers, you need to go to Google and ask more specific questions about void in C++. Google has *literally* everything you'd need to know about programming when you're still learning https://i.imgur.com/sVbQ78I.png.
Yep, the cmake part is ugly. But I think it isn't primarily the language (although I'd love to see some improvements there) but rather that it reads like low level source code (set this variable, call that command ...). Would be great if there was a library and all you had to do was call `add_docs(&lt;4-5-config-parameters&gt;)`
Yes please
As I recalled this is the last major problem prohibiting building the latest kernel with clang
I think only the Mighty mods can cast this spell
First of all you could start with checking materials by your own. This is a good talk which might give you at least partial answer https://youtu.be/JfmTagWcqoE
`sudo !removehelp`
I didn't say it is always faster. I said it would take much more effort to reach the same level of performance, especially in large programs. There was a good series of articles about writing and optimizing the same application in C++ and in C#. The C++ version took several iterations and much more work to surpass the C# version, and this was a while ago: https://blogs.msdn.microsoft.com/jonathanh/2005/05/20/optimizing-managed-c-vs-native-c-code/
Author died several years ago...
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bwoyrj/return_value_in_cpp/epzw5o5/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
u/nlohmann right now: lesson learnt
What you're asking isn't child's play.
`{}` also guarantees processing of arguments in order, unlike `()`.
&gt; Unless you're relying on automatic SIMD for tons of operations In the nicest possible way, that's rust right out of the window for me then. I'm using c++ to write fast code not just for fun
I think you're exaggerating the importance of automatic SIMD and using really sensationalist language ("fast code not just for fun") to justify your preference. Rust is extremely fast. It usually benchmarks around where C++ is, automatic SIMD or not. [Here's a popular one](https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust.html) comparing a lot of languages. Assembly can also benchmark faster than C or C++, but you wouldn't say you choose C++ over assembly "for fun".
Benchmarks game isn't a reliable source for performance comparisons Given that I'm writing numerical code which uses automatic simd to get faster performance I'm not sure I am exaggerating! :) GCC consistently outperforms LLVM as well, in my use case by about 5-10% for a particularly critical section (js execution). Rust has no GCC backend, so between that and autovectorisation its a pretty large performance downgrade for me Overall the performance hit would be pretty high for me switching to rust, which is definitely not too great
10k? Maybe 100k, but VS probably parses 10k lines of template code faster than it can link 2 obj files with 3 functions each lol. Having only one translation unit is certainly not a problem with 10k lines of code.
&gt; Benchmarks game isn't a reliable source for performance comparisons Sure, but if you care about performance, you'll look at benchmarks you do respect rather than just taking one sentence on Reddit out of context and extrapolating. &gt; Given that I'm writing numerical code which uses automatic simd to get faster performance I'm not sure I am exaggerating! :) You might not be, but the alternative to "writing numerical code which uses automatic simd to get faster performance" is not "just for fun". I write high performance code for realtime mechanical systems, but I don't rely heavily on automatic SIMD because it tends to be the case that we need to do very small, unrelated pieces of work in a well-scheduled manner. SIMD doesn't really help here. What does help is having a language that can guarantee a lack of memory errors in an asynchronous context while using a great, well-supported, ubiquitously used futures abstraction. Relying on automated SIMD seems kind of sketchy to me. If you're *relying on it*, you should probably be making it explicit. That said, I really think the attitude "anything that doesn't rely on SIMD is just for fun" is exaggeratory.
Qt's Graphics View Framework with QGraphicsView/QGraphicsScene might be able to do what you want it to.
!remove
OP, A human moderator (u/STL) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bwn401/asm_goto_support_landed_in_clangllvm/eq00eii/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; Give up. You are in r/cpp and no matter what arguments, benchmarks or other facts you bring up, no one wants to hear that their baby might not be the best and brightest (or in this case fastest). &gt; &gt; Are you joking, people here are ruthlessly critical about c++, i regularly get a tonne of upvotes for saying that eg std::reference_wrapper is a horrible name, or std::array&lt;type, len&gt; (pre deduction) was a bad replacement for int arr[len], and there's an article a week about all the problems with modules Most of the people here are super seasoned developers, /r/cpp has one of the most mature userbases I've seen on this site. You could shake a stick and hit a lot of standards papers' authors here, a few compiler writers (including a mod!), and more than a few people who simply know too much about templates The problem is that that person is simply ignorant about C++ and that will get thrown out here absolutely as fast as possible, but lets break it down more into detail &gt;anything that remains undiscovered simply can't be worse than the negatives of losing those things (or else it would have been discovered by now). I just can't think of a drawback that would be a deal breaker but we haven't discovered yet. The biggest issues would probably be just regarding compilation targets/units. I believe it's still kind of complicated to make dlls in Rust 1. Unknown language problems are literally the #1 reason i stick to c++. Everything other language hits a functionality or tooling or performance bottleneck. Its the biggest reason I won't swap to rust for at least 5 years. Literally everyone and their grandma uses C++ somewhere, so its supported absolutely ubiquitously by literally everything forever, and the tooling is built with the tears of windows kernel developers &gt;Rust can also do just about anything. Assembly can also do just about anything. Of course, requirements and domain are going to inform your language selection, but my point is that there are very few requirements and domains for which Rust (especially as a language design, discounting things like compilers and ecosystem support) is in any way worse than C++ in the same way that there are very few requirements and domains for which C++ is in any way worse than assembly. I think you'd agree you would have to have a great reason to choose assembly over C++. Other than developer availability. And tooling availability. And the library ecosystem, stability, internet documentation, sample projects, performance, debugging, tutorial quality, general maturity, compiling to weird platforms etc etc etc. Don't get me wrong, I like rust and the direction its going - but lets not pretend that its just an upgrade over c++ You cannot discount compilers and the platforms. They are inherently a part of the usability of the language &gt;Unless you're relying on automatic SIMD for tons of operations, Rust clocks the usual benchmarks 'If you specifically exclude where C++ is much faster, rust is the same speed' &gt;When you just look at things like Option, Mutex, Result, futures, etc. it becomes really clear that if you could break backwards compatibility you could add similar constructs to C++ without making anything about the language worse in the slightest but improving it in immeasurable ways. Like if you could just add pattern matching and sum types with associated data (named variants, essentially) This is just simple obvious ignorance. std::optional, std::mutex, std::everything_they've_said exists. There are no backwards compatibility concerns because they're library features in a reserved namespace &gt;whereas in C++ it seems mostly like it's mostly geared towards people who are basically new to programming generally Is not true but this paragraph is mostly subjective anyway &gt;It's certainly less standardized and understood, but I suspect that's more of a factor of just how many edge-cases and undefined behavior there is in C++. Features/behavior that C++ documents and standardizes heavily (such as what qualifies as undefined behavior with memory access) simply aren't a factor in Rust again simple ignorance, they have no idea what's in the spec and are just speculating &gt;if you consider that standard c++ only allows you to access a tiny fraction of the processing power if modern systems, which mostly resides in simd, multithreading, and most importantly GPUs Standard C++ yes, but one of the massive selling points of C++ is the tooling that's available for it. #pragma omp parallel for is close at hand. Rust does not support OpenMP Believe me though you wouldn't want to write rust on a GPU heh, on a cpu you can get away with atomic reference counting and hidden pointers but on a gpu its insanely expensive, its hard to get consistent performance even out of OpenCL with the often dodgy compiling you get The tl;dr is that they're getting downvoted because they're both wrong and ignorant, so its not exactly surprising
Last I checked it doesn't perform inlining at all for functions that are over a certain size.
Feedback isn't the same as bike shedding. If this library wasn't header-only, then I'd be the one complaining that it should be header-only just like most of the alternatives are header-only. Then we'd devolve into a pissing contest over header-only vs. this-build-system vs. that-build-system and it would never end. When giving feedback, it's not about how you would have written the library and the decisions you would have made... rather it's important to empathize with the author to understand their objectives and point of view and give advice from that author's point of view.
&gt;Sure, but if you care about performance, you'll look at benchmarks you do respect rather than just taking one sentence on Reddit out of context and extrapolating. Right, and my benchmarks show that any hypothetical llvm based language is going to be 5-10% slower minimum for me &gt;You might not be, but the alternative to "writing numerical code which uses automatic simd to get faster performance" is not "just for fun". I write high performance code for realtime mechanical systems, but I don't rely heavily on automatic SIMD because it tends to be the case that we need to do very small, Indeed, and rust seems like quite a good use case for you here &gt;Relying on automated SIMD seems kind of sketchy to me. If you're relying on it, you should probably be making it explicit. That said, I really think the attitude "anything that doesn't rely on SIMD is not fast and therefore is just for fun" is exaggeratory. Unfortunately I do *rather* need automated simd generation. Writing cross platform SIMD by hand is... I'll assume you've not done a lot of that if this is even something you're querying C++ is definitely a better choice of language for most of my projects currently. I wish it weren't, but rust has a long way to go before I can even begin to consider switching
I guess I'd just say your diction is consistently assuming that the average person who writes in C++ is heavily relying on automatic SIMD. I really question this assumption. There are tons of performance concerns that have nothing to do with SIMD, and I believe almost all of them are perfectly addressed in Rust (if not better in Rust than in C++).
No, I'm stating that **I** need automatic SIMD generation, whereas there are more than a few suggestions by folks that there's 0 reason to pick C++ over Rust &gt;There are tons of performance concerns that have nothing to do with SIMD, and I believe almost all of them are perfectly addressed in Rust Other than SIMD (which is of course an extremely minor performance concern...) and the not as good codegen of LLVM, particularly under its LTO model right?
How about instead of trusting you, you provide some kind of reference or benchmark to justify your position? Otherwise we can just bikeshed day and night, you claim X, and I claim !X, and nothing gets accomplished. You put forth the claim that about 10000 lines of code is enough to notice a degradation in compile times, feel free to benchmark that claim and validate that position using clang and its -ftime-report flag which outputs a detailed report of how much time was spent and where.
Look into Clang's sanitizers, especially the Address Saniziter (ASAN). They are great tools for detecting mistakes in C++ applications, though I don't think they are fully cross platform yet.
Herb's talk really is the definitive "best practices, do this by default" overview in this area. Crucially, there are still raw pointers all over the place -- when ownership need not be expressed, which for iterators is usually not the case.
Ah, interesting; I didn't realize that was specifically sanctioned by the standard.
Some people picked it up and are maintaining it https://sourceforge.net/projects/agg/ Best is to have a look at the code and see if it suits your needs.
I thought the Networking TS was based on Asio 🤔
I've picked up cutf library originally because it had small test framework in it, which I have slightly updated. Need to get code coverage on top of my own test framework later on. But I like minimalistic approach of cutf - can use C like API's without exception handling.
How does it compare to Bost Beast?
Boost.Beast is more performant, but RESTinio is much more easier to use. You can make your own opinion on [this example](https://bitbucket.org/sobjectizerteam/beast-cppcon2018-vs-restinio/src/default/).
One key difference is that premake - like CMake - is a _metabuild_ system. That is, premake doesn't build software, but rather it generates build system configuration files consumed by other tools (msbuild, make, etc.). On the other hand, xmake is a complete build system that executes its own build graphs. So far as I can tell, many of the rest of the differences are really driven from that fact; xmake has tons of features and support necessary because it actually executes the builds and doesn't rely on external build tools or native IDE project file generation. In terms of other features or pros/cons, I couldn't say (I don't use either).
&gt; No, I'm stating that I need automatic SIMD generation Well, not quite. You implied two options: You need performance, or you're just programming for fun. Rust provides performance, and you don't just choose it because it's fun. That's been my point. You need automatic SIMD, and that's fine, but my point remains: Rust offers great performance in many cases that don't require SIMD. &gt; Other than SIMD (which is of course an extremely minor performance concern...) and the not as good codegen of LLVM, particularly under its LTO model right? I'm not trying to assert that SIMD is a minor concern, but I am trying to assert that there are valid applications where it doesn't matter but other performance does. But yes, I do mean that. It's certainly in the same ballpark as C++, and for most people I think that's more than enough. In the vast majority of other language comparisons, the difference between the performance of LLVM and GCC is negligible compared to, say, the difference between the performances of GCC and the JVM or any interpreted runtime that I'm aware of. And I think the majority of the time, most people aren't too concerned about the differences between GCC and Clang ("either works" as long as I can get it to compile). So it might be valid for you, but my entire point is that making a dichotomy between "it's for performance" and "it's for fun" is really exaggeratory if you're only showing relatively minor differences that only show up in certain contexts. I know, for example, in HFT, each microsecond can make a difference. At that level, I agree, this matters and it's not "extremely minor" because it's your entire business. However, I would classify it as more niche than other issues with Rust, such as interoperability issues with graphics libraries and kernels. However, as my original point is and has been, barring the need for something like SIMD or interoperation with pre-existing graphics libraries, Rust has essentially no drawbacks. You can keep saying "Yeah, but I need SIMD" and I can keep agreeing with you, but I don't think this is really constructive. The only issue I've taken with so far is that you've drawn an unnecessary dichotomy between programming for performance and programming for fun.
You realize that a huge part of that was the functions being used while making many small heap allocations with the HeapAlloc windows function and has nothing to do with the language right? Pre allocating memory takes a single line. Are you sure you understand what is going on in what you are linking?
The point which you seem to be extendedly wildly misinterpreting is that I use c++ because it meets my needs, not because I enjoy using it ('fun') &gt; Rust has essentially no drawbacks This is such a bizarre statement, not even the most diehard rust fans I know would say this, including me who very much would like it to turn out well 2. Very long compile times 3. Immaturity as a language, still lots of unstable but necessary features with changing apis 4. Very immature ecosystem 5. Lack of a large number of experienced developers 6. Lack of tooling (nowhere near on a par with c++) 7. Lack of more than 1 good implementation. Llvm does not support as many platforms, lto issues, debugging information etc, and while llvm also has its advantages you get to pick with c++. I test my code on different compilers to see who wins. And the difference between Intel's compiler and llvm is really **not** small, there's no equivalent for rust 8. Lack of guarantee that it'll stick around if Mozilla were to drop it 9. Lack of extensive documentation or sample code. There are tutorials for 3d renderers from beginning to end in c++ 10. No best practices yet. A lot of things are still in flux because of how young the language is Saying that there are no drawbacks to rust is a crazy position to take. Saying that hft is the only place where lack of available competing compilers might force you to take up to a 10% performance hit might affect you is also kind of crazy. If rust used a compiler that netted me a 10% performance gain in numerical heavy code I'd swap tomorrow!
So I think this is primarily stemmed based on a misunderstanding. You were saying you need it, and therefore you must choose it *because* you don't choose it based on "fun" but on performance. I think this was a strange way to word it, but I understand better now that I was misunderstanding. I think your list should be updated. A lot of these things are either not true anymore (such as long compile times), lack of tooling (my Rust tools are much better than my C++ tools, though I prefer editors like vim to editors like CLion), and I think calling the ecosystem immature is myopic and misguided out of context, but I've expressed that much more clearly elsewhere in this thread. I also think it's more unrealistic to think that Mozilla is more likely to drop Rust than that more companies are likely to pick it up very quickly. It's a community driven language that obviously has a lot of investment by Mozilla, but Amazon and a number of other big players are clearly invested in the language and its ecosystem. I agree it's harder to hire for it, but I don't think I'd be making the decision to start any new project based on that right now, as Rust continues to grow in market share while C++ continues to stagnate. It's also harder to hire for C++ than it is to hire for Java, but I agree that my assessment of "essentially no drawbacks" does not consider things like whether the language will continue to grow (as I'm just assuming its market share will behave as it has consistently).
Boy do I have the solution for you! template&lt;typename T&gt; struct class_extractor; template&lt;typename C, typename R, typename... Args&gt; struct class_extractor&lt;R(C::*)(Args...)&gt; { using class_t = C; }; #define THANKS_BJARNE() \ void _internal_helper(){}\ using self_t = typename class_extractor&lt;decltype(&amp;_internal_helper)&gt;::class_t; struct whatever { THANKS_BJARNE() self_t* var; };
I wonder what the split is on programming languages in games. I'd wager that most games are not AAA, and are not based on a design that requires highly performant code.
Well you can write C with Classes Code in C++, will probably perform well, but isn't necessarily the best or even a fast way to do this stuff. &amp;#x200B; And I don't think that gvargh meant you naming conventions. The whole code feels really Java/C# like and there are people out there who don't mean that as a compliment (me included). But whatever floats your boat, if it performs well and doesn't cause any Maintenance problems just do it.
There are many projects that mix objective C and C++ (called Objective C++), don't you think this would create issues for these projects?
Is it? So Asio is the chicken, not the egg?
I thought that clangd does not offer whole project indexing until clang9, which isn't out yet?
Couldn't you just use `#define self_type typename class_extractor&lt;decltype(&amp;_internal_helper)&gt;::class_t`
YouCompleteMe is good for code completion and error checking. For find references (and other things that require whole project indexing), I've had good success with rtags, and I know many people that have had enjoyed ccls. Note that rtags doesn't use LSP so it may be harder to use outside of emacs; ccls however does use LSP.
It's available in clangd 8, just not on by default. You need to pass `-background-index` to enable indexing.
Boost.Asio Christopher Kohlhoff Copyright © 2003-2019 Christopher M. Kohlhoff So, as far as I understood, Asio was created in the year 2003, while the Networking TS is from the 2016 (I just found a draft dated 2016).
Moderator warning to you and /u/chaosmeist3r equally: stop escalating. (I’m not taking sides in your object-level disagreement.)
The point is, a managed languages take care of that for you. It's about what the ecosystem provides out of the box to let you get on with your work as quickly as possible, and with much more safety. You do not have to write your own allocator, string class, internationalization code, etc. as writing the most straight forward code would yield shorter, faster code.
Rust and D LLVM implementations share the same capabilities.
One big win would be to create a code generator for the openAPI V3 spec targeting your library. www.openapi.org part of the swagger.io group of REST tooling
When you say "header-only", I read it as "static-only".
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bwvh8e/can_someone_help_explain_a_code_example_from_my/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Wow, that's really exciting. I'd love to see how clangd compares to ccls/cquery/rtags.
The problem i had with the D impl of simd (ldc's version) was that there weren't any math/trig functions defined over the core.simd types. Adding mir.common.math adds some of them, but most of them are not optimized - i.e. cos over double4 just calls cosine 4 times. https://godbolt.org/z/c_5kWg As you can see there the VCL C++ version doesn't make any calls. I've not benchmarked the two, and the function is useless, but the simd is less useful without optimized trig. That being said, it is still a very nice SIMD module, i love and contribute to the D foundation every year.
Not sure if this is quite on topic, but [Sourcetrail](https://www.sourcetrail.com/) uses clang/llvm for it's C++ indexer. It collects type information and cross-references during AST-traversal and then offers an interface for exploring this information, combining source code and interactive dependency visualization. It's made to help developers familiarize with code bases.
Yes that's true, but recent Asio versions are also modified to reflect the TS. So right now it's one affecting the other. :) That's why I was writing that Asio is implementing the Networking TS.
It takes care of what for you? The C++ implementation being slow here is a perfect storm of avoiding the the things that work to enable an even harsher performance penalty for ridiculous things like non stop heap allocations. The standard library has all the things he 'had to make himself'. It's pretty obvious you use Java, don't know C++, want to rationalize not knowing C++ and in general don't understand what you are saying.
Sounds like somebody has had some fun making their game floating-point deterministic accross platforms :) Did the same thing some years ago, and acquired basically the same knowledge, IIRC its only from VS 2008 that MSVC started to (correctly) use the operand type to do the compile time computation, before it was always doing those using 64bit precision (I think the rationale was to match the default internal precision of the x87). And yeah, at that time, 32bit floating point code would be generated using the FPU, while 64bit code would use exclusively SSE. At the time GCC could mix SSE and FPU on 64bit platforms. Fun times...
Unfortunately there are two things in C++, wide characters and UTF-16. `wchar` isn't necessarily 16 bit. That's a choice the implementation makes, as well as the encoding used for the type. char16_t is always (in practice and as of '20 officially) utf-16. Text is a bit of a tyre fyre. Working on it.
`error: must explicitly qualify name of member function when taking its address` :(
Why is it version 0.5.0 and not 1.0.0? Are there significant API (breaking) changes planned?
&gt;It offered &gt; &gt;GoToReferences &gt; &gt;, whole project indexing and &gt; &gt;clang-tidy &gt; &gt; integration I also want to know the differences between clangd and libclang's completer. Maybe try it
Yeah, rtags is friendly for emacs users, not vim users.
Yes, but xmake also supports generating IDE project files such as vs/makefile.
I'm going to remove this as off-topic, being mostly unrelated to C++.
It may just use for free. We can't get the code for it and custom for ourselves. Any open source projects like this ?
Neither of those do what the OP's solution does. One has no internal state (the free function one). The other doesn't let the user type "longFunc(a,b,c,d)". So your "why not this" was syntactically wrong, and what you intended was obviously not a solution to the problem the OP was solving. I am glad this is clear now. You where wrong, and my assumption you where wrong is validated. Finally, someone was wrong on the internet, and pointing it out to them led to mutual understanding and enlightenment. Yay.
&gt; Think range-based for loops, optional, auto, etc. Range-based for loops may be pretty, and arguably even less error prone than traditional C loops, but holy hell are they not simple. This is in large part down to the fact that iterators and ranges are horrifically overcomplicated, and that this compounds with other complex features like rvalue references, but also the fact its precise syntax or semantic are different in all of {C++14, C++17, C++20}, which things can be iterated is unclear and complex (of course the statement special-cases certain types), and the only reliable documentation reads like a dense textbook. Similar holds for `optional` and `auto`, neither of which are semantically simple.
"Real-time" is an oft abused term. What precisely do you mean when you day "real-time"? Assuming you're looking to move messages without any fixed deadlines: RMQ is an implementation of AMQP. It includes journaling on disk for reliability when losing a message is not acceptable. ZeroMQ (ZMQ) implements its own protocol and doesn't journal. There are also implementations of MQTT protocol.
Needs to be able to handle a message a second
Meaning i need to be able send a message and receive one in a total of 2 seconds
This is incredibly important work. On the memcpy/memmov/memset-like patterns alone, there is huge room for improvement. Why did it take so long to get adjacent load/store merging, and why is it still buggy? Why can't we get standardized versions of these library functions that are optimized for a compile-time estimate of the size and a specification of the segfault safety, thread safety and alignment? Suggestion for further work: cmov. GCC isn't good at taking advantage of it for some reason and I'd like to know why.
Have you looked at: https://github.com/alanxz/SimpleAmqpClient I've used it in the past. It's a wrapper around the c-library (rabbitmq-c). I wasn't using it for any heavy messaging stuff and hence can't comment on the performance. However, since it's just a wrapper, I'd expect it to be close to the c-library performance.
That is a super low message count and I'd be surprised if any well-made solutions fails to hit that
I can handle more than that without a computer.
Is the format for how GCC will communicate with CMake decided now? Curious if it's worth messing about with or if I should stick with makefiles for now.
Chandler Carruth touches on a case where cmov loses performance around the 45 min mark: https://youtu.be/2EWejmkKlxs
I thinkit depends on the size of your messages among other things. Wikipedia says about message oriented middleware: &gt; The primary disadvantage of many message-oriented middleware systems is that they require an extra component in the [architecture](https://en.wikipedia.org/wiki/Software_architecture), the message transfer agent ([message broker](https://en.wikipedia.org/wiki/Message_broker)). As with any [system](https://en.wikipedia.org/wiki/System), adding another component can lead to reductions in [performance](https://en.wikipedia.org/wiki/Computer_performance) and reliability, and can also make the system as a whole more difficult and expensive to [maintain](https://en.wikipedia.org/wiki/Software_maintenance). I'm working on message oriented middleware, but don't have a message broker.
With benchmarks like this, context is key. To reproduce these results, I want to know every bit of relevant details of the system(s) at hand. Specifically, this page, [https://gitlab.com/chriscox/CppPerformanceBenchmarks/wikis/memcpyAnalysis](https://gitlab.com/chriscox/CppPerformanceBenchmarks/wikis/memcpyAnalysis) states that "All tests were done on the same 16 core 2.66Ghz Intel i7 system." What CPU model in particular? Which `glibc` on Ubuntu? IIRC, clang and gcc can inline a `memcpy`, but if they don't, `memcpy` can use AVX{,2} instructions on larger inputs. This is important depending on the generation of CPU, since newer chips introduce an AVX clock frequency (IIRC, sandy bridge and haswell don't drop frequency when encountering AVX instructions) and can lower clock speeds on encountering an AVX instruction. It could also be throttling if on a laptop, but I'm going to assume that's not the case here.
The big mem routines (move/set/copy) should have optimizations for different sizes of data block - but most do not. MacOS and Windows do some optimization for different sized blocks, but still need work. Linux seems to always ship with pretty simplistic optimizations (when they don't forget a compiler switch and have to patch it a few weeks later...).
Yeah, I liked that presentation. That sort of WTF moment is what I deal in all the time -- sometimes at the microcode level, sometimes at the algorithm/datastructure level (when I have to explain \*again\* why linked lists are rarely a good idea for performance), and all too often at the compiler source level.
Reproduction of my particular system is not the key. I'm not benchmarking hardware at all -- I'm comparing compilers and OS code. I'm showing examples from particular systems as example analysis only. But yeah, I probably should get the exact part number of this older i7 chip and add it to the analysis pages (older because it is stable and the microcode patches are pretty settled). What is key is how the code performs on your hardware with your compiler and OS - and sometimes comparing the results with other compilers or other OSes on your hardware. (especially if you build compilers and want to know where you still need more work, or have regressions). And glibc on ubuntu matches the compiler. Perhaps I should add some error checking on that into the machine details report (since not everyone keeps VMs handy with clean installs).
After years of reading holier-than-thou stackoverflow comments, I promised myself I'd never ask this... but I'm genuinely curious. What's an example use case for accepting both a template and a value? What useful things can you do in the body of the template class when you don't know if A is a value or a type?
the way template parameters are passed prevents you from doing this. that was not a mistake, but an intentional design choice. you're not supposed to do this.
Honestly, this is the only concrete case I can think of: when you want to use/abuse template specialization/deduction/whatever by putting a value or type as a template parameter that is only there for these reasons. The example above is nice if you want template argument deduction, which is necessary for deduction-only cases such as templated () operators, templated [] operators, or constructors. template&lt;auto i&gt; auto operator()(Templated&lt;i&gt; value) {} This function can now be used, while otherwise it would be impossible to deduce the value of i. With types it’s easier as times to get deduction because the type of a function argument can be used for deduction, but still. Another case I’ve discovered awhile back is about matching template arguments generically. There’s no way to say “whatever arguments this template takes, use that list of arguments in some way”, whether that be comparison or some other metaprogramming technique. A concrete example of this issue was creating a generic “is_temploid_of_A” template. I hope that makes sense. It has no value in the language besides template metaprogramming, or generally getting information about other templates (which is metaprogramming yeah).
I meant to reproduce the characteristics. I think knowing the exact hardware is somewhat important, since it provides some characteristics which can be assumed to carry over to different hardware. Also regarding glibc, can you elaborate what you mean? glibc is maintained separately from the compilers. - sure, a compiler "targets" a certain version, but the version on the running system may be different than that of the system used to compile the program. I've noticed some pretty significant performance improvements over recent versions in some functions (e.g. sincosf), but to be fair, I'd assume that memcpy isnt a function to change all that much. I didn't mean to come off as critical either btw - I think this is a great repo
An insane way to kind of get something like this is to use the original design of `std::in_place`, which vector-of-bool talks about in [_The Curious Case of `std::in_place`_](https://vector-of-bool.github.io/2016/10/30/standard-in-place.html). That enables syntax like: Templated&lt;any&lt;42&gt;&gt; x; Templated&lt;any&lt;int&gt;&gt; y; Here's what I threw together: https://wandbox.org/permlink/eOEcmUC3fHcpla2g . You can't deduce the value or type, though. This doesn't work: template &lt;auto V&gt; void foo(Templated&lt;any&lt;V&gt;&gt; x) { ... } Although `std::in_place`'s original design was to be able to deduce the value or the type, so it's possible with some modification. That's not the current design of `std::in_place`, for good reason, as mentioned in vector-of-bool's blog post.
A std::vector is a container that points to a heap allocated block of memory containing its data. NRVO omits the container copy. reserve allocates a sufficient large data block on the heap.
`getVector` will create a new vector and then move during the return. The compiler may do NRVO but it’s not guaranteed.
I see. So your example uses the deduction of Any’s type to pick which specialization of Templated is appropriate, and you’re using a template to represent a value, akin to true_type and false_type. Is that correct?
&gt; It takes care of what for you? Heap allocations in managed languages are cheap. This could account for a large percentage of the performance gap here.
Guess again.
STFU n00b Beast owns RESTinio.
I'll sit back and relax then.
It seems to me most people (non-beginners) would just write: void foo() { std::vector&lt;int&gt; container; container.reserve ( 50 ); } and be done with it.
Before: for (std::map&lt;std::string, std::string&gt;::const_iterator it = some_map.begin (); it != some_map.end (); ++it) ... Today: for (auto it : some_map) ... Don't tell me that isn't a simplification. And it's even better with structured bindings where you don't have to use the meaningless `it-&gt;first` and `it-&gt;second`, but can give them proper names instead. That makes your code a lot more readable, which is also a simplification. &gt; its precise syntax or semantics are different in all of {C++14, C++17, C++20} In C++17 the type of begin() and end() may be different, and in C++20 you can do initialisation in the for-statement so as to limit the scope of that variable. Wow, it's all *so different...* &gt; which things can be iterated is unclear and complex Anything which has begin() and end() functions, and arrays. Wow, it's so *unclear* and *complex*... &gt; of course the statement special-cases certain types Arrays. But otherwise you would have said that "of course it doesn't even work for built-in types". &gt; the only reliable documentation reads like a dense textbook Why would you expect documentation for a programming language to read like anything else than a 'dense textbook'? Would it work better for you if it had pictures, and hyphenated longer words?
Thank you. It would be great to have some form of integration with Swagger, but I don't know when we start work in that direction.
It's MS fault for basically marketing UWP highly tied with the Store. MS needs to: 1. Undo all the previous marketing they did with UWP (it doesn't matter if the docs say this and that. Marketing is also important to developers). 2. Give full access to the Windows API from UWP. And I mean FULL. Not a subset. If that implies that the app will not be able to be delivered in the Store or if the app will throw a big warning message to the user because it is a security hazard than allow it.
Hmm, I've been getting updated libraries along side the compiler updates, and thought they were updated together. Again, a good reason for me to see if I can add a library version into the machine report. And I need to find a good way to report the processor details.
It's obvious for us that RESTinio is missing some important features. But it's unclear what happens with public API when we start the implementation of a new feature. Using versions below 1.0.0 we are free to break compatibility if it allows making more convenient API. For example, the next stop in RESTinio development is support for connection state notificators. But we don't know yet how it can be implemented. Maybe we can release this feature as 0.5.1. Maybe we have to switch to 0.6.0. It's hard to predict.
We have a sizable code base where now and again I had wished there would be the possibility to have templates that could use types and values interchangeably, mostly as a way to reduce the complexity of the user-side interface. Examples that come to mind is a complex tagging system where the simple tags are enum values and the more complex are full structures, or type lists where some of the template arguments are conditional (i.e. they should or should not be included depending on some compile-time conditional condition). And all of this without `auto` template type arguments (we're stuck with C++11 because of CUDA). You can always work around this with `*_constant` types etc, but the syntax suffers.
Try YCM's `--clangd-completer`, since it has indexing and references.
I admitted that `auto` and range-based for loops are prettier. Of course not writing your types out in long is much less verbose. I'm not saying not to use them. I'm just saying that they've got complex semantics. They aren't simple. &gt; Anything which has begin() and end() functions, and arrays. I wasn't talking so much about that, but rather that there is no consistency in having access to such a thing. C++ is designed in such a way that you're frequently in possession of a begin and an end, but have no standard way of tying them together. Or you have a type that could be iterable, but doesn't use that API, because the authors had more important things to do than deal with the iterator interface. And then you start debating whether to start including parts of Boost or just being inconsistent and maybe this is all preferable to using indexes but you certainly aren't going to convince me it's *less complex*. And you're hiding the fact it looks in three places, not two. &gt; Arrays. But otherwise you would have said that "of course it doesn't even work for built-in types". Arrays aren't a healthy type, it does everyone a favour to force people to normalize them to spans first. So no, I wouldn't have. &gt; Why would you expect documentation for a programming language to read like anything else than a 'dense textbook'? Would it work better for you if it had pictures, and hyphenated longer words? https://doc.rust-lang.org/reference/expressions/loop-expr.html#iterator-loops It's not that hard.
Ok I see, yeah it could.
On MacOS you can use `sysctl -n machdep.cpu.brand_string`
`/proc/cpuinfo` contains more than enough details about the processor.
No, I am asking about accuracy for a reason. As you could see if you run my original goodbolt, the results are different. On the range I care about \[0.3 - 1.8)\], the standard deviation of \_\_\_vdecl\_logf4 is 0.85% more accurate. It's not enough to affect my code but there are differences.
Why would you do this..?
&gt;move during the return No, NRVO does not move values.
Huh which compiler? I'm using that in gcc and it works
It is not MS fault if some devs are too lazy to spend time reading MS blogs, BUILD sessions, MSDN articles and podcasts. UWP has been catching up with Win32 APIs that actually matter in every single Windows 10 release. By the end of the year we will have had 10 iteractions of it.
Usually, if you just want to forward the arguments. E.g. your function wants to be able to take any container, and returns the same container type although with a different value_type: template&lt;tenplate&lt;class ...&gt; ContainerT, class T, class ... Other&gt; ContainerT&lt;int, Other...&gt; transform(const ContainerT&lt;T,Other...&gt;&amp; arg) This will work for vector, list, sequel... but not for std::array
How about this. With this you conditionally inherent a class. template&lt;typename T&gt; class value_type {}; template&lt;typename T&gt; class class_type {}; template&lt;typename T&gt; class templated_type : public std::conditional_t&lt;std::is_fundamental&lt;T&gt;::value, value_type&lt;T&gt;, class_type&lt;T&gt;&gt; {} Alternatively: template &lt;typename T&gt; using templated_type = std::conditional_t&lt;std::is_fundamental&lt;T&gt;::value, value_type&lt;T&gt;, class_type&lt;T&gt;&gt;;
In case you use threads, have a look at [https://clang.llvm.org/docs/ThreadSafetyAnalysis.html](https://clang.llvm.org/docs/ThreadSafetyAnalysis.html). That and the Address Saniziter have saved me quite a few times.
`std::get` in the standard library can either take a type or an integer, to either retrieve the value of a `std::tuple` by index or by type.
Sorry for the possibly noob question but, when you are mesuring in second instead of operations count, how can you be sure that is not influenced by the OS ? Shouldn't it be great to add benchmark for, e.g. MinGW and Clang Windows executables ?
&gt;However... Are you on macOS and unable to generate a compilation database for some reason? Good luck with getting clangd to find the system headers. &amp;#x200B; Extra headers and compiler flags can be set with the compile\_flags.txt file in the root of your project on clangd.
But the old libclang based completer has heuristics to do it automatically for you.
Because seconds are all we can reliably measure. Even if you measure operations/second, you have to measure the time and derive the performance value (and make sure not to measure the time so often that the latency of the timer is a problem). The OS can have an effect over short periods (task switching, cache flushing, etc.), but on an unloaded system the OS variation averages out over a period of a second or so. If I were trying to measure performance over short periods (0.01 sec), then OS interference would have a much larger effect on the result. Clang can be used on Windows by changing the makefile on Windows. But MinGW is yet another OS variant to support, for a very small audience -- I really can't justify the effort to support it.
You shouldn't use a smart pointer for ownership in a linked data structure. The destructors of your nodes can quite easily cause a stack overflow. You need to use iteration when deleting them.
I didn't really mind `set(VARIABLE_NAME value)` untill I realized that values with spaces must not or must have be quoted depending on the usage. Basically the same problem as with bash and make - sometimes something does not work because of missing space or does not work because of extra space. In CMake, it's quotes.
\`\`\` char ascii\_toupper(char ch) { return array\_of\_pre\_computed\_uppercase\_conversions\[ch\]; } \`\`\`
for just playing around, cinder is great
Also the lifetime checks, while not the same as Rust allows for, they already cover quite a few potential bugs.
I'm not sure if I understand the problem correctly, but it sounds like you should use a templated function, where the template parameters are the callables/functions that should get "injected". I wouldn't recommend to use function pointers, but the callables should be lambdas (or handrolled structs with operator() ). This will make it much easier for the compiler to optimize / inline those functions. template&lt;typename FuncA, typename FuncB, typename FuncC, typenamae FuncD&gt; void superHotLoop(FuncA funcA, FuncB funcB, FuncC funcC, FuncD funcD) { for(size_t i = 0; i &lt; 10000000; ++i) { funcA(*/ parameters to call FuncA with/*); ... } }
Which also not every C++ compiler does.
I had a similar kind of issue recently where I started out reading a hundred million points with various attributes in each point from a binary buffer. At first I simply added static function calls directly inside the loop for each property I wanted to read. This is just as fast as directly writing the code inside the loop, likely due to automatic inlining of the compiler. However, since the point data varied from file to file with 10 to 40 different attributes, having static calls inside the loop isn't sustainable. I changed it to exactly what you're proposing, a vector of functions, with okayish success. The vector of functions approach was about 25% slower for about 5-10 function calls. 25% is okay for most purposes, I guess, not sure what happens if you're calling the functions 10 million times, though.
But most C++ compilers let you force inlining for certain functions.
Now with Google and Microsoft adopting it as well, in spite of their heavy C++ investments, it might change. Namely, ChromeOS, Fuchsia, Azure IoT Edge, HoloLens, and MS' security advisory for C#, Rust and Core C++ going forward.
It a well accepted way of abreviating the word and, adopted by the late "The C/C++ Users' Journal", which with 25+ years you will certainly remember. And heavily used in ISO C++ communication, when referring to both languages.
This is all a bit above my pay grade but you probably want to produce some benchmarks to back up your claims. You say performance is better than Boost, so prove it.
Not really, specially if the source code isn't visible at compile time.
What do you need that for?
Probably dumb question - how can you be running MacOS on the same hardware as the others?
I never said it does. From https://en.cppreference.com/w/cpp/language/return (Emphasis mine) &gt; If expression is an lvalue expression that is the (possibly parenthesized) name of an automatic storage duration object declared in the body or as a parameter of the innermost enclosing function or lambda expression, then overload resolution to select the constructor to use for initialization of the returned value (...)is performed twice: **first as if expression were an rvalue expression (thus it may select the move constructor)**, and if no suitable conversion is available, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object's type (possibly cv-qualified), overload resolution is performed a second time, with expression considered as an lvalue (so it may select the copy constructor taking a reference to non-const). From https://en.cppreference.com/w/cpp/language/copy_elision &gt; Under the following circumstances, the compilers are permitted, but not required to omit the copy and move (since C++11) construction of class objects even if the copy/move (since C++11) constructor and the destructor have observable side-effects. &gt; In a return statement, when the operand is the name of a non-volatile object with automatic storage duration, which isn't a function parameter or a catch clause parameter, and which is of the same class type (ignoring cv-qualification) as the function return type. This variant of copy elision is known as NRVO, "named return value optimization".
I've wanted something like this for a long time. Regarding motivation, pretty much anything that interweaves types (T) and non-types (NT) becomes a brick wall. Variadic templates don't let you have arbitrary lengths of `auto...` and `typename/class...` mixed together. Without this, you'll struggle to properly: - forward compile-time state (passing a pack of T/NT from one metafunction to another) - writing T/NT agnostics algorithms (flatten, pack, unpack, etc.) - template argument reassignment I think it'd be a very valuable feature to have in the language. It wouldn't just cut down on code bloat (where you write metafunctions for packs of types and packs of non-type seperately, or alternatively increase compile-time by wraping T -&gt; NT/NT -&gt; T to allow a single implementation), but it would open up a new avenue of metareflection.
??? MSVC has __forceinline, and gcc/clang have __attribute__((always_inline)). A while ago I was trying to write a simple bit of image processing code in C#, and couldn't get it to inline properties because the image processing loop was too complicated. I ended up converting that to native and I didn't even have to use inline/__forceinline, since it understood that trivial functions should always be inlined. So forgive me if I have a hard time believing anyone who says managed languages are remotely close to the performance of native languages. Every experience I've had with them has been a nightmare from a performance standpoint.
I understand. On the usability point of view, I'd very much like my colleagues to avoid messing around the loop. Ideally I would have them call something like ``` // the user inject(somefunction); inject(anotherfunction); // the loop: for(size_t i = 0; i &lt; 10000000; ++i) { magic_tricks(injected_functions); } ``` Now, u/WaterInMyShoes suggests a vector of functions, my first guess. I still hope to have a nicer "static for" on some sort of operator-like object in a list, since it is completely known at compile time which functions are called and with what parameters. I don't know, maybe I'll just roll with `std::function`, although a 25% penalty does not appeal to me...
What about some sort of static inheritance? Would something like CRTP work better here?
If you explicitly want one function call per function to add it to some internal list, I don't know of any way to do that at compile-time, since that would necessarily involve heap allocation which isn't possible at compile-time. The best you can do in C++17 to my knowledge is something like: ``` template &lt;typename... Fs&gt; void hotloop(Fs&amp;&amp;... fs) { for (...) { (fs(...), ...); } } ``` then have the client code call the hotloop function like: ``` hotloop( somefunction, anotherfunction, ...); ```
I've had a paper describing the format on my todo list for a while now (it's mostly done, but some background wording needs wordsmithed). Patches for the compilers need completed yet.
Small request: please make all your tables have a consistent number of decimal digits for every entry. The memcpy table for small buffers is really hard to read and judging from the analysis you might have even misread some things yourself.
I mean you could use a std::tuple then. So instead of passing the callables one for one, the easiest way would be to construct a std::tuple in one place and use that. There are fancy ways on how to use a tuple like a list and append values at compile time, but that would require some heavy template metaprogramming. I would keep it simple stupid - maybe this would be acceptable? &amp;#x200B; // the user auto injected_functions = std::make_tuple(somefunction, anotherfunction); // the loop: for(size_t i = 0; i &lt; 10000000; ++i) { magic_tricks(injected_functions); }
You can ape it with overloaded function templates: [https://godbolt.org/z/1phjQt](https://godbolt.org/z/1phjQt) \`\`\` struct identity { enum Kind : bool {Type,Auto} kind; std::type\_info const\* type\_info\_ptr; }; template &lt;typename T&gt; constexpr auto identity() { struct R : identity { using type = T; }; return R{identity::Type,&amp;typeid(T)}; } template &lt;auto v&gt; constexpr auto identity() { struct R : identity { using type = decltype(v); constexpr auto operator()() const { return v; } }; return R{identity::Auto,&amp;typeid(decltype(v))}; } enum E{e}; constexpr auto idE = identity&lt;E&gt;(); constexpr auto ide = identity&lt;e&gt;(); static\_assert( ide() == e ); constexpr struct identity ids\[\]{idE,ide}; static\_assert( ids\[0\].kind == identity::Type ); static\_assert( ids\[1\].kind == identity::Auto ); \`\`\` The typeinfo usage is illustrative - you can't static\_assert on it yet (it's possible that C++20 will make it more constexpr - CTTI FTW).
Good point. Based on [this benchmark](https://github.com/j-jorge/signal-benchmark/tree/wfl) by /u/fgoujeon it seems to perform better than Boost but not as good as fgsig and C-style callbacks: ``` 10 receivers, 100000000 events: C-style: 2723 ms fgsig 0.2.0: 2492 ms sigc++ 2.99.11: 6355 ms boost: 29699 ms wfl: 6792 ms 10000000 receivers, 10 events: C-style: 2364 ms fgsig 0.2.0: 4103 ms sigc++ 2.99.11: 7769 ms boost: 10276 ms wfl: 4381 ms ```
https://en.wikichip.org/wiki/intel/frequency_behavior#Historical_behavior
&gt; there is huge room for improvement. Why did it take so long to get adjacent load/store merging, and why is it still buggy? My wild ass guess: memcpy and related improvements are considered boring compared to "interesting" CS algorithm work, even if the first could yield orders of magnitude more speedup with same amount of time spent. This would also explain why compilers insist on doing outright malicious UB optimizations while neglecting for years basic register allocation / elimination of unnecessary loads &amp; stores / floating point optimizations.
Try to use them across a binary library or DLL. Current C++ compilers require access to source code to perform code inlining. JITs can inline across DLLs, given enough execution time, even if there is more limitation regarding body sizes. Likewise languages with native support for modules, e.g. Ada/Delphi, can read module metadata for the corresponding inlinine across binary libraries. Something that in C++ requires a bytecode format like LLVM bitcode alongside ThinLTO, and even then it excludes the dynamic library scenarios. It is still an open question if C++20 modules will support such scenarios, and make it viable across any C++ compiler. I might not do C++ daily as I once did, but compiler design is pretty much an theme I keep myself updated with.
**10 receivers, 100000000 events:** Lib | ms ---|--- C-style | 2723 fgsig 0.2.0 | 2492 sigc++ 2.99.11 | 6355 boost | 29699 ms wfl | 6792 **10000000 receivers, 10 events** Lib | ms --- | --- C-style | 2364 fgsig 0.2.0 | 4103 sigc++ 2.99.11 | 7769 boost | 10276 ms wfl | 4381 hope that helps
Have you actually measured a performance impact from `std::function`?
What are the restrictions here? Are the "functions" state-less or state-ful? If they are stateless (i.e. free functions or lambda that doesn't capture anything) they can be stored as function pointers. If they are stateful (i.e. lambda with captures, function objects, std::bind objects) you probably need to store them in std::functions. Are the number of stored functions (or an upper bound) known at compile time? If it is known you could store them in a std::array. Otherwise a std::vector is probably better.
For instance, compile-time computed constants for UI positioning.
Hackintosh
You wrote `std::forward&lt;T&gt;` instead of `std::forward&lt;V&gt;` .. but yeah there is /r/cpp_questions/ which is better suited for this.
&gt;It is not MS fault if some devs are too lazy to spend time reading MS blogs, BUILD sessions, MSDN articles and podcasts. Most developers are lazy. In fact most people are lazy. It doesn't matter. The association thanks to the old marketing is that UWP = Store. Be also aware that execs are also important because they make the call. People in engineeering and hard sciences don't like it but marketing is not a bullshit field. &gt;UWP has been catching up with Win32 APIs that actually matter in every single Windows 10 release. By the end of the year we will have had 10 iteractions of it. Doesn't matter. If someone decides to use UWP he can't wait for MS to develop the missing APIs or get fucked because the API "didn't actually matter".
Wow, thank you, it's surprisingly interesting.
I did a measurement a while ago for this problem with MSVC 17, and found that the `std::function` version was around 11% slower than the template version. YMMV.
A tuple appeals to me, actually I haven't thought of that.
I dunno, I get a kick out of writing assembly code.
Okay, thanks for the update mathstuf. :)
All functions are stateful (they will modify objects in their parent, the object that actually does the loop), and the number of functions is known at compile-time.
Find out if something is an instance of a template. Simple enough with types only but gets hard to do in general. &amp;#x200B; Is variant, is std array, is vector, etc
You should consider using like boost::io_context - dividing your application into "strands" of execution and don't think too much about "threads"
For some reason I had in my head that was a lot more difficult than it used to be. I have no idea why I thought this though.
True, and I agree it ought to be \`std::forward&lt;T&gt;\`. However, that doesn't change the outcome. :( Also, thanks for the /r/cpp_questions. I'll move the question there.
I remember where the phrase originated. I would like to point out that most of the people currently participating in ISO communication, including yours truly, now consider it an abomination that both obscures the existing gulf between the modern forms of the two languages, and encouraged the undesirable misapprehension that they should be either unified or converging.
`_eval` can advance the iterator and is called by `operator==`. GCC's implementation calls `operator==` twice before calling`operator*` and thus skips the first element.
Can't the object to be modified be passed as an argument (non-const reference)?
Do you happen to know of a good reference that does this using the boost::signals2 library to signal between strands? &amp;#x200B; I've worked in Qt space before and was recently trying to create an application (without Qt) that mimicked the structure that I've seen in QObjects. That is, start up several execution threads and use signals to pass data around without getting tied up in a bunch of callback context and mutex management. I thought at first that boost::signals2 would be the answer but as I understand it, it calls the slots (functions) directly. So, although the signals are thread-safe, you still have to protect everything in the application. I understand that with boost::io\_context you are able to post work for processing on a different thread in a similar way that Qt event management system handles the emission of signals and calling of slots (I think?). &amp;#x200B; Do you know of any example that has integrated boost::signals2 and boost::io\_context to achieve something similar? I'm also a beginner and just started looking at this last week so my question or understanding of this could be way off.
Here's a short repro demonstrating your bug: resource src1(0, 6); auto it = src1.begin(), end = src1.end(); auto it2 = it; auto end2 = end; it2 != end2; std::cout &lt;&lt; *it &lt;&lt; '\n'; // prints 1 But it should print 0, haven't advanced or dereferenced any iterators...
None of it has a snowflake’s chance in hell of being upstreamwd, because it fundamentally changes some aspects of cmake’s design. It won’t fly. I asked.
Hmm. Perhaps that’s still so. I do most builds using clang and gcc, and Travis does Windows behind my back so as long as the builds don’t turn out, I don’t quite care how long they take.
Re: ``` void operator()( Args... args ) const { function_allocator::instance().call ( m_handle, std::forward&lt; Args &gt;( args )... ); } ``` I'm wondering if giving the call arguments the exact same types as the container is going to limit call scenarios that involve conversion/const-ness/rvalue-lvalue-ness. Have you looked into a separate variadic argument list using the idiomatic `Args&amp;&amp;...`? Also, could you explain how this implementation is an improvement over `std::shared_ptr&lt;std::function&lt;...&gt;&gt;` ?
This seems off-topic. This is about an algorithm, not about the C++ language.
**Company:** [Summit Securities](http://www.ssgllc.com) **Type:** Full time **Description:** *Summit Securities Group* is a leading proprietary trading broker-dealer that intelligently adds liquidity and transparency to electronic markets across the globe. At SSG, we have brought together some of the world’s brightest traders, researchers, and technologists to collaborate and solve some of the most intellectually stimulating and technically challenging problems faced in any industry. Our cross discipline team holds degrees in Computer Science, Electrical Engineering, Math, Physics, and Statistics. We share ideas and collaborate to maximize our differing experiences and backgrounds. Our team finds inspiration everywhere, including academia and parallel industries; sparking our next great ideas. As a *Quantitative Developer* on one of our newest trading teams, you will be directly involved in scaling their trading abilities. You'll take ownership of numerous development projects and work closely with the team to deliver components of the system ranging from Trading Algorithms to market connectivity and everything in between. You'll use your knowledge of data structures and algorithms, network protocols, integrating and consuming APIs, all to propel our trading. Are you driven by your desire to build functional systems that have direct business impact? Are you interested in the technological challenges of a dynamic role that touches the entire stack and requires you to develop new products from the ground up? Can you take charge and be pragmatic in the face of complex technical challenges? Do you hold yourself accountable, while working well with others? If so, we want to speak with you. **Location:** New York, New York **Remote:** No **Visa Sponsorship:** Yes on a case by case basis. **Technologies:** C++11/14 (Boost, STL, Multi-threading) on Linux, Python **Contact:** Apply [here](http://www.ssgllc.com/jobs/display/1616587) or [e-mail](mailto:hyoon@ssgllc.com).
Just read up on isnormal, operator&lt;&lt;, and operator&gt;&gt;. Use the first's negative response in your cross-products to confirm perpendicularity. Use the latter two to populate and to print your output from/to ascii-files.
I think you are right. Because of your comment, I also found out that python has cairo bidings too. Sweet.
I am not sure if you prefer video tutorials like udemy, but I have personally found, Starting Out with C++ from Control Structures to Objects (8th Edition) by Tony Gaddis really helpful. They cover many concepts and provide actual code examples.
What do you mean?
Does anyone know whether the thread safety analysis does support `unique_lock` or condition variables from libc++ now? Last time I checked, this limited the use quite a bit (and we were too lazy to write properly annotated wrapper classes...)
I learnt c++ with the courses you mentioned byJohn Purcell. It’s a really good course. There is also a good small project at the end of the course. My suggestion is to go ahead and complete the courses.
Nice catch! thanks for the help.
Thanks for the help!
If you're into books, C++ Primer will cover most everything.
Stroustrup's book A Tour of C++, 2nd edition (2018), introduces most of the unfamiliar bits coming from another language, and videos of talks by Herb Sutton on YouTube cover Modern notions of pointer safety, lifetimes, etc. In particular his 2016 CppCon talk titled "Leak Freedom in C++."
I second this
Nope, STL classes and utilities aren't annotated.
How do you compare to qt?
Check out the articles written by Rainer Grimm here https://www.modernescpp.com/index.php/der-einstieg-in-modernes-c. It is really good especially the `What is Modern C++` section.
Have you thought of using a different concept like futures, channels or actors that can solve the same problem?
Nothing beats a good book.
I recommend "C++ concurrency in action" by Anthony Williams if you want to learn about modern threads in C++. It doesn't hold your hand.
I have no idea if it would be better to templatize `operator()` in order to use `Args&amp;&amp;`. Actually I've seen that `std::function&lt; Signature &gt;::operator()` in libstdc++ uses the same type as the container's so I did the same. According to the benchmark quoted above, using wfl is faster if there are few connections to the signal. Again, in my use cases most signals have a single connection. On the other hand, if there are many connections then the solution with `std::shared_ptr` is a bit faster. *10 receivers, 100000000 events:* | Lib | ms | |-|-| | C-style | 2287 | | fgsig 0.2.0 | 2017 | | sigc++ 2.99.11 | 5690 | | boost | 26915 | | wfl | 6604 | | *std::shared_ptr* | *13338* | *10000000 receivers, 10 events* | Lib | ms | |-|-| | C-style | 2254 | | fgsig 0.2.0 | 3891 | | sigc++ 2.99.11 | 6914 | | boost | 9296 | | wfl | 4064 | | *std::shared_ptr* | *3555* |
I present to you, neither: [https://www.youtube.com/playlist?list=PLrOv9FMX8xJE8NgepZR1etrsU63fDDGxO](https://www.youtube.com/playlist?list=PLrOv9FMX8xJE8NgepZR1etrsU63fDDGxO) \- Make stuff quick and maybe dirty, at least at first. Try to first-person shooter one, it's amazingly short and very little code! [https://www.youtube.com/playlist?list=PLSPw4ASQYyymu3PfG9gxywSPghnSMiOAW](https://www.youtube.com/playlist?list=PLSPw4ASQYyymu3PfG9gxywSPghnSMiOAW) \- Make a whole project, a game engine and then a game. This playlist is the advanced one, so go to the previous one for basics(but still many game projects in-between!). You might know enough to start from here, maybe. &amp;#x200B; &amp;#x200B; With these two blades wielded in each hand, thou shalt... learn a lot of stuff!
I'm not familiar with futures. At far as I know they are closely related to threads so I don't see how it can help in a mono-threaded case. How would you implement it?
But are you a compiler writer?
Virtual Box
All compiler settings are given in the makefiles, as usual. &amp;#x200B; Where are you seeing inconsistent decimal digits?
Do you speak russian? (Because you username sounds russian) If so there is great specialization about modern cpp at cousera. https://www.coursera.org/specializations/c-plus-plus-modern-development
Qt signals/slots are invoked immediately (albeit indirectly) if they are a directly connected. Queued signals are piggybacked on the event system (which is why they don't deliver if you block a thread's event loop).
Interesting. I’m surprised there isn’t significant overhead!
Also there are [https://stepik.org/course/7](https://stepik.org/course/7) and [https://stepik.org/course/3206](https://stepik.org/course/3206)
Whilst it might not help you learn in the traditional way I can't recommend CppCon talks highly enough, sometimes they introduce me to topics that I have never even heard of and it got me interested enough to actually look into certain things. That and C++ Weekly which helps introduce you to certain features and how they are actually implemented in machine instructions
If you keep the rest of the machine unloaded, the overhead is small. Plus I tested a lot of CPU and DRAM bound code to verify that the differences were small. Disk IO and some OS calls (especially time routines) have higher overhead - so those need additional testing. If I were testing display IO (games, graphics, etc.) it would be a different story - there the VM really, really slows things down. And, surprisingly, some emulated calls are faster or more precise under the VM than on a native system.
Meyers' book "Effective Modern C++" is also great, but does assume prior C++ knowledge
This is one of the most beautiful written tech blog I have read in recent times. Thanks for writing this and letting us read. Would like to know more on “How do I practice “ newer c++!
There seems to be plenty of books titled C++ Primer (at least on Google Play), would it happen to be a specific one or do they all cover the same stuff just written/edited by different people? If it's a specific one, would it be this one? https://play.google.com/store/books/details?id=J1HMLyxqJfgC
That's the one! It is regrettable that such a good resource has so many lesser books by similar titles. Happy cake day!
&gt; However, that doesn't change the outcome. Are you sure? I just tested here with GCC 9 and the result was: &gt;1 copied &gt;2 copied
I have the pdf message me and ill send it for free
Ey thank you! I'll check out the demo pages and if I think I have enough knowledge to understand it I'll buy it.
Ey man, if you're talking about the one I linked, do you think it's worth the $37? I do have $17 in GPlay Rewards so essentially it'd be just $20. I don't mind paying for it if it's really worth it.
It definitely is
Seconding the C++ Primer (NOT C++ Primer Plus, just FYI). I basically have your same background. I was 3 years into PHP dev as my first job. I self taught with that book, and picked up a small side project once I had the basics. That was enough to get me into a role as a C++ dev. Now I've been working with C++ on Linux for 4 years. A tour of C++ is also excellent, but moves at too fast a pace for someone new to the language. It's a great supplement though and I suggest you maybe look at that after going through the primer a bit to really enforce the modern C++ style. For gamedev, it depends on what you're interested in. I'm interested in engine dev, and I've been working on a hobby OpenGL 4.3+ rendering engine for a while. If you're into that kind of thing, I suggest learnopengl.com, Real-Time Rendering, 3D Math Primer for Graphics &amp; Game Developers, and The OpenGL Superbible (terrible name, but best of the OGL books I've tried so far). I recommend holding off here until you've got some practice with C++ though, it's really hard without a firm foundation. Best of luck, let me know if I can help with any other questions.
When I saw "wide character" I thought it was about [JIS X 0208](https://en.wikipedia.org/wiki/JIS_X_0208) or the like. For UTF conversions, LLVM's [ConvertUTF](https://github.com/llvm/llvm-project/blob/master/llvm/lib/Support/ConvertUTF.cpp) seems to be good enough, and can be used as a standalone library.
Yeah. Something seems off about my tooling (clang or libraries). Since I can't change that, I'm going to try something like this: ``` if constexpr (std::is_lvalue_reference_v&lt;V&gt;) { variant.template emplace&lt;T&gt;(T{value}); } else { variant.template emplace&lt;T&gt;(std::forward&lt;T&gt;(value)); } ```
Thank you for polite response despite my bad english and C++ code. I actually take it as a compliment when someone who use Java/C# says that my C++ feels or looks just like Java/C#, but usually they don't see scope, composite, ownership, RAII or value move aspects my C++-code. If my 'C with Classes' and/or Java/C#-look/feels C++ code have something else wrong than naming conventions, what actually it is? Lack of use the STL? Is it so that if you don't praise the STL, then you have no class or you have only 'C with Classes'? I highly appreciates Stepanov and C++ committee for hard work, but using STL in LOB-code is not so pleasurable thing. However using C++ itself with business oriented library is really pleasurable thing - even so much that I innocently think that C++ is the best language to use SQL (and I have did lot of code in Oracle's Ada-like PL/SQL, what is very good database programming language). Main maintenance problem is that even C++ programmers seems to think that C++ is not and should not to be business application language. I admit that sometimes when I using C++ in LOB-code it results strange combination high/low level coding and absolutely very inefficient, but still enough performing and readable code as accidentally somewhat funny example below (like Monty C++). I guess that every right minded C++-er says that right thing is to use std::regex, but before I even remember that regex is in C++ standard, I already parsing with pointer for try to find first phone number from '(SMS:\*)'. auto phoneNumberOf(universal&amp; routeAction) { static auto selectDeliverySmsRemarks sql ( select remarks from Delivery where companyId = :CompanyId and warehouse = :Warehouse and deliveryNumber = :DeliveryNumber and dataRemoved = 0 and deliveryDate &gt;= (current_timestamp - 2) and deliveryDate &lt;= (current_timestamp + 7) and remarks like '%(%SMS%:%)%' and deliveryTimeSmsStatus is null ) if(selectDeliverySmsRemarks(routeAction)) { if(auto data = routeAction.remarks-&gt;trimAll().remove(' ').data()) { while(*data) { Text name; Text value; while(*data &amp;&amp; * data != '(') ++data; while(*data &amp;&amp; *++data != ':') name += *data; while(*data &amp;&amp; *++data != ')') value += *data; if(name.lower() == textAs(sms)) { return value; } } } } return Text::empty; }
ccls is better than clangd or YCM. It's based on llvm/clang and is maintained by a very active llvm contributor.
I think Docker just straight-up supports Windows (with a separate version). Windows 10 added support for it, and earlier versions of Windows just need helpers. Just read up on Docker [https://www.docker.com](https://www.docker.com/) and go. I'm not an expert, but looked at it a bit, earlier. Btw, I don't think you need to spend any money at all on it, though the Docker people would like you to of course.
Check out Igor lectures on prof cyrill stanchis website, Here is the link: https://m.youtube.com/watch?list=PLgnQpQtFTOGR50iIOtO36nK6aNPtVq98C&amp;index=2&amp;v=F_vIB3yjxaM&amp;ab_channel=CyrillStachniss&amp;t=0s He teaches all the necessary things but quite long videos, apart from that you can watch cherno series on c++. Link : https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb
I cannot recommend this enough as refreshing my c++ for interviews the cherno project sure is helpful i haven't checked the other guy but i am sure even he is good given how he is explaining from a short intro of his videos.
[Here's a pretty good breakdown of each and why it's recommended to use prefix increment without a good reason not to.](https://stackoverflow.com/questions/24901/is-there-a-performance-difference-between-i-and-i-in-c) [Postfix increment can also be an undefined behavior minefield.](https://stackoverflow.com/questions/949433/why-are-these-constructs-using-pre-and-post-increment-undefined-behavior)
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bxcb14/when_to_use_post_and_pre_increment_in_programming/eq58e6h/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
That's too easy, why not add a dozen more tools while we are at it.
I was thinking about that library as well, but did not want to write or port tests to it. In cutf there were tests as well, and I managed to avoid couple of regressions during my changes.
I think that would be safe to do.
Haven't used it for docker but have done it for redhat,fedora,centos,ubuntu using this method. [https://devblogs.microsoft.com/cppblog/linux-development-with-c-in-visual-studio/](https://devblogs.microsoft.com/cppblog/linux-development-with-c-in-visual-studio/)
Not sure about Visual Studio (most documentation mentions only .net), but with Visual Studio code there's a small guide to using Docker and build in the container https://devblogs.microsoft.com/cppblog/c-development-with-docker-containers-in-visual-studio-code/
That’s really interesting. Thanks for the details!
You might want to update that guide, \`asio::io\_service\` has been a deprecated alias for \`asio::io\_context\` for quite some time now.
Windows + WSL is nice combo.
Was it optimized? -O2 or -O3? When I was testing boost::property\_tree for parsing jsons under debuging it was so f\*\*\*ing slow. In realease performance was not soo bad.
I should really get around to trying Windows subsystem for linux.
Futures can be used in a multi threaded context, but thats not a requirement. See JavaScript e.g., there they are common mechanism to handle continuations and all within the same thread. The futures of the C++ are from my point of view not very useful and the new futures will come hopefully in 2023. Until then you could take a look into our future and channel implementation. There you can specify if the tasks shall be in the same thread, use here an immediate_executor or in a different thread on a thread pool with the default_executor. For some OS we have a main_executor that executes the tasks on the main loop.: http://stlab.cc/libraries/concurrency/ I recommend as well a look into Sean Parent's presentations on this subject, https://sean-parent.stlab.cc/papers-and-presentations/#better-code-concurrency.
Yes it was optimized, with -O3. Also, the benchmarks are done with GCC 9 on a 2014 MacBook Pro running Ubuntu 19.04.
I think I would prefer the style you selected, because it matches my style for a chain of if's, and it draws my attention to the important parts (the bodies).
&gt; YMMV. Indeed, and that's the important bit.
PSA: In many cases, Udemy will happily host courses from people who steal them from other authors. Please check that the author of the courses you want to watch are actually the authors and not some thief. Alternatively, find courses on platforms that are more reliable, like Pluralsight.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bxdwzb/ssh_password_cracker/eq5mm71/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Don't forget about WSL. It is really convenient for writing cross platform code. In my opinion, no C++ dev environment comes close to Visual Studio for the overall experience. This has been my strategy. &amp;#x200B; 1. Set up a CMake based project in Visual C++ 2. Use std-lib along with cross-platform libraries to build and debug on Windows 3. Install WSL on the same machine with clang and/or gcc 4. Navigate to the directory of your project and build in WSL using CMake from the same source files 5. Run your tests to make sure the code works This way you can write in Visual Studio and get all the great code completion. debugging, etc and build from the same source without having to do any file sync.
That only covers c++11 - not c++14 and the latest c++17. IMO you should consider a more modern book that covers c++17.
Look for the Kate Gregory's courses in Pluralsight. Very clear video courses. She's one of the best C++ communicators out there.
🤔 I wouldn't do that as a first project, but a database or a simple webserver needs everything you described. - handles multiple connections - needs synchronisation to access data - you might need to create your own containers for specialised tasks, and for learning that's a good thing
You can create game. This is require multithreading, architecture, maths, library using, patterns.
Many thanks, your kind words are really appreciated. My plan is to publish some new posts in the next months and I'll cover my thoughts on practicing. Stay tuned!
Yes, sure there are. But they are doing it wrong: Having your logic in ECMAScript you again loose your decoupling between model/view.
No. I am Bulgarian. Is similar language but actually I better know english, not russian
VisualStudio+VisualGDB is a way to go. Docker stuff needs to added separately. But as far as development - it's IMHO one of the best I've tried
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bxe6at/what_projects_can_i_do_to_show_my_skills_and/eq5t024/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!remove
OP, A human moderator (u/blelbach) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bxbnel/what_is_the_best_approach_for_cross_compiling_on/eq5t0wz/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Can you publicate perfomance comparison by VTune, it will help to demonstrate more representative functions calls and GPU\\CPU efficiency?
CppCon talks are definitely the go-to way to learn about advanced C++.
Isn't a new edition of the book coming out soon? Maybe people who are planning to buy this book should wait a few months if they can.
can u send to me? 😇😇
If you want to develop a deeper understanding of how computers work, I wouldn't recommend modern C++... it's become quite advanced and proper use doesn't get you close to the metal like old C++98 would. &amp;#x200B; If that's your main goal, I'd advocate for learning C. Don't get me wrong: C++ is awesome and I love it, but I'm just trying to pass on some helpful advice.
This is sick: [https://twitter.com/czmosra/status/1085993965529255936](https://twitter.com/czmosra/status/1085993965529255936)
I try to open the link from PC and is tells me this content is not support in my country.
Ey, does Amazon work in your country? If so: https://www.amazon.com/Primer-5th-Stanley-B-Lippman/dp/0321714113 If not, let me know
OK, thanks for all of You replys. I will check all of the contents. Friday and this weekend I will check the whole content, which You guys give me. &amp;#x200B; Thanks.
I found on github and I will download and check the content, how is it. Thanks
I almost finish the course. Only 2 videos and the project and have to watch. I will watched and I wil do the project.
I cannot open the link. Could You tell me what is the edition. I found and download fifth edition from somewhere, on the internet.
I would bet that your previous experiences were actually the header pulling in lots of other dependencies and not a few thousand lines in the header itself. Don't forget that visual studio can compile 6MB of C in a single second. We all realize C++ isn't going to be the same, but parsing a few thousand lines is not a big deal. An explosion of dependencies that turns into many orders of magnitude more lines is a much bigger deal.
Yes, this is work.
Thanks alot. I think that is very interesting for someone who want to learn the language. In the first view is look little bit complicated but is required to see the tutorials.
Conference for learning I'm not using. I using more to see what is new on the market. I watch only few times for javascript and one time php. For learning I prefer course or book, like almost all of you recommend it.
From inside a "clean VM" I ran using both both GCC 7.3 and 9.1: ubuntu@ip-10-0-34-154:/mnt/codulus$ g++ --version -std=c++17 test.cc &amp;&amp; ./a.out g++ (Ubuntu 7.4.0-1ubuntu1~18.04) 7.4.0 Copyright (C) 2017 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 1 copied 2 moved ubuntu@ip-10-0-34-154:/mnt/codulus$ g++ --version -std=c++17 test.cc &amp;&amp; ./a.out g++ (Ubuntu 9.1.0-2ubuntu2~18.04) 9.1.0 Copyright (C) 2019 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 1 copied 2 moved ``` So the problem is still there for me. Any ideas on what might be different? To install 9.1, I ran Ivan's instructions at: https://gist.github.com/application2000/73fd6f4bf1be6600a2cf9f56315a2d91
&gt; g++ supports restrict in C++ as an extension As do Clang and MSVC.
My issue with AngelScript is... the syntax seems to be *more* complicated than C++.
GameMonkey used to be pretty good, though it's become obsolete. I don't think the 64-bit port ever fully stabilized (I had had to make a lot of local changes for it to be 'clean'), and it never optimized well. I've used Squirrel a few times. Not much to say about it positive or negative - it worked.
what do you mean by that? So far it looks quite similar to me
Fun. Any reason your member variable `val_` is *suffixed* with a `_` instead of prefixed?
The rules regarding reserved names (which did not change in C++11): * Reserved in any scope, including for use as implementation macros: * identifiers beginning with an underscore followed immediately by an uppercase letter * identifiers containing adjacent underscores (or "double underscore") * Reserved in the global namespace: * identifiers beginning with an underscore * Also, everything in the std namespace is reserved. (You are allowed to add template specializations, though.)
Interesting, but `_val` doesn't violate any of those.
Prefixing an identifier with an underscore is a bad idea. In global scope those are always reserved, and even locally they are reserved if the name begin with an uppercase letter. Using a `_` suffix instead of a prefix, if you must use underscores at all, gives you more liberties and is less likely to accidentally encroach something reserved by the compiler or the standard library.
I see what you're getting at (and thanks for linking the rules). I don't predominantly work with C++ these days (unfortunately), and we don't have those kind of conventions in, say, C# where I find it quite neat to quickly find member variables in the intellisense drop-down. Thanks for the lesson :)
Ha, thanks for the reminder — I wanted to put that workaround in a tested self-contained easy-to-integrate header for people to use, but forgot to do that. It's now in https://github.com/mosra/magnum-singles and if you choose to use it, you'll receive an adapted version once libc++ or MSVC STL implement the C++17 additions as well.
If you mean the idle behavior, it's just about `requestAnimationFrame()` not being called all the time, that's it. Besides that the two app implementations should perform comparably the same, the removed indirection layer could *theoretically* make `EmscriptenApplication` slightly faster but I doubt that would make a measurable difference — it makes a difference mainly in the download size.
It's really disappointing this doesn't get optimized.
I think the problem tends to be that as you try to explain to people the reasons, they think (often incorrectly) that they understand, and then think they are part of that 0.000001. So in principle yes I'm always in favor of spreading knowledge. In practice it's unclear whether trying to explain in best faith actually results in the best code in the wild compared to "volatile shaming" :-).
Just a personal habit. For some reason I prefer the way it looks to the `m_foo` convention that's often used, and a plain underscore as a prefix gets you into trouble if you have names that start with a capital letter.
Totally with you on the `m_` construct, I've never liked that myself - and as I've found it, it's got repercussions in the C++ world. :)
That's from the [Google C++ style guide](https://google.github.io/styleguide/cppguide.html#Variable_Names), class members should end in an underscore. That way if you see them in the code you immediately know it's a class member, not some temporary.
This makes me inexplicably happy.
Thanks for the info!
Stanford’s C++ class is quite good. You can find it on iTunesU or at https://web.stanford.edu/class/cs106l/lectures.html
Oh dear, I didn't expect this to show up on /r/cpp! In case it's not clear from the readme, this should not be taken too seriously...
By the way, you may like many things produced by Google, but their C++ guide is really among the shittier works they have made public, full of non-standard practices. I invite you to standard coding practices: [https://github.com/isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines) . This does not only apply to their coding style, but folder structures, build systems, pretty much anything since their C++ teams consist of a bunch of smartasses which come together and reinvent the wheel because they are Google and can do it better than any other standard to exist to day. So they believe. Did you ever gracefully use a Google C++ library for use in a project? You can't do it gracefully. Because you need to install 2 build systems which build on top of one another first and then build a set of base libraries before you get to building the library you wanted. They are full of shit.
I knew clang did. MSVC, however, I didn't.
What do you mean by "or a value"? honestly, that wording is just giving me flashbacks to a terrible Unicode library I saw that used templates to generate a code unit counter, it was a single line `T == UTF-8 ? 1 : 2;` Like what the shit i even the point of making something like that a template in the first damn place? I still don't understand, and frankly I don't want to.
Ok, I won’t explain then lol.
Title should be C++ header hell.
Do you really have compiler flags that are different for each library *and* affect the PCH?
Should we really take anything on /r/cpp seriously?
Even with the fix skreef suggested? Can you send me the code you tried? You can post as reply here.
Yeah I didn't liked that too, but since using \`\_\` prefixes is not recommended, and \`\_\` suffix does not help auto-completion, I would still prefer \`m\_\` prefix, in addition that it's kinda consistent with other big projects (like Qt, etc).
Igor videos are time taking but get many things clear if you don't know many things and cherno gives perfect description what the title says that's when u know things and want to revise them before iws.
On Windows, because of the DLL hell, each library had to define its `EXPORT` macro to be `__declspec(dllexport)` when compiling the library and `dllimport` otherwise. That means different compiler flags for every library, yes -- and VS2010 at the time complained very loudly when I tried to use a single PCH with different `/D` flags. I didn't try any other PCH system since then.
The reason for that stuff is due to the scale at which Google deploys stuff. Also they use a [single codebase](https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext) for nearly all projects, complete with continual integration etc. It's not easy to take a sub-project out of that, publish it as open source without some disentangling.
in the next version of datetime dates from before the transition to Gregorian calendar will be required to default to roman numerals :D /s
&gt; For some reason I prefer the way it looks to the m_foo Because humans naturally read that as "m underscore foo" - three syllables - whereas you read `foo_` as "foo". I did a lot of code reviews for both styles, and got to listen to how people pronounce names - the above happened pretty well every time!
The only fix I applied was to change `void main` to `int main`. Otherwise, exactly as shown earlier.
I agree with the author that ranges can help us to write some next-level pretty code in C++. I'm also a little concerned about the compiler's ability to optimize them, though. It seems like every time and author mentions them, [they also point out how slow they are](https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/). Is this just a problem that will be solved with time, or are there other fundamental hurdles for compiler writers to overcome?
I've deleted the code yesterday after i tested it. I would like to try it again to replicate the result. And maybe try it with a different compiler.
Here you go. What I find odd is that the `rvalue` check that I added in `store` prints `false`, which makes it hard to see why the code results in a move. ``` struct Foo { Foo() {} Foo(const Foo&amp;) {} Foo(Foo&amp;&amp; foo) { foo.moved = true; }; bool moved = false; }; template &lt;typename T&gt; struct Container { std::variant&lt;T&gt; variant; template &lt;typename V&gt; void store(V&amp;&amp; value, std::enable_if_t&lt;std::is_convertible_v&lt;V, T&gt;&gt;* d = 0) { printf("lvalue: %d\n", std::is_lvalue_reference_v&lt;V&gt;); printf("rvalue: %d\n", std::is_rvalue_reference_v&lt;V&gt;); if (std::is_lvalue_reference_v&lt;V&gt;) { variant.template emplace&lt;T&gt;(T{value}); } else { variant.template emplace&lt;T&gt;(std::forward&lt;T&gt;(value)); } } }; int main() { // Control test { Foo foo; std::variant&lt;Foo&gt; variant; variant.emplace&lt;Foo&gt;(foo); // This prints "1 copied" as we would expect, because we passed in an lvalue. printf(foo.moved ? "1 moved\n" : "1 copied\n"); } // Actual code { Foo foo; Container&lt;Foo&gt; container; container.store(foo); // This prints "2 moved" but I didn't intend that. I am passing in an lvalue, // and expected the forwarding store() to result in a copying emplace, not // a moving emplace. What's going on? printf(foo.moved ? "2 moved\n" : "2 copied\n"); } // Actual code { Foo foo; Container&lt;Foo&gt; container; container.store(std::move(foo)); printf(foo.moved ? "3 moved\n" : "3 copied\n"); } return 0; } ```
Has science gone too far?
I actually had to implement a little thing using roman numerals at work this week! What a coincidence
I mean, that you can show callstack to demonstrate, difference. If I understand post, you reduce function calls
There are exactly *zero* function calls while being idle, that's what the pie chart shows. Compared to `requestAnimationFrame()` executing a callback 60 times per second.
Why not.. just use "this-&gt;" for member variables instead of re-inventing the wheel/cluttering your variable/functio names?
I mean part of Emscripten optimization.
 if (on_rcpp = True){ take_seriously(); } else { dont(); }
Well it spits out different warnings which you can disable (i.e. it's not a hard error and thus basically doable). I used a pch shared across all libraries to speed up my (local) build and got great speedups. Even quite sure it was with VS2010 back then. With 1 pch per library you don't gain anything, as you said.
But that will anyways evaluate to true with a single equal sign.
I would love that too, but the only problem is that you're not forced to prefix with this-&gt;, which means invariably someone will write code that doesn't.
Because having a visual indication that something is a private member is useful, but prefixing every access with six characters is a lot more clutter than a single underscore? (TIL that people apparently like to bikeshed the names of *private variables* when joke projects get posted on Reddit...)
The age-old "human" problem.
Carmack uses m_ so I use m_
Don't understand what you want, sorry. The code size optimizations are done by *deleting heavy code* and replacing it with less heavy code. It's not about reducing any function calls or shortening call stacks at runtime, it's removing code at compile time. Can't use VTune on WebAssembly. I used Google's Bloaty to show me which functions occupy the most bytes.
Should have used Yoda conditions or just skipped the comparison with true.
&gt; (TIL that people apparently like to bikeshed the names of private variables when joke projects get posted on Reddit...) - &gt; There are only two hard things in Computer Science: cache invalidation and naming things. -- Phil Karlton Now is as good a time to talk about it as any.
(that's the joke)
Unless `on_rcpp` is of a type that overloads `operator =` in this case and doesn't return `true` for this.
Just because things are non-standard, they aren't bad, as long as your entire codebase follows that guide.
Unless `on_rcpp` is of a type that overloads `operator =` in this case and doesn't return `true` for this.
I've had good results with this [lock-free ring buffer](https://github.com/rmind/ringbuf/). Unlike most implementations I run into, this one supports contiguous ranges.
std::vector with a custom alocator built of [alloca](http://man7.org/linux/man-pages/man3/alloca.3.html) would be similar. I don't know if this would actually work, though.
Sadly it doesn't work nested, e.g. `for (auto &amp;[key, [first, second]])` for a `std::map&lt;int, std::pair&lt;int, int&gt;&gt;` is invalid :(
Python and Haskell generally have too much overhead to compete with C++ in programming contests, where time limits matter.
Well it depends on what you're doing with Python. I find for e.g. flow algorithms it will never fit in time limit.
The fix skreef suggested was correct. You should replace `std::forward&lt;T&gt;` by `std::forward&lt;V&gt;`. I've tested with both GCC and Clang and they both reported: &gt; 1 copied &gt; 2 copied &gt; 3 moved You can see it in action [here](https://coliru.stacked-crooked.com/a/e3674ff08f05f500).
 \*\***Company:\*\*** [Stellar Science](http://stellarscience.com/index.html) \*\***Type: \*\***Full Time regular W-2 employment with phenomenal benefits. \*\*Description\*\* **We hire smart Software Engineers** who love to create and maintain high quality, extensible, modern code in C++14/17 or Java (willing to learn modern C++). **Support software development in the following domains:** computer vision and image processing, image simulation, high power microwave systems modeling and simulation, laser source generation and effects modeling, computational electromagnetics (CEM), space situational awareness (SSA), high performance computing (HPC), and computer aided design (CAD) tools, among others. \*\***Location(s):\*\*** Seattle, WA \*\***Remote:\*\*** Remote work is not immediately available. \*\***Visa Sponsorship:\*\* NO -** US Citizenship is required + willingness to undergo background investigation. \*\***Technologies:\*\*** C++14, C++17 - Cross-platform software development on Linux, Windows, Mac or OOP in Java willing to learn Modern C++ \*\***Experience in any of the following is a plus:\*\*** · 3D graphics using OpenGL, Open Scene Graph and/or WebGL · User interface development with Qt, Java Swing, GWT · Supercomputing, OpenMP, threads, MPI, GPUs · Google closure or similar tools for large-scale javascript development · OSGi, Orekit, or Apache Commons Math \*\***Contact: \*\* Apply for the specific job** Seattle, WA – [https://stellarscience.applytojob.com/apply/trfk2S3W3U/Scientific-Software-Engineer-Seattle?source=RedditCPP](https://stellarscience.applytojob.com/apply/trfk2S3W3U/Scientific-Software-Engineer-Seattle?source=RedditCPP)
Maybe it should be a locale?
No, it's decided based on a provided location, and the library is required to account for historical changes in both political boundaries and, of course, the earth's magnetic field and tectonic shifts.
Adding a duration to a time_point will make a network call to the Pontifex Maximus in order to determine how many days there will be in the current year.
There's at least 6 types of strings in C++, off the top of my head: standard C strings. std::string std::wstring std::u8string std::u16string std::u32string
Auto playing video...you are warned
Can you support date ranges as well as absolute dates? This would require signed Roman numeral operation, with II's complement.
That's quite evil.
How about having a good IDE that will color members and local variables differently?
I can see use for this in Age of Empires clones.
 static inline constexpr struct { unsigned value; std::string_view symbol; } symbol_table[] { { 1000, "M" }, { 900, "CM" }, { 500, "D" }, { 400, "CD" }, { 100, "C" }, { 90, "XC" }, { 50, "L" }, { 40, "XL" }, { 10, "X" }, { 9, "IX" }, { 5, "V" }, { 4, "IV" }, { 1, "I"} }; Can someone help me understand this? Is symbol_table the name of the struct and so a new type, or is it the name of an array of the nameless struct? Or something else? I've never seen it done like this. And it accepts an braced initialization? Whew. Why a string_view?
&gt; Is symbol_table the name of the struct and so a new type, or is it the name of an array of the nameless struct? The latter. &gt; And it accepts a braced initialization? It's an aggregate, and the brace-initialization is in this case [aggregate-initialization](https://en.cppreference.com/w/cpp/language/aggregate_initialization). &gt; Why a string_view? As opposed to what? Knowing the string length can be useful/efficient so `char const*` is out, and we want to avoid allocations and make this constexpr so `std::string` is out...
If you know of any (or a VS plugin), please share!
Yes it is an array of nameless struct.
I think the readability of the code should not depend on the user's IDE preferences
Please double-check your formatting; it is broken in both old Reddit and new Reddit.
Resharper C++ does it. You can see how members, function parameters and local variables have a different color [here](https://www.jetbrains.com/resharper-cpp/features/) It will also tell when your declaration is hiding another symbol in case you do something error-prone like having a local variable with the name of a member variable.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bxqh1c/how_to_install_c_onto_visual_studio_code_for/eq92irq/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
VSCode definitely works with g++ on Win10. If you're using VSCode's integrated terminal, you need to ensure that g++ is on the path. For example: C:\Temp&gt;where g++ C:\MinGW\bin\g++.exe C:\Temp&gt;
FP concepts in a systems language? What year is it??
This code is outstandingly clean. I aspire to write code like this.
If you make it *constexpr* the compiler might be able to better optimize the code that uses the array because it knows what the values are and that they will never change.
[No](https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines).
I would say this is the best time for bikeshedding.
And will generate a warning. QED.
Ok, sorry i was wrong)) Thank you for explanation
Does this mean they will ship a newer libc++ than 4 or 5 or whatever it is now?
Is it still::filesystem? If not Apple can go fuck itself.
I'm actually with @Fiennes on this: This is about *member* variables, so global scope doesn't matter. If you also throw in a (usual) coding convention that variables always start with a lower case letter (and possibly with _ prefix) you are save. I was with you till my last group project. Prefixing them has a huge advantage: IDEs will work easier: Want a member variable? Start typing `_` and have autocompletion do its magic.
Thanks a lot for the work. Of course, one has to be careful when interpreting micro benchmarks w.r.t. to their relevance for overall application performance. However, It is generally depressing to see how much performance of semantically equivalent constructs can vary even on modern compilers.
Definitely would not work and after a while unique array pointer would not work either, unless given some custom deleter.
What's most important is that it's impossible to know what anything does :)
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bxr840/question_with_global_array_static_constexpr/eq99m9c/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
It's important for the array to be const, because that puts it in read-only data. Being constexpr is a relatively minor improvement (it requires the initializers to be compile-time constants). Adding static to either const or constexpr just prevents other translation units from directly linking to that array. At local scope, the story for static is different - static const/constexpr arrays can be put into read-only data, and the function just pushes a single address onto the stack. If you have a non-static array, even if it's const or constexpr, the compiler will typically emit code to push every single value onto the stack so the array has a distinct address.
Yep. We have a long way to go on compiler technology. A lot of what I'm doing is taking things I find while profiling and performance tuning applications then turning those findings into benchmarks. Many of the applications can't be broken down or handed over to compiler developers -- but isolated bits in a benchmark can. Then I abstract the idea and test variations (and usually find more problems). Yes, improving the small chunk of code may not have a huge impact on the full application - but sometimes they can (like certain image processing kernels). And sometimes knowing that there is a problem lets the application developers choose a better solution. But, as you can imagine, all the small optimizations missed can also add up. The more issues you fix, the faster many different applications will get.
All these comments and not a one zero joke...
Ah ok, I'm glad to hear that. I didn't know you could use the word reflection for that. Is this the proposal you're talking about: [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0194r6.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0194r6.html)? Btw: runtime reflection can be nice for debugging.
My default VS setup can do it, I just needed to set it up in the editor settings.
Thank you, I was just about to open the link on Sprint Review with volume turned on.
How so?
Personally I'd prefer to `#define m (*this)` and then be able to write `m.var` \- looks a lot like m\_var without having to add "m\_" to any non-self accesses as well (`other-&gt;m_var` vs `other-&gt;var`)
In case some people did not know, Firefox now let's you disable auto-playing. You can definitely change it in about:config by setting media.autoplay.default to 1 (to disable). Maybe also through the normal settings.
2050 we all rust programmers now
Thank you!
You might say... there have been zero so far? (I was originally going to throw `std::out_of_range` with a silly cod-Latin error message if you passed 0 to the constructor, and have a default constructor that initialised the value to 1, but I thought that might be taking the joke a bit too far...)
The next type is to provide an integer formatter compatible with {fmt} :p
Also kudos for the consistency in the license year ;)
it's good question. You can find new C++17 features about templates in [https://leanpub.com/cpp17indetail](https://leanpub.com/cpp17indetail)
Buy the second edition. The first edition is still *correct*, but it's no longer *complete* with respect to the latest language features. C++11 through C++17 added variadic templates (big feature), variable templates and deduction for class templates.
I think it's enough to get base knowledge about templates. After that you just can read some articles about new features. Main idea of templates still the same
You should build this out into something like ["Lingua Romana Perligata"](https://metacpan.org/pod/Lingua::Romana::Perligata).
Don't change! You guys are the best! Learning a language through a podcast seems rather impossible. I think the format they choose for cppcast is pretty good. They even cover all news and talks about new features and go pretty in depth for a podcast. For further learning I would always recommend watching the mentioned videos, as they have more value with visual code representations etc.
C++17 has improved significantly on how we deal with templates and added features like const expressions that interact really well with templates.
Always good to have a design patterns review. The compile-time version of this would involve templates. Alexandrescu is always talking about template parameters being customization points, and this is a good fit. e.g., ``` template&lt;class TextSender&gt; class CellPhoneTextApp { // ... void CellPhoneTextApp::SendText() { TextSender::SendText(m_recipients, m_textField); } }; template&lt;class TextSender&gt; class GalaxyS8TextApp : public CellPhoneTextApp&lt;TextSender&gt; { public: GalaxyS8TextApp(); virtual ~GalaxyS8TextApp(); virtual void Open(); virtual void Close(); }; ``` Upsides: - Less indirection (no virtual call to send a text, no ptr indirection for text sending) - We don't need any storage for our TextSender if it doesn't need state Downsides: - Templates, haha. Compile-times will suffer, and you trade runtime flexibility.
The fact that this comment is so upvoted is the reason why I not even bother coming around here anymore... just spouting vile and ignorance. &amp;#x200B; Just because CMake works for you it doesn't mean that it works for everyone. There are legitimate reasons why C++ is so unpopular when pitching it as a prospective language for a project, and one of the reasons for it is tooling. It sounds like you're happy with the existing tooling available. Google was not, and thank goodness, because that led to them and Apple funding LLVM.
Their altruistic funding policy has nothing to do with the quality of their C++ codebases, and how their practices are unorthodox to the point of preventing adoption by external users albeit being "open source". If they were unhappy with the existing standard tools, they should have put effort into improving them rather than writing their own "open source but hardly usable by anybody except us" libraries / tools.
Hey there, I might be working on what you need: a message passing framework with compile-time subscription. My goal is to achieve minimal run-time cost, avoiding function pointers, polymorphism, allocations, etc. I'm also trying to make it simple and clean, I happily take feedback on this :) Maybe my solution is overkill for your problem, and unfortunately it is still work in progress, but you can probably make exactly what you need starting from what I currently have. You'll find the code here: [https://github.com/LouisCharlesC/mess](https://github.com/LouisCharlesC/mess) Have a look at the readme and examples/ folder! I hope this will give you ideas.
&gt; Their altruistic funding policy has nothing to do with the quality of their C++ codebases How come not... why do you think that google has plenty of engineers employed full time working on clang? Because they are altruistic? Listen to yourself.
Clang is not their codebase, it hence does not follow their conventions. And yes they obviously benefit from contributing to it, despite they are altruistic in the sense that they do not limit the benefits to themselves but give it to public. &amp;#x200B; Some counter-examples, software actually developed by Google, in a Google way, that follow non-standard development practices, folder structures, and build systems: \- [https://bazel.build/](https://bazel.build/) \- [https://dev.chromium.org/developers/how-tos/install-depot-tools](https://dev.chromium.org/developers/how-tos/install-depot-tools) \- [https://github.com/v8/v8](https://github.com/v8/v8) \- [https://github.com/protocolbuffers/protobuf](https://github.com/protocolbuffers/protobuf) I am not saying these are useless or bad. Some of them are (sadly) even monopolies at what they do. They just follow horrendous software development practices. I can build 90% of the libraries I need on Github in about 2-3 mins thanks to the rising standards, but for example V8 took almost a week to build and link right as an external. This is what you get when you do not follow the standard practice. People can not adopt your technology. And defending this as an ideal, especially when you also are an external, is braindead.
Just `brew install llvm` and use the libc++, compiler, linker and all the other tools that ship with it. This way you always have up-to-date tools. Be warned though—this requires you to set a lot of environment variables.
(I'm the primary author of these books.) &amp;#x200B; I think the 1st edition can still be useful to understand the fundamental principles and mechanisms of C++ templates. Those didn't change much after the first round of standardization. The first edition even covers SFINAE in some depth (I coined the term in that book). &amp;#x200B; On the flip side, several new kinds of templates have been added (alias templates, variable templates, and deduction guides), an important new kind of template parameter was added (variadic template parameters), and things like generic lambdas and forwarding references also affect how modern generic code is designed. C++20 will add concepts (covered in an appendix of the second edition) and that, too, will considerably influence the templates we'll see in the near future. &amp;#x200B; I hope that's helpful.
Yep, I am getting consistent behavior. Somehow I lost track of my `T` and `V` experimentation (upon skreef's recommendation) that I missed it. It makes sense why my test case failed also. Thanks all!
With Concepts in C++20 you have to learn a lot new. Good news: Many things become much easier! ;-)
Shouldn't ab_filum() be ab_filo()? *Ab* requires ablative instead of accusative.
In other words... you have no facts, and you didn't at all address my point. V8 would be way more slower to build if it was using the conventional tools out there. How do I know? I'm highly familiar with the specifics, and benefits, provided by such tools... The only braindead part of this conversation is your groundless vague argumentation that they should do your bidding, without knowing none of the specifics involved.
Thanks for this book. I’ve been reading it casually for a while and it is truly a “complete guide.”
I had not seen your edited point. First of all, I am not arguing that I am an expert, but a long time consumer (and developer) of open source libraries/tools sharing his observations. Secondly, putting the whole chromium source in front of me to analyze and point out what I would make better is surely convenient for you, but I am coding something else at the moment and have limited time for a 1m+ line code review. If you think these libraries have aspects that overperform standard code, and they are there for good reason, which I am failing to see, YOU have to prove them to me. &amp;#x200B; Starting from this statement: \`V8 would be way more slower to build if it was using the conventional tools out there. How do I know? I'm highly familiar with the specifics, and benefits, provided by such tools...\` Since you know, can you please share the knowledge. What are the specifics? How would V8 be slower if it used a standard build system and a standard set of libraries? Please open this up further.
&gt; Ab requires ablative instead of accusative. "Ahh! No, ablative, ablative, sir. No, the, accusative, accusative, 'ad domum', sir." "Except that 'domus' takes the ...? " "... the locative, sir!" "Which is?" "Domum?" "Domum."
macOS 10.15 seems to ship an up-to-date libc++, but of course it'll be back to being out of date by the time you can require 10.15...
The second edition is fantastic, y'all really nailed it and I consistently learn new things from it. I feel bad because I haven't really sat down and sunk my teeth into it. I'd highly recommend it over the first edition, mostly because C++14 and up really gave us a ton of new tools and techniques we can use on templates that improve them. It still covers the basics the first edition got, but now includes tons of forward-thinking information as well.
He should paint ab_filo() all around github now!
Looking at the example, my instinct would be to have a `ServiceProvider` abstraction with Sprint and Verizon implementations, and inject the `CellPhoneTextApp` with a `ServiceProvider` dependency.
The second edition is one of the only in depth resources on changes to c++ past 11, and is a must-have for those that don't want to code by compiler error.
&gt;you trade runtime flexibility. Which is when you offer a polymorphic object as an option for the template argument, like [std::polymorphic\_allocator](https://en.cppreference.com/w/cpp/memory/polymorphic_allocator)
Thank you u/fluffynukeit, u/kindkitsune, and u/sempuki for the kind words. &amp;#x200B; I'll try to remember the phrase "code by compiler error" ;-)
I knew Google Translate wasn't to be trusted! Thanks, [fixed](https://github.com/tcbrindle/numeris_romanis/commit/19ac2544faf69fc2d96f6c09ae8b43112abed2a1).
Learncpp.com is in my opinion a great website, i’m following the course right and it’s simple, clear and with great examples/exercises
I know \`\_\` was refused for a ignored, but what about \`\_\_\`? (double underscore). There is no collision with current code since it's currently reserved.
The older stuff like metatemplate programming and SFINAE is like hard mode. Not only is it harder (but fun to learn!) but with that added complexity there is a slower development times and the potential for increased bugs. I highly recommending for real world projects moving from metatemplate programming to constexpr if. This functionality gets expanded quite a bit in C++17 and is worth the wait. For hobby projects, learning metatemplate programming can be a lot of fun and worthwhile though, especially SFINAE.
[Link to slides](https://devstreaming-cdn.apple.com/videos/wwdc/2019/409t7ah0xy3ocqab4a/409/409_whats_new_in_clang_and_llvm.pdf?dl=1)
Concepts made it into C++20?! Woo! \o/ (Apparently I've been living under a rock.)
Most or all of the info in the first edition is still relevant. It's certainly a lot better than nothing. But... at some point sooner than later, you're going to want to get up to speed on all of the new topics covered in the 2nd edition. So you will end up studying that book as well, having to reread or skip over the duplicated parts. As a C++ developer, your time is going to be worth significantly more than the $60 the book costs (if it isn't already). So, if you can't borrow the 2nd edition from someone (did you check your local library?), I'd recommend just buying it if you can. It will pay for itself many times over. You can even sell it used for most of the $60 when you're done, although I personally find myself referring to mine fairly often and would prefer to keep it around if possible.
What you want is called "inlining". Declare a wrapper function inline and pass it to function with loop, compiler may unwrap this function call inside loop. You'll need to check that compiler actually does that. There are some requirements that has to be met for compiler to actually inline a function, for once, optimization level has to be pretty high, function body might need to be available at compile time too.
Sorry late to the party, but what about using the comma operator? It also doesn't require any type.
and media.autoplay.allow-muted to false
Why are you using IAR? AVR-GCC exists.
Use \`T\*\`, don't over think it.
I'm very grateful for the link to [P1371](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1371r0.pdf) as the discussion on pattern matching was a little abstract for me without going to the paper to see what it's about. (For those in the same boat, it's a universal replacement for `if` and `switch` with some extra bells and whistles) I really like its value proposition. It brings back the excitement I had when I found that PHP switch statements could use strings. I'm also glad that the paper makes an effort to consider cases where `inspect` may be equivalent to a `switch` statement, because if this syntax becomes standardized, I wouldn't want it to come at a performance cost.
Your book is amazing and is one of my go to references. Thanks so much for putting it together.
Have you seen [range-v3](https://github.com/ericniebler/range-v3) a/k/a `std::ranges`? You should be able to write `auto v2 = v1 | std::view::transform([](int i){ return 2*i; });` or `auto v3 = std::ranges::sort(v1 | std::view::filter(condition) | std::view::transform(lambda))`;
Almost: It's `std::ranges::view::transform`. :)
&gt; First, I have to explicitly allocate the target vector; You could have used `std::back_inserter(v2)` instead of `v2.begin()`. &gt; second, I have to pass 3 iterators to transform. With the ranges library that we're getting in C++20, you'll be able to use containers instead of iterator pairs. std::vector&lt;int&gt; v1{1, 2, 3, 4, 5} std::vector&lt;int&gt; v2; std::transform(v1, std::back_inserter(v2), [](auto i){return i*2;}); &gt; dot chaining of transformations That is also a part of the upcoming ranges library. &gt; something like `auto v2 = v1.copy_if(condition).transform(lambda).sort()` would be convenient I haven't looked too deeply into ranges, so I might make a few mistakes regarding actual syntax, but something like the following should be possible: auto v2 = v1 | copy_if(condition) | transform(lambda) | sort(); And it requires no inheritance or revamping of containers. It just requires **tons** of template black magic. &amp;nbsp; &gt; I have even more ideas how to improve the STL; but let's just wait if you say what I wrote above makes any sense before presenting them :) It makes sense, but in a slightly different way, that doesn't break anything or limits the flexibility. You should definitely take a look at the origin of `&lt;ranges&gt;` header - [the ranges-v3 library](https://github.com/ericniebler/range-v3).
Thank you for one of the few non-trivial but approachable examples of expression templates! I've been slowly getting through your book each night before bed. It reads a lot like Meyer's books in that it's very easy to follow along and a nice read
In C++20, all being well, you'll be able to say auto v1 = vector{1, 2, 3, 4, 5}; auto v2 = v1 | view::transform([](int i) { return 2*i; }) | ranges::to&lt;std::vector&gt;; which admittedly isn't *quite* as short as C#, but still pretty nice IMO.
&gt; why can't both `transforms` coexist? Hey that is the current state of C++20: The existing algorithms are in `std`, as always, but the new ones taking ranges, which is basically what you want, are in `std::ranges`. :) Almost everything in your post is possible in C++20; The only thing not on possible are (I believe) creating containers from ranges directly (you need to store the range and pass in iterator to the container you want to create) and the dot chaining. But for the last one you can use `|` instead, which is also pretty great.
Backing up the author, I've gone through most of the first edition and picked up the second about a month ago. While most of the high level is the same, there is enough new modern concepts in the 2nd edition that you should do the 2nd.
There's a `namespace view = ranges::view` in namespace `std` in C++20, so either will work.
Oh nice didn't know that, thanks
Just wanted to thank you for writing these books. They have been super valuable in advancing my knowledge of templates. &gt;The first edition even covers SFINAE in some depth (I coined the term in that book) Can you tell us your original intended pronunciation of "SFINAE"?
[Yes! It is `std::filesystem`](https://developer.apple.com/documentation/xcode_release_notes/xcode_11_beta_release_notes/)
Modern glibc has a ton of optimization for different sizes. IIRC they previously dispatched to a specific snippet of assembly for each specific size when the size was small enough, essentially a "giant switch" - that's a ton of code! Now they use what I've suggested in the past as the best strategy: use overlapping stores for a range of sizes. Eg all memcpys from 17 to 32 bytes can be handled by two 16-byte loads (and stores: one aligned to the start of the region, and one aligned to the end). In the 32-byte case you get two adjacent but non-overlapping stores, but for any other size the stores overlap in the middle (at the extreme, in the length 17 case, the loads overlap by 15 bytes!). This is both faster than trying to use adjacent non-overlapping stores (think about the length 31 case...), and helps "quantize" the length for branch prediction: any strings with length 17 to 32 take the same path, so if you lengths are random but withing that range you'll predict correctly, as opposed to the "giant switch" approach which almost always mispredicts unless the length is the same on every call.
My 2 cents: these talks shouldn’t take more than 30 minutes!
Volatile ensures that the writes actually occur as they are considered a side-effect, in a similar way to file or terminal output. Are you aware of any system supporting C+11 where writes 'don't make it to other CPUs'? Such a system would be non-coherent and making implementing &lt;atomic&gt; essentially impossible.
Hello, I'd love to get feedback/opinions on this. This is a fairly young project, so there's still a fair bit of room for refining the API. In particular, I'm not super happy with the function names. I'll probably end up renaming \`then\_finally\_expect()\` to just \`finally\_expect()\`, for example, but I'd love to hear if someone has a better idea.
long before me IAR was much better according to an evaluation done at the company. Now it is a huge code-base that is very reliant on IAR specific features. We don't always get what we want... :/
There is no *legal* use case because as pointed out a few times, unsynchronized access to an object where at least one access is a write is UB. That said, I am aware of no implementation were your use case will not work, as every compiler I've seen implements volatile as reads and writes to memory, and every system that I know of that supports C++11 is coherent, so the scenarios people are suggesting of writes "never making it" are mostly fantasy. Consider also that before C++11 using volatile in this way wasn't UB, it was simply outside of the purview of the standard, so volatile was widely used in this way: adding the -std=c++11 flag to the compiler isn't going to change this radically. That said, if you are using C++11, there is little *reason* to use `volatile` in this way: you will get almost exactly the same semantics and performance from `std::memory_order_relaxed`.
Sure, but now you are outside of the scope of the standard. So you just reason from the guarantees provided by hardware: if I write something on one thread (and assuming no further writes), will I see it on other threads? Yes, almost immediately. In fact, I would be very interested to hear of any system supporting C++11 where this is not the case. Since everyone is so concerned about visibility, what guarantees does std::atomic put on visibility in this scenario of writes by one thread to a single location like this? None, I think. The guarantees are all about ordering, what you will see for some objects *if* you see a write to another object, or the *allowed* orderings of modifications and so on. I don't think it ever says you'll *actually see* a write "soon" or "ever" or anything like that. How would you even do that w/o reference to a global clock or something like that?
Does std::atomic ensure you'll eventually see the update of the other thread?
It has nothing to do with x86: there is no modern architecture I'm aware of where writes don't become visible to other threads "basically immediately". Such an architecture would be non-coherent and saying these are not populate in the CPU space would be a massive understatement. C++11 std::atomic is basically written with the assumption of coherency.
Does std::atomic?
Yes, `__` does work. I really dislike it due to its visual similarity to `_`, but we don't yet have a better idea. So `__` is what will be used for the next iteration of `[P1371R0](https://wg21.link/P1371R0). It was also the option used in [P1110](https://wg21.link/p1110) among other options presented.
So do it.
Well, kind of... It ensure if you see any of the update then it sees all of the ones before, and you can use an atomic_fence as an observation point you cannot not observe.
Watch them double speed?
Yes, but here there is only one update. So saying if you see one update you'll see the rest isn't too useful, because there is only the one update to ever observe... and the standard says nothing about it.
I mean, you see all the non atomic update before the atomic one.
Main points * DI is just a fancy term for using constructors (25 dollar concept...) * DI can be easily misused * DI doesn't require a library/framework * DI library/framework helps with the wiring mess
Raw pointers are completely fine. The main reason people recommend not using them is because the average Joe abuses them.
Transform has more parameters since it is more flexible. If you want less typing, use for_each or just a range-based for loop - vector&lt;int&gt; vec1 = {1,2,3,4,5}; vector&lt;int&gt; vec2; for (int i : vec) vec2.push_back(i*2);
How does it compare to NanoLog from Stanford? https://www.usenix.org/system/files/conference/atc18/atc18-yang.pdf
The 6th Edition of C++ Primer comes out in September 2019 and should cover up to C++17.
!remove
OP, A human moderator (u/STL) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/by3kg4/oh/eqcay4m/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
:'(
Thanks for the summary
Thanks for the summary
There used to be more "less coherent" CPUs before indeed, but even on x86, std::atomic goes to interlocked exchange CPU instructions. So what do you mean by the "assumption of coherency"?
Thanks. I checked out the Coursera course. Seems quite interesting (we've to build a computer in a simulator in the final project) and also doesn't have any cs prerequisites. Thanks very much.
Child raping fuck.
Yeah! Imagine if people said "modern C++ doesn't use ints", I wouldn't be able to keep a straight face.
Need to watch it, my only exposure to DI was through [https://github.com/google/guice](https://github.com/google/guice), which was getting replaced with [https://github.com/google/](https://github.com/google/guice)dagger, put it simply you never do "new SomeObject( someArgs...)", what you do (in your constructor) is: "SomeConstructor( @NeedObjectOfTypeA a, @NeedObjectNamedB b, ... etc)" - then you have completely different place, a factory, config, etc. that is the one providing instances of these objects - it could be everytime a new instance, or recycled, or singleton, or instance per session, or instance per thread, or who knows. So all it boils down to - testability, and late configuration - e.g. by newer directly instantianting anything in your code with explicit "new MYCode(Myargs)" - but just saying I need an instance of "class A", or if you need more specific configuration I need an instance of this thing I've named "B" (which might have class "C"), etc. etc. - so then your test runner, or configuration might provide completly dummy, fake, mocked versions of these, and/or in general actual decision of what these objects really is done in other place (That used to be called a "module" in itself). That to be said, I've only got the basics, and I'm probably wrong about many details what I've just said, and I do consider it useful, but only useful if the rest of the team I'm working with finds it too. Also not every language is able to implement them.
Let's put extension methods and terse lambda in C++23 to be on par with C# :)
Transform can work on raw pointers or itetators if of already created objects, it is the whole idea. No algorithms in STL are memory-allocating IIRC.
My 1 cent: these talks shouldn't take more than 15 minutes!
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Watch them quadruple speed?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/by60wx/modern_c_authors_and_books/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
There are chrome extensions that add controls to allow you to exceed 2x! It's great for boosting to 2.5x for the extra slow talkers, or speeding up to 6x to fast-forward through the boring parts.
You can disable any kind of version control in Qt creator, in About -&gt; Plugins.
I completely agree with you. There hasn't been anyone as thorough in their approach for writing books as the authors you mentioned in a while. The best advice you can get is scattered across blog posts and talks of variable quality which often do not agree with each other. I'm afraid this is going to become a lot bigger problem with C++20 and moving on. The number of subsets of C++ people use is only going to grow.
Apart from the ones you mentioned, I haven't seen any "modern" books covering multiple topics. There is the [sixth edition](https://www.amazon.co.uk/dp/0135161797) of the C++ Primer which was originally due to published in January 2019, but it looks like it has slipped to September. The current fifth edition is excellent, so I am expecting the sixth to be of similar quality. And there is [C++ Crash Course](https://nostarch.com/cppcrashcourse) from No Starch Press slated for later this year (currently in early access) - the NSP books are generally very well written and edited. But both of these books will be geared towards beginners, so likely won't appeal much if you want more advanced topics. The best focused-topic C++ 17 book I have bought recently is [C++ Concurrency in Action (second edition)](https://www.manning.com/books/c-plus-plus-concurrency-in-action-second-edition) which was released a few months ago. The print copy I received was warped and on terrible quality paper, but the content is very good.
The reason is that the market is small. Of course, we still need c++ devs, but go to a job fair and all jobs are about C# and Java, whatever an index says about some google rankings that students use to make their homework.
N. Josuttis has [C++17 book](www.cppstd17.com) he is in the process of writing at leanpub. It is currently at 94% complete. Definitely, check it out!
I like Ivor Horton. https://www.apress.com/gp/book/9781484233658 No one ever recommends this for some reason, personally I like it much more than c++ primer.
Have you read the Core Guidelines? They're just about book length...
Would it kill you to explain what HDF5 and MAT are?
C++20 looks like a much bigger release almost comparable to C++11. In contrast, 14 and 17 felt incremental. I expect that as C++ 20 gains more adoption we'll see more books about the new features.
I bet that if you don't know them you're lucky!
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/by8euv/best_app_to_learn_c_for_windows/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
The Hierarchical Data Format 5 (HDF5) is a format to store (mainly) numerical data [https://www.hdfgroup.org/solutions/hdf5/](https://www.hdfgroup.org/solutions/hdf5/) . It is used in the `.mat` files that are used by MATLAB ( [https://mathworks.com/products/matlab.html](https://mathworks.com/products/matlab.html) ) to load and store numerical data. Beside MATLAB, \`.mat\` files can be loaded in Python, Julia and several other languages thanks to several libraries that support input and output in this format.
Yes, but in this case there are no such other shared updates. The only shared state is the one flag variable `done`.
Probably a number of interlocking issues... It's a ginormous undertaking. C++ has become a lumbering oil tanker of a language. If the official spec is the size of a book, what size book would it take to explain another large book in any detail? These days, theft of IP is a huge issue. The bigger the effort to create something, the more damage done by theft. It'll probably get scanned in an be available on the internet as soon as it's released, which isn't something likely to encourage a huge effort, unlike the good old days. Even if it's not outright theft, the information is all out there for free, so it makes these types of books less valuable to more and more people. I can't remember the last time I bought a language oriented book, or any books about any development topic. It's all out there online. Well, I did buy one on SIP some years ago I guess, but that was a rare exception. C++ is not as much a target language for large numbers of newcomers these days, I don't think. Given the care and experience it requires to do right, and it's lack of applicability in the far and away probably the most common entree to the development world these days (web and mobile), how many of the potential customers would be old timers or experienced developers who probably aren't big buyers of such books, because they just pick it up via osmosis online anyway? How many companies will even start using C++ 20 features any time remotely soon? Most companies are probably more concerned with creating product, not obsessed about the language itself. Quite possibly most of them are only still now getting to or considering moving towards significant adoption of 17 level stuff.
That's a big improvement but two things still make it more verbose than in C# 1. verbose lambda syntax. It would be great if we could write just \[\](i) =&gt; 2\*i. There were multiple abbreviated lambda proposals but all of them rejected imho. Looks like shorter lambda syntax is not favored by the committee. 2. containers miss range constructors so constructs like ranges::to were invented. For me this is too funny because one of the motivation behind concepts was to be able to overload on them and container range constructor was always given as an example. Unfortunately it didn't happen for some reasons.
I highly recommend Bartłomiej Filipek's [C++ 17 in Detail](https://leanpub.com/cpp17indetail?utm_source=blog&amp;utm_campaign=adside) I've just finished reading it, and it's been a very useful guide to everything that is new in C++ 17.
Check out Learn You a Haskell for Great Good!
My *n* cents: watching talks should be O(1)!
&gt; Why is boost::lockfree::queue so slow and would another boost::lockfree datastructure be better? `boost::lockfree::queue` is based on a linked list and lists are generally not CPU cache friendly. This is why performance of this container is poor.
These days it seems like most folks think of DI as you just call some system API and pass it an instance of some interface. And that's obviously one way to do it. Back in the day, the term I always used and heard used was just 'framework'. That was just a core class that implements the logic, and which defines some abstract mixin type interfaces. You implement the interfaces and plug in instances of your derived versions into an instance of the main framework class. Both basically get you to the same place, but one is system wide and the other can be done via as many instances as you want in the program. I definitely do both. And it is most definitely nothing remotely new and has been around since the beginning of OOP time I'm pretty sure. It was definitely around in the early 90s when I was getting into OOP. The nice thing about the framework style one is that you can do it in various ways. 1. You can create an instance of the framework class as a member, have the containing class implement the mixin interfaces and then the containing object plugs itself into the framework member object. 2. You can have various pre-fab classes that implement the mixins, to which you can hand and instance of the framework class to own, and they plug themselves into it in order to implement the framework loging in different pre-fab ways. That sort of double reverse inversion in which different versions of the core logic can be plugged into a prefab set of 'sockets' to implement the logic in different terms. 3. And of course there's absolutely nothing preventing you from creating a derived class from the core framework class, having that derived class implement the mixin interfaces, and then plug itself into the base class. That is convenient to create a prefab set up for a specific scenario. All are potentially useful. They are are providing the same inversion of control principle, but in different sorts of ways. The core framework class is still going to drive the process however it happens to get set up. In the 'call a system API' the overall system itself takes the place of the framework logic class, but otherwise it's the same.
Just comment without watching the video, that's an O(1) algorithm that's also been proven to work well in practice!
Yes this is what got me to actually learn C++ from scratch as a complete novice. Good balance of low level hardware details and high level OOP concepts without the hand waving.
Interesting, but if write-only and the entries are small in size it might be better to simply duplicate array's with timestamps per thread and then merge them afterwards. I find it a bit weird (or maybe I missed it) that the context is not given from the start: This system only is performant if you want to write to multiple elements of a collection atomicly. The benchmarks also only cover a fixed number of elements per transaction, if a transaction tends to update a lot of elements, it might better to just have a well placed mutex.
“C++17, The Complete Guide” by Nicolai Josuttis is really good. It goes over all the new features in an easy-to-read way. [https://leanpub.com/cpp17/](https://leanpub.com/cpp17/)
This is what I’m looking for. Thank you
I think I have a pretty extensive C++17 book list at [https://github.com/BartVandewoestyne/Cpp/blob/master/C%2B%2B17/books.md](https://github.com/BartVandewoestyne/Cpp/blob/master/C%2B%2B17/books.md) Each time I see a new book mentioned somewhere, I add it to that list. Feel free to let me know if any are missing!
It appears that moodycamel is broken. https://github.com/cameron314/concurrentqueue/issues/157
The market for technical books has shrunk considerably in the last quarter century. I think that’s the main cause of your observation...
they always mention how easy it is to use incorrectly and misunderstood
What is so special about C++ concurrency? I'm asking because I'm fairly comfortable with C++11 and have even had a couple of C++ jobs, will I find any value in the 6th ed of the C++ primer or C++ concurrency?
I pronounced it like "sfee-ney".
Happy cake day ;-)
pedophile fucking trash. https://heavy.com/news/2019/06/peter-bright-dr-pizza/
What does "equilivent experience" mean? How do you get a programming job without having a degree?
Here's a post on it: https://devblogs.microsoft.com/cppblog/lifetime-profile-update-in-visual-studio-2019-preview-2/
Coherency is basically a black and white thing: are writes by one agent seem by all other agents, without any special action? All modern CPUs are coherent in this sense. What x86 has is a stronger *memory model*, which is about possible orderings that other CPUs may see - but it is no more or less coherent than other CPUs. Indeed, if you are somehow judging coherency by "how long" it takes for other CPUs to see a store made by another CPU, then x86 is among the least coherent in that it has the deepest store buffers - but this distinction is mostly meaningless. Interlocked instructions are about atomic RMW, like compare &amp; exchange or interlocked add or whatever. They aren't needed for coherency. Note that regular reads and writes of std::atomic don't need any special barriers on x86 except for seq_cst, they rely on coherency. What I mean is the assumption of coherency is that the whole C++ memory model is based on the idea that when one thread sees a "release" write by one CPU, it sees *everything* before that release write (the "release sequence" or whatever they call it in the standard), including the 99% of things that happened before that don't use std::atomic at all. This is a very useful model for concurrency, because it means you can use normal code to do almost everything, and then just ensure you *publish* the final cross-thread update using an atomic (e.g., my making public a pointer that points to the local stuff you've done), and you get the guarantee that everything you did before is seen as well. Other memory models like Java follow this same idea. Without coherency, it would be essentially impossible to implement efficiently: how would you know what to go back and flush? How far back in time?
A sufficiently impressive GitHub repository opens a lot of doors.
You realize that malloc locks, right? Also what is async supposed to mean in this context?
This is written in C
It’s only yield the thread when its value been taken by other thread, and re calculated queue size, its does not really happened unless surprisingly happened Async in this means mpmc
It’s just a header, you can compile with c / c++. You can see the OverallTest for more details :)
If you do believe in your work, stop using the term "c/c++". The perception is bad.
You don't need to null check before a delete.
I am sorry I don’t get what you mean. It’s actually a header can use for c or c++ .
As said countless times, fast means nothing. But benchmarks can give an idea.
I have updated the example, thanks :)
This is technically true, but it is not hard to replace `malloc()` with an allocator that minimizes mutex contention overhead, such as `jemalloc` or others. :-) In general I would not be worried about `malloc()` as a performance problem in this context, unless it is used indiscriminately.
C and C++ are quite distinct. Although most C code can be used from C++, it is not ergonomical or idiomatic.
Check out C++17 From Nicolai Josuttis, he's actually a member of the ISO standardisation committee
It’s actually malloc when expand the new set, so it won’t really happened if your pre alloc size is enough. Even it’s , It only happened one time per expanding ;)