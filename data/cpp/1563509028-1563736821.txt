It didn't seem to provide me any benefit so no
There's nothing special about std::string, except that the in-memory representation of an empty string is really simple. Since the assigned value is known at compile time, the compiler can deduce what the end-state of the object is, and just produce it. You can try it yourself: https://godbolt.org/z/W3tjoc
If you use a third party library they might have left in a fatal design error or bug. But if you do it yourself, you'll know.
Much better and no need for the book: https://lemon.cs.elte.hu/trac/lemon . Also many times faster and more compact.
If you look to the [right](https://www.boost.org/doc/libs/1_70_0/libs/graph/doc/index.html), you'll understand why the documentation is terse.
It's C++11, header-only, easily extendible and the documentation is short, but sufficient.
All of the above is fake news anyway.
Yes, indeed, inversely.
If you define `VCPKG_DEFAULT_TRIPLET` in your environment to like f.e. `x64-windows-static`, this will be the default on everything, this is a do-once-never-touch exercise.
Why would you want a free push back?
[Have a look](https://www.reddit.com/r/cpp/comments/cet4zz/why_does_everyone_seem_to_reinvent_the_wheel_when/eu6wvm3/).
Context. We've also had "New" York. Colleges aren't as volatile as software and languages, so I'd (as if I'm some kind of authority...) give a pass to anyone calling a college new. As for C++, we all know the "headliner" features of C++20. It's going to be as big as C++11 was, so why should we stick to calling C++11 "modern"? We didn't call C++98 "modern" because it was "just" 10 years old when C++11 came out.
&gt; return types `-&gt; ()` is just `void`, `-&gt; !` is `[[noreturn]] void`, `!` sign in `println!` indicates a macro call.
&gt; From my understanding the constexpr keyword is there to help the programmer enforce the compile-time computability on the spot, otherwise we'd get long compile error lists that some function somewhere isn't constexpr, similar to how it currently happens with templates. `constexpr` does not do that, in C++20, `consteval` will. `constexpr` on a function states that it possibly could return a `constexpr` value. Marking a value T `constexpr` will enforce that, or it will fail [if anything on the requirements list is not fullfilled], with 'function does not return a constant expression'.
Yes, I've learned that before, but what is wrong with spelling out `void`, `[[noreturn]] void` (it's long, but it's clear. I'd also accept `none` or something as a contextual keyword) and `println`?
It will [if requirements fullfilled] if you write: constexpr Foo make_foo ( ) noexcept { ..., return Foo; ); constexpr Foo f = make_foo ( );
There are certain contexts (templates parameters) that only permit constant values. Constexpr provides a minimum bar for when a compiler must be able to evaluate something at compile time (note that this is different from actually doing so, sometimes), so that such computed constant values can be used as template parameters in all implementations without compatibility bugs.
This makes a lot of sense, thanks for that insight.
It can, I wouldn't say it will. If you don't use f it will simply not bother creating it. But even if you do, it might decide to delay the evaluation as late as the actual execution. Typically, the interpreter at source level is slower than the one deeper in the tool, so they can simply not evaluate it unless useful. Then later automatic optimizations will take care of it as they always do, but it's all heuristic based.
Documentation is the problem nine times out of ten in my opinion. The kind of people who will write a complicated generic library just almost always suck, for some reason, at imagining a neophyte trying to sit down and understand the situation. They also tend to be bad writers of English prose, for whatever reason.
Neither stack nor heap? How/Where is the memory allocated then?
COM is still used and probably will be as long as Windows exists. COM is a reasonable solution for its problem - making compatible object orientations of complex objects available in a wide variety of languages. Unfortunately, languages are very different, and COM isn't perfect and so you pay a pretty substantial ergonomic penalty for this benefit. Most people aren't writing WinRT.
Compilers (at least GCC and Clang) do special-case `strlen()` so that they can evaluate it at compile-time for constant strings. Without that `std::string a = "";` could not be optimized to the same code as `std::string a;`.
Yes, in this case it will, or it will balk [i.e. won't compile]. `f` needs to be initialized with a constant expression [because of the `constexpr` qualifier]. In C++20, with `consteval` [added to the make_foo function] it is guaranteed [that the functions return a constant expression]. I.e now you can write: consteval Foo make_foo ( ) noexcept { ..., return Foo; ); Foo f = make_foo ( ); which is different in the sense that unlike the `constexpr Foo f`, which is implicitely `const`, the above Foo is assigned at compile time, guaranteed, but still modifiable. constexpr Foo make_foo ( ) noexcept { ..., return Foo; ); Foo f = make_foo ( ); does not guarantee anything.
Being initialized with a constant expression does not mean being initialized by a literal constant. It's just guaranteed the interpreter could. As for consteval, I don't know the semantics. What does it mean "at compile time" when the C++ is interpreted? I'm surprised the standard would take such a stance.
&gt; It's just guaranteed the interpreter could. No, not as far as I've seen, adding the `constexpr` qualifier to the function does in itself not guarantee anything, contrary to `consteval`. You can very happily write code with `constexpr` added to the function definition only to find out that it blows up once you try to assign it to a `constexpr` variable instance.
The keyword constexpr is \*NOT\* there to tell the compiler to evaluate something at compile time. The keyword constexpr means "I belive that this can be evaluated at compile time. If you disagree Mr. Compiler, you must generate an error". The compiler is still free to generate code which evaluates the constexpr at runtime. In practice constexpr probably means that the compiler will evaluate whatever you've specified and optimize it away. But it's not guaranteed. As to why you would want such a keyword - well one of the great parts of a compiled language like C++ is that the compiler will tell you if you fuck something up. So a fairly large number of keywords and language construct SPECIFICALLY EXIST to tell you if you've fucked something up at compile time before your program even runs. We're talking like const, public, private, protected, having typed pointers, return types, static\_assert etc etc etc.
You will not find a satisfying answer, because absolute opinions are usually just dogmatic and stupid. You can write an extremely high performing, well maintained, easy to follow codebase in C++ using code which will also compile in C (with a few syntax modifications possibly). That said, there are a ton of great features in C++ that can probably be used to make that codebase **\*even better\***! So if someone is telling you your code sucks - well it probably does. But not because a C compiler can also build your code!
I think it's a great question. Check out this tool that automatically sprinkles your code with the magic dust constexpr is: https://github.com/trailofbits/constexpr-everything
The [BSS segment](https://en.wikipedia.org/wiki/.bss).
I think the other side of the same coin there is: how did you even know that the function was appropriate to use as your template parameter in the first place? And without a constexpr keyword the answer is "because you read every single line of code in that function and assessed it against the 'automatic constexpr' standard". Gross!
... the **ultimate** tool, you say? [https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html)
It's *exception* vs *undefined behaviour*. Undefined behaviour might lead to a segfault but that is not always the case. You should write your code so this does not happen.
Segfault is the happy result, yes obviously there is much worse.
`!` is a type. Thanks to that you can eg. implement a trait function that must return some `Result&lt;T, E&gt;` as infallible, by returning `Result&lt;T, !&gt;` (see [never type and generics](https://doc.rust-lang.org/std/primitive.never.html#-and-generics)]). You cannot achieve that with just a marker keyword on return. You could argue that something like `never` woyld be more readable than `!` (or that `void` or `unit` than `()`) but that’d be bike shedding. And reusing symbols in new contexts is easier than introducing new keywords (`!` type is a new, still nightly, feature; calling it `never` would be a breaking change for all the code using it as an identifier).
TIL, thank you! :)
The problem with `constexpr` by default is that it cannot be relied upon. If a library offers a `constexpr` function you can reasonably expect it to remain that way until an interface breaking change is pushed to the library. Therefore, you can use it contexts where only `constexpr` is valid like template arguments. You cannot do that with `constexpr` by default because the programmer has made no guarantee and they are liable to change it at any moment without even thinking about it. And since it's not safe to rely on `constexpr` by default, it's arguably much better that it doesn't exist at all. Now you get an error and you know to change your code rather than it breaking randomly in the future.
I don't think you can use concepts like that
Yes.. That's the style Herb has been pushing for.
I tried using a recursive `constexpr` function that way a while back in MSVC. It gave me a compile error claiming it could not evaluate it at compile time. The actual runtime of the function call was much smaller than a second, so it seems MSVC has some unreasonable arbitrary limitations on what it will attempt to evaluate at compile time. Of course, you get an error which is better than silently evaluating at runtime, but it's really annoying that you can't use a perfectly valid `constexpr` function at compile time.
I don't think we would want to rely on compiler optimizations for constexpr. That would make a lot of code break in debug modes and across different compilers.
Besides what people have already stated here I've seen some people roll their own, lets say strings because they found out that copy on write is good for their specific application, something that std::basic_string doesn't implement.
I don't think this comment deserves to be downvoted. Having a function marked constexpr doesn't mean it will be evaluated at compile time, not even if all arguments are constant expressions ([https://godbolt.org/z/7R\_yv2](https://godbolt.org/z/7R_yv2)). There are also some things that you are allowed to do inside a constexpr function, that will work fine when evaluated in a non-constexpr context, but will fail in a constexpr context ([https://godbolt.org/z/JJFOoz](https://godbolt.org/z/JJFOoz)).
&gt; You could argue that something like never woyld be more readable than ! (or that void or unit than ()) but that’d be bike shedding. Exactly what I'm arguing. Rust is way too eager to give meaning to a random string of non-alphanumeric characters, making the code unnecessarily harder to read. Yes, there is a level of bikeshedding here, but think of a declaration like `let foo: &amp;'static str = "foo";` from a newcomer's point of view. It's stupidly busy and unreadable.
Did you try [to tweak] any of these compiler flags: /constexpr:depth&lt;N&gt; recursion depth limit for constexpr evaluation (default: 512) /constexpr:backtrace&lt;N&gt; show N constexpr evaluations in diagnostics (default: 10) /constexpr:steps&lt;N&gt; terminate constexpr evaluation after N steps (default: 100000)
I think it's \`*HKLM*\\*Software*\\*Policies*\\*Microsoft*\\*Windows NT\\Rpc*\\MinimumConnectionTimeout \` but I can be wrong. Anyways I agree that COM is not good for network. However it's fine for local RPC, especially between C++ and C#.
I didn't even know these existed. Thanks for the tip. I'll keep them in mind.
 cl.exe /? does magic.
Isn't this a problem for D too then? How do they solve it?
Optimizes to constant != constexpr. https://godbolt.org/z/TBd0oz
Having said that [the other stuff], did that recursive function work at run-time [i.e. did it have some terminal/last value]?
It says here that Excel add ins are made with HTML, CSS, and Javascript. https://docs.microsoft.com/en-us/office/dev/add-ins/excel/excel-add-ins-overview Why are you posting in the CPP subreddit?
See if `std::valarray` is suited for your case.
Well, nothing except that I cannot form the symbol without it getting replaced! Although /u/mujjingun provided a solution for that, albeit a rather wordy one.
&gt;does not guarantee anything I watched a [talk by Daveed Vandevoorde](https://www.youtube.com/watch?v=m9tcmTjGeho&amp;t=36m18s). If I understand correctly it will try to evaluate make\_foo() at compile time, and only fall back to runtime evaluation if that fails, assuming f is a global.
we are doing it in CPP, it was done before and I'm only updating it so that it can be used in 64 bit excel
The expected semantics in that case are simple: during preprocessing of main.cpp, the preprocessor sees the #define from m.h, and replaces both occurences of MY_CONSTANT in the text of the .cpp file with 1. After preprocessing the module m.ixx gets imported, so we now also have a constant MY_CONSTANT with value 1, but nothing is using that constant anymore, it all got replaced by the preprocessor. So after all is said and done, what the compiler sees in the end is essentially this: constexpr auto MY_CONSTANT = 1; int main() { static_assert(1 == 1); }
The blog misses the obvious way to initialize an empty string, which would be: `std::string empty{}` This makes it painfully obvious we are initializing the variable - even if it were a POD it would be default-initialized. It still uses the default constructor, so it produces the exact same output as the version without the curly braces.
That uses the `std::initializer_list` constructor with an empty list, not the default constructor, though the net effect is the same.
So, it does not guarantee anything, that's what I said. It [the compiler] will not tell you that it didn't, if you made an error making the specific function not evaluable [forgive me the made-up word] at compile time.
Sorry, but that's completely wrong. Compilers for many languages have been converting function calls to constants for decades. Well before C++11 introduced `constexpr`. `constexpr` is a feature which allows one to provide an explicit, interface-level guarantee that a function can be evaluated at compile time, and that it will be if it is used in a `constexpr` context, like as a template argument, array size, in an `if constexpr` statement etc., regardless of any optimization settings.
That makes no sense to me. It's certainly a valid overload, given that an initializer\_list can be default-constructed. However, why would the compiler choose this overload when a constructor taking *no arguments* exists and is a better match?
This basically summarizes my thoughts before I posted ;-)
Some compilers support 128-bit types as an extension. For GCC and clang it is `__int128`. See [https://www.godbolt.org/z/W91u17](https://www.godbolt.org/z/W91u17) If you need more, there are multiprecision libraries, such as [Boost.Multiprecision](https://www.boost.org/doc/libs/1_70_0/libs/multiprecision/doc/html/index.html) and [gmp](https://gmplib.org/).
Yeah, it's tricky stuff, you have to have struggled with it for a while [learning by doing] to get 'your approach' right [once you 'get it', though it works great]. Basically it comes down to writing 'factory functions' that don't do anything [at all] outside of the scope of that function.
C++ 20 is postmodern C++
&gt;Because then you now exactly how it works True for small teams/projects/your-very-own-projects, opposite for big teams/projects.
The link goes to a part in the talk were he talks about the initialization of a global variable. He says that it will try to evaluate the expression at compile time and do *static initialization* if it can, otherwise it will fall back to *dynamic initialization* at runtime. At least that's how I understand it. In your example Foo f = make_foo ( ); if f is a global and if you know that make\_foo() returns a constant expression then you know that it will be evaluated at compile time. I admit this is a bit fragile and I think this is why they're adding a new keyword `constinit` in C++20.
I guess it's solved by never relying on compiler optimizer. If it decides to compute whilst compilation, than it's good, but as a programmer you shouldn't rely on any optimization that may occur. Kind of the same in Rust language
[The bad publicity](https://latacora.micro.blog/2019/07/16/the-pgp-problem.html).
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cf4g45/excel_addin_conversion_from_32bit_to_64bit/eu7avri/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
`{}` is not an initializer_list. https://en.cppreference.com/w/cpp/language/value_initialization It's a type of value initialization.
It's not always about the client, many clients are different, or don't know what they want. I would like to use COM mostly as the provided interface, not for the inner-workings.
r/cpp_questions
I think we are on the same page, but you paraphrase Daveed as saying 'it will try to evaluate the expression at compile time' and then you go on and conclude 'then you know that it will be evaluated at compile time'. To me, that are not the same statements.
I can't speak for Bluetooth, but COM design principles are quite nice in theory. Implementation on the other hand is very cumbersome.
DirectX API is actually what made me thinking of COM-like API. It might be cumbersome, but it's also true that you dont know the alternative and how much more cumbersome could be.
Im afraid I dont really understand. As a rule of thumb, about 2/3of the clients will use it from a C++ project with different compilers, and 1/3 we expect to use it from VB or C#. I don't expect other languages at the moment.
Thanks for the input.
Windows only.
I guess the main reason is that it's not enforced by the standard. MSVC and Clang are ABI compatible, though. But the story of ABI compatibility is more complex, and you have to take extensibility and STL into account.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cf4mlb/opencv_calibrate_fisheye/eu7bzo3/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
what about 'constexpr if'?
Even though the assembly is identical, it's still less work for a compiler and less work for you (5 characters!) so the advice is worthy.
He's been pushing it for types, but concepts are not types and can't be used in casts or return types like that.
You are worrying about 4 cycles in a code, where you are calling an non-inlined function that does god knows what? Regarding the APIs that use out params: Yes, those are exactly the kind of c-style APIs that I try to avoid or wrap as soon as possible. Just because another library forces you to use them doesn't mean that should be a common case in your code. Also, in general I know roughly two types of those APIs: 1) Very short inline functions or macros (e.g. when manipulating registers) that get inlined and where the optimizer can easily omit the 0-initialization if correct or 2) functions that are complex enough that the overhead of zero initializing an int or even a small struct doesn't matter. All that aside: If you are programming c++ under extreme resource restrictions you've got to do what you got to do. Necessity obviously trumps purity and many reasonable guidelines might not apply. But I anyway don't have the impression that c++ is particularly common on 16Bit micro controllers (I had to push very hard to use it in one of our projects and it wasn't easy to set up, but maybe that is changing nowerdays).
This is true - but it's often done under the guise of teaching C++ at the same time, when it only teaches a superficial knowledge of the lower-level parts of C++.
I'm really surprised by this paper, I've used both `std::aligned_storage` and `std::aligned_union` in the past with great success. If these are deprecated, we should have a library alternative that is equivalent to: alignas(Ts...) std::byte storage[std::max({sizeof(Ts)...})]; Otherwise people will just define that over and over again, defeating the purpose of standardization. Also, the argument that this doesn't work in `constexpr` is not an argument in favour of deprecation, it is an argument in favour of extending `constexpr` capabilities.
Counterargument: `std::string empty = ""` is more consistent with other (non-empty) string definitions you may have; more consistent with C strings; and more consistent with other languages. imo what you will always be doing is translating `std::string empty{}` in your mind to `std::string empty = ""` anyway. Why not abstract that away to the compiler?
&gt;I once had an open source dependency become a porn site. It's damn funny. But it does happen. Can I get the dependency name?
constexpr make a guarantee just not the one many people think. It guarantees that it is possible to evaluate a function at compile time but not that it will be calculated at compile time. The compiler settings will make a huge difference and are way more important than constexpr if you want to make sure that as much of the computation as possible is done at compile time. The compiler will even evaluate things at compile time that you haven't marked with constexpr. But with constexpr you make sure that you - the programmer don't do anything that makes it impossible for the compiler to do that.
what you say about constexpr is spot on, what you say about the compiler is only true if you use the right settings - which you should check and understand if time or space efficiency is important for you. Because depending on the flags you set the result can be widely different.
It looks that way - AFAIK it wasn't fully developed and the C++20 deadline for postponing unfinished features is nowish
It's unconditional.
Committee is working this week. We need to wait the end of the session to discover.
sad if true
I think the problem here is library API vs the APIs of implementation details. On a library API level I want to be very careful about the compatibility promises I make and thus, an explicit opt-in for the constexpr promise makes sense. On the other hand, there are a huge number of small helper functions in any project, where I don't care, if a change breaks a few callers at compiletime, because I a) get immediate feedback if the change would break anyone at all and b) I can often easily fix the call sites. In those cases, the requirement for constexpr is just annoying (same with noexcept)
&gt;The thing is that with Rust. You "Corner" all the unsafe code in a place where it is very visible that THERE is unsafe code. So its also easier to review / test / find bad things. Because you have "cornered" the unsafe code, instead of that it could be "somewhere" in your code and it's hard to find hard to review hard to test etc. etc.
sorrowful if genuine
The important point that people like to overlook is that constexpr does *NOT* even guarantee that a function can be evaluated at compiletime for all input values that are valid at run-time.
This is a troll post? Press the link to the paper on the webpage and you go to a manual 404 page. At the very least, the linked github page is bad.
They're half-baked and have quite a few issues. And don't really provide any significant value.
no it's not. yes, the paper link is 404 but it doesn't change anything
Considering that they were first accepted major feature in 20 and I haven't heard much of a public outcry against it, this is very surprising.
it is indeed
&gt; They're half-baked and have quite a few issues. True. &gt; And don't really provide any significant value. False.
can you show some of the issues?
Ok. Still, with just a headline I have no idea what you are on about. Linking to broken pages seems like a bad idea (even though this github page often seems to work). Anyways, the axiomatic-part of contracts seemed very nice to have. That's the stuff I wanted, so without an article I am unsure if they are targeting the interesting parts of contracts or the parts I don't really care about.
Yes no *public* outcry, but in the committee in the last few meeting it got really controversial.
If you're getting a linker error, doesn't that mean you've missed linking the lib?
What do you mean by that exactly?
I read it as Concepts first 😱
&gt;you paraphrase Daveed as saying 'it will try to evaluate the expression at compile time' and then you go on and conclude 'then you know that it will be evaluated at compile time'. To me, that are not the same statements. You're right. When I wrote *'if you know that make\_foo() returns a constant expression'* what I was trying to say was *'if you know that make\_foo() could be evaluated at compile time'*, so that you know it will try and succeed... Because you might have tested the function thoroughly enough to be confident that it were going succeed in giving you a constant expression. In this case it's trivial to test because the function doesn't take any arguments. All you need to do is put constexpr in front of the definition and see if it compiles. &gt;constinit \[is that accepted?\] I got the impression it was approved from trip reports and other places, but [there still seems to be some work going on](https://github.com/cplusplus/papers/issues/137), so I don't know. &gt;consteval will fix that, though. consteval will prevent the function from being called at runtime so it's not something you would want to use on functions that are useful at both compile time and runtime. constinit is more explicit if you want to ensure that a global variable is being *static initialized* which can be important if you want to avoid the *static initialization order fiasco*. constinit cannot be applied to local variables (because the initialization does not happen at compile time) so it's usage is kind of limited. If we want to ensure that some expression is evaluated at compile time we can already do so by storing the result in a constexpr variable. constexpr Foo f_const = make_foo ( ); Foo f = f_const; With consteval we could create some kind of helper function but not sure it's worth it. consteval auto const_evaluate(auto value) { return value; } Foo f = const_evaluate(make_foo()); Wouldn't it be nice to have a consteval operator? Foo f = consteval( make_foo() ); // this has not been proposed as far as I know We need to be careful if we want our code to be portable, though. Forcing constexpr evaluation for performance reasons where it is not strictly needed runs a higher risk of accidentally relying on specific implementations marking functions as constexpr that are not guaranteed to be (GCC marks many of the &lt;cmath&gt; functions as constexpr and relying on this will fail on most other implementations), and it can also have a negative impact on compile times.
Out of interest, have you looked at Rust code outside of examples intended for beginners? I ask because content intended for newcomers can be a bit more... verbose in things like that than typical code to help the person understand things. That declaration, for example, is twice as long as it needs to be. You would typically write something like `let foo = "foo"` and let the compiler handle the specifics, unless there's some ambiguity.
I mentioned in reply to someone else that I had the need to read RLS code on several occasions. While it's not as bad as the tutorial example, I still had the same "I'm reading a token soup" kind of feeling. Again, I don't know a lot of rust, but the main thing that so far made me indefinitely postpone learning it was syntax.
Ah, my apologies. Your post suggested to me that you had no experience with Rust. I can see why syntax would be difficult to adjust to; it is somewhat different to the typical C-like languages. I remember when I started learning, and coming from a primarily C# background I found the lifetime, reference, and lamba symbols, and the `-&gt;` and `=&gt;` dotted around a bit strange. Not to mention the good old turbofish (`::&lt;_&gt;`). I still get that wrong every now and then. Plus, the return type on functions was on the wrong side. After a while, though, I found I just kind of... got used to it. It's not necessarily better or worse, just... different from what I was used to.
You can even write constexpr functions that return different values depending on if it's evaluated at compile time or at runtime (or at least you will be in C++20 when we've got [std::is\_constant\_evaluated()](https://en.cppreference.com/w/cpp/types/is_constant_evaluated)). Please, don't! ;)
&gt; Ah, my apologies. Your post suggested to me that you had no experience with Rust. No apologies necessary, I get why that was an obvious question to ask. &gt; I can see why syntax would be difficult to adjust to; it is somewhat different to the typical C-like languages. I remember when I started learning, and coming from a primarily C# background I found the lifetime, reference, and lamba symbols, and the -&gt; and =&gt; dotted around a bit strange. Not to mention the good old turbofish (::&lt;_&gt;). I still get that wrong every now and then. Plus, the return type on functions was on the wrong side. &gt; After a while, though, I found I just kind of... got used to it. It's not necessarily better or worse, just... different from what I was used to. For the most part, I can't argue with that. I have to say, though, only haskell, lisp and rust had syntax that made me feel like this. All the others, I may not know the standard library, but at least the syntax is readable!
You need to link the library. Add `-l path/to/lib` to your compiler invocation
Humm I didn't know about that one, after reading about it, it seems minimum timeout is 90 seconds which IMHO is anyway too long, drawback also that it affects all RPC on the node and not app specific since it is a policy setting, that could cause issues. Anyway thanks for the info.
You need to add more details to your post for people to give more detailed answers. What commands did you run, what were your file structure and include statement when "amalgating". And you can't just say " I got an error" and not post the error itself.
&gt; they do leak memory, just in an easier to debug way. Just a note that leaking memory is also in-line with Rust's memory safety. https://stackoverflow.com/questions/56107324/why-does-rust-consider-it-safe-to-leak-memory
We have an embargo on discussing committee results before hey are finalized at the end of the week.
It’s a project It’s a learning experience It adds to their portfolio And sometimes new solutions are better than older solutions. If we never reinvented the wheel we would still be using Windows 95 right now. You want to bare that cross? I know I don’t.
If you get a linker error it means you already got past the compilation phase. That means that all the necessary includes were found, containing the *definition* of all the functions used. &amp;#x200B; Now you just need to tell your compiler where the *implementation* of these functions are. They are typically in a library, either static (say jsoncpp.a) or a shared library (say [jsoncpp.so](https://jsoncpp.so)). If the library is installed, you'd probably use -ljsoncpp.
This answer should really be at the top. Constexpr is not there to force the compiler to produce optimized code (though it might), it's there to help the developer write code that could be optimized by the compiler.
If you‘re browsing random github repos, I would guess a lot of people do it for learning purposes. If you‘ve written a container yourself, its a lot easier to understand why an implementer would make certain decisions or trade-offs. And that will help when picking a library to use in the real world. Otherwise I would say the usual concerns apply: License problems, compatibility with proprietary or legacy code, specific restraints not fulfilled by general implementations, specific usage patterns that can be optimized for
&gt;*definition* Declaration. The definition *is* the implementation, and is what is in the lib.
Wrong
The paper links are often 404 before they get publicly released - after they are debated?
thats really cool, ive been writing alignas(std::max({alignof(Ts)...})) all this time which definetely felt kinda stupid :D
Huge upvote but unfortunately the project has been a bit dead for the last two years, the author is probably quite busy with other projects, and nobody is really picking up any work. I really wish there was more activity again, cereal is awesome!
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Ok, thank you! This makes some sense.
Very often you won't discover your own bugs for a long time if ever. And being overconfident about your own abilities is really detrimental. If you use a library, particularly if it's one with a more or less active community, you'll have dozens, hundreds, maybe thousands of other people using the library, and many bugs have likely already been found and fixed.
Agree with you, but there are 960 open issues in the vcpkg repository. Okay, a number of them are new port requests, but many of them are problems and bugs. Microsoft is massively overwhelmed with the effort and unfortunately this results in quite poor quality and problems for many packages (and/or old versions).
Aztec rider. It was an XSL library for Java. Navigating through the offline HTML documentation and then it would jump to porn. This was in a office environment where porn was a serious offense. I went to my manager right away, but she understood. Ended up putting an entry in my host names file, since I would keep jumping to the site.
Blaze is a bit of a one-man library, unfortunately. It means a [bus factor](https://en.wikipedia.org/wiki/Bus_factor) of 1. This can be very problematic. Okay Eigen is a bit of a 2-5 man show as well, which is kind of really scary, considering how many things rely on linear algebra and Eigen nowadays.
I'd prefer going in the direction D is moving towards. Adding reference/pointer lifetime analysis to compilers, supported by core language annotations, (aka a "borrow checker") and making it optional for sections of code. Giving all code the opportunity of increased safety is better for security than some, especially when legacy code isn't going anywhere anytime soon and has to be interfaced with. It's not as if everything else is equal either, so throwing the baby out with the bathwater for one feature in exchange for a whole new set of problems seems short-sighted. It seems that giving all existing code the option of better safety assurances is infinitely preferable to giving some new code the requirement. Especially considering the new almost invariably has to interface with the existing.
Yea, so what's the difference between `build . - - target install` and `cmake --install .`?
Well isn't the problem then more of tooling? Your compiler should be able to tell you "hey dude. This can be constexpr. You sure you didn't just forget to label it as such?"
&gt; What's faster, understanding its documentation or reimplementing your own version? my own version would have 1% of the features, though
problem is that they didn't template the temporary containers on the Alloc parameter ; see for instance this function which has caused me much trouble : https://github.com/boostorg/graph/blob/develop/include/boost/graph/transitive_closure.hpp#L122
&gt; Regarding the APIs that use out params: Yes, those are exactly the kind of c-style APIs that I try to avoid or wrap as soon as possible. Just because another library forces you to use them doesn't mean that should be a common case in your code. ... and chances are you are going to wrap them by using an uninitialized variable. &gt; But I anyway don't have the impression that c++ is particularly common on 16Bit micro controllers The most common SDK for Atmel (which are 8-bit, not 16-bit) is Arduino, which is C++ - though it's terrible.
https://ossia.io - operations on audio / signal processing graphs
It's actually worse than that, because "automatic constexpr" would be transitive, so you'd have to look at every function that gets called from the first function, and every function that gets called by those, and so on. Pretty much the only way to find out whether something could be called at compile-time would be to try it and see. (Although having said that, it's not all that different from the situation we have today with constexpr function templates, which may or may not be callable at compile-time depending on the template arguments you supply.)
I think you may have taken my comment a bit more seriously than I intended it :)
Notable exception: /u/louis_dionne. Boost Hana docs are excellent.
IRC, there is no hard guarantee the `f` is evaluated during compilation anywhere in the standard. Only that it's also a constant expression.
What do you mean with not relying on compiler optimizer? What does optimization have to do with constexpr? Also can you give me examples of functions that aren't constexpr? I mean I understand that allocation technically isn't, but the compiler can make a allocator based on static memory and use it to enable if wanted. I really don't get why a function shouldn't be able to run at compile time. I'm sorry I'm not really a C++ user, but I'm trying to keep up with it's advancements.
UBSan doesn't detect all UB. constant evaluation does.
That's quite possible. I'll do it myself... /r/woooosh
Because they're bloated for just an inclusion of a structure
Also the fast bits of numpy are written in C so if you only know Python you aren't going to be able to re-implement it, at least certainly not with the same performance.
How would IO work in constexpr?
&gt; imo what you will always be doing is translating `std::string empty{}` in your mind to `std::string empty = ""` anyway.? No, I don't and I think that this kind of thinking is a left over from c and c-style strings, where there is indeed a difference between `const char* foo = nullptr` and °const char* foo = ""` While both syntaxes produce the same result in the case of `std::string`, they generally mean different things to me: Default constructing an value object (including zero-initialization via `T t{}`) means "I don't have a proper value to initialize this with right now and I don't care what it's state is as long as it is cheap to construct". Assigning a value to an object (even if that is the same value that would result from a default construction) means "This is the value I want it to have right now".
I mean sometimes I want to do IO at compile time, like read a configuration file and save it encoded to memory. So at compile time is ideal, instead of lazily decoding it in runtime. I get the compilation time argument, but you can just avoid using functions in const time and lazily run them, a bunch of features are avoided because they trash compilation times in some situations, it's part of the language working with that.
That's a huge benefit if you only need 1% of the features.
&gt; am I stuck with all the other versions in that revision Not necessarily. As I said, that's the idea, so you don't install versions of ports that are incompatible with each other. After all, what if the port that you want the absolute latest version of (which it seems you do) is incompatible with Boost 1.70 for the same reason your application is? Of course this is a trade off, and this safety loses you some flexibility. But it is actually possible to mix port versions from different versions of vcpkg. vcpkg just gets its ports from the `port` subdirectory of the repo, so you can copy the relevant subdirectories from one vcpkg revision to another in a local checkout. This is the same mechanism you'd use to make your own custom port: just put a new subdirectory in there. Of course then there's no guarantee that the versions will be compatible with each other. The problem with this, aside from losing the guarantee that they're compatible of course, is that it's harder for others to build and update dependencies. Normally you'd just say "use vcpkg revision abc123 to build this (and if you want newer versions of anything, use a newer revision of vcpkg and update this document/script)". But this way you'd need to specify something like "use vcpkg abc123, but copy ports x, y and z from def456 first (and if you want to update anything, good luck...)". &gt; It's another build system for C++ that I need to learn along with cmake No, it's pretty much just CMake. The main script for a port is literally a CMake file called "portfile.cmake", and in the simplest cases just specifies a github repo and revision to download from. vcpkg just formalises a few things you would have to do anyway if you were building some packages with CMake. &gt; I'm just going to steer clear of c++ as much as possible and go back to drinking heavily Both are valid strategies IMHO.
Have a look at the sidebar, such questions belong to /r/cpp_questions. Also, specific questions would be appreciated, not just: "I've got homework, solve my problem". Thanks.
I didnt want the solution. Just ideas.
But how can it be a constant expression if you don't evaluate it during compilation [you won't know if you don't]?
Fake!
I think you have a point about the pre-curly braces syntax being more explicit and obvious than the other options. IMHO explicit things are s more expressive and easier to understand than implicit options and options requiring one to know and memorise standards or a set of rules before understand something. Look at the modern take on smarthphones, for a simple analogy: 90's cellphones manuals were getting bigger than the cellphones. Then, designers opted for abolish paper manuals and rely on afordances of its user interfaces. Maybe programming languages should following this philosophy. Anyway. I upvoted your comment. Thank you for sharing your opinion.
&gt; All you need to do is put constexpr in front of the definition and see if it compiles. No, it definitely depends on what's between the braces [and test this 'by storing the result in a constexpr variable' as you write]. &gt; If we want to ensure that some expression is evaluated at compile time we can already do so by storing the result in a constexpr variable. Yes, exactly, that's what I've been trying to make clear to some doubters. &gt; We need to be careful if we want our code to be portable, though ... Sounds like bugs.
QUE ME RESTAS PUNTOS WACHO
Or you just tried using it and checked if the compiler said no, aka how I do a lot of things in C++.
Well much of program's behaviour also depends on concurrent execution. Can't imagine make it work in compile time
The Bible isn’t really good for C++. It’s becoming outdated and it’s mainly about this dude who dies for our sins and comes back again. I suppose it could teach you to forgive those who wrote unnecessary custom data structures, but it’s mainly high-level concepts.
I guess it depends on what you expect from constexpr. I have no problem with a parallel computation at compile time if it means not losing that time in runtime. Of course that depends on what you are doing, but if you don't need that parallel computation at compile time don't set a const to it? Or a template parameter? Just lazy load it and call it a day, just like it has always been done (except for macro hackery).
&gt;I mean sometimes I want to do IO at compile time, like read a configuration file and save it encoded to memory. So at compile time is ideal, instead of lazily decoding it in runtime. constexpr functions as currently specified are only used to compute some result, they do not have side effect, so it doesn't really matter if the evaluation happens at compile time or at runtime. IO at compile time certainly sounds interesting but there need to be a clear distinction in the code between compile time and runtime otherwise it's likely to cause surprising results. Don't forget that the computer that compiles the program might not be the same as the compute who runs it. The IO capabilities and the file structure might be totally different. I don't know if this is something that "reflection" will allow us to do one day, but since compile time evaluation is so slow it might be better to just build a separate program that reads the file(s) and spits out code, as part of the build process. &gt;I get the compilation time argument, but you can just avoid using functions in const time and lazily run them, a bunch of features are avoided because they trash compilation times in some situations, it's part of the language working with that. My main concern is not the time it takes to evaluate constexpr functions at compile time. Just making it *possible* to evaluate all functions at compile time (even if you don't actually do it) requires you to define everything in the same translation unit (inline functions and templates has the same problem). This would require all code to be recompiled each time, which is not a problem if you have a finished program that you just want to build from scratch once, but if you are working on the program and make small changes that you want to test all the time then it becomes a huge problem.
Part of the problem for me with using external libraries in C++ is it often if not always leads me deep down into some kind of dependency hell, where it takes me more time to compile my code than to write it. Including library A requires libraries B C D E, which require F G H I J K L M N O P. Then one gets updated and the others don't work, or one requires an older version of the C++ compiler, etc, etc, etc. Hacking around with 3rd party libraries just to get my code to compile is just a massive headache I'd rather deal without. It's even worse as I work in an academic setting, and when trying to get things to compile on our high performance computing clusters I need to email the support staff, who make take days to weeks to respond with installing and/or updating the libraries I need, to still not have things work right.
That makes sense, it's just that comming from a rust background a procedure macro does that at compile time, altough const functions don't. But it has been pretty nice exploring that compile time world with procedure-macros. You can do anything at compile time with it.
My simple and straightforward answer would be that you don't need this horrendously expensive and overpriced nano degree if you want to become a C++ engineer. &amp;#x200B; To become a proficient C++ engineer you can do either or both of the following: Route 1: Safari books online 1. Sign up for [safaribooksonline.com/](https://safaribooksonline.com/) 2. and head over to Bjarne Stroustrup's titles catalog there: [Bjarne's home on safari](https://learning.oreilly.com/search/?query=Bjarne%20Stroustrup&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=false&amp;include_notebooks=false&amp;is_academic_institution_account=false&amp;sort=relevance&amp;facet_json=true&amp;field=authors&amp;page=0) 3. This page contains his introductory title: "Programming: Principles and Practice Using C++, Second Edition" and "A tour of C++". Both of these can be viewed along with thousands of other titles/video tutorials on C++ and any other programming language. 4. Safari also hosts Robert Sedgewick's amazing book on algorithms using C++ [here](https://learning.oreilly.com/search/?query=Robert%20Sedgewick&amp;extended_publisher_data=true&amp;highlight=true&amp;include_assessments=false&amp;include_case_studies=true&amp;include_courses=true&amp;include_orioles=true&amp;include_playlists=true&amp;include_collections=false&amp;include_notebooks=false&amp;is_academic_institution_account=false&amp;sort=relevance&amp;facet_json=true&amp;field=authors&amp;page=1) , along with several other equally amazing titles from him ( both video and books). &amp;#x200B; Route 2 : Pluralsight Pluralsight has an excellent set of C++ tutorials which they've curated into a path. &amp;#x200B; &amp;#x200B; Both these resources are really high quality and you can go with either of them. Both of them cost around 20-30 USD per month each and you wouldn't get better value for money anywhere on the internet. You can also look at Linkedin Learning ( aka [lynda.com](https://lynda.com) from back in the day) too. They have [18 courses on C++](https://www.linkedin.com/learning/topics/c-plus-plus?entityType=COURSE&amp;sortBy=RECENCY), which will give you a decent intro to this language.
As barchar stated it doesn't trigger the underlying build system again ( has good and bad ). Additionally `cmake-install` offers the ability to do a particular component install and allows for controlling the install location two things which I don't think are possible with the `build` interface. In addition it has nicer controls over installing the stripped install version.
&gt; Also can you give me examples of functions that aren't constexpr? There are many things that could potentially make a function non-constexpr, such as: * Calling a non-constexpr function * Modifying global state * Using `new` or `delete` (even placement `new`) * Throwing an exception * Performing a `reinterpret_cast` or equivalent C cast * Using a class that is not a "literal type", such as anything with virtual functions or a non-trivial destructor * Doing anything that is undefined behaviour according to the standard (even if the behaviour is actually well-defined at runtime with the target compiler on the target platform) (N.B. some of these things will be changing in C++20.)
All of those could be possible, they just aren't right now.
Its basically to replace most ugly `ifdefs` with more syntactically consistent expressions. Thats at least how I look at it :)
My point is simple: since you **are** asking, it is more important to ask your clients than this sub. This sub won't use this. I didn't think you'd use COM "inside", you wrote it's for the interface, that was clear.
**Company:** [OxFORD Asset Management](https://www.oxam.com/careers/) **Type:** Full time **Description:** We are an investment manager based in central Oxford, UK. We are seeking outstanding software engineers to develop and maintain system-critical software. You will be responsible for all aspects of software development on a diverse range of projects, such as automating trading strategies, integrating third party data into our system and the development of data analysis tools. You will work as part of a highly skilled and motivated team who care deeply about software quality, efficiency and robustness. A background within finance is not necessary for this role. The ideal candidate will have several years of experience of commercial C++, a thorough understanding of the STL and be comfortable with good software engineering practices such as unit testing and code review. We also welcome enthusiastic graduates and postgraduates in mathematics, statistics, computer science and the natural sciences with experience in C++. **Location:** Oxford, UK. Central offices located close to local amenities, parks, restaurants, shops and bars. **Remote:** We do not offer remote working. **Visa Sponsorship:** Yes **Technologies:** C++17 on Linux. Python used for internal scripting and research. **Contact:** [recruitment@oxam.com](mailto:recruitment@oxam.com)
&gt;No, it definitely depends on what's between the braces I meant this as a way to test if the function can be evaluated at compile time. If it fails I know that it can't. &gt;\[and test this 'by storing the result in a constexpr variable' as you write\]. That's what I meant. '*put constexpr in front of the* ***variable*** *definition'* &gt;Something has to give, better than at run-time. It's a tradeoff. The same computation at runtime is probably going to run much faster.
Constant evaluation detects all UB which can be written as constexpr... So maybe 10% code coverage, less if you are on C++11.
I see, thank you!
Seems to work with gcc/5.1, clang/3.7 and MSVC 2015 or later. I don't have MSVC 2013 handy. Haven't checked if it works there.
&gt;Right - But this could be addressed by using constexpr as a keyword indicating that a function MUST be constexpr. That is the default would be automatic constexpr, but it would only be guaranteed in the future if the function was explicitly marked constexpr.
For more details on this property or \`constexpr\` to catch undefined behavior see my post \[Exploring Undefined Behavior Using Constexpr\]([https://shafik.github.io/c++/undefined%20behavior/2019/05/11/explporing\_undefined\_behavior\_using\_constexpr.html](https://shafik.github.io/c++/undefined%20behavior/2019/05/11/explporing_undefined_behavior_using_constexpr.html))
Yes. As stated above, the function was evaluated in much less than a second at run-time.
Then you can't do `Iterator x = foo(...)` if Iterator is not a type.
So ... a C++11 string_view?
It's a bit different because Python code is not valid Java code, but a lot C code is valid C++ code.
Cumbersome. That is about as moderate a description I would give com.
Thank you sir for addressing this point specifically. While I still disagree with it, I appreciate that it is now made clear to would-be adopters who can decide for themselves which paradigm they prefer.
You can because that's how concepts work (or did they change the syntax to `concept auto x`... I lost track)
Then yes - COM is totally valid and understood. I'm sure other answers here have more details. Just do the bare minimum (avoid registry etc.). If your customers are demanding IDispatch/OLE/Automation, then eventually put out binaries that wrap your existing and support that.
Is it owning the data? If so then no it's not a string_view
Is it mutable and resizable? If not it's not a string. OP's datastructure is similar to C++17's std::string_views sv("some string") plus multiple constexpr operations like concatenation. Does sv own the array in question?
Of course a string can be immutable
Then it's const.
Ah, concepts, not concept. I overlooked the s. Yes, concepts are not types, so using them like types doesn't make any sense. For further reading checkout: https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/ &gt;As I wrote on the Reddit thread: Second, a huge amount of the discussion in this thread is of the form “but if we had concepts we would write “Conceptname x = …;”. That’s exactly true and I’m one of the ones pushing strongest for that — and it’s a reason to use “auto x = …;” today because it will mean the same thing, namely to deduce the type (not specify it exactly, no conversions, etc.), just adding the ability to check that the deduced type matches the concept. This is a direct (and intended) evolution of declaring with auto per AAA. If you like that, you’re in good company, and you should use auto today. Telling people to declare with concrete types today is not at all the same thing and puts you on a different path of committing to concrete types, which is the opposite of “Conceptname x = …;”. -- Herb Sutter Furthermore, the syntax for concepts can be `auto c = Concept&lt;int&gt;;` Concepts aren't variables, so `auto c = Concept{1};` and `auto c = Concept{int}` doesn't make any sense. The idea is to keep the name of the type, concept, macro, whatever-it-is, to the left most part of the line. You'd be surprised how much it increases readability in a large code base.
I am puzzled by the conclusion too. I understand deprecating `std::aligned_storage` and `std::aligned_union`, leaving only the `_t` variants to avoid accidentally forgetting `::type`. I don't understand throwing the baby out with the bath water on the size bound issue; certainly if the maximum size is unbounded today it is a simple matter to add a bound to the standard. And last, but not least, is `reinterpret_cast`. The proposed replacement *also* requires `reinterpret_cast`! --- Personally, I think an API like such would be nice: template &lt;std::size_t Size, std::size_t Alignment&gt; class erased_storage { public: template &lt;typename T, typename... Args&gt; constexpr T&amp; construct(Args&amp;&amp;... args) { auto t = this-&gt;template get&lt;T&gt;(); new (t) T(std::forward&lt;Args&gt;(args)...); return *t; } template &lt;typename T&gt; void destruct() { this-&gt;template get&lt;T&gt;()-&gt;~T(); } template &lt;typename T&gt; T* get() { static_assert(sizeof(T) &lt;= Size); static_assert(alignof(T) &lt;= Alignment); return this-&gt;template raw&lt;T&gt;(); } template &lt;typename T&gt; T const* get() const { static_assert(sizeof(T) &lt;= Size); static_assert(alignof(T) &lt;= Alignment); return this-&gt;template raw&lt;T&gt;(); } /// Prefer get whenever the type of definition of T is known. template &lt;typename T&gt; T* raw() { return reinterpret_cast&lt;T*&gt;(&amp;storage); } /// Prefer get whenever the type of definition of T is known. template &lt;typename T&gt; T const* raw() const { return reinterpret_cast&lt;T const*&gt;(&amp;storage); } private: alignas(Alignment) std::byte storage[Size]; }; Then provide `aligned_union` on top, which additionally check that the `T` passed is part of the `Ts` list (just in case). And of course I'd wish for `constexpr` support to actually be able to `constexpr` all that...
As a newcomer to cpp, the documentation for pretty much all libraries is horrendous, with Boost being one of the worst offenders.
100% agreed. I think OO has corrupted a lot of people so they see free functions as "bad" somehow. Free functions much easier to chain in "pipes" of processing, they're "guaranteed" to not have implict state through accessing private variables, they're easy to wrap inside std::function and pass around, they're trivial to cache if they're pure, and the list goes on. I prefer POD structs + free functions any day over classes + methods.
binary heaps :-)
reinventing the wheel is fun! C++ is a toolshed (or perhaps a bikeshed) for wheel reinvention.
Throwing an exception is `constexpr` since C++14, even though gcc rejects a number of cases until at least 9.1 where it's rumored to be fixed.
apparently we're getting exactly that dark magic in 20 since constexpr will support new/delete then.
I would note that automatically qualifying an entire function as `constexpr` is one approach, but not the only one. Another approach is the try-and-see, where the compiler interprets as much as it can, and bails out only if the flow of execution reaches an instruction which cannot be interpreted at compile-time. This would, for example, let a user constexpr-call a function which writes to `std::cerr` in case of error, even when I/O is not supported, as long as for the particular set of arguments passed by the user no error occurs.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/cfc9of/recommendation_for_an_opinionated_c_book_that/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; , but that most of them wouldn't recommend it because of how out-dated (and sometimes straight-up wrong) most of it is. So I'd be careful with "bible" books when learning programming. Sounds like a bible to me.
It depends on what you understand by “valid”. Indeed C code can be compiled by C++ compilers. But where C compiler was okay, C++ compiler can create undefined behavior, or vice versa. Working with raw void pointer as with an object of dynamic type(polymorphism) is valid in C, but I can not call it valid in C++. The same goes for all C string manipulating - okay in C, absolutely not in C++. My point is that renaming a file from C to Cpp, or compiling C code with C++ compiler doesn’t make the code itself C++ at all. The code can look the same between the languages, but the mindsets required to produce (and consume) C and C++ code are quite different. I would say as different as mindsets of acoustic guitar player and electric guitar player. Both are guitars, and you can play music written for one instrument on another, but it will sound worse(in general) and feel a bit off. So to answer previous question C-style code in C++ is considered a bad practice because it is just an obvious hint that the author didn’t bother to “think in C++” but choose to think in C thus making the code less readable, more error prone and raising the cost of maintaining such code:)
See also https://github.com/akrzemi1/static_string
How does that change the fact that compiler still technically allowed to compute `f` at run-time?
I (the author) would love to hear your thoughts on it. What is the use case that you would consider refl-cpp for and why? Would you like to see more examples/documentation?
Multi-index is great. Unfortunately, it has dependencies on MPL, when it could be using variadic templates. MPL has several nasty problems, and is not something you want in a modern codebase, let alone an old one where it was used out of necessity, rather than because it was good. A C++11 or 14 reimplementation would be absolutely great to have.
Yes, the data structure does own the data in a std::array&lt;char, N+1&gt;.
I'm using std::array for the underlying buffer. constexpr mutation is only supported in C++17, and I believe we need C++14's expanded constexpr to do any form of meaningful mutation at constexpr time. If we want to stick to C++11, the syntax would look something like auto dec = MAKE_CONST_STRING("abc").const_str.mutate(0, 'd').mutate(1, 'e');
Implementing Concepts in C++03 was sort of a neat brilliant hack, but the result was grody. And it's still just good enough that nobody has come along in the last 20 years to make something clearly better with more modern tools and experience. Using the type selectors "vecS" and "setS" in the API in templates is super weird. You don't get to just do `boost::graph&lt;std::vector&lt;int&gt;&gt;` which would mean you could also do `graph&lt;myOwnType&gt;`. BGL couldn't quite make up its mind and just pick a data structure that was good enough for most use cases to keep things simple. But it also isn't general enough to allow a completely arbitrary type in the templates. So you learn an arbitrary set of names that are a shadow subset of STL by rote. BGL could either be massively cleaner and more pleasant to use, or it could be faster and more efficient to use. And it's so damned flexible that all the combinations of ways you can make a graph with selectors and things almost certainly exceeds the number of developers that actually use BGL on a regular basis! So most of the flexibility is necessarily for no benefit because it's likely that there are many possible combinations that have literally never been used. It's very nearly a tookit for making your own graph library, rather than actually being a graph library. Even the trivial example uses typedefs for types that people are actually expected to use because the BGL types themselves are so unwieldy, so it's fully expected that making use of somebody else's BGL code will essentially require porting to your own subset of the API and typedefs as if you were using two different libraries all together, once you make your own graph types like: `typedef adjacency_list &lt; vecS, vecS, directedS &gt; graph_t;`
yes, probably, maybe. It will be something of a nightmare though. You will have to use the windows headers, you could use libc++ instead of our stdlib. you'll still probably need to use the crt headers from msvc. the thing to pass is --target x86_64-pc-windows-msvc if I remember correctly.
I very much doubt the OP defined the use of "string" in their post via `std::string`. It has a more general CS meaning that includes the OP's class.
Then C++ has constexpr strings since always. They even have a handy syntax: `"string"`
If you're doing what's described at https://www.chessprogramming.org/Magic_Bitboards, you could try following the ideas under "[32-bit Magics](https://www.chessprogramming.org/Magic_Bitboards#32-bit_Magics)", but with 2 64-bit ints instead.
It's not a string_view. It does not support remove_prefix/remove_suffix.
I'd recommend also posting your code in text form in the future as it could help the visually impaired programmers 'take a look' at it and give their opinions as well.
A good example of this is std::vector. Alex stepanov (dont know if i spelled it correctly, ps: creator of the standard library). He later regretted his choice of naming them cause he didnt know that vectors where already a thing in physics.
Implying that people with good eyesight are happy to deal with code as an image file.
Yes I'm doing magic boards. Actually, I just ended up using an array of 2 uint64_t to represent a 128 bit. I didn't do this originally because I thought that this representation would not behave with respect to bit rotation, but it does. Its actually quite fast a rotation, only about twice as many instructions as rotating a 64 bit, and it is much faster than using boost::uint128_t. Also it lets me use multiply using the fast multiplication of the halves, which is something that bitset and valarrays can't do quickly
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/cfezq4/could_i_get_some_help_include_iostream_doesnt/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Witch craft! I wonder how they'll implement that.
&gt;I don't have MSVC 2013 handy. Haven't checked if it works there. sec...
 1&gt;------ Build started: Project: test, Configuration: Debug Win32 ------ 1&gt; test.cpp 1&gt;d:\dakota\downloads\test\test\test.cpp(25): error C2144: syntax error : 'auto' should be preceded by ';' 1&gt;d:\dakota\downloads\test\test\test.cpp(25): error C2065: 'N' : undeclared identifier 1&gt;d:\dakota\downloads\test\test\test.cpp(25): error C2975: 'N' : invalid template argument for 'detail::index_sequence_builder', expected compile-time constant expression 1&gt; d:\dakota\downloads\test\test\test.cpp(9) : see declaration of 'N' 1&gt;d:\dakota\downloads\test\test\test.cpp(32): error C2143: syntax error : missing ';' before 'std::array&lt;char,L+R-1&gt;' 1&gt;d:\dakota\downloads\test\test\test.cpp(32): error C2065: 'L' : undeclared identifier 1&gt;d:\dakota\downloads\test\test\test.cpp(32): error C2975: '_Size' : invalid template argument for 'std::array', expected compile-time constant expression 1&gt; c:\program files (x86)\microsoft visual studio 12.0\vc\include\array(18) : see declaration of '_Size' 1&gt;d:\dakota\downloads\test\test\test.cpp(32): error C2065: 'R' : undeclared identifier 1&gt; c:\program files (x86)\microsoft visual studio 12.0\vc\include\array(18) : see declaration of '_Size' 1&gt;d:\dakota\downloads\test\test\test.cpp(32): error C2065: 'LI' : undeclared identifier 1&gt;d:\dakota\downloads\test\test\test.cpp(32): error C2975: 'I' : invalid template argument for 'index_sequence', expected compile-time constant expression 1&gt; d:\dakota\downloads\test\test\test.cpp(4) : see declaration of 'I' 1&gt;d:\dakota\downloads\test\test\test.cpp(32): error C2065: 'RI' : undeclared identifier 1&gt; d:\dakota\downloads\test\test\test.cpp(4) : see declaration of 'I' ========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========
This could get more interesting if the constexpr-ness varied based on input argument or on a template parameter.
Your comment agrees with mine, but I was mostly making a [RedGreen joke.](https://youtu.be/bR23H7ACnNY?t=20)
Yo what is this theme? I need this badly.
&gt;kavel Well of course. But that's kinda missing the point of talking about how a type manages memory internally. What you're showing here is that whne you manage the instance of a type itself you can put it wherever you want but that's a given and is true for every single type in C++. &amp;#x200B; When you talk about "is the buffer of std array heap/stack allocated" then you usually talk about how the type itself manages the memory internally, and for std::array's case the answer is it never heap allocates it like std::vector
Why isn't foo() evaluated at compile time?
Although you can write a constexpr version of strlen as far back as C++11, so it's still something anyone can do for their own classes. It's not magic or anything.
Clang, at least, doesn't appear to do any special-casing. Inlining is what makes strlen("foo") work: https://godbolt.org/z/hdZGyN
Sorry, for that. I had the example ready to commit to master, but it seems I have forgotten to do so. Of course, I meant to provide the code too. Wouldn't want anyone to have to transcribe from an image.
**This Example:** [**https://github.com/veselink1/refl-cpp/blob/master/examples/example-builders.cpp**](https://github.com/veselink1/refl-cpp/blob/master/examples/example-builders.cpp) **refl-cpp Repository:** [**https://github.com/veselink1/refl-cpp**](https://github.com/veselink1/refl-cpp) **Blog Post:** [**https://medium.com/@vesko.karaganev/refl-cpp-deep-dive-86b185f68678**](https://medium.com/@vesko.karaganev/refl-cpp-deep-dive-86b185f68678)
The theme is called "One Dark Pro Monokai Darker". 🥴It is my favorite. I have touched-up the contrast here a bit, though. Here is a link: [https://marketplace.visualstudio.com/items?itemName=eserozvataf.one-dark-pro-monokai-darker](https://marketplace.visualstudio.com/items?itemName=eserozvataf.one-dark-pro-monokai-darker)
One will need an implementation for [__iob_func ( void )](https://github.com/degski/iob_func) at least.
The default is not required to work for over-aligned types.
&gt; certainly if the maximum size is unbounded today it is a simple matter to add a bound to the standard. A major implementation's `aligned_storage` is unfixably (ABI) broken. As a result, the only bound that could conceivably be added at this point is not a useful one.
You probably don’t need to link against mingw libs though.
Well, I've lost the thread then, as there must be some reason to do it the very hard way [like dependencies built with MinGW] other than a liking for self-flagellation.
One reason would be cross build from Linux I suppose (same process but not mingw) also maybe building autotools based libs for msvc abi
OP used MinGW, no? All seems a wee bit silly as using clang-cl works perfectly fine, and with the event of almost-always-cmake, getting stuff to build with the VC toolchain has mostly gone away. I had my hand at building gmp the other day [for vc-use], for that you'll need that iob_func.
Hi, lib Author here. I will replace GPLv3 with Appache 2.0 inside next 30 min. Thank you.
Because it was part of C++98... those were different times.
`valarray` is just a piece of frozen history. It has a host of idiosyncrasies and is little used. If you want to call it something else you can just use a template alias.
Yes, it would be more consistent. But `std::vector` and `std::valarray` were in the 1998 standard, while we didn't get `std::array` until 2011. And then it was too late to change the names. People have mostly forgotten about `std::valarray`, in any case.
I beg to differ. There are real life very prominent projects, gone wrong because of this kind of seemingly irrelevant little details. Some outcomes have been catastrophic. " ...The story of the Mariner space rocket to Venus, lost because of the lack of compulsory declarations in FORTRAN ... " ... What this has to do with us today? I dare to think this is history, very relevant today and for C++ projects too. So please, try not to mix signed and unsigned when coding the pacemaker firmware for example.
The standardization of new features is dark and full of terrors.
I think you misunderstood my post. I was just pointing out that the compilers can warn you when you mix them up. &amp;nbsp; For anyone who doesn't know FORTRAN, it has implicit declarations. How does it work? Every variable whose first character is in the range `['i', 'n']` is an `integer`, the rest are `real`. That's where the "God is REAL unless declared otherwise" joke comes from.
I like to use the VCL for form design. I then write my own C++ code inside the automatically generated functions. This keeps me from having to write win32 API code for my own windows. :)
Because the function is not called in a *constexpr context*. The compiler could still have computed the result at compile time under the as-if rule but with optimizations turned off (-O0) it didn't happen. You can force the function to be evaluated at compile time by storing the result in a constexpr variable. constexpr int r = foo(5); return r;
[served](https://github.com/meltwater/served) is a simple one, depends on asio.
You are allowed to have a throw statement in a constexpr function as long as it doesn't throw during constant evaluation.
While not header-only you I often see Pistache recommended ([http://pistache.io/](http://pistache.io/)).
Appologies. I was rushing to change the licence from GPLv3 to Appache 2.0 ... It is morning here ;)
Licence is now Appache 2.0 Go ahead and use.
It does if you call the right strlen: https://godbolt.org/z/K0_S3c
I think you are right. I normally take "evaluated at compile time" to mean "constant evaluated". I don't think any compiler would actually do constant evaluations at runtime because they would still have to verify that the constant evaluation will not fail, and the easiest way to do that is to simply try to evaluate it at compile time, and it would be stupid to throw away the result only to compute it again at runtime. It also goes against people's expectations. The compiler has great freedom under the as-if rule but normally we don't see crazy stuff.
[httplib](https://github.com/yhirose/cpp-httplib) is header-only, no dependencies.
&gt; No anal borrow checker. Feature, not a bug, at least on production usage where either the machine or the data aren't your own, and a memory vulnerability can be more than a fixable inconvenience. &gt;Variadic generics. Will be in [this RFC](https://github.com/rust-lang/rfcs/issues/376) although not the highest priority and no ETA. &gt;Function overloading. A form of it (IMO better than traditional overloading anyways) will be in the [Specialization RFC](https://github.com/rust-lang/rust/issues/31844). It's close to stabilization, just needs a bit more polish. &gt;Default function arguments. Would be convenient, but [repeatedly rejected](https://github.com/rust-lang/rust/issues/6973) by core team, together with optional arguments and keyword arguments. Their counter is that it adds a complexity to an already very busy area (due to lifetime arguments being there) without a critical benefit to justify them. &gt;Compile time execution. Gradualy being built in the form of [Const functions](https://github.com/rust-lang/rust/issues/53555). A small part already exists, but it's kinda crippled now (e.g. can't do loops/branching yet), with the rest being built over time.
Const generics, generic associated types, specialization, and async/await are the for **major** things Rust needs to deliver to complete its story. The rest can be just small stuff added over the years, but these four really feel missing, and the longer they aren't built, the more painful migration to them will be, since they will allow better (but incompatible) APIs to those that can exist today, leading to a (at least temporary) ecosystem fracture and migration effort,
I must be wrong. I am switching compilers, but have no warnings here: [https://godbolt.org/z/u0fkZo](https://godbolt.org/z/u0fkZo)
What you're doing wrong is: - `-Wsign-conversion` isn't included in `-Wall` in clang. - Your `sc` is declared as **u**int8_t. And keep in mind that `char`, `unsigned char` and `signed char` are three distinct types.
Out of curiosity, why isn't valarray used more? When I discovered it from /r/cpp a few weeks ago, it seems like exactly the kind of thing that would be handy for me in quite a few situations
I highly recommend it!
FWIW although this is not an answer to your question, I completely changed my opinion on header-only libraries. Now I believe in just enduring the pain of dependency management with CMake `fetchcontent_declare`, system packages, Conan, or container images. When you stick too many header only libraries and template shenanigans into your project the compile times just suck too much and you end up hating life. You compile and build many times, way more than you will deal with setting up a build environment.
I dont use Boost because is not going to solve the problem STL has, well, maybe some but even that (STL + Boost) cant match a good library like .net, Java or similar and you will face the problem of being so little and incomplete sooner or later And if you want to use a library the party just starts, in my case i need that it has a cmakelist.txt in orider to be able to use with CMake (not close to even 50% of projects, is much lower), even if it has other history is if it works and compiles or i can make do it because for sure you will have to touch both cmakes, yours and theirs in order to make it work, after all of that work it may happen that doesnt fit your needs 100%, a thing that happens often so you only wasted time It is more easy and less problematic to create whatever you need, more if it is something easy. With other languages you can try as many libs as you want as they only require one command and an import or similar, in C++ is not that easy And this week i suffered about a library not being fitted for me, i needed a DOM parser, i choose one, it is top of the line and all was fine, two weeks later (this week) i needed to delete some childs of the DOM and surprise, the library i was using doesnt allow it, well it doesnt feel good discovering that when it the project is being done with it... So is a tedious process and is logical that for easy tasks/things you create a custom one instead of dealing with the unknow, if the language allowed changing libs with one click like python do it wont happen, i would be using libs like crazy, one click, fits my needs? No, no problem, another click and try other. If C++ dont make a huge upgrade in the ecosystem it would be soon a niche language, the other day was notice here that MS was planning to use Rust instead of C++, reality is that they are already using at Azure and MS contributes with 60 engineers to the language, i know because i looked more in more deep, when companys like MS or Google are putting so many resources it means something and it is not good for C++ so it is now or never to make a 201X ecosystem instead of the 80s we use daily
I dont like python but i think that is not true, python has it owns libs made with python, it is only when you compile it (python can be compiled) it replaces all the python code it can with C parts in order to gain a 10x performance but you has to tell it to do it, it is not the default build
How about something like this: ``` module; #include "windows.h" export module your.module; constexpr int WM_LBUTTONDOWN_value = WM_LBUTTONDOWN; #undef WM_LBUTTONDOWN export constexpr int WM_LBUTTONDOWN = WM_LBUTTONDOWN_value; ```
Use either ```vector``` or ```array``` depending on whether you want to dynamically size or not. ```valarray``` is not as good as either in any situation (why do you think otherwise?)
&gt; The standardization of **new** features is dark and full of terrors. I see what you did there. It's also worth noting, that features are never deleted.
That's the theory yes. gcc 7.3 certainly doesn't like it, though :(
How did they? *sigh* :(
Valarray was not meant to be a container like vector or array, but to represent a mathematical vector and to allow for easy and efficient vector operations. IIRC, in theory, the specification iallows for more efficient math computations than what you get if you implement them in a native portable fashion on top of e.g. std::vector. But I don't think any standard library implementation or compiler has ever used that leeway.
std::valarray was meant for vector computations not storage. However you are much better of using a linear algebra library like Armadillo or Eigen, so it's pretty much useless now.
Pattern Matching | Optimistic C++23 :) (goes back to sprinkling asserts)
&gt;constinit keyword Isn't this what constexpr variables do?
Modules and a sane build system is all I want for Christmas..
Seems to work fine. [https://godbolt.org/z/YKPto7](https://godbolt.org/z/YKPto7)
std::format &lt;3
Sometimes yes. [Sometimes no](https://stackoverflow.com/questions/34280729/throw-in-constexpr-function): &gt; error: expression ‘&lt;throw-expression&gt;’ is not a constant-expression As per [#67371](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67371): &gt; This seems to have been solved entirely with the release of 9.1! So it should remain closed. (8.3 is still broken) It's unclear what exactly would cause the "random" behavior; some control-flow analysis gone awry I suspect.
No. You can't modify `constexpr` variable, while your can modify `constinit` variables. Effectively: constexpr = constinit + const
constexpr variables may be initialized at runtime. constinit must be initialized at compile-time, this allows you to depend on them being available when initializing other static variables. I think.
I upvoted you, because it's a very reasonable argument - but it's a reasonable argument I don't actually buy. I'm generally not a big fan of "people should know", because that's a path to error, but in this specific case I would be pretty suspicious of a C++ developer who didn't understand what `std::string empty;` did. Another possibility is `auto empty = std::string{};` if you are an Almost-Always Auto person, which I almost always am, but I wouldn't use that either. I wouldn't mention it if I saw either version in a code review, however. However, `std::string empty = "";` is definitely the worst of both worlds.
First of all, thanks for the report. Before I read the whole report, I want to share my thoughts about `volatile_load` and `volatile_store`. Some people use `volatile` for its intended purpose - variables used inside CPU interrupts, today, need to be `volatile T`. If C++ deprecates `volatile` keyword in favour of `std::volatile_store()` and `std::volatile_load()`, it suddenly because much easier to directly read/write to a variable that used to be `volatile` by forgetting to use these specialized functions. Yes, this can be solved by something like the following: template&lt;typename T&gt; class VolatileT { T t; public: VolatileT(T new_t) { volatile_store(&amp;t, new_t); } operator T() { return volatile_load(&amp;t); } }; Why not add something like that to the [P1382](https://wg21.link/P1382) with a name like `std::volatile_value&lt;T&gt;`? I'm certain there's enough people working on freestanding systems that would benefit from not having to maintain the above class which is essentially boilerplate (however tiny in line numbers).
OK, that's obviously a bug. Good that they fixed it.
Hey, I actually use ostrstream...
Constexpr variables have to be initialized at compiletime too. That's their whole reason to exist (otherwise const would do)
P1152 doesn't deprecate the keyword; it deprecates a bunch of uses of the keyword and volatile variables that have dubious use cases, often being in the language just for a false consistency with const. The R0 of the paper goes into the details of what it proposed and what it explicitly didn't touch.
Correct; the keyword is a compile time assertion of "this object has constant initialization, so it will be initialized statically, without any runtime code to execute".
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [ISO C++ WG21 Cologne Meeting report - C++20 feature freeze](https://www.reddit.com/r/programming/comments/cfkl3d/iso_c_wg21_cologne_meeting_report_c20_feature/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Unfortunately those desires are somewhat in conflict.
I had really hoped for a minimal version of contracts to gather experience and then extend them in future standards where necessary. Waiting for c++23 will just result in that much more bike shedding and feature creep without actual feedback from the user.
That's right, but the paper about `volatile_load`/`volatile_store` (the linked P1382) is the one that talks about deprecating the keyword entirely.
I was recently surprised to find `std::valarray` quite handy when I had to perform several masking operations on small arrays of values. It is quite expressive and the job well enough.
You're using the wrong beer emoticon for Cologne.
&gt; [`web_view`](https://wg21.link/P1108) got strong support, with lots of design feedback. Very surprising, I didn't expect that because personally, I think that the proposal is not very good. If we use JS and other technologies to display stuff, why not directly use those languages? Why go through C++? But maybe I don't understand it; I'll make sure to go through the minutes.
Just want to say: Great work on finalizing C++20 - A real major update! And it makes me more eagerly looking forward to C++23 which may be the next big release! Also it's interesting that the committee seems to be blessing works on graphics, more specifically the web_view and updated 2D graphic proposals. IMHO it is still a big plus for C++ if we really get this included. Would like to know what the committee's stand on this now, and really hope that the communities can be united on this eventually.
+1. There was consensus for P1607 in Evolution, which IMHO was an almost perfect minimal version of the feature that would have allowed us to gain experience without assuming what user wants (in contrast to what the removed status quo did). Unfortunately the consensus was reverted by the decision to remove contracts all together.
I'm not seeing that in the proposed wording or the prose, but maybe it's just the past week finally getting to me... ;)
Give me the right one?
What about renaming co_yield to yield?
Yea, that makes sense. Constinit variables are thus constexpr variables without the const at runtime, essentially. Pretty far from what I described. Thanks
No.
There were at least two papers for that, can't remember the polls right now...
I'm still sad they didn't drop strstreams, they have been deprecated since 98...
We really tried to get something minimal out -- but in the end we need to agree what we're doing is right, and if we're unsure, the right thing to do is defer.
AFAIK Intel offers a heavily optimized version...
So sad :(
How Ranges could be merged in case they depends on Concepts, which has been moved off?
Which of the alternatives would you prefer? a) the standard library no longer compiles (this_thread::yield), or b) the same code in a coroutine can have a different, yet still valid meaning than outside of a coroutine (context sensitive keywords for inside coroutines)
There's no "blessing" on webview or graphics. WG21 has a number of levels and branches, and passing the last level on the international standard branch is the only way to say the thing is C++XY. Webview passed the most basic level and graphics is not on IS branch at the moment.
Okay, I reread P1382 again and it really doesn't mention deprecation or removal of `volatile` keyword. &amp;nbsp; The place where I read that P1382 implies removal of `volatile` keyword is /u/c0r3ntin's [blog post after Kona](https://cor3ntin.github.io/posts/kona2019/#deprecating-volatile). &gt; Thanks to JF Bastien, **we are taking some steps towards getting rid of the `volatile` keyword**. [P1382](https://wg21.link/P1382) which will not be in C++20 will offer a sane replacement for the useful use cases of volatiles. Emphasis mine. &amp;nbsp; pinging /u/jfbastien
Contracts was moved out, not concepts.
Thanks for the clarification.
Looks like shit tho 😅 but it fits well into C++ that way I guess
A step towards. It might take a very long time. Definitely not any time soon !
Heh, I read your blog post to mean that P1382 implies deprecation of the keyword. Thanks for clarifying that.
One day. Maybe. Baby steps. Definitely not before we replace all supported use cases ! That would be bad form
That's a relief. I was surprised by the, wrongly assumed, haste to get rid of volatile. I know the committee is usually very careful about breaking changes. Still, if C++ is going the route of `volatile_store`/`volatile_load`, besides the names being confusing, I'm interested to hear thoughts about including a wrapper class template like the one I posted at the start of this comment thread.
I'm not complaining - better be safe than sorry. It is just my impression that there is too much of an all or nothing mentality when it comes to big features instead of focusing on incremental introduction. But of course that is just my impression from the outside. Reality is probably much different and much more complicated than what I imagine.
I remember reading concerning reports that the memory allocation of [coroutines](https://en.cppreference.com/w/cpp/language/coroutines) could not always be optimized away. Is there hope that the situation can later improve in a backward compatible fashion?
meta programming is destroying c++
b) is perfectly fine !
Homogenous variadic function parameters are a nice surprise. I'm wondering if they need to make the function a template in the case where the paremeters are not a template type? It seems like it would be possible to use a similar mechanism to varargs functions, just with extra type safety and a better way of accessing parameter values (`sd::span`?).
Modules and std::format FTW !!!!
Well, that's not what EWG decided ;&gt; (And for me personally (b) is an over-my-dead-(potentially national)-body objection, sorry.)
Personally I'm not sure it makes sense to replace a language feature with a standard library type that has the same semantics (whatever they are).
Thank you all for your answers. I'm a big user if Eigen so I don't really need a thing like valarray on a daily basis but from time to time, it seems to be the right tool for the job (that one place in your code base where bringing in Eigen would be an overkill). Maybe a generic wrapper around standard containers bringing valarray like functionality would be a good addition to the STL
I can see your point. Am I wrong to think that it implies inability to deprecate `volatile` keyword for valid use cases?
Thanks. I (obviously) wasn't aware of that. One of those days I have to seriously check out Intel's toolchain.
Ju to by
*laughs in constexpr*
As an alternative to C would be more correct. Microsoft never really adopted C++ for their systems code.
Love all the constexpr stuff
Probably? I haven't followed those papers, but why would you want top deprecate valid usecases. IIRC a problem with volatile was that it was weakly specified, so maybe this is more a question of fixing the specification than replacing it.
Using precompiled headers solves that problem.
The specific syntax is still open for debate and the author of the paper at some conference said that feedback is welcome, so... Try to come up with something better that takes into consideration all the things the paper does and contact the author.
So what issues did you run into?
That's an interesting question. As far as I know, coroutines have a sketched out path for future improvements, but I don't know the specifics.
Maybe i missed that in the past, but what's about structured bindings being unable to be captured in a lambda-expression? I remember i read somewhere that this will be concerned in C++20. I think this makes structured bindings very unattractive :(
&gt;Pattern Matching | Optimistic C++23 It seems like everything that has not been approved for C++20 is Optimistic C++23 / Conservative C++26.
I haven't read the full paper and am not really willing to because I'm just not really invested in C++; but why not orient it on one of the languages that already have pattern matching and are doing it well like Rust, Haskell, OCaml or F# (There probably are a lot more languages that already have it). Rust would probably fit into C++ best
Using both is better , you get performance robust cpp code and JavaScript frontend.
Regarding the paper, and to clarify in particular (/u/HalFinkel) : &gt; It has been further suggested that I look at QML/QtQuick, instead of QtWidgets, as a point of comparison. However, it’s not clear why standardizing something which looks like QML/QtQuick would be more useful than using web content. The reason is that QML is a language which is specified for interoperability with C++. That is, in current C++ (+ moc's reflection features, which is doable in pure C++ with https://github.com/woboq/verdigris, or, ideally in C++23 with metaclasses) , given : class Foo : public QObject { Q_OBJECT Q_PROPERTY(int bananas READ bananas WRITE setBananas NOTIFY bananasChanged) public: int bananas() const; void setBananas(int); Q_INVOKABLE double doStuff(QString, QString); signals: void bananasChanged(int bananas); }; then it is possible to have QML code doing Item { Foo { id: aFoo bananas: 36 } Label { text: "there are " + aFoo.bananas } PushButton { onClicked: aFoo.bananas++ } } without requiring any further work. What equivalent of this is there in the web world ?
If you look at the example code, you'll see that the C++ code emits HTML and JS. Why? Why do you need C++ for this?
HTML, CSS and JS/ECMAScript is becoming the "standard" of modern graphical user interfaces. It makes a lot of sense to use such standards instead of reinventing the wheel. And it still makes sense to implement the backend in C++ to leverage the performance C++ gives, even if the frontend is in JS. So I am very happy that a web-view is suggested, but such a thing would have to be kept up to date (at least two updates per year to be kept up to date with the constantly evolving web standards/[API](https://developer.mozilla.org/en-US/docs/Web/API)). Applications using [Electron](https://electronjs.org/) are already embedding a Chromium based web view together with EACH application (which causes a lot of bloat). Preferably C++ should also use a Chromium based web view (because it has the most complete implementation of today's web standards) but instead allow it to be loaded from an external library that is shared between every application using it (so we don't end up with bloat). I don't really see this happening though, so for now I will just spawn my user interfaces inside a browser which is communicating with my backend using WebSockets.
What example ?
In the paper, where he shows how one could use the proposal.
Even with annotation like `async` or similar?
Hmm, seems that Unicode actually does not have enough emojis. Therefore i renounce my previous post and state the polar opposite.
I'm honestly impressed with the C++20 feature list. After reading the report I have a few questions regarding `constexpr`: - Considering [constexpr allocation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r6.html) what kinds of allocations are not allowed in a `constexpr` function? Those of the classes whose destructor doesn't release the memory? Anything else? - What other operations are not allowed in `constexpr`? I know throwing an exception, executing inline assembly, I/O, `volatile`. Did I miss anything? &amp;nbsp; On an unrelated note, I am so happy that [P0466](https://wg21.link/P0466) made it in!
&gt; I'm wondering if they need to make the function a template in the case where the parameters are not of a template type? Yes; which is potentially a problem. &gt; It seems like it would be possible to use a similar mechanism to varargs functions No that isn't possible, because you'd expect things like fold expressions and `sizeof...` to work and for that it needs to be a template.
Yes; I don't want to need to go look for what context I'm in to be able to mentally parse a statement.
That was added in the last meeting. I don't I understand your last sentence.
&gt; Those of the classes whose destructor doesn't release the memory? Jup. &gt; What other operations are not allowed in `constexpr`? Coroutines ;)
&gt; Deprecating volatile I tried to read the paper, but I'm not entirely sure I get what the change is. I got the impression from reading it that it is only a partial deprecation, removing the 'footgun' parts. Does someone know how this might affect volatile inline assembly? e.g. `__asm__ __volatile__("" : : "r"(data) : "memory");` (a dummy read part of a secure memset for clang/gcc)
In the link you sent ? If so obviously we need C++ for a task which isn't the GUI or maybe we mix both HTML UI and C++. Just take the best of both worlds as I said. HTML UI for desktop apps is pretty common and looks great.
It has been taken into consideration. The main difference is something like this (full disclosure: I may botch the syntax): int x = 3; int y = match(x) { 1 | 2: return 0; // bitwise XOR or multiple possible values to match against? 5 | x: return 1; // bitwise XOR or multiple possible values to match against? // to the left of `:`, is `x &lt;=&gt; 3`, making this equivalent to `5 | 3` // or is `x` a placeholder binding, making this, essentially, the default match-all case? - The C++ paper allows both, but with different syntax. } Pattern matching can introduce a lot of these ambiguities and the paper takes care to address them all. Right now that is at the cost of readability. Another iportant piece of the puzzle is keeping things consistent. Should `1 | 2` mean a different thing inside a pattern matching block? Somewhere along the way, the design deviated from rust's and if I remember the conference talk correctly, it had to do with consistency.
&gt; Homogenous variadic function parameters Which paper are you referring to?
&gt; Jup. And you can't return such a type from a `constexpr` function. Those classes aren't exception safe anyway, so they'll leak sooner or later. I'll just pretend that those don't exist. How is compiler supposed to know that the destructor correctly cleans up the allocated memory? Allocators can get quite... creative. &gt;&gt; What other operations are not allowed in constexpr? &gt; Coroutines ;) Naked `new` and `delete`? Placement new and placement delete? Inside a constructor and destructor, respectively? &amp;nbsp; Either way, I'm amazed how far `constexpr` got.
There's not an obvious way forward to get guaranteed zero allocation without a special allocator.
Anything about P1383R0 (constexpr math)? This will be awesome for DSP (e.g. computing coefficients at compile time).
Paging /u/jfbastien
Clearly the right answer is to add said emojis to Unicode...
"Making std::string constexpr" source\_location: constexpr **const char\*** file\_name() const noexcept; constexpr **const char\*** function\_name() const noexcept; Hmm, may be here must be std::string?
I'd be nice if web_view would provide a way for C++ to render directly to a `&lt;canvas&gt;`.
Re b) I’ve read a lot of discussions on this and I was initially for it. After reading your concise description I finally see the problem. we can’t have the semantics change if I am refactoring code and it moves from outside a coroutine into a coroutine... Thanks
&gt; Those classes aren't exception safe anyway, so they'll leak sooner or later. I'll just pretend that those don't exist. Sorry I meant that even if the destructor cleans up any allocated memory you can't return such type. &gt; How is compiler supposed to know that the destructor correctly cleans up the allocated memory? Static analysis basically. You can't generally use placement new and the `void*` new is disallowed. What you can do is use typed new and allocators. Those can happen wherever.
&gt; at least two updates per year That's not going to happen as long as C++ is an ISO standard.
Why would you force the compiler to do that extra work and introduce a dependency on `&lt;string&gt;`?
&gt; Homogenous variadic function parameters are a nice surprise. I cannot recall any motion for this in Cologne. And I cannot see this in the report. Are you sure these got in or were even discussed?
&gt; Sorry I meant that even if the destructor cleans up any allocated memory you can't return such type. So `std::string` which is now `constexpr` still can't be returned? &gt; Static analysis basically. You can't generally use placement new and the void* new is disallowed. What you can do is use typed new and allocators. Those can happen wherever. So the following would work in a `constexpr` function? int* x = new int; delete x; &gt; Static analysis basically. Alright, that makes sense, even though you can make things too complex for any static analyzer to understand.
&gt; So `std::string` which is now `constexpr` still can't be returned? If it stays in constexpr land it's fine. You can't assign the return value to a constexpr variable for example. &gt; So the following would work in a `constexpr` function? AFAIK yes. &gt; Alright, that makes sense, even though you can make things too complex for any static analyzer to understand. There is a constant evaluator running. If it ends with memory that hasn't been deallocated, it complains. So it's not really static analysis technically I guess.
&gt; It's also worth noting, that features are never deleted. That's not true. Look at `std::auto_ptr` and `std::binary_function`. There are more, these are just the ones I've encountered.
Alright, that all makes sense. It's still impressive how far `constexpr` got. &gt; There is a constant evaluator running. Isn't that just an interpreter, like python has? Well... closer to what vim has for its embedded language since there's no bytecode compiling.
I don't think this would be ambiguous because you can't put nonconstants as a pattern (disclaimer: I only know rust and haskell maybe it's allowed in other languages but I kinda doubt it) so this would always be 1 or 2 and 5 or x would make no sense since x is a wildcard that matches everything by binding to x. And as for consistency: you don't need to use | here. You might as well just put every pattern on a seperate line. But if you want to use it the languages that do so get by fine (and they also have the | as regular operator). &amp;#x200B; You could make the argument that it would make C++ harder to parse but that ship has sailed a long time ago and no beginner would attempt to do so anyway.
Yeah it is! It's pretty crazy :)
So C++20 adds two new `const` keywords. May I suggest `xzibitconst` for the next one?
In C++ you almost always need to know what context you're in to mentally parse a statement. Even something like `x * y;` or `a b(c);` is ambiguous unless you know what declarations are in scope at the time.
In my opinion HTML UI is generally terrible. It never looks native, it has huge overhead for even the simplest windows, it invariably feels 'wrong' as the MMI exists in a different process from the actual application (and has trouble synchronizing), etc.
Yes, but that usually depends on names in scope. I want to avoid having to add "is this function 'async' or not" to the list of things I have to constantly track. Besides, this one is harder to deal with than those while refactoring or writing more code around it. Btw. 'async' itself was an abhorrent choice for the marker in itself.
I am little concerned we are painting ourselves in a corner, then. Other languages seem to be managing just fine by using a different paradigm altogether: transforming the coroutine into a (voldemort) struct which is essentially a variant encoding the resumption point and the possible set of live variables (depending on said resumption point). I heard that somehow this was not considered possible in C++ as the size of such struct couldn't be known at compile-time, as optimizations would first need to be applied. How, then, do other languages manage it? I very much doubt their compiler technology is much more advanced than C++'s, so surely there's something we are missing here. Desugaring to a struct, *just like lambdas do*, would completely sidestep the issue of memory allocations; it seems eminently preferable to me!
C++29 ought to be the next big release. There will be lots of consolidation to be done after C++20, I'm sure.
Thanks, I always appreciate the wire up /u/blelbach. Are you able to post with correct formatting first try?
&gt; so this would always be 1 or 2 Why? Syntax `1 | 2` always meant "bitwise or" which would evaluate to `3`. &gt; you don't need to use | here. You might as well just put every pattern on a seperate line. But if you want to use it the languages that do so get by fine This was also mentioned in the conference talk and the example was Swift, which until recently didn't have a way for one of the two interpretations of `1 | 2`. Recently they allowed the other interpretation by adding some wonky syntax, essentially ending up with C++ sketch of pattern matching\*. &amp;nbsp; \* To be clear, this is just what I know from listening the talk at the conference I keep mentioning.
&gt;Homogenous variadic function parameters are a nice surprise. This suggests they made it in. They were only discussed.
I am german and from cologne and I say beer is fine.
I believe it's this paper: [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1219r1.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1219r1.html)
This is why languages shouldn't be on 3 year release cycles.
So constexpr is compile time initialized, can be used in compile time expression and const at runtime. constinit is compile time initialized but can't be used in compile time expressions, and non-const at runtime. The question is, do we really need two different keywords for that? Why not just make a keyword for compile time initialized objects (that are also can be used in compile time expressions), and if you need it to be const at runtime just add regular const.
They were discussed in EWGI.
We have a private subreddit where we test and proofread.
Cologne had me very confused for a second
I know, that was just a really dumb joke.
Well that takes away some of the magic :/.
Hahaha, I see! :-) Nice video!
There is none. The web is a clusterfuck of full blown web frameworks who need to work around of all the limitations of html/css/js. But I think this proposal only shows one thing: This is a perfect task for a library. We need a alternative to Rust cargo for c++ to handle such libraries. Just because we cannot simply add Qt = "5.13" into a toml file like in Rust we need now everything in our standard library?
Clang may get a constexpr bytecode: https://lists.llvm.org/pipermail/cfe-dev/2019-July/062799.html
&gt;Why? Syntax `1 | 2` always meant "bitwise or" which would evaluate to `3`. Because that's how pattern matching works. If you need dynamicity in there you use a pattern guard which then removes the ambiguity because it moves the `|` into the guard expression. I don't know swift but I don't see it as a predominant pattern-matching language. Small rust example: [https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f96d92c4725f42551b14f8e23f63408a](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f96d92c4725f42551b14f8e23f63408a) fn main() { let x = 5; dbg!(match x { 1 =&gt; "one", 2 =&gt; "two", //1+2 =&gt; "three", // invalid, can't match on inconstant values 3 | 4 =&gt; "three or four", // | is obviously regarding patterns x if x == 5 =&gt; "five", // only matches if value bound to x leads to guard expression evaluating to true x if x == 2 | 4 =&gt; "six", // | obviously a bitwise operator _ =&gt; "Well I don't know", // wildcard matches everything else }); }
Why exactly?
And I'm arguing that your interpretation of `|` is inconsistent and that "it's how other languages do it" is a weak reason to introduce inconsistency like this one.
Why, other languages managed to do it, and it works perfectly fine for them Is C++ doomed to be deprecated because it is unable to clean itself ? C+++ when ?
They probably give up other optimizations that C++ doesn't. In our case the cure was worse than the disease. In theory you could everything you're looking for, but it wouldn't be with today's compilers, and probably not even C++.
?
If it's a web view for C++, why not support using C++ for the front- *and* backends?
[P1112 - Language support for class layout control](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1112r1.pdf) is silent about nested structs. What will the the size of Y: struct X { unsigned long long a; int b; }; [[layout(smallest)]] struct Y { X x; int c; }; 16 or 24? It is not much use maximizing tail padding unless you can use it. Something like this paper is sorely needed however. Currently getting Clang to reuse the tail padding for a nested struct requires a lot of fiddling with no_unique_address and base classes. And MSVC doesn't reuse tail padding at all.
I preferred the `async` keyword approach, as did every single one of my coworkers I showed it to.
What about contracts is so controversial? The axiom? The continue after failure? I mean, I think about contracts as language level asserts, so I don't find whats so controversial about them. I am probably missing something.
Yeah, I think looking for a single `async` keyword is *vastly* less taxing than finding arbitrary `co_meow` keywords.
`constless`
What is MMI?
I also use `volatile` to access memory mapped devices.
I agree fully. The answer isn't a bigger standard library, it's making it easier to use third party libraries. Thus the C++ Modules Ecosystem Technical Report.
I do feel that I'm slowly getting pushed towards D. I've expressed my concerns before as have others, but it doesn't seem as though the committee takes them to heart.
&gt;`co_ns` What's wrong with `co_const`?
Pathetic
Two more characters. I have tendons to think about.
To me no being able to declare a variable \`yield\` in a coroutine would have been ok, but being forced to use workarounds to access objects called \`yield\` or \`await\` declared outside the coroutine - objects that might not be under your control - is a big downer. I still think that being able to make it obvious that a coroutine is a coroutine at the declaration point (and when you don't know its body) would be a very valuable feature.
Its not even the performance that makes me want to use it necessarily, mainly just the fact that its a convenient class that provides a lot of useful functionality, instead of having to use some sort of random vector-like thing pulled in from a library
There was also a proposal to change coroutines in C++20 so that it would have been possible to add RVO for coroutines later but it apparently wasn't accepted during the meeting. I'm not sure what the future will look like, but it seems that we won't be able to get RVO for coroutines in the future?
Absolutely. I still hope for lin alg types in the standard library.
&gt; They probably give up other optimizations that C++ doesn't. Maybe? My "no silver bullet" mantra tell me indeed it's likely a trade-off. &gt; In our case the cure was worse than the disease. I'd like to know more about the alternatives, with their pros and cons. Are there records I could check? &gt; and probably not even C++. Do you mean there's something specific to C++ that could prevent optimizations, or is this a more general statement?
lol
it's not inconsistent. The context makes it 100% clear what you mean and nobody that has any experience with pattern matching would assume that 2 | 4 matches 6 but rather 2 or 4. But as I said, if you want to use a different seperation character you always could (for example unicode codepoint 2223 ;) ). Or you just don't allow it at all (IIRC that's what Haskell does). "How other languages do it" in this context is a big factor because pattern matching is a feature already widely adopted in lots of languages and even ones with similar syntax and C++ is kinda "late to the game".
It will probably not make it. There wasn't enough time in LWG unfortunately.
Everything unfortunately. :( And I'm not even exaggerating. Continuation, axioms, global build levels, assumption were very controversial. There isn't much left if you take those things away.
The main motivation for `constinit` is to avoid the "static initialization order fiasco". It's not something you can use on non-static variables. It was originally proposed as an attribute but it was changed into a keyword because it should not be something that the compiler can ignore.
&gt; Rename Concepts from PascalCase to snake_case 😫
Its extremely slow as well. Developers have been moving away from scaleform for yonks, every app which uses anything even near html for ui is unbelievably heavy
Can anyone explain how the spaceship operator is used? All I can ever find is how to create it in a template but not how it is used in an if statement.
Remove the "probably". The train has left the station, nothing more is going into C++20 except bug fixes.
Standard library types look like that. (I don't like the renaming, but still)
Isn't this true of code already, due to things like ADL etc? If you copypaste code and hope it works you're going to run into issues anyway
I’m not sure I agree. I feel like that is a knee jerk reaction because coroutines are new. From a callers point of view coroutines are no different from a function that creates a thread and does the state machine manually.
&gt;Man–machine interface, I guess.
\&gt; I'd like to know more about the alternatives, with their pros and cons. Are there records I could check? &amp;#x200B; The memory is fading, and I wasn't expert enough any way, but basically the problem is knowing the size of your stack frame is C++ front end, and optimizing memory is generic back end. You'd have to construct a compiler that has an extra side channel to deliver C++-specific information to the back end, and IIRC the question polled of compiler writers in the room was "could we do this with C++ compilers in 10 years?" The answer was "no". That was mostly the end of debate. The best record to check is https://wg21.link/p1493
Doesn't this make it impossible to tell whether a function is async or not without scanning through the body of it looking for co_keywords?
Before all thanks for the info so detailed, it is nice to see and check what you want deeper A deprecation? I am glad the iso deprecates obselete stuff, i hope i can see more in the future And i hope that C++ 23 really focus on the ecosystem which is lagging hard behind, i know it is not part of the comitte but should be, after all are part of the tool itself. If not i think that unfortunately C will start to lost traction among the industry as more productive with pretty much the same performance consolidate, it is not only Rust, any other modern language has a hidden build system, a more than decent package manager and a library that doesnt sucks If not it will happen the same as ASM and C, C lost some performance but it was adopted as it was easier and faster to code, with the new winds that we are living it is going to happen again, C/C++ if dont do anything will be switch to another thing making it the new BASIC, Cobol or any other niche language you want, i hope that we as a comunity take the threat serious because it is and deserves to be taken care, now it is still time
Everyone with a different opinion on what to leave out.
It removed the following: - `x += y` where `x` is `volatile` (and other operators like `*=`) - Stated reason in R0: Compound operations in the form of `read; modify; write;` are misleading and should be spelled out as `read; modify; write;`. - `++x`, `--x`, `x++` and `x--` - Stated reason in R0: Same as above. - `Class::Member() volatile;` - Stated reason in R0: It was introduced to be consistent with `const`, but doesn't really make sense. - `f(volatile int x)` - Stated reason in R0: "it leaks function implementation information to the caller. It also has no semantics when it comes to calling convention because it is explicitly ignored (and must therefore have the same semantics as a non-volatile declaration). It’s much simpler to have the desirable behavior above by copying a non-volatile parameter to an automatic stack variable marked volatile." - `tuple_size&lt;volatile T&gt;` and `tuple_size&lt;const volatile T&gt;` - Stated reason in R0: "It’s unclear what hardware mapping is expected from a tuple, and how a volatile discriminated union (such as variant) should be accessed." - `tuple_element&lt;I, volatile T&gt;` and `tuple_element&lt;I, const volatile T&gt;` - Stated reason in R0: Same as above. - `variant_size&lt;volatile T&gt;` and `variant_size&lt;const volatile T&gt;` - Stated reason in R0: Same as above. - `variant_alternative&lt;I, volatile T&gt;` and `variant_size&lt;I, const volatile T&gt;` - Stated reason in R0: Same as above. - `atomic&lt;volatile T&gt;::is_always_lock_free()` needs to be `true`. - Stated reason in R0: "volatile atomic should offer the union of these properties, but currently fails to do so." &amp;nbsp; The compound assignments, increments, decrements changes and changes to `std::atomic` are there because `volatile` is supposed to mean that each byte of the `volatile T` is accessed only once. I have no idea why that is the case and would love to hear an explanation from /u/jfbastien.
I think ADL is pretty deep into language details compared to coroutines. But I’ll admit I’m diving deep into personal opinion!
Is `std::forward_list` a function now? :) Also, they shouldn't probably look like types either because they're not types.
Because that was what I wanted to do from the start. [https://github.com/DeanRoddey/CIDLib](https://github.com/DeanRoddey/CIDLib)
Shit yeah, good thinking.
What is template if? How does it work?
What is your paper number? That is after all the only way the committee takes any input.
Okay, let's say that `1 | 2` means multiple values to match against. That means you need some wonky syntax (like `^(1 | 2)`) to denote bitwise or. In either case you *need* to introduce less than pretty syntax, because "don't allow it at all" is out of the question. &gt; If you format it differently ... That's bikeshedding and not worth discussing.
&gt;Yeah, I think looking for a single `async` keyword In a known location no less.
They do? Types in C++ are always spelled in standard_case...
Suppressed that.
The thing about spaceship is that it allows you to write one or two functions &amp; then get a whole bunch for free. So, the advantage is in writing it more than in using it directly. But I assume using it directly could look something like: auto x{a &lt;=&gt; b}; if (x &lt; 0) std::cout &lt;&lt; “less than\n”; else if (x &gt; 0) std::cout &lt;&lt; “greater than\n”; else std::cout &lt;&lt; “equals\n”;
Metaprogramming is the best part of c++
Dude you obviously don't get at all how pattern matching works. There is no way to do 1|2 in a pattern and mean bitwise or. If you want to do that you *must* use a guard, there's just no way around that. And the guard is a regular expression (not a regex-regular expression) in which you can use | for bitwise or all day long. Not allow it at all was in regards to matching multiple patterns. Formatting it differently was just to show how absurd a bitwise or in that situation would be. And again because you really don't seem to get it: you don't fucking need to use |, we have unicode with a gazillion different characters or you could always use a newline etc.. The | is just an example of how it's done in other languages with no(!) ambiguity whatsoever.
As we've seen with Arthur O'Dwyer latest blog posts, depending on whether you're using a normal function or a coroutine you should have different expectations with regard to potentially dangling references. To me it's enough of a footgun to warrant a "warning" keyword on the declaration.
&gt;Unfortunately, the group was unable to review all papers that Library Evolution approved for C++20, which means they won't make it in. Which papers are these? I'm assuming the range constructors for std::string_view and std::span are part of it?
Proposal: deprecate `std::valarray` in C++23?
Do you have any source for this? I cannot find anything on the subject.
Wow, the C++ committee is really doing a great job. There are so many good features coming into the standard (std::format, constexpr features, better threading support, etc, etc). Thank you all for all of your hard work. &amp;#x200B; My main concern from reading the report though is that I hope web\_view doesn't make it in to further versions. web\_view is such a complicated feature (at this point browers are almost as complicated as OS's), that I'm not sure that it would be possible to standardize it in any good way. (Plus, web\_view can always be implemented in a library without too many issues.)
&gt; There is no way to do 1|2 in a pattern and mean bitwise or. No, I don't get how that is something that would break the laws of nature and therefore be impossible... in the context of designing a new feature. &gt; you don't fucking need to use |, we have unicode with a gazillion different characters or you could always use a newline etc.. You were the one who argued estetics first. Now you're saying there should be a fancy unicode symbol that 99% of keyboards can't even type. &gt; you really don't seem to get it And you obviously haven't read the proposal. I won't be continuing this discussion.
P1771, [[nodiscard]] for constructors makes me happy. It really bugs me that it doesn't apply and have made bugs that it would fix, such as forgetting to assign a lock_guard.
Maybe is a crazy idea to has something as complex as a mini browser in the STL but the reality is that it needed, everything today spins around internet so being able to use it is a must Things like auto updating the program, sending a voluntary report with the statistics and many more relay on the fact that you can send and receive a HTTP Request and if your progam wants to compete with other that where make on other languages you will needed The reason that it will only complicate the STL is one reason of why C++ it is where it is while other langs has huge and very complete librarys out of the box And as external library, well, no thanks, i prefer to deal with as few deps as i can, you know, having a 80s build system doesnt make it easy to add new things to the project. It is a functionality needed and should be in the core of the language
Intel doesn't provide a standard library, only the compiler, but its compiler does implement more aggressive implementations for `valarray`. GCC, in the age of C++98 when `valarray` was introduced, also was written to better optimize `valarray`. The creator and user to this day of `valarray` made sure of it. It's not that those patches were reverted, it's just that GCC got much better at optimizing `std::vector` and today they have pretty comparable performance.
Final word: &gt; CONSENSUS: Bring a revision of P1383R0 retargeted for a TS to LEWG(I) for further designn review.
maybe string\_view?
Intel C++ Compiler does not have a stdlib, but Intel Performance Primitives comes with its own `valarray` header: https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-using-intel-s-valarray-implementation
It wouldn't break the laws of nature but why would you make it different than all the other languages when you can do the same thing with a simple predicate in form of a guard expression? But oh well, I guess most C++ devs just have their heads so far up their ass that they never look at what other languages might have to offer anyway I'm sorry but if you don't know how to effectively use unicode that's your problem. No I haven't, I've looked at the syntax because I was interested in how they'd do it because I already expected them to fuck it up
For aync io, that rarely matters, as the coroutine state need be stored in other place anyway. For state machine or generator, it may have performance issue.
See, you've come to this thread with hostile intents and are now resorting to ad hominem attacks, while completely contradicting your own arguments. I see no point in continuing a civilized conversation.
std::tuple&lt;int, std::string, bool&gt; x = { ... }; Previous syntax: for ... ( auto&amp; tuple_elem : x ) std::cout&lt;&lt;tuple_elem; New syntax: template for ( auto&amp; tuple_elem : x ) std::cout&lt;&lt;tuple_elem; Expands to: { auto&amp; tuple_elem = std::get&lt;0&gt;(x); std::cout&lt;&lt;tuple_elem; } { auto&amp; tuple_elem = std::get&lt;1&gt;(x); std::cout&lt;&lt;tuple_elem; } { auto&amp; tuple_elem = std::get&lt;2&gt;(x); std::cout&lt;&lt;tuple_elem; } Expansion happens at compile time.
Microsoft with it Visual Studio has been dealing with the build system and packages manager since decades ago with no problems on this part, Code::Blocks also hides the build system the same way VS does I dont see the conflict, it has be done and i dont understand why nobody is doing anything about it because this two things are a pain to work with compared with other options like the config.json of Node what deals in one file with both problems and as transparent as you want, perfect out of the box if you dont plan to touch, it will work as expected And which is worse is because the STL is poor in options you will have to use an external library, a thing that only will bring pain and frustration, that´s of course if the lib is using the same build system that is not always the case That may be a necesary evil until now because Java, .net or Python werent match for C++ in terms of performance but not today, there are threats that are very real and many (including myself) will switch to one sooner than later, i dont has problems giving a 5% of performance to get 5 times the current coding speed
So, what will happen to `switch` after pattern matching is implemented?
&gt; HTML, CSS and JS/ECMAScript is becoming the "standard" of modern graphical user interfaces. It makes a lot of sense to use such standards instead of reinventing the wheel. ... nah i think i'll keep my declarative GUIs that don't execute arbitrary scripts in an exploitable JIT compiler inside of a resource-hungry browser frontend
Ok I see, thanks!
Can we make a breaking change that just rips all emoji support out?
Hi, I wrote it, and I have to agree with you. When I started preparing this talk I wrote everything I want to talk about. Ended with about 300 slides. So I had to cut down 60-70%. I kept what I thought is the most interesting, but was not smart enough to change the title... &amp;#x200B; Yossi
You are welcome! It's definitely a team effort though. At first it was just me and a few close colleagues, but now it's about 30-40 committee members. The document is traditionally drafted from scratch in a Google Drive document during plenary (which lasts about 2-3 hours). It's usually an incomplete trainwreck until about 5 minutes before the deadline.
Indeed. But unfortunately we'll have to wait for C++23 for formatted IO, so we might still need to `write &lt;&lt; " " &lt;&lt; things &lt;&lt; " " &lt;&lt; like &lt;&lt; " " &lt;&lt; this` for a little while yet :(
&gt; designn Just noticed this typo. Thanks!
It does not support Windows
https://old.reddit.com/r/cpp/comments/cdj5zx/c20_the_small_things_timur_doumler/
I'd rather have `std::web_view`, which is easy to standardize, allows you to do modern 2D display and UI, and can use existing efficient implementations that utilize modern graphics hardware, instead of [P0267](https://wg21.link/P0267), which is difficult and time consuming to standardize, isn't consistent with C++ standard library design principles, is based on an outdated approach to 2D graphics, can't draw text, and has no clear userbase.
I believe so. Marshall has a list somewhere.
There was discussion on this over multiple meetings. People didn't like that string_view looses the null terminator information which the system APIs you may pass this to would want. In order to avoid the overhead of creating a std::string just to get a null terminated string it was decided to just return a null terminated string.
it’s exactly what i was looking for, many thanks!
That's a great idea! Then you could do the OpenGL/Vulxan/DX graphics using C++ and still present it in the web\_view. This is a must for a web\_view to have a proper value as a all purpose GUI.
it’s exactly what i was looking for, thanks!
This lines up with my own feelings. The idea that "using libraries is inconvenient, so lets stuff absolutely everything directly into the language" rather than working on making a good _language_ and letting the libraries be libraries seems like the wrong way to go to me. Combining that antipattern with, "fuck it, everybody seems to be using a shitty bastardised document scripting language that grew by accident, so let's give up on doing UI using something actually designed for application UI" really feels like the wrong path, and I have been consistently surprised by how popular it seems to be with some folks. Let C++ be C++. Not everything has to be a web browser. Maybe most things _shouldn't_ be web browsers.
Even in the case of async I'm slightly worried to be honest. Specifically, I'm worried about stacking coroutines: when you form a chain of nested coroutines, do you end up with one allocation per coroutine? This would be terrible, imposing a large overhead to create it, wasting "padding" multiple times and being cache adverse.
&gt; -Wsign-conversion isn't included in -Wall in clang. This is "well-known" but you certainly can't blame someone for being confused when `-Wall` doesn't actually turn on all warnings. :-D &gt; Compiler also only warns about unsigned-&gt;signed because that's where an overflow Integer is one of the evil [**undefined behaviors**](https://en.cppreference.com/w/cpp/language/ub)! &gt; might happen - unsigned variables wrap instead of overflowing. But if a calculation wraps when you don't expect it, you might still get the wrong behavior, even though at least it isn't UB.
Any "web view" will be constrained to using the same web standards that will work inside a browser, hence no C++ in such a frontend unless you compile your C++ code to [WebAssembly](https://webassembly.org/) (which will actually run inside such a view). But to my knowledge WebAssembly can't (yet) manipulate the HTML DOM directly, so some JS would still be needed to manage the GUI components.
Playing Devil's Advocate with a counterargument to "it never looks native." ... At this point, so much stuff a user interacts with day to day is HTML either in-browser or "Electron" style native-ish HTML garbage that to many users the OS-specific window manager and few native applications that follow the platform HIG that they use may now seem like the oddball applications. It's one of the reasons I sometimes feel like we should just cancel computers, apologize, and all move to cabins in the woods without electricity.
Nothing. It's an efficient jump table and there's tons of code relying on it.
I totally respect this! It really comes down to what is most logical to do for the application you're making.
Fair, still don't see that much of an advantage. But I could live with that.
Stdlib implementations go through a heavy review process. So, they are very high quality. However, they are constrained by history and by the need for universality. They need to work for all thing for all people. That requirement comes with trade offs of complexity. Sometimes you need different trade offs. Like higher perf in unoptimized builds by dropping support for options you aren’t using anyway. People love Boost because it has just *so much stuff* just sitting there waiting for you to use. But, in doing so, it is also a gargantuan mountain of some of the most compiler-torturing code that is in common use. And, there really is not a quality guarantee. If you want to contribute a library, the project leads pretty much only want a long term commitment to maintain it. I’m not familiar with Armadillo. So, I cannot comment.
Thanks, the comparison table, reproduced below, is very helpful to get into the mind of the committee. Type-erased coroutines: - ✓​ Can be forward declared - ✓​ Can be called recursively - ✓​ Can be put on ABI boundary - ✓​ Does not require solution to `sizeof` challenge - ✓​ Definition can reside in the implementation file - ✓​ Can be virtual - ✗​ BUT!!! Requires heapallocation &amp; indirect calls Embedded coroutines: - ✗​ Cannot be forward declared - ✗​ Cannot be called recursively^1 - ✗​ Cannot be put on ABI boundary^2 - ✗​ Requires solution to a `sizeof` challenge - ✗​ Definition must reside in the header/ module interface file - ✗​ Cannot be virtual - ✓​ Does not require heap allocation ^1 *Symmetric Coroutine proposal allows self-recursion, but not mutual recursion at the moment.* ^2 *Otherwise extremely fragile, as any change to implementation immediately leaks through an interface.* It's interesting that 3 of the concerns are very specific to C++. Most languages do not worry about Forward Declarations, ABI Boundaries or Interface/Implementation differences. This leaves us with the comparable trade-offs: - Recursive calls: can be solved with explicit boxing of the recursive call. - `sizeof` challenge: only a challenge if one wishes to optimize the memory to start with; I do find the idea of optimizing the size of the coroutine by using a heap allocation (which allocates more than requested) rather... strange. - `virtual` challenge: unless the language has first-class support for dynamically sized return values, this may require a heap allocation. It's notable that outside the C++ world, one could probably get a better trade-off by: - Oversizing the saved state slightly. - Then requiring that it be dynamically allocated *only* when the user wishes to perform a recursive or polymorphic call; the former similar to the fact that a `struct` X cannot contain itself by value, the latter similar to the fact that a `virtual` function cannot return an instance of `Derived` by value. I am disappointed, once again, by C++ seemingly forgoing its ultimate premise: You Shall Not Pay For What You Do Not Use.
Whether a function is _a coroutine_. It isn't necessarily "async". It's perfectly feasible to write synchronous coroutines, which is why that choice of a keyword would've been ridiculous. I'm fine having a marker. I don't think we _need_ one; I think we'll need a way to plug in a custom traits type (to explicitly modify the promise type at definition time); but even if we required one, I'll forever be against making any context sensitive adjustments of the kind proposed in that paper, because they just make moving code around impossible without sophisticated tooling to tell you if you'll hit a problem.
std::format returns a string so you could just output that. write &lt;&lt; std::format(" {} {} {} ", things, like, this); // not sure about the exact syntax
Thank you for the thoughtful response and all of the hard work you do. My main comment here is that we seem to have gotten in an uncomfortable situation where it seems like we are being forced to include std::web\_view in order to kill P0267. I just wish we could evaluate the merits std::web\_view alone in isolation without considering the effects on/due to P0267. (I do understand that there are several proponents of std::web\_view out there with at least somewhat reasonable arguments. I think more discussion is needed to fully flesh out consensus.)
I don't think we'll need telling whether a function is a coroutine or not all that much. We'd need to scan for that keyword with this paper, and in practice, as long as you don't have weird reference parameters into your coroutines, I'd wager it'll almost never matter whether you're in a coroutine or not. The one time where it will matter is when you're taking locks or using TLS; you're not supposed to do that across suspension points. But even then, you just need local knowledge of suspension points, i.e. local places where you do `co_await`, and not per-function global knowledge of if you are in a coroutine or not. You'd need that same knowledge with `await`. You can all it grandstanding, but I'm pretty sure most people in this thread misidentified when you need to know if a thing is a coroutine or not. I'm also pretty sure that _that_ particular problem would just be aggrevated by the proposal to make the context sensitive keywords, among other problems (like weird meaning changes when trying to migrate code into and out of coroutines).
Whether a function is a coroutine or not has no bearing whatsoever on its interface. Only its parameters and its return type has any bearing on that. On the other hand, `constexpr` changes what the interface of a function is. There's a fundamental difference here.
it could impose some overhead, but typical async program cost is dominated by io, rather than allocation. You may try coroutine ts with asio. As connections increases, the allocation overhead should be a minor to none factor of performance.
#define await #define yield are our friends forever And for Herb's try expressions await or another #define is our friend again
Because everything about `std::valarray` is terrible.
/r/cpp_questions
&gt;Whether a function is a coroutine. It isn't necessarily "async". It's perfectly feasible to write synchronous coroutines, which is why that choice of a keyword would've been ridiculous. Come on, the actual name of the function marker is by far the least interesting part of the proposal, it could be called co_xwzissles for all it matters. This is just bikeshedding &gt;because they just make moving code around impossible without sophisticated tooling to tell you if you'll hit a problem This is already true! ADL, header macros, function overloads, etc. Copypasting code blindly is already a bad idea Worst case scenario? You have to scan all through a function body looking for specific keywords whenever you copypaste code. Which is exactly what you have to do in the current coroutine proposal, except currently you have to do it every time when trying to figure out if a function is a coroutine or not, instead of just a once off!
First of all, don't try to master a language. Any language. That said, there's a world of difference between C++98, C++11 and C++20. They are all major releases. C++03 was so small people sometimes completely ignore it. C++14 was basically a bugfix release of C++11 and C++17 was a medium sized release. Which you should learn? C++20 is still a year away until released, so some major features are missing in compilers. You would want to get as up-to-date as possible, but some major changes happened in C++11, so perhaps start with C++11 (what some call "modern C++").
Definitely c++11 or later. But keep your live simple and don't try to use all features at once. Read up on RAII and exceptions. The naming is not nice, but applying it consistently will prevent whole classes of bugs. Concentrate on dividing your problem in multiple easy to understand onces. Prefer composition over inheritance.
C++20.
Everyone thinks C++ is broken -- but always in completely opposite directions...
Hey, what about std::flat_(map|set) and std::any_invocable? I saw you wrote "and many more" proposals have been merged, is there a list that can I check?
What is HIG?
That's not exactly true, there's no implicit threads anywhere. But drop the part about threads and you're precisely on point.
I had not considered the case of I/O, actually. The codebase I work on is heavily future-based, to leverage all cores, and therefore using async for CPU computations. Naive memory allocations are often slower than transferring tasks to another thread (via work queues).
I think you intended to have a list at the start of your post, but it isn't formatting right.
I agree, but there is a strong demand from some on the committee for us to add modern UI to the standard library. We need to satisfy that demand in some way. I think `web_view` stands fine on its own. I'd actually use it.
I would today start with C++11 but not limit myself for learning. Try C++11/14/17 features. For personal projects use what ever is easiest for you. If your compiler only offers C++11 use that, if C++17 use those. They build on top of each other and not many (I think like 2-3) breaking changes where introduced, so your C++11 code will most likely also compile with C++17 activated. Compared to C++98 many things are a little easier to do. IMO it's easier to learn with C++11. Some things I like about C++11: - lamdas - ranged for - basic concurrency part of std - variadic templates - std::array - override keyword (I really like the error it gives me) - and some more C++20 is not yet finished, so maybe just have a little more patience,.but if your compiler supports a feature that you really want or need go for it, but I wouldn't recommend it for stating out.
In your case, a parallel task scheduling lib like tbb maybe fit better.
The best approach to get an answer to a paper that is still in the early stages of the standardization pipeline like this one is to email the author and ask them this question directly. Feedback on papers is always appreciated - and this observation will probably save Evolution time during a future meeting, so please do contact the author! Thanks :)
Isn’t that true of any asynchronous API?
This is correct. We had an extended discussion about "promoting" such allocations into runtime static storage in Kona, but we've found numerous problems regardless of which side of the stick we tried to approach it from. I'm rather certain that we will have a solution for C++23, though; there's an idea that has been floated around that seems workable. You should expect updates on the developments of that idea once the dust of doing NB comment resolution for C++20 has settled.
This is, I suppose, because it is fundamentally impossible to satisfy everyone. This is why I really agree with Brian Cantrill's point that one of the key aspects of choosing a programming language was ensuring that the *values* it seeks to embody align with the values you are looking. And this is why I am regularly surprised by the C++ committee; regularly proposals are accepted which clash with the advertised values of C++: You Shall Not Pay..., Zero-Cost Abstractions, Leave No Room For A Lower-Level Language. This is confusing, and makes me question what the true values of C++ are, and whether it really fits my usecases.
The three you mentioned didn't quite make it through the Library wording review on time. On http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/ in the last column you'll see "Adopted" next to some of the papers from the post-Kona mailing. Expect similar annotations once the post-Cologne mailing is out (probably in about 3 weeks).
Thanks for the notice. The formatting *was* right on the new layout, but not on the old one. Adding a blank line between the "head" and the first element did the trick. I wish Reddit would align the formatters between the various front-ends :/
In addition to what Vittorio explained in the other comment, `constexpr` instances of `std::string` won't be allowed to survive beyond compile time in C++20. We tried to make that work, but we couldn't; we think we have an idea how to solve this problem for C++23.
Oh, thank you, i just found it: "P1381, Reference capture of structured bindings, was approved for C++20" That sounds very good. My last sentence just meant that structured bindings are not very appealing if one can not use them in reference captures.
No worries, we have our own specific framework specifically crafted for our (performance) needs. I'm just on the lookout for ways to improve its interface, and the coroutines syntax could have been nice but... well, we'll do without.
I guess we need std::basic_zstring_view as a safer and more convenient wrapper for old null-terminated strings. C++ still lacks in interop with legacy API.
It's interesting... I'm in the exact opposite camp. I never understood why anyone would want to use anything other than a browser window for GUI for apps that require only browser supported stuff (meaning games excluded as WebGL is quite a bit behind non web versions etc.). I would like to see an option in C++ to get a web_view window without the need of creating a local web server and open up a browser (that's what I'm currently doing and it's not that bad with format/boost::asio/boost::beast/boost::dll/boost::spirit::x3 combination - leave js/html/css in templates that don't need recompiling and use C++ for database/filesystem/other resources access instead of torturing yourself with Apache or Tomcat like servers). Standardizing that and perhaps additional "hey support native_look_css_on_demand for OS where your C++ compiler is running" would for me cover most of my use cases. From my perspective the proposal is a leap in the right direction.
I've considered using it - what work does it need?
The first part was a direct reply to your comment. You said "whether a function is async". That's what it was a reply to. As for "this is already hard" - oh, sure. But discarding insane cases like non-capitalized macros, your code will end up doing what it was doing before. If you have an ADL-enabled call to a name, that name better mean the same thing whichever function it finds, otherwise your code was brittle even before. What I'm saying is, yes, you've got to be careful already. That doesn't mean that we should just throw our hands in the air, yell "it's already difficult!", and make it more difficult than that.
Ah. I exclusively use the old layout.
Still no networking library and executors?
Yes, exactly. All asynchronous APIs inherently have lifetime and issues.
Getting the nice pattern matching of Haskell is not possible without radically changing the syntax of the language. C++ inherited all the mistakes of C, and has a strong commitment to never break backwards compatibility. Both of these things helped make C++ successful in the '90s, but now the language is creaking under the weight of technical debt that can never be fixed. They are bolting more and more ugly syntax onto this bloated monstrosity. I say this as a person who really loved C++ in the '90s. I would never start a new project in C++ now...
Would you share the original slides? I’d be very interested :)
In your previous post, you said you didn't want to have to look at the function signature to know if a function were a coroutine or not, but now you're saying it will hardly ever matter... which effectively invalidates what you originally said.
It seems really bizarre to be dependant on another language is all.
I was a bit confused regarding that in the proposal and other comments. I would expect that standard would require that the API exists and "renders" stuff somewhere: implementations would then either act as a local web server and you would need to open a web browser window to see the result, would provide chromium based web view or a custom web view. That's not the case in the proposal at the moment but I'd expect it to evolve in that direction.
I'd have to write several papers, and other people already have.
Yes. It just makes me a bit sad that they didn't add something like template &lt;class... Args&gt; void print(string_view fmt_str, const Args&amp;... args) { format_to(ostream_iterator&lt;char&gt;(cout), fmt_str, args...); } so that everyone's first C++20 program becomes import &lt;format&gt; int main() { std::print("Hello world!"); } because that would have been fantastic.
Did [P0593](https://wg21.link/P0593) make it into C++20? Its github page suggests the CWG discussed it, but there doesn't seem to be any verdict.
&gt; I never understood why anyone would want to use anything other than a browser window for GUI for apps performance performance performance. Electron is so fat and slow, once you have a few electron apps going at once, you might as well say goodbye to one cpu core When doing performance testing, there is a visible difference in the numbers for me when discord is open, vs when it is not
We didn't have time for either. Sad for `any_invokable` - it missed C++14 and C++17 too.
That's not quite right. Constinit guarantees that the object is constant initialized (part of static initialization). Constexpr does not require that.
_If the keywords were context sensitive_, then I'd need to know whether I'm in a coroutine or not to know how to mentally parse `yield foo;`. As it stands, I don't need to track that. Sorry if I didn't phrase this clearly enough before!
The template keyword doesn't seem to fit there at all. Was there any polling? I understand ... is bad when argument packs are not supported but what about `for constexpr` which was suggested in some other paper?
Constexpr requires a constant-expression as initializer. Doesn't that imply constant initialization?
`std::print` is [actually present](https://fmt.dev/5.3.0/api.html#_CPPv2N3fmt5printERK1SDpRK4Args) in fmtlib, but they decided to leave it out of C++20.
Thanks for the information. Much appreciated.
Thanks for the information. Yes, I was looking forward to it. Still, better late than never.
I find the choice of `template` odd too. Maybe /u/blelbach knows more about it (or knows someone else who knows).
Proposal author here. The body of the statement is actually a local template, so template makes a lot more sense than constexpr. Also, nothing in the statement is required to be constexpr. Unfortunately this just missed being in C++20. There wasn't enough time to finish reviewing the language wording. Priority was on bigger ticket items.
As a random commenter with 10 years of professional c++ usage: I think adding either of std::web_view or the 2d graphics proposal to c++ would be an abomination. Please do not include either. I can expand on this if you really want me to, but the majority of my negative thoughts about both are covered by the negative commentary you can see in this reddit post and previous ones.
`web_view` doesn't use a web server. It just uses your browser's embedding API.
&gt; yield foo; I'm curious what other possibility there is for this.
We already are. Regular expressions in the standard library aren't defined in detail: instead we just cite the ECMAscript standard.
It could be a declaration if there's a type called `yield`. (Same for the statement "form" of `await`.)
\&gt;:
If we were in a situation where we were using the `async` keyword, `yield` would presumably also be a reserved keyword and thus not be eligible for being a typename (same as `await`). Otherwise, nothing stops one from making types called `co_yield` and `co_await`.
Human interface guidelines.
&gt; using enum For a moment I thought it was something to allow enums to inherit from each other. Sigh. P.S. I wonder whether the usage of "using enum" in another enum was ever considered?
But it wouldn't, because it can't; see option (a) somewhere up the thread. I'm serious when I'm saying that we have considered the many possibilities, many times ;)
Yes, that's why I'm sad it won't be in C++20
There's [this](https://ultralig.ht/).
Man-Machine Interface. Sort of a more comprehensive term for "Graphical User Interface", as it includes the entire spectrum of possible interactions, rather than just assuming it must be graphical.
&gt; &gt; Class::Member() volatile; &gt; Stated reason in R0: It was introduced to be consistent with const, but doesn't really make sense. Does this mean that you can't overload a member function by whether or not the object you're calling it on is volatile anymore like you can with const? Because that always seemed... somewhat useless to me, I was curious if it ever had any useful semantics
That is insanely useful!
I (the author of the \`std::format\` proposal) deliberately made the decision not to include anything I/O related to make the proposal as uncontroversial as possible. Even without this, the proposal barely made it to C++20 on time.
I had serious problems using boost from vcpkg even before 1.70 released. It's not just a bad release.
&gt;`sizeof` challenge: only a challenge if one wishes to optimize the memory to start with; I do find the idea of optimizing the size of the coroutine by using a heap allocation (which allocates more than requested) rather... strange. `sizeof` challenge is not about optimization. It is fundamental and what finally pushed scale in favor of heap allocated coroutine. It is not certain that you can actually compute a conservative size of the coroutine frame. See the table on page 5 of [P1492 - Coroutines: Language and Implementation Impact](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1492r0.pdf). The paper says (on page 9): &gt; A likely limitation is that such approach may highly overestimate the required size. It is possible to construct examples for the coroutine state to be 10,000x higher than it should be, though we expect that in ordinary programming the overestimation will be on the order of 3-10x.
You got the idea right. Overloading based on `volatile` qualifier was deprecated. I can't say I've ever had a need for `volatile` function parameters, but there is a semantic meaning *from inside* the function - it makes the use of the parameter volatile. It, however, has no effects on the call site. Full description of this from R0: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1152r0.html#parret
And thank you for your hard work! I've used fmtlib for a long time and I think `std::format` will be one of the most useful additions to C++20. I certainly didn't mean to suggest otherwise -- I'm just a little disappointed we couldn't have everything in one go :).
Thank you for the paper! It'll take me time to digest it, as it covers a lot of ground, however from a cursory reading it already looks very interesting.
Ah sorry, what I meant was that struct hello_there { void some_func(){printf("Not const"\n);} void some_func() const {printf("const\n");} } overloads depending on whether or not the object itself is const, as far as I'm aware you could do that for volatile as well which that change now disallows (if I read it correctly!)
[I have argued strenuously for us to do neither](https://wg21.link/P1062) But some on the committee feel otherwise.
Paging /u/griwes.
It was not moved at Cologne. Perhaps it was voted in earlier? If not, then it did not make it.
Neither of these have been targeted for C++20, as of 6-9 months ago.
"Human Interface Guidelines", if I'm not mistaken. Every (?) platform has a set of rules that specify what a dialog should look like, what a menu bar should look like, etc. Part of that is simply implemented in the UI layer, part is what you tell the UI layer to do as a software dev. I think GP basically means the look and feel.
I wasn't in the room when it was discussed this time, but \`template\` feels correct to me. &amp;#x200B; Think about this way: \`template for\` essentially means "treat the body of this function as-if the iteration variable was its template parameter, and then instantiate it for all elements of the range". You don't instantiate any functions or classes (unless needed by the block), but a block, so it's much faster than it'd be otherwise (for instance when using one of the many lambda tricks), but you're still essentially following the exact same mental model for how it works.
Well, I understand you sentiment, but from my personal expectation, C++20 has Concepts and Modules which make it a big enough release. And C++23 will likely have Networking settled and deserve to be named big again for being the first C++ release having a standardized networking library in the language that most network stacks in the world are written in.
Deprecation of volatile? What do they mean by that? Volatile is useful for many things
That's also deprecated, right.
What I find strange is that on the one hand, we have people arguing that you are automatically disqualified from the performance club if you use exceptions, virtual dispatch, or memory allocation of any kind. And on the other hand it is apparently perfectly fine to serialize your MMI into HTML, stream that to another process, deserialize it into a DOM, and render that to the screen at 60Hz. 32 bytes for an exception is considered too much, but apparently 400MB for a web browser is fine. HTML wasn't designed for MMIs, and you couldn't do a worse job if you tried. It has no mechanism for building your own controls, or for doing selective updates to the screen, or for sending events to the C++ other than having javascript post chunks of text. It boggles the mind that anyone would think it makes for a suitable environment for a high-performance language. There's also the question of how this fits into the goal of making C++ easier to teach. "So to display hello world on the screen we just write a few dozen lines of HTML, some CSS, and then a bunch of javascript because we want to know if someone is trying to close the window." Is that *really* easier than just teaching people how to use Qt? Speaking of Qt, why not just standardize (selected parts of) that? It may not be perfect, but it is not nearly as imperfect as what's been proposed so far, and at least it's a battle-tested solution.
Where does this demand originate from? It kind of sounds politically motivated more than anything...
Are you sure it wasn't moved at Cologne? Because [the github page](https://github.com/cplusplus/papers/issues/106) shows updates from the previous three days, two of which seemed to have been spent in CWG.
Okay, I guess it makes sense and my "it's odd" feeling is caused by `template` not being followed by `&lt;typename`.
I wasn’t in those discussions but I’m all for it. It potentially will allow us to quickly bring up modern forms of I/O within the standard framework. We can then look at more direct ways to achieve that over time.
I’m guessing Human Interface Guidelines.
Is the variadic pack issue solvable (potentially for C++23)? Or is there no hope on that?
You may want to read the paper.
I believe the feeling is that it is needed to help make C++ more accessible, on-ramp new programmers, and encourage educators to use C++.
Oops. Good catch.
There's other places where it isn't, like the template disambiguator (admittedly a rarely needed feature) and explicit instantiation declarations and explicit function specializations.
The template disambiguator did cross my mind, but all three of those are features I've seen used, but never used them myself.
I wish it was more like https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated
That (fortunately) didn’t pass. Renaming co_yield to yield is a bit awkward wrt. long-reach context sensitivity, but it could be done. However, renaming co_return (which is sugar for calling a potentially overloaded function) to return would be deeply misleading (e.g., different conversion/move semantics, different target type, etc.). Doing one without the other doesn’t feel like progress to me. (co_await -&gt; await is less problematic.)
C++ doesn't need a graphics library, at least for now. What it really lacks is an **effective* package management.
What C++ needs is the same it provides everywhere: primitives. Building blocks. Not ready-made solutions that are very specific to a handful of use cases and completely unacceptable everywhere else. For MMI, that would be things like std::window, std::button, std::checkbox, std::menu, etc. Plus std::canvas (for writing your own controls), and a mechanism for sending events to the C++ application. We have ways to manipulate files, not a complete database engine. We are getting ways to send data on a socket, not a complete webserver. That's the approach we also need for graphical work: building blocks.
Don’t forget constant destruction.
If you have P1240 reflection and this feature together, you get the pack-processing capability in a slightly different guise.
Correction: You can return those types from constexpr (and consteval) functions, however the calls to that function will have to be proper subexpressions of a constant expression.
`std::byteswap` didn't make it in because it didn't get reviewed. So it's been pushed back to C++23, but it'll probably be added at the first C++23 meeting (which IIRC will be in Prague in February)
What a name xD. Thank you!
I like the way you explained the topic. Nice post!
http://interface.free.fr/Archives/Apple_HIGuidelines.pdf Back in the day, when our parents were walking uphill both ways to get to school, major platforms all had very serious documentation of how to write a _proper_ Application UI for the platform called the Human Interface Guidelines. Dialog boxes should all have the default button on the left vs. the right. The clipboard actions should be called "copy" and "paste" rather than "duplicate" and "insert from clipboard" and they should be in a menu called "Edit." All that kind of stuff that makes an Application feel _right_ . And developers were expected to read through it before they started designing the application. In contrast to something like the Slack app that uses Electron and populates the OS-X menu bar with a few pro-forma menu entries like a vestigial fossil of the good old days, and does most of the actual functional menus in the web browser window with HTML. Slack is more concerned with being consistent _across_ the platforms, rather than being consistent _with_ the platforms. It doesn't really care how OS-X or Windows UI conventions work, because it just wants the Desktop app to work like the Slack web page.
It’s fairly easy to track the allocations. My implementation (i.e., the constexpr interpreter within the EDG front end) simply tracks every interpreted dynamic allocation and associates some metadata with it. If at the end of the evaluation any of those allocations remain, we fail constant-evaluation and, if appropriate, issue an error. The metadata actually identify where in the evaluation the allocation was done. So I issue a not saying something “some allocations we’re not freed; the first offending allocation occurred at line xxx (quote line and indicate position)”. It’s pretty neat, actually.
Numerous problems?? I was aware of only one (but it’s a nasty one). (The one problem is the fact that embedded objects might need to be destroyed but that is unsafe if the allocated storage is mutable.)
&gt; In the Evolution subgroup, I presented P0709 for the first time and received broad encouragement for most of the proposal along with a list of questions to which I’ll come back with answers in Belfast. I am very interested to know the opinion of the committee on the OOM part.
It works really well, no big work needed. But you should probably use the develop branch - the master hasn't been updated since 2017. There is a tiny bit of activity going on in the develop branch - mainly "maintenance" fixes like compiler and msvc compatibility updates, support for C++17 optional, and a few things. The main thing (but certainly no showstopper) is the many open issues ( [https://github.com/USCiLab/cereal/issues](https://github.com/USCiLab/cereal/issues) ) and milestones for 1.2.3 and 1.3.0 releases ( [https://github.com/USCiLab/cereal/milestones](https://github.com/USCiLab/cereal/milestones) ) that basically have stalled for the last two years. However there seems to be good news, the main author said in May he's working a bit on cereal again: [https://github.com/USCiLab/cereal/issues/563](https://github.com/USCiLab/cereal/issues/563) It would be really awesome if the project would gain more traction though! I think there's many people using it but hardly anyone really contributing (aside from opening issues).
That couldn't be done at a library level Also i personally dislike (and don't see a need for) having real code hidden inside a string literal
I think it might make sense to amend the comment to say "strong support to continue investigating this direction", rather than "strong support for the paper as-is" which I find to be a plausible interpretation of the comment. Also one particular aspect which i don't believe was mentioned in discussions, is that i'm slightly scared on how will the window management work for a web_view. Developers will inevitably want to resize / position the web_view (either in a new window, or embed it into an existing one), and the current paper does not seem to address that.
Yeah, it's weird that this doesn't work in MSVC, but as a workaround you can assign the length of "hello" to a local constexpr variable and then return that. https://godbolt.org/z/CF7pQH
Just to be precise, with the interface currently specified in the paper, it is also possible to communicate from the web side to the cpp side via custom uri scheme handlers, and then from the cpp side to the web side, by injecting and running javascript. But i agree it's not as tightly integrated as c++ &lt;-&gt; qml.
It's less error prone and easier to read.
I mean, you and I had a rather extended back-and-forth about this, and I count every bit of that rabbit hole as a different problem. Promoting the storage itself, dealing with mutable vs immutable, dealing with "is this from now on or just in general", dealing with indirect wrappers that don't propagate constness like \`unique\_ptr\`... I think I missed something, but can't quite remember what it was. We should probably also count Mathias' observation that currently it's always valid to \`const\_cast\` a const pointer obtained from a \`std::vector\`, but it'd change with the approach as you originally proposed, as one of those problems.
Just had a look over that paper and their motivating example is writing html + javascript inside string literals into a stream. Now i'm sure whoever proposed this has good reasons for it and im no expert on any of that but to me that looks absolutely awful. Why not provide a way to actually create html using real c++ code? If its "not standardy enough", maybe a 'web_view' isn't something that should be standardized.
Boost hana docs are amazing, I frequently consult it for reference for understanding category theory concepts / how I’d implement them in c++. If I’m not mistaken Hana was his thesis?
This would indeed be useful but my guess is the semantics are tricky.
It was one of the two papers that CWG ran out of time for (the other one was Expansion Statements).
Can we hope for compilers to optimize pattern matching equally good as a switch statement when possible?
Someone ought to write a proposal about banning misleading titles.
Hey, that’s unfair counting ;-) If the mutability of the allocated storage is nailed down, all the other issues go away. (The other items are just consequences of it not being nailed down statically.)
That does sound neat. I am still not sure how non-transient, since you allocate ar compile time, but the deallocation waits until run time. *Some* non-transient allocations are allowed, per [P0784](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r6.html). Though, to be fair, I'm still not 100% clear which.
this would only piss people off. if you don't like it don't use it
That ECMAScript citation is the bane of my existence.
so to make c++ more accessible we have to add everything that could just be a library because we can't standardize package management? Also accessible for whom? I don't think many beginner programmers would be able to use web_view in its current form (ie. what i got from the paper) for anything remotely useful/complex
Thanks for the reply. Does that mean it will be discussed at one of the following C++20 meetings, since it reached CWG, or is it too late for C++20?
adding a library is easy if you dont make it overcomplicated and a new std header is still 'a dependency'
can you do size of(Ts...) ? on mobile so no compiler
It seems feasible to me given criteria on the case conditions. Whether or not this will happen is something I'll have to see later.
No, unfortunately non-transient allocations were dropped in Kona. The way I had planned to implement those was to (a) evaluate the initialization, and if that succeeds (b) evaluate the destruction at compile time right after that. If (b) succeeds and allocations have been cleaned up, then the allocation can be promoted and the run-time invocation of the destructor should just be removed. However, that reasoning counts on the fact that the storage accessed by the destructor is immutable, which is true for the constexpr object itself, but not necessarily for the allocated storage it points to. For example, if you define a constexpr vector&lt;string&gt;, we find ourselves unable to destroy the embedded strings and you get an error. As /u/griwes mentions, we’ll probably find a solution soon. (We actually had a working solution, but EWG didn’t like it.)
I agree completely.
Almost certainly too late. P0593 is a bit special in that much of it could actually be handled as a DR (defect report). That could even retroactively apply all the way back to C++98. Effectively, implementations can already do that now. The part that specifies APIs though is off-limits until C++23 at the earliest. (Cologne was the last meeting for voting features into the C++20 WP.)
Thanks for the explanation. I remember non-transient allocations being dropped in Kona, but P0784 still talks about them, which made me think they got into C++20 after all. I honestly never thought I'd see allocations in constexpr context. Great work!
Sadly, although EWG was happy with either option P1607 presented, external forces were not able to agree to go with either of those options for C++20. Hopefully SG21 gets off to a good start and gets us a useful feature landed in C++23.
replace all other emojis by beer. problem solved
Alright, thanks for clearing that up. It's not really a big deal, but it would be nice if `malloc` were able to create objects.
No, you're not dreaming. That should absolutely be possible to do.
LEWG liked it - though it was considered mandatory that there is an escape hatch for those that need a throw-on-OOM. From what I can tell, EWG didn't like the OOM stuff...
Thank you so much!
Here is LEWG: [https://github.com/cplusplus/papers/issues/310](https://github.com/cplusplus/papers/issues/310) Not sure if the EWG polls are already publicly available...
So a conforming implementation will need to ship something like Chrome? hmmm
No
String interpolation is much harder in "systems" languages where you don't have garbage collection and where you generally care much more about controlling allocations. Rust doesn't do it either, FWIW. Nonetheless, Vittorio Romeo (/u/SuperV1234) has a paper proposing interpolated string literals in C++ which was [discussed here a few days ago](https://www.reddit.com/r/cpp/comments/cc2j0w/rfc_early_draft_of_interpolated_literals_proposal/), so it's not completely impossible that we'll see something like this in future.
&gt; In short, contracts were just not ready. It's better for us to ship contracts in a form that better addresses the use cases of interest in a future standard instead of shipping something we are uncertain about in C++20. Notably, this decision was unanimous -- all of contracts’ co-authors agreed to this approach. 3 year delay for something that could probably be shipped in 6 months &gt; What happened to my favorite library feature not listed? &gt; Unfortunately, the group was unable to review all papers that Library Evolution approved for C++20, which means they won't make it in. The group couldn't review them this week so check again in 3 years &gt; NOTE: This is a plan not a promise. Treat it as speculative and tentative. Some of the things in this table of been in "next release or the one after" since before C++17. &amp;nbsp; In the time it takes for the C++ committee to hold another meeting other languages have released new versions. If it's taking a decade to take an existing networking library and ship it in the std library then something is wrong with the process.
Any chance that I can pass static_assert a constexpr string in the near future?
As a random commenter with 9 years of professional C++ usage - I can only agree. Why comittee wants to even spend precious time on something that should clearly be a standalone library? Seeing that Networking TS is scheduled for 23 and took a lot of effort to get there, and is far less complex in comparision (not saying it isn't complex!) is making me nervous. I feel there is still lot of ground level work to do for our beloved language and timing is important.
Other languages don't specify a standard, they write a patch for the reference compiler. There's a world of difference there. Committee may be slow to adopt certain features, but let's not disregard the amount of features that landed in C++20. &amp;nbsp; Is it good to have a language that is so unstable and changes so fast? I have serious doubt about any such language's backwards compatibility which is a great strength of C++ and C.
I'm not sure what you mean by "politically motivated", but the [Direction Group](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0939r3.pdf) have indicated they're in favour of some sort of basic graphics support in the standard, and Herb Sutter's name is on the current graphics proposal.
I'm confused. You told me here on /r/cpp a few weeks ago that the committee takes input from the community in a variety of places. Is the only way to engage with the committee via formal proposals, or not?
Yes. I read the article and it was very much different from deprecating the volatile keyword (which would've been a silly proposal).
EWG will be more conservative, based on what Herb said previously.
Nice post, but why do you use forward_as_tuple instead of std::tie?
&gt; Other languages don't specify a standard, they write a patch for the reference compiler. There's a world of difference there. Ironically another ISO standardized language with no reference compiler is probably one that would be considered to move far too fast around here, ECMAScript. They release yearly and the language proposal process/status is hosted on GitHub. &gt; Is it good to have a language that is so unstable and changes so fast? I have serious doubt about any such language's backwards compatibility which is a great strength of C++ and C. That you release more than 1 version every 3 years does not mean your language is changes fast, it means you release features as they are completed rather than waiting forever. That you take 10 years to add networking to a language does not make your language more stable, especially if the majority of the years was failures in process to be speedy instead of technical churn. It's not like networking is a new fad that needs to be carefully watched.
I didn't know ECMAScript was ISO. Interesting. Though they don't have a standard library, so they don't have to spend time on that part of the language. You were talking about 2 releases per year - that is definitely too fast. As for Networking, the reason it wasn't merged is because it *should* depend on Executors and they are still being worked on, not bikeshedded. I'm also not convinced high level libraries should be standardized instead of focusing on a package manager and allowing everyone to just pull in any library they need. But that's just me.
&gt; You were talking about 2 releases per year - that is definitely too fast. How is 2 features per 6 months any faster than 12 features per 36? Average latency and throughput is independent of jitter. &gt; As for Networking, the reason it wasn't merged is because it should depend on Executors and they are still being worked on, not bikeshedded. There are plenty of given reasons why networking has been delayed but I don't see how any of them make it less embarrassing that it won't be until 2023 or 2026 it gets added (barring any more infighting on what is needed for it to be accepted). &gt; I'm also not convinced high level libraries should be standardized instead of focusing on a package manager and allowing everyone to just pull in any library they need. But that's just me. That's a fair position given the current structure but wouldn't it be better if the language spec and the standard library didn't have to compete with each other for a times in a meeting every 6 months?
I presented a new draft ([D1819R0](https://vittorioromeo.info/Misc/D1819R0.html)) in EWGI and they want to see it again. The main concern is that the complexity might not be worth the benefits, and there will be plenty of committee time spent on this if moved forward. The laziness of the expressions is another major concern.
&gt; How is 2 features per 6 months any faster than 12 features per 36? Average latency and throughput is independent of jitter. Because you're not accounting for overhead of going through "bugfix" phase of National Body's ballot. Right now they meet up 3 times a year, with one year left for "bug fixes". In the absolute perfect scenario, you can cut that down to 2 last meetings. There isn't much room left for WG21 "internal" meetings if you plan releases every 6 months. &gt; There are plenty of given reasons why networking has been delayed but I don't see how any of them make it less embarrassing that it won't be until 2023 or 2026 it gets added (barring any more infighting on what is needed for it to be accepted). There's Boost.ASIO and standalone ASIO, give that and a path to significantly improve the implementation `std::network` with executors, I don't find it embarrassing. &gt; That's a fair position given the current structure but wouldn't it be better if the language spec and the standard library didn't have to compete with each other for a times in a meeting every 6 months? Unfortunately that's impossible when all of the headliner features, in case of C++20, require both library and core language changes. Again, I do acknowledge that C++ can be slow to adopt some things. I personally couldn't care less about networking, but would have loved the status quo of Contracts.
Http requests has nothing to do with a graphic display solution based on a web browser
I think that a lot of the motivation behind std::web_view and the 2D graphics proposal is for teaching purposes. A goal that I think will harm the C++ language and standard library. While I don't think that we should make the language *harder* to teach, I strongly believe that any proposal motivated by "Make subject X easier to each" will directly harm whatever X happens to be.
Yup, C++ really clicked for me when I finally understood what RAII is about.
Both of these arguments (the ones about networking) are only true of the current monolithic 3 year model where everyone has to fly out to approve a constexpr change. It's not inconceivable to have a model where there are less process restrictions than technical restrictions.
Hi! I recently implement similar serialisation like this, before I came to a different realisation Serialisation, at least in my code, is a pretty isolated, self contained thing. I do data = serialise(type), and that's about it - its done through much higher level wrappers. The reality is, none of the rest of your code needs to know about members(), and the even more depressing piece of reality is that templates are extremely slow to instantiate once you go recursive With this kind of approach you'll inevitably end up with a bunch of templates being instantiated everywhere, and unavoidably slow compile times, and the code that's used to implement your serialisation (macros etc) inevitably leaks everywhere A better approach is to implement serialisation as free functions, such that you declare void serialise(const your_datatype&amp; in, context&amp; whatever); in a header file, with an implementation that looks like: void serialise(const your_datatype&amp; in, context&amp; whatever) { DO_SERIALISE(in.val1); DO_SERIALISE(in.val2); } This has a massive advantage - you can totally decouple your serialisation code from your implementation, types that contain other types which are templates (eg class hello{some_template&lt;int&gt; hi;}) don't need to have the serialisation definition of some_template&lt;int&gt; available in a header if you don't need to directly serialise the template itself (aka no exposing or instantiating unnecessary templates anywhere), and generally you can massively compartmentalise all the horrible heavy template instantiation in one file Disadvantages: You have to maintain a separate file which touches on all the members you need to poke, and its not next to your class. You'll definitely forget to update variables - in my tests, the tradeoff of compile time and compartmentalisation is completely worth it - now every serialisable class inherits from a tag type and that's it - all the actual logic is totally hidden off somewhere else
That's a valid point, but some committee members (I think it was Bryce Lelbach, you can find him around here) said there is a big difference when you're able to see eye to eye whomever you have something to discuss with and being there, instead of home means you can focus on the committee work, instead of getting distracted by your regular job. I don't see a point arguing against "committee likes meeting eye to eye, because they feel they are more productive that way". Also SG14 (low-latency study group) has regular teleconferences. Other groups occasionally gather outside of WG21 schedule.
There was polling for 3 different syntaxes - why \`template for\` is preferable to \`for template\` (whch would nicely mirror \`if constexpr\`) still eludes me...
Was looking forward to contracts :(
&gt;3 year delay for something that could probably be shipped in 6 months Considering the latest outfall I very much doubt contracts can be done in 6 months...
It's true only for library creators.
I really appreciate these reddit reports, and its entirely possible that this exists but I don't know where it is, but are there official secretary-style meeting notes (somewhat like Person x said a, b, c) or a complete list of votes for accepting papers and results? Or am I completely misunderstanding how meetings are run? &amp;#x200B; It would be great to be able to look into smaller changes I was interested apart from being potentially grouped into 💥 And many more! 💥
Incorrect. Metaprogramming can be useful in creating any performant program where there are multiple different types you want to analyse at compile time (rather than runtime with virtual functions or similar) and generate efficient code with fewer redirects/dereferences/runtime-abstraction/etc via inlining. CRTP is one example, you can find plenty of others. It can also be used to create more expressive code (e.g. embedded Domain Specific Languages) or anything where you want to combine types or functions at compile-time without relying on stuff like vtables to dynamically look up type-specific information. Any sufficiently large program has many sections that effectively function like library code anyway, so even if your statement was true, that would still be a very strong reason to include metaprogramming, not exclude it. Also you can make compile-time maze solvers.
I've had a proposal along these lines churning in my head. Inheritance is the wrong model. I prefer to call it "enum composition" instead. So you could write something like: enum class Primary { Red, Yellow, Blue }; enum class Secondary { Orange, Green, Purple }; enum class Color { using Primary; using Secondary = 10; }; This would do exactly what you would expect. In addition, it creates an implicit conversion constructor so you can do: Color c = Secondary::Green; As well as an explicit conversion operator to go the other way: auto s = static_cast&lt;Secondary&gt;(c); These would apply the appropriate offset to convert. I haven't thought through this fully, but it feels like something that could work. I have wondered if a library shouldn't would be better. You can *almost* do this with `std::variant`, except it wouldn't create `Color::Red` and switch statements are significantly worse. I thought maybe pattern matching might solve the later problem, but who knows if that will happen.
Deprecating (some uses of) volatile.
Personal opinion, it has to be 24. Otherwise the following would have very surprising results: void clear(X&amp; x) { std::memset(&amp;x, 0, sizeof(x)); } Y y = { {1, 2}, 3 }; clear(y.x); std::cout &lt;&lt; y.c &lt;&lt; '\n';
There was a proposal to make some changes to the design of coroutines, in particular splitting the coroutine_handle into two types: suspend_point_handle and continuation handle. See P1745R0 and the accompanying P1662R0 and P1663R0. These changes would have _allowed_ adding async rvo in future in an incremental fashion by providing a mechanism that allows a coroutine to resume on one of several resumption paths (ie value or exception) and also adding a mechanism that allows different kinds of co_await expressions to use different handle types (a different handle type is required for each result type with async rvo). It was deemed too late to adopt these changes for C++20. I do not know of a path to incrementally add async rvo to the current design so we would likely need to add a coroutines v2 if we want to add support for this capability in future. It is unclear whether adding a v2 coroutines would be palatable to the c++ standards committee.
Does it mean that we will not see template if in C++20?
Sure, i am using CMake and want to use FFMPEG, how is the easy way? I am telling because FFMPEG even if it is the CODEC lib for C doesnt use CMake so you has to create your own version of it and i am tired of that, i am all ears to know how And a header it is a dependecy but it works, you put the include and done, thats why i prefer to be included in the core that importing my self, it will save hours of work
I know but once you has the DOM parser, the CSS engine in place and the JS one and all of that it will make sense to have the option to send requests and being able to use as an internal browser (the intended use to load the UI) or an external
I read the article and if I'm getting this right (please correct me if I'm wrong): "they're using templates to replace some of the functions served by the volatile keyword"
Interesting question. I don't have a specific reason. They're pretty much interchangeable in here and lead to the same results. The only difference I see, `std::tie` always gives you a tuple of lvalue references. Similarly works `std::forward_as_tuple`, but it can form a tuple of rvalue references if you deal with rvalue expression. Though, I can't imagine a practical use-case to justify it. Seems, using `std::tie` would simplify the code. Thanks for catching that!
What **is** it then? And what serious problems did you have? Did you raise an issue?
If we had package management standardized and widely adopted maybe this would be a decent argument. It does work decently for python with pip, but they still have an absurdly large and at time absurdly niche standard library.
You are confused. The committee only takes input from papers. Committee *members* take input in a number of ways. Which committee members did you give your feedback to?
Let me rephrase then -- which paper numbers reflect your input? Or including the other reply I made: which committee members agreed to represent your feedback? You've said your feedback was ignored, so I now have to track down where your feedback was lost.
There is no "template if". There are expansion statements, which are spelled "template for". Almost certainly not in 20. But it doesn't really matter that much. Compilers often release with features way in advance of the published standard. I'd expect some compilers to ship this initial implementations with their C++20 support.
Yep, EWG and LEWG have somewhat divergence of opinion. LEWG likes the idea of non-throwing allocators, everything conditionally noexcept on the allocator, making the default allocators non-throwing. EWG has concerns about the last point.
Can you be more specific which things you consider clashing? If Coroutines don't fit your need, it costs you nothing to not use them...
Unfortunately there is really little the committee can do in this area.
Yep, they didn't make it in. Nor did ranges::to. Terribly sorry about that. ranges::to now targets early C++23.
Jesus... Do you know what? I has been using C++ for long as 10 years now and attitudes like you are the cancer of the comunity, so you want it to be hard and complex so no one can use it and make you proud that you can? Fine, and when all the "experts" retires who will use it? And while that can be true a decade ago with things like go, Node or Rust among others pushing so strong it is the wrong call, it is a suicide move
I'm not an expert by any means but \`template for\` reads a little nicer to me. You get something that sounds roughly like templated for which is a pretty complete description of what it is.
Eh, not really. I recommend ready [the first version](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1152r0.html) of the paper, which has more extensive background.
To anyone that studies computer science, in my university when i studied they were teaching Java, now they are teaching Python, you cant expect that a python programmer will be willing to deal with all the pain and time added from C++ without a very good reason and because there is not many most will pass. Rust nowdays is even faster than C++ in some cases so it biggest strong point is not so strong now They teached us C because in my country i choosed a mix of computer science and electric engineer (it is not a very popular choice) so to code for the microcontroller and it was only C and of course the IDE of the vendor hides pretty much everything about build system or package managing using tools to add the OS to the chip among others So i learned C++ on my own and it was because i thougth it was i needed to learn, i dont has that point as clear as i had, back in time 10 years it was a clear choice, not anymore. Without people learning the language is dead, if you cant hire developers and as time pass are less in the market is a structural problem meaning that managers will switch to another option leaving C++ code as legacy
Could you make one thing clear? When you say "default allocator", does that only include `std::allocator`? What about `std::pmr::allocator` in combination with `std::pmr::new_delete_resource()`?
Indeed!
i agree package management is what should be worked on, especially if c++ wants to stay relevant with all the new technologies coming out constantly. web_view doesnt bring us any closer to that at all tho. it would just go unused and die because of how slow/inflexible updating anything in the std-lib is (keeping up is especially important for anything web-related; stnadarizing something thatll be outdated in a few years isn't what the stdlib was/should ever be about) sadly a standardized package manager, as much as it would help basically every c++ programmer, isn't something that i foresee happening :(
Thanks! Yeah, all the work on P0784 was in adjusting the wording. The preface material was only slightly tweaked.
You basically never want to use the operator itself. For regular comparison you use &lt; etc as before, but it'll magically forward to &lt;=&gt;. If you want a three way comparison you call std::compare_3way, which works on types that don't have &lt;=&gt;. You should only use &lt;=&gt; to write comparisons for your class.
By definition you cannot know the behavior of a type erased type at compile time which exclude pmr. Default allocator referred to both std:: allocator and new expressions
See the issues and projects here: https://github.com/cplusplus/papers
There are a few other items that are not permitted In constant expressions. “Go to” comes mind (I expect that by C++50 that limitation will be lifted ;-). “Asm” also, though now it can at least appear in constexpr function definitions (just not executed as part of a constant evaluation); the latter is useful in combination with std::is_constant_evaluated().
Those are both planned for C++23. The latter is on my plate (I have an implementation of it; it’s kind of fun). However, it leads to side effects from constant evaluation, which is a tricky topic (think: interactions with SFINAE).
I dont think string literals executing code would be less error prone than the normal code everyone is used to, its just (a lot) of added complexity on a language thats already very complex and should have a good reason for every new 'feature' it's definetely not easier to read if your ide/vax... doesnt know it (it's a core language change), so syntax highlighing / goto definition of a symbol inside a string literal, renaming an identifier, static analyzers have to inspect string literals etc... As much as it looks cool, having working tools to work with code is more important imo
Sorry, meant template for, of course. That's pretty bad news for me. I found out that working with expansions are pretty hard thing. for... is really great idea.
&gt; are there official secretary-style meeting notes (somewhat like Person x said a, b, c) or a complete list of votes for accepting papers and results? Yes there is! Those are not public though.
Committee been working to pipeline and parallelize our work to accommodate unprecedented load. The fact that this proposal in garnering interest at an early stage of the pipeline shouldn't be of alarm, and is precisely how the system is intended to work. Networking TS is dependent on Executors, which is the only reason for its delay.
非要说明吗？搞TMP完全是走偏了！ 现在的情况是基础设施要啥没啥，比如几十年了连个网络都不支持，一味的搞TMP而不去完善基础设施，基础设施不完善，谁还会用你？看看隔壁的golang，自带标准库要啥有啥。假如要写一个东西，如果用cpp你需要到处去找库，甚至自己造轮子，而选择其他的语言，标准库就要你想要的，你还会选择cpp？ 当然，现代的TMP对库作者是爽了，不用搞SFINAE这套。可问题是你要给就给一套啊，今天给一个enable_if明天告诉你concepts更好，而且各个编译器的支持又不一样。 我造轮子已经造够了，现在只想当一个调包侠。
The argument is that new developers could get started with any standard complier, and not have to learn a packaging and build system at the exact same time. That said I agree; I don't feel this is the right place to put this library.
So a 2D software rendering API (canvas) and a 3D API without any hard guarantees to be actually accelerated are modern and in line with C++ performance wishes? Webview has no place in std.
Many of us remember the BGI, OWL, MFC training wheels, that is why we started using C++ instead of C in first place.
Breaking backwards compatiblity of Coroutines will be much more palatable when everyone's using std::task and std::generator. Would you have considered it worth it to delay Coroutines (to 23) entirely?
This was actually the performance benefit of letting the back end of the compiler do the optimization: it will allocate enough for all your nested calls IIRC. If we wanted user controlled allocation we would have lost that. Also I should point out the current Freestanding author considers Coroutines Freestanding: you can statically allocate a fixed Coroutine heap and overload the new operator.
The wording for any_invocable was done -- but you can't get blood from a stone, and it'll just have to wait until 23 opens. Good news is it'll be available on compilers early, and you can always copy an implementation from your favorite OSS project.
I finally skimmed the paper for that today. I hadn't been paying attention to it because I thought it had something to do with regex and I wasn't interested in that. D'oh. It actually looks super cool, despite having a really vague and understated name. It looks almost exactly how every newbie thinks switch() is supposed to work.
Better than the alternative. I think neither belongs in the standard. I'd rather have `web_view` if we must have something.
Uff, brace your self, this type of opinions are not very popular here even it they contain part of the truth or reality I will say it is half broken if you compare to modern products, it needs a updgrade and soon, the good part is that is optional, using C++ is not mandatory, you can choose any other language you want
The committee is practical, not "intellectual". Have you ever been to a committee meeting? If not, then perhaps you should attend one to see how things actually work.
If c++ can't be taught to new developers it will not be used outside of legacy software. Simple as that. Whether we actually need a graphics library in the standard for that is another question, but this "c++ is for experts" attitude is just stupid.
I will want to attend to one but i am afraid of going and voting, i am not a guru so my vote, even if it is needed for quorum i wouldnt feel good about it because i will voting based on what others do not on what i think is the best And i always defend the hard work of the ISO and people like you that keep us to date of what´s going on, the problem is not lack of hard work, i guess it is a focus one, instead of dealing with so extreme cases it should be better to improve the foundations. I dont know how to solve it but the overall results are not fulfilling if you compare to other recent rivals
So, I'm not really sure I understand your point, or what you think should be improved. Can you give me a TL;DR/bullet points on what you think?
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cfwfkm/line_51_is_showing_error_any_suggestions_t_ok_fix/euczfbe/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
So are you arguing for our against the use of this party libraries? You seem to be for in one paragraph, and against in another.
TL;DR: OP wants a BDFL to ship a high-quality, batteries included standard library. OP, you'll never get your wish. Too many people use C++ for high-perf code where people want to understand and specify exactly how their code gets compiled down to machine instructions. These machines also may be weird embedded systems lacking all sorts of capabilities you'd expect from a modern CPU. This means any standard library implementation has to satisfy a gajillion stakeholders and use-cases. No offense, but if you want high-level libraries with "it-just-works" semantics and reasonably high performance, maybe try the JVM?
Do you mind if i give my opinion? In short, a smooth experience like the one you get with Python, Node or similar No build system, make it a default one that hides all the complexity of the project but that allows some customization, Visual Studio ones is far from perfect but it would be a good starting point A good package manager, including a third party lib is painfull and slow and chances of success are not 100% A better and more complete STL with simplier sintax, list.find() or list.contains() instead of "std::list&lt;int&gt;::iterator findIter = std::find(ilist.begin(), ilist.end(), ObjectToFind);" which will require a post process in the findIter object, i know the C++ is more versatile but it makes harder and complex to use That´s would be a nice starting point and if the ISO promises it will be coming to the language in recent years (26?) i will wait for it because i am at the point of switching, in the next months i am going to buy a good book about Rust and give a real try, if i like what i see i will make the switch, i was reading the reddit about it and there are jobs offer (here are too but in the sense that is not a toy, is a useful tool that companys are using) or the fact that they are working on an ultra fast compiler only for debuging make me smile like i havent since C++ 11 release, and it is only one feature
You’ve to put &lt;&lt; before endl on line 52
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cfwhyh/line_51_is_showing_error_any_suggestions_to_fix/eud03ei/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
It's line 52 and your missing &lt;&lt; before endl where the red squiggle is..
What's BDFL?
&gt; A better and more complete STL with simplier sintax, list.find() or list.contains() instead of "std::list&lt;int&gt;::iterator findIter = std::find(ilist.begin(), ilist.end(), ObjectToFind);" std::find(ilist, ObjectToFind); in C++20. That seems fine.
Benevolent dictator for life, like Guido Rossum for Python.
&gt; No build system, make it a default one that hides all the complexity of the project See, this is the problem with zero-config build systems; you can't just "hide" the complexity in the general purpose case. Can you make something that works for many simple use cases? Sure. But you can't make something that works that way for everyone's large scale C++ projects. C++ targets a different later in the stack than Python or Node. You use it to solve different problems. You use C++ to build fundamental and system software layers. Sometimes, by nature, that is complex.
&gt; Do you mind if i give my opinion? Please do, feedback is always good.
Google tells me it is the "Bund deutscher Fußball Lehrer" (German Soccer coaches association) ... 🤔
And because a whole study group will be working on it for years, the feature will become even more powerful, complex and have even more pressure to be everything for everyone, because they of course can't wait yet another 3 years to get their special usecases supported. Or at least that's what I fear.
I dont think he wants a dictator ruling the language, i think he wants what many of us dream about and many other competitors has, i like coding and i enjoy doing in Java, in C++ it is hard to do as it is not the code, it is the code and all the ecosystem around you and because it is from the 80s is the experience you get, far from a good one, back in the day may be fine but since i has tried better things i want them
&gt; A good package manager, including a third party lib is painfull and slow and chances of success are not 100% A single central package manager isn't the right solution for C++. We don't even have a single implementation (and that's a good thing). We couldn't make a global package manager that will work for everyone. What we can and are doing is figuring out how to interact with many different package ecosystems, including existing ones. That's one of the reasons that my study group is writing a C++ Modules Ecosystem Technical Report. Our goal shouldn't be to standardize a package manager. **Our goal should be to make it significantly easier to use 3rd party libraries in C++.** And we are working on that. C++20 modules will help with that by giving us a modern compilation model with proper encapsulation.
Benevolent dictator for life. https://en.m.wikipedia.org/wiki/Benevolent_dictator_for_life
Being a guru isn't a requirement for participation. My point was more that the author might have a different perspective if he saw how we actually work.
Libraries have the additional benefit of not being available in all platforms where there is an ISO C++ compliant compiler, with various levels of code quality.
I didnt say it is an easy task, Visual Studio or the new Xcode deals with it in a much more better way that CMake, make or any other and both products handles huge and really complex projects As i am not an guru i cant give you a clue of how they do or a paper to work with, i know for a fact that it can be done as C++ products are around with it done and since all modern langs has done too i want in C++ Trust me, i couldnt care less if the process wasnt a mess but dealing with the build system is pain, slow and not a good experience in general while draging yo because it is heavy time consuming making you a much slower developer And thanks about the tip of the new STL, i will upgrade the compiler and see if that overload is avaliable or i has to wait
I'm suggesting the (excellent) committee isn't achieving the big picture goals for C++. I think it has spectacularly failed to give the wider productive tool BUT perhaps that is the fault of the ambitions. It is excellent at providing those carefully considered 'dont pay' and extensible building blocks. But applying those same principles to say networking has not been a success. The standards part needs to reduce what it takes on but in parallel encourage the wider community to created 'boosted' (non) standard, perhaps opinionated solutions. So my 10 years frustration that say ASIO hasn't been standardised has changed to realise it shouldn't be in the standards. It just distracts. There are a lot of other working groups on specific items that fall into the same category. Standards purpose needs to do less and focus just on what it's very good at.
&gt;A good package manager, including a third party lib is painfull and slow and chances of success are not 100% CMake does allow for concise project definitions. For personal projects, the vcpkg package manager makes it easy to use 3rd part libs. It's all not python level ease-of-use, but also not a world apart either.
BGI and OWL were part of what made me pick C++ over C. I agree with Herb on this one. On the other hand C++ has been loosing its position as GUI programming language, being pushed down the stack for visual composition engine, GPU shaders and graphic language, with the actual app being done in something else. So I think we have reached the too little, too late for expecting that it will change the course of C++'s decrease for coding userspace apps among newer generations.
I now but if dont truly undestand the papers how could i make a decision and hope it is rigth? I may vote for the 03 pointers believing it was the rigth choice and we all know that thankfully 11 deals with it and solve the matter, it is the weigth of responsability and not being 100% sure about what you are doing You need to be a truly expert or at least is what i think, i am only a good developer so not for now, otherwise you will hurting the lang in the mid and long term with your decisions
I don't need to attend because I simply don't need to care about that work. You have a proven and excellent track record at the building blocks level. I trust you. I know you wrestle with the wider issues constantly. Should this feature be considered, rejected etc. I look at the outcome and for every great building block or strategic change requiring standards support e.g ranges, modules, you have struggled to deliver the goals stated 10 years ago for a wider ecosystem, productive tool.
Well, i dont want an explicit one, only something that make easy and quick to work with, if you can achieve this i am sure someone (even me) could develop a layer on top to make looks like a one command importing system as other does I know that the main reason of modules it is to make that but i am not a believer, i want but i fear it will not be enough. I hope i am wrong and it is the tool we deserve
C++ needs them. Standards committees principles means that it cannot deliver the length and breadth required. Limited standards resource should be focused more tightly. It has the power to encourage and guide the ecosystem but doesn't have the resource to implement. Halve the scope of the standards work, but encourage 10x ecosystem development
I guess that's the point. I want java's ecosystem but in a C++ system. I still love C++ This was a goal stated for C++ 10 years ago when C# emerged and Java was also already more productive for most application development.
Have you looked at rust's cargo? It's far from perfect, but what do you think about it?
Vcpkg is awesome but is not a fault free solution and they still dont has all the libs, they are working hard and i am thankfully that MS released it for more than Visual Studio Cmake could allow what you want, the problem is that you start dealing with differents commands that do the same and the party starts, there are few libs that works as expeted with only adding the add_subdirectory() so 99% of the times you will has to struggle to make it work, and that is if the libs has the cmakelist, because are some really important projects that they dont, ffmpeg is one of them, the most important codec library of the world and no support...
You can have many tools under a single universe. Yarn is a reimplementation of npm but the package descriptions are identical and libfoo:1.42 is bitwise identical regardless of client use. Having a single source of truth is important. Multiple reimplementations are hard to deal with indeed. What does "c++20 standing lib" means?
&gt; It is excellent at providing those carefully considered 'dont pay' and extensible building blocks. Right. We can agree on this one and that's what I love about C++. &gt; But applying those same principles to say networking has not been a success. I personally couldn't care less about `std::network` getting in. There's Boost.ASIO and the standalone version, people can use that. With the help of `bcp` bundling just the necessary parts of Boost is easy. Not everything needs to be in the standard library and, perhaps more importantly, the standard library isn't, or at least shouldn't be, a mean to distribute a library to one's users. &gt; The standards part needs to reduce what it takes on I do tend to agree. I don't see any point in `std::web_view` and from here it looks like it will take a ton of time that could be better spent on something else. &gt; but in parallel encourage the wider community to created 'boosted' (non) standard, perhaps opinionated solutions. We have Boost, Abseil and GSL. I haven't used GSL, but I've used the other two. IMHO\* is great and would have the same opinion of Boost if it were "rebased" onto C++11. &gt; So my 10 years frustration that say ASIO hasn't been standardised has changed to realise it shouldn't be in the standards. It just distracts. Again, we can agree on this, but for this to work the way I think you're imagining, we need wide adoption of modules. If the reported benefits end up in the same ballpark (for a pretty liberal definition of "ballpark") I believe we'll see pretty fast adoption of modules.\*\* &gt; There are a lot of other working groups on specific items that fall into the same category. Maybe domain experts need to figure out how to gather around and discuss moving C++ forward in their domain outside of the C++ standardization process, but that is a *wild* dream. Why? Just try justifying that to your employer. Employee: Hey, I'm going on a trip and the company should cover my expenses, like in the previous year. Employer: C++ standard meeting again? Employee: Something like that, yeah... Employer: "Something like that"? Employee: Well, this time we decided to separate from the standard. It's just me and a few guys going to Kona for a week. The actual committee meeting is in two weeks and I also have a paper I should champion there. &gt; Standards purpose needs to do less and focus just on what it's very good at. Good luck getting people to agree what parts should be dropped, potentially after years of work. A simple example: I don't care about ASIO getting into the standard, but would have loved it if [P0593](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0593r3.html) got into C++20. At the same time I'm sure there are people who don't give a rat's ass if P0593 ever gets adopted, but want Networking TS adopted yesteryear. &amp;nbsp; \* "IMHO" sometimes read as "In My Horrible Opinion". \*\* If the compile time drops by 50% (and claims were made that much larger improvements are possible), suddenly selling a) move to C++2, b) large refactoring effort and c) switch to modules to your CTO becomes plausable. "If you let us do this for a while, the distributed system used to compile this beast would need only 50% of the power, saving you potentially a lot of money every month in electricity."
Cargo is only simple because it forces you to use a very specific project structure, if you follow the same setup in C++ (which you probably should) then setting up CMake is a walk in the park
&gt; Our goal shouldn't be to standardize a package manager. Our goal should be to make it significantly easier to use 3rd party libraries in C++. A standard package manager is simply one of the more modern / easier ways people are introduced to, and use, third party libraries. So ultimately I think having a standardized package manager or not, as long as the _ability_ to create one is there, will plenty good enough. Then many people can create package managers. Or maybe one will win, who knows. But right now downloading and configuring third party libraries to be used in any project is almost always a PITA. Sure, some are straight forward but it's never as easy as, say, Rust's cargo. I think a lot of folks new to C++ would really like to see it work more closely to every other modern language in regards to using third party stuff. Here's hoping C++20 modules are a big help with that.
Magically behaving ide are part of the problem because they hide an I credible amount of complexity instead of reducing it, leading to ecosystem fragmentation. VS code is in a much better place because it doesn't try to pretend building c++ is magical. It let users set up the few required build command manually and let the build system deal with the nastyness
I'm sorry, but i have a very hard time understanding what you're saying exactly? How does the standards committee encourage (or not) third party library development?
Mixed language development may well be the answer where C++ is complemented by C# ecosystem, python etc. I want high performance in parts so want to follow a lot of what's good about C++ (or Rust etc. as systems languages) I want C++ to allow the choice. Concrete example: I look at Herb Sutter's proposal for a meta language description to enable ecosystem libraries to integrate with the core. Personally I would ditch at least 50% of what is currently ongoing. (Too late for C++ 20) I would move heaven and earth to get that capability fast tracked as soon as possible. As is, it'll canter along and perhaps be fully released in C++ 26 and gain traction and experienced best practice/ be tweaked in C++30.
A building block for graphics would stop way before std::button. It would be std::window (with event handling) and that's all. And maybe a generic way to initiate a graphical context (cairo canvas, OpenGL, DirectX, etc). SDL2 has done it portably for many many years.
Python's package manager is "fine", until you need to package a module written in C++ that optionally links against a shared library. And then, when ~~you~~ I try to use `pip` to install a dependency, ~~you~~ I get flooded by bug reports because users have the python interpreter and CPython headers, but a lot of them don't have `pip`. &amp;nbsp; In my personal experience, every C++ build system was much easier to work with than Python's `pip`. We ended up forking a dependency just so we can build it with cmake instead of using `pip`.
Looking forward to see all these features implemented in MSVC.
The thing isn't about you having the same setup, it's about a standard. Why do you need to make your custom CMake setup if you can just use a default that works the same? That just seems like a I like to build my own things problem, it doesn't help the community at all.
&gt; Language evolution is NOT the end objective in the real world. end goals or AIMS are not objectives. AIMS &amp; end-goals should be specific, measurable, actionable / assignable, relevant and time-based. Objectives help you get to end goals, but generally represent a unit of work towards an end goal or aim. How can you be complaining about language whilst using incorrect words? &gt; It's ok to define things that aren't infinitely flexible, and infinitely extensible but get the job done. Agreed. Kate Gregory talks about this in some of her more accessible pluralsight courses. Also Kate has done a number of YouTube talks covering this. &gt; It's OK and, in some ways better, to provide an opinionated library outside the standards rather than deliver an intellectually burdened, extensible interface two years later than needed. If I squint a bit this might be okay for a business. Not a standard or framework. Of course you can cast everything using (void *) if you're working on some internal noise project. Doesn't mean training should push that as a good way to code. &gt; All the helpful features in the core language and core libraries are MEANT to enable a much wider ecosystem to make the tool that is C++ more productive. What does this mean. Do you have examples of when core libraries restrict ecosystem and make C++ less productive? &gt; But we aren't getting a wider ecosystem, we are just getting a language where we are apparently 'not paying for' a huge intellectual burden. All programming languages suffer this to an extent. Some of the newer languages have enterprise support from Giants like Google &amp; Mozilla, but ultimately, all are under-funded. C++ further suffers from not having too many giants supporting a freely available compiler, and many compilers having differences which make inter-compiler compatibility a burden. There are additional costs to even get started with C++ &gt; Look at how the wider productive ecosystem hasn't flourished since C++ 11. &gt; &gt; I know many excellent libraries have been made, but think about your next large project and how much is coming from a mixed bag of variable quality 3rd party libs to plug basic capabilities. &gt; &gt; The committee work is spread so thin that core building blocks get pushed out further in time and so can't be built upon by library authors. &gt; &gt; Networking, executors, any form of I/O - slipping again. &gt; &gt; Lots of hard work being done but by far too few people in their spare time. &gt; &gt; Seems a very dysfunctional way to move the monolith forward. &gt; &gt; 'You don't pay for what you don't use' is laudable up to a point, but the 'don't use' because you don't actually have, say, a basic network library is more of a reality. Hmm... IDK it is easier for application languages to make lots of decisions up-front about this sort of thing. For example non-blocking as a default, or hashmaps called arrays because the mental model is contiguous. C++ largest challenge as I can see here is C and legacy C++ compatibility. My point is that whilst language sugar and features may be available in a lot of other places; choice and robust open design are not. It would be nice to have an official C++ compiler, linter, formatter, documentation standard and a larger standard library, but without finding millions of dollars to fund it; I don't expect it will fall from the sky at any point soon. Worse still, implementations of C++ for embedded platforms and non-x86 hardware will continue to have warts
It should encourage but not 'do'. Lots of proposals consume evaluation effort. Some make it further.
&gt;The thing isn't about you having the same setup, it's about a standard In this context that's the same. This is again similar to naming conventions, there is already a standard yet people fork and come up with their own snowflake conventions when everything would be easier if you just sticked to the idiomatic style. Style readability is mostly about familiarity anyways. I mean you would never write snake_case in Java or C#, and for the same reason it doesn't make sense to use camelCase in C and C++.
The problem is the reason that forced they to has to hide it. Build system is only equal to pain and stress, it may handle the nasty stuff but requires much effort from the developer in order to do it And bigger problem is that Rust has hoard my attention recently and it went to "will see the future of this new C++ killer" to "i am eager to try and see if it becomes my new high performance lang". I has for granted so many things and more that are comming that really makes it hard not to do the change so in the end is promises vs reality. The issue is that much more people say this way than not and people are tired of waiting for them to arrive
I'm planning something similar myself using CRTP with a serializable class that requires the subclass to have a Tie function (using std::tie to return members) and a static constexpr members array of stringviews which will allow simple serialization to json
So, why not something like cargo? &gt;Style readability is mostly about familiarity anyways That's literally not true. Style is about standards, not that they are good, just that they are everywhere and everything looks the same. If I start maintaining a codebase that uses a different style than I prefer I will keep using the old style.
What does this mean. Do you have examples of when core libraries restrict ecosystem and make C++ less productive? Not being a 'positive' change isn't the same as being a 'negative' one.
You don't need a single implementation to have a good standardized package manager. We need a standard dependencies format (e.g. Requirements.txt, project.json) and a standard CLI for the frontend. Then we can get as many implementors as we like.
I don't think the main problem is that c++ is used for different kind of projects (although that is a problem). The main problem is that there hasn't been any standard build system, project layout, dependency management system, c++ featuresey or in general "standard way to do things" for the last 2-3 decades. But any modern solution (package management or build system) is expected to make interop with all the projects that have been developed in all that time to "just magically work".
&gt; This was actually the performance benefit of letting the back end of the compiler do the optimization: it will allocate enough for all your nested calls IIRC. If we wanted user controlled allocation we would have lost that. I find this surprising, since a transformation to a state-machine also allows stacking without issues: you just put the inner state-machine in one of the state of the outer state-machine, ad infinitum.
[p0660r9](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0660r9.pdf): &gt;It is intentional that class std::jthread supports the full API of std::thread (i.e., by supporting to start &gt; &gt;the thread without taking a stop token as first parameter) to be able to replace any usage of std::thread &gt; &gt;by std::jthread without further code changes. If it's a drop-in replacement for std::thread, why not just fix std::thread instead? ABI again?
Advantage being?
&gt; Can you be more specific which things you consider clashing? I can name a few, I'll refrain from the full list as I want to enjoy the sun today! I am generally concerned, specifically, about performance, in keeping with the list of principles I mentioned: You Shall Not Pay..., Zero-Cost Abstractions, Leave No Room For A Lower-Level Language. Sticking to the language: - Implicit memory allocations in implicit conversions; sneaky :/ - `sizeof` vs `strideof`: distinguishing the two allows reusing padding bytes. - Empty structs occupying 1 byte: partly addressed by [`[[no_unique_address]]`](https://en.cppreference.com/w/cpp/language/attributes/no_unique_address) in C++20. - RTTI: `virtual` does not equate `dynamic_cast`. - `std::initializer_list`: cannot be moved from. - Lack of `std::is_trivially_relocatable`: cannot bulk `realloc`. *(Wasn't it coming?)* - And now, Coroutines. There are many more examples in the standard library; but as I said, the sun is calling. &gt; If Coroutines don't fit your need, it costs you nothing to not use them... Well, it does actually. We are back at carving subsets of the language that fit and doesn't fit our needs, banning libraries that do not conform to our subset (which requires auditing them), etc... all of this is painful, and expensive, and at some point makes you wonder whether another language would not be more suitable. That's why ensuring that your values align with that of the language you use (and its community) matters. I don't think promoting a fractured community is healthy; although mayhaps it's inevitable as the size of said community keeps on growing.
&gt; Also i personally dislike (and don't see a need for) having real code hidden inside a string literal You already have that with literal suffixes.
I would very much like a delay to 23, since we will already have Coroutines TS in all major compilers for everyone who likes to user them, be able to gather more user experience, but most importantly can still make braking changes to the design if deemed necessary (which from the looks of it yes).
Something along the lines of how ibiblio repository is setup for Java Maven? Standard layout, common versioning semantics, metadata files with known names and structures.
&gt; Our goal should be to make it significantly easier to use 3rd party libraries in C++. And we are working on that. This problem can be split into two pieces: - using dependencies that have been somehow prebuilt (if needed) and installed - using dependencies in a way that you build them at the same time as your code that uses it There is a solution to the former, which is called `pkg-config`. Not only does it work, but it is already widely used. The whole of Linux userland development is built on pkg-config, including many C++ packages. Even Qt provides pkg-config files and it works really nicely. Pkg-config is not without its issues, sure, but the fact that almost all discussion about C++ dependency provider discussion an papers either don't mention Pkg-Config at all or just poh-pooh it away in a corner is not particularly nice. The latter problem, on the other hand, is not really solvable. Having two different build systems working together in one build dir does not work and can't really work. A lot of people desperately want this to be possible, but it is not. I wrote [a blog post](https://nibblestew.blogspot.com/2019/02/why-is-cross-language-cooperation-so.html) about this ages ago. It talks about mixing Rust and C, but the core issue is the same.
Not saying it is never the case, but 99% of the time std::sort will beat anything you can write.
It's something that I dont understand. Why can the committee requires compiler to implement X to be conformant and can't require build system to consume a specific project description to be conformant?
I'd hope that a conforming implementation could launch a tab in the user's preferred browser. AIUI there's API for that on all the major desktop platforms, as well as mobile.
So if I understand correctly: a problem was identified, a solution was proposed and implemented, a path was proposed with minimal changes today to allow for a better future tomorrow, and while the problem was acknowledge we still voted to ship coroutines that we don't know how to fix? That's unfortunate to say the least. I understand that the previous coroutines alternatives were shot down because of implementability issues, but since this one has already been implemented I don't understand why the committee would choose to ship apparently unfixable features when there is a known solution. That does sound like something that would have justified coroutines being delayed to C++23.
Isn't the understanding of a build system required for learning javascript? I don't think that it a valid consern.
Pattern matching is jargon that I believe originated from the functional programming community, so I can imagine the confusion coming from a different perspective without it.
Please re-read my comment this is exactly what I meant. People should stick to the standard not make up their own. That makes things consistent which is what matters
&gt; No build system, make it a default one that hides all the complexity of the project but that allows some customization, Visual Studio ones is far from perfect but it would be a good starting point &gt; &gt; A good package manager, including a third party lib is painfull and slow and chances of success are not 100% Is this satire?
There is no standard build system or project layout that will work for everyone.
We are moving in that direction, with the C++ Modules Ecosystem Technical Report, which will contain a number of different build interchange formats.
That's my point about cargo, instead of people making their own standard they stick to a default one that's general enough and provides scape hatches, but that are supported out of the box. It's incredible to use libraries in rust, seriously, it's as easy as python but it supports compilation to many architectures, systems, with C libraries easily integrated.
Is `web_view` required to appear as a separate application, or can it launch a tab in the user's preferred browser? The latter seems like it should be simpler, both to implement and in terms of user expectation. It's also the approach taken by an increasing number of cross platform desktop applications.
&gt; I look at Herb Sutter's proposal for a meta language description to enable ecosystem libraries to integrate with the core. Which proposal do you mean?
&gt; I want C++ to allow the choice. &gt; Personally I would ditch at least 50% of what is currently ongoing. (Too late for C++ 20) Everyone has different priorities. If you want C++ to have choice, that means we will spend time working on things that not everyone may think is important.
We had a problem. We though "I know we can solve this with regular expressions!" We now have two problems; the original problem, and regular expressions.
&gt; Here's hoping C++20 modules are a big help with that. Modules alone won't. We need some coordination between tools, build systems, and compiler implementors. That's what SG15 is for, and why we are working on an auxiliary document (the C++ Modules Ecosystem Technical Report).
It's a fine solution for Rust, which has a single implementation, a very targeted set of use cases, and ~100k users. C++ has multiple implementations, runs on a myriad of platforms, and supports a wide range of domains and environments. Something global like cargo wouldn't work for everyone in C++. We should enable something like that to be built, but we should also enable other options (distro package systems, in house package systems, etc).
&gt; i dont understand why nobody is doing anything That's simply not true.
An alternative approach for this could be something like: - Start with Compiler Explorer - Make the backend output WASM binaries - Update the UI to run said WASM binaries on the user's web browser - Add a library to so simple 2D graphics (optional) Now you can do simple C++ graphics coding using _nothing but a web browser_. This could even be expanded to host a full online C++ development course. You could take the class using any computer and without needing to install _anything_ on your machine.
Because both behaviors are desirable?
As far as I know, they are used to create an API/ABI compatible binding from C to Windows internal C API and syscalls, because the latter might change with new releases, and it did. I suppose you need to trace which dll is used to execute that function and then disassemble that dll.
&gt; Time to recognise that less is more in the standards work I agree. I'm solidly in the "batteries not included" camp. Not everyone is, though - some believe that a lot more features and a bigger standard library is necessary for C++ to remain competitive.
What are BGI and OWL?
MSVC ranges are still a work in progress. /u/stl, is it available yet?
Guido stepped down, though.
`WinMain` isn't part of the windows API. This is a function you wrote. The windows runtime _calls_ your `WinMain` at some point, but that doesn't make it part of the API. There's no need to disassemble it because you literally wrote the code it was generated from in the first place.
Iff there were to be a iso-std-layout, that would hugely improve the chances of coming up with [or converging to] a std-build-system or for existing tools to 'just magically' work [also] on that std-layout.
Where do you see "c++20 standing lib"?
I never said it would. But there is a difference between having a default that works for 90% of the projects and and special solutions for the remaining 10% and having a dozen different solutions that are each used by 20% of the projects (with each project supporting multiple ones). You wouldn't even need a single build system for the 90% just a standardized interface (e.g. description of how to compile it and how to use it)
Not yet. Casey will be working on it.
I would assume it's to make sure existing std::thread usage doesn't break anything. Calling join in the dtor would not affect ABI, but it could lead to calling join twice for code relying on pre-C++20 behaviour.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cfxp1d/how_do_i_look_inside_the_win32_api_functions/eud7mho/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; it doesn't make sense to use camelCase in C and C++. A surprisingly number of people use camelCase or PascalCase in C++.
Yeah, that's what I want to know. What would one have to do to look into the Windows internal C API and syscalls? Is direct disassembly with tools like x96dbg and WinDbg the only way? There's no documentation for that kind of detail?
&gt; ... is not a fault free solution and they still dont has all the libs ... No, but getting better and there are now over 1'000 libs (and counting), going for 'all' seems a bit over-ambitious. CMake is doing the same as C++ itself, add more stuff and keep the old, for backward compatibility.
Wait, are you serious? If I use WinDbg or x96dbg to peek behind the curtain this is a violation? I just want know what stuff like WM_Paint and RegisterClassA are doing behind the scenes. I'm curious.
&gt; If the compile time drops by 50% (and claims were made that much larger improvements are possible), suddenly selling 2x to 3x compile time perf wins for switching to modules is what I'm hearing from the three major compiler vendors. During the SG15 last Friday, an LLVM implementor showed us a live demo of hello world (using `&lt;iostream&gt;`) compiled without modules against a build with implicit modules (e.g. no code changes, just include translation of `&lt;iostream&gt;`). Building with modules was about 4x faster in the live demo (discounting the time it took to build the `&lt;iostream&gt;` module). I was impressed.
The other of those "both" is a suicide. I can't quite call it "desirable".
By focusing on making it significantly easier to use third party libraries. Modules goes a long way towards this, by giving us better code encapsulation.
From the windows terms of service: &gt; Restrictions. The device manufacturer or installer and Microsoft reserve all rights (such as rights under intellectual property laws) not expressly granted in this agreement. For example, this license does not give you any right to, and you may not: &gt; &gt; (i) use or virtualize features of the software separately; &gt; &gt; (ii) publish, copy (other than the permitted backup copy), rent, lease, or lend the software; &gt; &gt; (iii) transfer the software (except as permitted by this agreement); &gt; &gt; (iv) work around any technical restrictions or limitations in the software; &gt; &gt; (v) use the software as server software, for commercial hosting, make the software available for simultaneous use by multiple users over a network, install the software on a server and allow users to access it remotely, or install the software on a device for use only by remote users; &gt; &gt; (vi) **reverse engineer, decompile, or disassemble the software, or attempt to do so**, except and only to the extent that the foregoing restriction is (a) permitted by applicable law; (b) permitted by licensing terms governing the use of open-source components that may be included with the software; or (c) required to debug changes to any libraries licensed under the GNU Lesser General Public License which are included with and linked to by the software; and &gt; &gt; (vii) when using Internet-based features you may not use those features in any way that could interfere with anyone else’s use of them, or to try to gain access to or use any service, data, account, or network, in an unauthorized manner.
Oups, standard
Well, personally, I'd rather have a program stop (crash) rather than hang indefinitely because it's attempting to join a thread as it unwinds from an exception and that thread never stops. A proper shutdown sequence is not easy, and I am not convinced that `jthread` is necessarily a good idea here. *PS: on the other hand, I really like `stop_token` to help coordinate the shutdown.*
I've heard Bjarne mention that he heard even wilder stories, but I tried to be conservative with 2x speed up.
They're already doing this?
Even an attempt is a violation?! Son of a... I guess they have to protect their intellectual property, but it's kind of annoying that you just have to trust that the Win32 functions can do their black magic correctly. Thanks for the info.
https://wg21.link/p0707
Of course I've been saying similar things for a long time, though it's a little ambiguous exactly what you are saying I think. I certainly believe, if this is what you mean, that way too much time has been spent on containers, much of which anyone can trivially do if they need to, and not enough time on stuff that real applications need these days which aren't trivially doable. I think a huge amount of time has been spent pushing premature optimization all the way up into the language design process. I've put my money where my mouth is and created a system that puts the emphasis where I think it should be, i.e. less on creating an operating system in a single templatized header that uses zero CPU, and more on providing the type of functionality that is needed to do the kinds of programs that C++ is intended for (other than embedded) without having to just throw a bunch of bits and pieces together. [https://github.com/DeanRoddey/CIDLib](https://github.com/DeanRoddey/CIDLib)
Borland Graphics Library (MS-DOS) and Object Windows Library (Windows 3.x), relics back from the day before the decision POSIX was good enough for C++'s standard library. Something that ISO C++ is now trying to fix, but appears to have come too late, having let other eco-systems offer more mature tooling.
Borland Graphics Library (MS-DOS) and Object Windows Library (Windows 3.x), relics back from the day before the decision POSIX was good enough for C++'s standard library. Something that ISO C++ is now trying to fix, but appears to have come too late, having let other eco-systems offer more mature tooling.
&gt; 30.5.2.2 jthread destructor \[thread.jthread.destr\] &gt; &gt;\~jthread(); &gt; &gt;If joinable(), calls request\_stop() and join(). Otherwise, has no effects.
Indeed everyone does have different features they deem important. My criteria for work by standards would be at least one of: * Cannot be implemented as an external library * 'Needs' language/keyword support for a consistent, usable interface * Provides a framework or ABI to align code generation tooling (compiler etc.) More importantly, criteria that don't of themselves warrant inclusion in the standard * Needs the insight of the experts within the standards committee * Needs to be a std:: feature to ensure everyone uses it (std lib vendors need to deliver it) * Used as the basis for other libraries * Provides a widespread feature e.g. unicode, formatting, file system i/o Note that goalposts do move as more and more functionality can be implemented as external libraries.
My preferred direction on that is to permit structured binding from an untyped braced initializer list: auto [x, y, z] = {1, 2, 3}; If you have that, then the existing direction for `template for` is sufficient to also address variadic packs: template for (auto x : {pack...}) Combined with P1061, that also lets you do neat things like: auto &amp;[first, ...rest] = {pack...};
The plenary minutes, however, are public, they are published in the post meeting mailing.
Like I said, if you want to know more about how operating systems work the legally least questionable way is to look at open source operating systems/kernels like Linux.
`pkg-config` is great for system-level dependencies, but not so much for dependencies that you want to ship. So, at work we maintain 2 legacy versions of our software in addition to current version and the to be released future version. We also use Qt, which you want to be in the prebuilt category, for the GUI of this software, with the following configurations: * Legacy 1: Qt 4.8, gcc 4.9 * Legacy 2: Qt 5.5, gcc 4.9 * Current version: Qt 5.5, clang &gt;= 7, system stdlib * Development version: Qt 5.12, clang &gt;= 7, libc++ &gt;= 7 Oh, and these configurations must be built side-by-side on the same system. AFAIK, `pkg-config` literally can't solve our problem, but I would be delighted if you could prove me wrong.
The member functions of `directory_­iterator` are supposed to init the cached attributes ([\[fs.class.directory.iterator\]/9](http://eel.is/c++draft/fs.class.directory.iterator#9.sentence-1)): &gt; Constructors and non-const `directory_­iterator` member functions store the values of any cached attributes ([fs.class.directory.entry]) in the `directory_­entry` element returned by `operator*()`. /u/jwakely, is this a libstdc++ bug?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/cfy67d/need_help_about_learning_c/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
With a hanging program you at least still have a chance to attach a debugger, see what's going on and fix. After terminate it's just dead and not helpful (unless you resort to some platform-specific facilities in a terminate handler like writing memory dumps). &amp;#x200B; I dare say that "joining a thread as it unwinds from an exception" is not a common case in general. The common case is to just use threads as regular RAII objects (which don't require any special finalisation ritual), and this common case doesn't work. If I'm wrong and the exceptional case is not so rare and the suicide is the best option - well, we have std::uncaught\_exception**s** now, so it is possible to implement the "scope\_fail" idiom within the thread class and terminate only if it's getting destroyed by a stack unwinding.
Yep it is indeed surprising. Seems like a thing that mostly only C++ suffers from. In other languages people tend stick to the standard/idiomatic style to a much higher degree.
No. Attributes are allowed to be cached, not required to be, and that's in the C++17 spec **not** the TS. GCC 9 caches some attributes for the C++17 iterators, I don't remember what's cached or not in GCC 8.
No, you don't need to call `refresh`. If the attributes are not cached then calling `is_directory` will fetch them (and maybe cache them for future use).
&gt;Maybe domain experts need to figure out how to gather around and discuss moving C++ forward in their domain outside of the C++ standardization process, but that is a wild dream. Why? Just try justifying that to your employer. Maybe we should move on from the idea that you need to physically be in a certain place to communicate with others.
In GCC8.3 the file-type attribute is *not* cached, and ```is_directory``` *always* returns ```false``` unless ```refresh``` is called first. So it probably is a bug in libstdc++, maybe fixed in GCC9, haven't tried that.
That is not happening.
They should ask themselves how come that Python is [accessible, on-ramps new programmers, loved by educators](https://www.tiobe.com/tiobe-index/), but (ta-da!) does not come with a graphics library? Maybe it's not about a graphics library after all?
Could you please post your code? On my machine, this works: #include &lt;filesystem&gt; #include &lt;iostream&gt; int main() { for (const auto &amp; entry: std::filesystem::directory_iterator(".")) { std::cout &lt;&lt; entry.path() &lt;&lt; '\t' &lt;&lt; entry.is_directory() &lt;&lt; '\n'; } } &gt; g++ --version g++ (Ubuntu 8.3.0-6ubuntu1) 8.3.0 Copyright (C) 2018 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. &gt; uname -srv Linux 5.0.0-20-generic #21-Ubuntu SMP Mon Jun 24 09:32:09 UTC 2019
RemindMe! 3 days (To post my "what belongs in the standard library" slides).
I will be messaging you on [**2019-07-24 12:28:37 UTC**](http://www.wolframalpha.com/input/?i=2019-07-24%2012:28:37%20UTC%20To%20Local%20Time) to remind you of [**this link**](https://np.reddit.com/r/cpp/comments/cfwclg/c_is_broken/eudc6m2/) [**CLICK THIS LINK**](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=%5Bhttps%3A%2F%2Fwww.reddit.com%2Fr%2Fcpp%2Fcomments%2Fcfwclg%2Fc_is_broken%2Feudc6m2%2F%5D%0A%0ARemindMe%21%202019-07-24%2012%3A28%3A37) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete%20Comment&amp;message=Delete%21%20cfwclg) ***** |[^(Info)](https://np.reddit.com/r/RemindMeBot/comments/c5l9ie/remindmebot_info_v20/)|[^(Custom)](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=%5BLink%20or%20message%20inside%20square%20brackets%5D%0A%0ARemindMe%21%20Time%20period%20here)|[^(Your Reminders)](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List%20Of%20Reminders&amp;message=MyReminders%21)|[^(Feedback)](https://np.reddit.com/message/compose/?to=Watchful1&amp;subject=Feedback)| |-|-|-|-|
Not sure what you mean?
SG15 voted on this at this meeting. We had consensus against recommending a particular project layout.
true it kinda hides a function call, but you still write the actual code inside a function. that said i guess interpolated strings are not that bad if you dont do anything too complex in it
/u/HalFinkel?
You should hear what /u/blelbach has to say about that. For the record, I'm not against the idea, but there's two sides of every coin.
Well, at least "we" made progress, "we" decided not to decide anything.
Oh my. You are going to be so burnt by compiler updates for the rest of your life.
&gt; If all functions were constexpr you would essentially end up with one big translation unit which would be terrible for compile times That depends on the language and compilation model. C++ has so many context sensitive things it would be terrible, from macros to "is `&lt;` and operator or a template introducer". Butnit isn't hard to imagine a language designed to be compiled in parallel.
For anyone curious: [https://imgur.com/a/howyHHj](https://imgur.com/a/howyHHj)
ADL is a thing, and if you avoid camel_case in your own code, you reduce the risk of getting bitten by it.
Nah, I use it for things like “ can I make this variable/ method a const?” Kind of thing
I prefer the solution we discussed on IRC. We will just use the `relinquish` keyword.
What did you use to make those buttons? I'm teaching myself C++, but having difficulty finding a good solution to go beyond console programming and have point-and-click interaction.
&gt; Cannot be implemented as an external library Are you saying almost nothing in the standard library belongs in the standard?
Well it depends on what you mean by "side-by-side". There are at least two different meanings for it: - all versions are installed in some common prefix (e.g. `/usr`, `/usr/local`, `/opt/something` etc) - each dependency type is installed in its own separate place (e.g. `/opt/qt-55-clang` etc) In the former case it does not seem to be possible to have two versions of Qt since they install e.g. their headers to the same path so they would overwrite each other. The latter case is fairly straightforward. Since all of the installations are in their own directories, choosing between them is a question of setting `PKG_CONFIG_PATH` and possibly `LD_LIBRARY_PATH` to suitable values before running configuration and possibly execution steps. This is a common development method and has been used in Linux development for close to 20 years. This approach does have some boilerplate. There is a longer and better solution for this problem but you'll have to wait until CppCon when I'll have a presentation about it.
&gt;I'm just a little disappointed we couldn't have everything in one go :). Totally understandable =)
Looking at the title, most likely Qt with something like [this](https://doc.qt.io/qt-5/qpushbutton.html)
&gt; I believe the feeling is that it is needed to help make C++ more accessible, on-ramp new programmers, and encourage educators to teach C++. I don't really understand the need for this either. During my engineering cursus, at no point it was needed to make any UI at all in C++ to learn the language and I don't remember anyone complaining about it "being too hard".
Oh, nice! Never heard of Qt. I'll check it out. Thanks for the link!
Hi, I use Qt Creator which is pretty easy to use, as it has a graphical editor for GUI. I recommend (these tutorials)[https://www.youtube.com/playlist?list=PLS1QulWo1RIZiBcTr5urECberTITj7gjA]
Only now I realized the title doesn't mean what I intended - sorry, I'm not a native speaker
That exact code you pasted there does not work for me. &gt; g++ --version g++ (Debian 8.3.0-6) 8.3.0 Copyright (C) 2018 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. &gt; uname -srv Linux 5.2.0A #87 SMP PREEMPT Thu Jul 18 10:24:41 BST 2019
Thank you for sharing! I'll check this out as well. Thank you also for the link.
By allowing the same set of feature in all contexts ? We could make everything constexpr if not for exceptions, reinterpret cast and io functions
This looks really promising. Having an easy to use plotting library (like a printf for 2d and 3d data) would be super valuable for our image processing pipelines. Having more screenshots in the documentation would really help sell the project, and make it easier to use. Do you plan on adding online updating of the data to the library?
I've been saying for a long time now that we mostly don't need new shiny library features but more core features. Most people couldn't care less about 2d, ranges, asio, audio if we had a good standard package description and compilation model. They would just use a 3rd party. The std for me should not be a big framework or try to standardize stuff that is sometimes not even yet a standard in domains not related to the language itself. (see all the fuss the 2d proposal made) Less new fancy stuff that do not solve actual problems (if there are easy to install 3rd party, it is not a problem). It seems modules are partly going in the right direction at least on this point, it will make us have a more modern and decent compilation model.
&gt; With a hanging program you at least still have a chance to attach a debugger, see what's going on and fix. This assumes that a *human* will intervene *on the host* to inspect the program. This may be helpful for debugging, but is not in production, either because the developers are far removed from the final users (desktop/mobile applications) or because the developers do not have direct access to the host (embedded, server). &gt; After terminate it's just dead and not helpful (unless you resort to some platform-specific facilities in a terminate handler like writing memory dumps). Indeed, a crash dump can be reported to the appropriate gathering server for later inspection, and possibly a watch dog can restart the process in the case of an autonomous system. With "cattle, not pet" in mind, you have to prepare your system for failure. Assume the program *will* fail, and put in place countermeasures to minimize the impact of such failure: periodically saving data, monitoring, crash dumps, watchdogs, etc...
There is also a problem that number distributions algorithms are implementation defined so good luck rerunning simulation from same initial state but on two different platforms.
This is interesting: it works on an \*ext4\* filesystem, but not on a \*reiserfs\* one.
D, Modula-3, Oberon, Active Oberon, Swift, Sing#, System C#, Real Time Java are "system" languages with GC (reference counting and tracing implementations).
Asked myself the same question, jthread behavior seems like it could have been enabled based on stop_token being the first callback argument or not
We can already see where this leads when looking at C++'s place across ChromeOS, Android, iOS, iPadOS, watchOS, Windows, Fuchsia SDKs. Device drivers, GPU shaders, visualisation engine, compiler backend and that is all about it. Naturally there are other OSes out there, specially on the embedded space, which is an area still dominated by C anyway.
Not at all, HTML source includes are enough.
`man readdir` says the following: Currently, only some filesystems (among them: Btrfs, ext2, ext3, and ext4) have full support for re‐ turning the file type in d_type. All applications must properly handle a return of DT_UNKNOWN. So, I guess, `libstdc++` should check and if type is DT_UNKNOWN it should call `stat`. Could you comment, /u/jwakely ?
Yes it does, with Tk.
Why not, they are real, i cant always use the lib i want even if it has the same build system, there are times when you simply arent able and let it be choosing another. If the library owner do the job to ingrate with the package manager i know for a fact that it will work, well, if that day finally comes And i dont know about the rest but i dont like having to track my cmake as i code, if i put a class name and later decide other better i only want to change once, not in C++ and latter on CMake, or if i try something like another lib not having to do the cmakelist clean up latter The comunity and/or the comitte could do what they want, i am only telling what less hardcore users wants and why nobody these days is learning C++, i has been warning since a long time but now is aproching the end, i dont like to code at least 3 times slower at best compared to Java (which i love) with more problems when there are other options, i choosed C++ back in the day for the performance and i has been locking this week benchmarks, the conclusion i gathered is that C is faster, later Rust and in 3rd place C++, they are close but numbers dont lie so Rust is not a bad choice, it is at the same level of performance (wil depend on every case if it is second or third) but it has a better tooling and the things that will come are incredible Past christmas i will try for real and if i like it and if all the things about it are true (performance, smooth experience, good library, ...) i will switch, myself it is not relevant but i am sure that my case is the same as many more, and once the ball starts rolling no one cant stop it, if i think is better (so i will use it) i will tell others to try, and the ball will keep getting bigger, that´s the problem and the ones who did that before me and speak about the experience only grows my desires to try and see for my self, when Rust was only a toy from Mozilla i didnt looked at it thinking i will try it in the future, some years later i only read good things about it and has the things i want in a tool that make my life easier, i hope anyone could see the picture because if C++ dont do anything really good about it will not matter at all in not so many years And when developers start to switch the industry will follow which means the ISO will start loosing people, if the company dont plan to use anymore the tool makes no sense to invest money on it, Nokia, Kodac or even BASIC back in the day were "to big to fail" and we all know what happened, nothing is granted and you can be the number one that will see tomorrow if it still true
Having left pure C++ coding in 2006, there are plenty of workloads where Java or .NET are good enough and reaching out to C++ is no longer an option. Now they have been improving regarding AOT compilation, value types and low level memory management, so even they are a real threat for certain workloads.
Already fixed in https://gcc.gnu.org/r270962
I am not the author, so can't answer that, sorry.
That's really nice, keep it going and hopefully you have a new project to share soon!
Well, let's say you advocate fixing it up rather than fixing it down.
I'd love to see PCG in the standard. See also [https://github.com/imneme/pcg-cpp/issues/51](https://github.com/imneme/pcg-cpp/issues/51) &amp;#x200B; I don't think it's possible to require \`random\_device\` to be guaranteed to be non-deterministic, as it simply won't be possible on some systems that support C++. If it's non-deterministic on a general purpose OS on modern hardware then complain to your compiler vendor and get them to fix it. (Yes, I know on Windows GCC used to provide a poor quality \`random\_device\` but that's because Windows is not a priority for me to work on, and it's fixed now anyway.)
Thanks!
For a person who claims to want to enable developer productivity, that part kills a lot productivity. We can't have a Rust situation where you need to include a 3rd party library to generate a random number.
Well, 10 years ago i wouldnt be as exigent as today and maybe i will be satisfied and excited about modules Not today, what we are going to get is something better that we has today but it will not be as easier and quick as what i consider should be, once you has tried a lang that doesnt has all this added problems you dont want anything else Will see how it goes but i dont has many hopes
It's preferable to provide a way to fail at compile time than to `return 4;`
How does one join the Contracts Study Group email list? It seems really interesting to observe a Study Group right as it forms. This seems like a good opportunity.
&gt; map My understanding is that volatile will only be deprecated for member access. I think this is good.
I'm saying it should be guaranteed to be non-deterministic -&gt; it either should be available if machine and system allows it, or not available, fail to compile Btw, is it fixed ? Last time I checked on Windows it still was just a wrapper for Merssen Twister. That's another problem with GCC implementation - it's a union of something little needed for reading from /dev/(u?)random and THE WHOLE MERSSEN TWISTER, making it much larger than it should be
I agree, i am using Java for one project and it is really fast, faster that was i remenber, i am impress Well, on the cpu cycle time because the memory consuption it is of the scale as always, a basic JavaFX hello world using 400+ megs... I dont know if it is because i has 32GB or not but it is too much for a single window even if i has more than 20GB free
I agree with most of your points.If by any chance you are a domain expert, I would encourage you to help the committee improving &lt;random&gt;. Maybe less extreme, make a library and write about it. Though challenge!
Both Pascal and camel cases are good to use since the standard is written in the third-case. So you'll never interfere with the standard. Like, Rational is useful since rational is just a proposed standard. And Complex is useful since complex does not promote properly. And Vector is useful since vector does not represent vectors.
That doesn't really make sense imo. What's the point in choosing an algorithm if its behavior differs on different platforms?
Or you could use well-established abbreviation HCI [https://www.interaction-design.org/literature/topics/human-computer-interaction](https://www.interaction-design.org/literature/topics/human-computer-interaction)
std::random really needs a convenience function that generates a random float or double between 0 and 1. It's what I need most of the time and almost every language has it, so it's weird to have to write three lines of code in C++ for something that should be a small and concise function call.
The thing is, it *may* hang during unwinding, or not, depending on how you design your callable. It's not rocket science to detect unwinding and let your threads know that it's time to stop. The problem is not even thread-specific - any other destructor can potentially fall into an infinite loop or wait for something that won't happen because some precondition wasn't met due to an exception. In all other cases it's assumed that the programmer is smart enough to finalise correctly. Only std::thread questions your competence and derails RAII on a happy path because you *may* implement your bad path incorrectly.
&gt;Not sure why I bothered typing this, because your post will get down-voted into oblivion within minutes probably and no one will ever see this. Rest assured, some of us ignore the downvotes on the post and see 80+ comments as a indicator of an interesting discussion. Too bad most redditors don't understand that they should upvote interesting content, even if they don't agree with it.
Wouldn't all this go away if library header files were stored in the library container itself (.a, .so, or whatever), and the compiler only needed a -lthirdpartylib flag to get everything needed without version incompatibility problems?
This isn’t scratch, it’s C++! Jokes aside, great job!
Neither problem are solvable. 1 is an odd minefield. I fully agree with you on 2, there is a reason why dependency managers have a tendency to eat the world. You can't get far without a single source of truth.
Don't worry about `a few failed tries.' The best programmers in the world always need a few failed tries before something works completely.
I think fundamentally C++ has a culture of people doing whatever they want and guidelines will go against that. It's also difficult to explain to people that guidelines for open source projects or new projects will not prevent people with existing codebases and build engineers from continuing to do what they have always done.
Indeed, when I found that out I had to basically ditch a lot of &lt;random&gt;'s facilities, I rely on reproducible random numbers in my use case so its a bit of a head scratcher that the distributions are unspecified
You avoid ADL with the standard, not with all other libraries that might have decided a different case. It doesn't scale. Of course because we don't have dependencies management it never had to.
THIS. 1000000000 times this. I think whoever thinks otherwise probably is thinking of the std as his playground.
This. If cryptographically secure numbers aren't available, it should be a hard compile error, not 'well, look into the implementation of your compiler and hope it does good'
&gt;Thanks, didn't know about it.
Distributions are built from source in a consistent environment (the only thing that is not guaranteed consistent is compiler flags)
It makes more sense if you don't call them "algorithms". If you don't care about reproducibility they're perfectly fine. By not specifying exactly how it should be done more freedom is given to each implementation. The optimal algorithm might be different on different hardware, and if the standard got it wrong we would be stuck with a suboptimal algorithm forever. That said, reproducibility is important for many applications so it might make sense to provide two set of distributions (in addition to the current ones). One set that should just be as fast as possible with no guarantee about reproducibility, and another set with a fixed algorithm that is the same everywhere. Not sure this makes sense for the floating point distributions, but for the integer distributions it certainly does.
A lot of applications that use random numbers don't rely on reproducibility. Like any single-player game or a multi-player game that synchronizes clients in a way that doesn't rely on independent identical simulations.
Indeed. I should have done more research before posting. Thank you for correcting me.
I dug up [the comment I think you're referring to](https://www.reddit.com/r/cpp/comments/ccqz7t/z/etq7t1m) and I find it hard to agree with most of it. Your face is irrelevant to the ideas you have, and face-to-face conversation isn't inherently superior to internet communication in any way; that part reads like "we've always done it this way so this must be the right way" to me. The part that I find somewhat valid is that the committee members get to take some time off to focus on C++. I guess that's good for those who can convince their employers to fund it, but I am unconvinced that it's a good enough reason to make it prohibitively expensive for everyone else. Why can't employers who are okay with this kind of thing just give those people extra PTO to be used for this?
I think “the application server” sounds a bit misleading here. What you are describing is a domain/endpoint logic. If you want to make a server then go for a lower level logic like socket managing etc. But your architecture looks fine, thou using rest for in-layer communication may be a bit redundant here. You can just separate projects for a first time. You may want to take a look at actors if you want so.
Ha, thank you
Very cool! I specially like the choice of colors.
I would like to have portable way to serialize the state of the engines (preferably in a way that doesn't force me to use streams/strings but this is less important). It might seem like the &lt;&lt; and &gt;&gt; operators should be able to do this, and I'm not sure if that was the intention, but in practice it doesn't work like that. [GCC and Clang does produce the same for std::mt19937](https://godbolt.org/z/wodfm5).
It was months ago, and I was helping somebody who was struggling. I can't recall what the fix was, but it was an issue similar to this one: https://github.com/Microsoft/vcpkg/issues/3025
If changes are not negative or positive, they are probably positive to someone, even if it's not you
How so?
What if the device is in a system provided library and it's only known if it is deterministic at runtime?
A mailing list will be setup. If you are interested, email me, bryce at cppcon.org, and I'll get you in touch with the right people.
That seems pointless: you won't be able to interact without major work in implementations. Also if this really is for teaching or things like that, the advantage is extremely small if we are just talking about launching an existing browser, over the teacher providing the few lines of code to do that on the specific platform used. Plus it still leaves open the question of what to do for platforms without a web browser; so it would probably be optional, and if it is optional my wild guess is that it will be implemented by nobody. And including the shitload external specs of the by reference in the C++ standard is utterly batshit crazy. 1/ The C++ standard is already way too large, no need to multiply its size by 100. 2/ The web is an ultra fast moving target, and using a browser just too old or too new will render the aggregated result non-conforming. I will probably never understand why people think it is a good idea to pursue that kind of thing in the context of the C++ international standard. IMO if they think this will favor teaching adoption or that kind of "soft" effects, they are extremely deluded -- I even wonder if they have talked to teachers about that subject. Likewise for industrial applications: virtually nobody would use that class of API. Now I understand that the kind of 1st rev paper like the one linked is not really "serious" and more to make people react. Well I guess I'm reacting, so it's not a bad paper after all... :)
I don't think stating dependencies in compiler flags is the right way to go about this. If anything, they should be in the source files, or in a separate dependency description file, and the linking should be done automatically.
I was under the impression that those overloads are under `std::ranges` no?
Ah, yes, that is right I believe.
Or you could just use namespaces.
my biggest program once compiled with no errors after 3 hours of modifying existing classes and adding more stuff. I really couldn't believe that. (never happened again)
"Scientific" &gt; do math by hand ahahah
&gt; Well, at least "we" made progress, "we" decided not to decide anything. Incorrect, we have pretty clear guidance on what to pursue and what not to pursue. We are interested in implicit builds of modules, but not mechanisms that rely on a proscribed file name or file layout scheme. That leaves only one alternative; fast dependency scanners, a technology that we have already been working on and looks very promising.
In principle you'd be able to detect this with `std::random_device::entropy() != 0.0`, but it's not well supported.
&gt; Could you please spell out the reasons for not even wanting to recommend some std-layout [nobody talks about imposing]? I think the general feeling of the room is that anything we would recommend would be unlikely to work for some use cases, and might conflict/contradict the best practices for those outlying cases. To paraphrase one participant, "I'm strongly opposed to this, not because I don't think it would be useful for a lot of people, but because my organization already has a proscribed project layout, and I'm almost certain whatever the C++ committee comes up with would contradict that."
&gt; face-to-face conversation isn't inherently superior to internet communication in any way; I strongly disagree with this statement. Firstly, I'm not claiming it's superior, it's just different. Technical discourse at this level is inherently intense and emotional. Would you break up with someone you are dating over email? Making decisions on what to do with something that people have invested significant amount of energy into is best done in person. Sometimes, we have an important member of the committee who cannot attend face to face meetings regularly. Despite efforts to use messengers/voice chat/video chat to keep them involved, the work always suffers when we don't have them in person. Also, you missed one of my major arguments; the face to face meetings force us to focus on committee work for a full week, to the exclusion of all else. That is a huge benefit. We are all very busy in our day jobs. That said, a lot of important committee work does happen online. It's not one or the other; we need both face to face and online.
Then there's the unlucky bunch who have pip installed somehow, but what they really need is pip3. Also there's the matter of linux disros that only offer an ancient version of pip, and updating pip effectively brakes it on that system. It's really not in a good place right now, at least not for people who just want a package installed and don't feel like going on a wild ride of trying to fix it.
You seem to be in the right track, you can maybe think of having 3 layers, with dal (dao, whatever), business and presentation (rest). A library for the two firsts is an option. Decouple them with right interfaces as if your DB could change in the future so your business stay equal (also consider an ORM such as ODM or qxOrm), and if your presentation could change (going to say gRPC), without disturbing the business much either. Pistache is going to have a threading model in his mind, look if it fits you or not. One process could suffice, you could load-balace it, watching DB bottlenecks.
I work adjacent to the CUDA driver team. A large part of building the CUDA driver involves custom build steps/phases that are unique to what we are doing (building a massive Windows core driver/Linux kernel driver + user mode driver components + compilers + SDKs). I doubt a standard build system/project layout would ever work for us. I think this is true for a lot of environments. We need to enable people to use the solutions/structure suitable for their specific domain/organization.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cg0y25/after_c_basics/eudu3c7/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Thanks
This is also fair and true.
Thanks for sharing. I installed qt creator 2 days ago and wanted to start developing GUIs.
We still don't have a good replacement for strstream, unfortunately.
I still think you can express that in term of a dependency graph. Build `x` with tool `y`. And if you have a recipe to build y your can build it before x implicitly. In theory. I wouldn't claim this is currently practical for your use case. I am pretty sure it is not. Striving for simplicity in the general case doesn't mean we will, can, or should do that for every project anytime soon. I think that whatever the use case getting rid of _unecessary_ complexities (for example avoiding TU specific flags) is beneficial. Maybe different approaches can converge.
&gt;Making decisions on what to do with something that people have invested significant amount of energy into is best done in person. I'd argue the opposite, actually. Typing out an email (or any other form of non-real-time communication, like this reddit comment which I've edited in several places now for clarity and coherence) means you can carefully consider and edit what you're about to say before committing to it. &gt;Sometimes, we have an important member of the committee who cannot attend face to face meetings regularly. Despite efforts to use messengers/voice chat/video chat to keep them involved, the work always suffers when we don't have them in person. This is the same argument that companies use against remote workers. The rebuttal is the same here: yeah, if most of you are talking in person and then relaying it to that other person, you're going to have a bad time. If everyone is remote, you're all on equal footing, and the problem goes away. &gt;Also, you missed one of my major arguments; the face to face meetings force us to focus on committee work for a full week, to the exclusion of all else. That is a huge benefit. We are all very busy in our day jobs. I didn't miss it. I explicitly conceded that point in my comment.
Could have undesired effects in generic contexts
Once you run the examples and see how simple and powerful it is, you will love it.
3 hours modifying without attempting to build it?
&gt; like containers, much of which anyone can trivially do if when they need to I would be very surprised to hear about a non-trivial application that doesn't use any containers. Since they are very useful, why shouldn't they be in the standard library? &gt; I also think a huge amount of time has been spent pushing premature optimization all the way up into the language design process, Not everyone thinks that having everything be a polymorphic class with runtime configuration for things that should be really decided at build time is a good idea. &gt; without having to just throw a bunch of bits and pieces together I'd rather combine multiple high-quality single purpose libraries to do the tasks that I need than having a single huuuuge monolithic library that does everything badly (or at the very least not as good as the single purpose libraries). &gt; maintaining readability by avoiding massive templatization, I don't know what exactly you have against templates, but they're pretty useful. Sure if you're doing a library you're probably going to need some template stuff that is a bit verbose at times but really, when you're writing code that uses them they're perfectly readable.
At the time they were developed it was the right thing to do for a lot of the libraries, but I wouldn't be in favour of, for instance, a decimal value or currency class. If &lt;complex&gt; didn't exist, I'd probably sit on the fence :) Filesystem, regex, many others - omain advantage for being standardised is the std lib is probably available everywhere. Well, imagine if you could get that sort of advantage as an external library but allow it to evolve, not require the standard development process (e.g. extensibility hooks, measured progress) and may be get to the 90% functionality point in 3 months. Its a mindset change for libraries development; NOT giving up on it. If anything, trying to release creativity without consuming vast parts of the standards time. For instance maybe an opinionated solution may be a good library to start with. e.g a filesystem using utf8 using 'bytes' exclusively (too scared to say char). Libraries can be developed on their own timescales, can deliver partial implementations, can have versions that don't have such a high bar on backward compatibility. Just like real life. Something like ranges would be a difficult one. I'd probably say external (but from a position of ignorance, and admiration of what it achieves) At this point in C++'s life, adding more basics in std might NOT be the right thing.
Even if they do converge, it doesn't mean everyone will migrate.
I guess we just have a different perspective. I prefer to deal with people in person. I find face to face communication goes better.
We don't need them too ! Just need a critical mass of open source projects. Look how fast people moved to cmake over the past decade. The reason they did it is because they saw a value in a bigger ecosystem
\`pkg-config\` is designed to work \_within\_ a consistent distribution of software. It's utterly insufficient for dealing with variant versions of "the same" library. It does a pretty good job for answering the question "What flags do I need to supply the compiler and linker to use this library the way it was compiled". For package management you also need to answer the question "How do I build this package", which is much more complicated. It's the difference between \`debian/control\` and \`debian/rules\` vs the \`.pc\` file produced as part of building the package. Modules are going to make this even more complicated, as it's very likely a project will have to compile the module interface compatibly with the compiled library being consumed.
Note I'm making this suggestion for C++ as it currently is. &lt;random&gt; has your back already. I'm NOT suggesting this strategy for a new language.
About a year ago I posted a [library](https://www.reddit.com/r/cpp/comments/8g92er/c_data_structures_designed_for_constant_time/) of data structures for constant time erasure, insertion and lookup, and great cache locality while iterating. Many comments I got we very positive while some rightfully criticized me for the lack of unit tests and benchmarks. Today, I hope to avoid those mistakes while presenting a new library of segmented data structures, algorithms and coordinate structures. In the center of it all lies a coordinate structure called the Segment Iterator; inspiration for which I found in the book [Elements of Programming](http://componentsprogramming.com/elements-of-programming-authors-edition/). Work that Stepanov and McJones had done really impressed me, and inspired me to create this library. I'm not going to go into details of how exactly is it implemented here; whoever is interested will hopefully find all information necessary in the ReadMe of the repository. The ReadMe is mostly done, but missing some pieces, such as detailed explanations of benchmark results(of course all results are included); time prohibited me from including everything I wanted. In the future I'll add all things which are missing. For those who've read Elements of Programming and for those who enjoy formal definitions and proofs, [here](https://www.dropbox.com/s/hc042pm8kkhgj70/11nBMv.pdf?dl=0) you will find just that. Any comments, critics and words of praise are welcome.
It's been common in Unix for more like 40 years. But shadowing things in `/usr/`, `/usr/local`, `~/`, plus `/opt/package` can be very complicated. You can't mix libraries compiled against different versions of dependencies in C++, or really C for that matter, although the conventions in C make it less of an issue. It's why so many projects "vendor" packages into the build rather than using system packages. It's not just not wanting to use the older system supplied version.
There going to be a help because they're going to force a lot of these issues to get addressed. Modules themselves are not at all a packaging solution, nor are they intended to be. Even distribution of compiled module artifacts has issues and controversy. Fortunately the stakeholders are working together in SG15.
Ugh. This jwakely guy has the worst ideas. That's why I'm posting anonymously.
I wasn't in the room, but have been working in SG15 for months. I kicked the tires and made a bunch of suggestions on /u/vector_of_bool 's pitchfork layout. My feeling is that a lot of layout proposals work for "large" projects of dozens of files. I have medium sized projects at work with thousands of files, and it's not clear how you move from one to the other. There's also cost borne by tool vendors to make it work transparently, which would be the point of specifying it, which would have to be _in addition_ to the cost of a more general solution. That all said, if we can get traction for a set of project conventions like layout, getting tool vendors to adopt it organically is more likely. I personally think standardizing project descriptions in a way that makes integration and reuse easier will get us more bang. `pkg-config` only for build, not consume.
&gt; std::find(ilist, ObjectToFind); in C++20. That seems fine. Exactly. There are two radically different communities of users: one which manages existing projects with existing weird layouts and build systems. This is not the community that needs help and guidance with a recommended standard layout that can help you start a small/medium project with little to no custom configuration. This is where the second community of users comes in: users starting new projects, users without pre-existing experience in any of the numerous existing build systems, users who wish they could just start writing some C++ without having to figure out the last few decades' worth of problems and solutions. Having a recommended standard layout isn't meant to force everyone with existing projects to standardize towards that build layout. It is meant to give guidance and help the tool ecosystem help their users get a new setup without any headaches.
Migrating everyone, whereever to, should be a non goal. My personal goal is to make it easy for people to use lots of open source libraries very easily in a way that result in correct, reproductible programs that don't crumble over time. That alone is ambitious enough that we may never get there even if we already have good approximations.
I was also surprised at the lack of screenshots. Looking forward to finding time to play around with this for point cloud data though.
Where might I go to be able to keep track of developments in this area? I know it's going to be another two years, but I want to follow along with those particular developments, if possible.
That is the exact point I wanted to make.
That would be enough to make me happy. I only threw in a few standard controls to have some capability for modelling system-native controls, but to be perfectly honest I don't even think we need those anymore.
All forms of communication have their place and it looks like C++ WGs encourage use of most. I'm involved in standardisation processes for mobile network technologies. They might coordinate 20+ working groups for a release with some WGs similar in size to the whole of C++. They deliver a release quickly and reliably every 18 months or so across these WGs. Some considerations I've seen work well * Overlap requirements, architecture and implementation work (stage 1/2/3) so a group may be working on three releases at a time. * In C++, requirements seem to pop up and vie for attention throughout the first 2 years of a 3 year cycle. Managing them via the three stage approach with say a year per stage on average, gives a bit more focus and smaller releases. A release a year? Still a 3 year release lifecycle * There might be advantages in not actually doing working group work itself at the plenary. * Encouraging separate working group meetings whether face to face, virtual conferencing, short calls, emails etc. The point is that each group can adapt a little more and not require the full complement of 200+ interested parties in the building.
Everything new in the standard is there because someone thought it important enough to do a lot of hard and time consuming work. It's an almost entirely individual and volunteer effort, even for those people who are supported by their company. Ideas that "The Committee" should focus on X, and then X would happen faster, misunderstand how the project works. The committee doesn't direct efforts, although the committee has recently started identified areas they would like to see work done. The committee basically invites people to do work, by submitting papers, and discussing them. And, at least in my opinion, the things that were pushed to 23+, like Contracts, Executors, and Networking, did not suffer from a lack of people working on them, or a lack of attention by the committee. They are difficult technical topics that will involve tradeoffs in design and implementation, and it simply takes time to get that to a local optimum. Particularly where we would like the library and language to maintain coherency, so considerations about how each change affects the whole, and how each piece should use the rest, takes time.
I am going to present a third solution in my CppCon talk. You'll just have to wait until then. :)
I was rereading the section on shared pointers in Effective Modern C++, where there is an example of CRTP: enable\_shared\_from\_this. It's one of those things I vaguely knew existed, but beyond that... and it didn't help that the Wikipedia page is full of references to F-bound polymorphism and God knows what else. So, bring in my go-to source for explaining C++ exoticisms...
All the implementation has to do is to start an HTTP server on localhost and tell the desktop to point a browser at it. This seems fairly reasonable to me. But it's a significant amount of boiler plate to do it in eg Beast plus the platform dependent aspect. The way I've come to look at it is that the web app is the modern platform independent UI in the way the 3 standard streams were in the 80s and 90s. And remember that they weren't ever truly platform independent - Unix systems sure, but not native desktops like Be, and not current mobile or tablet OSes. Even Windows had issues with console apps - `system("pause") `? Whereas any platform that can run a text editor let alone an IDE has a web browser.
Hunter will die and more people switch to vcpkg
Code with non-monospace white font on a light blue background? Count me in!
Looking forward to it ! I will also explore a few things in mine. Exciting times !
I fear that even more. We hope to hit the ground running by deciding on what to not relitigate, what the full scope of supported use cases is, and what cases we are ok with focusing on to get a c++23 deliverable. Just getting everyone talking a consistent language will also be an early hurdle.
Another example of why software development is a job not a profession.
Not that unusual given decent on-the-fly error reporting, for example Qt Creator with the Clang code model. It’s almost as good as compiling for real continuously.
I really would like a way to have a portable std::shuffle, as in if I seed a generator with a specific seed I will always get the same shuffle regardless of the compiler or platform. Currently the generator will return the same sequence of random values, but the uniform random integer algorithm is implementation defined.
Hunter has been around and working for longer than vcpkg. Also, its not controlled by a big corporation, which IMO is both a benefit (free community, no conflict of interest) and a negative (bigcorps have deep pockets for maintenance). So, I hope hunter wins out :)
If you reduced the proposal to a simple constexpr generator of scatter gather buffer lists, with the "ones to be inserted later" marked with their identifier, I think you'd get it through. It would be a valuable building block lots of other stuff e.g Networking, Ranges, LLFIO could build on top of agnostically.
Wow, someone gave me silver, never been given a coin on reddit before :D Thanks anonymous benefactor
Yes, it's fixed. We're stuck with the union, for ABI compatibility though.
I won't pretend I'm a complier writer. All I know is that is what we were told by the best experts there are.
I'm still making my way home jet lagged so my brain barely works, but with the exception of initializer list, those are all things hard or impossible to get rid of. Granted you'd want to have all abstractions with zero overhead, but tradeoffs... If C has it, there's room for another language underneath. If Rust can do it, it's worth considering why we can't. But honestly this stuff is hard and everyone's trying to do the right thing.