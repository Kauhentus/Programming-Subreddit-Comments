cl /EHsc p.cpp where p.cpp is e.g.: #include &lt;iostream&gt; int main() { std::cout &lt;&lt; "Hi" &lt;&lt; std::endl; return EXIT_SUCCESS; } cl /EHsc p.cpp also works, but gives C4530. Everyone should only compile with /EHsc (C++/CLI users are no-one to me :-)) It is more probable that you have a bug in your code than that this didn't work.
Correct me if I'm wrong, but isn't this very C-ish? void next_round(unsigned&amp; game_round) { ++game_round; std::cout &lt;&lt; "Round " &lt;&lt; game_round &lt;&lt; ":\n"; }
Neither references nor std::cout exist in C...
It's a really interesting time for modern C++ template metaprogramming. Three years ago, I would have avoided almost all metaprogramming in a production project, because of the numerous perceived footguns. Three years later, we've seen a lot of generic code, and we know better, clearer ways to do things, and we know how to debug these things. h/t also to clang for having better error messages.
Take a look at Bjarne Stroustrup's Programming -- Principles and Practice Using C++ (Second Edition) http://stroustrup.com/Programming/ This is a book by creator of C++, and it is used from introductory programming classes. Another option is Think like a programmer by V Anton Spraul https://www.nostarch.com/thinklikeaprogrammer That actually uses C++ from the start as well as introducing you to programming.
So like this? unsigned int next_round(unsigned int game_round) { ++game_round; std::cout &lt;&lt; "Round " &lt;&lt; game_round &lt;&lt; ":\n"; return game_round; } This looks worse in my opinion.
That looks a lot better to me, plus it will lead to less bugs.
But if you do that the std::cout would print the old number unless you do also + 1 inside the cout line. This makes the code even more unreadable for beginners I think. Not that passing a reference is easy to understand for beginners now I think about it...
It's like people are looking for counter-examples in the wrong places. I'm just trying to say: Please return the value when you change it instead of passing a reference/pointer to a void function.
I agree that this causes less bugs. And after thinking about it passing a reference as a argument might also be to hard for beginners at this stage.
It's great! Especially when you mentioned auto before explicit types.
Please replace this: &gt; On Windows, I recommend using Microsoftâ€™s free Visual C++ Express for Windows Desktop with the Community Edition! It's orders of magnitude better and also I think Express hasn't been updated in a long time (not 100% sure on that one). In any case, Community is the way to go. I think the tutorial is pretty good! You should continue it. It's quite technical and also the logic and boolean expressions right at the beginning might scare off a lot of beginners, but on the other hand, if you're a CS student (or "above"), you _do_ want something like that and it's really nice :-)
Yes, this part is outdated. &gt; At the time of this writing, the most recent version (which we will of course use) is 2013 Update 3 Thanks for the heads-up! EDIT: [Updated.](https://github.com/Oberon00/cpptutorial/commit/e1ae46d7a18929a86d58e0e99589ad88ac67899e)
It isn't a question of learning C or not learning C, a C++ programmer should know C. It is a question of whether one should learn C *before* learning C++, or should C be introduced after the learner has become familiar with higher level concepts in C++. A big problem is that good C teaches bad C++ habits, especially around RAII, and for the learner, C encourages insecure programming habits (reading user input into fixed size arrays, etc), that can be mitigated with the C++ standard library. If the goal is to learn C++, they should start by learning C++ and pick up C along the way.
You really don't even need to make all that boiler-plate code for move-constructor at any of intermediate steps (and your compiler don't want to resolve all that overloadings and other surplus things). You may pass all parameters by lvalue reference and only at the very end (namely, on list initialization in your case) you may apply `std::forward` to them. See [here](https://github.com/tomilov/variant/blob/master/include/versatile/utility.hpp#L90) an example (the repository contains other illustrations for the above strong assertion in neighbouring files).
Recently there's this very popular idea in programming world, that immutability &gt; mutability. If I was writing tutorial, I would do things as immutable as possible, wherever it's possible. It's not true that `next_round(x)` is better than `x = next_round(x)` in a broad context. It's shorter, yeah, there's less symbols, so it's "more readable". If you write `x = next_round(x)`, every time you use `next_round`, you're a bit repeating yourself. But it enforces immutability, so, according to recent fashion in programming, it's better. 
The library is being used through Java as a native library so I have JVM crash dumps. I am checking for OS AVX support as well. I have followed byte offsets reported in the JVM stack trace and the function being called doesn't have any intrinsic functions. I'm using MSVC v140 so it shouldn't have that issue, I don't think it would affect me anyway
&gt; Recently ;) Yes I'm familiar with the concept of immutability. One of the hardest things when writing this tutorial so far was coming up with good examples, I don't want to claim that I have succeeded every time. Maybe I will rewrite this example with immutability in mind. But just changing the function to use a return value while leaving the `cout` side-effect in just won't cut it. Also I have not used "it is shorter" as an argument.
Thanks! I took the time, and created a PDB and debugged the program. (to my understanding) it crashes because: * I override operator new * My override uses std::cout * operator new is called before main, so maybe something is not initialized I am not sure if it's "OK" to use cout in operator new. Any idea?
There are plenty of ways to skin that particular cat. Another way is I could have just taken all of the arguments in the ctors by value and simply moved them into place (saving vertical space). In either case, the objects are elided into place anyway. It's really just a stylistic choice.
&gt; I didn't mean to be mean. If I was, sorry. Sorry, that ;) is certainly ambiguous. But it was not meant ironically, reading that sentence just made me chuckle a bit. I did not mean to express offense, because none was taken. :) &gt; If cout is just for logging, it's not very relevant to my point. It's meant to be a placeholder for something relevant. Otherwise the reference parameter would really make no sense here. But references are not the topic of this tutorial section, so maybe I can do something about it.
Because C++ can actually do things that higher level languages can't(some APIs are designed for best use with C++, e.g. Direct3D and OpenGL) and even the things they can do, I think a well written C++ program could do it better and generally MUCH faster. I learned the very basics of programming by taking an online course using Java, but once I switched to C++ and thoroughly learned that, I have never even considered going back to Java. If I had known better, I'd have started with C++ in the first place. 
FYI the boost library has tons of material related to metaprogramming,[e.g.](http://www.boost.org/doc/libs/1_61_0/libs/geometry/doc/html/geometry/design.html) The boost library has so much documentation associated with it that it would take a team of several people to edit efficiently. I think that this community could become very useful if someone organized a weekly thing where a particular part of the boost library is highlighted and a blog-type post is made explaining a minimal nontrivial example and then readers would reply with their own minimal nontrivial example that demonstrates roughly the same design pattern.
Not at the call site for sure. Anyway, I'm of the opinion that outputs belong in the return value. 
Creating a `std::shared_ptr` is a expensive only when compared with almost-free things like `std::unique_ptr` - but it's basically nothing when compared with your typical asio/futures/promises/thread system, where you are very likely doing terribly expensive things like context switches or at the very least, invalidating your data pipelines. I rarely use `std::shared_ptr` - over 90% of the time I want to have unique ownership, if only so I know exactly when the destructor goes off. But occasionally you can't get around having multiple ownership of a resource. In those cases I use a `std::shared_ptr` and I just don't worry about it. I can certainly say that I've seen profiles for almost every C++ application I've worked on and never once have `std::shared_ptr`, atomics or any such thing appeared anywhere near the top 20. In particular, I write a lot of C++11 and you can't move into a lambda capture there, so I find myself using shared pointers to get around that. It used to bother me, but I never saw any performance implications ever from it, and now it doesn't bother me.
Oops :D Should have known that given that I work for Microsoft!
For a true five year old, I would say learn Python. There's way too much idiomatic crap that must simply be memorized in C++ to develop at a respectable level. Approaching it with a quick and dirty mindset will end poorly. If you're willing to put the time required to learn, however, it's a fantastic language. I would start with Stroustrup's intro book as another poster recommended.
Good point! That would make the [description of the integer types](http://oberon00.github.io/cpptutorial/proc/types-and-vars.html#integer-numbers) mostly easier. But I see one problem: I can't explain, in terms of the `&lt;cstdint&gt;` types, what the type of a integer literal is.
`future` already models shared ownership. There's no reason to put it into a `shared_ptr`.
What's wrong with the built in types? 
I'm not sure if this is at all related to what you're seeing, but double check that your project isn't built with some unintended instruction set. It'll be in your MSVC project settings: `C/C++ &gt; Code Generation&gt; Enable Enhanced Instruction Set`. Setting that to say, AVX, will allow the compiler to generate AVX instructions for the compiled code. If it sees that it can use some AVX instruction to zero a bunch of stuff, it'll use it. This will be done despite your own CPU detection.
Absolutely, but it won't give any guidance on the language features that weren't available at time of writing.
Correct. From Chapter 13.7 of *The C++ Programming Language 4th Edition*: &gt; [3] Use exceptions for error handling; &gt; [14] Donâ€™t use exceptions where more local control structures will suffice; There are folks that use it as a generalized message passing mechanism, sadly.
Why is that? (I have never written tests before)
&gt; There are folks that use it as a generalized message passing mechanism, sadly. In my experience exceptions are underused, not overused. I'm currently not allowed to throw exceptions into the "main code" (by which my boss means "any code I might see or work on"), so that we have to wrap a lot of idiomatic code in a generalised function call that catches the exceptions and works around this rule that was only introduced after the new team of programmers started to use a more modern style when rewriting 90s software. That has been my experience at three shops now. I've had to work with rules such as * no exceptions * no virtual * no function overloading * all data members public and at some point you have to ask "Why C++?" in such a case. What would "generalised message passing" use look like?
&gt;but im worried c++ will take a lot and not give much back. Rust... The syntax kills me inside but the features are interesting C++ and Rust(I'm still learning them myself, but I love it) will require you to really understand what your program is doing(like Java) but also how it's doing it(unlike Java). I personally would choose C++ over Java whenever possible because it is just so much more flexible in terms of design. The best comparison that I can make between Java and C++ is how they designed their OOP features. Java panders to the OOP crowd but doesn't actually deliver. It forces every file to be exactly one class and every variable and function to be a field or method respectively. Yet despite the so called "pure OO" paradigm it doesn't allow for operator overloading, it treats user defined types differently than primitive types(both of which makes libraries not feel like natural extensions of the base language and can lead to spaghetti code). Java also uses the assignment operator to initialize an object as follows, why? TypeA a = new TypeA(0); C++ on the other hand has most things outside of classes. It allows for multiple inheritance, though you really ought not use it and if possible use composition instead of inheritance altogether. But it's still better to have and not use, than to not have and at some point want to use a feature. &gt;It forces every file to be exactly one class and every variable and function to be a field or method respectively. In C++ a given file can have any number of class declarations and or definitions or none at all, it's your call as to how to write it in an organized manner. Variables and functions can be written anywhere and if they need to be accessed from out of scope then the extern keyword can be used. &gt;Yet despite the so called "pure OO" paradigm it doesn't allow for operator overloading, it treats user defined types differently than primitive types(both of which makes libraries not feel like natural extensions of the base language and can lead to spaghetti code). C++ is easily the gold standard of modern object oriented programming. And it is designed for use in large codebases, using many libraries. It has operator overloading and if they are well written allows for user defined types and objects to be treated exactly the same as those in the standard library. This makes working with good quality third-party libraries incredibly easy. It also means you could reimplement the entire standard library yourself if you wanted to. Finally, this is the same object initatialization in C++ TypeA a(0); And here's the preferred way in C++ 11 and 14(the newest versions): TypeA a{0}; Ah, much cleaner EDIT: C++ does also allow you to use a pointer like this, just don't do it unless there's a reason to and especially not as a beginner. TypeA *a = new TypeA(0); delete a; This will, I believe, allocate resources for an instance of TypeA and then return a pointer to the allocated memory. I then take that and assign it to a pointer of TypeA which I have named a. This will persist until it is manually deleted with a call to delete or when the OS reclaims the memory allocated to your program once it stops executing(manual memory management). In contrast an object initialized with one of the first two methods(not a pointer) will delete itself once it goes out of scope(scope-bound memory management). 
That makes no sense to me. The "no exception" and "no virtual" rules would make sense if you were building for an embedded real-time system. The other two are just counterproductive in all contexts IMHO. &gt; What would "generalised message passing" use look like? Some time ago I did come across an author suggesting the naive desire some of those who are new to the language have, to throw exceptions as a means of quickly returning a value far up the stack, sort of like a goto with a return. He used the term "message passing" to describe the behavior.
Bya Java, C++ here i come!
That's what I wanna hear! \#C++MasterRace
Here's another post in this thread that also points out globbing can be a real problem: https://www.reddit.com/r/cpp/comments/524844/recommend_a_build_system/d7itluo
Thanks for answering my questions. :)
Does the rise of immutability have something to do with lock-free design in concurrency? Or because it leads to more natural syntax just like y=f(x) ?
That's a big "if"
Yeah... maybe its popularity (immutability's) is a consequence of increasing importance of concurrency. 
Everyone and their grandmother has a 101-level tutorial. Do the internet a favor and write a 201 or 301 one.
C++ implementations are allowed to rely on whatever non-standard implementation details they want. That includes the library portion of the implementation depending on details of the language implementation.
Haha :p all good, I can imagine in such a large company, unless you're directly working on or using VS for C++ &amp;&amp; you actually care about these kinds of guidelines &amp;&amp; you actively searched for them, it would be very easy to miss the announcement. I read the VS release notes and I still missed it upon release...
s/cstdint/stdint.h/g
Your diagnosis is incorrect. You will not get an illegal instruction exception unless the CPU would actually retire that instruction.
retire?
Because `cstdint` doesn't really buy you anything. On every implementation under the sun `cstdint` just includes `&lt;stdint.h&gt;`. You have to assume the global namespace is polluted anyway; you might as well save time typing `std::`.
I think immutability is half of the picture, what you really want is referential transparency. Easy concurrency is one benefit, but the biggest benefit of writing in a functional style is composition 
Another possibility for this specific case, though it isn't really any more succinct, is to rely on the fact that you can `return` a void expression. Then you can use RAII to do the post-call wrapper. This doesn't work, though, if you need to log the result of the function. template &lt;class F&gt; auto debug(F f) { struct cleanup { ~cleanup() { std::cout &lt;&lt; "called debug" &lt;&lt; std::endl; } } cleaner; return f(); } **Edit**: of course, yours is more general. 
These are really great. Thanks!
Hmm. Do you have module/DLL load address information from the crash? The only other thing that stand out is that the PC address of the faulting instruction is high for a 32-bit process, up in the range that's usually used by system libraries. Custom DLLs will typically attempt to lower in memory around 0x10000000 unless the default base address is set in linker settings. If you can't get this info, you can try forcing the base address of your DLL to ensure that it has a known address, which will then allow you to directly look up the faulting address in the DLL in your symbols or a test program using the same fixed-address DLL. Without knowing the faulting function and at least some idea of the call stack, you're kind of blind here. 
If the goal is to have a single debug function, this works. You could always handle the two cases separately, i.e., something like: template &lt;class F, typename = typename std::enable_if&lt;!std::is_same&lt;typename std::result_of&lt;F()&gt;::type, void&gt;::value, void&gt;::type&gt; auto debug(F f) { auto r = f(); std::cout &lt;&lt; "called debug" &lt;&lt; std::endl; return r; } template &lt;class F, typename = typename std::enable_if&lt;std::is_same&lt;typename std::result_of&lt;F()&gt;::type, void&gt;::value, void&gt;::type&gt; void debug(F f) { f(); std::cout &lt;&lt; "called debug" &lt;&lt; std::endl; return; } There's an interesting [paper proposing a change in void to a complete type](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0146r0.html) that would fix this issue.
Hmm, it does sound interesting. It does sound like a hassle either way though, for instance what would `std::tuple&lt;void&gt;` or or `std::make_tuple(void())` do? I guess it would be a tuple with that member, but then you can't call `sizeof` on that member...and it seems confusing on how to get a unique address... Or else all generic code is supposed to discard void members, which would not be pretty either. I don't know, it seems a little easier to use another type to signify "empty" -- one with easily valid `sizeof` etc. If there were a standard way of getting a complete type out of `void()` things would be much better--not sure what way would work though... I'm happy in my own code to use an empty object like `hana::nothing`, I just needed a short way of getting it out of `void()`. In more complicated situations than my example, it's very tedious to write out all the checks for a function returning void. I think it might also get better with `constexpr` lambdas; if I can get a parameter-less functor easily inside my procedures, it's not hard to remove `void` then.
Every time I touch `&lt;string&gt;` it's ~15 minutes to build the compiler and libraries and ~45 minutes for the test run.
You meant per translation unit, not per file, I hope. So, you're 100% sure, then, that none of the translation units includes any headers with function definitions? Because if there are **any** duplicate function definitions in the translation units you compile with different SIMD support levels, you **will** have the problem you face. E.g. if there are **any** default constructors/destructors, or any methods defined in the header, etc. TL;DR: If you're compiling different translation units with different SIMD support levels, they must be C, not C++, and each such object file must have a distinct set of exported symbols. Duplicate symbols, even if ordinarily allowed, are not allowed at all in your scenario. This check must be automated and a part of your test suite. 
I am no expert in assembly by any measure but [take a look at this](https://bugs.chromium.org/p/chromium/issues/detail?id=375968#c8) and see if it in any way applies to your problem.
No.
Finally? Finally this set of guidelines has been around for almost exactly a year?
You forgot another important piece of advice: 1. Don't use C++ 2. Pick up botany instead
&gt; Visual C++ &gt; Linux Crazy times we're living in. 
Judging that the vmovss op codes are the only higher level instructions it must be these.
I would even go as far and disagree with you on the point &gt; a C++ programmer should know C. I know C in the sense of that I could probably write a small/medium-sized C-program that compiles with a C compiler only, but it would hardly be good or idiomatic C, I would have no idea how to do things with char*, functions-only, no vector-type, etc... That would be horrible. No, I don't need C to program C++ at all!
Honestly I don't think that using exactly sized types is helping that much, until you have a good idea how to use them. And even then, on the platforms where `uint32_t` and company would be really useful, they do not have to exist, just `uint_least32_t`, which on one hand lets you count, on the other hand doesn't give you the useful guarantees about arithmetics being modulo 2**32. All in all, I think you should just use the usual variable width types and maybe explain that they are variable width.
Because in both places it's invoked `f` is a non-const lvalue &amp;ndash; the `result_of` argument must reflect this.
Crash dumps show that EIP is pointing at vmovss instruction, i.e. it's really trying to execute it. So looks like there is some bug with instruction set detection
My code is structured differently than you suggested. I have a base pure virtual class, each SIMD level then has a child class that inherits from the base class. For the cpp of each child class I set code generation to allow AVX/SSE respectively. The constructors for the child classes are private, but there is a static helper function in the base class that will detect the highest supported SIMD level and return a new object of the child class for that level. FastNoiseSIMD* FastNoiseSIMD::NewFastNoiseSIMD(int seed) { GetSIMDLevel(); #ifdef FN_COMPILE_AVX2 if (s_currentSIMDLevel &gt;= FN_AVX2) return new FastNoiseSIMD_internal::FASTNOISE_SIMD_CLASS(FN_AVX2)(seed); #endif #ifdef FN_COMPILE_SSE41 if (s_currentSIMDLevel &gt;= FN_SSE41) return new FastNoiseSIMD_internal::FASTNOISE_SIMD_CLASS(FN_SSE41)(seed); #endif #ifdef FN_COMPILE_SSE2 if (s_currentSIMDLevel &gt;= FN_SSE2) return new FastNoiseSIMD_internal::FASTNOISE_SIMD_CLASS(FN_SSE2)(seed); #endif #ifdef FN_COMPILE_NO_SIMD_FALLBACK return new FastNoiseSIMD_internal::FASTNOISE_SIMD_CLASS(FN_NO_SIMD_FALLBACK)(seed); #else return nullptr; #endif } 
Are there any problems for non polish speaking people?
Java is indeed quite limited compared to C++. I can't program in Java anymore, it doesn't even have free functions! Eeeek! But there are better examples, for example Python. It has a similar flexibility to C++ (and it has awesome ranges, one thing C++ doesn't really have yet "natively"). Of course, for graphics programming I'd still go for C++. I always would. But a five year old might be better off with Python :-)
omg. I don't even use much fancy features.
Following the thread that I started [here](https://www.reddit.com/r/cpp/comments/524844/recommend_a_build_system/), I've started putting together a repository comparing different C++ Build Systems for exactly the same codebase. The idea being that the only difference between different branches in the repository are the build system being used, and everything else about the project is identical. I've only added CMake, Autotools and Waf so far, and I'm not hugely pleased with the implementation of those three as it is, but they do work. (I'm a bit rusty with these things) Please feel free to improve what I've already done there, and to add new systems to the list as well to compare how they all work.
Yeah I see, although the SIMD level is detected correctly, the game log shows that. So something else is the issue, but I have no idea what. The only place AVX instructions are possible is in the AVX child class, and that would never be called if AVX support wasn't detected. Also the same users can run the preview app for the library which uses the exact same code and compilation settings, but is an exe not a dll.
It **is** a lifetime issue with `std::promise`, not a compiler bug. An excerpt from a SO answer by Anthony Williams, a concurrency subject matter expert: &gt; `std::promise` is just like any other object: you can only access it from one thread at a time. In this case, you are calling `set_value()` and destroying the object from separate threads without sufficient synchronization: nowhere in the spec does it say that set_value will not touch the promise object after making the future ready. The fix is to move the promise into the other thread, so it's lifetime is controlled by that thread. Here is the discussion on stack overflow http://stackoverflow.com/questions/12522928/non-obvious-lifetime-issue-with-stdpromise-and-stdfuture
Maaaybe
I use sfml. I g++ -c * then g++ *.o -o &lt;sfml stuff&gt; then ./sfmlapp every time i want to run code changes. I just followed the tutorial and it made sense to me if i wanted to test the game
CMake, has its warts but does the job and is highly portable.
I personally see Python as being a higher level C++ because they feel so alike in some ways. I think that even in the Python documentation, it says that Python is designed to be similar to C++ and Modula-2. I see this as a good design choice on Guido van Rossum's part. Personally though I always have type problems with Python since I can't see what type things are in the code, it makes it difficult to deal with type mismatches. Other than that though I can't complain about it. I actually want to learn math/stats tools in Python since that is what I think would help me in my career field the most. 
Dump the exported symbols from the object files compiled for different instruction levels. If any exported symbols overlap, you have a problem. The structure of the code is orthogonal to checking whether you have a potential for crashes. You may also need to inspect PIC and other thunks emitted by the compiler, because it's not obvious that they are all binary compatible when different instr. levels are involved.
Cool - I didn't know that was an option. Thank you :)
&gt; If you choose not to use templates in advanced ways, compile times will be about the same as Java. Now that is a "baseless statement".
Ah now I see it. Then that would look like a configuration error to me - the function was called even though the CPU doesnt support the instruction set. Another explanation (as it crashes so rarely) might be a cpu revision that does not support those instruction (I have no idea about AVX extensions and versions) or perhaps an intel vs. amd issue? Alignment issue? I would 1. check the stack where the call to vmoss function comes from. 2. make a list of the CPUs that have this crash and look for common factors in that list.
Well for me C++ is actually pretty high-level as well, at least the way I use it. I never use (or have to use) low-level stuff like pointers, I don't even have to go down to iterators very often. C++ can be beautiful, high-level and safe. Of course, if you're a beginner, with so many old and bad tutorials out there, and people still thinking C is the way to go or that they have to start with C, it makes it very difficult to get to the point of seeing the "high-level beauty" of C++. A lot of people never get there actually and give up at pointers, because they think that's C++.
Is that any different to embedding static libraries inside executables? The original idea of it was simply to show various build systems in action on a more complicated setup to the normal "Hello World" apps that you normally get, rather than to cover every possible use case, but if there are situations that people think are really worth covering then of course they can be added.
ReSharper understands both syntaxes when parsing and completing Doxygen comments, and you can update the template to use '@' instead of '\' when generating documentation comments - so there's no special setting for that. We don't yet support importing .clang-format configs - we might take a look, thanks! Configuring the internal formatter is pretty easy though - you can select a piece of code, Alt+Enter -&gt; Format Selection -&gt; Configure, and ReSharper will show the options that affect formatting inside the selection. These options can also be saved to a file inside the project similar to .clang-format and shared with other team members. 
I myself use snake_case for variables and Bigger_Snake for classes
You may also be interested in [build-shootout](https://github.com/ndmitchell/build-shootout) by the author of Haskell-driven [Shake build system](http://shakebuild.com/). It is not the same, it compares low-level capabilities of build tools on synthetic simple cases, not the build generators on a realistic project like OP does. But still it is very interesting.
IIRC embedding a static library inside an executable doesn't require the static library to be compiled with fPIC, unlike when embedding inside a dynamic library.
Another small thing for CMake : instead of doing target_link_libraries(... ${Boost_UNIT_TEST_FRAMEWORK_LIBRARY}) you can do target_link_libraries(... Boost::unit_test_framework) Same for `Boost::date_time`. It makes it much clearer IMHO
Try to use forward declaration. It will speed up build times.
Many powerful libs are built upon advanced templates. It's hard not to use it.
I agree that this is an rare use case, I wasn't really expecting you to say yes! Unfortunately my pre-parser mangles the whitespace a bit, and incorrectly translates a few things so I am keeping original source for now. I will look into the document action templates, thanks.
Why is this set to true, if no check takes place? Shouldnt it be set to false? https://github.com/Auburns/FastNoiseSIMD/commit/c619b89d51c8fdcd9a2dc18b0366e0ab908c974c
...and then get killed by link times? ;)
I agree with you, modern C++ is as bare or abstract as you choose to make it. The standard library has some very high level capabilities and of course it contains the entire C standard library which you know better than I, is pretty bare metal. I learned C++ by learning the basics in Java and then reading Jumping into C++, Programming Principles and Practice in C++(not all of it, since it's a huge textbook!), and a few other books and online tutorials. TBH I think you just have to check them to make sure they include C++11 and/or 14 or just look it up yourself after. I do still think though that to effectively write C++ you do have to know what pointers and references are and how, when, and why to use them. I think it's better to teach them effectively than to dodge around them because they are a tricky topic. C++ does use pointers for a lot of things and the C subset does so even more. Though I don't necessarily consider pointers to be a "low-level" construct you can think of them in a very abstract way in that they are just a variable that points to the location of another.
Do you plan to reach a point where Resharper replaces Viasual Assist X completely? How do the two compare right now you think? Doxygen is already a big plus.
according to this stack overflow post http://stackoverflow.com/a/7249442 &gt;Option #2: Pass -fno-exceptions. &gt;This flag instructs G++ to do two things: &gt;All exception handling in STL libraries are removed; throws are replaced with abort() calls &gt;Stack unwind data and code is removed. This saves some code space, and may make register allocation marginally easier for the compiler (but I doubt it'll have much performance impact). Notably, however, if an exception is thrown, and the library tries to unwind through -fno-exceptions code, it will abort at that point, as there is no unwind data. What do you mean a false sense of security? If you disable exceptions you simply can't handle exceptions. I don't know how that would make you feel secure or insecure it's just simply how it is.
Makes me want to have Visual Studio on Linux too...
See my thoughts about how two tools compare in the relevant StackOverflow [question](http://stackoverflow.com/questions/35714595/how-are-resharper-c-and-visual-assist-different/37659465#37659465). The summary is that VAX is faster, but R++ has more features and on-the-fly code analysis. We're still working on performance and hope to improve it in future releases.
&gt; But couldn't i achieve the same results by making my variables static (if i were using Java)? Same results as what? There's a number of main differences. First, you have destructors. You've probably seen these in your classes, their name starts with a `~`. Destructors are automatically called when a value does out-of-scope (I'll get to values in a minute). Destructors are awesome because they let you clean up your data. One example is if you have a class with a bunch of pointers in it. The constructor can allocate those pointers, then the destructor should clean them up. Destructors are useful for cleaning up any sort of resources, not just pointers: you can have your destructor close any files you're working with, close network or database connections, save your important data to disk, all sorts of awesome things. Contrast this with Java, where you have to explicitly close files an database connections. Java's try-with-resources alleviates this somewhat, although you can still get into trouble. Second, you have variables. In Java, every variable that isn't a primitive is actually a pointer. Java pointers give you some of the bad of C++ pointers (they can be null and cause your program to crash) without all of the good (you can't do fancy low-level things with Java pointers. This may be a good or bad thing, depending on how you feel about fancy low-level things). In C++ you have pointers, but you also have values and references. Here's a breakdown: Values exist only within the scope block they're declared in (scope block = inside {}). If you do something like `std::string my_string;` then you're declaring a value of type string, and C++ will automatically call the string's no-argument constructor. Then when the scope block ends, C++ will automatically call the string's destructor. Values are allocated on the stack. http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html talks about the stack and the heap, which is definitely worth knowing about if you want to work with C++. That link uses C for its examples, but C and C++ are close enough that everything's still applicable. Values are cool because they're automatically cleaned up by your program. This is kinda similar to how Java has garbage collection, but only from a high-level conceptual standpoint. Java's garbage collection happens whenever it feels like and frees up memory that's no longer used. In C++, values are cleaned up whenever the scope block they're declared in ends - this is a much more immediate and predictable process. However, this can get your into problems. If you have this code: class example { public: example() { pointer = new int[100]; } ~example() { delete [] pointer; } private: int* pointer; std::vector&lt;example&gt; examples; void show_example() { example my_example; examples.push_back(my_example); } }; Then the `my_example` that you added to the vector is no longer valid. It's `pointer` variable has been deleted, so you can no longer use it. This can get you into trouble if you're not careful. Another thing to know about values is that, whenever you assign one value to another (including methods that take values as parameters) the entire value is copied. The C++ runtime literally does a byte-by-byte copy of your value. Sometimes this is what you want, but for complex types it probably isn't, because byte-for-byte copies of large objects can be kinda slow. Enter references. References act like non-primitive variables in Java, except that they can't be null. This is absurdly awesome IMO because nulls are the absolute worst. References are declared with a `&amp;`, like `std::string&amp; my_ref`. A reference is not deallocated at the end of a scope block. Additionally, references take up the space of one word on your computer (32 bits on 32-bit machines, 64 bits on 64-bit machines iirc), which means that functions which take references are a bit faster than references which take values. The syntax for references is the same as the syntax for values - you use `.` to access members. You have to bind a reference to some object when you create the reference - so code like `std::string&amp; my_ref;` won't compile, but something like `std::string str; std::string&amp; my_ref = str;` will. You also have pointers. The use of pointers is discouraged in modern C++, but they're still useful in some cases. Pointers are declared with a `*`, like `std::string* my_ptr`. Pointers are allocated on the heap, which means they're not automatically cleaned up when you end a scope block - you have to manually clean them up yourself (see the code above for an example of this). Pointers take up the same amount of space as references, and thus are exactly as fast to pass around as references. The syntax for pointers is different than the syntax for values or references - you use `-&gt;` to access members. Pointers can be bound to values by doing this: `std::string my_str; std::string* ny_ptr = &amp;my_str;`. I don't know why you use the ampersand here, but you do. Pointers are cool because you can use them to access arbitrary bits of memory. You can add offsets to pointers - like this: int* int_ptr = new int[5]; *int_ptr = 3; // The value of the memory address at int_ptr is set to three int_ptr[1] = 5; // The value of the memory address at (int_ptr + 1 * sizeof(int)) is set to five 2[int_ptr] = 7; // The value of the memory address at (int_ptr + 2 * sizeof(int)) is set to seven. This is strange syntax that no one I know uses int_ptr[100] = 20; // Not a compile error, and not a runtime error either. This is perfectly valid C++! You can have a lot of fun doing this because you can see whatever happens to be in your RAM With great power comes great responsibility. Pointers can do some really cool stuff, but the can also lead to lots of crashes and security issues. The advice in modern C++ is to not use them unless you absolutely have to. Thanks to C++11's smart pointers, you almost never have to use them. There's a couple more things, like functions outside of a class, but that should be enough for now and I have to get to work.
You misunderstand my point. /u/MengerianMango stated that if you don't you templates ("in advanced ways"), then compilation speed is on-par with java. This is what I'm disputing.
I think the different build systems should not be on different branches. Instead, there should be a separate folder for each build system and they should reference the single src folder.
I assume Visual Studio would allow you to step through using its debugger, right?
How much do we need to know before we can be said to "know"? For the C++ learner, I had in mind something a little below what you describe as your skill level in C, (which is also how I would describe my own knowledge of C). That knowledge would be gained by lessons that that, e.g. explored how to implement the standard containers and algorithms they've been using up to that point, or tours through the C part of the C++ standard library, etc. I don't think an expert C++ developer needs to be an expert C developer. But, there shouldn't be very many times where idiomatic C code surprises a C++ expert. 
You can still use cmake + clang. It's an IDE with debugging support. I've been using it for small stuff, just to try it out. It's pretty good.
I'm using visual studio at work (since vs6 upto vs14) and for my personal projects I use clang\gcc with myriad of IDEs, I have a love\hate relationship with VS but for huge projects you just can't compete with it. 
By a false sense of security, I meant that some tool chains would let you turn exceptions off even though standard library could throw. So you think there's no exceptions, but it's actually false. This is in fact common when you combine libraries: you can link with a lib that has been linked with exceptions, and will throw,but your code is built without support for exceptions. **Bad idea.** Same with the stdlib, by the way... You have to build it in a different way, exactly as the gcc doc (linked in the SO article) say: [libstdc++ files **can be compiled**, emphasis mine, with -fno-exceptions](https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_exceptions.html). You can't just pass the flag when compiling **your code**, which seems to be your belief? But even then... is the quality of the resulting code the same when any thrown exception just aborts, compared to, well, code with exception handling?
I definitely agree with you. You can't say you are proficient in C++ without knowing pointers, let alone references. I just think pointers in particular should be taught a lot later than they usually are. Kate's CppCon talk sums it up so well, it's brilliant.
Thanks for your reply! Hope to see .clang-format support in the future :-) Any update on debug step filter? I once saw a ticket about it in your bugtracker but there was no progress on it. This is a big feature of VAX. I wonder that not more people are annoyed of stepping into all these string, vector etc c'tors every time you press F11 to for example step into a function that has a few vector/string/... types as arguments.
Our test runs take a long time because we are exhaustive and do a lot of code generation. For example, we instantiate every STL algorithm with every possible iterator power plus a few special cases. And we do that crossed with ~15 different sets of compiler switches, to make sure the standard library works in release / debug / with various compiler switches. C++ builds are slower than Java's builds for 3 reasons: 1. Java doesn't do all the work. The C++ compiler does backend code generation for you as part of the compilation step; Java does this at runtime (in the JVM). 2. C++'s separate translation model forces headers to be reparsed over and over again. Compiler vendors are working on defining some kind of modules system to fix that problem. 3. C++ templates generate purpose-specific code for each T; whereas Java uses one piece of code for all reference types for its generics. Its a consequence of making essentially everything require memory allocation in Java. (Those 3 points also apply to C#)
My guess is that the MSVC compiler, associated libraries, and tests far exceed 3 million lines. As for you 10k lines, you should be fine. It may take a couple seconds per compile, but nothing prohibitive. Since you are using the SFML engine though, I would recommend looking into precompiled headers if you find compilation to be taking too long.
It depends on the kind of applications you make. The basic issue is that it's a cost that do not scale well. If you are doing intensive work and regularly pass through these allocations, you are just killing your runtime performance. But as you say, it's not always obvious. The current code I have to work with at dayjob have too many shared_ptr but still manage to not make the software unusable. It still lost half it's performance compared to an older version of the codebase that didn't use it much (that and std::maps and overabusing mutexes). Anyway yeah, I said that because it's an easy solution that work, but you have to know what you are paying exactly. An allocation is still one of the most expensive operation on all platforms and I'm just considering that.
Fair enough. I'll try and get a new version up with different code - covering points made elsewhere - and all in one branch. Would people prefer to have one source tree and parallel build systems? Or a copy of the source tree per build system? The copy per build system would mean that the layout could differ between them if that makes more sense - as I'm sure it will in some cases - but means that changes to the source code are more difficult to manage. I'm not too concerned about that though as the source code is actually not the important part here...
To me this problem looks like stack corruption which then causes a jump to a wrong place in course of returning from function.
We just had a new update, well a few weeks ago, but I just got docs for it posted. We have a makefile project now and I've posted some scripts that while not perfect show how our projects can be generated from existing source bases. https://github.com/robotdad/vclinux 
You might want to take a look at these scripts I put together to generate our makefile project template. They almost certainly won't work for something big and convoluted but hopefully they serve as a guide you could use to write a script that could handle your sources. https://github.com/robotdad/vclinux
Here's everything I know: Code: #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;string&gt; // replace operator new and delete to log allocations void* operator new(std::size_t n) { std::cout &lt;&lt; "Allocating " &lt;&lt; n &lt;&lt; " bytes" &lt;&lt; std::endl; return malloc(n); } void operator delete(void* p) throw() { free(p); } int main() { std::string s; for (size_t i = 0; i != 1000000; ++i) { s += '.'; } } Command line to compile (using MSVC 2015 Update 3): cl /EHsc /Zi /Fd:main.pdb main.cpp Compiler output: Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24213.1 for x86 Copyright (C) Microsoft Corporation. All rights reserved. main.cpp Microsoft (R) Incremental Linker Version 14.00.24213.1 Copyright (C) Microsoft Corporation. All rights reserved. /out:main.exe /debug main.obj Callstack: main.exe!std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt; &amp; _Ostr, const char * _Val) Line 785 C++ main.exe!operator new(unsigned int n) Line 7 C++ main.exe!std::basic_streambuf&lt;char,std::char_traits&lt;char&gt; &gt;::basic_streambuf&lt;char,std::char_traits&lt;char&gt; &gt;() Line 26 C++ main.exe!std::`dynamic initializer for 'fout''() Line 12 C++ main.exe!_initterm(void(*)() * first, void(*)() * last) Line 16 C++ main.exe!__scrt_common_main_seh() Line 221 C++ kernel32.dll!76f838f4() Unknown [Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll] ntdll.dll!77bc5de3() Unknown ntdll.dll!77bc5dae() Unknown Error: Unhandled exception at 0x00C6B41F in main.exe: 0xC0000005: Access violation reading location 0x00000004. I'm flying to CppCon tomorrow so I won't be able to debug this further until I'm back, so hopefully this will do :)
Several of the people in charge of the Google style guide have publicly said that it isn't really appropriate for new code and if they were to do it again now the style guide would look very different. The only reason it looks the way it does today is to ensure that their massive legacy code base stays consistent.
I've worked on some "convention over configuration" project some time ago, so I could bootstrap any C/C++ project quickly with CMake, and only having to worry about C/C++ source. I cleaned it a bit and published here: https://github.com/berenm/CMakeBuildPackage for curious people. Obviously many third-party libraries won't fit very well the requirements, so dependency management may still be a bit messy...
Sorry, no progress on that yet. The issue is [here](https://youtrack.jetbrains.com/issue/RSCPP-13896), please vote for it if you haven't already to receive updates and help us better prioritize new features. As a poor man's substitute for debug step filter, you could use the builtin Debug.StepIntoSpecific Visual Studio command. It's bound by default to Shift+Alt+F11, but I believe the default keyboard scheme in ReSharper redefines this shortcut, so you'll have to bind it manually in VS keyboard options. When used, it will show a pop-up menu with functions you can step into.
Whitesmiths plus Monaco, the Comic Sans of monospace fonts &amp;ndash; good god... ;-]
I had a similar opinion until VS 2008. Then they decided to re-write the UI in C# and the thing became as slow as Eclipse. Shame really. I really wish they kept the UI truly native. But the bar is so slow now (pretty much all major IDEs written in non-native languages especially Java ) I don't see them having the incentive to produce an IDE as snappy as VS2008 
I have used both 2013 and 2015. They are slow. The compiler and debuggers are fine. I just don't like their choice of the UI toolkit.
It's awesome that this is possible. It is horrible if you actually use it. Please don't turn fatal programmer errors into non-fatal exceptions. It significantly reduces the ability to debug programs. It also pokes holes in a lot of security mitigations.
If FMA3 isn't enabled it shouldn't stop using AVX2 just because FMA3 isn't supported.
This should be the dll for the first crash dump, possibly not the second. https://dl.dropboxusercontent.com/u/47692480/StarMadeNative.zip Thanks.
I'm checking for OS AVX support too
&gt; I am checking for OS and CPU AVX support Yes. So were they. And like you they were checking for `osxsave` and `avx` before using `xgetbv` and it wasn't enough. They had to include a seemingly redundant check for `xsave` as well. I know it may not correlate with what is observed in the crash dump but it might be something worth checking for . You could define something like: bool cpuXsaveSuport = (cpuInfo[2] &amp; 1 &lt;&lt; 26) != 0; Then in `int GetFastestSIMD()`, change: if (osAVXSuport &amp;&amp; cpuAVXSuport) to if (osAVXSuport &amp;&amp; cpuAVXSuport &amp;&amp; cpuXsaveSuport) and see if the bug is reproducible just to eliminate that as a potential issue. Just a shot in the dark.
Next to none used to do a little a few years back. Okay sounds about what I want thanks for the info.
The null pointer part won't work if you try to access a struct member that isn't right at the beginning.
[Buckys C++ Turorials ](https://m.youtube.com/playlist?list=PL96ED5F4FC5EA8F7D) helped me a ton when I started learning C++. He does a great job explaining in simple terms. 
I feel as though Java programmers and even PHP/Ruby scripters make more than me.
You're absolutely right. I was talking about total build time
Well then I must be miss-remembering what I read in Stroustrup, because I could have swore that he explicitly stated that every valid C program would compile in a compliant C++ compiler.
Check out the beginner recommendations here: http://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
That's an interesting perspective, and I can see some benefit to looking at exceptions that way. How do you think that applies with something like a library, when you, as the library author, don't know if there is a plan to recover?
I haven't read the updated version, but the original was god-awful. Full of bad ideas and vague misunderstandings. A good book on any topic probably won't select "dummies" as their target market.
s_currentSIMDLevel is a static data member so it will be zero initialized. Only way I can see it getting corrupted is if some other code manages to write into it.
The "* for Dummys" books suck if you want to not suck at something. 
Just so I'm not a negative nancy, my recommendation is Andrew Koenig and Barbara Moo's "Accelerated C++". Note: Koenig's office at Bell Labs was across from Stroustrup's, so the legend goes. 
I was able to track down a copy of StarMadeNative.dll and match the disassembly against the source code. Long story short, all of your initialization paths are executing AVX code and it's a miracle you aren't getting more crash reports. Taking the version: http://files.star-made.org/build/dev/starmade-build_20160913_133133/native/windows/ Here is your offending code, commented. It turns out to be the constructor for the FastNoiseSIMD base class. ;m_frequency = 0.01f; 10006180: C5 FA 10 05 1C F4 vmovss xmm0,dword ptr ds:[1006F41Ch] 06 10 10006188: C5 FA 11 41 08 vmovss dword ptr [ecx+8],xmm0 ;m_xScale = 1.0f; 1000618D: C5 FA 10 05 24 F4 vmovss xmm0,dword ptr ds:[1006F424h] 06 10 10006195: C5 FA 11 41 10 vmovss dword ptr [ecx+10h],xmm0 ;m_yScale = 1.0f; 1000619A: C5 FA 11 41 14 vmovss dword ptr [ecx+14h],xmm0 ;m_zScale = 1.0f; 1000619F: C5 FA 11 41 18 vmovss dword ptr [ecx+18h],xmm0 ;m_lacunarity = 2.0f; 100061A4: C5 FA 10 05 2C F4 vmovss xmm0,dword ptr ds:[1006F42Ch] 06 10 100061AC: C5 FA 11 41 20 vmovss dword ptr [ecx+20h],xmm0 100061B1: C5 FA 10 05 20 F4 vmovss xmm0,dword ptr ds:[1006F420h] 06 10 ;this-&gt;__vtbl = 'vftable for FastNoiseSIMD' 100061B9: C7 01 F0 F2 06 10 mov dword ptr [ecx],1006F2F0h 100061BF: 8B C1 mov eax,ecx ;m_seed = 1337; 100061C1: C7 41 04 39 05 00 mov dword ptr [ecx+4],539h 00 ;m_noiseType = SimplexFractal; 100061C8: C7 41 0C 05 00 00 mov dword ptr [ecx+0Ch],5 00 ;m_octaves = 3; 100061CF: C7 41 1C 03 00 00 mov dword ptr [ecx+1Ch],3 00 ;m_gain = 0.5f; 100061D6: C5 FA 11 41 24 vmovss dword ptr [ecx+24h],xmm0 ;m_fractalType = FBM; 100061DB: C7 41 28 00 00 00 mov dword ptr [ecx+28h],0 00 ;m_cellularDistanceFunction = Euclidean; 100061E2: C7 41 2C 00 00 00 mov dword ptr [ecx+2Ch],0 00 ;m_cellularReturnType = Distance; 100061E9: C7 41 30 01 00 00 mov dword ptr [ecx+30h],1 00 100061F0: C3 ret As for why it is getting called... unfortunately, the constructors for your optimization level tiered subclasses have all been inlined into the NewFastNoiseSIMD() function, which apparently was compiled with AVX enabled. Here's an excerpt from the disassembly: ;jump if s_currentSIMDLevel &lt; 3 (FN_AVX2) 1000137C: 83 F8 03 cmp eax,3 1000137F: 7C 18 jl 10001399 ;call operator new() 10001381: E8 3E 03 05 00 call 100516C4 10001386: 83 C4 04 add esp,4 10001389: 89 45 FC mov dword ptr [ebp-4],eax 1000138C: 8B C8 mov ecx,eax 1000138E: 56 push esi ;call FastNoiseSIMD::FastNoiseSIMD() + FastNoiseSIMD_AVX2::FastNoiseSIMD_AVX2() 1000138F: E8 5C 4D 00 00 call 100060F0 ... ;jump if s_currentSIMDLevel &lt; 2 (FN_SSE41) 10001399: 83 F8 02 cmp eax,2 1000139C: 7C 31 jl 100013CF ;call operator new() 1000139E: E8 21 03 05 00 call 100516C4 100013A3: 83 C4 04 add esp,4 100013A6: 8B C8 mov ecx,eax 100013A8: 89 4D FC mov dword ptr [ebp-4],ecx ;call FastNoiseSIMD::FastNoiseSIMD() 100013AB: E8 D0 4D 00 00 call 10006180 ;set __vtbl to `vftable for FastNoiseSIMD_SSE41' 100013B0: C7 01 D4 F3 06 10 mov dword ptr [ecx],1006F3D4h 100013B6: 89 71 04 mov dword ptr [ecx+4],esi ;call FastNoiseSIMD_SSE41::FastNoiseSIMD_SSE41() 100013B9: E8 52 A4 03 00 call 1003B810 ;s_currentSIMDLevel = 2 100013BE: C7 05 E0 27 07 10 mov dword ptr ds:[100727E0h],2 02 00 00 00 ... ;jump if s_currentSIMDLevel &lt; 1 (FN_SSE2) 100013CF: 83 F8 01 cmp eax,1 100013D2: 7C 31 jl 10001405 ;call operator new() 100013D4: E8 EB 02 05 00 call 100516C4 100013D9: 83 C4 04 add esp,4 100013DC: 8B C8 mov ecx,eax 100013DE: 89 4D FC mov dword ptr [ebp-4],ecx ;call FastNoiseSIMD::FastNoiseSIMD() 100013E1: E8 9A 4D 00 00 call 10006180 ;set __vtbl to `vftable for FastNoiseSIMD_SSE2' 100013E6: C7 01 88 F3 06 10 mov dword ptr [ecx],1006F388h 100013EC: 89 71 04 mov dword ptr [ecx+4],esi ;call FastNoiseSIMD_SSE2::FastNoiseSIMD_SSE2() 100013EF: E8 2C 4C 02 00 call 10026020 ;s_currentSIMDLevel = 1 100013F4: C7 05 E0 27 07 10 mov dword ptr ds:[100727E0h],1 01 00 00 00 All three of your vectorized code paths are calling versions of FastNoiseSIMD() that are built with AVX due to inlining. You need to block this if possible. __declspec(noinline) might do the trick, but there's no guarantee that it will force the code generator to partition the code generation as desired. This is the reason that I discourage mixing compilands with different compile flags being linked into the same EXE or DLL; you have no guarantee that inlining and linker optimizations won't blend code undesirably across the boundaries. 
Nice catch!
I gave an answer on programmers stackexchange once kind of like this: http://programmers.stackexchange.com/questions/306703/opengl-multithreading-and-throwing-destructors/306723#306723 I had this scenario in mind when I wrote my comment above. I think, with a library, how you should signal errors is partly a taste question. A lot of libraries will provide both an exception and exception-free interface for when various ancillary operations may fail, to accommodate all the different projects. IMO it's okay for a library to assert if the program is FUBAR, undefined behavior would ensue, etc. Suppose for instance, you had a bunch of free functions as part of your library interface, and it needs to be initialized by calling a specific function. That function initializes some static singleton that's part of your lib. In C++ you'd rather make the lib an object and all the calls be methods, but maybe it really conceptually needs to be a singleton, like you are interfacing with the system at a low-level and there can only be one of the thing you are talking to. If the user uses functions without initializing them, or tries to double initialize or something, what should happen? Should it throw an exception? Why? In what scenario would the user catch the exception and handle it? Realistically, none -- they would realize that they screwed up and weren't properly using the library, and fix their code so that it doesn't do that. If the lib asserts when it is double initialized, then you get a clear and immediate signal that double initializing it is bad and unrecoverable. If the lib starts throwing a `lib::initialization_exception` or some such thing, my first thought as a programmer is, oh what the heck is that? Am I using the lib wrong? Am I supposed to always be catching initialization exception? What does it mean? What is the proper reaction to this? When a lib asserts, in my mind, it's more clear cut that, I'm not supposed to be "handling" this scenario, we are just not normally ever supposed to get to this place. I think it's just a better cue that may help people figure out what to do faster. My 2 cents. (You could also just leak or give them UB if they double initialize... but typically it shouldn't cost anything really to do this check...) Another thing I would suggest is to use Rust style idioms like Result type in a C++ library. This is also pretty similar to the `std::expected` proposal (which wasn't actually accepted into C++17 yet afaik). This is an exception-free but still fairly idiomatic way of reporting structured errors in C++. It's better than C-style error codes, basically instead of returning a type `T` you return something that's kind of like a variant over `T` or `ErrorStructure`. (Usually that type is called `Expected`.) The exact properties of `ErrorStructure` can be customized for your lib, I mean it basically contains the information that the exception would have contained. I wrote about this also on programmers.stackexchange here: http://programmers.stackexchange.com/questions/324313/idiomatic-usage-of-exceptions-in-c/324909#324909 Edit: I read another answer: &gt; I think instead of throwing exceptions that say "there's a bug in your code", you should fix the bug. What I'm saying above is pretty similar, but slightly different: Instead of the library throwing an exception saying "there's a major bug in your code", it should just assert.
The spec days that set_value makes the shared state ready atomically. In my interpretation of atomic this means that the whole of set_state is indivisible, i.e., the mutex is held for the whole duration of set_value and future isn't unblocked until after the mutex has been released. After the mutex has been released, the method is done with the object. With such implementation, there'd be no lifetime issue. 
&gt; dynamic_cast&lt;&gt; has it's place, but should usually be avoided. Exactly. That's the case for most of C++'s features. They're silly and add needless complexity and will let inexperienced devs shoot themselves in the foot ...... until you need them. The only instances of dynamic_cast in my entire codebase (300,000 lines) shows up in a GUI library. Not having it there would have resulted in me making my own ad-hoc version of it out of absolute necessity. After more than a decade of saying, "who would *ever* use this feature?", only to find myself using said feature in the distant future, I've stopped saying that. Right now the big one I've never found a use case for was virtual inheritance to avoid the diamond problem. But I'm not going to claim it shouldn't be in the language. I'm sure someone is getting great mileage out of it somewhere.
4 minute video on do while loop. This clearly is the best use of time.
I've recently released a game with ~20k lines of C++ and I have a very dense style (I like to fit as much as possible to a sinhle screen) so it'd probably be above 50k in more common styles.The code has a lot of template metaprogramming and all other kinds of C++ abuse. A full rebuild takes 2-3 minutes, but a typical edit-compile-run cycle takes 5-6 seconds thanks to a very careful organisation of includes.
&gt; Today we are incredibly excited Is it even physically possible to write an announcement without pissing yourself in excitement at the very first sentence 
Those are actually terrible. 
Thanks for the correction, and the example--that's really good to know. I edited the post to fix my mistake / credited your comment, and will try to be more careful about blaming gcc for parts of the standard that don't behave as I want them to. :-)
Is it same for GCC and Clang?
Those graphs are completely unreadable on safari mobile for me. They're cut off before any of the values are visible. 
Does anybody have comparisons with the Intel Compiler? Itâ€™s mentioned once in the comments but also without any data. I am a bit hesitant to download the full Phoronix Test Suite just to try it out with icc, but if there was a decently short example, it should be possible to produce some data for me.
Thank you for taking the time to look into this. I double checked FastNoiseSIMD.cpp (containing NewFastNoiseSIMD()) is explicitly set to no enhanced instruction sets. As for solving the issue I'm thinking disabling [Whole Program Optimisation](https://msdn.microsoft.com/en-us/library/0zza0de8.aspx?f=255&amp;MSPPError=-2147217396) on all the sub classes, this would make the compile before link time and stop any cross object inlining. What tool did you use to disassemble the binary btw, I tried to do what you have done but didn't manage to figure it out.
clang BTFO AGAIN!
Does this work?: constexpr auto str[] = L" ... ";
I don't understand, why is he testing gcc 7 but not clang/llvm SVN? Also I am more interested in which area gcc performs better than llvm, in terms of code generation, what is missing in llvm? A side-by-side comparision of the generated code would be nice. A benchmark without proper analysis is seriously useless IMO.
Nice thanks.
&gt; I think that if safe, effective pointer use habits are taught early on then it'll lead to programmers writing less unsafe code. It also leads to a lot of students being overwhelmed and switching to other languages and then thinking the whole rest of their lives that C++ is "C with classes" and/or mainly about pointers. Of course, that mainly depends on the teacher as well...
oh...thats true to the very core of it.
You can horizontally scroll each graph individually.
I always thought clang would be significantly faster than gcc at compiling, but that doesn't seem to be the case.
This was only done to see how it works. Sure it needs some work to be "production ready". Other languages like D and Ada have this built in (at least the division by zero case). Only C++ needs to have this as "undefined behavior".
I wonder if there's a list of undefined behaviors in the standard. I know that the committee works on reducing the number of undefined behaviors. I choose only null pointer and divizion by zero, how are they harmful? The rest can be forwarded to std::abort and before that use some other OS technique to gather the backtrace.
It used to be quite a bit faster but as they've added features and optimizations to try and close the gap with GCC that difference has basically vanished.
Seconded on the analysis and side-by-side. As for LLVM trunk, 3.9 was released pretty recently (Sep 2) so it's unlikely too much as changed since then or even since 3.9 was branched off for testing. So maybe it's a more reasonable comparison that it seems.
&gt; Did they really write their own async library? I weep at the thought. They use libevent according to their dependencies. They must have wrap it in some way (gonna take a look at that). 
Well, these are optimized builds. I'd be much more interested in comparing debug build speed, since that affects my productivity way more.
Have you looked at Beast ? 
Questions are welcome. Especially if you think that this test file is not enough to document the library. 
&gt; Have you looked at Beast ? I haven't - do you have a link? A quick Google isn't turning up anything obvious. Boost is a beast, for sure. But very useful. :-) 
Your dealing with SEGFAULT is for all segfaults, not only when dereferencing 0. Windows implementation looks like it should work (didn't see that before), unless an optimizing compiler screws you. Also, there's platforms without virtual memory, where you can't do these tricks at all. But quite frankly, the most eggregious mistake this makes is that it tries to continue from what is normally a bug in C++. And in fact, an NRE is normally a bug in every language. This is simply too smart for its own good, really.
I think that C++ is a good first language to learn and you'll learn a lot from using it. That said modern C and modern C++ appear to be very different languages. It's considered a bad habit to write idiomatic C in C++. C++ is not just C with classes and it hasn't been for a long time. It is a separate programming language, so if they are teaching C++, learn C++. Learning C at the same time will only serve to confuse you. 
"Perhaps" incorrect interpretation. Well, this seems to be an issue that has to be clarified by the committee. How can I direct such request for clarification to the committee? I'd say that your mutex analogy does not hold water because gcc implementation shows that it is possible to code the "stronger" expectation of atomicity. You can't do this with a mutex.
My understanding is it's always had better error messages, especially for templates.
It is other way around - [link](https://llvm.org/bugs/show_bug.cgi?id=29160)
Yes
The goal of this parser is to be simpler and shorter to use. In only one C++ call it provides as much features as you can find in boost option. Plus it checks for missing or invalid arguments. 
Not exactly. Clang spent a lot of time writing good error messages for things that trip up newcomers. A moderately experienced programmer would only need to know the location to fix it (which GCC has always given just fine). On the other hand, for the kind of issues that actually trip up experienced programmers, clang is often *worse* than useless.
I don't look at their implementations and I'm too lazy to write test cases to observe their blackbox behavior.
Cool, thanks. I'll definitely check it out then.
it's a shame that it relies on an external compilation step (symbols.hh)
Both the 2 SO questions I linked were run using gcc compiled code. The fact that you haven't seen it on gcc is because it's a race condition, so will happen spuriously. As for directing your question to the committee, I would suggest it has already been confirmed. In my top-level comment I posted a link to a SO question [answered](http://stackoverflow.com/a/12527892/955273) by Anthony Williams. He is a co-author of the concurrency proposals that were implemented in C++11. - [n2497](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2497.html) - [n2320](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2320.html) - [n2184](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html) - [n2139](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2139.html) - [n2094](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2094.html) Given such a preeminent expert stated as such, I would take his word for it. That's just my opinion though of course.
&gt; Clang has never been better than GCC at anything for any notable period of time. You have to differentiate clang and llvm. clang doesn't generate code, just IR. LLVM does the code-generation and optimization. Well, in my opinion, clang is "better" than gcc in terms of being modular (eg. having libclang). Can you extract/inspect the AST or do anything else than simply compile code in gcc? Nope, you can not. Also, from my point of view clang being written in C++ and because of its architecture, it is much simpler to hack on clang than hacking on gcc. &gt; Rather, it has the full power of Apple's marketing team behind it. Not sure if this is true. Please explain. Apple's contribution to clang (not llvm) has significantly degraded over the years, as they are now more focused on Swift (and obviously llvm).
How do you quantify the memory usage of a single element in an std::deque?
Terrible article, zero analysis or thought. The author's platform is clearly 64-bit (good) where pointers are 8 bytes. That's why list nodes occupy 24 bytes - 16 for two pointers, plus 8 for the element and alignment. (There may be invisible allocator overhead.) This is *fundamental* to the nature of a doubly linked list. Similarly, set is a red-black tree, and its nodes are laid out accordingly. (There's more possible variation in deque and especially unordered_set.) If you want vector, you know where to find it. Also, vector efficiency is not quite as simple as "zero overhead". vector pays 3 pointers per container, plus geometric overhead. The geometric overhead is actually very small (even 2x reallocation isn't that much overhead, if you work out the math, and 1.5x trades more time for less space).
I don't see why this couldn't be accomplished with a builder.
&gt; for the kind of issues that actually trip up experienced programmers, clang is often worse than useless. such as?
And if you are using MSVC and your computer has many cores in it, you can enable multiprocessing for compiling and reduce that time significantly depending on the number of physical processors your build pc has. Here's the [docs](https://msdn.microsoft.com/en-us/library/bb385193.aspx).
From the doc: &gt; A short note on the design goals of the code itself: Although Envoy is by no means slow, little effort has been put into micro performance optimizations of the native code. Fans of deep performance tuning will find ample opportunity for improvement. The code has been written to be modular and easy to test versus aiming for the greatest possible absolute performance. Itâ€™s our view that this is a more efficient use of time given that typical deployments will be alongside languages and runtimes many times slower and with many times greater memory usage.
I'm as unsure of how to parse this comment as CLion is of how to parse my code.
&gt; You have to differentiate clang and llvm. Not really. They're both pieces of code in the compiler. Should I have to distinguish between GCC's C++ frontend and GCC's backend, since they are not always both present (say, in gfortran or gccgo?). &gt; Can you extract/inspect the AST or do anything else than simply compile code in gcc? Yes, you absolutely can. In fact, the API for doing so is *more* stable than Clang's in practice. For both compilers, each compiler release causes *some* incompatible API changes, but the porting effort is usually less for each GCC release, and GCC only releases once per year, whereas clang releases twice a year. Also, nobody uses between-release versions of GCC significantly, whereas vendors do that for Clang/LLVM a *lot*, by design.
&gt; Clang has never been better than GCC at anything for any notable period of time. Readable error messages. :) Also, sanitizers.
&gt; C is a proper subset of C++. This is not true. Not all valid C programs are valid C++ programs; moreover, there are programs that are valid in both languages but have somewhat different meanings. But let's concede this as being "mostly true" - in other words, close enough that you can get around the edge cases. Well, it's still a bad way to think of it that way. The techniques of C are very different from those in C++ and are basically wrong in C++. As the first example you'd walk into, in C you have to do a great deal of manual memory management. This is tricky and experience shows that in a large program, it's very easy to make mistakes which result in intermittent, hard-to-find bugs. C++ has a rigorous memory management system - in fact, a general resource management policy. It's quite easy to use, and once you understand it, you will _never_ make a mistake. Strings in C++ are fairly plain, but you can still do things like `std::string t = s1 + "hello" + std::to_string(number);` In C, you have to manage your memory for strings and you have to manage their contents as well. Doing this is a necessary skill for C - useless for C++.
Plus gcc has worked to speed up compilation time.
Gcc error reporting has improved dramatically over the last few major releases. Probably because of competition from clang.
I wasn't familiar with Visual C++ for Linux, and it disappointed me a little when I got a few sentences into the article. What I really want is a Visual C++ toolchain that cross-compiles from Linux for Windows, not the inverse. I like my Linux on my workstation, but I need to develop for Windows. The less I have to switch back and forth, the better. I know there is MinGW as a cross-compiling toolchain, and I do love it, but the prospect of an officially-supported Microsoft one would be way cool.
CLion does a great job, especially given its very young age (it's quite remarkable). Does it have Edit &amp; Contine, and a Debug step filter yet? (Ok I'm being unfair here, comparing a paid VS plugin with an IDE - but still, it's a feature I can't miss). It boils down to personal preference, I'm sure you could list many things you would miss from CLion if you were to use VS.
If you thought that article was bad (or left wanting) check out his blogs relating to string operation benchmarks or integer compression methods. What I can't understand is how he garners so much "positive" attention from the community with what is essentially: "crap" Surely these days being a non-tenured "professor" isn't that much of a rock star status thing? 
It's always had better error message, and for the very most part covers newer standards before GCC does. Clang also allows cross-compilation from a single-binary (albeit not as well as GCC does with its separate installations). It's also much easier to leverage the compiler technology in both clang and LLVM through their respective libraries than it is to hack GCC into what you need it to do (such as for static analysis, JIT, building a compiler, writing a debugger plugin for an IDE, etc). libclang and libllvm are fantastic tools that let you leverage them for far more than just a plain compiler. The documentation for working with libclang and libllvm are also vastly better than whatever can be found for mucking with GCC's internal pipeline. I prefer using GCC, only switching between the two for better test coverage or if I want to see another compiler's error messages while debugging an esoteric issue, but to say it's never been better at anything is ridiculous.
Sounds great in theory but doesn't work in practice. I've seen quite a few Unis and in most of them, Professors are teaching C++, and these Professors haven't programmed for the last 20 years, or at least don't program regularly. The best case is that they have heard of C++11 but have no idea what it is. The most common case is they've never written idiomatic C++ code, they think it's "C with classes" and know C from 15 years ago. Most of these Professors haven't done any hands-on work in years, they do lecturing, grant applications, supervising PhD students, managing their PostDocs, and maybe, sometimes, write their own paper or do their own research (mostly theoretical). This is a very fundamental problem in Universities - people teach coding that do not code and even if they do, do not follow language progressions at all.
Is it header-only? It's a shame it's embedded in this bigger library, it might get more traction if it was a separate, small library.
I don't see why this wouldn't work the same if you provided each of the functions twice, once for `T&amp;`, once for `const T&amp;`.
Well no, their version is shorter because it's 3 functions instead of 6. If they require a C++11 capable compiler they might as well use the features it provides..
Well I'd argue that that is a problem with the faculty and not so much the language that they're teaching. 
&gt; Well C++ is designed to be fully compatible with C code It was designed to be mostly compatible with C89. C99 and later versions introduced new things, for example the following struct initialization syntax (don't know what it's called): struct MyStruct { int a; int b; }; int main(void) { struct MyStruct x = { .a = 1, .b = 3 }; } which is not valid in C++. If this stuff interest you, you might want to read http://www.cprogramming.com/tutorial/c-vs-c++.html (where the very first bit of code presented is valid C89, but not valid C++).
 #include &lt;stdlib.h&gt; int main() { int* p = malloc(1 * sizeof(int)); free(p); } Vaild C, but fails in C++ because of implicit void* cast.
There are a number of things that article says about C that have been wrong since C99 came out.
&gt;&gt;I didn't know that as I couldn't find proper documentation for gcc's APIs. &gt;https://gcc.gnu.org/onlinedocs/gccint/ LOL
I've used both GCC and Clang heavily for years, and I have never encountered a situation where clang's attempts at being helpful were actively counterproductive, and I've encountered very few situations where GCC's error message was better than Clang's. At most they're unhelpful in different ways (which is still useful sometimes in that it still helps narrow down the problem).
Both of which have improved dramatically in newer versions of gcc?
Wouldn't the C++ equivalent just be this: int main(int argc, char* argv[]) { int *foo = new int; return 0; } 
 int main( void ) { int class = 42; return 0; }
In C++ you have to explictly cast it, otherwise you get a compiler error: int* p = static_cast&lt;int*&gt;( std::malloc( 1 * sizeof( int ) );
Clang's cross-compilation support works very well when targeting Apple's devices and makes the build process for fat binaries much simpler than it is with GCC targeting Android, but I would not be at all surprised if everything else was barely functional.
So then why not compile it as C code(which most modern C++ compilers should be able to do) and then including it in the project as a C file? 
Nope, due to trying to keep compatibility with C ironically enough. They generally only add overloads or more strict rules. /u/trojx is right though, you should use static_cast over reinterpret_cast. (static is required for void-&gt;T &amp;&amp; T-&gt;void, but reinterpret is needed for T-&gt;U (which breaks strict aliasing, so don't do it unless you're really sure of what you're doing))
I've certainly always viewed it as an insult, although that may be just bleedover from my tabletop RPG days, where the similar term "Rules Lawyer" is used for someone who will not shut up about the Rules As Written and will endlessly insist that their interpretation of things is correct even when it's completely irrelevant and the rest of the group wants to just move on.
Cool, thanks!
The list: - `static_cast` does explicit casting between literal types and a couple of other cases (might generate minimal runtime code) - `const_cast` casts away a const (const doesn't exist at runtime so it doesn't generate any code) - `reinterpret_cast` takes the bits of one type and acts like they're the bits of another (no code added) - `dynamic_cast` upcast (cast from Base to Derived) or downcast (cast from Base to Derived) using RTTI to verify the cast is valid, otherwise throwing `std::bad_cast` (decent runtime cost due to checking RTTI)
While you're correct that most C++ classes are done horribly, that's not how this discussion started. It was somebody asking if they could learn C and C++ at the same time.
Can confirm. Have already written a POC of such things a while back. In any case, a UDL for it isn't standard (but hopefully will be in C++20). To be truly portable, the easiest thing is a macro `foo(STRING_C("abc"))`, but GCC and Clang both support the UDL, as well as Boost.Hana if you give it a specific `#define`.
Thanks to LLVM/Clang yes.
Interesting how Clang is faster in some cases, with my EASTL benchmark numbers on Windows, GCC comes out considerably faster than Clang, and MSVC being the slowest by a tiny margin. I'll try to get some performance numbers posted soon on EASTL's documentation. (Disclaimer: I'm not affiliated with EA, merely a contributor to EASTL via github.)
And I gave them my best shot at an answer but then the discussion did turn to how C++ classes were taught more like C and that could cause the OP confusion if he was also learning C. 
Those are all pretty simple to understand. Thanks. I feel like you could teach C++ well if you wanted to. 
I don't think I've ever heard anyone called any kind of lawyer except as an insult. Lawyers are stereotypically unpopular people. Obviously *necessary* depending on the situation, but in the popular expression, "necessary" is immediately followed by "evil". 
It's how I actually started learning C++, looking back at it, it was more of a C with classes thing, lots of stuff I had to unlearn. Don't recommend it.
This is really cool, and a great idea. I decided to do it with actual template metaprogramming instead of with constexpr functions. I used fixed-point arithmetic, which sucks. I tried with a scale factor of 100 but clang++ kept barfing. I might not have my divergence test quite right yet. #include &lt;stdio.h&gt; #include &lt;iostream&gt; template&lt;long R, long I&gt; struct Complex { static constexpr long r = R; static constexpr long i = I; }; // Fixed point scale factor constexpr long S = 10; constexpr double Sd = S; template&lt;typename ostream, long R, long I&gt; ostream&amp; operator&lt;&lt;(ostream&amp; out, const Complex&lt;R, I&gt;&amp; complex) { return out &lt;&lt; "(" &lt;&lt; complex.r / Sd &lt;&lt; ", " &lt;&lt; complex.i / Sd &lt;&lt; ")"; } template&lt;typename C1, typename C2&gt; struct add { using Result = Complex&lt;C1::r + C2::r, C1::i + C2::i&gt;; static constexpr Result result{}; }; template&lt;typename C1, typename C2&gt; struct mul { using Result = Complex&lt;C1::r * C2::r / S - C1::i * C2::i / S, C1::r * C2::i / S + C1::i * C2::r / S&gt;; static constexpr Result result{}; }; template&lt;typename C&gt; struct diverged { static constexpr bool result = C::r &gt; 4*S || C::r &lt; -4*S || C::i &gt; 4*S || C::i &lt; -4*S; }; template&lt;typename C, typename Z, size_t iteration&gt; struct in_mandelbrot_helper { using ZSquared = typename mul&lt;Z, Z&gt;::Result; using Result = typename add&lt;C, ZSquared&gt;::Result; static constexpr bool value = diverged&lt;Result&gt;::result ? false : in_mandelbrot_helper&lt;C, Result, iteration + 1&gt;::value; }; template&lt;typename C, typename Z&gt; struct in_mandelbrot_helper&lt;C, Z, 5&gt; { using ZSquared = typename mul&lt;Z, Z&gt;::Result; using Result = typename add&lt;C, ZSquared&gt;::Result; static constexpr bool value = !diverged&lt;Result&gt;::result; static constexpr char print = value ? '*' : ' '; }; template&lt;typename C&gt; struct in_mandelbrot : public in_mandelbrot_helper&lt;C, C, 1&gt; {}; constexpr int kBegin = 0; constexpr int kEnd = 5; template&lt;typename ostream, long R, long I&gt; ostream&amp; operator&lt;&lt;(ostream&amp; out, const in_mandelbrot&lt;Complex&lt;R, I&gt;&gt;&amp; mandlebrot) { return out &lt;&lt; (in_mandelbrot&lt;Complex&lt;R, I&gt;&gt;::value ? "*" : " "); } template&lt;long R, long I&gt; using M = in_mandelbrot&lt;Complex&lt;R, I&gt;&gt;; int main(int argc, char *argv[]) { std::cout &lt;&lt; Complex&lt;10, 10&gt;{} &lt;&lt; std::endl; using c0_0 = Complex&lt;0, 0&gt;; using c1_11 = Complex&lt;10, 11&gt;; using c2_21 = Complex&lt;20, 21&gt;; using cn1_0 = Complex&lt;-10, 0&gt;; // true using c1_0 = Complex&lt;10, 0&gt;; // false auto result = add&lt;c1_11, c2_21&gt;{}.result; std::cout &lt;&lt; result &lt;&lt; std::endl; std::cout &lt;&lt; "add&lt;(1, 1.1), (2, 2.1)&gt;: " &lt;&lt; add&lt;c1_11, c2_21&gt;::Result{} &lt;&lt; std::endl; std::cout &lt;&lt; "mul&lt;(1, 1.1), (2, 2.1)&gt;: " &lt;&lt; mul&lt;c1_11, c2_21&gt;::Result{} &lt;&lt; std::endl; std::cout &lt;&lt; "mul&lt;(2, 2.1), (2, 2.1)&gt;: " &lt;&lt; mul&lt;c2_21, c2_21&gt;::Result{} &lt;&lt; std::endl; std::cout &lt;&lt; cn1_0{} &lt;&lt; " (is) in mandlebrot: " &lt;&lt; std::boolalpha &lt;&lt; in_mandelbrot&lt;cn1_0&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; c1_0{} &lt;&lt; " (isn't) in mandlebrot: " &lt;&lt; std::boolalpha &lt;&lt; in_mandelbrot&lt;c1_0&gt;::value &lt;&lt; std::endl; std::cout &lt;&lt; M&lt;-20, 19&gt;{} /* SNIP! */ &lt;&lt; M&lt; 19, -20&gt;{} &lt;&lt; "\n" &lt;&lt; "\n"; return 0; } Output is here: (1, 1) (3, 3.2) add&lt;(1, 1.1), (2, 2.1)&gt;: (3, 3.2) mul&lt;(1, 1.1), (2, 2.1)&gt;: (-0.3, 4.3) mul&lt;(2, 2.1), (2, 2.1)&gt;: (-0.4, 8.4) (-1, 0) (is) in mandlebrot: true (1, 0) (isn't) in mandlebrot: false ** *** ***** ********* ************* ************** ***************** ******************** ********************* ********************** ************************ ************************* ************************ ********************** ********************* ******************** ***************** ************** ************* ********* ***** *** ** 
&gt; Only C++ needs to have this as "undefined behavior". That's how C++ works. The other option would be to have primitive operations throw, which is a no-go for C++ -- it would remove the ability not to use exceptions from developers.
Why.. doesn't STL have std::getopt?
Not an answer, I just want to take the opportunity to say that the C++ language-lawyer tag is the best thing on StackOverflow. Lots of fun if you like C++ and can handle being proven wrong over and over and over again. Seriously, if it were not for StackOverflow or this subreddit, I would have had no idea how deep the C++ rabbit hole can go, and how fun it can be to fall in.
People who answer programming questions with the corresponding paragraph number in the standard. 
To add more weight to my claim about buggy implementation: the deadlock doesn't occur with Apple Clang 7.3. I still want an explicit clarification from the committee.
[Here is the solution](https://github.com/google/benchmark/blob/master/include/benchmark/benchmark_api.h#L231) I choose in Google Benchmark. It's based off of Chandler Carruth's suggestion in [this talk](https://www.youtube.com/watch?v=nXaxk27zwlk).
Everyone think different about code generation. There are reasons for it and against it. But I don't think "The more, the better". Sometimes code generation can be very usefull, but don't overdo it.
Because a programming language standard is supposed to be implemented in any OS already written or yet to be written and as such, how would *std::getopt()* be implemented in OSes that aren't UNIX clones?
[removed]
&gt; Here ARM refers to the Annotated Reference Manual, not a CPU. Which was the document (book) used as basis for the ANSI C++ standardization process.
it doesnt have to strictly follow unix style... why couldnt it be extensible?
Oh, huh. I wonder how many C programmers know about that. I don't think I've seen a C program use implicit return from main. Using booleans in C doesn't seem widespread either, but of course you are right that the type does exist.
On top of argc and argv, which are part of the C standard. It wouldn't do anything useful in an environment where argc and argv doesn't contain anything useful, but neither would anyone really expect it to.
huh.. im confused. why cant I set arg separators to shell specific one and call it?
Okay thanks.
Yep, currently its actual contest, whereas during the Clang 3.0 days, the GCC error messages were dumber than dumb. I admit to being a C++ newbie back then, but still... reporting basically every line in a file as an error because of mistake in included header is something else
Because it is not portable to expect a shell will be available. 
yes
People who focus on the fact that that C++ is an impossible to understand kludge, which it is, and ignore the fact that you can do usefull work with without perfect understanding.
Yes, you can. They are just programming languages, not brain surgery and rocket science.
Code generation is there to take away tedious stuff from the human who is also likely to get it wrong. There's no way to think "differently" about it, it's objectively the right thing to do in terms of code quality and maximizing the efficiency and happiness of the humans who code.
Yes, it's header only. The fact that it's part of a bigger library won't impact you too much because its whole codebase is about 4500 lines / 200kb of headers and its also header only. 
You can learn both side by side, but when writing C++ remember to ask yourself if C++ doesn't already have a better way to approach something. I'd also suggest reading about the C++11 and 14 changes as they really transform the way C++ is written.
that's an excellent solution! i'll be using that.
You're acting like the language you're using was the only tool available for every job. That's ridiculous. Auto-generated code can be beautiful if you pay a modicum of attention to what you're doing. Often it can be a way of making the code actually look better, because sometimes expecting a human to do the tedious right is a bit too much to ask and you end up with nasty hacks instead.
I found it very accessible and helpful. Cheers.
Personally, I think that if you are a true beginner wanting to try out programming, find an online class offered at your local community college. That way you have a formal learning process and plenty of help if you need it, plus you get credit! Something like 'Programming Fundamentals 1' is the one you want.
I went to school with a great rules lawyer. He knew exactly when to use his knowledge and when not to to get things done. Others would always insist on the rules being followed precisely at all times and were nothing but a PITA. 
&gt; There are folks that use it as a generalized message passing mechanism, sadly. I'm yet to meet those mythical folks. In fact, I don't think they exist.
I dunno - I'm sure I've seen code that comes close...
Knowing whether something is a problem with your code or with the compiler isn't totally useless, as it does somewhat effect how you go about solving the problem. It's *much* more reasonable to just try various permutations of the code that should be semantically equivalent when you're just trying to avoid hitting a bug in a specific version of a specific compiler than when it's your code that's wrong. It's just 90% useless.
Use `static_cast` for this, not `reinterpret_cast`.
Well, I don't thin that's the *only* reason. There is a certain system I maintain that relies on remote communication with a system that rarely changes relative to the number of times the interface is used. I use C++ both for generating the interface snapshot and for consuming the interface. If I had to autodiscover the interface on every function call, the system would be so slow that customers would never use it.
Completely agree with everything. I've fallen head of heals for C++, no other language is as useful for real production use. The problem with organizing a tutorial like that is C++ is a immense language. I've been in love with it for about a year now, and I'm still learning more and more about weird rules of the language or weird things about the STL, or whatever. A thorough tutorial would be massive, just look at [learncpp.com](http://www.learncpp.com/). I would also be scared to personally write something, as I wouldn't want it to be too similar to anything else, and would be worried about my work going to no use. That's why I respond to tons of questions on reddit :)
Two quick thoughts: 1) you are awesome. Thanks for trying it out . Feel free to send us any feedback. 2) intellisense is being actively worked on but it is a large item . No days yet. Sorry. Edit: auto correct fall
&gt; Have you ever actually used clang's cross-compilation? I have. I didn't try every single target, but I didn't run into the problems you mention. If those issues are reproducible then I hope you filed them as bugs.
Filing bugs against clang is a *great* way to have them be untouched for several years.
I think that what Stroustrup mean by 'language lawyers' is someone who knows the details of how the language work and know the ISO C++ specification kind of like how lawyers no the details of legal system and how it affects people and businesses. For the most part people do not need to know these details of the law but there are time we go to the edge cases were we should consult a 'language lawyer'
why nobody write proposal?
http://coliru.stacked-crooked.com/a/04450ada5004c66a It's a overload resolution failure that involves slightly complex SFINAE. clang only says 'substitution failure' while GCC lists all the involved functions and tells why the substitutions fail.
We're here, we're all considered **fucking insane** by the real world and most other programmers ("who on earth would love the complex language"), but we relish in the variety of tasks we can get done quickly and efficiently. 
I think they're overreacting. Having two clones and comparing them on local computer is easy. It would be cool to have them all on github in a single directory tree, but it requires all build systems to support it, and you to implement it...
It's a difficult one. As I've said elsewhere, it turns out that I can't accept pull requests into non-existant branches, which kinda sucks. But I do prefer the idea of branches over many copies of the same source all over the place... I'm still playing so we'll see what I can come up with :-)
There's finite amout of build systems you're gonna support. You can create some from top of your head and tell people in readme to mail you for new ones.
Some people have already sent in pull requests that I need to look at. Either to merge in to the code base as-is, or else if I decide to change the code - I've been toying with something more complex but I'm not 100% convinced yet. Either way they'll the added in soon...
I wonder why they built ChakraCore in C in the first place, and not in nice modern C++ :\
Race conditions are just that: race conditions. Whether you observe them or not is going to depend a lot on your platform / scheduler / etc. Observing a race condition on one platform but not observing it on another does not mean the platform where you happen to observe the race has bug(s).
I don't see how the committee can be any more clear than http://eel.is/c++draft/futures.promise#2
I'll do it if you do it.
&gt; The spec days that set_value makes the shared state ready atomically. Actually, it says much the opposite. http://eel.is/c++draft/futures.state#6
I've filed probably a dozen bugs, only a couple got fixed. At this point, no longer wasting my time isolating test cases and filing the report is the way to go.
&gt; `std::string`, `std::vector` and most of the other STL collections are heap-allocated, so if for whatever reason those aren't a good option it's back to C arrays and strings (we do now have `std::array`). `std::vector&lt;&gt;` takes an allocator, as does `std::basic_string&lt;&gt;` (for which `std::string` is a typedef) &amp;ndash; this allocator can provide memory from automatic or static storage, the _default_ allocator just happens to use dynamic storage. See e.g. /u/HowardHinnant's [`short_alloc`](https://howardhinnant.github.io/stack_alloc.html).
&gt;See e.g. /u/HowardHinnant 's short_alloc That's quite clever â€” it hadn't occurred to me that one could write custom allocators that don't allocate on the heap. But I'd be pretty apprehensive that using other forms of storage, with collections that're pretty tightly coupled to the semantics of dynamic storage, would make for a lot of subtle and hard-to-predict bugs. (As well as defeating much of the purpose of "safe" collections).
I wonder why there is a huge gap for big matrix ops.
This was a really good presentation by Sean Parent. https://www.youtube.com/watch?v=32f6JrQPV8c Slides and source https://github.com/sean-parent/sean-parent.github.io/wiki/Papers-and-Presentations
Nice episode. I was wanting a bit more technical depth, however. 
It's very common to provide a pure C external API for a library, even if the library is written in C++. The reason for this is that C has a relatively stable ABI compared to C++, so linking to C libraries dynamically is very easy.
[Not generalizable](http://melpon.org/wandbox/permlink/IrcRd8Ot6ZuqFk1i).
This is not a support forum. &gt;_&gt;
Anyone knows why deque seems to use 8 octets? I would expect it to be close/closer to vector. The container size author uses is 1024, looks like enough to get closer to amortized usage. That said, using anything other than a vector to store 32-bit data is a bad idea, and should be common knowledge. Article also fails to mention that e.g. per-node overhead of a list (or a set) is constant, so the bigger the data, the smaller the overhead.
Same I use in benchpress (full credit to Chandler Karruth again): https://github.com/blockchaindev/benchpress/blob/master/src/benchpress/benchpress.hpp#L192
In Stroustrup's book "The C++ Programming Language Fourth Edition" chapter 2 "Tour of C++ The Basics" he offers a quote at the beginning of the chapter: "The first thing we do, let's kill all the language lawers. - Henry VI, Part II" So to me, that rather sets some context...
No, no exception gets thrown--but it's still useful because if you go down that branch at compile time, the constexpr expression is ill formed and compilation fails, which is what I wanted to happen. Is there a more elegant way of doing it?
I think we are in full agreement. Rereading the posts, I think I didn't convey well enough that I see it as a process, like learning math. We don't teach algebra to 2nd graders, we teach it once they have learned more basic skills. I think students should learn algebra, but I am not therefore implying that 2nd graders should learn algebra. I was using the term "C++ learner" similarly to cover all stages of learning the language, not just those at a beginner level. I'm not implying that the beginner should explicitly learn C when I say that the C++ learner should pick up C along the way. There are some bits of C beginners will learn, more bits for intermediate learner, and even more as they advance deeper into the language. They will reach a point where they've learned all of the C++ compatible parts of C without a single explicit C lesson.
In theory, I agree. In practice, the reproducibility of a race depends on the probability of race to happen, and that probability decreases the longer the sequence of events leading to the race is. Every intro course to parallel programming uses two threads incrementing the same variable N times (w/o a mutex) to demonstrate the race condition, and the demo is consistently successful. Likewise, in a tight loop like mine, the race condition, if any, should be consistently reproducible, and it is with a buggy implementation. I changed only the compiler version and there's no deadlock anymore. I have a strong argument for the implementation being buggy, but haven't looked into the source (yet).
First, it's not the "opposite". It only says that two things must happen, but this has to be read in conjunction with http://eel.is/c++draft/futures.state#9 Next, http://eel.is/c++draft/futures.promise#2 says that the promise's mutex is held during the whole duration of the update of the "promise object". This is unclear, but I assume that the "promise object" here encompasses the shared state too. Lastly, http://eel.is/c++draft/futures.promise#15 says "Atomically stores the value r in the shared state and makes that state ready ". This wording is ambiguous wrt the scope of "atomic", it's unclear whether "atomic" encompasses 1) only storing of the value, or 2) both storing and making the state ready. The race observed and described elsewhere is possible only if the implementation took the first interpretation. However, if "making the state ready" is considered as modification of the promise object, such interpretation conflicts with the mutex requirement from the previous paragraph. `set_value` doing anything else on the promise w/o holding the mutex also conflicts with that requirement. This calls for clarification from the committee.
Why dont lvalue references to rvalues? I thought this always worked: void foo(string&amp; x); ... foo(string("kk")); ... 
I'm happy to call them universal or forwarding references informally, but why do they need a name *in the standard?* They're just an emergent phenomenon from template inference and reference collapsing rules (albeit carefully crafted to work that way).
Damn. Why is that?
Ah ok, that's good then.
&gt; I thought this always worked Always worked in MSVC which violated the standard.
It's most likely true, but it's also true that code generation is super criticized. I think it's because of how good build systems are complicated. Code gen can solve many problems easily. It can be an easy alternative to complicated language features. Sometimes it's enough. Assuming that you can enable it in your cmakelists without problems. Widely respected "Pragmatic programmer" book is pro-code gen, for example.
`c` isn't `const`. It only points to a `const char`.
r/cpp_questions and www.StackOverflow.com are generally more appropriate forums for questions like this. That being said, if you'd like help you really should post a minimal but complete snippet of code that shows your problem. In your case, going through that reduction process will probably be enough to show you your error.
Firstly, the sidebar says "For C++ questions, answers, help, and advice see r/cpp_questions or StackOverflow." Secondly, #include &lt;string&gt; int main() { std::string name = "hi"; const char* c; c = name.c_str(); } compiles and runs just fine. http://ideone.com/YwLts8 My best guess would be that you have some compiler error somewhere else (unmatched parentheses, redeclaring variables with same name etc.) I don't see why the code wouldn't compile otherwise.
If it becomes a big problem, you could consider using a more data-driven design by adding a scripting language so that you don't have to recompile c++ for every little gameplay code change.
parameters don't prolong the lifetime, rather temporaries just naturally live for the duration of the full expression they're in (which includes the function call)
Not read the latest edition but the earlier ones were more "C with Classes For Dummies". I can't see how such a book would do modern C++ any justice. You are better picking one of the books from http://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list
Notice that in the first screenshot you're getting an error even on line 174, where you declare the "c" variable. It probably means you already have a variable named "c" in the same scope (function) but with a different type (a char).
&gt; `assert()` is controlled globally and cannot be enabled for certain parts of the program only This is not true: It is perfectly legal to`#include &lt;cassert&gt;` multiple times with and without `NDEBUG` being defined: #define NDEBUG #include &lt;cassert&gt; int foo() { assert(false); // never fires } #undef NDEBUG #include &lt;cassert&gt; int bar() { assert(false); // always fires } Whether it is morally questionable is of course another discussion. ;-)
Try assigning your const char* c to an array of char. arrayOfChar [maxStringSize ] = "some string"; const char* c = arrayOfChar
&gt; http://eel.is/c++draft/futures.promise#2 says that the promise's mutex is held during the whole duration of the update of the "promise object" No, it doesn't. "synchronize with" means that memory writes made on one thread are made visible side effects on another thread. It doesn't imply anything about atomicity. &gt;Atomically stores the value r in the shared state and makes that state ready This means that if 2 threads call set_value, one of them "wins" and has their value set, and the other one gets `future_error` with `promise_already_satisified`. There is a single total order of `set_value` calls. &gt;I assume that the "promise object" here encompasses the shared state too. The race is not on the shared state, it is on the promise object. This is no different than trying to destroy a mutex while it is locked. "Single mutex associated with the promise object" means that the promise object can look like this: class promise { mutex _Single_mutex; void set_value(T) { lock_guard&lt;mutex&gt; _Lck(_Single_mutex); // do things } ~promise() { } }; If you call `set_value` and the other thread calls `~promise()` while `set_value` is unlocking `_Single_mutex`, you get this UB.
&gt; But const T&amp;&amp; is a thing too. And sometimes an important thing. They may be important to know about but I've never found them useful.
Temporaries live for the duration of the expression with [one (useful) exception](https://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/), however. 
regex uses them to enforce correctness, so does cref. I patched regex like that because I made that mistake in my own code.
The class definition of secret_cove can't be modified.
https://scmchallenge.com/#!/
It looks pretty interesting actually. Definitely seems less battle tested than SCons and the documentation isn't as good, but seems considerably faster. Thanks for the tip!
checkout the link: https://scmchallenge.com/#!/
Just create a fake account and log-in, Patrice wrote up this whole spiel about pirates and secrete coves - it's worth the read just for the laughs.
Care to elaborate on why it would work if the operator is templated but not otherwise? Might be because its before my first coffee today, but its not obvious to me right now...
&gt; If you call set_value and the other thread calls ~promise() while set_value is unlocking _Single_mutex, you get this UB. However, in my example, even with your implementation, the other thread *cannot* call `~promise()` because of the preceding blocking get, unless `set_value` looks something like void set_value(T) { { lock_guard g(mtx); update_state(); } // ~promise gets the chance to run in the other thread make_ready(); } Which is correct implementation according to *your* interpretation of the "atomically" part. According to *my* interpretation of the "atomically" part, `make_ready` should be part of the same critical section. Now, why do you believe that your interpretation is correct? --- On the other hand, the same race can happen even with my interpretation, i.e., `atomic { update(); make_ready(); }` if the promise's mutex is decoupled from the shared state's signaling mechanism. For example, class promise { std::mutex m; shared_state* s; void set_value(T t) { lock_guard g(m); s-&gt;set_value(t); s-&gt;signal(); // ~promise() gets to run in the other thread } } class shared_state { sem_t sem; // ... void signal() { sem_post(&amp;sem); } } Promise's mutex is used to guard access to the shared state's data, while semaphore is used only for signaling. (I'm aware the example won't work for multiple waiters.) The standard seems to allow such decoupling. 
How do you suggest they get out of that rut?
It's very frightening how many errors and bugs there are in very popular software...
I thought I solved the puzzle but I then realised that there should be another test (which I would have failed) bool TestCase4() { MyGraph g; { auto a = MyGraph::MakeNode(); g.SetRoot(a); auto b = MyGraph::MakeNode(); a-&gt;AddChild(b); auto c = MyGraph::MakeNode(); b-&gt;AddChild(c); auto d = MyGraph::MakeNode(); b-&gt;AddChild(d); d-&gt;AddChild(b); d-&gt;RemoveChild(b); } g.ShrinkToFit(); return Counter::count() == 4; } The [Pirates](https://scmchallenge.com/#!/puzzle/cpp-pirates) one I had no problems with. ---- **Edit:** The simplest [I could get to work (with my additional test case)](http://ideone.com/jgXzcc) was writing a [Mark &amp; Sweep](https://en.wikipedia.org/wiki/Tracing_garbage_collection) garbage collector for the graph which feels like cheating... **Edit #2:** I see my additional test was added :)
&gt; Stevens Capital Managment is also called Waterfront International Limited. It feels like every trading/finance companies always come-up with really cheesy names. Working for ValleyWater Group Limited in the Intergalactic Trade Center Building, Alpha Finance District and running a fund for Eric Nhiple's Management Investors surely sounds amazing. 
Exactly very educational pieces that every C+ programmer should read. The articles high quality is actually a feather in the cap for this company. 
I was able to do it by changing the internal type of children to weak_ptr. Though I'm not sure if that's allowed - the *challenge* aspect could be to do it only using shared_ptr. Here's a good read: http://stackoverflow.com/questions/27348396/smart-pointers-for-graph-representation-vertex-neighbors-in-c11 
Is there a reason to vote this down, other than spite ?
It may be a better fit for /r/cpp_questions /r/cpp's sidebar notes that it is for "Discussions, articles, and news about the C++ programming language or programming in C++."
which, in C++11 before generalised lambda captures, is similar to what you needed to move a value into a capture. One needed to bastardise the copy constructor/operator to behave like a move in a wrapper of sorts if they wanted that behaviour.
You could static cast both &amp;FooAobj and &amp;FooBobj to Foo*
&gt; What I meant by that is that you can't write a device driver or an OS kernel in Java Very true &gt; It basically expects you to be consistent about types but without explicitly writing them in your code. I love python for certain things, but large programs get very hard to reason about easily. &gt; Who knows maybe I'm just more cut out to be a C++ite than a Pythonista. Same :)
It's hard to do the conversion you want "sanely" in a world where multiple inheritance is allowed (example: https://godbolt.org/g/epKK37 . What is decltype(ptr)?). More generally, there may be any number of possible types that both sides of the operator can be implicitly converted to. So not doing the obvious thing here saves C++ from having yet another set of complicated conversion rules.
&gt; why can't it be smart and look at what the returned object is going to be used for Because that's not how C++ works. Any expression must have a type. It would seriously change the language if the type of a ternary expression was dependent on the context. Right now, you can do this: #include &lt;iostream&gt; #include &lt;type_traits&gt; int main() { std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; "Type of 1 + 1 == int: " &lt;&lt; std::is_same&lt;decltype(1 + 1), int&gt;::value &lt;&lt; '\n'; std::cout &lt;&lt; "Type of 1.0 + 1.0 == double: " &lt;&lt; std::is_same&lt;decltype(1.0 + 1.0), double&gt;::value &lt;&lt; '\n'; std::cout &lt;&lt; "Type of (true ? 1.0 : 1) == double: " &lt;&lt; std::is_same&lt;decltype(true ? 1.0 : 1), double&gt;::value &lt;&lt; '\n'; return 0 } All of which will output true. Changing the ternary operator would be a massive change to the language. Either use an `if-else` or cast each side to the type you want.
`"meow"s` is equivalent to `std::string("meow")` which is totally not a string literal. For a sufficiently long cat noise, it'll dynamically allocate memory.
Sorry, I should have said 'produce the effect of something akin to a literal string', and I imagine even `"M"s` would allocate something on the stack.
&gt;You can keep track of parents and then write a trace to the root in RemoveChild after you delete yourself as a parent. No link to root, nuke the whole cycle. At first I also used weak pointers for parents but I still had problems with cycles. How do you prevent getting into a loop when tracing the way to root? 
I am curious to see how you got it to work, care to share your code? 
`"M"s` would allocate no dynamic memory, but it would allocate `sizeof(std::string)` on the stack, just the same way `const char* = "M";` would allocate `sizeof(const char*)` on the stack.
The problem is `std::string` *owns* its internal buffer. For that reason it *always* has to copy whatever the input string is into that internal buffer. You can't point it's internal data structure at an address in `.rodata` and say "you don't own this data and you can't modify it" What would happen if you attempted to use one of the mutating member functions on that string? Typically your application would terminate. You *could* create a `const std::string` which would disallow using any of the mutating members, but there is no way for the constructor of the string to know that it's constructing a const object at the time of construction, so the compiler wouldn't be able to enforce it. Really the best tool for this is `std::string_view`
Cool, hadnt thought of that. Thanks.
&gt; I love python for certain things, but large programs get very hard to reason about easily. I'd also imagine that large programs that are in any way computationally intensive would get too slow. Python is designed for maximum programmer productivity, which I can appreciate, but not necessarily for maximum machine productivity though then again with PyPy, Numba, Cython, and similar projects that may not have to be true. In any case I'd still take Python over Java when programmer productivity and code readability matters; and I'd take C++ over both of them when low level control, execution speed, native binaries(not just a cheap wrapper with a runtime built in), or true object oriented programming are necessary or desirable. And if I'm feeling functional Racket(Lisp) is my go to. 
Might we also point out that some of these points were only vaguely valid at best for the time, it seems this is just pure hollow flamebait from someone who got inexplicably mad at C and C++.
Is there a specific reason why you pass the `string_view`s by reference? Should not they be passed by value instead, since they are small (2 pointers) and cheap to copy?
For anyone who uses Qt there exists the QStringRef class which works similarly.
More generally it would be interesting to know at what size does an object of N pointers (contiguous in memory) become pessimistic to pass by value as opossed to const ref. I suppose it's impossible to say without the context of other memory usage in the code.
&gt; I'd also imagine that large programs that are in any way computationally intensive would get too slow I would imagine most of the computationally intensive stuff would be written in C/C++, as python is just too slow for that. The other thing that I really like with C++ is templates, you can do literally anything at compile time (I'm throwing around the idea of compile-time regex parsing). 
&gt;I would imagine most of the computationally intensive stuff would be written in C/C++, as python is just too slow for that. Or Fortran, all the linear algebra libraries are still being maintained in Fortran. It's really not as dead as people think, it's just become a very domain niche language, and I could arguably say the same for Ada. &gt;The other thing that I really like with C++ is templates, you can do literally anything at compile time (I'm throwing around the idea of compile-time regex parsing). I haven't gotten to learning that part of C++ yet but I've been told that C++ templates are a minefield and that I shouldn't overuse them. But then again I was told the same about pointers but those really aren't that hard of a concept, the syntax is just a bit weird since the * in initialization just tells you it's a pointer while the * before an existing pointer is the dereference operator. So I had a question for you as a C++ fan, what do you think of Racket and of Rust? The CS class I'm taking now is teaching using Racket Lisp but what I really want to be learning is C++, Rust, and maybe Haskell(It looks so dope from the short online tutorial that I did with it). I asked my professor this and all he said is that learning a Lisp would help me think more like a programmer and therefore write better C++, which I had told him I was self-teaching for a few years. 
Sorry, but beginner questions are off-topic for this subreddit, please read the sidebar.
Precompile headers and avoid templates. 
Can compiler do this automatically? If programmer pass argument by const reference and size of argument is less than 2 ints, optimizer change code to pass by value instead const reference... something like that. Of cause you can't do this on mutable parameter but in case of immutable I don't wanna bother such a detail, and in generic context, programmer might not assume that type is small or not. Also if I augment type which was considered small then do I have to change every code from pass by copy to pass by reference? Yuck.
I seem to remember the new MSVC optimizer does that for integral types in some cases, but that was about it.
&gt; I haven't gotten to learning that part of C++ yet but I've been told that C++ templates are a minefield and that I shouldn't overuse them. Templates and TMP (Template Meta-Programming) are amazingly powerful tools to solve certain jobs. The problem is when people confuse the use of function templates for the use of regular overloading, and generally use tooooo many templates in their code. &gt; So I had a question for you as a C++ fan, what do you think of Racket and of Rust? I really don't know, I came up through C-like languages. I started with Processing -&gt; Java -&gt; Python -&gt; C -&gt; C++. I've never really dealt with them, though from what I hear with Rust's guarantees is very nice, but I just can't get away from C++, it's too awesome :) I really want to learn Haskell, a Lisp (possibly Racket), and something like OCaml, just to broaden my horizons in terms of what's possible in programming. 
[removed]
You could actually do this, because in this case you're the compiler. Just notice when a constant string with static or thread storage duration is initialized with a string literal, and change the constructor and destructor to directly assign to the internal pointers directly instead of going through new and delete. But you're right that the best tool for this is string_view. gcc and clang don't appear to initialize those at compile-time either, but it's cheaper to construct, so you still win as long as you don't need it NUL-terminated.
D can do this, a proof of concept [extension](https://github.com/solson/miri) to Rust can as well. It may be a bit more difficult in C++, but should be doable.
modules
The compiler would need to check no aspect of the object's identity was used within the function. That might not always be possible. Wouldn't it be better to allow the compiler to convert a value argument to a const ref argument if it would be more efficient? That would work better semantically as, by passing by value, you are stating you don't wish to pass identity. Compilers probably do this already under some circumstances. Can someone more knowledgeable than me say why we can't rely on this and just pass all const arguments by value unless we also wish to pass identity. 
If your string_view was created from a string literal, then `sv.data()` returns that string literal, including the NUL-terminator. There is no problem here.
&gt; If your string_view was created from a string literal How do I detect that in my function?
Isn't nginx written in C?
AFAIK Facebook is written in PHP but converted to C++ for speed.
i don't know if it counts, but i wrote the back end of century21.com in c/c++. era.com was originally written entirely in c/c++, and it got a few awards.
People are still waiting for web assembly which is not finished yet.
Apart from a non-free license: * Looks like a 20 years old code base. * Manual memory and resource management all over the place. * Uses platform specific APIs instead of `&lt;mutex&gt;` etc. * Uses `fopen`â€¦ really?! Ok, I stopped reading after facepalming myself several times. Not sure if I care enough to open an Issue named "Request: Complete Rewrite".
Sadly, no. This single line makes it about 15 MiB of header files (with bcp): `#include &lt;boost/lexical_cast.hpp&gt;`
Is there any good tutorials out there on how to use it? I really like to use the for a few Web projects I have in mind. 
Not anymore. They eventually created a JIT that was able to generate faster code than the C++ converter. http://hhvm.com/ &gt; there were many reasons for this; one of them was HPHPc's flattened curve for further performance improvements. https://en.wikipedia.org/wiki/HipHop_for_PHP#History_Before_HHVM
lexical_cast.hpp does not pull 15MiB of header files. iod/parse_command_line.hh actually pulls just 30% more headers that cxxopts. Just check the numbers : $ cat ./cxxopts.cc #include "cxxopts/src/cxxopts.hpp" $ g++ -E ./cxxopts.cc | wc -l 70771 $ cat test.cc #include &lt;iod/parse_command_line.hh&gt; $ g++ -E ./test.cc | wc -l 90615 
After ranges arrive, the usefullness of this does not change since `string_view` provides full string interface. Upd: comment changed since I misunderstood the question first.
What's your twitter? :)
I don't see the problem here. There is a good chance that users won't have to copy them since they probably have boost already installed. 
The one comment I'd make from a *very* quick look around is you are using owning raw pointers - I'd suggest you ought to think about using smart pointers rather than raw ones. You'd then not need to explicitly do deletions in places like the EntityManager's dtor, and you'd reduce the risk of memory leaks.
I do mean to start using smart pointers but currently I am using raw ones to get use to how memory is managed. 
Thank you! Yeah it isn't very well organized and documented so these are things I definitely need to improve on. 
Normally, public data is not in opposition with [private data along with getters and setters]: If you have private data and add a trivial getter/setter pair to it, you are better off making the data public: it is easier to write and maintain and makes it obvious both that the data is accessible from the outside and that you impose no restrictions on the value range. If you use data _with no logic associated with it_ it should probably be public in a structure (POD or not) or standalone. If you use data _with logic associated with it_, the data should probably be private and client code should have access only to the operations that use it, not the data itself. The presence of getter and setter functions for everything is many times a symptom of poor design even in Java (though sometimes this is imposed by the framework/language you are using - lack of support for adding public data in an interface definition for example, imposes it to be simulated through a getter/setter pair). In most cases (YMMV) private data along with trivial getter and setter should not be considered as a solution to any design problem in C++.
Well, it does not work via Wine. Is it calling some Windows specific stuff?
[CppCMS](http://cppcms.com/wikipp/en/page/main) is a web application framework
Well, std::string does not have a virtual destructor so I can't extend it, I added a constructor using std::string and a ToString to retrieve a std::string from the class. And use composition with function forwarding for non defined functions. The alternative is to copy the entire std::string class from gnu implementation and modify it, but that seems laborious in the long run. The difference being go strings are generally utf8 encoded byte sequences and so the functions behave in a manor consistent with unicode. It also provides trim and split and so on that is found in more modern std libs. Unless you had some other implementation in mind...
By extend I didn't mean extending a class. I meant extending my knowledge. For example, I like Boost libraries (at least some of them) because I can use them alongside with std::, for example I can pass std::string to Boost string functions. However, I cannot do this with QT since it requires QString for even a trivial task. (There might be reasons behind this but) QT requires me to change my entire string usage. Of course this is not possible for all cases but I suggest you to prefer free functions over classes when possible. I might use your trim function if it is a free function but if it requires me to use your string class instead of std::string I will reconsider. Well, all the examples revolved around strings but I suppose you get the main idea. Also, there are already established third-party libraries that you might be re-inventing while implementing this. Consider this as well 
Where would you expect C++ on the client side? AFAIK, browsers only know Javascript, HTML and CSS. Do you perhaps mean front end instead of client side?
It's going to be replaced by a proper QStringView soon, IIRC.
How often do you add or remove files that this is an issue? It is a level of redundancy that helps detecting errors like "I forgot to check this file into SVN" or "I forgot to remove this test file". Arguably, the right level of redundancy differs from person to person. For someone doing Java, C++ is totally redundant with its split into ".hpp" and ".cpp" files. I like it because it specifies the interface separately, although it means I have to change function signatures at two places.
This has been discussed here and there within the committee. There's pros and cons (sorry, I don't have the list at the moment). There has been talk of a formal proposal to change it, but that hasn't happened (yet). I know the designers of Concepts-lite have considered the idea, and decided to go with what they went with instead. ie the designers are well-aware of the "issue" and don't think it is an issue.
Isn't the point of wine to handle the windows specific stuff?
If that's ambiguous, then why the syntax with plain `auto` are not? You can apply the same example you just posted with `auto`. They are semantically the same, both variables are declared `auto` and yet they can be both different type. I personally think it would be much easier to explain that concept usage as if it was a constrained auto instead of bringing a whole set of different rules we will have to remember for that case.
Maybe they meant in the context of web programming. Compared to PHP etc. I'd say it's really small. At least I seldom see it discussed, but I haven't been looking much either. 
To reiterate: A *lot* of people have expressed concern over this inconsistency. You are not the first, and you won't be the last, and it is very possible that this decision will be reversed before Concepts are standardized. This is symptomatic of why we've had such trouble getting them â€” they were pushed back to C++11, then to C++14, then to C++17, then to C++20; there just isn't enough consensus on the details, and they won't make such a significant addition to the language without broad agreement on the semantics. However, applying the same logic as above to the `auto` case, you can kind of see where the designers were coming from: Which use case do you suppose would (or should) be more common â€” two parameters that are completely unconstrained *except* that they must be the same type, or two parameters of any type? The designers probably felt that if you didn't care enough about your constraints to encapsulate them in a concept, then you probably didn't care whether the two parameters were strictly the same type, either.
Qt's QStringLiteral() macro (which calls lambda), for example, creates static QStringData inside .rodata (it's 24 bytes header + utf16 string literal) with reference count -1, meaning it's read-only. Creating QString in this way resolves into some pointer moves, no converting from utf8, no reference count incrementing.
&gt;I wonder if it is planned to be fixed or if the committee has a strong opinion about bringing such rules to the language. This concern is constantly raised by various people, but the Concept proposal authors have a strong opinion and won't change anything. The main arguments for the current behavior are "we've heard all your arguments thousand times" and "we know better we work on this for years".
Oh, yeah. I meant .net and such. Not simple win32 stuff.
For the curious but lazy, here's the link: http://stackoverflow.com/questions/tagged/language-lawyer%20c%2B%2B Thanks for pointing out this tag, ubadair! It's all kinds of scary awesome :)
From Go's stdlib I would be more Interested in that net package rather than slices, goroutines. Having a std string made of runes would be cool but not as cool as net/http
&gt;Which is correct implementation according to your interpretation of the "atomically" part. That would be correct if and only if `update_state()` is the only thing that can fail there. `promise` must deal with construction of the user T in the shared state throwing an exception; in which case the next thread to call `set_value` can do so (without a `promise_already_satisfied` error). &gt;However, in my example, even with your implementation, the other thread cannot call ~promise() because of the preceding blocking get That's false. Here's an example execution showing the problem: 1. Outer thread creates promise/future/inner thread. 2. Outer thread goes to sleep on `future::get`. 3. Inner thread calls promise.set_value() 4. Inner thread takes the lock associated with the promise in set_value() 5. Inner thread unblocks the outer thread. 6. Outer thread wakes up from get(), and calls ~promise. 7. Inner thread tries to unlock the mutex in the promise object. With your example based on semaphores, the issue is much the same: 1. Outer thread creates promise/future/etc. 2. Outer thread goes to sleep on the semaphore. 3. Inner thread calls set_value. 4. Inner thread calls lock_guard::lock_guard() 5. Inner thread calls s-&gt;signal(), unblocking outer thread. 6. Outer thread wakes up and calls ~promise() 7. Inner thread calls lock_guard::~lock_guard() (on a destroyed mutex) 
After scanning that thread, the only conclusion I can come to is that the terse syntax should simply be avoided. If it is that contentious, it shouldn't be part of the standard.
&gt;SYCL is designed to not lock in your software development to one platform &gt;We currently only support Linux and two OpenCL implementations, by Intel and AMD Doesn't support nvidia or windows yet Still stuck on OpenCL 1.1/1.2 for the foreseeable future rip me
From their [FAQ](https://github.com/Microsoft/vcpkg/blob/master/docs/FAQ.md) &gt; C++ should be used in a C++ package manager for C++ programmers. Nice. This is something like [hunter](https://github.com/ruslo/hunter), less cross platform, but with a command line tool which displays / searches packages, and helps with the integration in existing projects. Due to the similarity of the projects I guess one can easily port packages between the two projects!
Haven't yet seen any C++ programmer without his own logging framework.
Is this the only implementation of the SYCL standard ? It is gonna be free, open source ?
X stdlib in Y is an idea that comes up on a regular basis, but it's not really a very good idea. X's stdlib is designed around the features and limitations of X, and a port to Y will be nearly always be awkward due to the features X has and Y doesn't, while also failing to take advantage of Y's features. Further, while having X's stdlib available may make things easier for people who know both X and Y, it makes your codebase significantly more awkward to work with for people who just know Y. In practice it's usually better to look at *why* X's stdlib is better for what you want to do in Y, and then design a library appropriate for Y which solves the same problems. 
No GSL?
How will this work for cross platform applications? I see cmake scripts however this appears to be designed and focused around windows.
Very fair point, and I can't find the benchmarks anymore as it was probably 2-3 years ago. C++ will still probably beat the pants off them if both of them were written in a very performance friendly way.
Honestly, as a cross-platform developer, I couldn't care less about it not being cross-platform - Windows is the only desktop platform that I don't know of a good solution for that provides easy dev builds right now, and maybe Vcpkg can be it. (Disclaimer: I've never tried NuGet - I thought it was for C# though?) On Linux, you just apt-get/yum/whatever to install your dependencies. On Mac OS X, you can use homebrew when you're developing, but odds are you're compiling all your dependencies yourself if you're shipping software. (You usually need to be picky about the Mac OS X SDK version and MACOSX_DEPLOYMENT_TARGET for all your dependencies.) On Windows, it's generally not that hard to get any C/C++ dependency up and running if it ships with a MSVS project file, but it's usually fiddly. I find there's usually some path or something I need to tweak to build stuff. And when you upgrade MSVS versions, you usually have to rebuild them all again, which is a pain. 
True. In theory, pure functional would help optimizations (such as loop invariant hoisting), but in practice it doesn't really help at all.
Great question! The best single reason is that we emphasize building from source, which means library authors don't have to publish new binaries when a dependency updates. https://github.com/Microsoft/vcpkg/blob/master/docs/FAQ.md#why-not-nuget
This is exactly the situation :). Our tool will make it much easier and less error prone to handle VS upgrades.
I think the best realtime thing you can find is [cppcon hashtag on twitter](https://twitter.com/hashtag/cppcon?f=tweets&amp;vertical=default)
Good idea :D
That's another good point; replacing it with a traits-based system would fix all of this, but eh.
Add an issue to our GitHub! https://github.com/Microsoft/vcpkg/issues We'd also happily accept Pull Requests for both of these libraries. 
yeah. i suppose i could do Foo* ternary_if(bool, Foo* a, Foo*b) { // ugly code inside } and then call that. or maybe a template template typename T, A, B T* ternary_if(bool, A* a, B*b)
you can try these out? http://stackoverflow.com/documentation/c%2b%2b/topics http://stackoverflow.com/ there is also cppquestions on reddit 
at least hhvm was written in c++, that sorta counts - right? :D
I'm more interested in the CMake integration being cross platform, I have little to no interest in VC++ integration, will the CMake integration work on multiple platforms? If not, is there plans to? (Without this competition with other similar projects will be very hard)
&gt; However, one big difference between our approach and hunter is that your project needs to be aware of hunter (and call into it) in order for it to work. Yes, but [cget](https://github.com/pfultz2/cget) is completely non-intrusive, and will install any standard cmake project.
What people don't like to hear is that OpenCL has lost (except in the FPGA space).
No pls :'( no more typing angle brackets :'(
As I mentioned in the post, I'm at Cppcon this week, so if you're here too then feel free to find me and tell me why I'm wrong :-)
Please anyone??
How does Vcpkg deal with using different runtime settings (/MT, /MTd, /MD, MDd) in Visual studio projects?
Typical brain-fart by a novice user trying to market/advertise the fact that they're at CPPCon - dude literally ANYTHING is better than using raw pointers.
So it's built on CMake. Are you planning on promoting CMake good practices? Like for example: * Tracking recent versions of CMake (sure the name looks like "make" that almost never changes, but you should upgrade your 2.6.2 install you have). * Using imported targets instead of using variables directly in your target * Having the other Microsoft libraries use modern CMake. Looking at you cpprestdk with your 2.6 requirements that is over 8 years old. * Stop setting things at the global level. Globals with side effects are bad in any languages. Even more in a build system! Stop using include_directories or link_libraries unless it's toolchain stuff (like sdkroot include folders or the STL implementation you want to propagate everywhere). Use target_link_libraries, target_include_directories and set the PUBLIC / PRIVATE / INTERFACE value properly! Include paths shouldn't leak to the user of your library most of the time! More questions: * What's the workflow for the CMake integration in Visual Studio? * Can you just double-click a CMakeLists.txt file in the explorer and have Visual Studio show a wizard asking how to generate a project? * Can you have in the same Visual Studio instance multiple targets (32bit / 64bit / ARM)? Original CMake doesn't do that, but you could work around it by having multiple build folders internally hidden.
Don't use `std::variant` - it does not support recursion. And by not supporting recursion it infects other code like `lambda_util::compose`. Using `lambda_util::compose` can I visit a `variant&lt;int, pair&lt;int,int&gt;&gt;` so that overload for `pair` calls overload for `int` (twice)?
[https://github.com/Microsoft/cmake/](https://github.com/Microsoft/cmake/) has two branches called `MSMultiPlatform`, and `Win10MultiPlatform`. The corresponding [discussion](http://public.kitware.com/pipermail/cmake/2015-August/061315.html) on the CMake Mailing list. Unfortunately this feature was not upstreamed.
Slides are taken from [@blelbach](https://twitter.com/blelbach)'s and [@meetingcpp](https://twitter.com/meetingcpp)'s twitter feed. So all thanks goes to both for uploading the pictures. For more impressions from CppCon 2016 check [#cppcon](https://twitter.com/hashtag/cppcon?f=tweets&amp;vertical=default) on twitter.
A counter-example is std::destroy_at.
You jealous for not being there? :-)
I'm here, I mean there.
There are (tens of?) thousands of awesome dudes who explain things really well. Do you remember anything else?
Slide #19 is some visionary-level insight, too. Applies to more than just code, too.
Not sure I'm keen on the idea of C++20 having a go style package manager :/
That's probably for the best. It would need some serious work to make that suitable for inclusion, from what I can see. CMake's model doesn't fit doing this at all, and I'm not sure why you wouldn't solve this problem at a higher level--for my work we do all this in CI jobs, with a matrix of supported platforms and build types. I wouldn't find consolidating it all into a single build would provide much in the way of concrete advantages.
He seems to give the same talk over the last 3-5 years. It's getting boring.
Can someone tl;dr what Bjarne said about that?
Wouldn't the issue be solved by defining that `a` and `b` can be different types, but allowing `[](Container a, decltype(a) b) { /* ... */ };`
Another use case is perfect forwarding. Take this for example: void doStuff(Container&amp;&amp; a, Container&amp;&amp; b) { /* ... */ }; And call it like that: doStuff(std::move(aVector), anotherVector); This will not compile (from my understanding), as the two `Container` will be the same type. Since one is moved, the type would be `std::vector&lt;Stuff&gt;&amp;&amp;`, but the other one would be `std::vector&lt;Stuff&gt;&amp;` which is not the same. This case is really lucky. Imagine a case were it compiles, but the code don't behave as expected? It would be hard to explain that.
Is this going to be on the cppcon youtube channel? (It was my belief all talks will end up there, but I may be incorrect).
Who do I register my name?
The first bunch is more or less the same-ish. But then goes into more detail about C++17 features.
Company: Nitro Type: Full time Description: At Nitro, weâ€™re changing the way the world works with documents. From the desktop to the cloud, we make it easy to create, edit, share, sign and collaborate â€“ online or offline. Location: Dublin, Ireland Remote: Preferable not, but there are always exceptions. We have few folks working remotely. Visa Sponsorship: It depends. Technologies: C++, STL and Boost Contact: You can apply directly at https://www.gonitro.com/about/jobs/217610
A little while ago, I made a const-expr string view class that would do pretty much this. https://github.com/erichkeane/const_expr_string The idea for me was to get compile-time defined strings with the advantages of std::string without the runtime cost and allocations of std::string. It isn't very polished, and I haven't used it in a while, but check it out! It really shows what we could do with string_view once it goes constexpr!
I am very sceptical about a package-manager, because it is basically guaranteed, that it will be an absolute security-nightmare, as every single one I know about is. In order not to be a security-nightmare, a package-manager **REQUIRES** enforced code-signing and a web of trust with some people who we know sufficiently well to be both trustworthy and critical in whose keys they sign. It is necessary that the user who installs it, picks a set of some of those people and trusts them explicitly. I never get why people are so happy to throw away the highly secure infrastructure of their OS's package-manager to use something completely untrusted. (yeah, some OS's don't have one, but that is in fact a major reason not to use those OS's.) 
Maybe, but I would say stuff like modules is the bigger deal for compile time. Package managers are more about managing third party stuff, which you generally build ahead of time (once) anyway.
How does vcpkg handle build dependencies? Ie, libflac requires the libogg artifacts at build time
I think a centralized trusted authority for packages will have the opposite effect on platforms that you know, people actually use, like android and iOS. We're a bit past copy and pasting a forked version of libfoothingwhatsit that some random forked and hacked on github for android support dont you think? 
Because this function will explicitly destroy something at a memory location. And the type to represent a memory location is a pointer. I also have a deallocate function taking `void*` where the pointer must not be null.
Per-language package managers are meaningless. They work only in communities that program everything in one language.
 &gt; We're a bit past copy and pasting a forked version of libfoothingwhatsit that some random forked and hacked on github for android support dont you think? I never considered that an acceptable practice to begin with. I think it's okay to use github-projects by pretty much everyone, but it is almost always necessary to at least skim the code. The only reasonable exception I can think of is code from people who I have good reason to trust (be it because they are my personal friends or because the write the kernel of my operating-system and could fuck me up anyways).
&gt; So, OP, I don't agree. Thoughts? That's entirely fair. The counterargument (as pointed out in the comments to the post) is, what do you do in the case of assigning to an empty optional reference? int i = 0; std::optional&lt;int&amp;&gt; o1{i}; std::optional&lt;int&amp;&gt; o2{}; o2 = o1; // ? As far as I can see, the only reasonable thing to do in this case is to rebind (the alternative is to make it a no-op), so then we're introducing an inconsistency. But my point was not to debate the merits of one over the other -- as I said in the post, there are valid arguments both ways, and either way will leave somebody surprised at the behaviour (indeed, from what I can tell this potential for surprise is the number one reason optional references are banned today). My point is that by allowing references in variants, the die has already been cast: `optional` is a special case of `variant`, and so the only possible reasonable behaviour is to follow suit by allowing references, with rebinding. The alternative is the equivalent of having `pair` behave differently from a `tuple` with two members, which I think we can all agree would be terrible.
Tangent here... but I've always wondered why Qt puts a Q in front of everything. Isn't that why namespaces exist?
Yes! We _require_ every library to provide both versions!
We build each library out of the same collection of artifacts it will be placed alongside, which guarantees ABI compatibility.
As I seen right now it just downloads a library archive and build for release and debug with specified configuration triplet (like x86-windows or x64-windows) with MD[d] runtime and it provides a system-wide search within VS (somewhat like in Linux). There is an [issue](https://github.com/Microsoft/vcpkg/issues/36) on this topic. In general it seems that the idea is to always build libraries on developer machine as compared e.g. with conan where libraries can be prebuilt and uploaded on the server (manually from local machine or automatically with appveyor/travis).
It actually is. We've added UDL support, including some things coming with C++14 (not only basic C++11). There is also digit separators coming soon. And hopefully even more with 2016.3 and further versions.
&gt; But hereâ€™s the thing: variant&lt;monostate, int&amp;&gt; is permitted, behaving as if it contained a std::reference_wrapper&lt;int&gt; Are you sure about that "behaving as if" part? I think there are limits on what you can do with the resultant variant. And/or I really hope there are. There was suppose to be. Note that `reference_wrapper&lt;T&gt;` does NOT behave the same as `T &amp;`. That is in fact the intent of `reference_wrapper&lt;T&gt;` - it "normalizes" or "Regularizes" references. If it behaved the same, it wouldn't need to exist. So basically, your argument boils down to "`T &amp;` does _not_ work like `reference_wrapper&lt;T&gt;`, so `optional&lt;T&amp;&gt;` _should_ work like `optional&lt;reference_wrapper&lt;T&gt;&gt;`" Do you see the illogic in that statement? I wrote about this here recently. Somewhat cut and pasted: The question is whether optional&lt;T&amp;&gt;'s assignment should "rebind" the reference, or assign "through" the reference. Consider this case: Foo foo; optional&lt;Foo&amp;&gt; orf = bar.getOptionalFooRef(); Maybe orf now refers to some Foo inside bar, say bar.someFoo. Or maybe orf is nullopt. Maybe on Mondays it is assigned, on Tuesdays it is nullopt. Now do this: orf = foo; // ** Does orf now refer/point to foo (rebind), or does orf still refer to bar.someFoo and thus we just assigned "through" the reference, effectively `bar.someFoo = foo` ? Does it matter whether orf was nullopt before this line? Or does it always rebind? Yes these are tricky and confusing cases. And you might not like the _logical_ answers... Now consider this RefLike class template: template &lt;typename T&gt; class RefLike { T * ref; public: RefLike(T &amp; r) : ref(&amp;r) { } RefLike &amp; operator=(T const &amp; val) { *ref = val; } }; The above is how a reference works (give or take). On construction, it binds to the incoming reference. On assignment it assigns _through_ the reference. Now consider an `optional&lt;RefLike&lt;T&gt;&gt;`. Since `RefLike&lt;T&gt;` is like `T &amp;`, then `optional&lt;T&amp;&gt;` should work like `optional&lt;RefLike&lt;T&gt;&gt;`. _That_ is logical. In particular: Foo foo; optional&lt;RefLike&lt;Foo&gt;&gt; orf = getOptionalRefLikeFoo(); orf = foo; Now it should be clear that orf binds to foo if orf was nullopt, but we get bar.someFoo = foo if orf was previously bound. Is that surprising? Did you want it to always rebind? ie Would you prefer `optional&lt;reference_wrapper&lt;T&gt;&gt;` always-rebind behaviour? If you find `optional&lt;RefLike&lt;T&gt;&gt;` to be surprising, and you instead want always-rebind `optional&lt;reference_wrapper&lt;T&gt;&gt;`, then use `optional&lt;reference_wrapper&lt;T&gt;&gt;`. We shouldn't specialize the _behaviour_ of `optional&lt;T&amp;&gt;`. It should work "as expected" when you logically combine the behaviour of `optional` with the behaviour of `T&amp;`. (We could specialize the storage - the boolean could be replaced by `pointer == nullptr` in this case as references can't be null - but we shouldn't specialize behaviour.) Need I say `vector&lt;bool&gt;`? (The canonical case of when-specialzing-goes-bad) Basically optional only works "sanely" with Regular types. `T &amp;` is not Regular, so you shouldn't be surprised when `optional&lt;T&amp;&gt;` is not Regular. If the behaviour of `optional&lt;T&amp;&gt;` is surprising, don't type it. Type the behaviour you want. Like `optional&lt;reference_wrapper&lt;T&gt;&gt;` or whatever it is. Mean what you say, say what you mean. 
Some quotes by Dan Saks: - "The purpose of social media is to reinforce your own beliefs." - "memcpy is neither easy to use correctly, nor hard to use incorrectly." - "Software Engineers are people too!" - "If you remember one thing, it's this: if you are arguing, you are losing." - "The C Mindset: "Just get the code to compile so we can get to the real work... Debugging.""
&gt; Are you sure about that "behaving as if" part? No, I'm not sure. As I said, I don't have a version of `variant` to play with yet, so I was basing my assumption on the permission given to store references in a `reference_wrapper` in p0033r3 (the latest variant paper I could find). If I'm wrong, then I'm more than happy to be corrected :-) &gt; "T &amp; does not work like reference_wrapper&lt;T&gt;, so optional&lt;T&amp;&gt; should work like optional&lt;reference_wrapper&lt;T&gt;&gt;" My argument is that `optional&lt;T&amp;&gt;` should work like `variant&lt;monostate, T&amp;&gt;` does. If one is permitted then the other should be too, or else both should be forbidden. Having one standardised sum type behave one way and another a different way seems to me to be the worst solution of all. &gt; Yes these are tricky and confusing cases. And you might not like the *logical* answers... We may end up disagreeing on what is logical! :-) But again, the point of that section was not to come down on one side of the other in the debate about rebinding. It was to point out that (perhaps unintentionally) the decision seems already to have been made, by allowing references in variants. 
It's still quite ugly... I wonder why they don't design it in proper modern C++ in the first place... for something as new as Vulkan... At least the header is part of the standard Vulkan SDK and doesn't need to be installed separately.
&gt; p0033r3 http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r3.html or the working draft of the standard (linked from isocpp.org) Note that it says a wrapper, not a `reference_wrapper`: &gt; [ Note: Implementations could decide to store references in a wrapper. â€” end note] My `RefLike&lt;T&gt;` is also a wrapper. IIRC, there was restrictions on `operator=` such that you can't assign a reference, just create one. But reading the standard, there are restrictions, but it is hard to tell what happens to references in all those restrictions. The basic text of variant says that it assigns (if T is already the right type) or initializes (if switching types). That would imply that it a reference should bind the first time, and assign through the second time. But yeah, I working variant would be nice to test with. I've heard they now exist. somewhere.
&gt;It's still quite ugly... I wonder why they don't design it in proper modern C++ in the first place... for something as new as Vulkan... Guess: because we want the same API for multiple languages. Looks like APIs like this will never be nicer because of this.
The last committee discussions I can find suggest that assignment to held references gets sfinae'd away. Or at least that was the intent. But I'm trying to get a more definite answer.
`std::stoi` calls `std::strtol` which in turn calls through to the cstdlib `strtol` which requires a null-terminated buffer as input. `string_view` is not null terminated.
 &gt; The last committee discussions I can find suggest that assignment to held references gets sfinae'd away. Do you mean that the intention is that `operator=(const variant&amp;)` would vanish if the variant contains a reference type? That would at least sidestep the debate about rebind vs copy-through, I guess... I can't see any language requiring this though? Please do give us an update (or feel free to message me) if you get a definite answer, I'm keen to correct my original post since, as you pointed out, I was mistaken about requiring `reference_wrapper` semantics.
i agree. what "optional" seems to do is try to make a reference work like a pointer. a pointer may be null, just like an int may be 0. where to next? how about: boost::dividerable&lt;const unsigned long long &amp;&gt; int_{someint}; if (int_) return 9 / int_; else throw boost::dividerable::not_dividerable; because we must make it abundantly clear the an int may cause a divide by zero. /s 
`[...] we added a new proxy class vk::ArrayProxy&lt;T&gt; [...]` Could we please just use GSL`array_view` instead of reinventing the wheel everytime?
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Awesome! I figured that
If you're a student clion is free and it's amazing.
Started using clion a month ago and it's amazing. 
Does this handle short-circuited evaluation for operators like &amp;&amp; and ||? A quick look suggests not.
Yup, exactly. We'd like people to try it out!
&gt; The Past: Why did C++ succeed? I believe that the slide is absolutely wrong and the two bullet points are not why C++ succeeded. Does anyone know what was said during the talk?
Pretty sure when I set up Clion it installed mingw for me, but I could be completely wrong
I've never had a problem installing a compiler. I've installed mingw, g++, cygwin without problems on both Linux and windows without any problems ever. Clion automatically detects them on the system as well. Just because something isn't spoon fed doesn't make it bad .
Afaik that behaviour was stopped quite a while ago for both Qt and QtCreator
I suggest my [MinGW distro](https://nuwen.net/mingw.html), which is a self-extracting, non-system-modifying, totally simple bundle of the GCC/MinGW compiler plus a bunch of libraries like Boost. I don't use IDEs at home, but I hear about people using my distro with IDEs. (GDB is a terrible debugger compared to VS, but I don't use a debugger at home, so I don't care.)
Code::Blocks + TDM-GCC is pretty light on resources.
â€œThe good is the enemy of the bestâ€œ - What was the context behind that saying? What did he mean by that?
p12: `forward_as_tuple` returns `tuple&lt;T&amp;&amp;...&gt;`, not `tuple&lt;T...&gt;`
&gt; For accessing tuple elements, why not square bracket indexing instead of get&lt;n&gt;, e.g. &gt; t[0] instead of get&lt;0&gt;(t)? That's such a simple question, I surprised myself that I didn't have a good answer. I was going to point to the *"they decided against member functions"* slide, but `operator[]` doesn't need to be a member, I think. 
&gt; tuple is "too-pull", not "tuh-pull" Finally, an answer to this question. Now I can fall asleep. I've been wondering how to pronounce "tuple" for as long as I've known the word.
You can already use indexing with Boost.Hana. `tup[0_c]` or `tup[int_c&lt;nonliteral_value&gt;]` Hana has some pretty neat stuff.
&gt; For accessing tuple elements, why not square bracket indexing instead of get&lt;n&gt; Because templates. Boost.Hana kinda pulls it off by leveraging user-defined literals, but there's no way to just drop an integral value into operator[] for use as a constant expression.
EclipseCDT, it's free, cross-platform, cross-compiler and awesome
What is result type of `operator []` should be in the case? Remember, it should be the same for any value of operator's integral argument.
/u/roschuma managed to pin Neil MacIntosh down in the VS booth at CppCon today so it's there now. :)
&gt; Would there be any added benefit over a struct if there were some additional, optional, name-based access to members of a tuple? You want map from boost fusion.
What makes you say that cdb &gt; gdb ?
I use devenv when I gotta debug at work, don't know windbg. At home I avoid writing bugs.
But is `std` "ess tee dee" or "stud"?
the standard library also uses exceptions
Not nearly as much as using C arrays and strings instead of proper classes though. In fact, writing stateless allocators in C++ is straightforward.
What OP probably meant is that ~~gamedevs~~ some people keep bitching about how exceptions kill their precious performance and how you should be using error codes instead.
[deleted] ^^^^^^^^^^^^^^^^0.0467 &gt; [What is this?](https://pastebin.com/64GuVi2F/43097)
&gt; I've heard that LLVM's Clang++ compiler still loses out to GCC g++ in terms of raw performance so I don't know what that says about LLVM. This is true, but not that big of a deal. Yes clang++ is slower in benchmarks, but it depends on the benchmark (in a few benchmarks clang++ kicks g++'s butt). Both of them will still kick the pants off of MSVC and more often than not icc too. &gt; I forget which company, but some company did dump a lot on money on to the PyPy project and that does make use of Just-In-Time compilation. For most of its common problem domains though I wouldn't say Python is slow per se, especially with the beefy hardware that most modern computer have, just that C++ and the like are much, much faster. I'd say that Python can do most mathematical stuff that I to do quick and dirty, pretty damn fast. Very true, and optimizing python is a much harder problem than Lua, but people are smart and I'm sure the first mature python JITs will be really fast. &gt; Open source project called Mathics Ooooo cool, I didn't know about that. &gt; What do you think of Mathematica and the Wolfram language? I've always wondered how computer algebra systems worked on the inside and honestly I'd be interested in building a small one in C++ to learn more about computer algebra. I think it's really cool, and useful for the programmers who don't really want to actually code what the computer is to do. And you should just do it, compilers aren't nearly as scary as they sound, especially if you use an interpreter instead of compiling to native. &gt; Do you by any chance know how CS or AM grad school works possibly for someone without a BS in those fields? To be frank I'm still a senior in high school, so barely have an idea how college works let alone grad school, sorry. (I also never plan on getting a Masters) 
sorry, but as long as the dictionary says that tuh-pul is a valid pronunciation I will continue to use it!
And even on high-end performance PCs, its debugger is still unbearably slow.
&gt; Remember, it should be the same for any value of operator's integral argument. why?
I personally use KDevelop. I know their last version is compatible with Windows but they don't ship any binaries yet.
"problem in the setup at the beginning" What is it? Visual Studio is a phenomenal IDE, if you can get it to work it is well worth it. I'm surprised you're having problems though; I've installed 2015 Community Edition on several PCs and it is a breeze (just remember to include C++!)
We have had pretty much zero cost exceptions for some time now, the problem lies with how ugly exceptions are.
&gt; C doesn't specify an ABI any more than C++ does How can this be true? Where does cdecl come from? Then we also have stdcall and fastcall that are compatible with C (and supported by all four major compilers?). 
I think what the author meant, for Vulkan APIs to exploit RAII features offered by C++, the C implementation of the API would have to offer reference counting to track handles, in a similar vein how `shared_ptr` works. 
Well the rationale for using exceptions in Vulkan is not because exceptions are fast, it's because they are used to signal aberrant circumstances in function calls, which should happen rarely at runtime. 
IMO `tuple`'s main utility is for storing parameter packs, e.g. as `std::thread` needs to do.
an ess-tee-dee requires antibiotics (or worse)
both Bing and Google translators pronounce it as "tuh-pull", not "too-pull"
Well Notes in the standard are always non-normative. ie meaningless. They are there to point out things that might not be obvious from the real wording (but _are_ still required from the real wording - the note doesn't add anything, just helps clarify.) But when is the standard ever not clear? So you need to read what it says about variant operators to find out what it does with references.
So long as "couple" isn't "coo-pull", "tuple" will always be "tuh-pull" to me.
update: GCC currently assigns-through the reference (ie consistent with RefLike&lt;T&gt;). still working on whether that is correct-wrt-wording and correct-wrt-intent.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [doctest - the lightest feature rich C++ single header testing framework - version 1.1 released!](https://np.reddit.com/r/programming/comments/53tmrv/doctest_the_lightest_feature_rich_c_single_header/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
But it's "tuple" not "touple"...
Not much since most OS are written nowadays in C, however it will become a problem on the OSes that are moving away from C ABIs, like iOS, Android and Windows, or embedded OSes for high integrity systems based on Ada.
A couple other quotes: * "Don't forget: if you are arguing, you are losing." * "What is the most important thing to remember? If you are arguing, you are losing." * "Let me hear you all say: if you are arguing, you are losing." * "If there is one thing you should take away from this talk it's: if you are arguing, you are losing." All interspersed throughout the talk of course. It was a really good talk about social engineering wrapped in the context of trying to get C programmers to start using some C++.
Sometimes feels more like an advert for C++.
Even the lunch and lightning talks?
Good idea, let's switch to PM and my github username is also the same as my reddit UN. 
I always liked to use pointers to signify on the caller site that a passed value, or rather pointer, is going to be changed, opposed to a reference where it might not be obvious at a glance. I can then either pass by value, by const reference or by pointer, depending on what I need. In that scenario, I wouldn't really want to recieve a null pointer most of the time, which would make some protection against that really useful. Would you, however, say that that kind of practice isn't really recommended? I mean, I don't use it often anyway as returning a variable is much clearer and cleaner, but in some cases it seems rather advantageous to me. I am not that experienced a programmer, so I'd rather know how to deal with that properly. :)
I've always pronounced it teuple, (tchoo-ple) ;_;
Caveat: I was pretty tired from travelling the day before, so I don't recall every detail. First, there were two areas of the past where C++ succeeded: Initial adoption and "post slump" (2008 and forward). Secondly, Bjarne didn't spend a lot of time on the subject (as far as I recall). The presentation was more about the challenges of C++ moving forward. Recalling success is important in the discussion, but not something he needed to spend lots of time on. &gt; Not by following the herd So the herd really did things different in both time periods: * Initial adoption: most languages designed at the time were incompatible with each other and chose a more pure implementation. COBOL was incompatible with Fortran. C was incompatible with both. While C was syntactically similar to BCPL, it was incompatible. C++ aimed to have compatibility with C and offer mixed paradigms: Simula 67's OOP and C's procedural paradigms. Backwards compatibility definitely went against the herd as well as trying to mix paradigms. Simula 67 did mix paradigms some, but not nearly as much as C++ did. Other popular language at the time rarely mixed paradigms. * Standardized C++ (which led to post-slump popularity): templates, STL, RAII, achieving low level access with high-level zero-cost abstractions. These were definitely against the herd at the time and still somewhat against the herd. Many languages refuse to adopt many of these features and those that do are really trying to 'make a better C++'. The power of these features though allowed safer and faster code which led to greater interest from different fields. &gt; By answering questions before people asked them. So I don't recall this being discussed at all, and I don't like the statement as it is worded, but I think the idea is more along the lines of "the language had features to solve problems before people realized there was a problem". For example, the use of RAII to manage complex resources and its ability to implement things like scope guards. Another example: template meta-programming. Once people discovered the power behind the combination of language features, it really perked some people's interest. &amp;nbsp; Later on in the talk, Bjarne discussed balancing backwards compatibility with innovation. To really be successful, you not only need both, but need to be able to break both a little bit. One point about backwards compatibility was how `auto x{17};` currently causes x to be an `std::initializer_list&lt;int&gt;`, but moving forward it will be `int`. This can break some code out there, but it is a necessary change for innovation. Anyway, I hope that gives some background.
Thanks for the info. I had to travel home yesterday just before the lightning talks began, so I'm happy to hear they were recorded.
I've been using this since release and it has worked wonderfully :)
I always pronounce it as "stid"
That would break due to endianness.
Yeah, it was whether a function may modify an argument passed to it. You're right that it's possible to use either reference or const reference to make a clear distinction, but I always thought that having a clear &amp;argument when calling a function is just so much clearer in that regard. If the general consensus is rather to stick to the reference/const reference distinction, and you'd just have to look at the function's signature more in-depth to see whether the function may modify your variables, I think I should probably adapt that style too to make my code easier to understand for more people. 
&gt; How can this be true? Stuff like stdcall and fastcall isn't specified by C, nor really anything about ABI. There is at least a defacto standard ABI on any given platform, but it's not something thats actually required by the C Programming language standard's specification document. &gt; Where does cdecl come from? It comes from Microsoft. It's a platform specific thing. The MS documentation for it specifies in bold that it's "Microsoft Specific" : https://msdn.microsoft.com/en-us/library/zkwh89ks.aspx 
The issue is that you did not provide specifications file. It contains instructions for server what files to take etc. Check out your [notifications](https://cppan.org/onqtam/notifications). At the add version page you should click 'Use custom cppan.yml' checkbox at the bottom of the page and put there cppan.yml contents. Or you could add cppan.yml into your github repository and server will handle it for you. cppan.yml contents for your project can be found at [page](https://cppan.org/pvt.cppan.demo.onqtam.doctest/version/1.1.0) at the bottom. Just click 'Spec file: cppan.yml - Show' to show contents. Version will appear almost instantly (5-10 sec.).
I am a little confused about why I got downvoted for this comment, and I'd love to hear what folks think I am wrong about to gain some extra clarity. The Vulkan standards committee has said that C++ wasn't a practical option in part because of ABI issues. On Windows, mingw and MSVC use different ABI's and libc++, and libraries aren't automatically compatible between the two compilers. And different MSVC versions aren't even consistent. But an app using Vulkan needs to be able to talk to a global Vulkan implementation on a system with a consistent ABI since it's basically talking directly to the GPU drivers. You can easily ship multiple builds of something like Boost for various MSVC versions and apps will build with whichever they need. But you can't ask a user to install new graphics drivers depending on whether they want to run an app built with MSVC 2013 or MSVC 2015. So, the C++ ABI isn't particularly stable over time or across implementations, etc. The spec for the C programming language doesn't specify an ABI either, but in practice all compilers on a platform interoperate with C much more easily than C++. So, Vulkan specifies a C API rather than a C++ API. And I lost some magic Internet points.
That was an excellent read. Especially liked the notion of phantom types!
Hold on, I'm confused now. If a function accepts a variable by const ref, it can't modify that variable, why would you need to look closer? 
The idea is that even though the template parameter never appears in the body of the struct, it changes the actual type of it. So if we have something like template &lt;typename T&gt; struct Input { string value; }; and two dummy structs struct clean {}; struct unclean {}; you can restrict your sensitive functions by declaring them to take as input values of type `Input&lt;clean&gt;`. As long as the only way to create a value of type `Input&lt;clean&gt;` is by passing a value of type `Input&lt;unclean&gt;` to some sanitizing function, then you will never run the risk of putting unescaped data from the user into your SQL database. The template type parameter T is kind of like a ghost: it's there, but it doesn't actually affect anything in your program at runtime. Hence a phantom type.
Just a tip: "single header" is not a feature, it usually implies in slower compilation times (because it gets compiled repeatedly)
[Here's a GitHub readme-like version that should be more friendly on mobile](https://github.com/elbeno/accumulate-fun/blob/master/presentation/presentation.org). NOTE: I'm not the presenter. I'm just trying to share what is publicly available so far.
Meanwhile I'm sitting here at 5-30 seconds of overhead with Catch. I'll have to give this a shot.
It prints out: **Hello World** // (from inside second recursion) **World Hello** // (from inside first recursion) **Hello World** // (from inside first normal function call) Which is expected, no?
Each time you call a function you get a new set of arguments. The `one` argument in the first call points to "Hello", while the `one` argument in the second call points to "World". As long as both stack frames exist, both variables exist at the same time as well. They are independent variables because they belong to separate invocations of the function. The same applies to local variables, btw. 
I'm curious as to why you chose to create doctest as opposed to improving Catch?
The same question was [raised 4 months ago](https://www.reddit.com/r/cpp/comments/4kibl4/doctest_the_lightest_feature_rich_c_single_header/d3fk4fe) when I released version 1.0 sometimes a reimplementation is the more practical choice...
hi everybody. Steve (co-presenter) here. Happy to answer questions.
"single header" is a major feature (or even requirement) for a lot of people! Besides, OP put a lot of care into very fast compile times.
empty_bases is unfortunately bin compat breaking so we can't do it with a compiler flag until the next version where we break bin compat. (permissive is just source breaking)
If you have proper integration tools of 3rd party libs, "single header" don't play much role.
it gives you the *option* to have it use exceptions. I don't see how that's any sort of argument for their speed, they're just letting you handle errors the way you prefer.
"Tuple" was used by mathematicians long before anyone ever heard of C++ (or C). In my experience, it's always been tuh-pull. Source: picked up a couple of math degrees in the 80s.
That example always gets you the you the arithmetic b^th bit (that is, in least significant to most significant bit order), if and only if n is positive. But if/when you write that int out in the network or to disk or whatever, where that bit is located in the data stream is going to be different depending on the system's endianness. That is, bit 1 on a little endian machine would look something like: 00000010 00000000 00000000 00000000 but bit 1 on a big endian machine would look something like: 00000000 00000000 00000000 00000010 (If all you care about is storing in-memory flag bits then that's OK; but in that case why not just use a bit field?)
I really like the presentation. I just don't know how to navigate on it properly. I press down and it doesn't go. I press right and it goes to the next slide, but then I have to press down to go to the next one because right doesn't work anymore.
I used this for a personal project I started recently due to its simplicity compared to the alternatives. It's the closest thing in C++ I've found that mirrors D's unittest feature which I got used to. Thanks.
Two phase lookup will be behind this switch
Correct, VS "15" (as you can see in Preview 4) contains a 19.x compiler and STL that are bincompatible with VS 2015. At some point we'll ship the "WCFB02" STL and 20.x compiler that I've talked about elsewhere, which will be thoroughly bincompat breaking and able to hardcode empty_bases and so forth. We haven't finalized when/how they will ship, but they won't displace the default compatible toolset in VS "15".
Since references can't be null, optional&lt;T&amp;&gt; (if the standard allowed it) could be internally implemented with just a pointer, using nullptr to mean an empty optional. But for probably all other X, optional&lt;X&gt; requires an extra bool.
Note that even for other cases than reference types, there have been talks over the years on the boost mailing list for supporting an easy way of hooking into boost::optional such that you have a tighter representation for a given type with bits to spare, though no such mechanism has made it into a release. It's certainly possible to conceive of such an implementation, though.
Essentially the same demo can be found in [Episode 19](https://www.youtube.com/watch?v=nLv_INgaLq8) of his C++ Weekly videos. Also here's the [repository](https://github.com/lefticus/presentations/tree/CppCon2016/RichCodeForTinyMachines) accessible via the TinyUrl link in the presentation. I tried getting Final.cpp to compile but it looks like tuple assignment isn't implemented by any of the compilers available on gcc.godbolt.org.
Sounds like a fancy name for what I've always called a "tag" type.
Yes please.
I'm not entirely sure how this manages to be constexpr, but wouldn't the [index function](http://en.cppreference.com/w/cpp/utility/variant/index) do that? 
[This one](https://www.reddit.com/r/programming/comments/52e8nz/diagram_of_cpurelated_operation_costs_from_memory/) might give you a rough idea. In real world it would also depend on how much CPU time your code is spending on calling those functions rather than actually executing its contents.
Thank you.
Thank you for the details. Given our design and code base, I am not sure if we can remove the dynamic memory allocatiosn. We do avoid dynamic casts as much as possible. The current debate in the team is right now about the overhead of "virtual" and if we should avoid it.
Thank you, yes I think we can try profiling and see it how much time the virtual function takes to complete.
This is a [pretty good talk](https://www.youtube.com/watch?v=nXaxk27zwlk) about trying to profile small things.
Just a tip: here in the 21st century, we have precompiled headers.
Ahh I see. Well, you need to know what type to pass anyway, doesn't seem so much extra to add constness to that prerequisite. 
You can do the exception handling without a macro now by putting the body in a lamba and passing that to a function that implements the exception handling
I hope heâ€™s not serious about telling people to re-implement std::all_of and std::any_of, etc, with std::accumulate.
Virtual function call is also yet another data driven branching, because the execution branch is chosen at runtime based on the type of the object that the function is called on. In modern architectures, data driven branching can have devastating effects on performance, so avoiding is really crucial if performance is the primary objective. This post is a good demonstration: http://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array.
By the way, I was surprised, that clang (and not gcc, unfortunately, when I tried it on godbolt) inlines even polymorphic loops and calls to std::function containing function pointer.
From a few practical examples: - Program that reads a bunch of file names and files. I was expecting performance issues in directory access, or file reading because I was copying every byte from every file multiple times. Nope, profiling showed me that 50% of my performance was eaten by std::string::find, which I could get rid of fully by doing strstr instead (as strstr here was SSE optimized, but std::string::find wasn't). - Have a program that does a full crossproduct between all tags in an XML file and all possible outputs. Performance was limited by actually compiling in debug mode; release mode was 30x faster. - One program to read an OpenStreetMap XML file. I had a bit of processing and tried to find out what caused it - it's actually 90%+ the XML library overhead. Note that in all my examples so far, and all examples I can think of that are less easy to explain, I haven't ever considered virtual functions to be a problem, and in no case was it ever the problem either. Virtual functions are a solution to a problem, and they're a *good* solution to that problem. That implies that if you're using them and you need them, you won't be getting rid of them anyway. If you're using them and don't actually need them, why did you add them in the first place?
Clang with libc++ or libstdc++? If the former, then the compiler is not necessarily to blame...
Wow, 82 points! Hey Mr BigDeal! Take this downvote, will ya? 
ah, got it, thanks :)
derp! i missed that. thanks!
[deleted] ^^^^^^^^^^^^^^^^0.3536 &gt; [What is this?](https://pastebin.com/64GuVi2F/42898)
What exactly do you mean by a polymorphic loop?
Measure. Most of a time the bad performance of a program does not come from where you would think. I'd say a virtual call is probably an unlikely suspect, a bad algorithm or bad access pattern are more likely. But, it really depend on you particular case. you can replace a virtual call either by some template machinery in some case or by implementing your own vtable like system. It may increase or decrease the performances depending on your case. In release mode, in some cases, the compiler can remove the virtual call for you. Be sure to test the performance with a release build. Most importantly. Are the performance actually an issue for you ? don't try to over optimize something that does not need to be ( not executed often, etc ) 
And Free as in Free Beer, not as in Freedom.
To be fair: I think the game developer part of the PHP Community is probably smaller.
To be frank, I've seen far more presenter issues with reveal.js than with Powerpoint. It is also very difficult for archiving slides.
&gt; Virtual methods are only slightly more expensive than non-inline regular function calls. They were designed in the early 80s as an alternative to C-style function pointer tables that had to be managed manually. They basically have the same performance. Just to clarify, it's basically going to be something like one extra cache hit (this-&gt;vtableptr-&gt;functionIWant() ~ approximately?) on non-multiply inherited stuff right? At least in what I imagine to be "sensible" implementations? I mean there might be way more that I'm not considering.
I sure hope so.
I think you just made these up yourself. I was curious about examples where people were bitching.
If you don't use IDE to write code what do you use? Is it Vim or something similar? I would say quite strange for a Windows developer :)
I'm currently trying to implement doctest in my C++ project, but I'm having some trouble. This might not be the correct forum (is there an official help forum?), but anyway. Is there any way to write tests inside a class declaration or definition? This doesn't work #include &lt;doctest.h&gt; struct MyStruct { static int addition(const int a, const int b) { return a + b; } TEST_CASE("testing addToInt") { CHECK(MyStruct::addition(1, 2) == 3); } } I just get a lot of errors, the first of which is /home/username/code/doctest/doctest/doctest.h:1131: error: field initializer is not constant doctest::detail::regTest(f, __LINE__, __FILE__, name); It works if I move TEST_CASE() outside the class definition, but I'd rather have it as close as possible to the function I'm testing.
Don't know - whatever https://gcc.godbolt.org/ uses with clang.
&gt; Virtual functions get you infinite extensibility of the class hierarchy. Do you need that? This is a good point, `std::variant` is just one example of the tricks you can pull off, as long as you're willing to spell out all the possibilities in one place. The trouble, usually, is that taking advantage of such information requires either a lot of boilerplate or template metaprogramming. Unfortunately, most C++ programmers are either scared of or dislike TMP.
Also, please, oh god please, merciful C++ compiler lords, bring us [p0255r0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0255r0.pdf)
You were downvoted because nobody insists on C++ as a library API. Vulkan-HPP is a header only wrapper around the C APIs and it should have RAII and move semantics.
Sadly, the only *good* alternative is XCode.
Ah, but you can compile C++ to JavaScript for outdated browsers and portability. The only reasons I can think of in defense of JS are development time and code size. Both are invalidated when the code base becomes too large and the glue code between C++ and WASM is only half the size of the application. (The amount of glue code will hopefully be almost zero when WASM is statndardized.)
You just can't see by looking at a function call whether it's a pass by value, by const reference or by reference. You have to look at the function signature. Otherwise you'd always know that something you pass cannot be modified, unless you pass a pointer to it, because non-const reference just wouldn't be used. It would either be a copy or an unmodifiable const reference. I'm not sure how to put this, I guess I'm not that good at expressing this.
The static reflection proposal is awful. This one, at least, has a nice syntax and every feature can be used with one liners.
It is unlikely that it will be an issue, and it's hard to know what you would do instead. Typically if you care about performance, you'll be doing something very many times. Speed up that something (and/or do it fewer times) and that will be your main improvement. And you need to profile, no real way around it.
I had similar issues on desktop. I hit right arrow to advance to the next slide, and thought the whole presentation was 8 slides with zero information. It turns out right arrow just skips to the beginning of each part, then you have to hit down arrow to navigate the part, then right arrow to go to the next part when done... except that if you use right arrow on a slide with transitions, it goes through each transition, then jumps to the next part once there are no more transitions. The keyboard shortcuts are a UI disaster. 
That's not what he said at CppCon. He wanted to understand the flexibility and possible applications of std::accumulate. In trying to understand its power, he wondered which standard algorithms he could write in terms of accumulate and he found he could implement the vast majority. He did mention that these are not necessarily always the most efficient implementations, nor the most straightforward implementations. He was just trying to learn.
Lots of "it's complicated" answers here. Bit of a cop out. ;-) I do agree completely that if you are trying to optimize, you should never theorize, but always do performance measurement and be guided only by that. That said, while virtual function calls cost somewhat more than a regular method call, their cost is still tiny. If your program were so optimized that devirtualizing some method calls actually resulted in an observable improvement in performance, my hat would be off to you. As is pointed out elsewhere here, there can be secondary "knock-on" effects of the compiler being unable to inline functions called through virtual methods - it isn't just the cost of looking up the operation in a table somewhere - and your mileage may vary - particularly depending on how often this method is called and how small it is. In my experience - and remember, this is just a rule of thumb, measurement trumps all! - here's a rough order of "places to optimize". 1. Your underlying basic algorithm. 2. Avoiding unnecessary object creation and unnecessary copies. 3. [Locality of reference](https://en.wikipedia.org/wiki/Locality_of_reference) - very roughly, "keeping everything in one honking chunk of memory and not scattered all over your address space." So measure, measure, measure. Everything else is just guesswork. However, I wouldn't even consider devirtualization as an optimization until I was forced to do so by having eliminated everything else - and even then I wouldn't expect to see substantial performance gains by doing so.
Thank you very much for the details.
This debate is wasting your time. Without hard performance data, you might as well be counting angels on the head of a pin.
&gt; Virtual methods are only slightly more expensive than non-inline regular function calls. Well... that's only partly true. Non-virtual methods can be inlined, and that might result in significantly greater savings. More, when loading the function addresses from the vtable, you might thrash your instruction cache fairly badly if there are many actual implementations of the virtual base class all competing for that limited space.
Take a look at https://github.com/aws When you have that many languages to support. It's nice to have similar APIs as much as possible. Sometimes, this means that your API won't be idiomatic in the language. They do a good job of trying to be idiomatic in every language and they do use newer features of languages. But the public interface assumes very little about what you're using.
I would like to point out that using the C API to implement the API in another language is an implementation detail. Of course, that's what people usually do because it's so much easier than the alternatives. But it hardly dictates what the interface of the API is. That is a choice made by the developers so that they don't have to maintain 15 very different APIs in 15 languages that do the same thing. The *biggest* thing for me when devs do this is that you really need one source of documentation for most things and it's trivial to follow it in your language of choice.
Ah, yes, this is true. "bit order" is usually irrelevant.
check out [this blog post](http://baptiste-wicht.com/posts/2016/09/blazing-fast-unit-test-compilation-with-doctest-11.html) (or look at my edit of this reddit post)
Is the cygwin dll in your system path? 
This is a very bad question. * How much of your total time is spent in call instructions? If it is very little, making it smaller won't help much * Yes, there is a price to a virtual call, but there is a price to achieveing the same in some other way. Either way, one has to measure. Without measurement, one can say this: unless your function body is very small/fast, you will be unable to tell the difference.
Is this for a game? If you are just wanting to play with OpenGL, you'll be using OpenGL libraries anyways. You may as well also use SDL or Qt to get a window open with a usable OpenGL context. From there you can work on your engine with your own code.
For starters, you are going to need a cross platform graphics library. Are you planning on using straight OpenGL? There are some more high level OpenGL wrappers out there. Once upon a time I wrote some game code using SDL with OpenGL. SDL provides some cross platform techniques for creating windows, handling keyboard/mouse events, and has a few other nice add-ons to support image loading and text rendering for example. SDL is pretty light weight. I recommend using OpenGL with SDL, SDL provides basic 2D support, but you can do much more and faster with OpenGL (think rotation, scaling, tinting, large number of on screen objects). Next, I think you need to decide what kind of 2D physics you want. I assume you are going to be implementing physics/collision detection? Are you planning on a pure tile-based engine, or can terrain/objects be shaped as arbitrary polygons? Tiles are pretty easy to implement from scratch, but polygons get pretty complex, you might want to look at an open source 2D physics engine for this. Finally, a few tips I can give after working on a few engines and looking at other engines. Most have the concept of a "scene" object (represents the 2D world, graphics/objects can be added to the scene, and it handles things like physics and rendering). They also have the concept of "entities", which are generic objects that can be added to a screen that have interaction logic and physics properties (OnCollision events, On(whatever) events, x/y velocity, x/y position, friction, elasticity, etc). 
Surprised that there's not much discussion in these replies about the devirtualization optimizations that we've seen added to compilers in the last few years. 
&gt; auto x = {17}; You are thinking about `auto x{17};`. `auto x = {17};` is and will remain `std::initializer_list&lt;int&gt;`.
We've already had someone contribute stb, so you can see the current portfile here: https://github.com/Microsoft/vcpkg/tree/master/ports/stb. Libraries that don't have releases require the packager to determine what is appropriate for a "latest stable". GitHub is awesome and provides zip files for every commit, so there's no issue with archive availability. As for using stb-like libraries, we purposefully try to avoid changing how the library works for users; if you have code that works today with your own copy of stb, it should work with vcpkg's stb.
DÃ©jÃ  vu.
What makes you think that there's no branch in a virtual function call? Please look at this paper that describes virtual function call impact on branch prediction in great detail: [The Direct Cost of Virtual Function Calls in C++](https://www.cs.ucsb.edu/~urs/oocsb/papers/oopsla96.pdf) (chapter "2.3 Branch prediction").
http://www.catnipcamera.com/wp-content/uploads/2013/03/High-Res-BW-016-1400x916.jpg
&gt; dynamic memory allocation itself is quite slow Relative to a single virtual call, sure. In the overall scheme of a typical program's life. When I redid our `to_string(int)` for string adding 1 divide in to_string had a far bigger impact than std::wstring's memory allocation. The user needs to profile things to find out where they matter.
In the context of the question, I think Chandler is referring to the acceptable waiting time for uninterrupted flow of thought, which is generally [ballparked at 1 second](https://www.nngroup.com/articles/response-times-3-important-limits/) (where the 600 ms figure comes from I couldn't say). So he would be arguing that compile times are still way too long even with modules.
The [Doherty threshold][1] puts it at 400 milliseconds. Perhaps Chandler was thinking of that when he gave a specific number in milliseconds and just got the number wrong. [1]: https://medium.com/@Gugel/the-doherty-threshold-5471ca990de6#.1ovlnhg2m
watched this talk earlier, thought it was very good. Nice to see Bjarne was pretty frustrated at lack of major progress in c++17, but it does make me a little uneasy that he seems to be gung-ho advising people to use non-standard stuff from bleeding edge compilers, even if much of it will be eventually standardised. We ALL want concepts, modules, etc, but, as a jobbing developer as well as an enthusiast there's no way I'll be investing too much effort in these implementations until we have a better idea of what it will eventually look like in the standard
It's more for when I come back to a piece of source after a while. I can then instantly see what a function can do to the variable rather than having to check every function signature used. But now that I actually think about the problem, I don't think I ever actually see code that modifies a parameter, be it via pointer or via reference. The performance boost just isn't worth the loss in clarity and readablity. Looking at it that way, I feel like my reasoning is more about a niche case not really worth changing my coding style for.
Personally, it seems more worthwhile to have `[[attribute]]` equivalents of all the declspec extended attributes.
I don't like the fact that he is trying to kill macros with modules. I find macros one of the best features in c++ 
This is probably quite pompous of me to say about him but â€” I'm not entirely sure if he's aware how much flexibility macros add. I used to use D a lot and it had *so* many metaprogramming abilities. CTFE, template metaprogramming, template mixins, and just straight out string mixins, plus essentially the proposed C++ module system, etc. And I still often missed plain macros which weren't available. For example, it would never be possible to do something like [this](https://github.com/solodon4/Mach7) in D(as cleanly as Mach7's syntax is, that is) without macros. IMO the correct replacement for macros are hygienic AST macros. I believe, but I'm not entirely certain, Rust macros operate like this.
one tip: - use final when a virtual function will not be overridden anymore. If your current pointer is of the derived type where the method is final, the compiler can optimize away the indirect lookup and it just becomes a regular function call - which the compiler may then actually decide to inline. 
[[0:00:00]](https://youtu.be/CPgxw1EzC54) - Introduction [[0:05:16]](https://youtu.be/CPgxw1EzC54?t=317) - What new feature of C++ helped you in a way you hadn't anticipated? [[0:10:45]](https://youtu.be/CPgxw1EzC54?t=645) - What is your favorite feature of C++17? [[0:12:25]](https://youtu.be/CPgxw1EzC54?t=745) - There were a number of features considered doable for C++17 that didn't make it. What happened between then and now? What are the expectations going forward? [[0:15:01]](https://youtu.be/CPgxw1EzC54?t=901) - Do we need a GUI library? When do we get it? [[0:17:31]](https://youtu.be/CPgxw1EzC54?t=1051) - Is the barrier of getting items into the standard a resource problem or more of a concensus problem? Thoughts on solutions for whichever problem is more common? [[0:22:45]](https://youtu.be/CPgxw1EzC54?t=1365) - How should educators go about teaching C++? Should educators start with C++14 and move into C++17 during the semester? Start with C++17 now? Just teach the core C++? [[0:26:01]](https://youtu.be/CPgxw1EzC54?t=1561) - The data driven design community has had complaints about how C++ is becoming bloated and not implemented elegantly. Is there a plan to move to a new standard library (std2)? [[0:32:18]](https://youtu.be/CPgxw1EzC54?t=1938) - What characterizes Modern C++ from previous iterations of C++. Can you apply modern techniques to older iterations? [[0:39:39]](https://youtu.be/CPgxw1EzC54?t=2379) - What is a decision you would have gotten wrong had the community not saved you? [[0:42:48]](https://youtu.be/CPgxw1EzC54?t=2568) - Thoughts on standardized tooling? How about providing an API for tooling? [[0:47:40]](https://youtu.be/CPgxw1EzC54?t=2860) - Status of multi-methods? Is there a hang-up with the committee when it comes to complicating the linker? [[0:50:06](https://youtu.be/CPgxw1EzC54?t=3006) - What C++ features have you seen other languages take inspiration from? What features has C++ taken inspiration from in other languages? [[0:52:28]](https://youtu.be/CPgxw1EzC54?t=3148) - Which C++ feature would you like to see available tomorrow morning? [[0:58:00]](https://youtu.be/CPgxw1EzC54?t=3480) - What are the new goals for the renamed Graphics study group? What help does it need from the community? [[0:59:37]](https://youtu.be/CPgxw1EzC54?t=3577) - How can the community help the committee? [[1:04:44]](https://youtu.be/CPgxw1EzC54?t=3884) - How can we make C++ viable for embedded/constrained environments? **Lightning Round** Answers must be in 5 words or less. [[1:16:57]](https://youtu.be/CPgxw1EzC54?t=4617) - There are points being specified in the C++ standard that were left unspecified/implementation defined in C. Is this something we can look forward to more? [[1:18:19]](https://youtu.be/CPgxw1EzC54?t=4659) - FPGAs and C++ compilers. Bad idea? Very bad idea? [[1:18:57]](https://youtu.be/CPgxw1EzC54?t=4737) - With modules, compilation speeds will improve. Should we look to rebudget the savings to more specific type deduction, look at developing a more convenient grammar, or do nothing and enjoy the improvement. [[1:20:15]](https://youtu.be/CPgxw1EzC54?t=4815) - Does the numerics working group have interest bringing in integration routines, optimization routines, root finding, etc? [[1:22:15]](https://youtu.be/CPgxw1EzC54?t=4935) - If you capture by value with a lambda, it captures CV qualifiers. Capturing with an initializer doesn't. Why? [[1:22:56]](https://youtu.be/CPgxw1EzC54?t=4976) - In the new constructor deduction of constructor parameters, how does that work with partial specialization. [[1:23:40]](https://youtu.be/CPgxw1EzC54?t=5020) - Is there a mentoring process for getting a paper proposed. [[1:24:29]](https://youtu.be/CPgxw1EzC54?t=5069) - Will the IS of Concepts and Ranges happen together or would Concepts need to be standardized before Ranges? [[1:25:09]](https://youtu.be/CPgxw1EzC54?t=5109) - Is STL2 allowed to fix `std::max`? 
With respect to, &gt; struct clean {}; &gt; struct unclean {}; Is there a reason to not prefer a scoped enum here instead? e.g, enum class Status{ Clean, Unclean }; template &lt;Status&gt; struct Input { string value; };
Generally, what are the costs of using std::variant? I've used it before but never looked a it's implementation details too hard.
Thanks, a friend of mine did a lot of magic. I'll see how I can change the font though.
Aha, I understand. This is probably a good excuse to clean up where I've been lazy, and move my definitions outside of the bodies. I have one more question though, about the example *[dll_and_executable](https://github.com/onqtam/doctest/tree/master/examples/dll_and_executable)*. It seems like TEST_CASE in *common.h* is run twice when I run the executable. Is this a bug, or is there any way to avoid that? Also, all the tests are run twice, but that went away when I removed the call to *context.run()*: // int res = context.run(); // not necessary..? int res = call_tests_from_dll(argc, argv);
Paging /u/chandlerc1024
Tests shouldn't run twice - only the test in the header should run twice (but indeed the version of doctest and the summary is printed twice - this is because each binary (the exe and the dll) has it's own test runner and there are 2 contexts invoked). The executable and the dll both have a test that is exclusively theirs. notice [here](http://pastebin.com/raw/S5FGYRP2) that first it prints ```I am a test from the executable!``` and then ```I am a test from the dll!``` The whole point in that example is to show that binaries (like executables and dlls) need to each have a test runner implemented in them - and this is how to call each other's runner. I might add a feature to 'transfer' tests from one binary to another - so the test in the header gets run only once in this case. If a test is written in a header and used within one binary - it will be registered only once - see [here](https://github.com/onqtam/doctest/tree/master/examples/multi_file_example).
In my experience the only real performance benefit you're gonna get from making a function non-virtual is the fact the compiler can possibly inline it. The actual call instruction cost is negligible. Any branch prediction and caching issues from virtual functions will still be there because you have to somehow do the same thing with ifs/switches/tables or whatever. Of course inlining can have a significant impact. The biggest question is just how often the functions get called and how long does it take to execute the body. In the most ridiculous worst case scenario where you are doing nothing but calling a virtual getter function in a loop I would expect ~10x difference between virtual and non-virtual (assuming compiler doesn't know the final type). In any practical application, I've never seen more than 50% boost from inlining a single function. In a *typical* CPU bound application probably less than 10%. 
&gt; I don't like the fact that he is trying to kill macros with modules. The committee isn't trying to kill macros with modules. What they want to do is prevent macros from being visible through modules. From a technical standpoint, this makes a lot of sense. Modules are a compilation artifact. Macros are a preprocessing mechanism. From a consistency standpoint, keeping macros from escaping modules will help reduce uncertainty in resulting code generation. While there is a lot of sentiment that having macros be visible (or exportable) from modules, there is good reason for the current viewpoint too. And remember, if macros aren't currently visible outside modules, that functionality can always be added on later if there is a strong desire for change in the community. The good news is that macros and modules can still be mixed. It's just that macros will have to be #included instead of #imported (or explicitly #defined of course).
**EDIT:** More exactly, I get this error main.o: In function `__static_initialization_and_destruction_0': /home/&lt;username&gt;/code/build-gas_flow++-Desktop-Debug/app/../../doctest/doctest/doctest.h:1617: undefined reference to `doctest::detail::setTestSuiteName(char const*)' I'm using qmake. --- Okay. Then I know how to structure my tests. I'm compiling a dll, so I'll probably have a separate executable just for running tests. Thanks for all your help so far. I'm having some trouble integrating doctest into a large project of mine though. I keep getting the error /home/&lt;username&gt;/code/doctest/doctest/doctest.h:1617: error: undefined reference to `doctest::detail::setTestSuiteName(char const*)' I've been trying to reproduce the error in a minimal example, but I've been unable to so far. I'll try some more if you don't have any suggestions.
Interesting panel, only annoyance is that the sound volume difference between the panel and audience was a bit too big. edit, looks like it got a bit better after 00:30
I see modules more about solving build system issues and less about macros.
I pronounce it as /tjupl/
All schools(till grade 12) in India teach Turbo c++ as it is required by the education board here. So you are talking about over hundred thousand still learning that. Me included (well for school, I use g++ at home). It is ridiculous. 
From your GitHub profile I can see that you are working in a computer vision industry (I suppose German automotive sector). For me it would be very interesting to know if you are able to use **FunctionalPlus** where you work?
That's nice to know and I'm glad it's like that ... The reason I asked this question is because my experience was actually the opposite (but I was working in German automotive industry). Unfortunately, experience has shown that people usually run away from anything that has something do with TMP code and not to mention functional style programming. Thanks for the reply ... keep up the good work :)
No, it was not FunctionalPlus that I was trying to introduce but it was rather usual template techniques that I wanted to make use of in order to advance the system architecture but more importantly to implement SQL domain-specific-language (one of the subsystems was obviously handling the DB and it was quite complex). I've managed to make it through but after a lot of discussions with the team ... This was just my experience and after I saw your post and your professional field, I thought what the heck ... it must be that I haven't been lucky enough to run into the right team :D P.S. I am not sure who is down-voting us and for what reason. It's silly.
FunctionalPlus also provides sets_intersection : [Set a] -&gt; Set a but I left it out in favour of `fold_left_1` to present a fold. Still, you win at golf. ;) std::string process(const std::string&amp; input) { using namespace fplus; typedef std::set&lt;std::string::value_type&gt; character_set; return show(size_of_cont(sets_intersection(transform( convert_container&lt;character_set, std::string&gt;, split_lines(input, false))))); }
No real reason. Any kind of template parameter should do, as long as the cases you want to cover are uniquely determined by the values it can take on.
May I counterattack with [Haskell](http://ideone.com/wZa1CB)? ;) length . foldl1 intersect . map (nub . sort) . lines
That makes sense. Thanks!
Ok, if one omits parsing then it boils down to len(set.intersection(*map(set, lines))) in Python ðŸ˜‰
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Oh wow I just read about that effect
&gt; people usually create header-only libraries because of laziness in creating a proper library That's funny, I have the opposite experience, everybody I know doesn't think about it and the missing knowledge and "laziness" leads to "just" creating a standard library. Everybody learns about .cpp and .hpp files even in their first C++ lesson, so that's what people know. &gt; Why would single header be a feature or requirement? See my post below, it's hidden because the user I responded to got downvoted to -6 ;-)
And on top of that it's still not properly cross-platform...
&gt;the advantage of Concepts Lite constrains: they can be applied not only to templates, but also to non-template members of class templates WOOHOO! That's awesome. As someone who has only been using C++ for a few years on a hobby project, this was a really good article. Sometimes the documentation and papers surrounding C++, especially new features, can be very difficult to understand and I thought this article did a great job of explaining concepts lite. 
Thanks! I think I figured out the cause for that error, but I'm not really sure what I did.
You are right. Most ML derived languages (e.g. Haskell) use similar annotations.
You can find the real slides on https://github.com/CppCon/CppCon2016. It will probably be uploaded soon.
Now multiply the number of characters in the code by its execution time? ;)
Herb Sutter's Garbage Collector presented in the keynote: https://github.com/hsutter/gcpp
Thanks for the live coverage throughout the week. It's pretty awesome for people who can't attend CppCon and can't wait for the video and slides to be uploaded fast enough. :-)
Me tu... shit!
The videos are going to be posted eventually, right?
I can only add that in case if both static and shared libraries are present it may be necessary to add -static to compiler options. Caveat: the exact option may vary among compilers; this advice is valid for gcc, clang, pcc and tcc compilers.
And there's no chance that implementations have changed/improved in the last 21 years..?
At my first university the official compiler was VC++ 6.0. Transferred to another university. First class was introduction to Linux, command line and how to use GCC. It's so obvious to me that the second approach is way better.
I'm curious, what happened with Howard's proposal(s)?
It's constexpr _iff_ the variant itself is constexpr.
What macro can I check to see if `/permissive-` is active?
What is this Type and Resource Safety magic he has in slide 20 (timestamp: 24:20) and is positioned between C++17 and 20? Does anybody have a paper/article on it?
Plot twist: "Tuple" is STL's middle name. It's pronounced "Lava-vedge."
You could also just make the copy constructor of the wrapper unconditional. The compiler won't complain unless it is called for a type that is not copy-constructible itself. The rule is: there must be at least one possible instantiation for which the constructor (or any member function) is valid. This is the only way to solve this for constructors and member functions that have no argument.
I think this is related work, but anyone knows where the tooling for dangling pointer/references that was shown last year, I think in CppCon also, stands as of now?
Is that a concert? Some kind of music band...
Could you explain the gist of how the `CHECK` macro captures the results of both sÄ°des of the comparison?
maybe looking at my [slides](http://onqtam.github.io/slides/doctest.html#/28) might be enough (this presentation will be improved a lot and I hope I'll get to talk about doctest on some conference one day). I was looking at [lest](https://github.com/martinmoene/lest/blob/master/include/lest/lest_decompose.hpp) while implementing the expression decomposition. Basically there are a few template classes with overloaded operators and one of them captures the left side with ```&lt;&lt;``` which has higher precedence than comparison operators, and then I returns a different templated type which has the comparison operators overloaded.
Clang-tidy has a [few checks](http://llvm.org/releases/3.8.0/tools/clang/tools/extra/docs/clang-tidy/checks/cppcoreguidelines-pro-bounds-array-to-pointer-decay.html) for the Core Guidelines, but there doesn't seem to be much progress lately (or it's hard to see any recent progress).
There is an indirect call, which uses the same mechanism as branch prediction, but worse. (In conditional branch prediction, candidate next instructions are known in advance, but not in the case of indirect branch. CPU's try to remember probable targets for indirect calls, but this is still more difficult than conditional branch.)
happiness os not overflowing hehe
Unfortunately, in the absence of real "moves" the compiler cannot guarantee that the previous state value cannot now be accessed again... it can be enforced at run-time by poisoning the previous state (as simple as stealing its resources), but it's still annoying.
Agreed, I wasn't aware that the current state is still like that. Nowadays I only use C++ mixed with Java/.NET, on as needed basis.
&gt; If we comment out line 14, our code compiles without errors. Why?
My guess would be [this paper](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Introduction%20to%20type%20and%20resource%20safety.pdf) in the GSL that refers to `array_view`, `not_null&lt;T&gt;`, `owner&lt;T&gt;`, etc.
[C.46: By default, declare single-argument constructors `explicit`](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-explicit)
Coding standards in C++ are very... personal. There are a dozen ways to do anything, and best practices in one standard are shunned in another. I fear that the Core Guidelines, despite the authority of its origin, will get lost in the sea of existing C++ coding standards. It's a similar story with Scala and other complex, multi-paradigm languages.
Interesting. Are there any plans of merging some of your changes into Eigen instead of separating them? I can see why the sorting functions and operators might be considered outside the bounds of Eigen for inclusion, but what about the pseudoinverse function for example?
This was discussed already several times. There is no way to make such functions efficient or even correct for every matrix, so the developers of Eigen force the user to think the problem through and make their choice, how exactly the user wants this to be computed (or if they need it at all? maybe they just need least squares solutions?). Pseudo inverse is even [mentioned in official FAQ](http://eigen.tuxfamily.org/index.php?title=FAQ#Is_there_a_method_to_compute_the_.28Moore-Penrose.29_pseudo_inverse_.3F) that provides a code snippet. And recently, they added a special facility for [pseudoinverse through Complete Orthogonal Decomposition](http://eigen.tuxfamily.org/dox-devel/classEigen_1_1CompleteOrthogonalDecomposition.html#ab2fd4c81aa1cd8bc917c7f135505cb7f)
What exactly does linSolve do, i.e. how does it choose the algorithm that's used? And what if I give it a 40000 x 15000 matrix, will it use an algorithm that gives me a result without waiting for an hour? The beauty of Matlab's x = A \ b is that it not only is simple and chooses an appropriate algorithm, it's also amazingly good at choosing an incredibly fast algorithm. I've had lots of problems with this in Eigen. (but managed to eventually solve it by using the parallel solver)
Interesting reading.
Yea who does not love a faster build system? But it is the price he is asking for, without a replacement of the functionality.
one HOUR?!!?
"The C++ Programming Language" is by Stroustrup. K&amp;R wrote "The C Programming Language". Learning Standard C++ equips you for all platforms, including embedded. If you learn the language in the context of one particular compiler or one particular desktop operating system, then moving to embedded will give you a rude shock.
&gt; cough cough... "pump my muscles as much as possible" with my awkwardly small sized t-shirts to show off my muscles Hi. I am Bryce Adelstein Lelbach, one of the organizers for CppCon. My understanding is that you attending CppCon this year. I hope you enjoyed the conference. You seem to have objections to the content that Chandler presented. I understand that, and you have every right to express them. However, attacking one of our speaker's physical appearances and mannerisms in a public forum is below the standards of behavior that we expect for CppCon. I would like you to contact me so we can discuss this and you can continue to attend CppCon in the future if you wish to do so. Send me a message. 
All of our keynotes and plenaries are 90 minutes. I'm not sure I understand your comment.
 /u/CPPOldie, Sorry; I may have been unclear. I did not respond to your post because I was concerned you would not return in future years. I responded because your post contained personal attacks against a CppCon speaker regarding his appearance and mannerisms. That was harrassment. CppCon has a code of conduct for attendees. We do not tolerate harrassment. I posted here to inform you and the community of this. Additionally, I wanted to speak with you before my report on this issue is completed and the conference decides what our response will be.
I was very interested in Kenny Kerr and James McNellis' presentation about C++/WinRT. Will it be uploaded there? Edit: corrected the name of presenters. 
I just finished adding basic texture mapping support, currently only for diffuse materials but I think I will be adding support for emissive textures, specular textures, normal mapping, etc, in the near future. It's a fun little project of mine, a learning playground, I'm currently working as a full stack developer intern and I also have to complete my thesis this school year so sadly I don't have much time to dedicate working on fun hobbyist projects like this. Hopefully it'll be interesting to someone. It definitely has it's design flaws and it's not that good of a source to learn C++. But it's a decent piece of work to learn the basics of raytracing and all the basic stuff related to it I think. Edit: Also, if you're into learning things from books here is a very very good book about 3D rendering; http://www.pbrt.org/ - I haven't personally read it completely yet though, only few chapters that I found the most interesting.
It's not an "intelligent" linSolve of that sort. It's a quick and dirty linSolve for prototyping ideas. If you're using such large matrices, then you really do need to be thinking about which solver to use, and probably shouldn't use the linSolve function. To be more precise, linSolve essentially does the following: JacobiSVD&lt;Derived&gt; svd = jacobiSvd(ComputeThinU | ComputeThinV); return svd.solve(b); **Edit:** Also, notice that a guide to which solver to use can be found [here](http://www.mathworks.com/help/matlab/ref/mldivide.html?requestedDomain=www.mathworks.com).
It certainly wouldn't have helped with actually getting work done. But I think it definitely would have influenced language designs. If you preloaded toolchains and docs for several modern languages, including C++, Python, or C#, I think modern paradigms would appear sooner. If you provided other languages like Rust or Haskell, you could maybe even shape the history of popular paradigms away from OOP and toward functional programming and Haskell-like type systems. You won't kill C though.
You are correct, most of the stats come from the 3D model files. I kinda regret adding them to the repo but oh well... 
Thanks! Let me know if there are other (general purpose) features that you would like having!
Mmm not really, but it's an amazing work :D
Works for me on mobile....android + chrome
... one can usually watch at 1.25x or 1.5x speed and the talk is still paced acceptably.
Clang-tidy and Microsoft have implemented checks for the core guidelines. Microsoft's CppCoreCheck has [some of the lifetime checks](https://blogs.msdn.microsoft.com/vcblog/2016/03/31/c-core-guidelines-checkers-preview-of-the-lifetime-safety-checker/). 
There's a big difference between C++ and Java/.NET. C++ is developed by many volunteers from many different companies whereas Java and .NET come to us from one source: Oracle and Microsoft. It's the same way with the C++ Core Guidelines. They are an open project, managed on GitHub, with contributions from many people at many companies. Some companies have contributed more, but no company claims ownership. Half of the guidelines are still ???, sure. This is a work in effort. Have you opened up [Issues](https://github.com/isocpp/CppCoreGuidelines/issues) on those ??? you want to see resolved more quickly? Have you taken the time to think about the problems and the possible correct guidance? (Note: lots of people have. Thank you!) Edit: Note also that tools vendors have been some of the biggest contributors to the Core Guidelines. Much of the editorial and maintenance effort has come from Microsoft, many very insightful Issues have been raised by Google's Clang contributors. (Morgan Stanley--not just Bjarne--have obviously spent a lot of time on the Guidelines but they aren't a tool vendor.)
Examples? Better yet, PRs? There have been [41 contributors to the GSL](https://github.com/Microsoft/GSL/graphs/contributors). If you see a place where the GSL doesn't follow the guidelines and there's not a good reason for it (like working around a compiler issue, for example), please submit a PR!
Excellent, thanks for posting!
The idea behind the Core Guidelines is that while everyone has their own personal standards there are some things we can all agree upon: don't cast away [const](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts-const) or [organize related data into structures](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-org). And there are some rules that we frequently disagree upon, such as whether to use [CamelCase](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-camel). Lastly, there are some rules we wish we could all follow, which is why the [Error handling](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-errors) section has so many rules that start with "if you can't..." The idea of the Core Guidelines is that we can be explicit about what we all agree upon. And we can disagree on those things we need to disagree upon. One big team at my company has adopted the Core Guidelines as modified for their team. They have a wiki where they list rules that they add, amend, and reject from the Core Guidelines. The rest they adopt wholesale. But they are explicit and open about what they reject and amend. Many owners of existing C++ coding standards are contributing to the C++ Core Guidelines. Like C++ itself, we can have one tool that everyone contributes to and everyone agrees upon. 
Depends on how much you actually did in that year. I have a project since 2/years that is faaar from finished because I only do something every 2 months.
He touches on the "high level C++" somewhere around min 57 and says, "forget that, you want to talk about the types/type system". And there's quite a bit of talk about data types. C++ absolutely destroys C there.
They should be up now.
Nice work! Taking a quick look at the code, I noticed that you comment a lot. This is by no means bad, none the less, would I recommend that you try naming and structuring your code in such way that comments explaining what it does become obsolete. Try using comments as a tool to explain reasoning, not function. [Function should be clear by design](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rp-direct) If you are intrested in pbr, [this](http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf) could be a good read for you.
When you define the `Frame` destructor: `~Frame() { ++vic.border(); }` you *are* relying on copy-elision. This has nothing to do with the move constructor, the thing is that the compiler is only creating *one* `Frame` object on this line: `const auto frame = vic.frame();` but also `__tmp = frame(); const auto frame == __tmp;` would be allowed (no copy-elision), and if that happens then you get *two* calls to the destructor (one for `__tmp`, one for `frame`). The only way to work around that is to have a boolean to track if the object as been moved-from, implement move-constructor and move-assignment to set/unsed that boolean, and perform extra cleanup in the destructor only if the boolean is set. This will most likely be optimized out, but it is still necessary in C++14. If you want to rely on guaranteed copy-elision in C++17, best thing would be to delete the move/copy constructor/assignment. EDIT: Forgot to say that overall it was an awesome talk, I really enjoyed watching it!
then NSA sucks at manual memory management :D 
Absolutely loved being walked through and shown how C++ could compile away so much. Zero Overhead abstractions, the compiler getting rid of branching, no function calls, mapping all variables to registers are all absolutely incredible. This is my favorite part of programming, to see the program written with abstractions to simplify working with them while compiling away better than I know how to make. "350 instruction plus a table of data" vs adding const and having 5 lines felt like the difference between what I write and what he writes.
Neural net with 1 hidden layer Without using any 3rd party frameworks.
Ready in what sense? We are just beginning now
Oh, thank you! Their website was just confusing for me I couldn't figure it out.
What is a Mitsuba sphere? I've only ever seen it in Unreal.
Worse is that you can actually also navigate using the arrow keys. That navigates chapters for left/right and only within chapters for up/down though, and does not advance on last slide of a chapter. It took me a minute until I realized there was more slides than just the titles.
Check out Peter Shirley's books like "ray tracing in one weekend"
See Herb Sutter's plenary talk at Cppcon 2016. It looks like it's not on youtube yet, but it should be in the next couple of days.
But isn't the user experience more important? What if wanted to use your features in combination with the 3.3 branch? If there is no strong technical reason to develop this as a fork, I wouldn't choose to do so... But generally I agree: Eigen should contain most of these convenience features.
If you are interested in writing a rasterization based renderer, this GitHub project is an amazing resource: https://github.com/ssloy/tinyrenderer/wiki Step by step tutorials that will get you something pretty close to (software) OpenGL.
Note that gcc actually adds an exception clause to the GPL to allow compiling non-free programs. Without that, compiled code probably would need to be GPL-licensed because gcc is adding parts of its standard library to all compiled binaries (i.e. C runtime init/fini etc.): http://www.gnu.org/licenses/gcc-exception-3.1.html
Poorer vim mode than eclipse (and emacs if you count it as an IDE).
I did not enjoy eclipse's vim mode. When dealing with screen splits and saving it was very unnatural. Then I also found myself using eclipse...
I use it for a PIMPL helper class I have. edit: https://github.com/playmer/Yours-Truly-Engine/blob/Constexpr/YTE/Core/PrivateImplementation.hpp Not sure how "perfect" or "good" this is, but it's kinda nice to have.
I'm glad I didn't go with "mirage" for my project. if it ever grows it will hopefully be easily searchable 
Great talk! Make me so scared to forget a const on my static variables
I would believe some of the things you say, there's always two sides to every story, and if something like that is happening, it's good if somebody stands up and lets us know. However from blelbach's post, there seemed to have been no second voting and the proposal seems to have been **accepted**. This makes everything else you say very hard to believe. Care to explain?
&gt; Use smart pointers and move semantics to supercharge your C++ code base. revolutionary
No, blocking does not mean 'parallelized'. It means 'cache-friendly'. Parallelization is 'Implicit MT' in that table.
Feel free to check out the fast and lightweight C++ IDE [juCi++](https://github.com/cppit/jucipp). It can be a hassle to compile with lldb (debugging) on Mac though.
Beginner questions are off-topic for this subreddit; /r/cpp_questions is more appropriate.
 Widget() : size(10000), ptr(new char[size]) {} ~Widget() { delete ptr; } That is ok!
I haven't spent any time with xcode, but I hear it's good. After that, qtcreator. People suggesting Java based IDEs probably haven't worked on large projects or tried alternatives; they're not nearly responsive enough. Having said that, if you use cmake a lot, qtcreator 3.6 is more pleasant than 4.1. Recent versions mess with your delicate configuration.
So... who bought the three "Microsoft iPads"?
Do you realize that you're not helping yourself? Even with such subject, personal attacks on anyone physical appearances and mannerisms is just plain wrong and completely unprofessional. I understand that you have issues with decisions committee made or how it was made, but those issues could be voiced in entirely different way. &gt; If I was truly lying there'd be more people than a flaky second rate phd grad to come to their defense. Attacking people. Again. Seriously? &gt; and if I was lying, what do I have to gain? Honestly, with you reddit history of comments where you constantly show no respect for any opposing side, I would say that you just trolling. Or you enjoy the conflict. Either way, I fail to see why are you not shadowbanned from this sub already. At least until you learn to behave in public places.
Paging /u/STL. This is gone too far.
[Here is the mobile version of your link](https://amazon.com/gp/aw/d/0393979504?qid=1415866438&amp;ie=UTF8&amp;tag=as_mi_tl-20&amp;sr=1-1)
Just curious, why fork from Yafaray? I read your about page with the differences, but none of them is really a reason to fork and develop a separate project?
You'll have to ask povmaniac... I joined him because around that time there was absolutely nothing going on at yafaray. Ever since, I'm supporting him. Yafaray vs TheBounty have different goals too. We're far more stable, for instance.
There's a sticky for this kinda thing.
[Video is up now](https://www.youtube.com/watch?v=JfmTagWcqoE)
Look at r/creativecoding , r/musicprogramming , Gamma audio library, openframeworks , Maximilian...
Guess he's back pedaling on the memory safety talk from last year, eh?
thanks
Assuming you _actually_ need the type to be moveable: `type(type&amp;&amp; rhs) : _pimpl(new impl(*rhs._pimpl)) {}` `type&amp; operator=(type&amp;&amp; rhs) { *_pimpl = *rhs._pimpl; return *this; }`
This is a *really* impressive talk! I'm hoping the ideas on deferred_ptr etc. could mature into a proposal or two. Kudos to Herb for tackling these issues head on.
But it's move enabled!! Code is now 378% faster.
/u/CPPOldie, harassment is not acceptable on this subreddit. This is a warning; I will use moderator powers in response to further personal attacks against anyone. ar1819, thanks for bringing this to my attention. I wasn't monitoring this old post, and (despite appearances) wasn't being summoned (I suspect that reddit doesn't summon people when a whole bunch of usernames are mentioned). This is a compliment; I will use gilding in response to further helpfulness.
Yep. That's possible, too. I'm assuming you forgot two `std::move` invocations here. But since the pimpl wrapper already uses a layer of indirection, swapping two objects via swap(this-&gt;pimpl_, that.pimpl_); instead of swap(*this-&gt;pimpl_, *that.pimpl_); seems like the obvious cheap approach where nothing can go wrong. A move is a one-sided version of this.
&gt; I'm assuming you forgot two std::move invocations here. Being moved from doesn't stipulate that you must be left in some kind of "zero'ed out" state. `int`s and `float`s aren't set to 0 when moved from. Move constructors are only a *potential* performance improvment, not a guarantee. They can be as expensive as copies if they want to.
I have to agree, last year's talk and this years have made me realize when I'm doing new/delete left,right,center ... I actually have a lifetime problem, i.e. I (developer) am unsure of my resources lifetime's and therefore I do it. Of course it results in code that causes havoc or leaks, etc. but I get it ... c++ has good 80% lifetime case now and has for a while.
Okay, I've been thinking about this issue far more than it's worth. :-) Conclusions: First, you are correct. The current behavior of `variant` means that `optional&lt;T&amp;&gt;` should rebind. Second, the larger question, of whether an object that is conceptually an optional reference should rebind, is one with no single best answer. It's similar to the question of whether an owning smart pointer should be copyable. In some use cases, it should, and in some it shouldn't. That's why we have both `shared_ptr` and `unique_ptr`. Third, the connection (an unfortunate one, IMHO) with `variant` aside, the non-rebinding version still strikes me as more natural and useful. To answer your question: int i = 0; std::optional&lt;int &amp;&gt; o1{i}; std::optional&lt;int &amp;&gt; o2{}; os = o1; // ? &gt; As far as I can see, the only reasonable thing to do in this case is to rebind (the alternative is to make it a no-op), .... In the version of optional references that I'm thinking of, I would say that should probably throw.
It's meant for professionals and serious students. (Students are encouraged to volunteer; volunteers get to spend at least half their time roaming the conference.) As far as what changes are coming, check out [this Wikipedia article](https://en.wikipedia.org/wiki/C%2B%2B17). Big items include: * std::string_view * std::variant * A standard filesystem library. * Initializers in `if` and `switch` statements. * `if constexpr` * parallel STL algorithms * Addition of math special functions (if you're in the hard-sciences) The other features are nice, but not as game-changing as the above items.
Then write a post, on your blog or here, explaining in detail what went wrong and how. Right now it's very difficult to track down which proposal you refer too. Right now - I can see that P0092R1 is accepted [1][2]. Maybe you are referring to P0355R0 [3]? But it came after Kona meeting, so unless there are some time warps I don't know what proposal you are referring to (I looked in 2015 mailing list to see all proposals from Howard E. Hinnant [4], and I didn't find any proposals about time rather then P0092R0 and P0092R1 from him). Maybe you are referring too another time proposals such as [5][6] which were from Google, but they also came after Kona meeting. So - am I missing something? Sources: 1. https://gist.github.com/StephanTLavavej/996c41f7d3732c968ede 2. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0096r3.html 3. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0355r0.html 4. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/ 5. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0215r0.html 6. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0216r0.html
This is kind of an old guide, but kinda highlights where you might want to start (http://lazyfoo.net/tutorials/SDL/50_SDL_and_opengl_2/). Try to get the basics of creating a window, drawing some simple graphics, and handling inputs. Search for some other tutorials. Once you get the graphics/input down, the rest is your design. Research game engine design perhaps, I tried to give you some starting points.
"Slander is spoken. In print, it's libel." - J. Jonah Jameson, Spider-Man (2002)
Nope! I don't think so. There's a bit of overlap, but Herb intended this to build upon his talk last year. 
The audible giggling is definitely not my fault, those people are too amusing.
I only see some blurry pixels for atoul() benchmark. How do I read that?
I am surprised nobody asked a question about signed vs. unsigned size and index types. Is this question discussed for STL2?
What tools do people use for measuring these experiments?
Curiously, I see that Eric Niebler [opened an issue](https://github.com/ericniebler/stl2/issues/182) about this in STL2 repo on github )(actually currently containing Ranges TS proposal). So apparently is is being somewhat discussed. 
Yep! We've definitely had discussions about it. The latest versions of the span&lt;&gt; and mdspan&lt;&gt; proposals should be using std::ptrdiff_t.
A good profiler like VTune. If that's not available, `high_resolution_clock`.
I wonder, is there any reason why libstdc++ people were not present? Were any of them at the conference at all? Looks like GCC community is less represented at CppCon in general than MS and clang. Why this happens?
This may be only cosmetics, but I was wondering why this attribute, in the case of specifying the struct, can only go in between the name (MyError) and the keyword 'struct'? Wouldn't it be nicer if it can be placed in front of the keyword 'struct'? So it is more consistent with the return case? Like so: **[[nodiscard]]** struct MyError { }; **[[nodiscard]]** int something() { return 1; } 
I **really** wanted to have libstdc++ developers on this panel, but unfortunately it didn't work out. This is the only thing about the panel that I was unhappy with. Most of the libstdc++ developers that I know are in Europe - and because they're on the committee, they are already traveling to the US at least two times a year. This can be a burden to both the person, and their employer. So, the logistics of getting the libstdc++ folks that I know to the conference are complicated. I reached out to one of them, but he was not able to attend CppCon. I had some trouble finding other candidates. About a week or two before the conference, I thought of someone who would have been perfect (and may have had a better chance of being able to do the travel), but it was far too late for me to ask. I have a plan for next year's closing panel, and I'm hoping to have more GCC/libstdc++ developers present. **TL;DR - We tried but were unable to get someone from libstdc++ this year; I'm going to try and have more GCC/libstdc++ developers next year.**
libstdc++'s regex maintainer was at CppCon and gave a great talk.
There are plenty of new features being introduced for the entire spectrum of programmers. One of the design goals for C++11 was to &gt; [Make C++ easier to teach and learn â€“ through increased uniformity, stronger guarantees, and facilities supportive of novices (there will always be more novices than experts).](https://isocpp.org/wiki/faq/cpp11#cpp11-goals) Jason Turner (/u/lefticus) does a nice job of introducing features through his [C++ Weekly videos](https://www.youtube.com/playlist?list=PLs3KjaCtOwSbcWD1LlHS7w5AVM0tCAD86).
You should benchmark against Boost Spirit Qi [Benchmark Source](https://github.com/shaovoon/intbench) lexical_cast: 792ms sse4i_atol: 103ms boost_spirit: 93ms The code is simple #include &lt;boost/spirit/include/qi.hpp&gt; template&lt;typename string_type&gt; inline bool str_to_value(const string_type&amp; src, unsigned int&amp; dest) { namespace qi = boost::spirit::qi; return qi::parse(std::cbegin(src), std::cend(src), qi::uint_, dest); } [C++17 string_view to integer/float example](https://github.com/shaovoon/str_view_conv_ex)
Great talk. PS: Intel 64-bit processors have 16 general purpose registers.
If I was trying to "hide" I wouldn't have added a comment when I deleted the original comment saying I made the mistake.
This subreddit is more oriented toward core aspects of the C++ language. For questions about programming in C++, please use /r/cpp_questions. That said, do you understand what the first line does? Do you know what `x &lt; y` means?
I will move to that sub, thanks. Yes, I understand that. I'm not sure what I put for the output though?
It either prints "True" or "False" depending on the value of the conditional. To figure that out, you will need to evaluate the expression x &lt; y || z &gt; x &amp;&amp; y == z Does this evaluate to true or false given that `x=0`, `y=5`, and `z=10`?
x&lt;y is true, the part I dont understand is z&gt;x(which is true) &amp;&amp; y==z y is not equal to z, it is less than z.
If a move constructor was as expensive as a copy constructor there would be little point in providing it in the first place.
By deleting, you hid your mistake, but not that you made one. I reacted because i am old; people regularly hide their mistakes and it pisses me off when I see it. *Who cares?* To top that, this a random anon forum. *Who cares?*
I would say that Billy was improving the signal-to-noise ratio of this thread by removing confusing/misleading comments that cannot topically contribute to the thread. You are now moving that signal-to-noise ratio in the opposite direction. ;-]
You did mention that Stevens supplied the 3 iPads at 50:35 in the video.
You don't need to "provide" a move constructor that doesn't offer any benefits (e.g. because the type is large and shallow e.g. `std::array&lt;&gt;`); the compiler is more than happy to do that for you.
Everytime somebody doesn't label his axes, someone link to this webcomic: https://xkcd.com/833/ Please don't. That's for the first graph, obviously.
How would working in Canada work as a US citizen?
&gt; I have seen other dependency managers for c++ but don't like any of them and find them lacking at some place. So instead of improving them you just make your own stuff that will be **even more** lacking ? When will the madness end...
C by itself is pretty neat. C++ is even better. C/C++ is not a language, it's a catastrophe.
Why bother? If there isn't a move constructor, a move request falls back on copying anyways.
Thanks for this writting! Just one remark: All your atoui functions could run about twice faster with : - an inlined call to enforce (and even faster if it does not use exceptions). - inline atoui functions. See it here: http://imgur.com/a/tEHqI
 for ( std::size_t i( 0 ); i != ( last - first ); ++i ) { enforce( ( '0' &lt;= first[ i ] ) &amp;&amp; ( first[ i ] &lt;= '9' ) ); result += 10^i * ( first[ i ] - '0' ); } I don't understand this code, what is it supposed to be calculating?
Ah, looking at the rest of the code it looks like he's written "^" to mean "to the power of", ok that makes sense, although it's not clear what language this is written in now :P
I took it as being from the type consumer's perspective, not the type author's &amp;ndash; moving an object (via explicit `std::move` or otherwise) is not necessarily faster than copying, since the move may just be a copy anyway. In any case I think we're all on the same page now. :-]
It's actually a very interesting debate, because I think there's no right answer. Signed seems "more right" and also faster, so, sign me up. P.S. You should be at CppCon next year. Submit a talk!
What are the intrinsics? Do you mean some intrinsics for binary-coded decimal integers? (e.g. for `FBLD`/`FBSTP` instruction)
&gt; For example, if you're writing for a system with no DRAM, then you're unlikely to use dynamic memory allocation. This is not strictly true. Really, all it means to be using 'dynamic memory' is to be reusing parts of memory for different things at different times. You might not allocate using malloc from a general purpose heap, instead you might take a few KB and chop it up yourself into your own little pool. But, doing that it still dynamic memory. Basically, unless your entire program state fits in memory all at once (aside from the stack), you are using dynamic memory. Some applications definitely do this, but sometimes programmers claim to have no dynamic allocations, when really they do, but they're doing it manually. 
Can someone explain what Walter Brown meant by Alex Stepanov's "mistake" in std::min and std::max? I did not quite grasp his explanation regarding the pairs. 
Also, am I not seeing it right, is this not evaluating a reversed number (i.e. least significant digit first)? Surprised no one has said it yet. It needs something like std::pow(10, last - first - 1 - i)
Impressive. What is iod on this graph?
It's worth pointing out that Alex himself also thinks this was a mistake. He has publicly spoken about it before and even said that he tried to correct the mistake many times but the committee wouldn't allow it to change.
I would love that one too. It remembers me what happened to override keyword. Although C# and Java put it to the front in C++ we have to put it after the parameter list where we normally put only const. That makes it illogical to use at least for me because override and virtual are tightly bound concepts in my head. I have no idea if such things could be fixed later when the standard is out.
Existing ones are too specialized. Some dependencies I have are tools and not meant to be integrated into the application. Some dependencies are resource files. What I propose handles all these cases in a very generic way. That's why I'm asking here to see what people think before actually starting the project.
`RTDSC`
&gt; Unfortunately due to the nature of the work working remotely is not possible That's not always the case. Shipping devices around is sometimes easier than visa sponsoring and shipping around (relocation of) humans ;)
Well, the point was to reproduce Andrei's benchmark, which does not inline these functions and which throws an exception in enforce(). So I had to keep them :) Nevertheless, I did try without the enforce call on a preliminary benchmark and it was indeed a lot faster.
In what capacity? It certainly can do everything your example does.
The honest truth is that if serves your needs, write it and use it. Nobody else will, because we use CMake, Conan, build2, autotools, Meson, or some other already-created and more fleshed out thing that doesn't require knowing squirrel.
Yes, they are released as open source and "editor agnostic" as they are basically command line utilities, so they can be integrated into most editors on a *nix system. For ClangFormat there are existing integrations into vim, emacs and Visual Studio
How much would the performance differ if you were to replace enforce()'s use of exceptions instead with returning an error code?
Kind of sad to see this down voted. So far the feedback has been very good.
I've never needed to dig into the source code of Make or Ninja in order to solve a build problem. The language used for the internals of the build application are an implementation detail. That being said, it's an implementation detail with a lot of ramifications. * I have wanted to deploy a small version of python in the past with only the libraries I need. This turns out to be difficult. It's pretty trivial with Ruby or C++. * Python and Ruby have historically had trouble with CPU parallelism due to the interpreter lock (overlapping I/O with computation works fine though). * I have had severe performance issues in past projects where there was frequent language crossing boundaries. This suggests that very few languages (probably only 1) should be used in a given project. The "C++" vs. "C and C++" arguments the author makes really seem like pedantic nit-picking. This back and forth reeks of a programmer holy war, with little possibility of anything positive coming from continued arguments.
I had the same impression regarding the author's argument, that's why I was curious of what other devs think. Thank you for your opinion. This reminds me of Dan Saks' quote of a quote in his keynote talk at CppCon last week: "If you're arguing, you're losing."
Frankly, id rather it not be python. One (main?) of the reasons being that it will probably be a pain to use on some systems (Windows). It matters for end user simply because if you use python, you have one more dependency you need to care about - python interpreter (unless its embedded, but its probably not). Its much easier to ensure that self contained (or depending only on system stuff) binary works well everywhere than something with dependencies you don't directly control (it may not be a big problem, but pain nonetheless). At the same time, as /u/ben_craig said, what its written in is otherwise not very interesting (could be Fortran for all i care;). If i have to 'fix' it often enough, its probably bad choice due to being immature though - this makes ms guys point somewhat moot - i want the package manager to work for me, not the other way round. Also, the article is silly with its titular 'fallacy'.
There may be some work in SG14 in this direction. I ended up doing this when I was writing an STL-like generic set associative cache at work as unordered_map wasn't flexible enough for my needs. What relaxations did you have in mind?
I agree with this stance. For better or for worse, a language should have good tools for its ecosystem written in that language. I don't see Python being "easy to learn" or "popular" as arguments. Maybe it's because I've been writing C++ for a long time but I don't think I'll ever think of learning a new language as "easy". It's a delusion. All languages are universes unto themselves. And next week, some language other than Python will be even easier to learn or more popular. Are we going to re-write the package manager then? Further, there exists a lot of projects that are C++ only, be them public open-sourced libraries, private commercial applications, etc. To be dependent on another universe entirely just for the sake of building said project is silly in my mind. I provide value to this project or to that company by writing C++ but I can only deliver that value by installing Java/Python/.Net? No!
I never understood people who try to get performance out of delegates. Why not just use function pointers? Honest question, why would someone prefer complicated implementations of delegate when function pointers are more portable and less resource intensive.
In a similar vein: [why the Meson build system is implemented in Python](https://github.com/mesonbuild/meson/wiki/Use%20of%20Python). There is also the bootstrapping problem. To implement a cross platform package manager you need to be able to download files (over https preferably), unpack them, validate checksums and the like. None of these is in the C++ standard library so in order to create a package manager you need to have a fully working package manager.
FYI https://twitter.com/WeAreROLI/status/778522243500535808
After thinking about it. It's better than squirrel as the driving language. Can you point where it can do dependency resolution? Are you referring to doing dependency resolution via it's build system? That works only for simple cases but not when you have dependency conflicts or more advanced checks. I like the idea of having it as the driver language though as most people are familiar with it and it will be easier to bring in projects already using cmake.
Maybe this is because you should keep out politics from these events and to attract people based on their interest in say C++ development and not because of their race or gender (remember Trump joke at this year cppcon?). I don't think you need some Adria Richards attending a meeting to explain how sexist and non-inlcusive C++ community is and I can assure you such person will not care a bit about what community is doing. Also stop naming minority women, people of color and even LGBTXYZ, these "groups" are nowhere near to be compared with disabled people in their struggle to be included anywhere, especially in the western countries.
I don't intend to introduce politics to Meeting C++. I just want to offer a chance to attend the event for people that otherwise couldn't.
I did some performance tests with WinkSignals, and based on that, fastdelegate was definitely faster than anything implemented with std::function. I measured a smaller difference than the claims of the implementation mentioned [here at the cpp subreddit](https://www.reddit.com/r/cpp/comments/54rsr7/fast_delegates_implementation/), but noticeable regardless.
This is off-topic for our subreddit; StackOverflow would be more appropriate.
How did they get 100 mil allocations within 100-200 miliseconds? I can barely get 5 million numeric operations within that time frame on a 6700k. Impressive!
I don't know for an error code but if I remove the call to enforce then the graph becomes this (for the incremental build benchmark): http://imgur.com/a/WoLmm It's up to three times faster for the implementation with the unrolled loop.
So basically this excludes only white males, because they can always travel so far and attend, but other cannot? Yeah, this makes perfect sense... It's hard to see that this kind of action has to get even in events like this... P.S. I'm not against any minority, but this gets ridicules at this point... What's next? Minorities are served out of queue in shops? And putting woman as minority is plain stupid for me... It's like 50/50 between man and woman, no? Just because they are not that interested in C++ means that you should treat them better than others?
Its not me defining the term diversity/minority here. The program is for people from the C++ community, which are underrepresented at conferences such as CppCon or Meeting C++. And yes, that is also including women. We're far from the 10% that is the minimum of women in our field, as the data from social media shows. 
Men can be part of this program, its not exclusive to women. You only have to be part of a group that is underrepresented, which women are. Also you don't have to be apply, if you feel uncomfortable with it. This is the first time I'm doing this, and I'm open to feedback, to improve the process for the next years.
Friendly, pre-emptive reminder: please keep comments respectful. I want C++ to grow and improve, and for that to happen, we need a welcoming community.
On the conference it won't matter. I see your critic, some parts I share, some parts I don't. I wanted to offer something different then the student program, and it happens that the terms of the program are defined by the foundation, not me. So, thanks for the open discussion.
&gt;Yes, you can be man. Just not white - we have enough of those already... This feels pretty much like that... For future reference from me - if you want to help, then help those who needs it. Not just to improve statistics. Some valid reasons would be financials and location (even someone with money can't always afford to hop on airplane and attend). Things like gender, race and sex preferences should be LAST thing to think about here...
Don't get me wrong. Programs like these are great! Really good work! Only thing that sucks are rules... I understand that you didn't chose this and it's okey. But for me - I wouldn't agree for such terms because here rich woman/member of minority can get it, but poor white man won't be able. I hope you will keep up good work there and hope that in the future, rules will be less unequal and more focused on people who really can't come, not just "don't come".
For future reference, it might be better to ask this sort of question in /r/cpp_questions. 
For C++Now and CppCon, our registration form does not currently ask for gender identity, age, ethnic identity and disability. I would like to change this going forward so that we can have better data. We do, however, ask for T-shirt sizes for both conferences. We can extract some statistics from this information, but it's bad data. For example, three speakers in the general program for CppCon this year asked for women's size shirts. This might lead you to believe we had three cisgender female speakers, but you'd be wrong! One of the three is a straight cisgender male who gives his conference shirts to a female family member. I am planning to go through this data from C++Now and CppCon sometime in the next few weeks, as part of a broader diversity initiative that we're organizing.
Results from running: https://github.com/ArashPartow/strtk/blob/master/strtk_tokenizer_cmp.cpp Integer To String Test [sprintf] Numbers: 80000000 Total: 657777787 Time: 8.0548sec Rate: 9932001.7912nums/sec [boost] Numbers: 80000000 Total: 657777787 Time: 8.1276sec Rate: 9842983.4969nums/sec [karma] Numbers: 80000000 Total: 657777787 Time: 3.2624sec Rate: 24521508.7349nums/sec [strtk] Numbers: 80000000 Total: 657777787 Time: 1.6857sec Rate: 47459071.0005nums/sec String To Integer Test [atoi] Numbers: 184000000 Total: -188243392 Time: 5.2460sec Rate: 35074215.3240nums/sec [boost] Numbers: 184000000 Total: -188243392 Time: 13.4782sec Rate: 13651662.4015nums/sec [qi] Numbers: 184000000 Total: -188243392 Time: 2.8576sec Rate: 64388706.2209nums/sec [strtk] Numbers: 184000000 Total: -188243392 Time: 2.4361sec Rate: 75529817.0372nums/sec [fast] Numbers: 184000000 Total: -188243392 Time: 2.2090sec Rate: 83296287.6112nums/sec String To Double Test [atof] Numbers: 75040000 Error:0.133514970373 Time: 11.3597sec Rate: 6605835.0017nums/sec [boost] Numbers: 75040000 Error:0.133514970373 Time: 17.0709sec Rate: 4395786.6994nums/sec [qi] Numbers: 75040000 Error:0.267026513647 Time: 2.2289sec Rate: 33666362.9336nums/sec [strtk] Numbers: 75040000 Error:0.133514970373 Time: 2.1366sec Rate: 35120398.7551nums/sec * clang version 4.0.0 (trunk 281716) using O3 * 3.13.0-37-generic #64-Ubuntu SMP Mon Sep 22 21:28:38 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux * Intel(R) Core(TM) i7-3517U CPU @ 1.90GHz ---- Integer To String Test [sprintf] Numbers: 80000000 Total: 657777787 Time: 6.9432sec Rate: 11522121.1764nums/sec [boost] Numbers: 80000000 Total: 657777787 Time: 7.0438sec Rate: 11357538.1400nums/sec [karma] Numbers: 80000000 Total: 657777787 Time: 2.9489sec Rate: 27128373.4980nums/sec [strtk] Numbers: 80000000 Total: 657777787 Time: 1.4688sec Rate: 54466824.2573nums/sec String To Integer Test [atoi] Numbers: 184000000 Total: -188243392 Time: 4.6419sec Rate: 39638684.7712nums/sec [boost] Numbers: 184000000 Total: -188243392 Time: 10.6277sec Rate: 17313327.2818nums/sec [qi] Numbers: 184000000 Total: -188243392 Time: 2.5492sec Rate: 72180271.7980nums/sec [strtk] Numbers: 184000000 Total: -188243392 Time: 2.2154sec Rate: 83056478.4053nums/sec [fast] Numbers: 184000000 Total: -188243392 Time: 1.7930sec Rate:102621991.8929nums/sec String To Double Test [atof] Numbers: 75040000 Error:0.133514970373 Time: 9.4085sec Rate: 7975781.8530nums/sec [boost] Numbers: 75040000 Error:0.133514970373 Time: 6.7916sec Rate: 11049011.1400nums/sec [qi] Numbers: 75040000 Error:0.267026513647 Time: 1.8811sec Rate: 39890619.7505nums/sec [strtk] Numbers: 75040000 Error:0.133514970373 Time: 1.8347sec Rate: 40901445.1771nums/sec * g++-6 (Ubuntu 6.1.1-3ubuntu11~14.04.1) 6.1.1 20160511 using O3 * 3.13.0-37-generic #64-Ubuntu SMP Mon Sep 22 21:28:38 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux * Intel(R) Xeon(R) CPU E5-2687W @ 3.0GHz ---- Note: Boost 1.61 was used. Note: In the double conversion Qi has more *error* than the other methods. Note: A more interesting benchmark: https://gist.github.com/anonymous/e78c3535e72d54208529 More results, albeit older ones, can be found at the end of the following article: http://www.codeproject.com/Articles/23198/C-String-Toolkit-StrTk-Tokenizer
t-shirts aren't a good measurement for gender. Some women want normal/men t-shirts, its not rare that men take a female one for coworkers or relatives.
&gt; That works only for simple cases but not when you have dependency conflicts or more advanced checks. That's in the eye of the beholder. You can do very advanced resolution, if you're willing to learn how the tools work. Our in house in system does transitive resolution and packaging as well as rejecting on transitive version conflicts. 
Well, when Conan and Meson came out someone could have said (and probably did say) that no one will use them because everyone uses CMake or autotools or some already existing thing that doesn't require installing Python; and when CMake came out people probably said we use automake which doesn't require us to learn your custom and frankly ganky language (okay, m4 and CMake's language are about equally ganky, but m4 had the advantage of people already knowing it). Not saying you're wrong; putting squirrel front-and-center is likely to keep away most people who don't already love squirrel. But I would take your first paragraph and add to it: The honest truth is that if serves your needs, write it and use it. And if you just want to write it, go ahead and write it. Who cares if nobody but you uses it? If you make something awesome, someone will eventually use it. Great! If not, you still made something, so be fucking proud of that!
&gt; Well, when Conan and Meson came out someone could have said (and probably did say) that no one will use them because everyone uses CMake or autotools or some already existing thing that doesn't require installing Python We could have and did, but they came out as working and fairly full-featured. They weren't just proposals. &gt; when CMake came out people probably said we use automake which doesn't require us to learn your custom and frankly ganky language They solved similar problems in different domains. Non GNU platforms (especially Windows) had no real options prior to CMake. But to your last point, that's exactly right. The reason Conan, Meson, build2, hunter, et al were even marginally successful is that the authors solved their own problem/scratched their own itch and made something that is worth using in so doing. 
&gt; [boost] It would be nice if it were clearer what this means. Boost is a large collection of libraries, I can think of three or four that could have been used here, but I've no idea which one actually was without looking at the source directly...
Calling `rdtsc` instead of using your platform's high resolution timer is less than ideal because your platform knows what CPU socket you're scheduled on and can fix that up, respond to power management changes, etc. See "[Acquiring high-resolution time stamps](https://msdn.microsoft.com/en-us/library/windows/desktop/dn553408.aspx)" on MSDN for examples of all the lies, damn lies, and bogus hardware from which your platform vendor(s) try to protect you :) (I'm not sure if *nix platforms have similar mitigations but it would surprise me if they did not)
I have tools to do all that as part of a fresh bare bones OS installation. Plus a general purpose package manager...
Allowing open addressing for collision resolution would be nice. I think std::variant addresses most of the issues that made the original proposal require buckets of lists.
Also, does signed int have any natural performance advantages over unsigned int ? 
Not intrinsically, but the compiler can optimize expressions involving signed arithmetic a bit more aggressively since signed overflow is UB.
OK, so it sounds like the real goal of making the constructor explicit is to make sure the caller really knows what they're doing, because "is this string empty" can't *really* be checked at compile time. So, your goal is to make sure that if someone does this: std::string my_string; std::cin &gt;&gt; my_string; foo(my_string); They get a compile error because `foo` requires that the string must not be empty and no one's checked that yet, so the caller should do this instead: std::string my_string; std::cin &gt;&gt; my_string; if (my_string.empty()) { // Throw an error or something. Maybe we can just keep going? Whatever. } else { foo(non_empty_string{my_string}); } Appreciate the discussion. Thanks!
&gt; Change the signature of is_whitespace() to accept a std::optional&lt;char&gt;. Sorry, but you just went way off the rails here. Aside from the fact that you wanted to use is_whitespace() in a particular kind of way, what justification is there for this? It just doesn't make any sense; a function that checks if a char is whitespace should not accept a "maybe char". What does it mean for a non-char to be whitespace? I think following this reasoning ends up with lots of maybe types all over your interface, when it's actually not necessary. What you are suggesting here is basically artificial widening of contracts, which is a bad idea. Narrow contracts are good. They make it easier to implement, test, document, and modify code. It's better to use narrow contracts and constrain things as much as possible, and use defensive programming (asserts) to catch things in development. Then when you fix your bugs, you have the most constrained, minimal set of code that works. John Lakos has written and talked *a lot* about this topic, he even writes specifically about why artificially widened contracts are a bad idea: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3604.pdf. You advise on the other hand using references instead of pointers (if things can't be null). If you stop and think about it, you'll realize that this (correct) advice is actually exactly the opposite of what you suggest earlier. It's *narrowing* the contract. Because if the client function has a pointer, it's the client's responsibility to check for null before dereferencing to pass by reference. If you are passing by pointer, then the client is not responsible for this check. The client performing more checks means that the you've given the client something with a narrower contract; so pass by reference is narrower. (or to make it even simpler: suggesting optional&lt;char&gt; over char is to make arguments nullable, suggesting a reference over a pointer is to make arguments non-nullable!) Finally, unsigned integers for always positive is a really bad idea. The reasons for this have been beaten to death; you can find a wide variety of C++ gurus discussing this point and invariably coming to the same conclusion.
Slides available [here](https://github.com/CppCon/CppCon2016/blob/master/Tutorials/Template%20Normal%20Programming,%20Part%201/Template%20Normal%20Programming,%20Part%201%20-%20Arthur%20O'Dwyer%20-%20CppCon%202016.pdf).
Slides available [here](https://github.com/CppCon/CppCon2016/blob/master/Presentations/Improving%20Performance%20Through%20Compiler%20Switches/Improving%20Performance%20Through%20Compiler%20Switches%20-%20Tim%20Haines%20-%20CppCon%202016.pdf).
Yes, overloading signed/unsigned is bad. But that's not the fault of unsigned.
sorry... we were discussing this. right now, currently there is no planned macro for feature detection until we have full support in. Is this a case where you have a MSVC non-standard workaround you want to remove when permissive- is thrown?
I am not talking about overloading, I am talking about passing a negative int to a function that takes an unsigned.
This justification for using a type with what is essentially an ill fitting domain is very common. However, don't all compilers warn about this kind of narrowing conversion? I have been using unsigned data types for non-negative values for many years and have never been bitten by this issue. Our current project has millions of lines of code where the use of unsigned in such cases is encouraged and I am not aware of a single undebuggable-conversion-from-signed issue. What am I missing?
This is a *well-defined* conversion and *it is not* narrowing. There is **no** warning. &gt; I have been using unsigned data types for non-negative values for many years and have never been bitten by this issue. Our current project has millions of lines of code where the use of unsigned in such cases is encouraged and I am not aware of a single undebuggable-conversion-from-signed issue. What am I missing? Well, congratulations on being exceptional, I suppose.
That's incorrect. It's a narrowing conversion and GCC warns (it really should error). C:\Temp\gcc&gt;type meow.cpp unsigned int meow(int i) { unsigned int u{i}; return u; } // N4606 8.6.4 [dcl.init.list]/7, /7.4: "A narrowing conversion is an // implicit conversion [...] from an integer type or unscoped enumeration // type to an integer type that cannot represent all the values of the // original type, except where the source is a constant expression whose // value after integral promotions will fit into the target type." C:\Temp\gcc&gt;g++ -Wall -Wextra -c meow.cpp meow.cpp: In function 'unsigned int meow(int)': meow.cpp:2:21: warning: narrowing conversion of 'i' from 'int' to 'unsigned int' inside { } [-Wnarrowing] unsigned int u{i}; ^ C:\Temp\gcc&gt;g++ -Wall -Wextra -c -pedantic-errors meow.cpp meow.cpp: In function 'unsigned int meow(int)': meow.cpp:2:21: error: narrowing conversion of 'i' from 'int' to 'unsigned int' inside { } [-Wnarrowing] unsigned int u{i}; ^ The GCC Wiki has [an FAQ](https://gcc.gnu.org/wiki/FAQ#Wnarrowing) about this. When performed without list-initialization (e.g. implicitly when calling a function), converting from signed int to unsigned int is indeed well-defined with modulo behavior. It's simply considered a narrowing conversion because the *value* -1 cannot be represented in unsigned int.
This is not a problem, simply use `-Wconversion -Wsignconversion`.
Same, one common example for the trouble of mixing `unsigned int` and `int`: #include &lt;iostream&gt; unsigned int get_width() { return 5; } int main() { int x = 0; std::cout &lt;&lt; x - get_width() &lt;&lt; std::endl; } An image width is naturally always positive, so `unsigned int` seems to make perfect sense. But coordinates can be negative and you constantly have to mix `width` with signed coordinates. In this case the output you get it `4294967291`, not the expected `-5`.
This is indeed well-defined but compilers will warn in this scenario if you ask them nicely enough: C:\Temp\gcc&gt;type kitty.cpp bool cat(unsigned int u) { return u &lt; 5; } bool dog(int i) { return cat(i); } bool pig() { return dog(-1729); } C:\Temp\gcc&gt;g++ -Wall -Wextra -c kitty.cpp C:\Temp\gcc&gt;g++ -Wall -Wextra -Wconversion -Wsign-conversion -c kitty.cpp kitty.cpp: In function 'bool dog(int)': kitty.cpp:6:17: warning: conversion to 'unsigned int' from 'int' may change the sign of the result [-Wsign-conversion] return cat(i); ^ (Unlike warning for narrowing which should be an error, here the warning about the implicit conversion is a true warning, about code that has well-defined behavior according to the Standard but is squirrelly anyways.)
&gt;An image width is naturally always positive, so `unsigned int` seems to make perfect sense. But coordinates can be negative and you constantly have to mix `width` with signed coordinates. Good point (although I don't see why image coords could be negative). But usually coordinates are two dimensional so you could write a proper type that has correct behavior in this case. 
`boost/typeof/msvc/typeof_impl.hpp` (included from `boost/typeof/typeof.hpp`) is one I recall offhand; I'll check my notes at work tomorrow for more.
Paste it to codepad and give me a link.
Here you are http://codepad.org/GLr50NwK I finished it, I just want to learn how to make it better.
&gt; The problem is that while the source value is unsigned, it is promoted to a signed int for arithmetic due to being smaller than int, and thus the indexing expression is signed. That isn't how integral promotions work. Note that `lookup[z[i] * 4u]` behaves correctly even though the type of `z[i]` is unchanged. ;-] (Great comment otherwise, I don't mean to detract from that...)
Slides not yet available. Hopefully they will soon be posted in [the CppCon presentation materials repository](https://github.com/CppCon/CppCon2016). 
This sounds like utter nonsense to me. By his logic, it would be impossible to write software in any language. It will all end up calling machine code somewhere anywhere, so you cannot write pure software in "just that language".
Checkout puredata, DSPatch, Synthesis Toolkit (STK). Depends if you want to focus on the whole user application or single moduls like effects. DSPatch is easy to learn. STK is more complex and for single moduls. Checkout out JUCE also. Many famous audio applications use this framework as well. Last but not least have a look at open framework.
Indeed; this thread has been axed.
Hi; this post is off-topic for our sub. You can post in [the stickied hiring thread](https://www.reddit.com/r/cpp/comments/4qrtqw/whos_hiring_c_devs_q3_2016/), though!
This post was removed from /r/cpp as it is off-topic; C++ questions should go to /r/cpp_questions or [StackOverflow](http://stackoverflow.com/).
Can you post a link?
You should offer free tickets to those who don't have enough money to buy it, not to those who belong to a certain sex or race, there is no reverse discrimination, only discrimination. 
??? If I wouldn't use debug build I would not have noticed it! This is an error, I'm thankfully it was noticed.
[removed]
Can you compare with my [sparsepp](https://github.com/greg7mdp/sparsepp)?
Thanks for the feedback, I'll try to improve on this site next year.
&gt; Finally, unsigned integers for always positive is a really bad idea. The reasons for this have been beaten to death; you can find a wide variety of C++ gurus discussing this point and invariably coming to the same conclusion. And it's as wrong as it ever was - guru or not: non-negative should be modeled as unsigned. Jonathan, you're totally right about that! As much as you went overboard with your suggestion to have string.back return an optional. Narrow preconditions are a blessing, thickening the interface by sprinkling optionals all over the place is a burden. Widening the interface of string.back just pushes the responsibility of handling empty strings from the caller of string.back to the user of the returned value. Much pain for no gain.
Sorry, was unclear. I was thinking about where you say "Windows build hangs". That is because of the failed assertion, and I agree it is a good thing, but again not on a build server. MS lib gives you the ability to check (it throws exceptions) in retail builds. That would have been a better option for you if you wanted to catch this error, as it fails, does not block the execution.
Ah, yes I need to enable it.
[deleted] ^^^^^^^^^^^^^^^^0.8098 &gt; [What is this?](https://pastebin.com/64GuVi2F/96168)
Hum, the memory usage curves definitely are not correct. It shows that the memory usage of dense_hash_map and sparsepp are somewhat similar, and I have verified dozens of times on different platforms that this is *not* the case.
&gt; The crowd that prefers an unsigned `std::size_t` should run UBSan with unsigned integer overflow check enabled over their own projects and report back with the numbers of bugs it finds. But unsigned overflow isn't UB, signed overflow is... o_O
It's not about overflow being well defined it is about semantics. Unsigned is more natural for well unsigned values. I don't have to deal with negatives values in the code I deal with, so I only use unsigned, mainly std::size_t
-ffast-math can change the results of various floating point operations, -O3 can sometimes make the code slower by blowing your instruction cache up and -march=native can stop the resulting executable running on other processors (or kill performance on other processors if it does run). Don't just blindly throw those on without checking they make sense for your use case and profiling before/after.
[deleted] ^^^^^^^^^^^^^^^^0.9839 &gt; [What is this?](https://pastebin.com/64GuVi2F/44052)
how did you measure memory usage? In windows I use GetProcessMemoryInfo() and report PagefileUsage.
&gt;As much as you went overboard with your suggestion to have string.back return an optional. Narrow preconditions are a blessing, thickening the interface by sprinkling optionals all over the place is a burden. Widening the interface of string.back just pushes the responsibility of handling empty strings from the caller of string.back to the user of the returned value. Much pain for no gain. But a (properly designed) optional makes it harder to use it incorrectly and catches errors as I've demonstrated. Whether or not that is worth is a different question. 
&gt;All the time, e.g., implementing a simple vector, one might want to do something if there is less space than for new `N` elements: `N &lt; capaity() - size()` instead of `N &lt; size() - capacity()`. Both will be true, because on wrapping arithmetic the result will be huge, but one is a bug and the other isn't. Good example. But it is still a bug with signed, just a more noisy one. And as you said, there are analyzers to catch it. 
[deleted] ^^^^^^^^^^^^^^^^0.3974 &gt; [What is this?](https://pastebin.com/64GuVi2F/20318)
Note that there are so many optimization flags in gcc that finding the right combination of them for any one application has become a problem for autotuning: http://groups.csail.mit.edu/commit/papers/2014/ansel-pact14-opentuner.pdf
Never underestimate the power of PyPy! ;-)
Sigh. The problem is that just because a number happens to be non-negative, doesn't mean it won't be involved in subtraction at some point in the very near future. Why do you think writing backwards for loops in C++ is such a disaster? http://stackoverflow.com/questions/275994/whats-the-best-way-to-do-a-backwards-loop-in-c-c-c http://stackoverflow.com/questions/665745/whats-the-best-way-to-do-a-reverse-for-loop-with-an-unsigned-index Or if you want to use your indices for something: Matrix m; double func(double); for (size_t i = 0; i != m.rows(); ++i) { for (size_t j = 0; j != m.columns(); ++j) { m[i][j] = func(static_cast&lt;double&gt;(i-j)); // oops } } I'm sure these examples play into why multiple committee members have definitively said it was a mistake for `vector::size` and `vector::operator[]` to use unsigned. Unsigned integers do *not* model non-negative integers well. They model a modular integer space. It's not the same thing. A good non-negative integer would, if constructed from an integer, check if the integer was negative and then throw an error. Unsigneds never do this. At best, you'll get a warning from the compiler, so you end up shutting it up with a static cast, which means you are right back where you started. Anyway this isn't meant to convince you, since if Bjarne and Herb can't convince you then I'm certain I can't. This post should be considered a public service announcement to anyone else reading this thread, so they don't get misled.
adding to fast-math: this will disable nan checking functions, like isnan(). 
Really, the main feature is VS2015 support. Everything else, if it wasn't there, I couldn't care less. 
This looks really nice. I found a new way to do void replace which makes it a little less cumbersome but everything you did looks much better. I'm going to need to read up on range-based, never heard of it. Also, in the printVector, it all says account.name, lines 84-90. I figured that was just a mistake and not intentional right?
Yes, excuse me, that is a typical copy&amp;paste error.
This is great! Most of the stuff here is common template knowledge, but it's nice to have the knowledge written down and presented in a structured way
OK, I think the poor memory usage result of sparsepp is due to the fact that you ran your benchmark on Windows, where the memory allocator does poorly with sparsepp memory allocation pattern. I'll look into addressing that. I have mostly tested on linux/macos. Thanks for alerting me to this issue.
actual tl;dr: Compiler switches exist. Use them. There is no magic combination to guarantee the best performance for all code and architectures, so measure.
[removed]
So... are eastern Europeans minority groups? A white able-bodied straight male who would have to spend 2 months of salary to even pay for the ticket - would they qualify for diversity? Huh? I love it when people are narrow-minded, prejudiced and discriminatory to feel good about themselves being better than their peers who wear their bigotry on their sleeves.
meh! Your contrived example is easily made correct by static_casting to int rather than to double. If you want make things fail you can - the beauty of C++. I can't see why people are always arguing about the well-defined modulo semantics of unsigned integers when going over the boundaries of their respective value domains rather than arguing about the undefined semantics of signed integers in the same scenario. In both cases you have to think about the consequences. This is not a property that applies to unsigneds only.
I see this issues, will improve on this next year. Also, as I said, apply in this case. I'm also interested to know who they exclude, and why. 
Agreed. If I might summarize: Counted value expressions are non-negative (usually) only *by construction*, not by definition. The simplest illustration of this I can think of: std::distance( begin(c), end(c) ); That this impedance mismatch doesn't cause more practical problems is only due to the fact the language allows implicit conversion between the signed and unsigned integer domains (which I regard as a critical mistake). The implicit conversion does not make the code more correct, it can only hide problems.
Sure, it's just making it much easier to fail, it's a question of degree. My example isn't contrived either, ever hear about a Toeplitz matrix? &gt; I can't see why people are always arguing about the well-defined modulo semantics of unsigned integers when going over the boundaries of their respective value domains rather than arguing about the undefined semantics of signed integers in the same scenario. No problem, then let me explain it to you: because "only non-negative" quantities are likely to get involved in subtraction, and because zero is such a common value, it implies that unsigned underflows are going to be way, way more common than signed over/underflows. Signed over and underflows only happen when you really picked too small of a width. Unsigned underflows happen all the time, because the *most common value is one decrement away from underflowing*. It really says something that probably one of if not the most natural way to write a reverse indexed for loop is actually bugged with unsigned for exactly this reason.
So much this. If you don't listen to what your compiler has to tell, you deserve to be punished.
disclaimer: I help organize some of these C++ conferences We don't, _in particular_, want more women or less white males or etc. _What we want is for anyone who is interested, to feel welcome and safe to attend our conferences._ Is that currently a problem? Are there people who feel unwelcomed for some reason (besides "I find C++ scary")? Hard to say. I think/hear there is evidence of that at some tech conferences. If it is a problem, why is it a problem? Also hard to say. Might be lots of societal issues intertwined here.. As conference organizers what can we do? - Shout loudly that we welcome everyone. - Tell attendees and speakers not to be a\*\*holes, and that we won't put up with them if they are. This should not need to be said, but maybe it does. Or maybe saying it just helps someone who was tentative about coming. (Also, Political Correctness can be taken too far, but let's at least not be a\*\*holes.) Now the question is, is that enough? If the root causes are beyond our control, is there anything conferences can really do about it? Or Is it beyond our control? Or does a more diverse conference eventually lead to more diversity in the field, in the next generation? If so, should we "incentivize" diversity now? In effect make white males now pay the (small) cost of a past societal mistake, in order to correct it in the future? (I would say there is a high likelihood that white males have unfairly gained elsewhere more than they are unfairly losing here, but I'm not sure if that is justification.) Hmmm, I've led a couple of lunch time impromptu philosophical discussions at C++Now, maybe I have a topic for next year... You could make the same argument about student programs, etc - is it a conference's job to correct economic injustices, or should that come from "society" or government? You could also argue that society *is* just people and organizations. The conference is part of society. Society isn't some other thing "over there". Is "shout loudly" and "not be a\*\*holes" enough, or should we do more? If so, what? How? I think you could summarize the current diversity program as "reality is, it seems we need to do something to get the ball rolling". That's not a water-tight argument, but Â¯\\\_(ãƒ„)_/Â¯ it's something. 
I mostly agree with what you write. My goal still is that we have *fair* diversity programs for Meeting C++ and CppCon (which currently lacks anything like that). I had to get started somewhere, and otherwise we'd never had that discussion, to include the community to improve things for everyone.
Went to download the binaries today and saw "Version 1.62 &lt; 2hrs ago" and I felt like I had a sixth sense.
[deleted] ^^^^^^^^^^^^^^^^0.3857 &gt; [What is this?](https://pastebin.com/64GuVi2F/11123)
[deleted] ^^^^^^^^^^^^^^^^0.2347 &gt; [What is this?](https://pastebin.com/64GuVi2F/60271)
Can somebody eli21 fiber for me?
It's a mixed bag (see StackCrooked sibling comment), some code is tighter with unsigned.
What's more annoying is that CUDA 8 RC only worked with Update 1. That's just evil. Right now, I'm running some sort of Frankenstein monster: build tools from 7.5, VS support from 8, and a completely unrelated NVIDIA driver after the included ones gave me blue screens.
If I follow the logic, there can be no such thing as a Python package manager because some Python modules are implemented in C or C++. When I pip install something, I am presumably not acting with a sane mind? As far as I can tell, the actual point of the essay was, "We kind of like Python for some things, so we used it to make a package manager you can use when writing C++." Just with a bunch of nonsense statements and absolutes and straw men thrown in to try up pad it out.
While everyone arguing about int vs uint, I wanted to ask, why don't stop with is_whitespace(str.back().value_or('\0')) Basically is_whitespace contract should be false for any non white-space characters, and those '\0' would be invalid value for it.
Hey thanks! So what would be the actual advantages? No OS overhead?
&gt; No OS overhead? That's one part. Also you don't have to worry about locking shared data as your code doesn't get interrupted randomly by other code. 
but this means that stuff don't really happen in parallel then ? what's the difference with an event queue ?
That might be my "fault", in the sense that I've been using new compiler hooks implemented in C1XX, EDG, and Clang, but not tested against NVIDIA's compiler (which I vaguely recall is EDG-based, but not necessarily the latest build that we're using for Intellisense).
SVN Clang with "-std=c++1z" has P0145R3 and P0400R0 already implemented [1] [2]. So I think clang is correct here. [1] http://clang.llvm.org/cxx_status.html [2] [Part 1](https://github.com/llvm-mirror/clang/commit/d91ab1cef18793b49a4940a5f842cec23eff7bfb) [Part 2](https://github.com/llvm-mirror/clang/commit/3f92868b7e1fb0b9e49e9407ff3f2c0e7f8d07ea) [Part 3](https://github.com/llvm-mirror/clang/commit/5b3280c92156724556fda9ff06e804f397cb3df7)
You could just use [linq](https://github.com/pfultz2/linq) which works with any c++ range.
At about 41 minutes in there's a slide on "Literals: C++17" which contains: &gt; auto multi = 'Ã¼'; // int since '98 This isn't strictly correct. According to the grammar, if `Ã¼` is a member of the (extended) source character set then the character literal contains a single _c-char_ and is therefore _not_ a multi-character literal. &gt; _character-literal:_ &gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`'`_c-char sequence_`'` &gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`L'`_c-char sequence_`'` &gt; _c-char:_ &gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;any member of the source character set except the single-quote ', backslash \, or new-line character &gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_escape-sequence_ &gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_universal-character-name_ &gt; &gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_â€” C++98 [lex.ccon]_ &gt; An ordinary character literal that contains a single _c-char_ has type `char`, with value equal to the numerical value of the encoding of the _c-char_ in the execution character set. &gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_â€” C++98 [lex.ccon]/1_ The correct behavior is clear if the execution character set can represent the character with a single numerical value that fits in a `char`, and this is different from what Alisdair's slide describes. An example of this is if you build using gcc or MSVC with the execution character set configured to ISO-8859-1 or CP1251. However there's a corner case for which the standard doesn't doesn't allow: If the execution character set does not represent the character as a single numerical value that fits in a `char` (e.g., UTF-8) then standard's specification does not make any sense, and different compilers have done different things. GCC and MSVC will treat the character as a multi-character literal as described in Alisdair's slide. Again, this is not mandated by the standard, and in my view it's not very sensible behavior. The reason for this behavior is that it's simply an accident from before GCC had explicit support for multi-byte source encoding and which has been preserved. When MSVC added support for setting the execution encoding to UTF-8 they simply emulated GCC's behavior. Clang will instead produce an error, which I think is the sensible behavior. error: character too large for enclosing character literal type auto x = 'Ã¼'; ^
I am not sure why there is not a per library pre-compiled header system. Seems that this will do the same thing as modules yet keep all the c/c++ features. as well as simplifying the includes. 
Presumably stackful coroutines?
~~I believe this is referring specifically to `__stdcall` functions. `__cdecl` functions have the cleanup in the caller. But I could be totally mistaken.~~ Actually it says it's specific to operator overloads which should end up being `__thiscall`, so now I'm confused.
It (the part that got into C++17) doesn't impose order of evaluation on function arguments, gcc is equally correct.
This is a link to the introductory post on my website about a new blog series I will be writing. In it I am going to implement (most of) the C++ STL from scratch, and release the source code on GitHub, as a resource for others to learn about the STL. I should have the first post on pairs, tuples, and index sequences posted in a few days, along with the source code pushed to the GitHub repository ([link here](https://github.com/daltonwoodard/stl-from-scratch.git)).
Sorry, I goofed up that example because 4 is an int. A better example is adding two unsigned chars, which also produces int instead of an unsigned type.
I have read the slides but I'm very confused. I was always told ffast-math is dangerous and should not be used. What do people here think about it? Also other than this, I cannot see a significant performance increase between -03 and -02. At the beginning it says GCC has 2200 something switches. But the main idea is to turn on ffast-math? Is that it? I was expecting more.
IIRC, on x86, thiscall is like stdcall except `this` is in ecx, no?
This sounds like a very interesting series to follow. How long are you expecting the series to last?
&gt; I've never heard of a 'fiber' in programming. Because (unlike coroutines) they're a systems/OS concept, not a programming concept. Fibers are cooperatively-scheduled usermode threads; coroutines are a glorified flow-control mechanism.
If you're recruiting for a position that requires working mainly in C++, why would you interview with anything else?
&gt; Now it is possible to retrieve actual name of the type as const char* at compile time. So we can do a lot of interesting things at compile time: check namespace of a type, sort types according to their lexical representation, check that type is a template type and so on... A few examples were provided. Santa came early this year.
I think I understand. I'm going to spend the night putting it into my code.
As long as `Colour` doesn't have any constructor taking just an `std::initializer_list&lt;&gt;`, the following is guaranteed to work (excepting compiler deficiencies, e.g. non-current MSVC): Colour colour{bp[cp++], bp[cp++], bp[cp++]}; // or auto colour = Colour{bp[cp++], bp[cp++], bp[cp++]}; (If `Colour` does have a constructor taking just an `std::initializer_list&lt;&gt;` it will still work, just via `std::initializer_list&lt;&gt;`'s idiosyncrasies.)
&gt;I expected a slightly deeper dive into the optimization flags I really would have liked to have gone deeper into the flags. There are so many little things that each flag can give under very specific circumstances; and that's before you start using "--param" in gcc! I would also have liked to have spent more time looking at the assembly emitted by each compiler and the effects each flag had on a given problem. However, there is only so much you can do in 45 minutes, and my goal was to get folks talking about compiler flags. In particular, I want folks to start talking about *actual measurements* made using different flags with different types of software (my needs in scientific computing are likely quite different from someone working on audio processing, for example) rather than relying on old mythos and FUD.
paging u/STL
&gt; (excepting compiler deficiencies, e.g. non-current MSVC) Event current MSVC (2015) has issues with correct ordering of init lists in some cases. I haven't tested VS "15", however.
It depends on the compiler. What does VC do with this? #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;iomanip&gt; int main() { std::cout &lt;&lt; std::boolalpha &lt;&lt; std::isnan(std::sqrt(-1.0f)) &lt;&lt; std::endl; } g++-6.2 -O3 -march=native test.cpp &amp;&amp; ./a.out &gt;true g++-6.2 -O3 -march=native -ffast-math test.cpp &amp;&amp; ./a.out &gt;false clang++-3.9 -O3 -march=native test.cpp &amp;&amp; ./a.out &gt;1 // I guess clang doesn't understand what std::boolalpha does... clang++-3.9 -O3 -march=native -ffast-math test.cpp &amp;&amp; ./a.out &gt;0 icc-2017 -O3 -march=native -fp-model strict test.cpp &amp;&amp; ./a.out &gt;true icc-2017 -O3 -march=native -fp-model fast=1 test.cpp &amp;&amp; ./a.out &gt;true icc-2017 -O3 -march=native -fp-model fast=2 test.cpp &amp;&amp; ./a.out &gt;true The only option for icc that mentions NaNs is "-fimf-domain-exclusion" which "indicates the input arguments domain on which math functions must provide correct results" but doesn't mention a default value.
If you've ever used NodeJS, the programming model is functionally very similar.
Stackful and scheduled.
[Presentation can be found here (PDF)](https://github.com/CppCon/CppCon2016/blob/master/Presentations/Elegant%20Asynchronous%20Code/Elegant%20Asynchronous%20Code%20-%20Nat%20Goodspeed%20-%20CppCon%202016.pdf). You can find most of the CPPCon materials on [github](https://github.com/CppCon/CppCon2016). 
I'm a new grad, not an experienced senior dev applying for a super specific position.
Is Raymond Chen on here?
I ask if pseudo code is okay, and if not use C++. Usually they're fine with pseudo code though.
[deleted] ^^^^^^^^^^^^^^^^0.8149 &gt; [What is this?](https://pastebin.com/64GuVi2F/49046)
That's quite possible. The SAXPY example really tests the memory bandwidth and the CPU's ability to maximize ILP with a very tight loop. If you had a test problem with more instruction or data streams, then the instruction reordering and register scheduling that becomes more prevalent at -O3 in gcc (less so in clang and icc) would likely play a larger role. I should look at their benchmarks. I've seen them referenced before.
[deleted] ^^^^^^^^^^^^^^^^0.0229 &gt; [What is this?](https://pastebin.com/64GuVi2F/44311)
[deleted] ^^^^^^^^^^^^^^^^0.2996 &gt; [What is this?](https://pastebin.com/64GuVi2F/08148)
GLM has swizzling! Anyway in my opinion the comparison is not really QVM vs Eigen (because Eigen is a full-fledged linear algebra library, which QVM isn't), the comparison is QVM vs GLM. (and potentially vs other libraries which I don't know) Or more specifically, what is worth comparing with regards to Eigen is QVM vs Eigen's Geometry module (and not specifically a comparison against the whole of Eigen).
GLM as well I think
Always true. C:\Users\Billy\Desktop&gt;type math.cpp #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;iomanip&gt; int main() { std::cout &lt;&lt; std::boolalpha &lt;&lt; std::isnan(std::sqrt(-1.0f)) &lt;&lt; std::endl; } C:\Users\Billy\Desktop&gt;cl /EHsc /W4 /WX /O2 .\math.cpp &amp;&amp; math.exe Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24406 for x86 Copyright (C) Microsoft Corporation. All rights reserved. math.cpp Microsoft (R) Incremental Linker Version 14.00.24406.0 Copyright (C) Microsoft Corporation. All rights reserved. /out:math.exe math.obj true C:\Users\Billy\Desktop&gt;cl /nologo /EHsc /W4 /WX /O2 /fp:fast .\math.cpp &amp;&amp; math.exe math.cpp true C:\Users\Billy\Desktop&gt;
&gt; In the figure on slide 40, you can see that -O3 is worse than -O2 for each compiler on Skylake, but better for clang on Bulldozer. The slides linked here only go to 33; to which figure are you referring?
Perhaps my summary was a bit flippant. I did enjoy your talk. I appreciate the emphasis on measurements and on different platforms. However, I was a little disappointed that the talk promised a discussion on the many multitudes of compiler switches but concluded with, essentially, `-O3` makes things faster.