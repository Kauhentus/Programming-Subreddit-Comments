&gt; The test was done with the source code and includes on a regular hard drive, not an SSD. A comparison of SSD versus HDD will be done later. Not sure I see the point, but ok.
I personally more interested in task-chains/task-continuations capabilities, and not in parallelized versions of *for\_each*, *reduce* algorithms and etc. From your comment I assume that i should dig more into TBB and that's probably what i'm looking for.
So how much I inject generated code into a class then without this?
Let me rephrase. Do you have any practical examples of the library in use? (C++ is my bread and butter but I've been learning Haskell for a few years.)
They are not included conditionally. The TableGen tool generates stuff based on DSL, which when can be used to fill all the boilerplate structures (or some other boiler plate stuff can be abstracted in a "template"), like [this](https://github.com/llvm-mirror/llvm/blob/42f63b6f964b7f33d207f92ed47d9d8cf96218fd/tools/llvm-mt/llvm-mt.cpp#L42) (notice how it's sued several times) or [this](https://github.com/llvm-mirror/llvm/blob/838b95b50e9680f5effabb2af2351124addeaa81/lib/BinaryFormat/Dwarf.cpp#L37_).
Let me rephrase. Do you have any practical examples of the library in use? (C++ is my bread and butter but I've been learning Haskell for a few years.)
I wonder if he uses 1 file for the unity build, or 1 file per processor/hyperthread. If the former then huge speed gains are possible. Note that cotire does the latter by default.
Maybe, you should also look into the things that are slated for C++20, just a random page: https://www.modernescpp.com/index.php/tag/c-20 gives you an idea.
&gt; I don't want to discourage you you didn't, it was sarcasm :-). i've been using C++ for 20 years, and happy to admit that i have a limited knowledge of it, about enough for my purposes. there's much more to programming than being a guru in a particular programming language, especially in such a monstrosity as C++.
I agree that there are better ways to handle the specific case of dependencies. I disagree that the #include mechanism itself is legacy. 
Maybe for my one example, but the point is you can't prove that a language feature will solve all of the problems someone might hit, which is what makes the preprocessor so powerful: it may be janky but it won't outright prevent me from doing something or make me jump through crazy architectural hoops. 
I believe this is off-topic for the C++ subreddit.
I meant that for the OP. You seem pretty battle-scared to me 😄
Thanks! Although i would like to hear more opinions, it seems that I've got what i wanted.
Oh that's your goal? Now I have a way better reason never to do that: security.
Yep, I did say that. To clarify, it was about codegen size (which is important, although not all-important; it is a highly imperfect proxy for runtime perf). With modern inlining and ICF, I haven't seen templates exhibit pathological behavior in the wild, except for heavy overuse of std::function. For throughput (compilation speed), templates are generally stressful. std::function overuse is bad for throughput, but not uniquely bad. We are working on using `if constexpr` to improve both debug codegen size and release/debug throughput; this is a work in progress (at the moment, finishing C++17 is higher priority).
What does that have to do with anything? Maybe I have a code/data dependency and generate enums from it? The point is that the #include mechanism is a powerful feature, and is not necessarily legacy. 
I'm not saying preprocessor directives are "legacy". I'm saying there's a difference between what you CAN do and what you probably should do.
What one *should* do usually depends on a whole host of complicated inputs. You assuming that I shouldn't do something means you presume to know more about my problem and constraints than I do, which outside of trivial problems, is unlikely. And that's the point.
&gt; Just install LLVM is easy. Super easy with https://scoop.sh/ scoop install llvm Done. If you don't use scoop, check it out. It's nice.
Sure, but such clever tricks are part of the reason for the success of C++. They're not always ideal, but they're usually better than the hoops other languages make one go through when the language support isn't there for something. 
You're probably right. Should I delete the post or should i edit it so that all the PPL and other C++ related stuff will appear in the topic?
not just any model. it's [this one](https://www.amazon.com/Wenger-16999-Swiss-Knife-Giant/dp/B001DZTJRQ).
Although ranges v3 does show passing an array as sort(array)
On that note ranges v3 does show passing an array as sort(array)
Is Chinese required for the job?
Not so much. Our software focuses on modeling spacecraft orbit trajectories.
But 20% faster is not really a big deal. A nice improvement for sure, but it won't alter your work flows or make any other significant change to how you work.
I don't see why headers are a big problem. Having the interface separate from the implementation, to me, is a good thing, though of course it more wordy. Visual C++ has a service that works behind the scenes. It keeps up with what's been built, caches output, and so forth. That makes a significant difference in performance. I have a full virtual kernel that abstracts my code away from the platform (and the STL as well.) [https://www.reddit.com/r/programming/comments/a2wnwt/creating\_a\_virtual\_kernel\_platform\_abstraction/](https://www.reddit.com/r/programming/comments/a2wnwt/creating_a_virtual_kernel_platform_abstraction/) Having separate interface and implementation means I don't have to do an abstract interface for every class in the virtual kernel, and then do derivatives of it, and have factory methods probably to gen up the right ones for the current platform. I can just have headers that provide the interface, and implementations for each platform. It's simple and straightforward and there's not thousands of virtual methods involved, because there's no inheritance required. And the code layers above the virtual kernel, which wrap that functionality, can just directly create objects by value. So, you know, C++ giveth, C++ taketh away. All languages have their pros and cons and any given aspect of the language may be one or the other depending on the needs at hand. &amp;#x200B;
That was my understanding of iota - a very small amount. Which is exactly what you do: add an iota. So to me the name makes sense. 
1. So can I, but it's still a fact that when looking at the standard implementations around (especially MSVC) it's really bad. It's even worse with `std::unique_ptr` which would really benefit from being part of the language (at least the version with default deleter). Just take a look at its `operator*` callstack. I'm not even speaking about `std::move` and `std::forward` that require pulling in headers. Hell, if we follow the logic then `reinterpret_cast` should have been `std::reinterpret_cast` and implemented as `static_­cast&lt;cv T*&gt;(static_­cast&lt;cv void*&gt;(v))` 2. `If you made this built in, you just crippled my ability to work around parts of the standard that my compiler doesn't support (properly, or at all).` How so ? Were you planning to implement yourself something in the std namespace ? That's undefined behaviour. Or as you are saying: `I regularly have to re-implement many std namespace features in my own namespace` then what would it change in this case ? You're still allowed to implement your own functions ? And you'll end up calling intrinsics anyway. Doubt you'll do better unless you switch to asm (and then clobber more things because memory ordering is harder to implement that way) So no, having it as a builtin doesn't prevent you from implementing your own version.
We have a sticky post for job offers. Please post there. Thanks.
Doing this make code non browsable by tools. Also it's not the same at all: C# partial classes let you compile only the part you're modifying while including headers within C++ classes will make it recompile everything anyway.
Declare a method in the source code and its definition in a separate generated file? 
I wager that for most C++ developers, that's irrelevant. The C++ devs in my organization get the tools provided to them by myself. If I can't get it to work, they can't either. Individual developers running tools on their own is outside my scope. They can do what they want, they just can't cry to me about it.
I never said it's a big deal, but precompiled headers are a low hanging fruit . It requires configuring it once and then you benefit from it during every build. Also, 20% might not seem like it's much, but for example if a change in some of our global headers resulted in 20% compilation slowdown it would be considered a regression.
We have a file with lots of anonymous lambdas, and it's the slowest to compile. Simple WPA capture over visual studio 2017 compiler reveals this: e.g. c1xx.dll!LambdaProcessor.CreateUniqueName calling BCryptHashData [https://imgur.com/a/ZYNt4ZP](https://imgur.com/a/ZYNt4ZP) I can't get the proper flame graphs, so can't tell how much it affects - but made me wonder - is it really necessary to use cryptographically strong function, in order to come up with unique lambda name - something like MD5 might be just enough? /u/STL? &amp;#x200B;
If the concept of a "Foo" is built into the language, and not something that's available at the standard library level in some manner, then in fact it might not be possible for someone to write their own version of it in a way that's standardized. Yes, in this situation, std::atomic can be written by hand, with hand-optimized inline assembly, but that's not standardized. (Note that this is what I did, so I know full well that it's possible). I have to write different inline assembly for MSVC vs GCC vs Clang. Each of those compilers provide compiler-built-ins to make the job easier, but it's *still* not standardized, and I've got test cases that demonstrate situations where the intrinsic produces suboptimal assembly. I've reported them as appropriate of course (Or found existing bugs in the appropriate trackers). But consider a universe where std::atomic (or whatever this other universe calls the same notion) was built into the compiler as a primitive type in the same vein as int, size_t, etc. Why would these compiler vendors offer the intrinsic(s) that I use to implement my version of std::atomic? There'd be little reason to offer these if the entire notion of an atomic integral variable is a built in type. So someone who wanted to write their own would need to fall back to only inline assembly. This is nice because it provides some rudimentary manner of inlining, saving a few operations here and there. But if inline assembly wasn't an option for whatever reason, your only recourse is to hand-assembly a .o file from assembly, and link that in, effectively preventing LTO. So, while it's *obviously* possible for feature "Foo" to be implemented as a built-in, doing so has second order effects that make some people's lives more difficult. 
Hmm, I didn't immediately know there's a difference between those 2 in this regard? Or maybe I did but just wasn't conscious of it... have any docs to read for this topic?
&gt; So can I, but it's still a fact that when looking at the standard implementations around (especially MSVC) it's really bad. Why is it really bad? What are they doing incorrectly? Not that I disagree, I've found several issues with the assembly code for atomic operations as generated by GCC and Clang (and found the appropriate bugs on their trackers to keep a watch on), but what, specifically, is MSVC doing wrong? /u/STL would likely want to know, I imagine? &gt; It's even worse with std::unique_ptr which would really benefit from being part of the language (at least the version with default deleter). Just take a look at its operator* callstack. Why would it benefit from being part of the language? What's wrong with the operator* function? I've implemented my own std::unique_ptr, I didn't consider it particularly hard to implement, or something that I'd like to see implemented by the compiler directly. &gt; I'm not even speaking about std::move and std::forward that require pulling in headers. Ok? I mean, the specific placement of these in the headers they're in could (I suppose?) be better, but what's wrong with these being library functions? It's not like it's hard to implement them as library functions. Don't get me wrong, I'd love to see more automatic behavior with regard to rvalue-references, such as return func(param, param); //&lt;- Can't use std::move, cause you don't know the order of evaluation But that doesn't really require they be built-ins, since the compiler can internally implement the notion of "cast to rvalue-reference" without needing to rely on std::move. &gt; Hell, if we follow the logic then reinterpret_cast should have been std::reinterpret_cast and implemented as static_­cast&lt;cv T*&gt;(static_­cast&lt;cv void*&gt;(v)) Yes, that would be wonderful. Dynamic cast as well. I'd say const-cast and static-cast too, but I'm a bit too tired to fully think on how one would do that at the moment. For your reply to #2, I see your point, and I explained my concern poorly. Please see this reply to the other person I answered in this thread: https://www.reddit.com/r/cpp/comments/adg4tv/c_headers_are_expensive/edihd0w/ 
As an alternative easy way, one can install llvm through `chocolatey`.
Why not just an incrementing unsigned integer converted to string? They'll all be unique and O(N) time to give names to every lambda where N is the number of lambdas you have.
**Company:** [Curtail Security](https://curtail.com/) **Type:** Full Time **Description:** We develop networking software in C++ that runs in Linux containers. Candidates should be familiar with C++11 or newer, Linux environments, and TCP/IP networking. We are a small startup company looking for motivated coders that want to develop tools to support containerized DevSecOps environments. **Location:** Irvine, CA **Remote:** No **Visa Sponsorship:** No **Technologies:** C++14, Linux, Boost, Docker, Kubernetes, TCP/IP **Contact:** Email jobs -at- curtailsecurity.com or send a direct message here
The difference is forwarding references only happen when `Args&amp;&amp;...` is deduced. If you explicitly specify the types through `class_t&lt;int, double*, char&amp;&gt;`, then since they are not deduced, they become exactly what you told them to.
You are assuming these should be forwarding references, which can only be deduced, not specified. You need to read more about forwarding references, chances are you might be using them incorrectly in some cases.
Just because it *can* be done in a library instead of in the language itself, doesn't mean it *should* be done in a library instead of in the language itself.
Even VS Code has auto formatting
Interesting, what technique are you doing with if constexpr to reduce compilation speed. Going through the library and replacing SFINAE constructs with if constexpr or something similar?
I have zero idea what this has to do with the thread. 
Well, a template is something that stamps out instances (conceptually, don't take it too literally) of whatever it's a template for. A function template stamps out functions. A class template stamps out classes. A member function of a class template gets stamped out when the class is stamped out (conceptually, again, in practice member functions don't get stamped out until used which is important for a number of reasons). In a function template, it has its own template parameters that have to be deduced from arguments, or specified. In these examples where we talk about perfect forwarding, `Args` is a variadic, deduced pack of template parameters. Because it's deduced, the correct thing to do is typically `Args&amp;&amp;...args` and then the usually `forward` stuff. This causes perfect forwarding, and such. In a member function of a class template, the template parameters that are appearing are actually template parameters of the class. The class in question is already completely fixed before the member function call goes off, so the `Args` in the member function are not deduced at all. They are decided by the type that you are calling `operator()` on. Since the types aren't being deduced, perfect forwarding isn't actually possible; perfect forwarding is a mechanism that involves deducing the types at the usage site, at compile time. But the whole point of type erasure is to hard-fix signatures and then dynamically dispatch, so this isn't compatible (e.g. no virtual templates). The `Args` is exactly the hard fixed signatures, which the user gets to pick. When you add `&amp;&amp;` you don't cause perfect forwarding because there's no deduction at the call site. Instead it simply changes all the argument types in accordance with certain rules. And this actually isn't what you want. For example, suppose you have a `std::function&lt;void(int)&gt;`. If you use `&amp;&amp;`, then again, because there's no deduction happening, `operator()` will simply take `int&amp;&amp;`, always. This means that you can't pass it a const integer, for example, because you would throw away the const qualifier. Probably not what you want.
Only works for functions, not things like enums. Anyway, people always say things like "just do x, or just do y", but there are usually constraints preventing such "simple" solutions. 
Then stay out of it? &gt;&gt; For formatting there is clang_format which seems to be a nice way but I am using gcc for compiling my code and to format my C++ I have to suddenly install clang tools. This just leads to more work and effort. &gt; sudo apt install clang-tools &gt; You call that ‘work and effort’? I was pointing out that even in the specific context of the OP's complaint, installing something that isn't otherwise available/installed is "work and effort" regardless of how "little" work it appears to be. And in the more general sense, there's a lot of work involved in supporting bespoke tools of various makes and models with the build systems of C++ development teams. Ultimately my point was that it's inappropriate to say "sudo apt install clang-tools" is so little work that you're silly for complaining about having to install something, because even though sometimes the person who needs to install it really can just do a one-liner, the majority of the time it's no where near as simple of a task.
It's one simple line that can be copy and pasted from all over the internet. You for some reason feel the need to come in with an avalanche of unrelated nonsense from your own frustrations.
There are probably many other things to consider, for example Edit &amp; Compile, and who knows else what - not a compiler dev here, just user, the d is always in the d.
I think the answer to your question is that you can compile 2 .cpp files separately and in different period of time, on different computers. When they will be linked together you still need to guarantee that type of lambda from TU1 is different than TU2.
[removed]
I have already removed it; no need to delete.
I am not a compiler dev, but IIRC, we are indeed using MD5, it just happens to be via BCryptHashData. I know for a fact that the original 2010 implementation of lambdas used ascending numbers (lambda1, lambda2, etc.) which was nice after we fixed an epic bug involving PCHes (turns out if you restart the count within a TU, it's super bad), but caused problems for teams like Office that want to rebuild a program to generate a patch, while having the least amount of generated code change. Adding a lambda in the middle of a TU with ascending numbers causes all later lambdas to be renumbered. In response, we changed the lambda scheme to be similar to that for unnamed namespaces, hence the hash. Can you file a bug through Developer Community with a preprocessed file, so the compiler team can investigate the throughput issue here?
It's mostly replacing tag dispatch with `if constexpr`. We almost never use two-way SFINAE when tag dispatch would be sufficient.
It still only highlights typedefs if they end with _t. 
Our std::atomic implementation has been overhauled for the next major binary-incompatible version of the VC Libraries. The existing implementation relies on a lot of helper functions which is certainly not pleasant to debug through (but more pleasant than when it was separately compiled; I made it header-only just before it originally shipped).
I’ve seen people use jinja2 for something like that. 
I think LLVM has a custom solution for this. I don’t think it gets “embedded” into a class, tho. 
&gt; This printed "2017" 8-) so you're saying the tooling IS there!? :p (jk btw) &gt;I'd prefer at least static_assert(is_nothrow_...) yea 100%. i wasnt trying to say the unconditional noexcept was okay, but just speculating if it was intentional or not. anyway thanks again for your time!
Damn son, why didn't I hear about it earlier?
Because nobody talks about it and that's a huge shame!
I recreated the problem; it's already tracked by https://bugs.llvm.org/show_bug.cgi?id=39328 .
The linux Kernel. Or 80% of the packages in any distribution. C++ is actually a minority.
thanks! how big are the largest subsystems in the kernel? I've only seen small kernel modules myself, I was under the impression that everything is split into very small independent pieces, which is not something we were able to achieve into our huge commercial product
It's amazing how almost every problem in life can be explained by a Downfall or El Risitas subtitled clip.
&gt; It is actually easier to build large system in C than in C++ because C forces you to think about APIs and interfaces. This makes no sense and it's typical C advocate mumbo jumbo. You can write shit API and interfaces in any language, C included. With a proper type system and proper abstractions it is easier to build a large scale system as potential errors can be caught at compile-time rather than run-time. Choosing C over C++ or Rust nowadays is insanity.
No.
&gt; some games developers craving for the last drop of performance, which were suggesting a non-oop paradigm called data-driven-programming. Essentially C if you ask me (no oop, no stl, no templates, no exceptions, some classes but data structures mostly). This doesn't have anything to do with OOP. It's a change in how you architect your game state representation. Traditionally, you might have a GameObject and you have many of these. Each frame, you have to iterate over each GameObject do some collision, draw them, ect. This is usually referred to as Array of Structs (AoS). The alternative, is Struct of Arrays (SoA). Instead of having a bunch of individual GameObjects which are usually allocated on the heap (and the data they hold also probably on the heap somewhere) you isolate all the parts required during your update iterations and store all the data for each object within one array. This localizes all the data your iterating over, so that it's more cache efficient. Both methods make use of OOP or can anyways. &gt; I imagine that a game is a large piece of C/C++ software. Having worked in a 15 millions loc c++ code (but not in the games industry), I have to say is very very hard to maintain a clean codebase in c++ (forget about the c++ quirks, just the size itself is a problem) even if it follows the oop principles This isn't unique to C++. Large code bases that aren't architected in a uniform way always end up being kind of a mess with cross dependencies everywhere. Hell, even well architected ones I'm sure have their ugly parts that no one wants to dig into. Language can only go so far, architecture is a skill in and of itself usually developed through experience. I can't imagine how C would make anything easier, other than less 'hidden' aspects you might have to dig through, like template definitions, operator overloads or all sorts of other extremely convenient features that make development a less painful process.
For small function you mean stateless functions? You shouldn't have so many of these since you should use function pointers instead when you can.
Begone troll.
It sounds like you're thinking of something from Java that doesn't apply to C++. I don't remember the Java terminology, but something like a class has to be complete in one file. Java implementers weren't friendly to those who would develop external code generators. C++ doesn't have that nonsense. I'm working on a C++ code generator and what I do is [add function prototypes to a class.](https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/account.hh) Then in a separate, [generated file](https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/zz.middleBack.hh) the implementations of those functions are written. The code in the generated file is based on the first file I linked to and also [this file](https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/middleBack.mdl).
How your data is oriented in memory is largely independent (some exceptions) of the feature set used. There are many ways of getting e.g. polymorphic data contiguous in memory, some of which use fewer C++ features and seem more like C, others that use more. The point of C++ is that it's a language with more features, and more expressiveness, that allows you to approach problems in more different ways, and find the one that works the best for you. Not that it provides individual silver bullets, but lets you find a good set of trade-offs. On the internet you'll often see a lot of people present very biased viewpoints, because it's the kind of place where shouting louder and being kind of extreme gets more attention. It's not really a balanced view of things. OOP itself is not a panacea; following its principles doesn't automatically make a 15 MLOC codebase clean or maintainable. The most important things for making a codebase clean or maintainable are language independent things like testing, modularity, code reviews, consistent approaches to similar problems, following language best practices (all languages have them), etc etc. A codebase that big is probably pretty old; a lot of old codebases in C++ suffer from many issues that make it harder than necessary to keep in maintainable. The first is probably a lot of manual memory management and general under-use of RAII. The second is overuse of inheritance (I'm not one of those hardcore inheritance is the devil people, but these really deep inheritance hierarchies are usually trouble). My personal opinion is that there are a few areas of C++ (like exceptions) that tend to be contentious. However, there is a subset of C++ that today is simply obviously better for writing maintainable code for a green field project than C. There are people that have somehow convinced themselves that for some reason it's better to reinvent a stack manually inside each function with \`malloc\` \`free\` and \`goto\` instead of just using a \`vector\`, when they need an array. These are the kind of people that will argue in favor of C, and honestly I find it hard to have a constructive discussion there. While the Linux kernel has obviously stayed on C over time, and it's quite large, as kernel code it's a bit of a special case (I still personally think that C++ is a better pick, but the advantage is admittedly smaller since there's more things you can't use). On the other hand, GCC has moved from C to C++ (it's worth googling and reading about). I would say in general that large codebases that have stayed on C, have a some mixture of reasons that aren't great, and reasons that aren't like to be applicable to other projects (starting with inertia).
You're not going to convince anybody if you don't explain your stance.
No
Thanks for pointing out this paper. Before reading, I would've said I was against a `std::function` substitute that never took ownership. After thinking about it, it's a really really *rare* situation I find myself in where I need to pass a callable to more than one place. Now I think it's great!
 &gt; It’s really important to keep teaching people how to do type erasure! Can you elaborate on what the author means by this? Don't `std::function` implementations already abound with type-erasure? (I say, without actually looking at them)
Sometimes ones needs types too, but yes, often it's possible to just generate the implementations separately and compile and link them in. 
This seems to be coming up over and over. I have a million LOC project that I've done by myself, and as I've said elsewhere I'd probably have shot myself by now without OOP. With OOP, I can keep it moving forward and have made huge improvements over the years, and it's still very solid and very clean, with very minimal evolutionary baggage. It's easy to think the languages are greener on the other side when you only are seeing one of them and have plenty of time to see the limitations (that any system will have once complexity reaches a particular point.) But, if you dropped the OO part, most you'd still have all of that inherent problem domain complexity but just with less powerful tools to deal with it. &amp;#x200B;
It heavily depends on your configuration and such. The kernel configuration I'm working on takes 2-3 minutes.
"If they added first-level support for this, then they wouldn't support other things that I want because reasons" Is a bizarre argument.
You summarized my argument in the least favorable way I was able to think of. I sure hope that wasn't because you're feeling antagonistic. GCC, Clang, and MSVC provide intrinsic / builtin functions for various types of low level atomic operations. A few sample documentation links: https://docs.microsoft.com/en-us/cpp/intrinsics/interlockedcompareexchange-intrinsic-functions?view=vs-2017 https://gcc.gnu.org/onlinedocs/gcc-4.7.0/gcc/_005f_005fatomic-Builtins.html I don't know the entire history of these builtins, but I can certainly say that they came about before std::atomic was standardized. One might even argue that these builtins were provided, at least *in part*, to provide a facility for people to get reliable atomic operations without needing to manually roll their own inline assembly code. Imagine though, an alternative universe, where std::atomic was standardized first, say with c++98 or earlier, and that the standard explicitly required that std::atomic was provided as a built-in type, e.g. ::atomic_int or something like it. Would the compiler vendor go out of their way to provide a generic low level intrinsic, in addition to the standardized high-level type? *maybe*, *maybe NOT*. My concern is that some "::atomic_int" would be a higher level interface than the intrinsic functions provided by MSVC or GCC or Clang right now. For example, std::atomic (and probably our made up ::atomic_int) don't support having some operations on the underlying value be atomic and other operations not be atomic. I just re-read the documentation for std::atomic again just to double check that i'm not mis-remembering. But what if I have a situation where I want to have some operations be atomic, and others not be atomic, based on whatever criteria i feel like using? Well, if std::atomic is built into the compiler, why would the compiler offer me an intrinsic API that lets me pieces-parts my way through writing my own std::atomic? So now I can't do what I want. My argument is a simple observation of human nature. If you remove one of the (possibly many) reasons why something exists, such as these intrinsic functions, you increase the likelyhood that they will go away in the future. The more stuff we bake directly into the compiler (instead of provided as library features which may, or may not, require intrinsic functions to exist as library functionality) * The more complex the compiler becomes * The less functionality I have available to me as a C++ professional Since I already have my std::atomic, and it generates *exactly* the assembly code I want, plus or minus a few minor bugs... I'd really rather not see this baked into the compiler, because all I stand to do is lose.
&gt; I think that for low-level programming, one of the issues with C++ is implicit memory allocations. Yup, I remember a bug in our code not too long ago where there was an object with a `std::vector` member in shared memory and we were crashing because even though the shallow part of the object is in the shared region, the actual allocation for the buffer happens in the process that constructed it, so the other process segfaults when it tries to use it...
Very cool, thanks for sharing!
that's not a feature.
&gt;Let me rephrase. Do you have any practical examples of the library in use? (C++ is my bread and butter but I've been learning Haskell for a few years.) Not yet and maybe will not. But it's not for business, it's for fun and FP fans :) Research interest only.
&gt; union aliasing a bit You mean type punning through unions?
Haha, look, I can write loops and read fiels. I learnt it! Guess C++ is not so hard as they said it would be, huh.
Choosing C is a historical necessity :-).
Complete OS kernels and their TUIs and GUIs were written with C. Also complex software like web servers, DB servers etc. This C code also uses some techniques that naturally belongs to the "OOP" land. For example, an opaque handle + operations on a handle (say, open/read/write/close on a file handle of int) is encapsulation and implementation hiding. Different handle types, say, disk file vs. socket is polymorphism. Etc. All pure C. As for AoS versus SoA in games - it's a performance-related approach and gives good results. Game development estimates that it's a good design trade-off in some of their their use-cases, so they use it. Nothing problematic there either.
I’m surprised no one has said to just make `contains` a method in rectangle. You’ll get the syntax you want with the ability to say `if (rect.contains(point))`. As long as `contains` is not virtual your “struct” (aka class, since this is C++) size will not change, and if point is passed as a `const &amp;` your compiler can optimize the hell out of it.
Wait what? We use generated code to make our product more secure because the results can be verified at compile time and put in read only sections of memory.
Headers in C++ do not provide sufficient separation between the interface and the implementation. If they did then the pimpl pattern wouldn’t be necessary.
But, it does it a hell of a lot better than all the code also being in the same file with the interface though. Yes, using implementation classes are often useful and I use them good effect. But you have the choice of when its useful and when it's not worth it. And it has to be said that, if the actual data couldn't be in the interface, you'd lose a lot of optimizations that C++ allows for, which can make all the difference sometimes. &amp;#x200B;
If atomic was part of the language you wouldn't need intrinsics - you could just use the atomics. And the argument "we can't do that, because there may be a person somewhere for whom this has a negative effect in some circumstance" is one of the reasons, why we can't have nice things in c++...
Right. The traditional/old school C++ approach was a generic 'entity' base class as an extension point. It would have an identifier for lookup by other entities or systems, lifetime management policies. From here, programmers would typically think about each entity in a relatively isolated way; they were effectively 'handlers' for various events they could receive as well as controllers for components an individual entity managed. Major funtions like an per-game frame update 'OnTick' or 'OnDamage' would be invoked on entities, each of which could handle it however it wanted. While powerful, this can nudge engineers towards thinking about the 'entity' as the primary abstraction rather than thinking about systems. For example, lets imagine a game where entities of different types could catch on fire. That may be implemented as an interface each entity or hierarchy of entities can handle. Many will probably run similar logic, possibly in a base class, with more dispatching to extension points (more virtual functions) inside of a base handler. Very powerful and simple, but not the only 'OOP' formulation. Rather than having each entity update and potentially handle fire internally, fire itself could be a system that receives its own per-frame tick. Entities could call in to the fire system to create a fire-system internal representation of themselves. The fire system could then walk over arrays of these representations to perform the update, a much faster operation than hitting multiple virtual functions per entity instance. Basically, move the OOP design to system behavior rather than object instance behavior. There is absolutely an agility cost which is why most game studios only apply techniques like this in places that are performance critical. Game code that is closer to leaf functionality may be subject to change based on designers trying to figure out what is fun on a weekly basis. In those cases, the C++ implementing that leaf functionality maybe used as something closer to a scripting language (rapid requirements changes, lower cost to change due to fewer dependencies, glue code that ties together the more systemic parts), etc. That cost is less likely to be optimized for performance as it may be dealing with tens of disparate updates per frame rather than thousands. Its needs driven by scale requirements vs needs driven by agility.
Yes, of course. You’re right. That’s the situation we have to deal with today. It’s just a damn shame, and major flaw in the language, because it didn’t have to be that way. I don’t know— maybe modules will fix the problem.
That was really insightful, thanks!
Ah cool! Never seen it, but good to know. Thanks!
I think you missed the two big points of my several comments in this thread. &gt; If atomic was part of the language you wouldn't need intrinsics - you could just use the atomics. I explicitly addressed this in my last comment. If std::atomic was part of the language itself, and the intrinsics went away, there's a high probability that the result is an all-or-nothing implementation of atomics. std::atomic is only atomic operations, there's no support for sometimes doing things atomically, and sometimes not. Intrinsics don't have this problem. You can pick and choose when to use atomic operations and when to use normal operations. So as a result, having std::atomic built into the language directly would *only* be superior if and only if the intrinsics continued to be provided by the compiler. But really, my point was much more general than just std::atomic. *why* build something into the language directly when a library solution can provide exactly the same runtime performance, with exactly (or nearly so) the same level of functionality and ergonomics, *and* we don't end up in a situation where low level building blocks never get developed. &gt; And the argument "we can't do that, because there may be a person somewhere for whom this has a negative effect in some circumstance" is one of the reasons, why we can't have nice things in c++... But that's *not* my argument. Not only are you misrepresenting my argument, but I actively disagree with you. What you seem to want (e.g. moving more things from the standard library -&gt; built in) is arguably worse than keeping it in the standard library. My argument is building std::atomic (or a variety of other things) directly into the language doesn't actually *improve* anything. Further, always wanting everything built into the language can easily result in worse outcomes. It can result in worse outcomes because the various compiler intrinsics that sometimes need to be introduced to support various standard library feature won't ever be offered. Instead we end up with a one-size-might-fit-all built-in solution. Additionally, it's *also* the case that individual developers *can't* implement built-in features. My company has an out of date standard library, and compilers, but we've been able to implement a lot of the stuff from C++11 and C++14 without needing any explicit support from the compilers we use. Library developers can't re-implement built in functionality, they can only re-implement library functionality, and only that if they have a compiler that offers the necessary standard language features and vendor-specific built-ins. -------------------- -------------------- Note: And it really pains me that I always have to put in caveats like this on reddit, but I so frequently get people reading what I write, and then thinking I said the opposite of what I was trying to communicate. I'm explicitly not complaining about just the notion of making std::atomic a built in. I'm using std::atomic as an illustrative example on how implementing a specific concept as either a built in feature or library feature can result in differences in terms of the functionality that's available to developers. In the *general* sense, if something can be implemented with about the same outcome as either a builtin, or a library feature, then implementing it as a library feature maximizes the options that people who develop C++ code. That's it as a nutshell. 
You could have simply named the lambda types from source file, line and column, or from scope, i.e. namespace,class, function name plus line and column. 
So it seems TomTom didn't live up to your expectations?
We could have had our cake and eat it too. There could have been specific interface files that sources would implement and the rest of the code could exist in simple files without headers. But that would be different than the C compilation model, and it would require a lot of extra work, which the creator of the language wouldn't be allowed to do, back then when C++ was created.
Perhaps u/stl reads this... All headers shall be precomputed by default. The compiler shall track if any dependency of a header has been modified, and if so, recompile all the dependend headers. Why throw out a perfect compilation of a header after it is done? It could be cached and reused in the next compilation. 
&gt; small function optimization Can you elaborate - what is "small function optimization" in this context?
This is a public forum. Maybe SuperV1234 won't listen to whatever arguments you may have, but other people reading this may be willing to. e.g. Me, and probably the OP.
well, thanks. I was trying to learn something, so I really wanted to hear other people's opininions
So what happens when you call this function with the following text: "cette fonction a un comportement indéfini"? I'm not asking this because I don't know, but because the function is dangerously wrong. And even though you'll find this mistake in lots of places, fixing it in the standard is apparently not an option. 
&gt; Types are a contract, but implicit conversions are part of that contract. Sure, but it’s generally understood that they weaken said contract. This isn’t to say that they’re never useful but there are people who suggest removing *all* implicit conversions (I wouldn’t go that far, but I do advise restraint).
&gt; Would the compiler vendor go out of their way to provide a generic low level intrinsic, in addition to the standardized high-level type? maybe, maybe NOT. My concern is that some "::atomic_int" would be a higher level interface than the intrinsic functions provided by MSVC or GCC or Clang right now. All the atomic builtins can be reproduced with std::atomic... &gt;For example, std::atomic (and probably our made up ::atomic\_int) don't support having some operations on the underlying value be atomic and other operations not be atomic. I just re-read the documentation for std::atomic again just to double check that i'm not mis-remembering. That's the whole point of \`memory\_order\_relaxed\` though ? Or are you speaking of something else ? &gt; But what if I have a situation where I want to have some operations be atomic, and others not be atomic, based on whatever criteria i feel like using? Well, if std::atomic is built into the compiler, why would the compiler offer me an intrinsic API that lets me pieces-parts my way through writing my own std::atomic? So now I can't do what I want. I think you're looping in circles here. Let's admit they would not provide those (not realistic, since most often they do so for C anyway) There is absolutely no reason for a builtin std::atomic to behave any different from the other builtin fonctions we have. Like, it should map exactly to the current builtins. If it's not enough for you, then the exisiting builtins functions are not enough too, and you'll end up using ASM in both cases. &gt; you increase the likelyhood that they will go away in the future, or have never existed in the first place. As demonstrated above, this would not change a thing wrt to QoI &gt; The more complex the compiler becomes I'll concede on this one, though the complexity is already present for the current builtins. The real counter-argument would be that you can more easily update a library than the compiler. (Though it's not that true, since they tend to be coupled together) Also... note that C actually already have those as intrinsics in the form of a type specifier, so compilers already handle this. https://en.cppreference.com/w/c/language/atomic &gt; The less functionality I have available to me as a C++ professional That's actually the opposite in this case &gt; Since I already have my std::atomic, and it generates exactly the assembly code I want, plus or minus a few minor bugs... I'd really rather not see this baked into the compiler, because all I stand to do is lose. What will you lose ? You'll lose something IF and only IF they remove previous intrisincs, which, as I said, is unlikely because of C. &gt; If it can reasonably be implemented as a library, why try to shove it into the compiler? Most of the time I'd agree with you, but not for such things that are anyway already implemented with intrisics or compiler magic behind the scenes. And the library is just renaming those, which is a waste of commpile and debug time. Such things include atomics, `std::is_trivially_*`, `std::addressof` etc etc... 
That's nice to hear! We had to roll our own implementation at work because it was slowing down our scheduler by a significant amount...
Hi! I'm a 23 years old C++ developer living in the Netherlands (Ukrainian born). My main skills include C++(11/14+) and Qt/QML, and I have a basic knowledge of Java, Python, SQL, Git, Jenkins and Perforce. I'm looking for interesting and challenging projects that would allow me to grow as a professional and develop new skills. I'm looking for a full-time job and I'm open to relocation. Please PM me for CV or linkedin profile. 
The layout of bitfields in memory is implementation specific, isn’t it?
A simple, non-intrusive solution is unity build. Merge all your .cpp files in to one or several .cpp files. As long as you have enough memory, the compile time will be optimal. There are cmake [module](https://github.com/sakra/cotire) to automate the process.
No, C++ compiled faster in exactly one example and slower than Rust in the others. The revised numbers had Rust beating the C++ range example as well in runtime.
Callables smaller than some size threshold will be placed directly in the `std::function` object, avoiding dynamic allocations. This will include, among others, function pointers and small function objects (including small lambdas). 
&gt;Today’s guest post is written by guest author **JFT**. It would be really great to know a bit more about who the guest authors are, who is this mystical "JFT"?
In Microsoft's implementation, IIRC, small function buffer is the size of `std::string`, so three pointers. (/u/STL can correct me if I am wrong). I don't remember values for other implementations, but I expect them to be similar.
Thanks you for pointing out std::uninitialized_move and std::uninitialized_copy, which ones I did not know.
&gt;For example, partial classes in C# is a language feature for a pattern that can be solved in C++ by adding a #include in the middle of a class definition. i threw up in my mouth a little bit
Wouldn't that still generate a different name for lambdas after a newly added one? In fact it might mean that the new lambda has the name of an old one, and now the last placed old one seems new. Doesn't seem to fix the issue STL mentioned?
Unicode in C++ is so bad that it's meme-worthy. I don't understand why they can't fix it.
Const is completely useless in return value. Remove it.
Yes I get that now but what is the difference between const before the bool and after the function?
I think I possibly picked a terrible example. But the point is there are many examples like this and I believe it makes other languages slightly less attractive because when one needs to go against the grain, it's extra painful. 
Well, they starter to do something about it. On last C++ Standard Meeting, San Diego, November 2018, Study Group for Unicode (SG16) had its first in-person meeting. So, hopefully, wy will get Unicode support by C++26 standard. Also, char8\_t has been added to draft.
After the function is only possible on class member function and this means that function can only be called if the object is also const in the context. Example: ```cpp class foo { public: void a() const {} void b() {} }; int main() { const foo f; f.a(); // ok f.b(); // not ok } ```
Thanks 😇
&gt; and this means that function can only be called if the object is also const in the context. No it's the other way around. The function can ALSO be called when the object is const.
Exact, my answer was a bit ambiguous. Here's a summary | f.a() | f.b() | | const foo f | ok | not ok | | foo f | ok | ok | 
It is possible to write code that can observe if a value returned is const or not, so it is not completely useless (I'd say it is very niche though). It is completely useless on bools though.
Your example was fine, just that sentence was not.
const before bool: The bool cannot be modified const after function: This function cannot modify the members of this class/struct.
Since the value is returned as value and not as reference or pointer, yes const is *still* useless. You don't care what the user does with it. And it's perfectly fine for the user to *not* take it as const. ```cpp const bool ok() { return false; } int main() { bool x = ok(); x = true; return 0; } ``` That's why the compiler emits a warning.
I'm doing a few illegal or questionable things I cannot prove are legal. I'm placement newing and then not storing the resulting pointer. I'm stuffing the sub union next to an array in another union, then using the outer union's memory for said placement new. I should just support a fixed small buffer size, it would get rid of the nested union and some of the questionable tricks. I probably need some std launder when getting the pointer-to-stack-data. Note that heap and stack are used imprecisely here. Should be free store and local storage. 
Since this is homework I don't want to give away the answer. About the const in the return type, in C++, return types have some strange rules, const is more or less irrelevant. On your second point of having the const after the arguments, this is a qualification of the object this member function is called from. It says that this function will not modify the members of the object, if you set all values to 0 in this function, it would not compile. As a hint for your assignment, search for symmetric operators in c++
 //A.cpp #define _ITERATOR_DEBUG_LEVEL 0 #include &lt;vector&gt; // B.cpp #define _ITERATOR_DEBUG_LEVEL 2 #include &lt;vector&gt; Macros, usually. 
True, but it misses the point. It is also dangerous if you use some extended ASCII encoding.
No, the compiler is emitting a warning because it discards the `const` because the return type is `const bool`. It does not emit a warning for `const Foo`, where the `const` is not discarded. Again, since you can write code to use it: not useless.
Yes, that's right for fundamental types.
After some time you get tired of the circlejerk/echo chamber and regrets having even commenting. The functional programming fanfic is strong here
Another approach eventually : https://gitlab.com/libyuni/cmake-import-remote-project
Not an answer to your question - sorry. But can't you link most of your dependencies statically?
In a nutshell: class X { public: Y f(); // This function returns a Y whose value can be changed. const Y f(); // This function returns a Y whose value cannot be changed Y g() const; // This function returns a Y, but guarantees that // the contents of X (i.e. data) will not change. private: Z data; } The difference between the first and second examples is very small and I think most would recommend the first form unless you have a specific reason to use the second. The third form has an entirely different meaning. It is making a statement about how X works, rather than anything to do with Y.
I've been enjoying this series so far, but seriously, please switch to using a font that doesn't disconnect underscores, especially in code blocks, __ looks much better than _ _ when it's connected to something like __this
But that doesn't allow you to switch to prebuilt or system-wide libraries easily. The approach that is described here is to have source-form dependencies include a &lt;package&gt;Config.cmake that calls the add_subdirectory on its directory, so that it fits seamlessly in the find_package model. Then, package management becomes an orthogonal issue, and just a matter of putting the dependencies (via submodules, wget-http-targz-archives, custom tool and content distribution, or whatever way you like) in the location where CMake will look for them, and in the form you prefer (prebuilt or source). You may even have multiple lookup paths with fallback to the source dependency if you want to provide prebuilt packages for certain platforms only. 
One thing that I want to point out: Data driven design has nothing to do with avoiding the standard library, templates, exceptions or any other feature. The core idea is to structure the data as the program uses it rather than as the programmer thinks of it. The data can still be in classes that have functions, and doesn't have to be plain structs. Since you bring up Gnome, they built their own system for writing object oriented code in C (gobject.) It has tons of boilerplate and is terrible to work with, and honestly the project would be served far better by simply using a language with the features that they are trying to use. At one point they even wrote such a language (vala) because gobject was painful to work with, but they have been moving away from this more recently.
I would prefer setting `RUNPATH` or `RPATH` in all executables and libraries you install. This reduces the chance that OS programs will run in a broken environment due to `LD_LIBRARY_PATH` being set. If you want the install tree to be relocatable, you can set `RPATH` relative to `$ORIGIN`. Some build systems (ex. CMake and Meson) have builtin support for setting `RPATH` during install. If some of your dependencies' build systems do not support this, you can do it in a post-install script using `chrpath` or `elfedit`.
**Company:** [Ubisoft Belgrade](https://www.facebook.com/helloworldsrbija/videos/550420105430754/) **Type:** Full time **Description:** We're making video games. A young Ubisoft studio in Southeastern Europe looking for **experienced C++ programmers and leads**. GameDev scene in Serbia is still young, so we are looking for people to influence growth and development of our studio. **Location:** [Belgrade, Serbia](https://www.flickr.com/groups/belgrade_photos/pool/). Working language is English and is required because we collaborate with multiple Ubisoft studios. Serbian and/or French are a bonus, but not required. **Remote:** No **Visa Sponsorship:** Yes **Technologies:** All programmers are working with C++11 with some C++14 features in Visual Studio. Platforms that we compile for are Windows, PS4 and Xbox One. **Contact:** PM or nikola.sobajic[at]ubisoft.com for questions, or you can apply directly on [SmartRecruiters](https://careers.smartrecruiters.com/Ubisoft2/?search=&amp;page=0&amp;location=Belgrade).
Those were new to me as well. Looks like it's time to start browsing cppreference.com again for stuff I don't recognize.
No summer internships (2019) in Germany unfortunately. :( I’m an international student in Germany, looking for summer 2019 internships. I can’t apply for the London Summer Internship because I’m a Non-EU citizen. 
Have you heard of `std::iota` yet?! /s
I wish people made more of a distinction between the containers and the algorithms when talking about 'using the stl'. The headache in games tends to be more about the containers and the allocator model rather than the the algorithms. The former may be replaced with domain specific containers while the later tends to work fine as is.
Was that the one that had to do with integers or something?
C++: make thousands$$$ a month just by sitting at your computer and typing what looks like gibberish!!! :)
This may be the death of open source. I know many people who are too embarrassed to publish their projects. Think of how many tools we won’t have because now many GH users will elect to not share them.
It' Array TO Int, but reversed /s No it's a suite generator (1,2,3, …).
That's a mighty hyperbole.
This is simple, but you can take a look [https://lion137.blogspot.com/2019/01/kleisli-category-by-example.html](https://lion137.blogspot.com/2019/01/kleisli-category-by-example.html)
github has offered free private repos for years.
Ah, now I get it: "array to int reversed" means it is really "int to array". So it generates a sequence by writing integers to an array! It all makes perfect sense now! 
Using a debugger on heavily templated C++ code was a life saver for me the other day. The code mentioned is nearly impossible to debug using a debug print because of catastrophically large rebuild times and inablility to print demangled template type arguments.
Maybe GitLab, or BitBucket.
Doubt it, given how as someone else stated, Gitlab and Bitbucket have offered free private repos for years now, provided the user count is small. &amp;#x200B; Personally, I use Github for some of my pet projects that I do want to be public, and currently use Gitlab for things like personal shell scripts, etc., as a form of "offsite cloud backup."
Definitely start with C++11. There were substantial changes that modernized the language. The changes in C++14, 17 and 20 are relatively small compared to the changes in C++11.
*data-oriented*, not data-driven - those are two very different things. You're also confusing some complaints as all being the same thing. Data-oriented-design concerns (and problems with _abuse_ of OOP that violate DOD) and concerns with templates or the like are _very_ different issues. Templates for example are a fantastic way of writing highly-optimized data-oriented structures and algorithms; people complain about templates because _abuse_ of templates makes compilation take many times longer, which hurts developer iteration speeds. STL data structures like `std::vector` are great for many data-oriented cases, too. Folks complain about the STL because because of a myriad of reasons, few of which have anything to do with data-oriented design. Most of it boils back down to compilation time, bad codegen in debug builds, and painfully archaic interfaces (e.g. allocators). Switching to C does not magically make code data-oriented. It can help in some ways (compile times tend to be _way_ better) but C does not by itself solve any problems, and throwing away useful C++ tools can hurt. Most of those "C is the best" games programmers are still actually using C++ and most of its features, just in more minimal circumstances than you'd see in idiomatic C++.
I mean, Open Source didn't even exist before GitHub, so obviously GH changing its policies will kill it! (yes, I'm being sarcastic)
yes, mistyped.
I've also been thinking about a model where the creator of an open source project could pitch some improvements they want to make, and the /r/cpp community (and hopefully the respective companies we're employed by) can pool together financial contributions to make that happen. Anyone here have any thoughts or experience with something like that?
Take a look at "https://isocpp.org/", and in particular read through the "Tour of C++". That will help you figure out about where you'd like to get started. I recommend beginning with the latest possible standard you have compiler support for (*especially* if you aren't needing it for work just yet) and working your way backwards-- you'll obviously hear different things from different people, but based on experience coordinating a C++ user's group and introducing some folks to C++ this appears to work well as the cognitive load appears to be a bit easier filling The Old Hard Way(TM) in backwards (YMMV). Good luck, enjoy the journey! :-)
thanks, will do :-)
thank you
Which projects to you have in mind? I love the cmake extention for vscode for example. There is also a clang tidy extention that is getting better and better, though still not a good out of the box experience... I'd love an official cmake dependency file like requirements.txt or package.json that vcpkg, cget or conan could consume without parsing the whole cmakelists.txt
People who "abuse" this likely would have never uploaded their shit publicly in the first place. May as well be considered as a backup for personal projects.
This is of course very cool, but it is off-topic for the cpp subreddit.
&gt;I'd love an official cmake dependency file like requirements.txt or package.json that vcpkg, cget or conan could consume without parsing the whole cmakelists.txt I think there is something like that, and CMake even added preliminary support for it like a year or two ago. But then it somehow died, because the main contributor got busy elsewhere or something like that? It was briefly discussed in a few reddit comments here, 3-6 months ago or so. &amp;#x200B; Now if I could just remember the name or how to find it...
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/adtye3/question_about_const/edl0jjf/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
\*\*Company:\*\* [Kitware](https://jobs.kitware.com/) \*\*Type:\*\* Full time \*\*Description:\*\* Kitware develops open source software platforms and supports them with services such as consulting and training. Among the company’s most known platforms are the Visualization Toolkit (VTK), ParaView, and CMake. Kitware is currently hiring Computer Vision Researcher - U.S. Persons to work on computer vision/machine learning efforts related to 3D reconstruction, object-based change detection, feature detection, motion pattern learning, and/or anomaly detection. Additional areas of interest include content-based indexing and retrieval, object detection and tracking, video event and activity recognition, functional object recognition, social media understanding, video compression, and super resolution. For more information, please see [https://hire.withgoogle.com/public/jobs/kitwarecom/view/P\_AAAAAADAAEiHlq2ENVLXpd](https://hire.withgoogle.com/public/jobs/kitwarecom/view/P_AAAAAADAAEiHlq2ENVLXpd). \*\*Location:\*\* Clifton Park, NY; Carrboro, NC; Arlington, VA; and Santa Fe, NM. \*\*Remote:\*\* No \*\*Visa Sponsorship:\*\* Kitware, as a company, does offer visa sponsorship opportunities. For this role, however, due to contractual restrictions, only candidates that are U.S. Persons (citizens, permanent residents, asylees or refugees) will be considered. \*\*Technologies:\*\* We use C++11. We also use Qt and Python. You can work on Linux, Mac, or Windows. \*\*Contact:\*\* Email resume and cover letter to [john.westbrook@kitware.com](mailto:john.westbrook@kitware.com) or [hr@kitware.com](mailto:hr@kitware.com). View other opportunities at jobs.kitware.com. 
That's funny, cmake-vscode-tools is exactly the project I had in mind when writing this. When something broke today and I found the fix in an existing PR, It reminded me how useful it was and I decided to become a patreon. I'd love to see the cquery vscode tooling get some more polish. I've been using it and it's absolutely fantastic, but still rough around the edges, so I'm back to MS C++ tools extension. It'd also be great to see some package managers supported. I know there is vcpkg and conan, but they each suffer from their respective issues and I find installing more lesser-known packages is likely to be met with issues.
I also recommend something like "Tour of C++" to start with. And do some small to medium sized projects. If you can freely choose, go with C++17, all starting from C++11 are good ;-) Also I get a lot of inspiration from conference talks (CppCon, Meeting C++, C++now and more). Two talks I would recommend: * [CppCon 2018: Jonathan Boccara “105 STL Algorithms in Less Than an Hour”](https://www.youtube.com/watch?v=2olsGf6JIkU&amp;feature=youtu.be) (very good for getting to know the STL) * [CppCon 2014: Herb Sutter "Back to the Basics! Essentials of Modern C++ Style"](https://www.youtube.com/watch?v=xnqTKD8uD64&amp;feature=youtu.be) (Good overview of modern Style) There are many more, but not all are beginner friendly, but I think it's a very good resource
20 is looking to be really big though with stuff like modules, contracts and concepts. But it hasn't even been standardized yet, so yeah I would take it a bit easier with that one either way.
Everyone loves to hate on C++, but there's no other tooling where you can write a high-performance application with GPU acceleration and a crossplatform GUI for example. The only real alternative is Rust and there's no GUI support and you'll still end up writing your CUDA code in C++ anyways. Any other libraries you need, you'll end up having to write wrappers around C headers, etc. I suspect the productivity increase is lost at that point. I came into this project from web and mobile app development, so I really considered every alternative (Go, Java, Rust, Javascript, etc). I suspect in the long term WebAssembly will shake this up. Vtk is already underway with this and the results are impressive: https://kitware.github.io/vtk-js/
Thank you!
You may be thinking of [CPS](https://mwoehlke.github.io/cps/)?
Thank you for your hard work!
As usual Mathieu with the quality content I started writing my own blog because of people like him. The truth is that you have to appreciate the beauty of the copy-and-swap idiom, despite it's (necessary) flaws. It's maximizes code reusage (is based on copy constructor and destructor), very short and as safe as you can be.
&gt; having copy construction from a non-const target do the right thing Actually, there is an explicitly defaulted `hyper_function(hyper_function&amp;)` constructor. Isn't that good enough? 
Yeah, line numbers are undesirable for that reason.
FYI, that is super duper unsupported for MSVC.
You are attempting to reinvent modules.
Our heuristic is that the small functor optimization should be able to store a `std::string`, yes. However, `std::string` is considerably larger than 3 pointers, due to the small string optimization. (`std::vector` is 3 pointers, plus debug bookkeeping - that's probably what you were thinking of.)
This is off-topic for both the cpp and cpp_questions subreddits.
Unity builds are highly intrusive and can change the meaning of code.
John Lakos wrote the (a) book on this: "Large Scale C++ Software Design" A lot of the specifics of the book are out of date (it predates iso C++), the principles are solid.
Heh, i figured. It was the most obviously awful thing I could come up with (I thought of NOMINMAX and windows.h after) - I suspect I thought of it because the parent tagged you in it. Out of curiosity, is it an ODR violation, or is it just some internal explosion?
Cps is kind of what i have in mind, thank you
More generally, UB is intended to avoid requiring that implementations go out of their way to implement any sort of predictable behavior *in cases where doing so would be impractical*. In situations where many implementations (or even all known implementations!) would process an action the same way, but there might exist platforms where offering any sort of behavioral guarantee would be expensive or problematic, the authors of the Standard expected that the only situations where it would matter if the Standard actually defined the behavior of the action would be those involving obscure platforms, and expected that users of those platforms would be better placed than the authors of the Standard to judge the costs and benefits of supporting the common behaviors on them.
I was thinking of libc++ and libstdc++ implementations, which are 3 pointers. I did not know Microsoft's is larger.
Ah, I missed that such a constructor exists (It's not explicitly defaulted though). Still will run into issues if you inherit from it tho.
I'm not sure what you're objecting to in that particular case. Unless an implementation documents the effect of making a function call to a null pointer, or a means by which a programmer can change that effect (e.g. by specifying that such a call will jump to address zero and allowing a programmer to write any desired sequence of eight bytes there), an attempt to call a null pointer would be allowed, among other things, to invoke any function of the compiler's choosing. It would hardly be uncommon for an attempted null-function-pointer invocation to jump to a region of address space whose contents, interpreted as instructions, would result in execution branching to some meaningless address in the middle of the heap, which could in turn cause execution to branch pretty much anywhere. While it would be unlikely that this sequence of events would behave just like a call to `EraseAll`, I would not regard the possibility of its doing so as even remotely astonishing except on platforms that define the behavior of a null-function-pointer invocation.
&gt;you don't code kernel modules in PHP. Not with that attitude!
It's a virulent ODR violation.
I stopped using the copy and swap, and instead do copy to temporary and move. Replacing T&amp; operator=(const T&amp; rhs) { T tmp(rhs); swap(tmp); return *this; } With T&amp; operator=(const T&amp; rhs) { return (*this) = T{rhs}; } In my experience, even when I need to write copy construction and copy assignment, 99% of the time, the move constructor and move assignment can be =default. In the rare cases, where a custom move assignment is needed, it is about the same work as writing swap.
The difficulty is that the authors of the Standard expected that in situations where a characteristic behavior of some target environment would help programmers accomplish some tasks, compiler writers would seek to honor the Spirit of C's "Don't prevent the programmer from doing what needs to be done" and expose that behavior even if the Standard didn't require it. There are many situations where it would be marginally acceptable to have a program abnormally terminate if given invalid data, but where allowing the author of malicious data to execute arbitrary code would be completely unacceptable. Further, programs subject to such requirements are often run on platforms which are guaranteed to force an abnormal program termination if certain operations are attempted on certain kinds of invalid pointers. Code which exploits the guarantees offered by the underlying implementation may be able to perform tasks more efficiently than code which cannot do so. Unfortunately, there's no means in C of expressing the semantics "call this pointer if it's not null, or process the function call using the platform's mechanism for null function calls if it is null". 
A more interesting example is `unsigned mulMod65536(unsigned short x, unsigned short y) { return (x*y) &amp; 0xFFFFu; }`. The authors of the Standard stated in the rationale the situations that they expected that commonplace implementations would process `(x*y)` the same as `((unsigned)x)*y` except in a few specific situations, none of which apply in this particular example, implying that they would expect this example to be handled likewise. I would not regard as astonishing the idea that an implementation might process (or behave as though it is processing) signed integer operations using a type with a wider range than specified. Such behavior is consistent with how many implementations handle floating-point arithmetic. Much more astonishing is the fact that integer addition, multiplication, and shifts can have side-effects beyond yielding some kind of result. 
I'm not sure if you are serious or not. Iota is just a greek leeter. The `std::iota` function doesn't first create a array (hopefully since `std::iota` generates an infinite list) but lazilly generates that list on demande.
Finally! Unit tests! I don't understand how qt creator can ship with no unit test template.
&gt;Don't you think this would be a convenient method to add to std::vector? No: by the time you access a vector element by index, your index should be (in most cases) already valid. If you are nervous about that, you should probably assert it before using the index (and if the assertion fails, it will denote either a bug in the calling code or it will be a symptom of incomplete design). &gt;I am pretty sure there is a huge number of C++ code that does this kind of bound checking There shouldn't be: most people use iterators these days and in the cases you need an index, you should get the index from a source that gives you indexes *for that vector*. If your code base does otherwise, consider addressing it as a design issue. &amp;#x200B;
Just a question, but which CMake standard were you using? CMake has made some radical changes in the last two or so years that (at least to me) make it far, far cleaner than it was in the past. Basically, to your point, the guide says that if you're doing string concatenation or manually adding build flags to CXX_FLAGS, you're doing it wrong. 
I always wonder about the relevance of using the Linux Kernel as an example for a large codebase in C. &amp;#x200B; The Linux Kernel is the kind of...application? that C had in mind when it was designed. It's constrained to low-level abstractions because it is itself concerned with the low-level interactions of the system. I've only lightly looked around the kernel code, and the fact that it's solving such a well-defined problem (nowadays) makes the code feel clean and neat. &amp;#x200B; However, for a business-side application or something like games, I don't see the connection as clearly. The problem being solved is always in flux and the need to reuse certain components and abstractions, or develop entirely new ones, e.g. an entirely new physics framework to fit the latency, performance, and realism required, seem like it'd be fairly difficult to iterate on quickly inC.
GN does not support outputting a CMakeList. It does, however, support serializing (most of) the build information to a JSON file which a tool could turn into a CMakeLists.txt (see https://github.com/google/skia/blob/master/gn/gn_to_cmake.py ). A little side project I'm currently scoping out is to write a CMake "IDE" backend to GN so that GN projects can be more easily integrated into CMake based projects. 
You start by reading he sidebar that says your question is off topic. It also tells you where it isn’t. 
https://gitcoin.co
Rust is also still developing their allocator interface. Right now (afaik) it’s restricted to using a single allocator for an entire binary or library, which could potentially get annoying. I guess you could always switch to unsafe when needed for other use cases but that feels dirty. 
Allowing computations that overflow to yield values that are only loosely specified facilitates useful optimizations. Allowing overflows that would result in incorrect output to be trapped facilitates useful validation of program correctness. Interpreting UB as an excuse to have overflow trigger arbitrary disrupt computations *that do not depend upon the result* does neither, but is nonetheless the approach favored by "clever" compiler writers. 
Yes! That's exactly what I meant. Thanks for posting it! It would be so great if CPS came back to life and would get adoption among CMake, conan etc.
https://github.com/keptan/fun here's mine which apes Rangesv3 slightly you can build unevaluated expressions, has lazy evaluation ect comes with some pure-functional data-structures
Interesting, I didn't think they'd store that much state. It'd also be interesting to see how much this is used in practice and if it's worth it.
I guess it's all relative, obviously it's a well run project, but I still believe it could be better with C++. Here's a bit of Linux Kernel code taken at random (well, after grepping for cleanup) static int oaktrail_rfkill_init(void) { int ret; wifi_rfkill = oaktrail_rfkill_new("oaktrail-wifi", RFKILL_TYPE_WLAN, OT_EC_WIFI_MASK); if (IS_ERR(wifi_rfkill)) { ret = PTR_ERR(wifi_rfkill); wifi_rfkill = NULL; goto cleanup; } bt_rfkill = oaktrail_rfkill_new("oaktrail-bluetooth", RFKILL_TYPE_BLUETOOTH, OT_EC_BT_MASK); if (IS_ERR(bt_rfkill)) { ret = PTR_ERR(bt_rfkill); bt_rfkill = NULL; goto cleanup; } gps_rfkill = oaktrail_rfkill_new("oaktrail-gps", RFKILL_TYPE_GPS, OT_EC_GPS_MASK); if (IS_ERR(gps_rfkill)) { ret = PTR_ERR(gps_rfkill); gps_rfkill = NULL; goto cleanup; } wwan_rfkill = oaktrail_rfkill_new("oaktrail-wwan", RFKILL_TYPE_WWAN, OT_EC_WWAN_MASK); if (IS_ERR(wwan_rfkill)) { ret = PTR_ERR(wwan_rfkill); wwan_rfkill = NULL; goto cleanup; } return 0; cleanup: oaktrail_rfkill_cleanup(); return ret; } Notice the same-ish 3 lines over, and over. When a function like this gets written or modified it's very likely that someone copies and pastes and modifies only the parts that need to be changed, forgets something, and causes a problem. Can we improve this? static int oaktrail_rfkill_init(void) { ScopeGuard(oaktrail_rfkill_cleanup) cleanup; wifi_rfkill = oaktrail_rfkill_new("oaktrail-wifi", RFKILL_TYPE_WLAN, OT_EC_WIFI_MASK); if (IS_ERR(wifi_rfkill)) { return null_and_ptr_error(wifi_rfkill); } bt_rfkill = oaktrail_rfkill_new("oaktrail-bluetooth", RFKILL_TYPE_BLUETOOTH, OT_EC_BT_MASK); if (IS_ERR(bt_rfkill)) { return null_and_ptr_error(bt_rfkill); } gps_rfkill = oaktrail_rfkill_new("oaktrail-gps", RFKILL_TYPE_GPS, OT_EC_GPS_MASK); if (IS_ERR(gps_rfkill)) { return null_and_ptr_error(gps_rfkill); } wwan_rfkill = oaktrail_rfkill_new("oaktrail-wwan", RFKILL_TYPE_WWAN, OT_EC_WWAN_MASK); if (IS_ERR(wwan_rfkill)) { return null_and_ptr_error(wwan_rfkill); } return 0; } This is significantly significantly cleaner. At this point, the typical arguments are: 1. Writing scopeguard is so complicated, it's an endless rabbit hole! 2. But null_and_ptr_error takes by reference so it's not clear what's happening any more! To which I would respond: 1. Maybe to cover all the insane corner cases (like throwing moves), but a simple ScopeGuard would be &lt; 100 lines and cover the vast majority of linux kernel use cases. 2. Well, it's an abstraction, it abstracts and declares intent. In the original you also have to look up what PTR_ERR does, it's not very different. At this point peopl will say: this is nice, but people will just keep going and going overboard. This is a very weak argument; once we establish that non-zero features from C++ would be useful in the kernel, the argument "there are more features" is bad. If you can't enforce something as black and white as which features to use, via e.g. code review, you're screwed. The linux kernel enforces far more subtle issues than this with success. Anyway sorry for the wall of text.
Wish we had more of those guides.
**Company:** [Stellar Development Foundation](https://www.stellar.org) **Type:** **Full Time** **Description:** Stellar is an open network for sending and exchanging value of any kind. Our global network enables digitization of assets - from carbon credits to currencies - and enables movement around the internet with ease. In doing so, it’s faster, cheaper, and more environmentally friendly than alternative platforms, and it empowers users and organizations to create a global, dependable network of trust while maintaining decentralization. The Stellar Development Foundation (SDF) was founded in 2014 by Jed McCaleb. We consider Stellar the “platform of the people” - building world-class, decentralized, and open-source technology that’s accessible and affordable to everyone. We believe that our technology and mission enables our diverse developer ecosystem to build innovative and transformative technologies on top of Stellar. Most of all, we firmly believe that we are building the financial system of the future - and that at the heart of it should be an inclusive culture. We look forward to hearing from you! **Location:** San Francisco, CA USA **Remote:** Not at this time. **Visa Sponsorship:** Yes **Technologies:** C++11, Blockchain, Distributed Systems. You can work in any operating system, but we aim for deployment on Unix-based servers. **Contact:** [Apply directly through our website](https://jobs.lever.co/stellar/110cf8db-eb1d-4ca2-bf80-3518a9aaaff8), and feel free to leave comments below with questions (feel free to PM me).
Bah it so should be `function_ref&lt;Sigs...&gt;`.
### nice tutorial
Indeed, our small functor optimization is sized so that one string will fit inside :)
Best? Not sure, but in the Windows and Linux world I've used [codelite.org](https://codelite.org) and have been happy with it. They do have an iOS version too.
What do you gain from this? Seems to be as costly in terms of memory use but harder to understand. (Everyone is familiar with the copy-swap idiom)
This one weirds me out because before it's the name of my primary Skyrim VR character and the cognitive dissonance every time I see or remember `std::iota` just won't freakin' go away.
So you're using fmt, cxx\_options, and std::experimental::filesystem? Right? Maybe source (or link to) fmt and cxx\_options for the uninitiated and/or curious. Just my $0.02
We were mostly using pre 3.1 cmake. Yes, some things become easier and cleaner, but I don't think I'd go as far as calling the changes radical, especially after using GN. The syntax is still horrific and convoluted (if not more, looking at you generator expressions), you still have to manually set build flags on target (if you need different warnings, etc). It doesn't come anywhere near to gn and its configs, where every build flag is traceable to specific part of build file. And I don't think cmake has anything similar to gn templates for creating custom target types. As for in-tree dependencies, we don't have lot of them, but basically the approach is to add and maintain custom BUILD.gn files for them. I can't say this has been particularly problematic. Here's example build file for [libuv](https://pastebin.com/FXUadhdB) (it's quite long but very straightforward), here's one for [pcre2](https://pastebin.com/KBPVbfzr). It feels very liberating to be able to do this one some targets ``` configs -= ["//build/config:default-warnings"] configs += ["//build/config:contrib-warnings"] ``` Larger dependencies we always build and stage out of tree. CMake is very easy to get out of control, whereas it's exactly opposite with GN. The decision to make GN language turing incomplete seemed baffling at the beginning (coming from CMake), but it didn't take me long to understand the benefits. If you tell 2 different people to write gn build for non trivial project they will likely end up with something very similar. That's often not the case with CMake. 
Simply any monospace font for code blocks I would say... :)
Many good answers here. One thing to keep in mind is that typical games workload is to perform the same kind of transformation over a rather large dataset with a relatively short deadline. Data oriented design is an absolute necessity, because you just won't get the necessary performance otherwise. Other applications might not have the same kind of problem structure and thus other approaches may be better. Regarding not using the stl: the standard library containers are mostly crap, string processing is virtually non-existing, early implemrntations were buggy and especially in c++98, the standard library wasn't that big to begin with, so it isn't a suprise that game studios (and other companies) developed their own replacement that is more tailored to their needs. However, newer days the standard library provides a lot of useful and high quality types that every new developer on your team will be immediately familiar with and your company doesn't have to maintain on their own, so I don't see a reason avoid it as a whole, even if you might not want to use individual parts of it (unordered_map being the prime example)
Kickstarter and similar platforms have been used for that in the past.
Nice
Maybe Cloud9?
Some people still try to push it forward, but there is great inertia in the boost community. 
The guy working on it gave an update on the boost mailing list a few days ago saying that 25 of the libraries now support it. I dunno if there's a web mirror of the mailing list somewhere. He also posted this graph of the prrogress: https://gist.github.com/Mike-Devel/46d04409d6ae6053861706e3ad91e4dc
What you want is [bountysource](https://www.bountysource.com/) (or similar platforms) and it has been used successfully in the past.
 GSL exists because Herb and his friends didn't have enough reasons to push its content into ISO standard. And if there are no reasons to have it in C++ standard - why anyone should use it?
I'm the author of that mail, and feel the need to clarify this a bit: Fortunately I'm not "they guy working on it", although my work might have had the most visible inpact so far. I'm not a boost library author/maintainer or hold any official position or authority. All I'm doing is that I'm openeing some PRs in my spare time to add at least minimal cmake support to boost libraries, which allows me to add a boost library to my project via \`add\_subdirectory( &lt;path to boost lib&gt; )\`. They generally don't run the unit-test, don't support installation (however, b2 does that now by itself thanks to Peter Dimov) and it is not clear if all library maintainers will even accept those PRs. However, my hope is, that if all else should fail those files will grow over time to provide full fleded cmake support (at least in the libraries I'm personally interested in). In terms of a boost-wide, full-fledged cmake solution, I think the author of [https://github.com/boost-cmake](https://github.com/boost-cmake) was - at least at some point - the one most deserving of the title "they guy working on it". IIRC he had created a fully cmake-ified version of boost that has/had some chances of being adopted, but last I heard he wasn't able to find a review manager for his cmake support library. More recently, RobertRamey has tried to get a call for submissions out that would allow various applicants to bring forward their solution which could then be reviewed and the "best" would then hopefully be accepted into boost. Btw.: The web mirror is here: [https://groups.google.com/forum/#!forum/boost-developers-archive](https://groups.google.com/forum/#!forum/boost-developers-archive) 
As you are already compiling in c++17 why not use std::filesystem ? And if you absolutely need experimental to compile on macos (without a llvm installed side by side) you may have easier life in the future using an alias like namespace fs=std::experimental::filesystem to switch back and forth. 
It's not exactly more difficult to understand though, it's just a copy and return? The main advantage is probably that it's shorter.
This. So much this. I wish I could upvote more than once in reddit - just like the clapping on medium (up to 50).
Fair point, although this introduces coupling between point and rectangle. That also introduces the option of creating rectangle from point(s) in that case, since x/y are in-common. Then a point member function "between" can be used if a rectangle is represented as opposite points... But i digress! 
&gt; he wasn't able to find a review manager for his cmake support library I know too many libraries that gave up trying to get included in Boost after this happened to them. 
So a scoped tagging system - Is there an implementation of this? I can imagine ways to do this with thread local objects but don't know if it's feasible.
the standard library is a catwalk for inflated egos, academic experimentation with the goal of grants and tenure. Not to mention a bunch of professional gurus creating problems that they can solve later for a fee. There is no accountability and no community feedback in the process. Yes it is a mess and the result you see
Maybe with http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r2.pdf
This problem is also true for Haskell and to some extent Java. I bet every language that supports both exceptions and return values has it.
Or from another perspective: C++ does have agreed standard error handling concept**s**. Expect `std::expected` to be yet another standard concept on top of the others. Biggest WTF in the standard library in my opinion is `std::generic_category` and `std::system_category`. When should one be used in place of another, and do implementations behave consistently in regards to that convention i.e. can it actually be used portably?
The success of C++ is due to: 1) zero-cost abstractions, and 2) backward-compatibility with C. Many other languages that have competed with C++ over the years have had one or the other, but not both.
I think feedback is good but I do not know what happens lately about this negative trend for negative posts about any possible feature of C++. C++ is fast, great and has a ton of libraries. I will keep using it. Remember there is a proposal from Herb Sutter wirh more lightweight error handling. You also have implementations of expected, optional and ability to disable exceptions. Name a language with this flexibility that is as fast as C++ at runtime and comparably well supported. After that maybe we can have a really serious rant.
&gt; B2 now creates cmake config files If this is the case and it works well, then it doesn't matter whether upstream Boost uses CMake. You just use `find_package` and it works. This is already the case with Qt 5 which does not use CMake, and which provides CMake config file packages too. I outlined how this works here https://lists.boost.org/boost-build/2015/11/28384.php but I didn't implement it. It seems Peter Dimov did it.
Oh gosh, now I'm imagining a language without return values :( what have you done!
&gt; A great example I keep running into: https://en.cppreference.com/w/cpp/container/vector/shrink_to_fit there's no way to say "do it anyway, fail to compile if you're not going to do it". If this behaviour is so valuable to you: would the benefits of rolling your own drop-in `vector` class start to outweigh the disadvantages?
The sentence says *re*learning, not learning. More precisely, the sentence might read "my quest for learning C++11 started in November 2018".
Excellent. Have not seen it before. Thanks.
I'm not sure if it's really possible, because even if you can't return a value, you can still write it to a predesignated place in the memory.
Personally, I'd still like to be able to compile and test boost using cmake using my own toolchain files. Also I don't think this works with individual header-only libraries yet? But yes. It is certainly a big step forward.
I tried to play with experimental/filesystem in order to understand this same issue, among others. But I couldn't. 
In my project (NavDB: [https://navdb.io](https://navdb.io)) every function returns an int (OK/WARNING/ERROR) that gets passed up until main. The reason I do that is so that I can log each function's error (including an error from a function it called) and have what looks like a stack trace in the logs, so that I can track down exactly where the error came from. For constructors and destructors I use a private int to track return codes, although I'm starting to think I should just use exceptions there. The networking code uses exceptions as this is how Boost ASIO returns errors. Is there any reason not to go this route?
I think if you want to test boost, it makes sense to use whatever system upstream uses to test boost. If you want to use boost as an external dependency, this will make it easier. The version issue you mention is exactly why this development is so valuable. `FindBoost.cmake` has lots of awful complexity which I opposed adding to it in the first place. 
Ultimate imperative language!
\`::SetLastError()\` ? Ouch ...
This is a really serious rant.
That only works reliable if I know enough of b2 to make sure the testst get compiled with the exact same toolchain and the exact same flags as the cmake project in which the headers get included in. For someone not familiar with b2 this is quite a tall order. Even more so, If I want to use things like sanitizers and/or cross compilers.
The refactoring part of the CMake branch you mentioned was merged, so the functional (debugger) part can proceed. I don't know why it doesn't proceed, but it's probably just whoever was working on it has different priorities.
Note that usually open source is made with time, not money. 
This sounds brittle, but waaay cooler than I expected. (I was expecting to see another DLL-based plugin system, but blink and jet actually load newly compiled code into a running application). I can see why a GUI developer might find this useful. I wonder if this could be useful for something else I've been yearning for: non-PIC dynamic libraries on x86-64. On x86, we could have non-PIC dynamic libraries, because the jump addresses could be rewritten by the compiler at load-time. On x86-64, dynamic libraries must be PIC, for reasons I understand, but am not capable of explaining.
I think the problem really stems from the places where exceptions don't work well. Otherwise I'd use them all the time. But when you're writing multithreaded or otherwise asynchronous code the path that a thrown exception takes gets fuzzy as you are often in some form on handler. E.g. im working on an app using actors which send messages back and forth. Throwing an exception in the message handler may mean something but it certainly isn't going to automatically make its way back to it's source. The other example is compability with C. Perhaps you are using or writing a library that may be used by either language. I'd say if you can cleanly use exceptions you should do so. And if you can't document why. 
Of course people who know CMake and not b2 and want to do things that require buildsystem knowledge would benefit if Boost used CMake. But the significance of Boost providing CMake config packages is a huge. Most users of Boost don't need what you need.
Bundled GDB works nicely with RHEL/CentOS 7. ANd likely native (older) version will work as well (even if the warning is present in toolchains settings in CLion).
Not if all variables are immutable and there is no arbitrary memory access (i.e. pointer arithmetic). A language without return values and call-by-reference is in fact possible and useful: see continuation passing style. 
That's a really interesting way to go about things... I'm only just learning error handling, so maybe outputting to a lot file would save a lot of time trying to find issues 
[removed]
`system_category` represents the error coding for your host OS. `generic_category` represents the POSIX error coding, which may or may not be a strict subset of your host OS error coding. I agree too much code uses `generic_category` when it really meant `system_category`. Some STL implementations have even been guilty of this in the past :)
We should be encouraging this sort of thing, because the only way to progress is with constant self-criticism. I've run into most of the points in his article. For example, the idea that exceptions are hideously expensive refuses to die, even though experiments seem to show that they have very reasonable time and space requirements, and often are significantly cheaper than passing back error codes and checking them for each frame in the stack. 
So, when your host OS returns a POSIX error code. Is it system or generic?
FYI Outcome and `std::expected&lt;T, E&gt;` have diverged by a fair bit, as per Boost peer review feedback. They are now two differing interpretations of how best to implement exception-less failure handling. There is a third approach proposed for Boost as well, called LEAF (https://zajo.github.io/leaf/). So suffice it to say that there remains disagreement as to the best design and approach. Even with regard to P0709, https://wg21.link/P1095 varies in some significant areas. P1095 was accepted, in principle, by WG14 (C), though counterdesign papers are coming to the next WG14 meeting. WG21 has yet to debate P0709 in depth.
Sounds reasonable, I guess you can talk to Vittorio or roll a reference implementation.
I actually tried to use the non-experimental header but Clang said it didn't exist when I tried to compile it so I reverted back to experimental. It may have been in part because I'm using Clang 6? I'll check later today.
Any error code being returned by any syscall should *always* be `system_category`. Period. You only make a generic category code if you synthesise a failure e.g. from `std::errc::*`. That's the whole point of the generic category, I can synthesise those generic failures using portable code.
Exceptions have been called `comefrom` statements, which are `goto`s from the other end. And like unrestricted `goto`s, unrestricted exceptions can cause spaghetti code. The proper way to do exceptions is to restrict them by having the calling function handle them or the program dies. That way, there are no long jumps in the flow. Unfortunately, I know of no way to restrict exceptions like this in C++.
Yes, GCC 8 and Clang 7 are needed for `&lt;filesystem&gt;`.
I'd more call it a U-shaped distribution myself. One tail involves 99.9% time. The other tail involves 99.9% money. Relatively few open source projects lie somewhere in between where there is a mixture of both. cmake is one of those relatively few, incidentally.
Thanks. This seems logical and straightforward. I'll do some testing later.
I agree with your points overall but: &gt; E.g. im working on an app using actors which send messages back and forth. Throwing an exception in the message handler may mean something but it certainly isn't going to automatically make its way back to it's source. Using `int` error codes isn't going to make it much easier to get the message back to the source! The hard part is the routing back, not the type of the message.
Tons of reasons. If you always return an int error code, then these aren't "functions" or at least not pure functions - they must be procedures with side-effects. Pure functions are easier to test, easier to write, easier to reuse and easy to compose. I mean, look at this code using your error codes: int getMyData(Data&amp; data, ...) { Database db; int error = db.initialize(....); if (error != OK) return error; DBCursor cursor; error = db.search(cursor, ...); if (error != OK || cursor.empty()) return error; return cursor.next(data); } as opposed to this version which uses exceptions: Data getMyData(...) { return Database(...).search(...).next(); } Also - what if in `int` doesn't give you enough information? What if you need to pass information back to the user like "Error in file xxx on line ###"?
If you want you can take a look at the NavDB C++ client for an example: [https://github.com/Navigator-Data/navdb-clients/tree/master/lang\_clients/cpp\_client](https://github.com/Navigator-Data/navdb-clients/tree/master/lang_clients/cpp_client) In the next release (v0.4.0) which should be later this month I'm going to include a separate C/C++ library which extracts some reusable code from the client and server.
The `int` error code is pretty bad - see my comments elsewhere on this page. Log files are necessary for real world programs _but_ there are two terrible problems with them. 1. No one ever reads log files after the first week, so if you log a problem to the log file it means essentially throwing it away _until_ you experience some more significant problem that makes you go to the log. 2. It's easy to put crap in log files - a project I worked on recently generated log files of 1 gig a day on a busy day, and nearly all of it was useless stuff that no one would risk throwing away. 
Here's what it looks like: if (my_func() == RET_ERROR) { log_to_file("failed: %s %d", my_var1, my_var2); return RET_ERROR; } return RET_OK; The logging is the main reason I take this approach, I like to have detailed error logs. The extra information goes in a call to the logger. Yes using exceptions results in less lines of codes but the logging is less finely tuned.
In my code only errors get logged (hopefully none!) unless I turn on trace/debug logging for specific files. This has been really helpful in debugging so I'm sticking with it.
cmake scripts?
See [Templight](https://github.com/mikael-s-persson/templight).
I read this paper a couple of times when it came out last year and I was blown away by it. It really fixes a long-standing pain point in the language in such a neat way - I thought, "Why didn't I think of this?" because in hindsight it seems obvious. Concepts are basically just pre- and post-conditions which throw exceptions - OK, with some additional type checking at compile time and some better optimization possibilities too. The synergy (hate that word, but it's the right one here) of concepts and the zero-overhead deterministic exceptions described in the Sutter paper you link above is a complete game changer as far as C++ error handling goes. If all goes well, C++23 will be a monster - concepts (already in C++20), zero-overhead exceptions, metaclasses, ranges and modules. Indeed, we're really ahead of the game, as we already know pretty well exactly how all of these except modules will go. Sigh, modules. 
Good to know. I'll grab that when I get home, thank you :)
&gt; The networking code uses exceptions as this is how Boost ASIO returns errors. This is lazy programming. Using exceptions as venue to convey logic and state I mean You care doing it right by passing state ir an ordered manner se each layer has the obligation to confront all the possible outcomes
&gt; Of course people who know CMake and not b2 and want to do things that require buildsystem knowledge would benefit if Boost used CMake. Sure, bu the hing is: There are an awful lot of those including IDEs and other tools that understand cmake but not b2. I think there is a reason why almost all newer boost projects I know of use cmake in addition to b2 for development. &gt; But the significance of Boost providing CMake config packages is a huge. Absolutely &gt; Most users of Boost don't need what you need. I've not enough experience or data to agree with or dispute that. 
Like Herb (and Bjarne) said, you can't use exceptions in a hard real time system. exceptions just aren't deterministic at all and thus fail the basic requirements for hard real time systems. Then there's the freestanding, highly constrained world that out right bans any use of heap and dynamic allocations. &amp;nbsp; Both of these would be fixed by "herbceptions".
\&gt; If all goes well, C++23 will be a monster - we already have concepts, but then zero-overhead exceptions, metaclasses, ranges and modules. Indeed, we're really ahead of the game, as we already know pretty well exactly how all of these except modules will go. Sigh, modules. Metaclasses have more chances landing in C++26 unfortunately. Except from that, I totally agree that C++ future is shiny.
There's absolutely no reason you couldn't have byte-for-byte the same log using exceptions. You raise the exception at the very place it happens, and put all the information you need to report the exception into it. Then you catch at the _highest_ level on the stack that is reasonable - the place where you can actually do something about it - because you have a lot more information there. Very occasionally, there is some information at stack frame levels between the top and the bottom you need to add, so at that point you catch the exception and throw an expanded one. In practice, that happens only in a couple of places in a project. &gt; My logging calls use macros which return the file, function and line that the logged error occurred at. You could use very similar macros to throw exceptions with exactly that data. But raising the exception to be caught near the top of the stack allows you to do more sophisticated things when you do handle the exception - for example, filtering by file/line number, or accumulating statistics for monitoring purposes. 
Most, but not all, error codings can be returned by `std::error_code`. You may find https://ned14.github.io/outcome/motivation/plug_error_code/ useful. There is indeed a lot of verbiage, but it's a once off investment. Once you've done it, Outcome will auto-convert a locally returned `result&lt;T, CustomEnum&gt;` into `result&lt;T, std::error_code&gt;` on demand, which saves lots of boilerplate and/or macros.
I'd really like both P1095 and P0709 accepted. Then we need reflections to replace RTTI and finally memory constrained systems that ban the use of heap can actually use C++, not "something that is technically not C++".
Don't get me wrong - logfiles will save your posterior on many occasions. You should always have logs. I'm just saying logs are not _enough_. If you log any error and continue, it encourages serious errors to go undetected. But if someone throws an unexpected exception, it will percolate up close to the top of your process stack, and if you are at all smart set off a bunch of pagers.
That depends very much on how frequently failure occurs. If it's anything apart from vanishingly rare, exception throws are very expensive. Several thousand CPU cycles per stack frame unwound on table based EH. If what you're doing doesn't care about a few ten thousand CPU cycles here or there, or failure is extremely uncommon, C++ exception throws are just fine. Even then though, be very careful with your assumptions. In my most recent contract I ported a large, old C++ codebase from x86 to x64. During database table queries, it threw about six exceptions per item retrieved. On x86 with its frame based EH (MSVC), you could display a few million entries in a few seconds. On x64 with its table based EH, the same query took minutes. As in, about eight of them. I had to gut and rebuild a ton of code to reduce the exception throws per item, and I got it down to under a minute before management signed off on it as "having acceptable performance", despite being still orders of magnitude slower than on x86. It's easy to say "don't use exception throws for control flow", but remember back when that code was written, all EH was frame based. So it was a reasonable design decision, back then.
There is, and it's used by about half of C++ out there. It's called "globally disabling C++ exceptions" e.g. `-fno-exceptions`
ASIO doesn't use exceptions. It is exception safe, but to my knowledge, it itself never throws an exception. ASIO uses `std::error_code`. You, and all C++ code, should use what in the STL instead of local reinventions e.g. `int` returns.
&gt; If you always return an int error code, then these aren't "functions" or at least not pure functions - they must be procedures with side-effects. If you return, via the function return, the error code, then a function can be marked pure. This is one of the major motivations of Outcome's `result&lt;T, E&gt;` because it allows the writing of pure functions and constexpr functions which can fail.
Zero overhead exceptions are not expected for C++ 23 currently, but rather as an experimental feature. If C adopts them for C23, then all the major compilers will have them, but they still wouldn't enter until C++ 26 as for obvious reasons C++ 23 can't incorporate C23.
Absolutely - that's really the best of both worlds in many ways, giving you `constexpr` _and_ a parallel error channel back from the function that you can't forget to check.
Interesting! What's the hitch with metaclasses? Didn't I see even a working demo compiler linked to somewhere? Well, I won't lose sleep if it doesn't happen. Metaclasses are nice to have and would cut down a bit of cruft but are not unmissable. 
Ah, yes, makes sense, it's a breaking change. I can't quite see how it would go as an experiment feature, though - it changes how exceptions are thrown, it can't be imported as a library. Perhaps as a compiler flag?
This is a late reply but I don't think vendor lock-in is an issue here. Once you have committed to using a specific game engine you have already committed to significant vendor lock-in. Even engines that use the same language will use completely different APIs, and may have significant differences in the underlying structures which dwarf the differences between the languages. The biggest competitor to Unity3D is Unreal, which uses C++ and a proprietary Blueprints visual scripting system. So a modified version of C# really makes no difference there. 
Seems that I misremembered that part about narrow (see my edit) - very sorry about that. &amp;#x200B; Just to be clear: the comparison operator wasn't the only problem I had with span in the past. That being said, I have less issues with the comparison operator of \`std::string\_view\`, because for me ,the value of a std::string\_view is still "the string" (not sure why, maybe because of the immutability of string\_view) - it just so happens that we don't own the storage. The value of a span (aka array view) however, has to me always been the range (address+size). Also, from a usage perspective: Comparing two strings happens all the time, whereas comparing all elements in a range (or two containers for that matter) was comparibly rare in my work so far. So there is a tradeoff here between "purity" and ease of use. &amp;#x200B; I think the general problem I had was that the gsl was sold as fundational library that was supposed to make c++ programming safer by adding safe interface vocabulary types that would gain tight integration with static analysis tools. What it actually felt like however, was more of a playground for future standardization efforts of \`std::span\` with frequent api changes and bugs all over the place and until recently, the tool integration was also mostly lacking. I'm over-dramatizing of course - many projects have apparently sucessfully used it. Maybe my initial expectations where just too high.
&gt; Several thousand CPU cycles per stack frame unwound on table based EH. Whoa! Where do these cycles come from compared to a simple return which also has to unwind the stack frame? 
https://www.boost.org/doc/libs/1_69_0/doc/html/stacktrace.html
The no-exception placebo is really irritating. People think that having exceptions would slow down their programs, yet the cause of the slow down is the individual people themselves. Sadly, it seems like shifting the blame by claiming that “stack unwinding” generates bloated code is a consensus among programmers, while they never realised it is automatically doing the exact same if-else error state automaton check you do manually with significantly less verbosity. Exception programming also leaves you a proper return type without explicitly specifying an out parameter/succeed result. It can also serve as a notification/signaling mechanism like in classic LISP. Java optional/C++ error code is a big step down to comfort those bigots who likes “explicitness” (impolitely, being repetitive). And also because of this, I kind of hated Unreal Engine where they use error checks everywhere and the source code is effectively cancerous. I wonder if CryEngine does the same.
There's also the issue that exceptions lead to a shitty dev experience in C++. If you have an uncaught exception it will just immediately exit the application. Even if you catch it you have no call stack for what caused the issue. The only way I know of to debug an uncaught exception is to just enable break on exception in a debugger, and reproduce it in a debugger. If your application relies on exceptions to pass error codes then you will get a lot of noise here, making that impossible, meaning the only debugging route left I know of is printf debugging... not great. The original design of exceptions was not to be used for error codes either, but for "exceptional" circumstances, e.g. out of memory errors. Expected errors for the api, like file not found, were never supposed to be exceptions. This also leads to confusion, like when do we actually use them. Their rarity means writing exception safe code is rarely necessary, and just disabling them means it is never necessary. Exceptions in C++ are basically a prototype for exceptions in other languages. 
&gt; The proper way to do exceptions is to restrict them by having the calling function handle them or the program dies. That way, there are no long jumps in the flow. I disagree, but I don't have a much better suggestion. I should be able to ignore exceptions that I can't handle to let my caller handle (ex if something throws as a sockdt has disconnected, it is definitely outside the remit of a "send ack" function to attempt to handle the error). That also doesn't fix exceptions, you could replace exceotios with error codes and still have basically the same issue
Exceptions can be great. The problem, though, is if you want your exception to be recoverable then your code needs to be exception safe. And it's a bit harder to write tests for exception safety than other tests. I rarely ever see exception safety tests in the wild.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/ae7ym5/first_time_programmer_please_help/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I think you're confusing concepts with contracts, of conflating both together. 
A proof of concept demo is to show off the idea and let people gain some usage experience. For standardization, the feature requires a whole lot of reflection that we have none of yet, and that part seems on track for C++23. That in itself is a giant list of much-needed additions.
The "send ack" function should throw its own exceptions. No, error codes are not the same thing. Error codes are often ignored by programmers. My proposal is the default action is to kill the program. The programmer has to purposely write code to ignore an exception. That makes exception handling non-optional.
Good article. Without this feature it seems like that macros will have to be used in conjunction with concepts to avoid repetition. --- template &lt;Regular T&gt; void foo(T&amp;&amp;); void bar(int i) { foo(i); // error } Ugh. Does this also apply to the terse syntax? void foo(Regular auto&amp;&amp;); 
Not exactly what I was talking about. The default action is for the program to die but only if the exception is not handled. Exceptions can be handled (that includes ignore them) but only by the calling function. There are no long jumps in the program's flow.
&gt;No, error codes are not the same thing. Error codes are often ignored by programmers. This is why we have `[[nodiscard]]`. &gt;My proposal is the default action is to kill the program. Feel free to sprinkle your functions with `noexcept`, and you'll get your desired behavior. No need to completely break exceptions for the rest of us.
We currently believe it won't be a breaking change. C, in particular, demands that old binary blobs can call into new binary blobs and vice versa. Source definitely must remain compatible. It is currently expected that C++ will do the same by default, but that the major compilers will provide an option to generate incompatible binaries which are much more optimal in terms of space and performance. Source compatibility would be retained in any case.
What's the size of your input? If it's just that string: "abcabcbb" then it's all inside the small-string optimization of std::string. By being all inside the small-string you skip any additional heap allocations that your unordered_map is going to do and it's just a series of memmove()s all on the same on-stack memory.
The results of functions are all stored in global variables. 
There are no constraints mentioned in the problem description, but the final solution is tested against over 900 cases. So, I am not sure about the maximum length of the input. But, in general, my solution will be faster?
Modern out of order CPUs have often pre-executed your function's return to its caller before it occurs. On Haswell or newer, the error flag checks after every function return are statistically unmeasurable. For table based EH, pre-execution is impossible. During table parse and stack unwind handler execution, multiple pauses on main memory occur, each costing 200 cycles or so. It very quickly heads into the thousands of cycles range. Here is a very naive and misleading benchmark proving this: https://ned14.github.io/outcome/faq/#what-kind-of-performance-benefits-will-using-outcome-in-my-code-bring
I can only speak for myself, but if I had a Patreon account or something like that, every $200 or so that I could get from there as monthly "regular" income, would directly allow me to spend more active time on my open source projects - fixing stuff that people bring up in issues, adding and enhancing functionality, etc. I suspect I am in the minority with that because many people would have a full-time job and couldn't dedicate more time to open-source projects no matter what, but then again it wouldn't be so rare I think. Also in Europe it's fairly common to work only 80%, or have 36-hour work weeks, etc., so I think the money would actually translate to "being able to spend more time on open-source projects" for many people.
&gt; Sadly, it seems like shifting the blame by claiming that “stack unwinding” generates bloated code is a consensus among programmers, while they never realised it is automatically doing the exact same if-else error state automaton check you do manually with significantly less verbosity. Modern compilers can and do substantially rewrite and fold sequences of if-else branch logic into no code output. It was originally thought possible to do the same with table based EH, but no implementation is known to do so. Herb for P0709 did a bit of surveying of the xbox team etc and they think approx 15% of binary size can be eliminated by replacing table based EH with if-else logic. Some programs much more.
Big O notation doesn't always tell the whole story. It's easy to compare the constant lookup of your `unordered_map` to the linear lookup of `string.find()` and assume the map will be faster. &amp;#x200B; The reality is that: * The `string` lookup is `O(n)` where n is the size of the alphabet (26 if the input is only lowercase), so it effectively *is* constant. * The `string` version is much more friendly to the CPU cache. In fact, even at its maximum size, it will probably fit inside a single cache line.
Without the input data, it is hard to know for sure. But it looks like the number of memory accesses and/or the use of specialized assembly instructions. In a modern computer, accessing one byte or 64 from the main memory cost about the same, so locality of access is of paramount importance. I can't find it, but there was a talk/part of a talk with a name like "I don't care what your data structure is, but an array is probably faster", which made the point that, in practice, since a few years, the most important practical things for performance was [locality of access](https://gist.github.com/jboner/2841832), and that arrays were just better in most real world cases. I suspect this is one of those cases.
I guess it all depends on your hardware/strings. I've never found hash tables to be all that fast. Not sure why - maybe the data sets I use.
I have a WG21 paper in the works which would implement fault handling e.g. segfault, FP exception, exception throw in noexcept, unhandled exception, no memory etc. I have a reference implementation in daily use, just need to write it up into a proposal paper. Anyway, one handling option is long jump, and we'd concurrently make it less UB to use long jumps in a very restricted subset of C++.
what is "FP" ?
P0709 proposes making many of the STL exception throws fatal by default. So far, WG21 appear to like that proposal, so you may get what you want by C++ 26.
I read your post and a bit more in that mailing list thread. Oh man, what an aggressive tone these conversations have. It's really too bad. Anyway your first post is very interesting, but I do still have a question: So how does it work - Does Boost write those boost-config.cmake files "manually", they mimic CMake syntax and "printf" that to the files, so that the output is valid CMake?
What do you mean by "I've never found hash tables to be all that fast."? The idea behind hashing is to save searching time at the cost of space. If they are almost never fast enough in practice, then why even introduce them? P.S. I am a beginner in algorithms and trying to understand the fundamentals properly. 
A few years ago, there was apparently one person in Boost that was very opposed to bringing CMake support into boost and that it wouldn't ever happen "under his nose". That person had a very important role, so nobody was able to step up to them. I am wondering whether that person is still there or not and whether "high up" the climate in boost is still very cmake-unfriendly?
* Your point on 'find' hit home! I was imaging find operation on the substring, but in this context is entirely different. * About the insertion and erase, won't the same argument be true in case of string also? It's an array, so if I remove something from the front, I need to move all elements in the array. Also, do you have ideas on an alternate solution which doesn't rely on insertion and deletion inside the loop, and is faster? (using a different data structure is also acceptable, I am trying to comprehend different possibilities).
See: https://www.reddit.com/r/cpp/comments/ae872h/why_find_and_erase_on_string_faster_than/edn5pom/ Hashing isn't free: * You must read the entire input series to hash it vs std::map which will do binary search to find the insertion point (which might not even read the entire input string or strings of existing members) * Adding an item to the hash table will most likely allocate memory * Iterating over the hash is going to be skipping over different allocations Unless you know your N will be large O(N) approach can (and frequently is) faster due to increased memory locality and increased cache hits. Of course your mileage will vary. I just haven't seen hashing be worth it for what I work on.
In essence, you are saying that because an array is contiguous, the operations such as find, erase, insert will be faster? If yes, can you please explain in detail why this might be the case because it's not very intuitive (considering the maths behind it)?
" ... \[This section proposes\] a solution — not without trepidation, because I understand this touches an electrified rail. ..." - Herb Sutter, [while presenting the possible "universal solution"](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r2.pdf).
&gt; while they never realised it is automatically doing the exact same if-else error state automaton check you do manually with significantly less verbosity. Uh, no it isn't. I agree with your point that exceptions, when used properly, don't slow down your code. But exceptions don't generate local control flow. It does stack unwinding. Here's a talk discussing the implementation: https://www.youtube.com/watch?v=_Ivd3qzgT7U
&gt; If you have an uncaught exception it will just immediately exit the application. Even if you catch it you have no call stack for what caused the issue. You can generate a stack trace from an exception with libunwind and other similar libraries.
Thanks for the answer. This discussion was really helpful. &amp;#x200B; I am just curious about your area of work (the problems that you deal with). 
You have an example of this? Because AFAIK you cannot generate callstacks from exceptions, you would have to embed the callstack into the exception. This would be ok if you made your own exception class, maybe generate the callstack on that exception constructor, but you wouldn't get that info from a STL exception, and this would be unnecessary overhead if you attempted to use exceptions as error codes.
I don't know if a good error handling system exists yet in any language. In languages that use exceptions as first class citizens (java, python) it's clear that exceptions aren't great as error handlers. Even in rust with the force-handled Result enum type, which I think is beautiful and the best error handling scheme so far, I see a lot of people on r/rust getting annoyed with it as well when used in practice.
&gt;should be `Args&amp;&amp;...` No, see https://www.reddit.com/r/cpp/comments/adg32t/x/edgxtgs/ and following. &gt;Basically, `hyper_function&amp;` prefers your `Callable&amp;&amp;` overload No, it prefers `hyper_function(hyper_function&amp;)`. &gt;small object optimization This is true. But I'm pretty sure the small runtime efficiency gain doesn't matter in this case. OP is the primary author of [`stdext::inplace_function`](https://github.com/WG21-SG14/SG14/blob/master/SG14/inplace_function.h), so he's unlikely to be unfamiliar with the technique!
Well, it all comes down to cache locality. If your access is localized, then each iteration on your string search takes about 10 to 20 cpu cycles. (String comparison usually gets short circuited pretty soon, so you can expect that most failing comparisons will only do like 4 or 5 iterations (around 40 to 100 cycles)) While hashing a string can easily take hundreds of cycles (keep in mind that the modulo that is done to bring a hash into range alone takes more than 10 cycles, and that it must be done O(N) times when hashing a string). There is also the issue that nodes in your hash table are mostly far appart from each other in memory, meaning you will take one cache miss when reading the node, and another one when reading the data of the string it contains (~400 cycles). This can be alleviated by using a flat hash table, which would, on average, get rid of 1 cache miss per lookup. Making your lookups almost twice as fast. Overall, this means that each lookup into your hash table will take upwards of 200 cycles, even if you are using a 'good' hash table (this is a conservative figure, since hashing the lookup key will probably take a comparable amount of time)
I believe you are misrepresenting C++. The advise has - to the best of my knowledge - always to use exceptions for *exceptional* circumstances and something else (in modern C++ some kind of variant-based approach) in all other cases. So the discussion is more about what an exceptional circumstance is. To me it is something like in the order of one in 100.000 calls. Hearing elsewhere in this thread about something like eight exceptions per "execution unit" is just not acceptable coding and never has been. And then, we have always had the problem with code that can not use exception because of their non-deterministic nature: here, of course, you just have to use another approach.
I do not understand what you are saying. What does concepts have to do with exceptions? Perhaps you were thinking about contracts?
I work exclusively in game development. Entity logic, input handling, rendering, saving/loading, mod API and so on.
sebamestre's answer does a good job of explaining what might be happening, but if you are still not quite clear on how the cache works to make contiguous memory access faster than non-contiguous access I think [this talk by Scott Meyers](https://youtu.be/WDIkqP4JbkE) does a very good job of explaining it with examples, diagrams and performance measures.
The day exception was added to C++ was the day that C++ will have more than one way for standard handling. It's just how things work when you have more than one way to do the same thing. Instead of trying to unify all error handling concepts, finding the best ways to handle different situations may be more beneficial in the long run.
if it works for them then it works for them. Yes there are other approaches, there are always other approaches. but it's effective and gets them everything they look for in the face of a failure. You can quibble about the details, but taking a C-like approach in C++ is perfectly fine.
It's a good idea to return 0 after main to indicate no errors, non zero should indicate error, say a file failed to open or unexpected exception.
My guess is Run-Time Type Information (RTTI).
Right, you can have a custom error code category! I had not realized that.
&gt; The original design of exceptions was not to be used for error codes either, but for "exceptional" circumstances, e.g. out of memory errors. From Stroustrup: &gt; Given that there is nothing particularly exceptional about a part of a program being unable to perform its given task, the word “exception” may be considered a bit misleading. Can an event that happens most times a program is run be considered exceptional? Can an event that is planned for and handled be considered an error? The answer to both questions is “yes.” “Exceptional” does not mean “almost never happens” or “disastrous.” Think of an exception as meaning “some part of the system couldn’t do what it was asked to do”. --Stroustrup
 &gt; Given that there is nothing particularly exceptional about a part of a program being unable to perform its given task, the word “exception” may be considered a bit misleading. Can an event that happens most times a program is run be considered exceptional? Can an event that is planned for and handled be considered an error? The answer to both questions is “yes.” “Exceptional” does not mean “almost never happens” or “disastrous.” Think of an exception as meaning “some part of the system couldn’t do what it was asked to do”. --Stroustrup
&gt;Should I include \`return 0;\` in the very first lesson? IMO Yes - you don't need to explain it at this point if you don't want, just say it's necessary. &gt;Where is the perfect place to introduce \`using namespace std;\`? Don't. It's considered bad practice. &gt;Where to introduce the different types of errors and debugging? Introduce debugging very early on - it's a fundamental part of developing. Introduce types of errors as they make sense - no need to talk about access violation / segmentation fault until you introduce memory and pointers, for example.
The actor framework has a request response mode and then I can throw an exception after reading the response. It does help in my case. In other instances I would pass a lambda or closure of some kind that should be called on error. 
You can, but they don't work right from shared libraries. This is a known defect, and will be fixed we think in C++ 20. Boost fixed its implementation some months ago, so that's a stand-in until then.
Including \`return 0;\` is also useful in demonstrating that \`main()\` is just a function. This is particularly useful to people familiar with functions from their math classes. I've encountered enough people who aren't able to make this connection on their own to warrant a conversation about the mathematical roots of programming.
Delineating between recoverable and unrecoverable conditions is a programming task that i think we are all responsible for. As for testing, i think the problem is that it's easier to prove an exception is thrown than it is to prove one never will be. Such a test would either require strict use of throws clauses, or tests that generate random selections of random but valid inputs for your functions, and then testing for not throwing. I actually do "property-based testing" in my codebase, but generally not with a focus on finding exceptional conditions. It's a hard thing to do right i imagine.
Yep. The terse declaration of `foo` means exactly the same thing as the partial-concept-id version - the only semantic difference is you don't get the name `T`.
I don't know what "manually" means to you. `b2` is the buildsystem of boost, and it generates the `config.cmake` files I expect. `b2` knows the files to generate. It's just like how `qmake` does the same thing, I expect.
Have you considered the range-v3 `enumerate` implementation, and if so, what does yours do different?
Not to hijack this thread, but if you are interested in such things, I posted a video a bit back about how my test framework works. It's a fairly straightforward but effective test framework, and some folks might find it useful info in their own efforts. [https://www.reddit.com/r/programming/comments/ac2o4m/creating\_a\_test\_framework/](https://www.reddit.com/r/programming/comments/ac2o4m/creating_a_test_framework/) There are links in that thread to a number of others that get into the creation of some considerably more complex stuff as well.
The feature would be opt-in for new code but leave old code and ABIs mostly unaffected, iiuc.
I think it's good to avoid new/delete (and obviously malloc/free) and use mostly the stack (or smart pointers if necessary). Same for C strings/arrays. But there is so much legacy code out there that needs to be maintained and helpful C libraries you can use from C++ code, so those topics should definitely be part of an introduction to C++. You need to have both: knowledge how to program on a green field as well as knowledge about those things to refactor/update/interface with legacy code. I think hand implementation of standard data structures (such as a linked list to understand the concept of pointers/references) are a good exercise but it should be clear that you don't want to do this in a "real" project unless you have to. Regarding data structures it would also be nice if the course would give a basic intuition which one to use when (see e.g. [http://www.stroustrup.com/bs\_faq.html#list](http://www.stroustrup.com/bs_faq.html#list)). &amp;#x200B; &amp;#x200B;
I am petty enough to avoid exceptions because of unwanted `try {} catch {}` clutter and the overall poor semantics. On top of that the added performance boost of compiling without exceptions is nice. I am perfectly content with my program aborting in exceptional circumstances.
&gt; decades have passed, standard C++ has no agreed and standard error handling concept Since 1998, in 20 years or so, you've failed to notice that all standard library functions report errors via exceptions. &gt; * Exceptions or no exceptions, that is the question? To be or not to be? Yes, exceptions, as the default, and possibly deferred ones such as when using `std::optional`. One might thing that return value is an alternative to exceptions but it isn't. That's about defining a suitable *contract* for your function or set of functions. An exception means a breach of contract, either by the caller or by the function being unable to achieve its contractual post-condition, and that doesn't come into play when, in some given situation, the contract is to return a value. So, much of the complexity lies in designing a suitable *contract* for your function or set of functions. And that includes the probably the most common alternative to exceptions: *undefined behavior*. For example, indexing via `[]` is by convention, in the standard library, just UB when the index is out of range. But one may choose to instead use `at`, which has a contract stating that it has well defined behavior for any index value, where it's contractual obligation is to return a reference to the specified item, and throw an exception if there is no such. &gt; * Are exceptions fast? slow? is that a wrong question to ask? No, it's a good question. In 2006 the international C++ standardization committee published a [technical report on C++ performance](http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf). In summary, the conclusion was that the overhead of exceptions at the time, was quite low, and acceptable. Since then 64-bit systems have become the norm, and especially in Windows this means improved exception handling efficiency, so called "zero overhead" exception handling. The idea is that one pays the cost only when an exception is thrown, i.e. in the contract failure case. Since the normal case code then doesn't have to check the fail/success status of its function calls, it can be faster than with contracts that specify failure indication via the function's return value. But even that marginal and limited-to-failure-case overhead is in principle avoidable. So in 2018 Herb Sutter (chair of the committee) published a paper describing [a new exception mechanism](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf) that largely avoids the overhead of *propagating* an exception, by letting a function declare that it throws only a given type. &gt; * And there is `std::error_code` .. almost not used in std lib. 10+ years after introduction. It's used in `std::system_error` and derived classes. I don't like it: it's over-engineered and just not very useful. &gt; * after 10+ years of existence, there are no more than just a few authoritative online sources on \&lt;system\\_error\&gt; There is nothing called "\&lt;system\\_error\&gt;" in the standard, so I'm not sure what you're talking about, but I'd guess `std::system_error`? If so, the most authoritative source is the ISO C++ standard. Next, if you don't want to buy that, and don't feel like using a draft version, then check out [cppreference.com](https://en.cppreference.com/w/cpp/error/system_error). &gt; Then there is `std::to_chars` and `std::to_chars_result` Yes. But not yet implemented by all compilers, and IMO badly designed. At least, it's not evident how one can determine an adequate buffer size without invoking locale-dependent functions. 
Thanks for the detailed explanation. This makes a lot of sense after watching Scott Meyers talk.
Thanks for the talk. I really loved watching it!
&gt; I've not enough experience or data to agree with or dispute that. There are more users of boost than there are developers working on boost (that would also benefit from cmake).
Hi there, thank you for your interest. The only languages required for this job are C++ and Python. Please feel free to submit your resume to us. 
Metaclasses are massive and controversial. It took this long just to get Concepts and Ranges and I expect it will take a long time to get Metaclasses (if at all).
1. You should not include `return 0;` in the first lesson. It has no value to a beginner who can do nothing but memorize it unless you explain how the CLI works. 2. `using namespace std;` is fine for beginner code because it reduces verbosity of vocabulary types such as `vector`, `string` and `array`, and makes the language less intimidating. This is also a pretty easy thing to unlearn when you get to explaining namespaces.
using namespace std; just... don't.... there is enough garbage in the global scope as it is, don't add more to as... just use std::cout, std::cin, std::endl, etc. how to introduce namespaces? teach them **why** namespaces are used, **how** to use namespaces, and how to access the variables, methods, structures within said namespaces. either using "namespace::class::method" or something like that
&gt; The "send ack" function should throw its own exceptions. So now methods which call methods that throw have to catch all exceptions and preserve the context? You know this is going to end up with people rethrowing as a default (more boilerplate and no benefit) or people just catching and throwing a generic error which probably was much less useful than the original &gt; No, error codes are not the same thing Never said they were. My point was that it doesn't matter what model you use, forcing programmers to handle the errors will inevitably converge to a bunch of useless boilrrplate. The issue is that writing robust code in the face of errors is really damn hard, and it doesn't matter if you use exceptions or error codes or some internal state, or whether you force people to handle errors or both. You can write excellent code with any of those paradigms, but people will always if kre it. Finally, &gt; My proposal is the default action is to kill the program. The programmer has to purposely write code to ignore an exception. That makes exception handling non-optional. That is the behaviour right now, unless I'm mistaken. I don't have a copy of the standard to hand, but I tried gcc mavc and clang, and all three simply terminate on an unhandled exception
&gt;Should I include `return 0;` in the very first lesson? I vote for 'no' - I've seen far too many newbies asking what it means. TC++PL's "hello world" (reproduced on [Wikipedia's C++ page](https://en.wikipedia.org/wiki/C%2B%2B#Language)) doesn't use it. &amp;#x200B;
&gt; as for obvious reasons C++ 23 can't incorporate C23. Didn't C++11 incorporate C11 threading and atomics?
Agreed. Exceptions are more like undesired state(s) in an execution of program, that can be waived if handled correctly.
Yes. See the note on the bottom of page 10 of [p0709r2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r2.pdf)
&gt; Adding an item to the hash table will most likely allocate memory Why do you say this? Memory should only be allocated when the hashmap is resized, no? Kinda like saying that adding to a vector will "most likely" allocate memory. Especially when you compare to std::map which will always allocate memory for new nodes. 
People working on boost are only part of the story. I had to compile boost for an embedded target for example and most sanitizers work best, if the whole code is compiled with support for that sanitizer. Not everyone is suited with the default compilation options for boost.Also using a different compiler and/or standard library then the system default one (not to mention a different c++ version) are not uncommon requirements at all.
Yes. First, in a modern architecture, when you access one byte of memory, it actually loads 64 (the cache line). This means that accessing close data is basically free. [Because accessing memory is *very* costly](https://gist.github.com/jboner/2841832). It also helps with parallelism, as all the data is already here (ie: if you do something on the first byte and something on the second byte, you have a good chance that the two instructions are executed in the same time, something known as [out of order execution](https://en.wikipedia.org/wiki/Out-of-order_execution). Also, if you have a test, [speculative execution will not have to wait on memory access](https://en.wikipedia.org/wiki/Speculative_execution). Then, you have specialized cpu instructions. Here are, for instance, [some old SSE2 instructions specialized in strings](https://www.strchr.com/strcmp_and_strlen_using_sse_4.2). If you need exactly what they provide, it will be hard to beat such instructions. Also, think that you objects are probably allocating memory, which is very slow. Overall, the math behind complexity calculation will say that your approach is better, but it uses *more* memory (pointers are 8 bytes), non-cached memory, and even allocates, so you will end up waiting on memory a lot. If real memory is 200 times slower than the register and you are using more memory, you can easily understand that, while you are asymptotically better, the constant factor is killing you for normal datasets. Say your operation is in O(n*log2 n), and the other guy is in O(n*n), but you are a factor of 100 slower due to your memory access patterns. [It will take some time before your faster algorithm is faster than the other one](https://www.wolframalpha.com/input/?i=n*n+vs+100*+n*log2+n+between+0+and+100). Hope that helps. 
Functional programming 
I don't doubt this is very useful, but why are they using legacy software? And calling out modern? &gt; We used clang-3.4 and gcc-4.8 in our experiments. GCC 4.8 was released in 2013. At least it's already using DWARF4 https://gcc.gnu.org/gcc-4.8/changes.html &gt; we used a modern debugger (gdb-7.7) https://www.gnu.org/software/gdb/news/ &gt; February 6th, 2014: GDB 7.7 Released!
The `setjmp/longjmp` from C where the original exception mechanism.
The threading *model* and atomics *model*, yes. But C++ 11 included C99 if I remember rightly. I'm not even sure if C11 wasn't included until C++ 17 even.
Yeah, that was actually the first place I looked when I wanted to solve this rvalue 'problem'. I had never used range-v3 before, but when I looked at the source code, it didn't look like it was handling its universal references correctly. So I just moved on. &amp;#x200B; For science, I have thrown together a [wandbox example](https://wandbox.org/permlink/KjgEE83eFr2FVwci) to show how range-v3 handles both lvalues and rvalues. Unexpectedly, the lvalue actually calls the copy constructor once and then the move constructor twice. The rvalue has its move constructor called 4 times. Like I mentioned earlier, I have not used range-v3 before this. So if I am using it incorrectly, please let me know. If it is correct though, then this amount of copying/moving seems pretty bad. Especially since I assume that the copy on the lvalue container will mean that changes to values in the loop will not be permanent since they would be made on the copy of the container and not the original container. &amp;#x200B; The primary goal I had when writing this new enumerate implementation is that it will do 0 copies/moves on the iterable object provided to it regardless of lvalue or rvalue state. 
Your completely going backwards with modern programming language trends. Most modern languages are going towards explicit optional/error handling. Just look at go, kotlin and stuff that modern C++ has to compete.
Far as I know, in x86 MSVC stack unwinding is implemented with branches. In x64 they finally changed it to use EH table though the use of .pdata section IIRC. You have to think of exception handling as a state machine, and both direct branching and table based handler are well-known state transition function. The overhead of exception is that the thrown object was allocated on heap and is subjected to dynamic memory management and there we also need to handle polymorphism, that exceptions can be inherited and overriding the handler priority! It is also worth noting that std::exception has a pure virtual ‘what()’ which mean we will need one vtable struct and one vtable pointer on every object. RTTI and exception are the two most hated-but-necessary components of C++. STL required them, unless you agree to use Boost.
Imho writing exception safe code is not more difficult than using error codes if you use raii - which you should do anyway, because even without exceptions you will forget to clean up somewhere. Retrofitting exceptions into an existing code base that is relying on manual cleanup however, is next to impossible.
Progress has been slow, but I think most of what we've learned with dynamic exceptions will still be useful with static exceptions.
I would look to Kate Gregory's talk on teaching C++ to people I feel she has put together a very good and consistent curriculum Her talk on this can be found here: https://youtu.be/YnWhqhNdYyk
I do not use Go because it doesn't really fit my philosophy of DRY. No proper generic and error handling are the two big reasons along with a weird syntax (but I do like Gopher and had a T-Shirt for it😆) Kotlin still encourages you to use exceptions and not pattern matching to do error handling. Again it makes thing more spaghetti upfront.
&gt; That is the behaviour right now, unless I'm mistaken. I don't have a copy of the standard to hand, but I tried gcc mavc and clang, and all three simply terminate on an unhandled exception Only after searching back thru the call tree to see if there were any handlers. I purpose that only the calling function is searched. If there's nothing there, the program dies. For example, a function that calculates the roots of a quadratic equation: procedure quadratic given Number a default 0 Number b default 0 Number c default 0 returns Number larger root default 0 Number smaller root default 0 except when not a quadratic when no real roots larger root gets ( -b + √( b² - 4ac ) ) / 2a smaller root gets ( -b - √( b² - 4ac ) ) / 2a except when division by 0 throw not a quadratic when negative square root throw no real roots The exceptions are rethrown with a more meaningful identifier. It's also more sensible since it can be written so that it throws its exceptions by pre-testing. It would be confusing to use an exception that does no originate from the function. procedure quadratic given Number a default 0 Number b default 0 Number c default 0 returns Number larger root default 0 Number smaller root default 0 except when not a quadratic when no real roots if a = 0 throw not a quadratic if b² &lt; 4ac throw no real roots larger root gets ( -b + √( b² - 4ac ) ) / 2a smaller root gets ( -b - √( b² - 4ac ) ) / 2a And finally, exceptions are part of the function's signature (aka API aka prototype), so programmers would not have to search the code for them.
I agree that it all needs covering - eventually. But new/delete doesn't need to show up in the first lecture on OOP, as it does in so many courses - classes are just as useful in globals or on the stack.
Why would you think of on average ~1/5 of the binary size for EH is that big of a deal when you could get less code debt? If you think that is still "bloated", then so libcurl/OpenSSL/glibc does it more then ever. 
The points weren't meant to be related to each other. More so saying adding an item to a contains is most likely going to involve heap memory and if you can just skip the container completely you're better off.
Standards committees really like features which through a source recompile, yield large improvements in some factor or other, especially if ABI compatibility is retained.
Not necessarily - you could also use [continuation-passing style](https://en.wikipedia.org/wiki/Continuation-passing_style) to avoid side effects. Then you could have a language with both no return values and no global state.
Just don't do `using namespace std;`. If you teach students to always type `std::` (std::vector, std::cout, etc...) then you don't actually need to explain what namespaces are at all (you can introduce that later). You just say a bunch of useful stuff is available, and it is all named starting with "std::". If someone asks "why isn't it `std::int` then?" you say "the base stuff is just `int`, etc, but these extras things in `std` are built on top of the base - later we will teach you how to built your own helpful pieces just like std:: stuff."
Coding constructors without being able to throw exceptions is not standard C++. To name just one ...
Insert on a string will allocate memory if the backing data is not big enough. Erase will just copy data around and modify the size member. Try out using a zero-initialized array or vector of 256 ints instead of an unordered map, And use your characters as indices into it. No heap allocation, no hashing, and O(1) lookup. 
Insert on a string will allocate memory if the backing data is not big enough. Erase will just copy data around and modify the size member. Try out using a zero-initialized array or vector of 256 ints instead of an unordered map, And use your characters as indices into it. No heap allocation, no hashing, and O(1) lookup. 
Insert on a string will allocate memory if the backing data is not big enough. Erase will just copy data around and modify the size member. Try out using a zero-initialized array or vector of 256 ints instead of an unordered map, And use your characters as indices into it. No heap allocation, no hashing, and O(1) lookup. 
Also, if I have a bunch of vector declarations, I might use "using std::vector", since it is pretty clear where the vectors come from. But yeah, "using namespace xxx" in general can be problematic, especially with a huge one like std.
True. One of my biggest concern is the incompatibility of ABI exception objects across different shared boundaries which causes even more unexpected and sophisticated states! If you mix old and new Windows C++ DLL and it is a clusterfuck when it comes to exceptions (although what I did as a plug-in system is very wrong already)
Perhaps not stl exceptions but you can override the boost throwing handler and under windows all SEH exceptions such as access violation, stack overflow carry the callstack as well.
Yeah, small namespaces are ok to use using namespace: Big ones just creates confusion and debugging hell
Agreed, and probably why exception was invented in the first place. Still, exception may not be the best fit for all error handling cases, e.g. recoverable situations.
the use of which, of course, is one of the reasons exception handling violates the principle (another big reason in allocation)
You can do exceptions... try { canFail1(); canFail2(); canFail3(); // good to go } catch (exception&amp; e) { handleError(); } Or you can do nested ifs... if (!canFail1()) { if (!canFail2()) { if (!canFail3()) { // good to go } else { // handle fail 3 } } else { // handle fail 2 } } else { // handle fail 1 } Or you can go in a straight line... int r1 = canFail1(); if (!r1) { // handle fail 1 } int r2 = canFail1(); if (!r2) { // handle fail 2 } int r3 = canFail1(); if (!r3) { // handle fail 3 } Not sure how the exception path is doing anything but removing clutter. 
This!
&gt;and will be fixed we think in C++ 20 Interesting, could you link the paper?
`std::string` only deallocates memory on deletion. Erasing only shuffles data around and sets size member. You could try using a zero-initialized `int[256]` array/vector and use chars as indices directly into it. No hashing, no resizing, O(1). 
One interesting thing not mentioned in this thread is "inheritance/composition with references, not pointers". This is another thing Kate Gregory talked about. If you use references instead of pointers you can postpone introducing pointer syntax (and thus pointers themselves and everything that comes with that avalanche if questions) until your "class" is ready to tackle that subject on its own - pointers aren't introduced as "a necessary evil" to do what other languages do without them.
Not sure why this is being downvoted. Returning 0 from main is VERY useful for integrating with external and automated tools (e.g. jenkins, bash scripts). Knowing that returning 0 indicates success and non-zero indicates an error is used basically everywhere I've worked over the past 20 years. &amp;#x200B; My current project has \~30 different build and test profiles in Jenkins. Knowing how an application interfaces with the CLI is very important.
C++ is a multi-paradigm language - it doesn't agree on almost anything. The answer to every C++ question is "it depends". This is both the pain and the beauty of C++.
&gt; You have an example of this? https://github.com/bombela/backward-cpp &gt; Because AFAIK you cannot generate callstacks from exceptions, you would have to embed the callstack into the exception. Backward.cpp works not by catching the exception in some enclosing scope, but by adding a signal handler for SIGABRT/etc. When you throw an exception that doesn't have a handler, the unwinder examines the call stack, realizes that there is no handler, and `std::terminate`, which aborts. Control then passes to backtrace-cpp's signal handler. This all happens "within" your throw statement, so the call stack still exists when backtrace runs.
http://wg21.link/P1196
Are we just allowing advertisements disguised as questions now?
Oh this is great. Bookmarked. I took her C++ course on EdX and liked it a lot!
Yea definitely, these guys will today learn what variable is and the next day they will automate their builds with jenkins. 
Exceptions and RTTI are the most well known. thread\_local also breaks this, though it is subtle, and often a sunk cost that people don't notice.
Since this seems to be course for the very beginners, I would stay away from language specific stuff and focus on fundamentals, cycles, flow control, etc. Debuggng should be introduced as early as possible if you have any homework assignments or anything they do on their own. 
Honestly the third version is the most readable to me
Only people with no experience in commercial applications believe is a good idea to force one way or the other to the whole project. Consistency is good, but is just a mean to an end. First comes the features that give value to the product, everything else can be sacrificed. 
Totally agree. Probably, this comes from other programming languages where "new" is the correct way to create objects (like Java). When it comes to OOP - especially inheritance \[0\] - I think one important issue (that is C++ specific because Java and many other languages don't have class instances stored on the 'stack' vs. on the 'heap') to discuss is slicing and how to prevent it. Because here, it can get confusing very quickly if the course teaches to always use the stack for variables. Maybe one way to teach it would be to make an example with slicing and then resolve the confusing by explaining what happened. (additionally: constructors - explicit sometimes, destructors - virtual sometimes, move, rule of 5, rule of 0, operators and overloading, ..., so many topics) Another example to show the user where 'values' lead can cause trouble is when referencing values stored in a vector that will be resized later on. This invalidates the references and causes the program to crash. For example one more indirection (e.g. through \`std::vector&lt;std::unique\_ptr&lt;T&gt;&gt;\` instead of \`std::vector&lt;T&gt;\` or by using indices instead of references/pointers to entries) solves the problem and keeps references to entries in the vector intact when resizing the vector. It would be nice to see a course teach those topics or at least raise awareness that those things can happen in C++. Explaining \`const\` helps here! \[0\] Although I mostly prefer other approaches to get polymorphism. There are so many in C++. Especially with the new standards. Teaching lambdas, std::function, std::variant, etc. is important in this context.
Could you explain a bit the `thread_local` part? Or point me in the right direction to read about it?
I've been developing with exceptions for over two decades, and what you describe is new to me. In my experience, an application that was developed with exceptions from day 1 has exception handling around things like the main event loop that stop exceptions from escaping into the wild. This acts as a backstop in case something is missed elsewhere, so the application never aborts. Furthermore, exceptions are derived from std::exception, which has a descriptive text. If an exception shows up in an unexpected place, the text easily identifies where it came from. If that is not enough for you, you can base your own exceptions on a child of std::exception that also carries \_\_LINE\_\_ and \_\_FILE\_\_ for the point of origin. I'm wondering where your negative experience comes from. Were you throwing things that were not derived from std::exception? Did you have a giant zoo of unrelated exception types that made it easy to miss one? Were you trying to backfit exceptions into a large system written without them? All of those might make for a less than optimal experience, I guess. 
It probably performs worse given all the branches. It has extra variables that are strictly artifacts of the design decision. It's about 40% longer. I'm struggling the see the upside of the approach in a C++ codebase, tbh.
The most obvious, that initialization of a local `static` is thread-safe. That implies some synchronization, at cost. It wasn't in C++03. 
All that means is you're not used to exceptions. Things look natural after you use them for a while. Also I use RAII everywhere an I almost never have try/catch blocks at all so usually my code looks like: canFail1(); canFail2(); canFail3(); Then at some distant single entry point there is one catch for error reporting everything. Exceptions have made all my code so much better.
I think it's more a case of "our tools can't predict the exception runtime overhead" rather than the exception itself being non-deterministic. Pragmatically I'd have to agree they're the same thing tho.
Which is kind of the point of this conversation isn't it? There are plenty of reasons to not use exceptions [beyond the things you pointed out](http://seanmiddleditch.com/keep-disabling-exceptions/). Your choices are basically error codes (which unless I'm misunderstanding is what the third example is) or things like expected and optional.
This is true but you can't use a GC language at all for hard real-time systems. C++ has tons of ways to do things which means it can do almost anything. Flexible tools are great. 
Requiring both the old and new thread handle in fiber_switch can make things error prone. Keep an internal thread local variable around that holds the current active thread, and use that instead so it's just fiber_switch(new). This also lets you offer fiber_active() which is very useful when multiple fibers may call the same routine, but you want to know which fiber is the caller. Keep another variable around to tell you if the main thread is initialized. Have fiber_alloc (and if you add it, fiber_active) check this, and call fiber_init_toplevel for you. Those two will make your library easier to get started with. You have so far, but avoid the temptation to support both synchronous and asynchronous cooperative threads. It's easy to implement one on top of the other separately. Best to only provide asynchronous, so good job there. On x86/amd64, it's a good speed-up to get the return address from the inner fiber_switch handler into eax/rax as soon as possible, then swap the non-volatile registers, then jmp eax/rax, rather than relying on ret to do it for you. This really helps the CPU to start fetching instructions sooner. If you want to support more CPUs, you can use a few more from my library: https://gitlab.com/higan/higan/tree/master/libco (higan is GPLv3, but libco specifically is public domain, or if you don't believe code can be PD, then ISC.) (Tencent stole the name of my library, but mine existed for years before theirs.)
With RAII 99% of my "error handling" looks like this: canFail1(); canFail2(); canFail3();
What are the difference to [Boost Context](https://www.boost.org/doc/libs/1_69_0/libs/context/doc/html/index.html) (or a [version taken out of Boost](https://github.com/septag/deboost.context))? Regarding Debuggers (mentioned as a problem in the README): it was very useful to have support for Valgrind and Address Sanitizer to be able to debug other problems without the Sanitizer crashing because of not knowing where the stack memory is located. Maybe [this code](https://github.com/felixguendling/ctx/blob/master/include/ctx/impl/operation.h#L51-L74) (Sanitizer) and [this code](https://github.com/felixguendling/ctx/blob/master/include/ctx/stack_manager.h#L55) (Valgrind) helps. Didn't have time to write a README for our library (and obviously there are good alternatives in Boost) but maybe someone is interested in reading the code [here](https://github.com/felixguendling/ctx).
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/ae2x8k/looking_for_a_c_ide_for_ios/ednzf5d/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Thanks Nial. But is this not where std::error\_condition equivalence to std::error\_code, "enters the scene"?
Thanks for this info. Unfortunately one does not have time to read all the things necessary to understand what is exactly going on in this "drama" 
I downvoted it because `return 0;` is auto-generated by the compiler and adds no value to the lesson. You can introduce it when you introduce functions – “Like functions, the main() also returns, usually 0 on success.” There, done.
Did you meant "non-exception panacea", instead of "placebo"?
Consider the cost of letting people do that manually. Some costs are worth paying.
I missed the extra overloads. Would need volatile maybe to dispatch wrong.
Went through it (i skipped all the example projects i didn't feel like writing so much code), in general everything seems simple and the progression makes sens, pretty good start. * the missing return 0, just seems like bad style to have the int main function not returning an int. Which brings me to the next point: * "\n" vs std::endl; there's a bit of a debate about it but i'd probably go with std::endl; just something you might want to think about. * I'd probably go with std::sqrt() over sqrt when you're already using cmath and adding std::pow() might be a nice addition, cmath would actually be there for a reason (afaik sqrt is not from cmath, std::sqrt is) * Quiz x = false; doesn't have to be a bool and might cause unexpected behavior e.g. if x is a integer. I'd say it's really important to know that just because you assign an value it doesn't have to be the right type. int i = false; // works just fine * using namespace std; It's complicated but important to introduce, i'd probably say you can make an extra module just for "using" maybe after you introduced a few other std functions or types (vector and sort maybe?) using namespace std; using std::cout; using Numbers = std::vector&lt;int&gt;; There might be some details i missed and i got pretty annoyed by the site that asked me every 5 seconds to upgrade to pro and start my 7 day trial... god i that annoying. A skip button would be nice to, couldn't look at some things because i couldn't be bothered to write the code.
well if it is advertisement it's pretty shitty trying to sell a basic programming course to the in general very advanced users in r/cpp
wait i pay for exceptions if i don't use them?
&gt; Should I include `return 0;` in the very first lesson? You do not need to return from `main` and the program is still be a well-formed. (`main` is the only function that returns a value for which this is true.) If you do decide to keep the return expression, I would suggest using [EXIT_SUCCESS](https://en.cppreference.com/w/c/program/EXIT_status) as it is considerably easier to read than an integer value.
Thank you for your useful comments. This library is intended to be used as a building block, so I just provide the essentials to do that. I will look into your code!
Or boost fibers. I just started using Facebook folly fibers as well.
I'm missing something. You're suggesting that by putting "using \[classname\]" I don't have declare constructors, et al in a derived class? That seems way too easy....
&gt; This is also a pretty easy thing to unlearn once you get to explaining namespace I don't think that learning something with the intent to unlearn it later is a particularly good idea
My library is just very bare bones, which I consider a feature. This allows you to tailor your high level abstraction to your usecase. Thank you for the links, looks interesting!
I won't even discuss GC languages for hard real time systems. The problem is, if you're using `-fno-exceptions` you are technically not writing C++, so hard real time systems have even less options. C and assembly.
Is this SO or something where you downvote everything? Jesus.
Hmm.. I meant, these build tools don't "understand" CMake, or can parse or write it. So someone "hard-coded" into qmake/b2 which lines they basically have to write to a \`config.cmake\` file so that CMake can understand it? I don't know how to better describe it... but don't worry, it's not really important - I was just curious to know. :-)
I don't understand how your mind works
Cget will compile boost with b2 using your cmake toolchain with `cget install -X boost`. Or you can just grab the cmake file used [here](https://github.com/pfultz2/cget/blob/master/cget/cmake/boost.cmake), rename it to `CMakeLists.txt`, and put it at the top of boost source tree.
&gt; If you have an uncaught exception it will just immediately exit the application. Even if you catch it you have no call stack for what caused the issue. `catch throw`
I actually started work on cmake over a year ago. I create boost cmake modules to help with the infrastructure [here](https://github.com/boost-cmake/bcm). Also, I had created a version of boost with cmake implemented [here](https://github.com/boost-cmake/boost) including support for `find_package`, pkg-config, and tests. Of course, this past year, I got busy with a new project at work and haven't been able to dedicate much time to it. I am starting back work on updating and hopefully get a newer version of boost building with cmake(in fact I just merged in some new changes to BCM today). I hope to get a formal review for BCM and then we can start updating projects to use these new cmake modules.
Alot of those issues he mentions are based on very low level exceptions like bad allocations. I've never gotten a bad allocation that didn't result in quitin time. It seems like a lot of work to ignore any positives for exceptions and to magnify what are often rare downsides. You'd be better of going to C or Rust than taking this road. 
Yes, this is the philosophy of languages like Python and Ruby, but famously not C++, which is the the context of the original quote above
Thanks. I'll give it a try when I get the chance. I have to say however: That cmake file kind of makes my point.
I'm not them, but as a recovering Java programmer, I'm accustomed to basically *every* exception producing a stack trace with line numbers of *every single frame* in the stack trace, along with a heap-allocated message of arbitrary length. There are almost no situations where you don't get that from an exception. When you're used to that convenience, moving to C++ "feels" like a step backwards. Of course this isn't possible for C++ since it's fundamentally incompatible with several of C++'s design goals. There are a lot of things about the development experience that can be made more pleasant if your language design chooses to prefer convenience over performance and robustness.
When teaching a complicated subject to beginners, it is best to avoid special cases and exceptions to general rules. If possible, avoid the special cases and postpone discussion of exceptions to general rules until after beginners are comfortable with general cases. It is also best to postpone discussion of distracting details. The special rules about main() (that it must have a return type, which must be int, that, even though it has a return type, it need not have a return statement, that if it doesn't have a return statement the system will provide a returned value) are all minor not-first-day-of-learning issues. The fact that OS's expect programs to return zero to indicate success and non-zero to indicate errors is a distracting detail that is also unworthy of mentioning in a first class in C++ programming. In keeping with the best teaching practices, it would be best to not have to mention any of these special rules/exceptions or distracting details to beginners. Unfortunately, main() is the one function that every program must contain. In order to not have to mention any of the special rules, you will need to have your example main() return a value and if you return zero, you will need to explain the semantics of that value. So I agree with MontagFTB. Ending your program with return EXIT_SUCCESS; // Tell OS we were successful. and the explanation that we need to signal to the OS that our application executed successfully, minimizes the distractions and avoid a lot of explanations that are simply not important to beginners. What MontagFTB didn't point out is that you will also need to have #include &lt;cstdlib&gt; because EXIT_SUCCESS is defined in cstdlib. Note that there is hope for this situation. It is possible that future standards will allow main() to return void, which will significantly simplify "hello world" level instruction. 
Please use more descriptive titles for your posts.
The only reason it wasn't in C++03 was because C++03 doesn't know about threads at all. Compilers (for platforms with threads) certainly did the synchronization long before C++11.
This is somewhat advertisement-ish, but I'm going to allow it, on the grounds that it's sparking useful discussion. However, the usual guidelines about self-promotion stand - posts that are purely "go buy this thing" are not creating discussion and will be removed, and similarly for repeated self-promotion from accounts that do nothing else. As long as people are being good kitties and helping the C++ community grow, we can take a permissive stance.
Unfortunately, the Linux kernel will always be written in C for the two simple facts of: 1. Linus hates C++ and thinks it encourages bad practices 2. Linux has to be compiled on thousands of platforms and architectures, many of which do not have a good C++ compiler. And C being a simpler language is much easier to port/write a compiler for.
What's wrong with using C++ with -fno-exceptions? It's very common. I don't think it matters if it's technically C++ or not. There are a ton of useful language features you can still use.
Consider that the compiler will do a better job at initializing static variables than people. Remember the way it used to be done in 98? It was painful, error prone and inefficient. I fully adhere to C++ principles but pragmatism is nice sometime. Now exceptions and rtii are a total different game as we can achieve the same result at smaller cost, hopefully in the next decade.
That may well be true, but: what are you basing it off? His email from 25 years ago that people advocating C over C++ love to link? I seem to recall that someone mentioned a project he did in his spare time that used C++ (Subsurface). I also don't understand how 2 and your final statement can both be correct. You write that the kernel will only ever work with gcc (which supports C++), and at the same time you right that it gets compiled for platforms/architectures that do not have a C++ compiler, and that C is an easier language to write a compiler for. How exactly are all these points are compatible?
It's an example of an [inheriting constructor](https://en.cppreference.com/w/cpp/language/using_declaration), introduced in C++11. It's equivalent to a constructor with the the same parameters that forwards those parameters to the base class. Essentially only the base subobject is initialized, and all other members/bases are default initialized.
Only one thing is wrong - it's not C++ any more. The standard currently forbids disabling exceptions and RTTI. So both `-fno-exceptions` and `-fno-rtti`, just like having UB in your code, means you are not writing C++. At least as far as standard is concerned, people turning off some potentially harmful features are actually writing an incompatible fork of the language.
To be honest, I'm not so sure about the point about GCC compatibility. I added it just after I commented, but it seems I might have been error. I seem to have been confused by the efforts in recent years to get the kernel to compile with Clang, which is more likely an issue with Clang than the kernel, now that I think about it.
I'm in the same boat as you. The last time I used C++ regularly, namespaces and templates were brand new and the standard was still years away. When I go into a C++ "tutorial" already knowing 3/4 of the material I think I'm safe in assuming it's a bad tutorial. One that I found pretty good so far is a course on Udemy: [https://www.udemy.com/beg-modern-cpp/](https://www.udemy.com/beg-modern-cpp/). It seems to be hitting what I've gathered are the big idea in writing "idiomatic" modern C++: RAII, proper copy/move semantics, proper use of std types and algorithms, lambdas, exceptions. My only real complaints is that, in a few cases, the course starts out by teaching you something mostly obsolete (how to use malloc, arrays) only to turn around and tell you to use the modern way (RAII, vectors) instead. I presume the teacher wanted to contrast "modern" C++ with "old" C++ but IMO for a beginner course that seems distracting. Otherwise, though, it's been pretty educational.
But why the stack-trace? I see no use of a stack-trace when an exception is thrown. Those are for programming errors, and exceptions should not be used for that.
That’s a good point. As I mentioned, I’m not a game dev so I really have no idea how much code reuse is possible if you switch engines. But Unity seems to be trying to make the case you should write everything in the modified C#, guaranteeing lock in
I disagree. They create another path through code, but that has nothing to do with spaghetti-code. In by far the most cases, whether or not your code follows an exceptional path or not should have no consequences for the code you write. Unless, of course your ressources are not protected by RAII, but in that case your code will already be spaghetti. 
I don't recall Visual C++ doing it. That's a platform with threads. Both in the OS and supported by the Microsoft runtime library.
The number of developers I've worked with over the past 20 years who have amazing understanding of the language and it's standards, but very little understanding of the ecosystems their code runs in is very high. Teaching from the beginning how your application interacts with the Operating System should be fundamental. &amp;#x200B; This is a variable, it can be stored on the stack or heap by doing X; the pros and cons are Y; memory is handled through Z design. There are primitive and complex types; e.g. ABC. This is the main function, it interacts with the operating system through Z processes. The concepts are not that difficult. 
Range-v3 thinks that your class \`S\` is a View so it assumes that copy and move are both cheap. If you add in \`const\`-qualified \`begin()\` and \`end()\` then it no longer thinks \`S\` is a View and you will no longer get any copies in the lvalue case (i.e. it will store a reference internally). However, then the rvalue case will not compile as range-v3 doesn't allow creating Views from non-View rvalues.
I thought CPS is for usage requirements like pkg-config, not for package/dependency management.
I'm no Haskell expert, but I would have thought the vast, vast majority of Haskell code uses `Either a b` / `EitherT m a b` (or some analog) with monadic handling eliding the annoying `if` / pattern-matching required. To my mind, this is the error handling system that has the fewest drawbacks as well: * You cannot ignore errors (like pure return codes) as they are encoded in the type * Monadic handling cuts down on the large amounts of boilerplate usually associated with checking returns * It is explicit in the type system, whereas exceptions are "hidden" It is also usable in things like asynchronous contexts, where exceptions become extremely problematic. I'm glad C++ will get something similar to this in `Outcome` / `std::expected`, although I haven't checked to see if these both still have some monadic interface akin to `map` and `flatmap / bind`. 
Just what I've been looking for.
So you just keep calling the next function, and every function is effectively noreturn?
The third version is buggy as it calls the same function 3 times.
&gt; That implies some synchronization, at cost Not always. Mostly for complex non-constexpr types.
Yes, in two ways: First, the tables used to unwind the call stack take quite a bit of space in your binary. This is probably fine on a desktop machine with plenty of disk space where binaries are demand-paged in, but annoying in more constrained situations. Second, the control flow used to run destructors constrains the optimizer and complicates control flow. This one can be mitigated by marking things as `noexcept`, so the compiler can tell where exceptions *can't* be thrown and skip the necessary glue.
Potentially. Alternatively, in an imperative language, they'd all return eventually - just not with a value.
It shouldn't figure here. Simply return `make_error_code(std::errc::whatever)` from your error code returning function. Internally, yes error condition is asked to do the conversion, but you shouldn't need to consider any of that.
If it solves your problem well it seems like a good choice to ignore if something can technically be called something and just use it. Every major C++ compiler supports no-exceptions. It's a real, genuine, quality tool with widespread support.
The difference is very poorly documented, but in a nutshell, error codes have literal comparison to error codes, and error conditions have literal comparison to error conditions. However error codes have *semantic* comparison to error conditions. That's the difference. Now don't get me started on how broken that design is in the real world (see https://wg21.link/P1028), but in theory it looks clean - it appears to separate the two concerns, though no audit of any code will tell you whether literal or semantic comparison is in operation without digging into the types of comparators. Plus semantic comparison has non-guaranteed complexity, which sucks. The design survived a Boost peer review just fine, and has been in Boost since 2009 or so. It's very well understood over there. So naturally the committee also felt it looked fine, and it entered the C++ standard without much thought at the time, as it seemed a relatively minor feature relative to other things. It's only more recently, as error codes have become much more popular, have the design shortcomings become more apparent, especially as non-Boost developers have started using it and have, quite rightly, become very confused. Some of the brokenness is proposed to be fixed in C++ 20, and maybe P1028 which is far harder to misuse accidentally may replace the whole thing one day. In the meantime, once you wrap your head around it, it is serviceable, it does do the job, and there are far worse things in the standard library than `&lt;system_error&gt;` e.g. `std::vector`, allocators, thread local storage etc.
No one said otherwise. 
Unless you disable them in your compiler you pay for them. 
Sure, but things are the way they are usually for good reason. A lot of the time it is simply age and hindsight. What seemed a great design twenty years ago turned out was not (e.g. error code), or a great design became a terrible design due to hardware evolution (unordered maps especially). Much of the rest is simply because the committee, like any org, just has to ship something even if not fully baked or else it'll ship nothing (variant being the classic example). Finally, error handling is hard. The C committee hasn't reached a perfect answer yet, so C lacks any error handling. It's not that they don't fully intend to implement a standard error handling into C one day. But it'll be when it's ready. The work on that has already spanned forty years. The lead dev on it is long retired, but still attends meetings. He's well old. But he's still committed to getting the design finished before he dies. And that's the alternative to shipping four standard ways of doing error handling. If you wait for the ultimate design, then you get no standard error handling, like in C. I know which I'd prefer, and it's what C++ has chosen. You may of course disagree.
&gt; just say it's necessary. Wait, what? Are we talkng about `main()` Because if we are [it's absolutely not.](https://en.cppreference.com/w/cpp/language/main_function). The standard says that if the end of `main` is reached, then 0 is automatically returned. 
C++ is a bloated mess now with no clear future in sight... it desperately need big corporations governance (the best would be Apple, Google, Microsoft together with the Linux and Game industry foundation) and money to establish a clear path going forward in terms of features and syntax clarity... Its beyond retarded the way its still do things today in 2019 compared modern languages... C++ as become a very old dinosaur who's still very important but as improved with napkin ideas all over the place that guy with that guy and that girl idea etc (you get the idea) without any standard or clear path on establishing things... NOBODY LIKE THE STL in the game industry nobody.. they all create their own silo of code each company... The best example of a extremely powerful modern language which evolved correctly is C#... but C# will never be C++ so we need to create (the whole computer industry not just 1 company all of them with all the programmer in a conference or something) a modern C++ who can do EVERYTHING database, webdev, games, desktop program, mobile etc etc WITH CLEAR EASY SYNTAX like C# etc Imagine a language who can create anything in any programming fields with the native performance of a C++ and with time you would add functionality to that language by adding module at the top like #include &lt;webdev&gt;, #include &lt;react&gt;, #include &lt;database&gt;, #include &lt;desktop&gt; etc etc theses modules would include everything a guy need to program the web or database or you get the idea ? instead of changing the syntax all the time but the key is to make the language easy to learn and use like C# BUT with a section we could call UNSAFE or NATIVE and then manipulate memory by hands etc The compiler job (Visual Studio or another) would be to compile for the platform you target so the specific paradigm of that platform would be included in the compiler itself no in the language syntax etc BUT THE FEW NERDS who take care of things love to re-invent the wheel all the time and love to feel elitist about programming so they create over-complexity over complexity etc just look at C++ now compared to plain old C and you will understand... a 12 years old girl who knows nothing about computer should be able to start reading the most complicated and powerful programming language in the world without having the knowledge and aptitude of a John Carmack to become a programmer and it should be easy that would be the best programming language 
It also works for overloaded virtual member functions when you only want to override one of them in some derived instance but still want the others to be callable from your derived instance without having to explicitly call the base version(s).
Neat! I'll give it a try!
Out of curiousity what are some of the common annoyances? I’ve really loved `std::expected`, and given the biggest pain point is eliminated by `?` I’m surprised that there are widespread complaints about Rust’s Result.
&gt; Just don't do `using namespace std;` I concur, although it might be reasonable to show them early on the ability to do something like using string = std::string; using vecstr = std::vector&lt;string&gt;; To a beginner the constant typing of `std::` feels like a pointless burden, especially if you're not an experienced touch-typist. But learning that they can alias long names helps with that quite a bit. 
No doubt you have not used it. But if you have, you did not do it properly. I can write as clean C++ as I can write clean code in many other languages. I'd dare to say that I can approach the tidiness of Python in C++17. But you know the difference between it and C++? Yes, you guessed right, it is second-to-none in runtime performance. I can code high level in C++, but when I need to squeeze the last drop out of it I have a ton of libraries for GPU acceleration, for SIMD, for fast Algebra (Eigen for example) that are very effective. Sure C++ is not perfect (initialization is the biggest mess C++ has in my opinion), but it is amazing the run-timer performance you can get with it without even going low-level. &amp;#x200B; &amp;#x200B;
Nah, its just like how Gentoo people had this placebo of disabling ccache
Interesting. I tried const qualifying `begin()` and `end()`, but I am still seeing the same behavior. Do I need to wrap up the object in some kind of a View class?
Be sure to use a name already used for high profile other things, guaranteeing that nobody will be able to find it
I think well applied logic and print statements are all you need in any language 
Maybe. Are most people now fast typists? I mean the internet generation? Doesn't everyone type? (Although code typing is definitely somewhat different)
yes its the most powerful and fastest programming language in the world but they need to simplify it with general standard like they did with C# for everything that is normal or common sense like initialization, syntax etc and you could use a word like UNSAFE or NATIVE to go low level with pointers Do you think its normal that it change so much since C++ 98 ? (it is not)
While that kind of pedantry is of interest to enthusiastic C++ developers with some experience under their belt, it would just confuse newer developers. The exception (pun not intended) can be taught as a random aside after the students gain some experience.
Stack traces help with debugging. If you have an uncaught exception, that may be regarded as a programming oversight, but who cares? It needs to be addressed either by fixing the input or fixing the program, and even reproducing the problem can be hard without context such as a stack trace.
as N approaches infinity, the big-oh tells the story of speed. Before that, though, benchmarking is what tells the story.
Sorry, here's a link: [https://wandbox.org/permlink/6APfi8A4hv6Ul96A](https://wandbox.org/permlink/6APfi8A4hv6Ul96A) (you need both const-qualified and not).
noexcept does not mean won't throw exceptions. If an exception is thrown the compiler needs to make sure std::terminate is called. So it's not the optimization panacea people expect it to be.
Thanks for posting this. I try to directly adhere to RAII and I thought maybe I was doing it wrong because I don't need try catch's all over the place.
From a developer point of view, you are totally right. That *is* what ~50% of the C++ developers have been doing. On the other hand, from the committee's point of view, it means there's something seriously wrong with exceptions since exceptions managed to split the community right down the middle. There's also the minor fact that "no exceptions" is implemented vastly different across compilers. And there's one or two papers concerned with freestanding codebases that are trying to define what "no exceptions" means.
1) What is your name? 2) What is your quest? 3) What is the average air-speed velocity of an unladen swallow?
Well i guess i'd have to range the question from simple to mid range to very deep. * simple questions about vector and algorithm, should show some familiarity with the STL, maybe a lambda and sort depending on the minimum knowledge i need. * Some optimization question, manual memory management RAII. How to implement a class that uses move semantics would probably be a decent question. I'd say doing that stuff properly shows pretty decent C++ knowledge. * Some questions i wouldn't know to proof they know the standard in and out. Something similar to the constructor post (https://mikelui.io/2019/01/03/seriously-bonkers.html) a few days ago. Somebody who can tell me right away that an empty list calls the default value constructor and not the list constructor clearly knows his C++. but with the last question i'm trying to find people that know a lot more than i do. And i find it really hard to estimate my own C++ knowledge, there's always some details i miss so i'm probably not qualified enough to find people with really deep C++ knowledge. 
&gt; There is nothing called "&lt;system\_error&gt;" in the standard, so I'm not sure what you're talking about, but I'd guess std::system_error? I'm pretty sure the backslash was just therre as an attempt to escape the underscore and that they were referring to the `system_error` header. People have been doing this accidentally ever since reddit introduced the rich comment editor with the redesign.
African or European swallow?
How well do you know C++? 
You can get a stack trace, but you need a debugger to get it, as [this talk](https://youtu.be/_Ivd3qzgT7U?t=915) demonstrates. And I really hate the way Java treats exceptions. The only Java app I regularly use is Fop, and any minor (or even imagined) error condition immediately results in page after page of exception information scrolling over my screen. What am I as a user supposed to do with all this completely meaningless information? It's part of a school of thought that I think quite a few people in this thread get wrong as well: exceptions are not a fancy method to abort, they are intended to let your application recover. That means they shouldn't be dumping pages of internals to the console, 'just in case someone cares'. If you need that information, you use a debugger to obtain it - same as for every other internal bit of the software that you wish to inspect. Plus, people already complain about the overhead of exceptions, even though measurements show it is generally faster than returning error codes. Imagine what they would say if every stack frame automatically included a heap allocation...
Explain the difference between an R-value reference and an L-value reference/ask them about move semantics
gcc-4.8.5 is RedHat 7 default. Not sure about gdb.
Yeah, that's probably not gonna cut it. I've had people for interviews who claimed 'expert level' C++ and were unable to explain what a shared pointer is. And I don't mean the intricate details. I mean shrugging when I ask for shared pointers, obviously not having heard the term. 
1. Why must you be cautious when using .push\_back on vectors? 2. Using the \[\] operator on a map can be bad, why? 3. Explain the difference between a struct, class and template. When would you use each? 4. What is your preferred mechanism for error handling and reporting? What are the pros and cons to this approach? 5. How do you ensure an object is placed on the heap? 6. What is the meaning of 'const' in the method definition void do\_something() const; 7. Show how you would do basic template specialisation
`thread_local` requires a separate allocation for every (library, thread) pair. Then think about how you can `dlopen` libraries, and threads get created and destroyed all the time. There are no good solutions, only creative ones.
I’m no expert, but I would ask a question involving undefined behavior, one involving templates, and one involving r-values (and maybe template deduction involving T&amp;&amp;).
Gcc did it msvc (iirc) not.
That doesn't make 4.8 any less obsolete.
The important part is that this happens on the callee side, so it should have any influence on the possible optimizations on the caller side.
As the sibling comment says, the optimization is in the caller, not the callee. Without `noexcept`, the compiler has to assume that any function call might throw an exception. On the other hand, any call to a `noexcept` function *cannot* throw an exception specifically because it will `std::terminate` instead. Spread this through enough of your callstack and that's the benefit people talk about.
With 7 I'd even dig a bit into class and function specialisation, and dig into the bads of template function specialisation. 
Could you answer the first two questions? I don't have a clue about the first one. Maybe because it causes a copy and you should use emplace_back instead? The second one, can it be related to [] creating the element if it doesn't exist?
Sure, but please teach the easy to use stuff (which should also be your default tools most of the time) first and only later, what's going on under the hood. Not the other way round. That "let's first teach assembler, then c, then c++98 (stop using malloc - use new), then the stl (stop using new for dynamic arrays, use vector), then c++11 (stop using delete use smart pointers) and if anyone hasn't switched to a completely different language by now, maybe we are telling him about c++14 (stop using new, use make_unique) ... " attitude , is a didactic nightmare.
1. What's wrong with vector&lt;bool&gt;? 2. How can you break the one definition rule? 3. How many pages are in ISO/IEC 14882:2017?
I like that #3 is a trick question, since the only difference between `struct` and `class` is default visibility.
Sure. 1. Vectors must have their memory allocated contiguously. So if you do a push\_back and it's unable to get a block of memory at the end of the current block it will re-allocate an entirely new block and transfer everything. Therefore adding 1 element to a vector can cause a re-allocation of the entire vector. You can work around this by using .reserve() to allocate in chunks or the entire amount if it's pre-known. 2. Yes Using \[\] adds the element if it exists. So while you think it's a lookup, it can cause a memory allocation which is very expensive operation. So you could only use \[\] for storing elements, but use find() if checking for presence. \[\] cannot be used on a const map either. 
Yep agree. I'd even ask the difference between a virtual function and pure virtual function. What do the keywords override and final mean.
If you don't comce from a different language, where everything is a reference/pointer, accidential slicing is actually a very rare problem. Nothing you have to worry about when you start to teach inheritance and polymorphism. Also your example about keeping references into a vector: Sure, iterator invalidation is a topic that needs to be mentioned at some point, but it just isn't a common enough issue to waist brain capacity on when students are still learning the basics of the language and making their first 100 line program. C++ experts are so great at yak shaving that they completely loose perspective of what is important for someone just starting to learn the language (especially, if you want to keep them motivated). 
That sounds... counterproductive. I hope this is not the case anymore, whoever this was. No one can deny that CMake has become the de-facto standard build (generator) system for C++ code, and that not supporting it is a terrible mistake.
From a language standpoint yes. From a usage standpoint there is a long standing principle that you use structs to represent data structures while a class is an object with methods. So you don't put any methods on the struct, only members. While a class can have both. Again, this isn't a language thing; but a very common practice (everywhere I've ever worked in the last 20 years)
&gt;2. Yes Using [] adds the element if it exists. Do you mean, if it does NOT exist?
Yes. Edited the fix. Thanks :)
Winning! :)
On a scale of one to ten, what do you rate yourself? What is something you know that you wouldn't expect someone (n-1) level to know?
Is it bad that I can answer all those questions, but I've never written anything in C++?
...I don't know that...
1. I can see some benefit in, but it really is a specialist piece of knowledge. Something only a very very few people would know who have encountered it. I mean storing bool in a vector feels bad; such a waste of memory. 2. I don't think has any bearing on someones ability to deliver C++ code as an employee (what I assume OP is asking regarding) 3. This would be a negative for me. People who have such a thorough understanding of the specification do not often have much appreciation for how C++ is used in the real world. They almost become "purists". I've worked and managed people who fit this criteria, they were average employees at best. 
FYI make_ context and swapcontext have been available officially in POSIX since 2001 at least
100% agree. Having interviewed many developers people who claim to be experts very seldom are.
I'm vaguely interested to see what people come up with here, but I don't like the spirit of this kind of thing if it's meant for an interview. If you don't know C++, you shouldn't be asking them about C++. If you do know it, then you should be able to come up with appropriate questions.
Do you know other languages? I mean I would expect someone who can answer all 7 to have fundamental skills in at least half a dozen languages. C# and Java should appear in that list.
Yeah, but I know the answers because I've read C++ primer and a few other C++ books... I've just never found a project to do in C++, so I've never actually written anything with it. One day...........
But then people add a method to a struct they never change it to class and sometimes justify that it is just a helper method and does not really change semantics so you end up with a ton of in-between stuff. Personally due to this and forward declaration mismatches being bad for msvc I lean over to 'everything is a class' or 'everything is a struct' approach more and more. 
Almost always struct everywhere!
I do not disagree with you here. The question is if we want a stack-trace as part of release build? That would be a burden on performance. If you experience problems like that, my recommendation would be to examine the cause of the exception. If this is not obvious from the data you have, this is a case for running the debugger.
Aliases make some things easier to type but much harder to read, so this is not good for anyone who has to grade assignments and try to give useful feedback to students. The possibility of multiple aliases for the same thing and multiple choices for name aliases makes it a nuisance.
Practical experience counts for a lot. When interviewing people I always ask to see samples of their code.
What's the answer to the first question?
Oop's! I would rather they'd say that that's not needed.
Yep. This is why you formally adopt a style guide and implement automated checks for code that violates it as part of the source code commit hook. 
Yeah, that's kind of the danger of simply asking theory, because I could answer lots of questions, but doubt I could write much code without tons of help from the IDE.
It uses bits instead of bytes :)
How deep is your C++ knowledge?
as far as I know vector&lt;bool&gt; is specialized so bool's are packed. This unfortunately also means that it behaves quite differently from all other vector's.
its great for overriding standard types. For example struct MyString : public std::string{ using std::string::string; } then I can declare my own &lt;&lt; operator without having to override the standard one for string (which one should never do) and I can still use it wherever I'd use a normal string
I think #4 would highlight the fact you haven't written code. Error handling and logging in C++ is something that is done many different ways; you'd need to have practical experience to truly understand the pros and cons.
I was recently asked to rate my C++ skills on a scale of 1 to 10. I ended up going with a 7, I know a fair bit but there's still a boatload of C++ that I have no idea of (e.g. I don't know any TMP beyond your basic SFINAE and CRTP). Then a little bit later I thought about it and realized I would have probably given myself a similar rating 4 years prior. At that time I knew a *lot* less about C++, but the set of things that I was aware of not knowing was also a lot smaller. I wonder how I will feel in 4 years. Maybe the set of things I know will continue to to grow at a similar rate as the set of things I am aware of not knowing, and I will be a perpetual 7.
This is true, those are more strategy based questions that don't get covered much in the books I've read, and it's not helped by C++'s disorganized way of doing error handling.
&gt;If you teach students to always type std:: (std::vector, std::cout, etc...) then you don't actually need to explain what namespaces are at all (you can introduce that later). I don't find this convincing. There is no avoiding namespaces, they are just a fundamental part of the language. Either you type `using namespace std;` not knowing what it is, or you type `std::` a bunch of times everywhere not knowing what it is. There's nothing wrong with `using namespace std;` for *instructional purposes*. The more stuff has to be typed, the less code can fit on a slide or whatever, and the less information content will be there. There may be industrial reasons to not do `using namespace std;`, but that is WAAAY beyond the concerns of someone who doesn't know what a namespace is.
And this is how it should be. I would answer much the same. In fact, some ears ago I was asked that very question and did give me a 7. And now I would probably go for something similar. (Perhaps even lower when I look at that line I just wrote when this response popped up ;-) Point is, when you start considering yourself to be an expert you pretty much stop learning and evolving. Which means your decline begins. When the disciple asked his master what to do when his struggle brought him to the top of the mountain, the only answer can be: You continue climbing.
Bwwaaaaaaaaaaaahhhhhhh.......
Nial, I need to have this in a place like "now". I might have figured out what to do, conceptually. Can I please bounce it off you, off-line?
The question is both specific enough and vague enough to have all the scale of right answers. "What's wrong" can be answered in multiple ways regarding on who's answering. * For some, the continuity relaxed and compatibility with bool\* respectively is wrong. * For others, it would be the performance of accessing by bit reference. * For some, the thread safety issues. * "Nothing" is also a right answer. It's just a specialization with its own trade offs. There's nothing wrong with that. The OP asked for questions to judge how deep one knows C++. This question can be answered correctly with any level of knowledge.
&gt; I'm wondering where your negative experience comes from. Let's say you accidentally try to dereference a nullptr. What you get in practice is a crash directly pointing at the problem (including a backtrace how you got there in the first place). Depending on the system and configuration, you get a core file which will allow you to do a post-mortem analysis of an issue which happens once or twice per year over a million installations. (Yes, this is not something the standard guarantees, but the practice even on most embedded systems) Now consider the same when you accidentally dereference an empty std::option (syntactially this looks the same as deferencing a nullptr). An exception will be thrown which will happily unwind the stack till some point where somebody was actually expecting an exception. Depending on where this point is, you have no chance to debug this problem if you cannot reproduce it easily. And even if you can reproduce it you have to put a breakpoint in the std lib (or patch it) or override cxa_throw...
To really assess someone's C++ knowledge, YOU have to be able to have a deep conversation about the language. Otherwise what you're asking here is a list of 3 questions to hand to your HR person.
As I understand there is a general consensus on the "way out" as suggested in: `P0709 R2`. Perhaps we "all" could follow (and support) `std::error`, in order to fast track the implementation finalization and use it "today" instead of `std::error_code` and friends. I would have no worries promoting `&lt;experimental\system_error2&gt;` if it would be "destined" by commitee, to be used. Before C++23, or whenever the 3 major compilers are ready.
I'm kinda the opposite - having worked on LLVM I'm now good at inferring what the compiler will do and what machine code will be generated for a given chunk of C++ code (optimizations and all), but I struggle with putting it into words. For interviews I practically have to rehearse the answers for the common questions.
You can't not use a feature because people might _deliberately_ misuse it. (Of course, features that encourage _accidental_ misuse are bad.) A structs, or specifically "plain old data", is really easy to reason about, really easy to share between compilation units, easy to fill for testing. It simply makes your life easier as a programmer.
I upvoted you, but I have yet to find any style checker than can warn you if you add methods to a `struct`!
&gt; Those are for programming errors, and exceptions should not be used for that. The standard library uses exceptions for that.
Say, what? Which part is "not needed"? Virtual functions, pure virtual, `override` or `final` - or just the whole concept of inheritance? All of these are essential to the language. Yes, I consider that inheritance and polymorphism are rather over-used, but when you need them, you need them.
What does the virtual keyword mean? What are the differences between a linked list and a vector? When would you prefer one vs the other? I cant think of a good third question off the top of my head.
To be pedantic, it's implementation-dependent as to how `vector&lt;bool&gt;` is implemented but yes, in practice all common implementations pack 8 booleans to a byte.
&gt; How many pages are in ISO/IEC 14882:2017? That last question is particularly dumb. Who cares? How would that ever help anyone do a good job writing a program? There are many reference materials I have read half a dozen times or more and I still have no idea how many pages there are in them, because it's _not important._
&gt; [One-definition rule] 2. I don't think has any bearing on someones ability to deliver C++ code as an employee Well, I think of it as somewhat marginal, but it is a real-world error, and one that's possible to make silently and have it lead to invisible errors (because it's possible in some cases to violate the ODR and not get caught by the compiler or linker), or certainly to obscure errors at compile or link time. So an advanced C++ programmer should know about the ODR. I agree with your other two points though.
&gt; On a scale of one to ten, what do you rate yourself? [Dunning-Kruger](https://rationalwiki.org/wiki/Dunning-Kruger_effect) says that actual experts will rate themselves too low this way, and incompetents too high. Of course, the next question you ask will help resolve that.
1) At which point to do you begin to experience horror and a feeling of a complete inadequacy of your C++ knowledge? a) Reading any C++ code b) Reading STL inner code c) Reading Boost inner code 2) Did you ever wake up at night to realize the memory corruption you've been debugging for past 3 days is caused by buffer overflow in a global static variable? Do you even understand any of these words? Was it your code that overflowed that buffer? 3) Can you think of 3 questions to judge how deep someone's C++ knowledge is?
I really feel like everyones answers relates to the things they know/understand themselves. But probably wouldn't be sure about the answers to other people questions. C++ is a massive beast and some people could have been using very advanced techniques and language features while being oblivious in regards to the others. Therefore perhaps a good question would be: What advanced/modern C++ features did you use and why? This will first give you an idea what do they consider advanced. Second it will tell you they were able to understand what the thing does and why. 
Well, I don't see how `class` with all public fields is harder to reason about or less "plain old data". In general class/struct difference is similar to a comment which may or may not reflect the real state of code around it.
&gt; At least, it's not evident how one can determine an adequate buffer size without invoking locale-dependent functions. Why would you use locale-dependent function to determine the size of a locale-independent result ? &amp;#x200B;
Well, yes, I agree that all feedback is good :) I just see the tone so negative in general, as if C++ was not getting anything right... that was my point.
Why would it be a tricky question? It is probably one of the simplest questions out there. It is asking what is the difference between class and struct. And the default visibility is the difference. Done. I feel like somone with genuine interest in the language should have known this. Not because it is actually useful but due to curiosity to know why people use struct and class seamingly interchangeably. 
idk about depth but my favorite "do they actually know C++ at all" question is: explain the difference between int a[N]; int *a = new int[N]; std::array&lt;int, N&gt; a; std::vector&lt;int&gt; a(N); 
FWIW I do not care whether it is "standard" or "not standard". At the end of the day it is a subset that has been working for years and lets me solve real problems that with other tools are difficult or impossible. I can still get templates, constexpr and a ton of useful features to do things properly. In C++ land you always need to know what you are doing. But when you know what to do, it can be a really powerful and versatile combination. I can write from high-level to down to the metal. With all its defects and asymmetries, I think this is the thing that sets C++ apart.
I would start with: Could you write a simple class B that inherits from a virtual class A?
Is it wrong that my first reaction to the first question is "which STL" ?
Again, the OP asked for the a questions to judge how deep the knowledge is. C++ knowledge != programming skills. The problem is, you can't really measure a huge amount of possible knowledge with just three questions. So you have to probe things that accompany the knowledge instead. The standard size is a popular theme in C++ discourse. Knowing the specific number is irrelevant to one's knowledge, but taking part in a global discourse is.
I had this problem. My solution was learning the etymology of the vocabulary of the thing I'm using, and imagine a world before it was invented and reinvent it as if I am the first person in the world to invent it. This pondering lets the etymology sink it and run over any holes I may have had I didn't know I had. I did this for 3 different things I was looking at in code a day, matching vocabulary to it. 300 vocabulary words later and I fee like I'm fluent in another language. As time consuming as it was to do all that, it was totally worth it. Now when I learn new concepts I remember the vocabulary from the get go. No more playing catch up for me.
No, it's a perfect reaction! Shows awareness and certain level of knowledge. Hired! Now, anyone claiming to be above c) is either a Boost contributor (which is easy to check), or, more likely, an impostor.
Dream on. I wouldn't judge answers based on whether they are using the same coding conventions as you or you friends.
&gt; This all happens "within" your throw statement, so the call stack still exists when backtrace runs. But throw is not generating any signal that you could intercept. Throw calls cxa_throw (or similar) which will already unwind the stack (and then it is already too late). You have to intercept cxa_throw to get a callstack for the exception, and even then you need a place where to put the callstack in case you need it at the catch handler. 
&gt;Did you ever wake up at night to realize the memory corruption you've been debugging for past 3 days is caused by buffer overflow in a global static variable? Do you even understand any of these words? Was it your code that overflowed that buffer? Oh god no. Is there a horror story attached to this?
Corner them in the bar and start reciting the code you're working on line by line. If they leave or try to change the topic they're obviously just not a rockstar coder like yourself 😎
That's because shared pointers are for communists. ^/jk
I know. This is not the only example of a bad design in the standard library. 
There is no such thing as a virtual class.
This is one of the reasons why open ended questions are asked. It lets them show their depth (and breadth) of knowledge starting from a relatively open place, instead of diving into a factoid.
Think you also need typ make a distinction between how well do you know c++ and how well can you solve a problem using c++ . I'm not a language lawyer that can vote the standard from memory, but I think there is little about c++ I don't know about (at least to the degree that I know when I have to look up the specifics before using it). That still doesn't make me an expert in writing large scale and maintainable c++ software and I know next to nothing about writing really high performance code (how to squeeze out the last bits of performance for a particular CPU.
This is an amalgamation of several stories, mostly. Once a co-worker allocated a static buffer for sound name in our sound system without checking the length of the written data, and the ensuing memory corruption took a while to dig out. Another time, we had a fun case of static global variables from two statically linked copies of Google's Protocol Buffers mess up library's initialization badly (one copy was ours, another was linked in by some iOS system framework without our knowledge).
`std::swallow&lt;&gt;::velocity::unladen;`
&gt; Why would you use locale-dependent function to determine the size of a locale-independent result ? I would rather not. Can you show code determining the required buffer size for `std::to_chars` of `double` with a precision supplied to that code, and fixed format? 
1. `extern int rating;` 2. How `extern` works.
&gt; How many pages are in ISO/IEC 14882:2017? More than 0, less than -1.
I really mean to learn, 'cause we're living in a world of fools breaking us down when they all should let us be. We belong to you and C (++).
And inheritance as well 
&gt;Another time, we had a fun case of static global variables from two statically linked copies of Google's Protocol Buffers mess up library's initialization badly (one copy was ours, another was linked in by some iOS system framework without our knowledge). Oh shoot. I didn't think of that. I've had that problem or a similar problem with protobufs too.
What's an int? . What's a std::vector?. The rest are 1500 pages of simple details... 
This comment is never gonna give you up, never gonna let you down, never gonna run around and desert you :(
It is not cross platform. I also does a lot more, saving fp-env and signal masks it not cheap, in many cases it's not necessary.
To be fair: I created the project in 2011 :-)
I am also curious about this. I started working on lot of graph algorithms and currently I use a vector of vector as datatstucture to hold the adjacency list mainly because I am not that good at manual memory management. I use a constructor to initialize the graph. 
Yeah, that was "fun" to debug and fix (we ended up changing namespace's name in our copy of protobufs to avoid the clash). Another fun time was when I literally hit "it's a compiler's fault" type of bug early in my career: some early GCC 3.x (don't remember the exact version) generated illegal opcode right in the middle of preparation to call a printf-like function with variable number of arguments. Spent days trying to get a reproduction (it was only in optimized version of the code, and was only triggered under certain circumstances), then some more time poring over -O3-generated code, trying to see what went wrong. Then, boom, I see "int 5" in disassembly. A privileged opcode that had absolutely no right to be there.
Because the answer will differ between language lawyers and people more interested in actual industry use (where conventions matter and sometimes strongly differ from the language advocates’ preferences).
**What is your personal preferred approach to writing C++? Tell me about how this preference arose and what the advantages of your approach are.** Everyone with experience and a decent level of skill has some preferred style of C++. For some people this means cutting edge C++ and metaprogramming, for others this means careful moderation and old-style constructs. None of these are wrong, and it would be stupid to throw away a candidate for not thinking modern C++ is amazing, **but** what is important is how they came to their decisions, and how they use the language to optimize for the specifics of their general domain. **Tell me in as much detail as you can about one specific thing that C++ makes dangerous, or otherwise just something that is dangerous in C++.** If you *really* know about the language, you know about its sharp edges. Everyone has different expertise, so while somebody might be able to tell you in depth about parallelizing large codebases, others might talk about writing generic code and ADL. This question can be followed up to expand on the answer quite easily, I would imagine. **You mentioned you have expertise in &lt;area&gt;. Can you explain to me how &lt;aspect&gt; works in C++? (I can choose something else if that would be better for you.)** Choosing random puzzles is silly. Not everyone knows `std::map`'s emplacement methods off-by-heart, not everyone knows the minutia of `&lt;random&gt;`, but every expert has *some* area of expertise. Ask them about it.
Good old pointers for me. Can't say I've really had the need for anything else though, but maybe there's a way to screw up with such structures I've not anticipated.
Oh man. That's like a more painful version of something similar I had early on as a dev. The text editor on OSX used smart quotes. This would cause a a buffer overflow in the Perl interpreter.
Technically it is of course correct stating the difference between struct and class is just the default visibility. What one could add is that many projects / companies have conventions to use the keyword 'struct' when you simply want to aggregate some data types without adding functions. So adding "there may be conventions in projects to express a certain intent" could be added here, showing that you have more background than just the technical difference. :-)
If shared_ptr (or similar) is not needed to implement the data structure, then it should not be used. Period. Use raw or unique_ptr instead.
That’s a fundamental problem with all the ”How well do you know X?” questions. In real world the meaningful question is ”How well can you solve relevant problems using X?”. It’s easier to ask about the first but what you almost always want is the second.
How often do you use raw pointers? More than 0? ... oh sorry, we're not interested
It depends on the actual use case, but "probably raw pointers" is the answer for me on most cases.
&gt; taking part in a global discourse is. What? No. Reliable, performant engineering is not achieved by memorizing irrelevant trivia or being in some in-group. You might as well test meme familiarity. On the contrary, I could make a good case that there was a correlation between "knowing how many pages the standard has" and "a tendency to over-engineering".
1) What's wrong with Java? 2) What do you wish C++ had? Follow-up: How would you go about implementing it. 3) What do you wish C++ didn't have? Follow-up: How could you prevent people in your organization from using it.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/aei1lb/any_good_solution_to_solve_exercise_in_book/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Generally, I like to let people ramble about high-level, open-ended concepts and see how much detail I can get them into. "Talk to me about C++ containers!" "...about threads and thread-safety!" "... about constructors, initializers and destructions!" And then I can dig in - for the last one: "What's uniform initialization? What about global static variables - how are they created and destroyed? What alternatives are there to global static variables? How does a shared pointer get created and when does it get destroyed? What's a virtual destructor and when do you use it?" 
 `precision + 3 +` [`std::numeric_limits`](http://en.cppreference.com/w/cpp/types/numeric_limits)`&lt;double&gt;::max_exponent10` should do the trick for the maximum size. If you want to allocate depending on the value, `precision+3+trunc(log10(abs(number)))` with the appropriate special cases for NaN, \[-\]Infinity and 0.
Have you ever interacted with a C-Library?
I would say that the thing to keep in mind is not in the allocation/copying around (which of course can be), but in the invalidation of references/pointers to the data in that vector. And this behavior is *really* different from most managed languages.
If you're implementing a data structure it'll probably be raw pointers - but it depends entirely on the use case. Consider unique\_ptr for forward links as it will implement most destruction for you, so you don't have to worry about writing a lot of that yourself. Back links pretty much have to be raw (or weak). If you want to be able to keep persistent references to parts of a list/tree, or are implementing a multi-threaded safe structure, you might need shared\_ptr.
Not visibility. Access. The names are "visible" - they are found by name lookup. You just can't use them.
shared_ptr as a first pass. If the performance of shared_ptr becomes a problem, chances are you need a different kind of datastructure (in the case of linkedlist) or something backed by a vector (in the case of graph or tree).
For me, `std::unique_ptr` if possible. You might be interested in Herb Sutter's talk [Leak-Freedom in C++... By Default](https://www.youtube.com/watch?v=JfmTagWcqoE) which is exactly about this topic.
I'm saving this. One question I've always meant to ask if I ever interview someone is, "**an OS call is made, something like fopen/ReadFile. Describe what happens in as much detail as you can.**"
`reserve` directly to the final size is fine. `reserve` in chunks can easily lead to quadratic behavior if you are not careful.
&gt; `precision+3+trunc(log10(abs(number)))` That seems to do it in general, but it requires testing for 0, and possibly also testing for NaN and Infinite, if the floating point representation supports those, and computing a logarithm. I would add 1 to that just in case the logarithm disagrees infinitesimally with the `std::to_chars` logic. Any slight deviation can give an off-by-one result from `trunc`. For example, one way that `log10` could be implemented internally is ln(x)/ln(10). And that not-quite-trustable DIY expression demonstrates, in my opinion, that the buffer size computation should be part of the `to_chars` function family. It can also do things such as knowing how many digits after an `E`, and how large the representation of Infinity or NaN. It would give far more robust, trustable client code. 
Fair enough. 
[Virtual Class](https://en.m.wikipedia.org/wiki/Virtual_class?wprov=sfla1)
huh I thought the first one was emplace_back vs push_back 
God damn, these are legitimately good questions.
I did some micro benchmarks on the Boost graph library and found its quite speedy. But I ended up storing my data in a compressed sparse row data structure since I needed to use some SIMD instructions.
**owning** raw pointer. Non owning raw pointer are good. 
Some open ended questions that are more about genereal C++ knowledge... 1. What are some best practices for managing header files? What kind of things should you put in them. What kind of things should you not put in them? 2. What is you philosophy on initialization? When do you use constructor/destructor vs iitializer list vs brace or equals initializer. Also you probably want a question that shows they have some practical experience. 3. What is you favorite editor/IDE and why? What libraries have you used regularly? What did you use them for? What other tools are a must for working with C++? 
A quote from the c++ standard or cppreference would be more convincing. C++ has classes with virtual members, it has abstract classes and you can have virtual inheritance from a class, but I'm pretty sure there is no construct called "virtual class" in c++.
&gt; counterdesign papers are coming to the next WG14 meeting Interesting. Are they very significant, or will compromise be likely?
&gt; Where is the perfect place to introduce `using namespace std;`? &gt; Don't. It's considered bad practice. I've seen this a lot, I'm not convinced. I would agree if there would be a C++ version of `from std import vector, tuple, optional, string`. Even more so for beginners, why force them to keep typing and reading `std::`, the important part is the `vector`.
It's probably best not to take it personally. Up/downvotes are us much about bubbling good information to the top and bad information to the bottom as much as anything - not attacking you the author of the comment.
Why is it different inside a vector than if using a book outside a vector? Why not give us bit-bools everywhere? 
More like - unless you're using standard library compiled with disabled exception, and then compile you project with disabled exception, you're paying for them.
This is exactly my point. If they say they are an expert, then they’re not :)
I believe Bjarn said he’d rate himself a 7, so I’d probably rate myself a 4 or 5
Mostly the virtual bit of it [the shapes, circles, rectangles, triangles thing], "ordinary" has it's uses (CRTP, f.e.).
If you want to avoid allocations/deallocations while processing the string, you need need to allocate its maximum size upfront. We know the string can't be any larger than the alphabet of the input, since that would mean the string must contain a duplicate letter. So, `256` is probably a decent number. `sub.reserve(256)`. That removes allocations, but erasing from the front of the string still requires moving all following characters to fill the gap. For that, a [circular buffer](https://en.wikipedia.org/wiki/Circular_buffer) would be ideal. A [`ring_span`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0059r4.pdf) type was proposed for this, but I never heard where it went. With a `ring_span` truncating from either end is simply a pointer adjustment.
[Virtual Base Class in C++](https://www.learncpp.com/cpp-tutorial/128-virtual-base-classes/)
**Company**: [Swiss National Supercomputing Centre (CSCS)](https://www.cscs.ch/) **Type**: Full-time. **Description**: The Swiss National Supercomputing Centre (CSCS) is operated by ETH Zurich and develops and provides key supercomputing capabilities required to solve important problems in science and society. The Scientific Software and Libraries group at CSCS is looking for **developers** who love writing stable, performance-portable, **scientific software** for the latest HPC systems. We have multiple open positions at both the ETH Hönggerberg campus in **Zurich**, and at the CSCS headquarters in **Lugano**. Your work will involve long term projects of at least one year in duration. Projects involve either close collaboration with a scientific collaborator, or work in small internal team working on software for use across multiple projects. Some examples of projects you might work on are: * Template meta-programming and domain specific languages to accelerate climate and weather codes on accelerated architectures * Quantum chemical and material science applications used for the prediction of novel materials * Optimising and wrapping sparse linear algebra and mesh codes for our finite element and finite volume users * Combining low-level optimization with task-based parallelism at extreme scale to perform fast linear algebra on the world's largest systems * Communication-avoiding parallel algorithms Our projects are open source whenever possible. Here are some of the projects we develop and contribute to: [Arbor](https://github.com/arbor-sim/arbor), [SIRIUS](https://github.com/electronic-structure/SIRIUS), [HPX](https://github.com/STEllAR-GROUP/hpx). Also have a look at the profiles of some of our team members: [Nora Abi Akar](https://github.com/noraabiakar/), [John Biddiscombe](https://github.com/biddisco/), [Ben Cumming](https://github.com/bcumming/), [Mikael Simberg](https://github.com/msimberg/), [Hannes Vogt](https://github.com/havogt/), [Sam Yates](https://github.com/halfflat/). We require you to have great C++ skills and a master in computer science, computational science, mathematics or natural sciences. Ideally you would also have experience in one or more of the following: * **Materials science, weather and climate, or linear algebra** * Development of numerical or scientific simulation software * Development of GPU-accelerated applications using **CUDA** or **ROCm** * Release management * Performance modeling **Location**: Lugano and Zurich, Switzerland. **Remote**: Only in exceptional cases. **Visa Sponsorship**: No. **Due to the migration regulations in Switzerland the process for non-EU residents is more challenging.** **Technologies**: C++11 to C++20. CUDA, ROCm, MPI, OpenMP. **Contact**: Tell us what project catches your eye and and why you'd be the right candidate in your application [here](https://apply.refline.ch/845721/6509/pub/1/index.html).
What do you mean?
It us still not a virtual class. It is virtual inheritance of a normal class
https://en.wikipedia.org/wiki/Continuation-passing_style
And again, the question is not about engineering. It's about knowledge of C++. Different things.
Asking too open ended questions could waste an oppurtunity as well if the person finds it too intimidating... they might have great skill and potential but unable to answer if they are being "tested"... I wouldn't advice too open ended questions.
I think a good question could be; Do you write code on your free time, for fun?
Because then they'll learn that typing std:: is actually good and proper and serves an actual purpose. Then they might never get the idea of putting using namespace std in a header somewhere to "make things nicer", or some other horrible thing.
I think it's better to learn good habits straight away than first learn poor habits and then unlearn them. This goes double for people without preconceptions.
There are virtual base classes: https://www.learncpp.com/cpp-tutorial/128-virtual-base-classes/
Could you give some examples of what you mean by "What are some best practices for managing header files?".
"Does C++ have destructors" seems to eliminate &gt;95% of "C++ engineer" applicants that I interview.
Also when declaring a \`friend\`, you need to specify whether the friend is a struct or a class.
&gt; the buffer size computation should be part of the to\_chars function family It already is, in a way. `to_chars` cleanly fails if the buffer is too small. Correctly handle to\_chars failures, and you get robust code. The reason I put the first formula is because in my opinion, the use case for to\_chars is to have medium sized buffers pre allocated (\~4KB), where you write XML (or json, etc) serialization, push the buffer to disk or network on "completion". Which means that a to\_chars failure/avoidance near the end of a buffer means you call it with the next buffer. 
I just used this today 😃 Nice feature
I thought this was more of python know how thing
Oh, all the time. And i've been using C++ for a *long* time.
&gt;I would agree if there would be a C++ version of `from std import vector, tuple, optional, string` `using std::vector;` is a thing. I haven't checked, but it should work.
&gt; "Nothing" is also a right answer. It's just a specialization with its own trade offs. There's nothing wrong with that. I'd like to say (as an interviewee) that asking "trick" questions in interviews is really stupid. I am always nervous because I'm trying to simultaneously hold in my head all of the C++98/03/11/14/17 quirks, years of algorithm study, all of my work experience, all while also acting like a human being talking to another human being. Asking coy questions like "what is wrong with vector&lt;bool&gt;?" doesn't leave me with a lot of brain bandwidth to dig through all of the bullshit to arrive at your perfect zen answer, unless it happens to be something that I have vast amounts of experience with. \`vector&lt;bool&gt;\` is not something most (non-embedded) developers have a ton of experience with, so I would list the first three things you mentioned because that's what the question is leading me towards. And while the typical vector&lt;bool&gt; implementation is perfectly standard-conforming, it does constitute a stumbling block that is so prolific that it's often taught in introductory courses (or was when I was in school). That can not only color the view of it as dangerous, it indicates there is something *problematic* about it as a C++ feature.
[Raw pointers still have their uses in modern C++.](https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/)
That reminds me of [this bug](https://bugzilla.mozilla.org/show_bug.cgi?id=372287) I found and fixed in Sunbird. The [patch](https://bugzilla.mozilla.org/attachment.cgi?id=264373&amp;action=diff) was trivial, but tracking it down was a pain because (if I recall correctly) the stack trace wasn't correct due to the bug hosing the stack.
Ah, gotcha. I probably should have tried that. Thanks!
As other said, I don't like vocabulary questions. Experienced people may know things without knowing how they're officially named in C++ jargon. Also, I don't like direct questions like "Why a virtual destructor?" or "What's/How RAII /works?". I prefer to ask how they'd write a base class (which also opens the door to discussion about value VS entity semantics), or "What's a resource (/memory) leak? And how do you take care of them?". Experienced people will have a lot to say on these topics.
and forward declarations require the correct keyword too
I'm not a boost contributor, but I've reimplemented some things they've done, and have done plenty of my own clever shit. That's easily checkable though :)
Whether or not to have a stack trace as part of a release build is more of a security question than a performance question. But if performance is a concern for you, then you should measure before judging. Of course running the debugger is a good idea for debugging uncaught exceptions. But without clues about how to reproduce the problem from a stack trace, it can be hard to narrow down where to look. Like suppose your exception is from going out of bounds on a vector. That is something that could happen in many places in a large program, so you might have a lot of trouble reproducing the problem (much less debugging it) without that information.
I dont think co routines will ever be mainstream as it is very hard to debug, in special Crashes. Fellas who deal with Sensitive processes will never buy into it. It ( coro) is surprisingly simple to use though, it makes for avery intuitive programming environment. 
if someone says 'expert level' that's a bad answer. My answer would be more along the lines of: "I've worked in several production codebases in it, mostly in C++03, but recently in 11 and 14, as well as a lot of 11 and 14 at home. Because of the field I work in, I've not used the standard library as extensively as I would like, and having to use it requires a lot more google than you might expect an expert to need. The most complex thing I've used it for was interfacing lua scripts into my own game engine, so that you could pass objects which acted as pointers to native-controlled objects in such a way that you could read and write their data, and call their functions in a type-safe way. Similarly you could bind lua functions to be callable from the C++ side, with automatic conversion of data types (including structs) into things that make sense and are usable in lua. This was tied in with automatic reloading of lua scripts, without breaking the connection to the native code at any point. This gave me a lot of the TMP/SFINAE knowledge I have, which is certainly enough to make trouble, but not enough to go and write my own performant STL. I've similar experience with other modern C++ elements like constexpr which I used in my most useful github repo. I don't have the specific detailed knowledge of the standard to understand the minutia of subtler easy-to-write bugs and performance issues, but I've never found such an issue I couldn't google my way out of" &amp;#x200B; It's not a great answer (far too long :) but it's the sort of answer I'd want to get from an interviewee
Sometimes that's true. But I think `using namespace std;` for a beginner is a good compromise. I've even seen it in production code (gasp!) with no noticeable effect on performance or correctness of the program, or any other negative outcome whatsoever.
Personally, I fiddled around with Boost.Serialization when it was somewhat new and unstable, and even managed to use it in unusual way, by marrying it to ASIO to send serialized commands continuously over the network without creating a new archive each time, but boy, did those headers made my head hurt! I spend A LOT of time digging through them, because the code kept crashing deep inside Boost. Not an experience I'd like to repeat.
That's what he said. Virtual inheritance pulls in virtual base classes. There's no such thing as a virtual class in C++ outside of that context (i.e. `virtual class T` makes no sense)
It probably reveals more about actual job performance within the team than random C++ trivia.
24 years of daily experience in c++ here and no idea what to answer to your question except for "it depends on the filesystem?".
Incorrect stack traces are FUN (in Dwarf Fortress definition of "FUN")! In one of our games, crash reporter (which we were unable to touch) kept mis-resolving functions in the traces, and I had to write a Perl tool that symbolicated traces more properly, using raw addresses and map files produced by Visual Studio. Of course, when the addresses themselves are incorrect, it's even more FUN.
Sure, but as I responded earlier: That is not a special kind of class. Just as a "normal" base class isn't a particular kind of class, but a way to use a class, a "virtual base class" refers to a specific way of using a class (btw.: That class doesn't even have to have any virtual functions). And as I said: There is no construct called "virtual class" (no "base" between virtual and class)
And I thought embedded systems were conservative in upgrading the compiler... At least I get to compile with GCC 6.x.
Really depends on the boost library though. I only find the deep macro code hard you read, but that's not part of every library...
I guess it does... Personally, I also get confused by heavy modern use of templates. It's one thing to be looking at something like vector or basic_string, but Boost's mix of templates and macroses seems impenetrable without applying a great effort. And some Boost libraries seem over-generic to me, even as an user. I was unable to do *anything* with Boost.Graph: every class had about a dozen template parameters, each of them by itself a template. After a few hours of fruitless attempts to make any sense of it, I decided to just re-implement A* once again on my own...
Yeah, depending on their field of specialty, it'd be completely understandable to have never looked under the covers.
If they start by complaining about “the amount of boilerplate code required to solve this problem”, they’re a keeper.
[gsl::span](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/gsl-intro.md) [std::span](https://en.cppreference.com/w/cpp/container/span) C++20
I'm using that for non-`std` imports. For `std` you'd have: using std::vector; using std::tuple; using std::string; using std::optional; way too verbose.
I'm not convinced `using namespace std` (in source files) is bad. I think having `std::` everywhere is a waste of time, when reading code as well as when writing it. Compare tuple&lt;optional&lt;string&gt;, int&gt; with std::tuple&lt;std::optional&lt;std::string&gt;, int&gt; The latter is a lot harder to parse visually, as well as to write.
I agree. Just virtual base classes immediately sprang to mind. Which is kind of funny, because they are quite rare.
&gt;way too verbose. `using std::vector, std::tuple, std::optional, std::string;` [https://gcc.godbolt.org/z/p0eqrU](https://gcc.godbolt.org/z/p0eqrU) Available as of C++17.
Thank you! This seems to be the perfect answer assuming it works in gcc 6.x.
Best practices are not perfect yet but much better than they used to be. The upgrade from C++98 was much needed and very welcomed. That said though, there is room for improvement. But I did not see yet all languages with an error handling that is perfect. Some use isolation and the actor model, using message passing. U pay passing messages. Others use results like Go. U have to propagate things up. Or Rust, which uses something similar to std::expected but you pay in verbosity to some extent. Later you have exceptions, that are slow but can be propagated from anywhere and correctly handled somewhere else, which is very convenient. None of this solutions is perfect. If there was one, all languages would have chosen it already. However, it looks like C++ does worse than others for having choices. I do not agree at all. If it was a solved problem and an obvious design mistake, I would agree. However, it is not.
I honestly think that boost graph is one the prime examples of generic (or more precisely traits-based) programming done right. Tbf it has a very steep learning curve and shows how much we actually need concepts in c++. Apart from that I have used it to implement subgraph monomorphism detection on the (seemingly) most unrelated datastructures and under no circumstances would I have done that myself :). In fact it is the only boost library (apart from the sandbox boost.extension library) I still bother to use.
Yeah, nearly 17 years for me now, and I still frequently feel inadequate looking at what people can do with the language. That said, I don't find things like gratuitously overcomplicated template abuse to be of great value. There is much virtue in simplicity and being understandable by mere mortals.
Explain RAII. 
Morover, don't use shared pointers if the _ownership_ is not shared.
I think a question about base class destructors having to be virtual is a pretty good one. You can also ask questions about the memory model. So what does a multiply inherited class look like in memory. Where are the virtual function tables. What happens when you typecast a multiple inherited variable to one of it component classes.
One of my standards is, "What happens when you call malloc (or use new) ?" Admittedly, asking it about malloc is more of a C question than asking it about new, but it gets at the same sort of question, and malloc is conceptually a little simpler. One of my related backups is "What happens when you open a file?" (The latter often being language agnostic, and I'll ask that to folks who have more of a sysadmin background and might know some Python, but never had to focus on manual memory management.) With some followup questions, you can pretty much fill up a whole interview with those two. Even if they have no idea about the details, you can get a sense of some critical thinking skills, and ability to learn on their feet as you fill them in and yank them further down the rabbit hole.
What percentage of the C++ standard do you know? The lower the percentage, the more they know. 
Sure, fire me an email at one of the usual addresses. Be aware I am currently unemployed, which means I am mostly on childcare and cleaning and chores i.e. expect a bit of lead time for me to reply to any email.
If I was asking, you'd definitely get a point for knowing a filesystem is involved. I've seen people shrug even more vaguely than that, lol. If I was doing the interview, I'd probably ask some followup questions like asking if you are familiar with any particular FS, where the code for the FS lives (to try and see if you understand the difference between userspace and kernel space). Where the code for fopen lives (to see if you understand the difference between libc and the kernel), and see if you could speculate about how a system could support multiple filesystems using a single fopen function that doesn't require the application developer to know what filesystem is being used. (Which can lead to a general philosophical discussion about layers of abstraction, separation of concerns, etc.)
I think it's worth noting that a lot of younger developers, recent immigrants or generally people who aren't entirely comfortable where they're standing -- may massively flub this sort of question, due to lack of confident interviewing and/or social skills. It's worth bearing in mind that you also need a backup plan to deal with this potentiality and let them just go ahead and solve a real problem and/or present the details of their past accomplishments.
The reference implementation for https://wg21.link/P1028 proposed `std::error` works in all the major compilers, C++ 11 or later, and is expected to ship in Boost 1.70 onwards in a few months time. You can use it right now, today, if you want to, from https://github.com/ned14/status-code. Absolutely would more implementation experience be very desirable to help the committee evaluate its design and whether it has design faults not currently obvious.
I have no idea, yet. Unlike WG21, WG14 does not distribute draft papers. You find out about a paper when it literally gets published. Next WG14 meeting is June in the UK, I'll be physically attending.
That's fine. I guess I've baited such responses by being not more explicit in my initial comments. Usually I hate people that make such pedantic comments, but as I am also teaching c++ now and then I've learned that some of those finer distinctions really matter, because people misunderstand each other or how the language works.
You're missing a third option: `std::unique_ptr`. Most data structures don't need any sort of reference counting, so the extra overhead and complexity that `std::shared_ptr` adds just isn't viable when implementing a data structure. Ok, so between `std::unique_ptr` and a raw pointer ... that's a tough choice. In the end, for production-quality library code a raw pointer is the right solution, IMO. I think it's a very worthwhile exercise to create a linked list (especially a double linked list) with `std::unique_ptr`. This teaches a lot about how to properly use a smart pointer, along with their strengths and weaknesses. You quickly learn that one of the links needs to be a raw pointer anyway: only one direction has an ownership semantic while the other direction is a non-owning relationship. Otherwise you get two owners, and that doesn't work with `std::unique_ptr` (duh). Eventually you step back and see how powerful the concept is: you never wrote a destructor, `new`, or `delete` in the entire thing, and you're guaranteed that it will never leak memory. Awesome! But there's a problem: the automatically-generated destructor. Think about what the destructor does. Your linked list probably has a `std::unique_ptr` that's the head of the list, so its destructor is called. Its destructor must call the destructor of the `std::unique_ptr` of the next node in the list, which must call the destructor of the next node, and so on. *This is a recursive function ... with a recursion depth of the length of the linked list.* So, what happens is your linked list works beautifully for the small test cases you try out, but then one day it grows to hold a million or whatever items ... and your stack blows up. And, unfortunately, I've never seen a compiler that can optimize this case out. [See here](https://godbolt.org/z/hRp5aY), for example. It's not tail recursion, and that's a big problem. The solution, unfortunately, is to write your own destructor. Something like this: ~LinkedList() { while ( head ) { auto tmp = std::move(head); head = std::move(head-&gt;next); } } Essentially, this breaks a node from the linked list, which can be destroyed on its own without blowing up the stack. That node still has a `std::unique_ptr` inside so you still get a recursive call, but it terminates immediately. Problem solved. Of course, at this point it makes you wonder if it was worthwhile at all. I have yet to see a compiler that removes the recursive call, even when it's guaranteed to be unnecessary ... so there's a bunch of superfluous code slowing down the destructor of every node in your list. Given the extra headaches in writing the implementation, and since you had to write a destructor anyway, so was there really a point to this exercise (beyond education)? Eh, maybe some (as it forces you to really think about memory handling along the way), but in the end it's not production-quality code. So, in the end, I prefer raw pointers for data structures like this.
For reference, I would rate myself a 4/10 in terms of C++ knowledge.
Fibers have been the standard name for heavy strings since the 90s
there are so many things i could ask about: i could ask about the behavior of various standard library functions and classes (why can `std::deque` sometimes be more performant than `std::vector`?), about tricky subjects like the dangers of lambda capture or lvalues/rvalue, what new features of C++ they most enjoy, and endless more. C++ expertise is really hard to judge, imo. I feel it's definitely not something that can be done quickly - simple technical questions don't usually cut it, and while verbal questions are the way to go (along with surveying they're projects, which they hopefully have somewhere I can view them) I struggle to choose just a few off-the-cuff that would help me most understand how well someone knows the language.
What I try to do is separate expected and unexpected errors. For expected errors I generally avoid exceptions and look for a way to avoid the error (check file exits before trying to open it) or use return values since it's a condition I need immediate logic to deal with and testing a return value is often prettier than try/catch. For unexpected errors, exceptions are awesome because you can get back up any amount of stack to an general purpose error handler. Strict RAII is absolutely required for this to work though. I think a lot of why people think exceptions are terrible is that haven't learned how to use RAII everywhere for safe deterministic cleanup. It takes quite a bit of effort learn and get used to but the payoff is huge. You also gain the ability to throw an exception to abort deeply nested things from any point, which is another amazing power. RAII is really one of the crown jewels of C++. 
True. At least until you get a namespace collision due to a library you want to include or someone else decides to commit something that collides with something in the standard library.
* Why must you be cautious when using .push\_back on vectors? How do you avoid this? * Using the \[\] operator on a map can be bad, why? I sound like you're digging for a specific answer in those. I can tell you about emplace, reallocation, iterator invalidation, map::find, complexities and copying and so on but I don't know what you personally mean by "cautious" or "bad", so I don't know which answers you're after.
\&gt; What's wrong with vector&lt;bool&gt;? &amp;#x200B; I think these are generally terrible questions, because it strongly implies you have a specific answer in mind and now the candidate has to try to guess what they think you're after. Also, you probably have different value judgements of "good" and "bad" compared to the candidate. &amp;#x200B; A better question would be ask the tradeoffs between vector&lt;bool&gt; versus vector&lt;char&gt; and under what circumstances you'd use one rather than the other. &amp;#x200B; &amp;#x200B;
This guy knows.
What, why? Is it a trick question, or how does 95% of your applicants get it wrong?
Isn't this going to be dropped in a forthcoming C++ standard, or is this only a proposal?
What is the major differences between SObjectizer and [caf](https://actor-framework.org/) ?
R/unexpectedmontypython
Soo .. is this like an open source C++ Simulink thing?
Classes default to private inheritance, structs default to public inheritance.
The haskell standard library, as well as other libraries I worked with, use dynamic haskell exceptions (the 'error' function). 
It seems `shared_ptr` would usually be overkill. Nodes are commonly owned only by the container, so while the container may have multiple references to a node, they do not represent shared ownership. Nodes are generally removed only by methods of the container object, so lifetime is clear. Just make sure methods that remove nodes can't throw, but you probably want to do that for other reasons anyway. Some answers have suggested `std::unique_ptr`, which may help for trees but are likely unsuitable for graphs and double linked lists (all depending on implementation of course). Use of `shared_ptr` and`weak_ptr` may help if you want to provide safe iterators. Even so, this takes careful implementation and use.
Nobody expects the... Ok, I'll stop now 
Any chance that the template can be changed as follows: **Remote:** [Do you offer the option of working remotely? Must remote candidates be in a certain geographic region or timezone?]
Because xtensor is a mess that is nearly impossible to compile on anything but the authoring group's OS &amp; compiler.
Incorrect. Look at [this backtrace](https://pastebin.com/ixHdHn6E) from backward-cpp. You can see that abort is called within _cxa_throw.
I liked it, nice explanation of the differences that ranges bring in C++20 by using reverse iterator. It was nice to mention the Haskell part, the `take(n)` very much reminded me of Haskell. Good work!
What have you written in Boost Spirit. Is it still written in Boost Spirit and how much was the exorcism :). Although Spirit is both beautiful and scary at the same time.
Oh wow, this is incredible feedback. I'm sharing this with the team.
There are a rather old comparison: [https://eao197.blogspot.com/2015/05/progc11-sobjectizer-55-compared-to-c.html](https://eao197.blogspot.com/2015/05/progc11-sobjectizer-55-compared-to-c.html) But both frameworks evolved significantly since then. Because of that it is hard to say how actual this comparison now. As far as I know CAF now has an analog of SObjectizer's Environment -- it is actor\_system, that allows to run several independent "actor subsystems" inside one process. And I really don't like that question. Because it is necessary to have good knowledge of both frameworks to make more or less objective comparison. But I don't looked at CAF for years just because I think those are very different frameworks with different philosophy and, probably, different goals. I can try to mention some differences but they a my personal point of view and it is very subjective: * SObjectizer is a result of many years of evolution (the history began in the mid 90s as an attempt to build object-oriented SCADA system). SObjectizer was never a research project. Because of that the stability and compatibility is a strong requirement for SObjectizer. For example the first version of 5.5 branch was released in Oct 2014 and there was almost no compatibility breaks inside 5.5.\* releases. CAF much more younger and less stable in sense of compatibility; * SObjectizer is based on some original ideas. CAF is a very good port of Erlang to C++; * SObjectizer uses mbox-es as destination of messages. Mboxes can have different types and can implement different logic. CAF uses reference to actors for message exchange; * SObjectizer has just one type of actor (agent in SObjectizer terms). CAF has several different types of actors. You can easily bind your actor to different types of dispatchers in SObjectizer, but you have to rewrite your actor in CAF if you want to run it on different work context; * SObjectizer has no such things as supervisor and supervisor tree. CAF has them because CAF is strongly influenced by Erlang. And we think that supervision has no sense for C++ actors; * SObjectizer implements pub/sub differently; * SObjectizer implements request/reply pattern differently; * SObjectizer provides support for such CSP-like functionality as \[mchains\]([https://www.slideshare.net/YauheniAkhotnikau/dive-into-sobjectizer-55-ninth-part-message-chains](https://www.slideshare.net/YauheniAkhotnikau/dive-into-sobjectizer-55-ninth-part-message-chains)): they are very similar to CSP channels; * SObjectzer-5 doesn't support distributed applications. This is the result of years of experience with SObjectizer-4. CAF does this support by implementing some custom communication protocol. I think there much more differences.
i like you all arcticles but one of article you disable translation to english i mean http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml i can't translate to english from google chrome can you please remove this restriction ?
* What is your favourite modern C++ feature, and why? * What is your favourite language feature of a non-C++ language (that C++ doesn't have), and how would you duplicate it in C++? * Can you describe the most annoying C++ bug you ever managed to fix, and how you worked out what it was and how you fixed it? 
&gt; a 12 years old girl who knows nothing about computer should be able to start reading the most complicated and powerful programming language in the world […] No, why?! We don’t expect 12-year-olds to be able to design and build space rockets from scratch without prior knowledge. Why would we expect them to be able to pick up programming in a high-performance programming language from scratch? [Something that John Carmack himself has admitted is more complicated than actual rocket science.](https://twitter.com/id_aa_carmack/status/557223985977765890)
The typical hang-yourself questions. 
2. Probably even worse, those uexpected additional elements could easily lead to erroneous behaviour. For non-gigantic maps I’m primarily worried about the potential bugs. They’re more likely to cause real trouble than a probably minor loss of performance.
Writing your own `span` isn't completely trivial, but it isn't tricky either. Having gsl span's (and std span's) source code and documentation for advise makes it much easier.
Sure; so pick a filesystem (or even say "a filesystem might") and go with it. Know NTFS on WinNT? Know ZFS on OSX? Know FAT on DOS? Talk about it.
&gt; The Range library has a View. A View is a range adaptor. A View behaves like a Range, so it is a Range. Sort of. This is not accurate. Range is the lowest level concept. It's just something you can iterate over (by way of calling `ranges::begin` and `ranges::end`) View is another concept. It's a refinement of Range that adds a few extra requirements: that the Range must be Semiregular and have all of its operations be O(1) (there's a heuristic to determine this, you can opt in or opt out). Then, there is a separate thing entirely, called a Range Adapter. This transforms a Range into a View. For instance, `filter` is a range adapter that turns any Range into a View with some elements removed. Importantly, all Views are Ranges (by definition).
I mean, C++ obviously doesn't have destructors. All evidence to the contrary has been generated by a conspiracy by the Italians tildas. Engineers who know this are on the inside; those who do not should be suspected of being Romantically compromised. 
Well, STRUCT STRUT UARTS ACTUS CAULS CLASS the difference is 5 on a word ladder. 
`operator&lt;` on a `struct` means it is still data. `.as_tie()` to implement `operator&lt;` means it is still data. A pair of integers with `operator+` that works member-wise is still just data. A constructor means it is still just data, as well as defaulted values on fields (which almost every field in almost every struct should have, just to reduce bug load). At least, those are all way closer to "data" than they are to an pure virtual interface class that is reachable via a custom dynamic casting infrastructure on your frame-level abstraction. 
6: Trick question, that is not a definition, it's a declaration. Also in C++ it is customary to talk about member functions, not methods.
Really? I have a regular reader who can't understand Japanese? Why? I mean, almost all my writings are Japanese. It should be very difficult to read the Japanese through machine translated English. Because the great grammatical difference between Japanese and English. Is C++ documents and textbooks are so lacking even in English? I only relies on the draft standard and the proposals in order to learn the new C++ features so I have no idea of the English C++ textbook for non-language lawyer. There is nothing to prevent the machine translation. I suspect the amount of text in the single page cause the issue. Anyway, even though that book was NOT a literal translation of the C++11 standard wording. It's very close to the translation of the standard wording because I explained almost everything in the Standard core part in the Standard wording order. Besides, it become slightly outdated since most of the wordings are rewritten in the post C++11 Standard. If you can read the English, why don't you read the C++ Standard directly? Now I know I have an unlikely regular Non-Japanese reader even though I write Japanese, there may be a demand of my English textbook. You see, I'm not a good English writer, but I'm certanin I can produce the English writing way much better than what machine translation does. I also found out that my English writing speed isn't that different from Japanese writing. Because for the technical writing, studying the topic take much time than actually writing a sentence. With the help of the professional proofreader, I might publish my book in English. Although I don't know how to publish English text book now.
Yes. I know that. My writing isn't that good. View concept is a Range concept and Semiregular and enable_view.
this. Shared ptr solves a hard problem. The hard problem it solves is *not* the general ownership problem. It solves the acyclic shared ownership problem. The acyclic shared ownership problem can be used to solve other problems, but simply shoving shared ptrs into something without first showing that it can be helped with a solution to acyclic shared ownership is a really bad idea. 
you are wrong about the problem about translation i can translate https://ezoeryou.github.io/cpp17book/index.html and it good for me after translation 
"C/C++" seems to be on anyone's resume that has a list of programming languages. Another thing that filters out a surprisingly large amount is just asking to describe a few containers from the standard library. Not looking for much other than vector and map, but people often can't even name that. That question can lead into a more in depth discussion, but often ends there. I don't think we should memorize the API but knowing of vector is pretty fundamental
Fibers are the standard name for a light-weight threading primitive: https://en.wikipedia.org/wiki/Fiber_(computer_science) The data structure you're referring to is more commonly known as a rope (til: or "cord"): https://en.wikipedia.org/wiki/Rope_(data_structure)
I can't tell if you intend the last sentence to suggest that I fix your blog. If that's in fact what you meant, then uh... no. 
You're thinking of I/O exceptions. How about math exceptions? Also, you seem to be thinking that exceptions should not be used for flow control. John F. Pane1, Brad A. Myers, and Leah B. Miller of Carnegie Mellon University did a study on how people program. They ask children to describe Pac-Man. They discovered that the common case was describe first and then the exceptions. * Pac-Man moves in the direction of the joystick. * When Pac-Man hists a wall, he stops. * When Pac-Man moves over a pill, he eats it and your score goes up by one. * When Pac-Man eats fruit, your score goes up by 100. * When Pac-Man eats a power pill, the ghosts turn blue and you can eat them. This is the natural order people think of things. Programmers have to learn to invert their thinking and do exception testing first. This makes programming more difficult. * If there's a wall in the direction of the joystick, stop. * If there's a pill in the direction of the joystick, increase the score by 1. * If there's fruit in the direction of the joystick, increase the score by 100. * If there's a power pill in the direction of the joystick, increase the score by 10 and switch the ghosts to edible. * Move in the direction of the joystick. 
That book is way much smaller than my C++11 core language book. Also, the HTML was generated from pandoc. When I was writing the C++11 core language book, I was young and naive. I believed at that time that the XHTML is the future, XHTML totally rule the world and the day of ugly outdated HTML was numbered. So naturally I wrote a single giant XHTML file by hand. How young and naive I was. After that, I grew up and started using markdown. I don't like markdown but it gets the job done.
1) Oh, don’t get me started! I might talk for a while about ownership, how important it is and how Java encourages you not to think about that vital topic.
Okay, maybe I'm wrong, then
Yes. Just using the Range view is by all mean easy. It's both easy to write and read. I totally recommend the range view for the people who just started learning programming... when it's available that is. It probably needs a few more years before any C++ compiler implemented it even experimentally. Production-ready quality implementation may take another decade. There is one thing Haskell is still better than C++. You can't easily write your own range view as obviously presented in the last part of article. For Haskell, it's trivially easy if you understand the basics of Haskell's type classes. I can write this but average C++ programmer has no hope of grasping all the glory implementation details.
Uh no. I fixed it.
And why exactly is this c++ related? How do I know I don't get the "c++ is c with classes and I don't like classes" type of programmer?
&gt;some examples of what By managing headers I just mean dealing with headers. It is a pretty open ended question. Stuff like using header wrappers to prevent re-includes. Also knowing not to put any "using namespace std" in any header files. When would you prefer to use source/header vs header only. Knowing when to use "extern".
You can just steal this one: https://github.com/bstamour/cpp-span It's mostly complete, at least to the point where it's useful.
&gt; I think it's worth noting that a lot of younger developers, recent immigrants or generally people who aren't entirely comfortable where they're standing -- may massively flub this sort of question, due to lack of confident interviewing and/or social skills. IMHO, unless they a severely struggle with the language (when it's another problem which should be considered), factoids are much easier to flub under high stress and lack of practice. Open-ended question help you relax and think at your own pace.
I sorta wish it was automatic/implicit, with overriding them being the explicit case. Or having a special inheritance syntax, like `class a : using b`
You destructor would not work. In the first line, you move from `head`. For `unique_ptr` this means `head` will become `nullptr`. And then you dereference it on the second line. All you need is this: ~LinkedList() { while ( head ) { auto tmp = std::move(head-&gt;next); head = std::move(tmp); } } PS: I did it in two statements because I am not sure if this will do the right thing: head = std::move(head-&gt;next);
I agree. I've been at this for 30 years. I came up with my own names for things well before the current trend towards everything being a pattern. "OK, folks, let's take a break here. Those who want can implement the Coffee Intake pattern." There would be lots of things I wouldn't know what they are talking about, but actually have implemented it many times. I posted a thread a while back about the many ways that I use what I call 'Janitor' classes. I've been using that term for over a couple decades. But the entire thread turned into an attack because I didn't use the term RAII. What's even more stupid is that only three of the probably 25'ish examples I gave have anything at all to do with resource acquisition or initialization. But clearly it's more important to use the group-speak term than actually impart practical advice to newbies. It's become a bit of an orthodoxy.
You can't, but if you really want to, you can ;) https://github.com/facebook/folly/tree/master/folly/experimental/exception_tracer
Of course, if you pass the object by reference/pointer as `std::string`, or Tiw forbid, slice it, it will call `std::string::operator &lt;&lt;`, as it isn't virtual.
Well, it speaks to the person's familiarity (and comfort) with low-level programming. High-level as C++ aspires to be, it is still very much portable assembly language with sugar on top. If you hire a programmer who thinks otherwise, they'll mostly be fine except for weird inexplicable hiccups when they don't know what a reference is, or how object files are compiled and linked.
Why don't you use WINAPI Fibers on Windows?
'maybe' is a strong word.
For 1, there's also the issue of potentially making more copies than necessary. Consider class A{ int data[3]; A(int a, int b, int c) : data{a, b, c}; } void func(vector&lt;A&gt; &amp;v){ A toAdd(a,b,c); v.push_back(toAdd); } Here the object toAdd is constructed, but then must be copied and stored into the vector v since those are the semantics of push_back. The unnecessary copying can have a large impact on performance, especially if objects are large. That's why it's preferred to use emplace_back in situations where objects are being constructed and stored in vectors. i.e class A{ int data[3]; A(int a, int b, int c) : data{a, b, c}; } void func(vector&lt;A&gt; &amp;v){ v.emplace_back(a,b,c); // Constructs an A object in v directly } 
Has a levenshtein distance of 6
It's not about a specific answer. It's about explaining your understanding of how .push_back() and [] work. Most beginners understand and use []/.push_back() but don't have a thorough understanding of the behind the scenes mechanics. This will give a good indication of someones C++ knowledge.
Using [] on a vector&lt;bool&gt; doesn't return a bool. It returns a proxy object that lets you manipulate the bit in question. 
Agreed. But using reserve gives you control over the allocation. Thus you can ensure allocation happens when you want it to. This will prevent your application from having potential bugs with lag spikes etc (very important for real-time systems/games/rendering engines etc). Again, it's about the interviewee understanding the mechanics of the structures. This will give an indication of someones knowledge level.
I guess one question would be, is it really testing their knowledge of C++ that is important, or is it testing their ability to apply whatever they do know of C++ to achieve high quality results? I think the latter is what matters, and my preference would be to ask them to bring in some non-trivial examples of their work and let's discuss them. It would be obvious if they didn't write it or understand what they wrote. And it would allow them to demonstrate how they work (not how I work) and what they can do with what they know, how careful they are, if they realize where the tricky problems might occur, etc... I'm not likely interested in a language lawyer, but someone who can create good, quality code. If there are any aspects of the language that my company's code base uses that the applicant hasn't dug into, that's not likely to be that big an issue for them to spin up on that, if they have a solid grounding in general coding principles and the core concepts of the language. &amp;#x200B; OTOH, if your company's thing is to aggressively use every new feature of the language as much as possible and create code that someone from 10 years ago might not even realize is C++, then maybe you do want a language lawyer. &amp;#x200B;
I find the latter much easier to read. "std::string" is one thing to me and I immediately know what it is without really thinking. "string" sticks in my brain as "identifier whose meaning is unknown, keep in mind you may need to look up what the heck it is" Some of that undoubtedly has to do with the code I'm used to reading.
I didn't say coding convention. I said "long standing principle". The concept of using a struct as a data object and a class as an intelligent object AFAIK goes back more than 20 yrs. Again, this is about having a two-way conversation with someone; not a closed question to determine knowledge.
Er ... um ... yeah, that's what I meant. I originally wrote the one-line version like you suggested, then decided to split it into two lines to make what's going on clearer, but didn't modify the code correctly and messed everything up. The one-line version works correctly.
Truly one of C++17's most underrated features.
This is also a valid point :)
I'm just admitting that I'm now uncertain. It's the appropriate way to apologize for having been wrong
This is possible, but in my experience this is much less of a concern than the performance impact. However, this being raised during the discussion of the answer would definitely be a positive.
This is also a good discussion point :)
Compile with -D_LIBCPP_DISABLE_AVAILABILITY
Your submission has been automatically removed because it appears to contain disrespectful profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/aem8n8/why_is_my_code_giving_me_different_output_on_the/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
using namespace std? 
When used as a native data type, is it real? 
My employer's interview test has some basic question about references that eliminates 95% of our applicants.
You should not get an exception when going out of bounds on a vector. This is a design bug of STL as mentioned elsewhere. What should happen is that the program core dumps, giving you a very good starting point for your bug discovery.
In my case, I was very much in an academic/test mentality in part due to the perceived power difference in an interview. I simply tried to sit silently, work through to the answer, and blast through with a solution. Not a good mindset for an interview. Switching over to what you're saying was a sudden and complete change.
Give some examples of mistakes in the standard library.
I only glanced at it briefly and std::vector&lt;bool&gt; is always a red flag to me: [https://en.cppreference.com/w/cpp/container/vector\_bool](https://en.cppreference.com/w/cpp/container/vector_bool) &gt;Exposes class [std::vector](http://en.cppreference.com/w/cpp/container/vector)&lt;bool&gt;::reference as a method of accessing individual bits. In particular, objects of this class are returned by [operator\[\]](https://en.cppreference.com/w/cpp/container/vector/operator_at) **by value.** &amp;#x200B;
In my code bases, it was called `array_view`.
Just out of curiosity, why do you need non-PIC dynamic libraries?
Thanks, will try.
I would argue it speaks only about the comfort with the respective kernel. Let's say you fopen /dev/null, it is perfectly possible for me to tell you what happens without having ever touched c++ or even c. To be clear: there is something to be learned about someone from every answer, but out of all the diverse questions mentioned in this post's answers this seems to be the only one that I could as well ask someone applying for a Haskell position...
I did not say how the vector was accessed. `vector::at()` in particular does check bounds and throws on error. Even the bracket operator may end up triggering exceptions if you go out of bounds. Core dumps are not universally helpful, especially not in the case of exceptions which may be caught and rethrown. In the simple case, yes, you may be able to reconstruct the call stack from a core dump, not always though. Core dumps are primarily a Linux thing also.
Odd - so the authors of those papers didn't even talk to you about their proposals or counterproposals.
First preference values, second preference raw pointers, third preference special-case smart pointers (e.g. intrusive). Maybe in a rare case, `unique_ptr`, but see the comment about destruction issues. Never `shared_ptr`.
This has some really scary caveats. &amp;#x200B; void foo(const string&amp;); MyString s("too long of a string for SSO"); foo(s); // compiles, and heap allocates behind your back I would only do this in very very restricted situations and would never make such a type part of the public API.
The tragicomedy of C++ was reviewed and much angst was had by all.
Speaking from experience and not being junior, open ended questions I struggle with more than pointed questions, because I drive in one direction and overlook other things I know. This makes me look quite a bit more ignorant than I actually am.
That was the proposed names for the standard version before it was renamed `span` for c++20, fwiw
1. "In C++, how big is an `int`?" 
Very good article
&gt; Range is the lowest level concept. &gt; View is another concept. When you say "concept here", do you mean C++20 concepts, or just concepts as in "notions", "ideas", "thoughts" etc?
\- RAII \- SOLID principles applied to C++ \- templates, types, SFINAE
Specifically, C++20 concept. But the other terms work also. As long as you internalize that a View is a kind of Range.
Have you encountered employers who said “yes” for remote, then turned out to have unacceptable restrictions?
&gt;why can `std::deque` sometimes be more performant than `std::vector`? Is this about using the right data structure for the right task (i.e. not abusing vectors when you should be using deques), or are there some weird edge cases where deques unexpectedly outperform vectors for some reason?
Excellent article, with ranges things are looking more simpler and composable.
I usually give them an example on paper that involves a parent and child class and ask them to work out the order of execution of the constructors and destructors as well as what happens with an unhandled exception and what to do to fix that. Since I work in embedded systems I also ask them to implement a string reversal function with a pointer, but thats not really C++. They can ask me any questions they would have searched online such as the parameters for some standard function or other. I dont necessarily count syntax errors or programming mistakes against them since we all make them, but I will improvise what compiler error they get or runtime behavior they see when they run it and its illustrative to see them work through fixing a mistake.
Neither. you didn't list unique_ptr, which is more likely to match the ownership model
&gt; What advanced/modern C++ features did you use and why? If I said something like auto type declaration, would I come off as a rookie?
That's general purpose code with wide usage, and the ownership issues are straightforward, so taking the basic hit of using a raw pointer in order to provide good performance for a wide range of uses is pretty easily worth it. I don't believe in 'over optimization' in general purpose code to handle pathologically heavy operations. Let the 5% fend for themselves using specialized data structures intended for that kind of thing. Otherwise you are creating much more complex code (which mean more time up front and more time every time you change something and more chance of bugs introduced when you change something) for the least likely case. But reasonable optimization in general purpose code to make it able to handle the 95% without getting piggy is always worth it. &amp;#x200B;
no I mostly use it for tests, possibly adding an implicit conversion or for making thin wrapping types that I dont use for example a class wrapping std::variant because the elements in the variant contains vectors of the variant itself. Then a wrapping type is needed
If you keep pointers to data in a vector you deserve whatever happens (been guilty of it myself, never gonna do it ever ... until next time. but no, i swear i'm not, i'll use unique_ptr, until i won't).
many thanks Neal, will do ...
I'm an interviewer in a large internship program where about 30 people in a room are interviewing students, 10 minutes at a time in order to put together a rankings list and eventually pick these students for internships. There is almost always a person in the room who asks the students to rate themselves between 1 and 10 on some aspect (C#, C++, programming in general, whatever). During the event I always keep track of the answers from the students and it almost always averages to 7.5. Most folks say 7 or 8 to indicate that they are somewhat experienced but with a lot to learn still. You get a rare 9 or 10. I've always hated ranking oneself in this fashion as most will pick 7 or 8 as to not appear either inexperienced or arrogant.
Given the huge address space on 64-bit systems, I have wondered why we can't address memory at the bit level and make this problem moot.
Interesting: _"Those good-for-nothing standard commitee members couldn't agree on whether The Concept map shall be implicitly generated or not. The same bunch of idiots who couldn't accept char8_t until C++20, blubbing: "but char is the suitable type for representing contiguous raw bytes" blah blah blah."_
&gt; I really feel like everyones answers relates to the things they know/understand themselves. But probably wouldn't be sure about the answers to other people questions. This right here. I do three things: * Read their résumé, and ask them about the work on it. This give me ***their*** take on their depth of knowledge. * Quiz them on a specific brain-dead-simple aspect of the language, that's too basic to appear in lists of C++ interview questions, is too obscure to be be thoroughly taught in tutorials, and too necessary not to be known by someone who has used C++ every day for any substantial length of time. This just simply tells me whether or not to believe their claims about their experience. * Give them a simple (~2hr) at-home programming test. This is to show me how they think about structuring code. (Only the first two are about understanding their depth of knowledge.) In other words, for me, it's not really about testing their knowledge. It's about testing their legitimacy, then either taking their word for it, or not.
... why did they change it? What's wrong with consistency? :(
I'd say there is always _something_ at least questionable with teaching something for instructional purposes, unless you are clear about it "we will do this for now to keep it easy, but we'll show you a better way later". I just highly suspect it isn't taught that way. It is taught as "do it this way".
Span is not a view since it allows to mutate elements.
It's not the culture in WG14. You don't discuss anything big on the reflector either, rather you submit a proposal paper first with meat on the bones, and go from there. Published proposal papers that are completely half baked and have zero chance are absolutely okay. Very different from WG21, where publishing a paper with even minor defects gets you a Reddit roasting!
Yes, US firms are especially bad on not saying whether their "remote is okay" includes non-US-residents or not. About half of US firms saying remote is okay only want US residents. The other half are fine with anywhere in the world. It's quite frustrating for anyone who isn't a US resident. The United States is not the planet!
My array_view does as well. array_view of const elements does not.
I would ask: **"What feature would you most want added to the C++ standard?"** This question forces them to identify what they know about the language, what it's missing, and how that could be fixed. It would not be good for someone without a deep knowledge of the language, but I do think it gives insight into *how deep* it is.
&gt; Again, _cxa_throw aborts immediately if no appropriate exception handler is present. I see the backtrace and believe you but this is definitely not happening on the Linux systems I worked with. How does _cxa_throw even know that there is no appropriate exception handler without unwinding the stack? For me, it unwinds until it ends up above main() or in pthread_create, where libc will catch the exception and call abort(). But then it is too late to save the stack. 
Any thoughts on the "modern" CMake convention of avoiding `set()` for things like `add_executable()` and just listing the files instead? Seems like these still use `set()` which seem to be disfavoured right now.
Then this is a topic to start a discussion. The point of such a question imo is not to judge a specific feature usage, but to find a topic they feel comfortable with, which can be discussed further.
If you could overload the dot operator it would be possible. The next best thing would be to overload the arrow operator, but that's really only used for smart pointers.
only with msvc I think. The language says you can mix them.
Developers who want to write code that's can easily be used by package maintainers should avoid explicitly making a library as shared or static. Instead they should be not declaring either and allowing the `BUILD_SHARED_LIBS` option to take precedence, unless there's some specific reason that the code is incompatible with being built one way or another. Also you may want to look at https://github.com/vector-of-bool/pitchfork and see if you can consolidate or collaborate.
Simple: RAII. This is among the most important things in the language.
won't be a good choice of question if the person has worked mostly with newer C++ variants with good practices. You can avoid landmines without knowing them by using different practices.
Does someone think `char8_t` is the suitable type for raw bytes? (It is not.)
I also wish there was. The closest thing I've found is to inherit privately like this, &gt;struct B { void foo() { } }; struct D : private B { using B::foo; }; int main() { D d; d.foo(); } but it always feels wrong to me and gets uglier if you want to do it with multiple 'components' and/or combine it with proper inheritance. &amp;#x200B;
&gt;`using string = std::string;` You can actually do `using std::string;` - no need to repeat the type name if you aren't changing it! Works with templated types like vector too: `using std::vector;`
Keywords. Just pick some of the moderately common keywords and ask about those. There are some that are obscure as heck but I think you could have an excellent interview and never leave the topic of keywords. 
That is not true at all.
That would make things so much worse than they already are with alignment. There's a reason that compilers insert padding into objects; it makes accessing members much faster. Plus it breaking backwards compatibility with x86 even worse than already, and most hardware probably doesn't even support it. And what would be the gain? It's a whole lot of downsides to just be able to directly address bits, which is a pretty uncommon issue for most programmers.
Something I always do on new C++ projects, which I didn't see here, is to enable all warnings and make warnings a compile error. The flags are different for GCC (-Wall -Werror) and MSVC (/W4 /W4) but you can use generator expressions within target_compile_options to cleanly include them. Sadly though, for MSVC, cmake always includes /W3 by default and MSVC shows a warning when multiple warning flags are defined. The only ways I know around this are to use cmake override files or a regex that replaces the relevant CXX compile flags. I can share this later if anyone is interested.
That backtrace is from a Linux system (Ubuntu 16.04 x64), for what it's worth. _cxa_throw examines the call stack (without actually unwinding it), looking for possible handlers in the exception tables, fails to find any, and then aborts. "Unwinding the stack" is a pretty nebulous concept. It doesn't happen by execution of any of your normal machine code, but rather by some external machinery which execution stays within, and then (potentially) jumps to your exception handler. So, the entire call stack exists up until that jump.
For SDL2 I'm using the following lines: target_link_libraries(Aelionauts "SDL2main") target_link_libraries(Aelionauts "SDL2") target_link_libraries(Aelionauts "SDL2_image") target_link_libraries(Aelionauts "SDL2_gfx") If you're not using add-on libraries, the first two lines should work for you.
I use them for parsing and creating some proprietary CAN messages from a radar module. The original code used bitshifts. Using bitfield structs made the code a lot more readable and less error-prone.
I prefer using `add_executable()` or `add_library()` just to define the target then use `target_sources()` to specify the source files for the target. It avoids the use of `set()`.
Well, unwinding the stack also entails calling destructors and what-not. If you actually have to find the appropriate destination twice, then I'm not surprised that throwing exceptions is slow :) But seriously: I had the thowing-uncaught-exceptions-is-not-debuggable problem several times in my career on various systems. I'm really surprise that you should get proper core dumps. I'm not sure if something changed in the exception handling or I (and my colleagues) missed something the entire time.
I won't judge anyone on that. I'm not validating his knowledge of conventions that I happened to stumble upon.
No reason to implement a linked list pretty much ever. If you _had_ to though, use `unique_ptr`. Same with a Tree. Exception would be if you wanted structural sharing, which _could_ be useful under some circumstances. Neither shared or unique pointers are appropriate for graphs (at least not in the way I imagine you were thinking of using them).
Iterators*. You can't push back on something that you are in the middle of iterating over. It's not obvious because you could in theory implement iterator as vector ref + index. It would be less prrformant. It's a good idea for a discussion with candidate.
If you have a sparse graph you're likely not going to get much better than vector-of-vector adjacency list, at least not unless you have specific needs that make this inappropriate (like huge graphs that won't fit into memory and what not).
A few comments: 1. In the static and shared library `CMakeLists.txt` there is `install(TARGETS ... EXPORT ...)` but no `install(EXPORT ...)` to actually generate the file. Any reason? 1. In the static and shared library `src/CMakeLists.txt` there is `target_include_directories("${PROJECT_NAME}" PUBLIC "${HEADER_DIR}")`. If the plan is to export targets and have them be useful then usually it's a good idea to have something like target_include_directories( "${PROJECT_NAME}" PUBLIC "$&lt;BUILD_INTERFACE:${HEADER_DIR}&gt;" "$&lt;INSTALL_INTERFACE:include&gt;") With this, consumers that depend on the exported targets will have the correct include path (interpreted relative to the package install directory). In practice I make headers their own target and just use `target_link_libraries`, like # include/CMakeLists.txt add_library("${PROJECT_NAME}_headers" INTERFACE) target_include_directories( "${PROJECT_NAME}_headers" INTERFACE $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}&gt; $&lt;INSTALL_INTERFACE:include&gt;) install(TARGETS "${PROJECT_NAME}_headers" EXPORT exports) then to use it: # src/CMakeLists.txt add_library("${PROJECT_NAME}" STATIC foo.cpp) target_link_libraries( "${PROJECT_NAME}" PUBLIC "${PROJECT_NAME}_headers" cexception) install(TARGETS "${PROJECT_NAME} EXPORT exports ARCHIVE DESTINATION "${CMAKE_INSTALL_LIBDIR}") and all together at the top-level we have # CMakeLists.txt add_subdirectory(include) add_subdirectory(src) install(EXPORT exports DESTINATION cmake NAMESPACE ${PROJECT_NAME}:: FILE ${PROJECT_NAME}Targets.cmake) install(FILES cmake/${PROJECT_NAME}Config.cmake DESTINATION cmake) To actually make use of the exported targets, have something like # cmake/${PROJECT_NAME}Config.cmake include(CMakeFindDependencyMacro) find_dependency(whatever) include(${CMAKE_CURRENT_LIST_DIR}/projectTargets.cmake) 1. Typo in `test/CMakeLists.txt`, at least for the static library repo. It uses `../source` but the directory should be `../src`. 1. Not sure why `cmake_minimum_required` is at the top of each `CMakeLists.txt`. 1. At the top of `CMakeLists.txt` in the shared and static library repos `CMAKE_BUILD_TYPE` is treated as a bool and as a string, also it is used in `option` twice with different defaults. Given that `option` is a declaration for a boolean cache variable this doesn't make sense to me.
Doesn't this prohibit downstream consumers from linking dynamically and statically to the same package in a single build? Why not build both?
thank you for correcting that! I can see how string_view deep comparison is a bit more intuitive since its immutable and basically only for strings. In that way it has a much more specific use case compared to span. I wont pretend to know the correct way to design span, but I expect the design of span's comparison would result in some complaints either way. Based on your expectations of GSL, i can definitely see where they fell short. After talking on this thread its I see that GSL is more of a future standardization playground than a well polished core library. But maybe the expectation to be a fundamental library with close tooling support would be unrealistic given the short amount of time (a few years?) and considering some of the ideas are new/unsolved (span). also afaik a lot of the work on the tooling side is a relatively new area of research. For what its worth, i dont think your expectations were "too high." I agree thats what GSL was introduced as, so i feel GSL may have been oversold a bit. That said I still strongly believe in the intent/mission of GSL, and I feel there has been a fair effort to clean up bugs as the library matures. but i definitely can see where some people were let down in terms of being able to adopt GSL. On the other hand, my expectation of GSL was more along the lines of "Oh look! span! nice!" so i feel very fortunate to talk to other people with a more critical view.
My favorite interview question is to show them the Niebler "For each arg" (https://isocpp.org/blog/2015/01/for-each-arg-eric-niebler, I slightly modify to have trailing return type) and have them tell me about the features that it is using. It covers a good amount of the feature set and gives me a good feeling for how much of the modernish stuff they know. I obviously don't fault them for having a tough time figuring it out, but it DOES give me a good feel for their comfort with the language. I can ask a few questions about it as well (plus give some hints) and start a dialog about the language features. Note that a 'pass' on that is dependent on the seniority of the job, but for the most part being able to identify a couple of C++ features and explain them reasonably enough is sufficient. I rarely/never give code where I expect the person to do anything but explain parts of it.
"Those good-for-nothing standard commitee members couldn't agree on whether The Concept map shall be implicitly generated or not. The same bunch of idiots who couldn't accept char8_t until C++20, blubbing: "but char is the suitable type for representing contiguous raw bytes" blah blah blah." That part does not belong in a discussion on a technical subject - if anywhere. Do not talk down on others, and do not call them idiots. I would expect most of the people participating in C++ standardization to be at least as intelligent and probably more intelligent and certainly have more knowledge of C++ than both you and I, and that ironically makes you look like an idiot.
&gt;Well, unwinding the stack also entails calling destructors and what-not. That's true, but this is all orchestrated by that "machinery" that lives within _cxa_throw. If you took a stack trace from within one of those destructors, you'd still be under _cxa_throw. It's possible that this varies between platforms or has changed recently. I only have experience with Linux.
&gt; That's true, but this is all orchestrated by that "machinery" that lives within _cxa_throw. If you took a stack trace from within one of those destructors, you'd still be under _cxa_throw. Well, this is kinda suprising for me, because I assumed that you are back in the frame where, well, you'd think the destructor is run. But on the other hand, I cannot come up with a reason why it has to be this way. Thanks for correcting me! I have to check again some other systems.
Except this is an intrusive solution, which does not fit everywhere. And anyway, you better use EXCLUDE_FROM_ALL in the add_subdirectory, because you rarely need to run all the targets of the projects you import and it costs a lot.
True, it all depends on the question and the person. So yeah, general recommendation: always consider the person's state and try different approaches.
&gt; What's wrong with consistency? :( Consistency is exactly _why_ they changed it. :) `string_view` is a range of an immutable sequence of characters. The Ranges TS/C++20 views are all ranges of immutable data. Hence an `array_view` should also be a range to immutable elements. `span&lt;T&gt;` is a range to a _mutable_ contiguous sequence of `T`, so it is not a "view." There's also the concern that `array_view` sounds like it is somehow specially related to `std::array` or C arrays, which isn't the case.
I have done this in the past but it is usually more trouble than its worth: new compilers, old compilers, and weird compilers always end up emitting bogus errors that then cause the build to fail.
I recommend watching this: https://www.youtube.com/watch?v=sBP17HQAQjk
I can create an auto-flair rule for Meeting C++. Would you like to pick a flair color? The existing colors are [CppCon](https://www.reddit.com/r/cpp/comments/9kcnfr/cppcon_2019_will_be_in_denver_colorado_usa_from/), [C++Now](https://www.reddit.com/r/cpp/comments/a60yih/cnow_call_for_submissions_is_open/), and [C++ on Sea](https://www.reddit.com/r/cpp/comments/9sqvyu/full_schedule_now_available_c_on_sea_february/).
If you typed iterators completely you'd be a masochist.
For a) depends who wrote the code. I've seen horror many times. For b) there are easy parts of the STL, and there are the complex parts like `std::function` that are definitely not something you'd be comfortable with right away.
They could be working on wording, in this case they probably ended up reading most of it.
It beats `char` at least, which has been used by interfaces for a long time. Now we do have `std::byte` that should be a core type and a keyword but again for reasons it didn't happen.
it is warning in clang too
Conan works quite nicely once you get the hang of it. if(NOT EXISTS "${CMAKE_BINARY_DIR}/conan.cmake") file(DOWNLOAD "https://raw.githubusercontent.com/conan-io/cmake-conan/v0.13/conan.cmake" "${CMAKE_BINARY_DIR}/conan.cmake") endif() include(${CMAKE_BINARY_DIR}/conan.cmake) conan_cmake_run(CONANFILE conanfile.txt BASIC_SETUP BUILD missing) target_link_libraries(tgt ${CONAN_LIBS}) conanfile.txt: [requires] sdl2/2.0.9@bincrafters/stable
Oh boy
For your drop view implementation you misspelled `requires` as `requres.`. Overall very interesting article and easy to understand.
example?
I don't know about you but we lost 10 years of opportunity because of ignorance of most basic Unicode knowledge among the Standard Committee members. The opinion about char8_t is unbelievably slow to progress toward the technically correct way. Pre C++11: `char8_t` is unnecessary. `char` is enough. Post C++11: Okay, apparently we need a `char8_t`. But let's provide implicit conversion between char. Also, the `char8_t` is `using char8_t = unsigned short`. That should do it. Around C++14: Let's use scoped enum `enum struct char8_t : unsigned short {} ;` Should we really need implicit conversion? Now: `char8_t` is a fundamental type. No implicit conversion between char. As it should have been added back when C++11. After my joining of Standard Committee I think sometime around 2007. First, I didn't say a word because I, as a typical Japanese programmer, use UTF-8 everyday and the needs to represent UTF-8 in a fundamental type was obvious. Then I learned not so much around SC. So I voiced my opinion but it was simply ignored. Then I learned SC as a whole don't think UTF-8 seriously even in 2010s . Well, at that time, I have no sponsor to back my seat on SC22 WG21 C++. I was just a observer and I have no veto power to the C++ Standard. Now I have and I need to voice my opinion strongly enough to let them hear the real situation.
Fixed. Thanks.
It's not a bad thing to do most of the time, at least not bad enough to harp on IMO. Programmers at that level get tripped up even by punctuation, so it's not a good idea to make them type more stuff they won't understand. If/when applications with libraries get introduced, then the nuances of namespaces can be explained.
I'm just providing two separate types because I'm still testing the template for building both static and dynamic libraries. But as first priority I need to make sure that the exciting library templates are working as expected. The static and shared library templates are going to be use to make this dynamically and statically linkable library. Last of all I can get real notes on how to improve the build of the library(s).
Thanks, good talk. The relevant section is [here](https://youtu.be/sBP17HQAQjk?t=437). His justification against building both static and shared is as follows: 1. Most library users are going to want either a static or shared version of your library 2. By building both, everyone downstream is given a choice (link statically or link dynamically) 3. The choice as to whether to link dynamically or statically is made at configure-time of libraries that depend on your library 4. If a user makes a decision (static or shared), an intermediate dependency of theirs that also depends on your library may have made a different decision which can have negative consequences It's something to consider, especially if the model of distribution for your library is being repackaged by others. It should be straightforward, if they want to support a package that contains both static/shared versions, to invoke the build system twice.
I well apply changes as soon as posable. while keeping everything as readable as possible. I am grateful for the input. The new template update will be released when 'meson' is integrated into the templates followed by some bug fixes.
The templates are both examples and fully functional projects that show CMake's use. Examples of projects that correspond with the projects well be provided after bug fixes with the existing templates and meson has bean fully or mostly integrated along side CMake. 
I will add warning flag support after I check to see if there is a command that is considered good practice by the community. 
My runtime's views are selectively mutable, thus the confusion.
Not too sure if Xcode generates cmake files but Xcode is a good ide for cpp, another one is clion where I do know that you can edit the cmake files to your own liking.
Yeah, the original proposals were the same. The committee just didn't like that the inconsistency of a mutable view and requested the new name. Said name is now used outside of C++, too. C#'s parallel is also called a `Span` for example.
I'd say Herb Sutter's cppcon talks are a great place to start. They are up on the cppcon yuotube channel
https://web.stanford.edu/class/cs193d/handouts/04-A-Crash-Course.pdf Essentially looking for an updated version of this. Unless nothing has changed? Idk haha 
Ok I'll check it out. Thanks!
Any written documents? 
View does not imply const.
View does not imply const. `span&lt;T&gt;` is a view, regardless of `T`
You will probably want to know about the C++ Core Guidelines
Very true. Thank you. 
I believe it was the other way around. C11 incorporated C++11's threading and atomics.
Of course I wouldn't type them completely... I'd use the typedef. std::vector&lt;int&gt; v; decltype(v)::iterator it = v.begin();
I believe C, adopted the C++11 memory model and not vice versa, and C++ definitely didn't wait until C++14, just so C11 could have it. I see no upsides for delaying C++ adoption of zero overhead exceptions to wait for C. First of all, even now C11 is still relatively rare compared to C99 and even C89. So it would be 2030's at the earliest before the C libraries that people commonly use took advantage of C23. &amp;#x200B; If zero overhead exceptions are ready of C++23, I would prefer that we get them and let C decide if it wants to incorporate it in C23 as they did with atomic.
The problem with you is that you whine so much that it's very hard to think of you as anything other than a dejected arse. \&gt; It probably needs a few more years before any C++ compiler implemented it even experimentally. Production-ready quality implementation may take another decade. Did they bury you under a rock 20 years ago and you just now figured out how to get out?
as long as you know c++11 then you're really not far behind at all.
Meh, I mostly do ish. 
I highly recommend this book for (re)learning c++11/14 concepts. https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996 It's a pretty fun cover-to-cover style read. It's more of a cookbook style book that gives examples of situations where you would want to use different modern c++ features.
Thanks. Exactly the sort of recommendation I was looking for
Just read the intro. This book is perfect. 
It's just silly that they didn't adopt my runtimes in their entirety :)
I don't mean to discourage experimentation in this area, but I'd strongly recommend against generally using homegrown fibers in production. Modern OSes have internal dependencies on stack allocation that are not documented and subject to change, which will then break programs attempting to allocate their own stacks. As an example, I once had to help debug a server that was mysteriously exiting without warning, not even producing a crash dump. We eventually tracked it down by Windows Error Handling dumps to a logging statement within a callback from a third-party library that was doing this kind of futzing around with the stack. Our environment was using a newer version of Windows that had additional protection against an exception handling attack. When our callback called OutputDebugString(), the OS used a common exception handling path that ran this new validation code, which promptly barfed on the broken SEH chain and fastfail terminated the process as compromised. Here's another example, of a GetTimeZoneInformation() crash with Boost.Context involved: https://svn.boost.org/trac10/ticket/10657 Looking at the context switch implementation for Windows in this library, it is already not updating the documented fields in the NT_TIB structure related to stack bounds, or the SEH chain on x86, much less required undocumented fields. The x64 version is also not saving xmm6-xmm15, which are nonvolatile and callee preserved according to the ABI. These issues are the reason that I would rather have code transformation based coroutines in C++ standard over context switching based. The former can be done on all architectures and environments, whereas context switching is not safe to do without OS support that may be missing entirely. 
Instead of set(MAIN_FILES main.cc some_lib.cc ) add_executable(main ${MAIN_FILES}) you would do: add_executable(main main.cc some_lib.cc ) The latter's the "modern" convention because it avoids possible errors with variable names, and because the variable isn't usually used in more than one place anyway.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/aeqvdl/went_insane_tried_python_for_a_while_how_do_i/eds1quo/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Well, I’d suggest CLion, it’s based on CMake and does the trick.
I'd recommend CLion or QT Creator for CMake projects.
From the guy who did it, huh? Blew his stack, I mean...
&gt; return 0 I quite like `return EXIT_SUCCESS/FAILURE`. It's standard C since forever, it might teach people that magic numbers have implied meaning whereas explicit is better and for those suffering from OCD, it might dawn that there could be a platform where these macros give different value for whatever reason.
OK, I ran across the website for Clion and it says free TRIAL. So, am I crazy, or do you have to pay for it? If I am not crazy, then why the hell is everyone so batshit crazy for something they have to pay for??? Is it not another Delphi situation?
It's also useful to show the "integration" with the shell or other callers. Also the primary reason for the return value of `main`.
maybe because they wouldn't have a development staff to work on their line of products that enterprise development shops license in the droves - given the cost of the IDE per each developer and the productivity the IDE delivers (whether it be CLion, Idea, or their Android dev IDE), or their plugin enhancement products for Visual Studio, the cost of licensing will easily pay for itself several times by improved productivity of development task
&gt; cmake always includes /W3 by default and MSVC shows a warning when multiple warning flags are defined. Is this an issue with an older version of CMake? I use `/W4` everywhere and I’ve never run into this in CMake v3.8 upwards.
Might also be interesting to mention that students and open source devs can get it for free. 
Look, I'm not a compiler writer. Even if I am, one compiler writer can't leave a dent in the current slow standard adopting situation. &amp;#x200B; A new feature must be added to the Standard, implemented in major C++ compilersm then the stable version of such C++ compiler must be adopted for production environment such as RHEL. &amp;#x200B; I really want to freeze myself for 20 years to prolong my life expectancy, to see the future where people use Range just like we use Iterators.
Uh, why comittee decided to use this strange syntax with | ? Anyway, article is good. 
I've been thinking of writing a service that makes writing CMake files easier. It would allow you to write your requirements in YAML and from that generate CMake files. If anyone is interested in using something like this please message me.
Awesome. When we make the switch (that's years away) I'll probably transition into this.
Then I'll (somebody'll) fix that file and move on. I find the fears of those namespace collisions, at least for `std`, overrated. I just introduced unity builds in our code-base (4000+ files), which as a side-effect means virtually every file in our code-base receives `using namespace std`. There were plenty of collisions due to liberal inclusion of other namespaces (e.g. `boost`) but none due to `std`.
Just to add to my previous reply: the functional style could also be present in the return int code, there is nothing stopping this approach. Two sorts of error handling are not a problem to me since I rarely use exceptions. Forgetting to check a return code could happen, but is a bug that I would fix. To me exceptions are often used to handle error checking for multiple statements at once, which makes it harder to see which statement failed and why.
Visual Studio or QtCreator
I've been planning to offer a service that converts configuration in YAML to CMake files. Would this be of interest to you?
It's an IDE, not a language/IDE combination. And it's a great one that is worth buying. Free alternatives include Visual Studio Code, QTCreator, etc., but sometimes paying for something isn't all bad, you know?
1. You don't need quotes around words when they contain no spaces. 2. You don't need to call `target_link_libraries` multiple times to link multiple libraries. `target_link_libraries(target SDL2 SDL2main SDL2_image SDL2_gfx)` would do.
UTF-8 can take up to 21 bits for code point encoding, right? And those bits can be packed in up to 4 bytes. What is the size of char8\_t and how does it work, when you store Japanese text? You must know better than most English guys.
So now I would not only have to learn cmake, but also your yaml schema. I"m not sure if that is a simplification 
Ideally you would not have to learn CMake except in cases where things go wrong. I don't have an example to give as this is just an idea right now.
However, alignment is being generally done on word boundaries, isn't it, rather than byte boundaries? Would it make much difference in practice should the compiler continue to align in the same way as it does now? Other than giving us the power to iterate and pack at the finest level should we choose to do so. I do deal with images which are 1-bit, as well as 2- and 4-bit, and all these special cases are a pain to deal with. In fact, they all get stored as a wrapped `uint8_t` value type to provide sane semantics for the containers which store them, at the expense of being wasteful of space. Direct addressable access without lots of bit-twiddling would have use for a number of applications. As you say, there are downsides, but byte-addressing does introduce limitations which are fairly nasty to deal with.
That's quite interesting as someone could 3xpect that the STL implementation may be at least the same speed as boost. They could have just taken their code. 
Yes, all three STL implementations of the regex library, plain and simple, suck. It sucked when it came out and it didn't improve over the years. On last CppCon there was a talk about "compile time regular expressions", besides being incomparable to `&lt;regex&gt;`, it blew all other regex libraries out of the water (at least for benchmarks that were showcased in the talk).
I guess it's about being able to insert to the front of the collection in a way that doesn't involve shifting N elements to the right. Additionally, as it grows it doesn't need to re-allocate and copy/move the existing elements over to a new larger buffer, in the same way a vector does.
Bjarne itself consider knowing 60% of the language.
I wrote an (untested) more or less equivalent meson for Basic C++ program: ``` # meson.build file project('myproject', version: '1.0.0', meson_version: '&gt;=0.49', language: ['c', 'cpp'], license: 'GPLv3') headers = ['file1.hpp', 'file2.hpp'] sources = ['main.cpp', 'file1.hpp', 'file2.hpp'] executable('myproject', [headers, sources], install : true) if get_option('with_tests') test_sources = ['test.cpp'] test_exe = executable('tests', test_sources) test('Test suite 1', test_exe) endif # You can also install_subdir if that is what you want, tweaking the options install_headers(headers) install_data(['README.md', 'LICENSE.md']) # meson_options.txt file option('with_tests', type : 'boolean', value : 'auto') ``` With this you also get for free: - LTO with -Db_lto=true built-in option - sanitizers for address, undefined behavior and others for free - coverage and coverage reports - optimized builds for debug, speed, size - warning levels for the compiler - ability to activate warnings as errors - profile-guided optimization - stl_debug option - flexible customizable installation following by default unix conventions - a test runner that can run a test many times and enter gdb on crash - a test runner that can wrap with a tool, for example valgrind your test suite when running A full dump of the options is here: ``` # Core properties: # Source dir /home/user/myproject/mesonbuild # Build dir /home/user/myproject/build # Core options: # Option Current Value Possible Values Description # ------ ------------- --------------- ----------- # auto_features auto [enabled, disabled, auto] Override value of all 'auto' features # backend ninja [ninja, vs, vs2010, vs2015, vs2017, xcode] Backend to use # buildtype debug [plain, debug, debugoptimized, release, minsize, custom] Build type to use # debug true [true, false] Debug # default_library shared [shared, static, both] Default library type # install_umask 0022 [preserve, 0000-0777] Default umask to apply on permissions of installed files # layout mirror [mirror, flat] Build directory layout # optimization 0 [0, g, 1, 2, 3, s] Optimization level # strip false [true, false] Strip targets on install # unity off [on, off, subprojects] Unity build # warning_level 3 [1, 2, 3] Compiler warning level to use # werror false [true, false] Treat warnings as errors # wrap_mode default [default, nofallback, nodownload, forcefallback] Wrap mode # Backend options: # Option Current Value Possible Values Description # ------ ------------- --------------- ----------- # backend_max_links 0 &gt;=0 Maximum number of linker processes to run or 0 for no limit # Base options: # Option Current Value Possible Values Description # ------ ------------- --------------- ----------- # b_asneeded true [true, false] Use -Wl,--as-needed when linking # b_colorout always [auto, always, never] Use colored output # b_coverage false [true, false] Enable coverage tracking. # b_lto false [true, false] Use link time optimization # b_lundef true [true, false] Use -Wl,--no-undefined when linking # b_ndebug false [true, false, if-release] Disable asserts # b_pch true [true, false] Use precompiled headers # b_pgo off [off, generate, use] Use profile guided optimization # b_pie false [true, false] Build executables as position independent # b_sanitize none [none, address, thread, undefined, memory, address,undefined] Code sanitizer to use # b_staticpic true [true, false] Build static libraries as position independent # Compiler options: # Option Current Value Possible Values Description # ------ ------------- --------------- ----------- # cpp_args [] Extra arguments passed to the C++ compiler # cpp_debugstl false [true, false] STL debug mode # cpp_link_args [] Extra arguments passed to the C++ linker # cpp_std c++14 [none, c++98, c++03, c++11, c++14, c++17, c++1z, c++2a, gnu++03, gnu++11, gnu++14, gnu++17, gnu++1z, gnu++2a] C++ language standard to use # Directories: # Option Current Value Description # ------ ------------- ----------- # bindir bin Executable directory # datadir share Data file directory # includedir include Header file directory # infodir share/info Info page directory # libdir lib/x86_64-linux-gnu Library directory # libexecdir libexec Library executable directory # localedir share/locale Locale data directory # localstatedir /var/local Localstate data directory # mandir share/man Manual page directory # prefix /usr/local Installation prefix # sbindir sbin System executable directory # sharedstatedir /var/local/lib Architecture-independent data directory # sysconfdir etc Sysconf data directory # Project options: # Option Current Value Possible Values Description # ------ ------------- --------------- ----------- # build_env_bin_dir /nfs/platinum.disk1/dir1/trdenv/env3/bin Bin dir to find programs # build_env_root_dir /nfs/platinum.disk1/dir1/trdenv/env3/ Bin dir to find programs # build_kind ppcap [ppcap, dat_opra] Which binary to build # Testing options: # Option Current Value Possible Values Description # ------ ------------- --------------- ----------- # errorlogs true [true, false] Whether to print the logs from failing tests # stdsplit true [true, false] Split stdout and stderr in test logs ``` 
Because... it’s a good product? Did you expect to get your whole life for free. Do you steal your food? Do you plan on living in an unpaid house?
I would say it was tricky around ~2005, the time when questions about "virtual destructor" also were very popular. hardly this question is good: compiler will always tell you if you have wrong access rights.
I'm pretty sure it was 60%.
Note that *std::high_resolution_clock* is most likely just an alias for *std::system_clock* which again is your OS provided system time (most likely unix time). On windows this will likely be *QueryPerformanceCounter()* and on UNIX this will likely be *clock_gettime()*. Any difference in their runtime cost due to hardware is more likely to be related to their respective implementation rather than anything with standard library implementation. *std::steady_clock* might be a better choice for a real-time monotonic clock for measuring the runtime of your algorithms.
Now the Unicode or UCS has emojis and people using it in any text chat, and almost all websites use UTF-8, everyone is using UTF-8. Being a Japanese has no advantage over English users. It's not that important to understand the minor details of UTF-8. The important thing is get rid of the wrong assumptions about characters and text. One char8_t is not one character. Also, one code point is not one character too. There are code points combined to represent a character or code points which select the variation of the code point immediately before. That said, I have slightly more knowledge about how Japanese are encoded in UTF-8 because I'm using it everyday. sizeof(char8_t) is 1. one char8_t object can represent any single UTF-8 unit value. Until C++17, C++ use char to represent both ordinary character and one UTF-8 unit but there is a really ugly wording. You see. Whether the char is signed or unsigned is unspecified in the standard. So for the purely standard point of view, char cannot represent all the one UTF-8 unit value. The standard solved that by magically said char can hold any one UTF-8 unit value, it's representation is unspecified but if we convert it's value to unsigned char, the original UTF-8 unit value can be restored. Most Japanese code points(those approved early in the Unicode history) fit in 16bits. It's called BMP. So most one Japanese characters can be represented by two UTF-8 units. Some CJK characters don't fit it BMP so it usually requires 3 UTF-8 units but we rarely use these character in modern Japanese.
Both AMD and Intel ( except for the Mac ) were run on Ubuntu Linux though. Do you think Linux has vastly different implementation for AMD and Intel? I would understand if the difference was between Linux / Windows.
Why not use a specialized benchmark library, like [Google Benchmark](https://github.com/google/benchmark)?
This was supposed to be a quick and easy test. I did not expect this amount of variance in the first place. I would also have missed the differences between Intel and AMD that way.
The one-liner is fine. You can shove that in a function and call it `pop_front` ;) (Don't forget the null-check of course)
I haven't looked at the `clock_gettime()` implementation in a recent kernel release. But it would make sense that this could be hardware specific and therefore differ in implementation on AMD versus Intel. [Here](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/src/c%2B%2B11/chrono.cc#L60) you can see std::system_clock implementation on GCC's libstdc++. 
&gt;From a usage standpoint there is a long standing principle that you use structs to represent data structures while a class is an object with methods. The wording is not very good: class defines not an object but a type. Also nowadays it quite common not to use struct keyword in C++ code at all. Next questions: * can you explain why such principle existed? * which methods will be created by compiler for struct and class? &gt;So you don't put any methods on the struct, only members. While a class can have both. That is too strong wording based on a custom code style. This is not very good for interview.
&gt; A structs, or specifically "plain old data" That is the point of discussion: "struct" is not more equal to "POD type" than "class".
Sure, but can't see the existing colors. Red or Orange?
Typically we (games industry) are right up to date on compilers but they won't let us use \`std::\` at all... So we both can't do this for opposite reasons!
I tested it with steady\_clock, but the results are the same for AMD and Intel.
I thought that the optimal solution for this is to use toolchain files. So one can have the strictest possible pack of flags in their CI and some optimal stuff for local fiddling.
Qt Creator does not update the CMake file, though. But you can easily add new files just by editing the CMakeLists.txt files. The IDE then automatically calls CMake and regenerate the build files. Otherwise it works really well with CMake and Ninja.
The wording of these questions is not very good for an interview. &gt;1. Why must you be cautious when using .push_back on vectors? How do you avoid this? You mean "in which conditions it is possible to avoid memory re-allocation"? &gt;2. Using the [] operator on a map can be bad, why? Why default-constructed value is "bad"? &gt;3. Explain the difference between a struct, class and template. When would you use each? There is only semantic difference between struct and class in C++, personally I wouldn't use "struct" in C++ code at all, it makes false impression of POD type. There is no difference between "class" and "template" - both are keywords in C++. For serious answer please tell me what is common between "class" and "template". &gt;6. What is the meaning of 'const' in the method definition void do_something() const; * you don't know the difference between *declaration* and *definition*. * you are using snake_case notation. * No input parameters, no output parameters and it doesn't modify state of the object, probably "something" is "log". TL,DR: I would be very careful with accepting offer from a such interviewer. 
Anyone know why it wasn't the case?
CppCon is yellowish, so I chose red. The automod has now been configured to automatically flair posts with "Meeting C++" in the title (ignoring body). If anything is incorrectly flaired or not flaired, please let the mods know. Thanks!
Yep. We had ratings all over the place until we put qualifiers next to the rating (10 was "I'm on an ISO C++ Committee") It's also why the second question is so important as it gives you a good idea where they fall on knowledge. The unfortunate problem is that a lot of people go "deer in the headlights" when you ask them the second question.
You still have to use variable for things like: `set(HEADER_FILES public_headers)` `set_target_properties(target_name PROPERTIES PUBLIC_HEADER "${HEADER_FILES }")` 
The copy and swap can be shorter too if you change the signature: \`\`\` T&amp; operator=(T rhs) { swap(rhs); return \*this; } \`\`\`
I get this on CMake 3.13. I can't remember if the warning is shown in the Visual Studio IDE but I've definitely seen it on MSVC command line builds (e.g. ninja generator).
Maybe a compromise would be to enable all warnings just for a single toolchain on the project and disable it for others? So you can still catch insidious bugs without constantly maintaining for every permutation of compilers.
First, I do not quite understand what it is you want. Is it a char8_t that is not implicitly convertible to char? Why can't you write your own then, it is not a big job? Anyway my experience is that calling other people idiots is not a good approach to achieve forward progress. 
My instinctive feeling when I see red is to avoid clicking, so psychologically red is a bad choice. What is wrong reusing an existing color - e.g. having the same color for all conferences? 
&gt;Quiz them on a specific brain-dead-simple aspect of the language, that's too basic to appear in lists of C++ interview questions, is too obscure to be be thoroughly taught in tutorials, and too necessary not to be known by someone who has used C++ every day for any substantial length of time. This just simply tells me whether or not to believe their claims about their experience. Can you give an example please? :)