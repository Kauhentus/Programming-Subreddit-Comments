Cool idea! But it would be usefull, if you add a var for the compiler and the flags. For example I use clang++ under Linux with the following flags: "clang++ -Wall -Wextra -Wpedantic -march=native -stdlib=lib++ -std=c++ -g" And it would be also usefull, if you could pass some additional compiler args. For example: ./mysource.cpp -O3 or ./mysource.cpp -O0
Allocating a smaller array and then growing it to its maximum size is not very efficient. Growing an array usually includes allocating an array with twice the size, and then copying the old data over. If you know that you will eventually use 10000 particles, you should just allocate all that space immediately. You might ask why we couldn't just allocate another array of the same size, and somehow "attach" them like a linked list of arrays, so that less memory is wasted. The answer is that we could, but the code becomes more complicated without any real benefits.
Oops. I meant vector. I agree there isn't usually a reason to use list, and it definitely isn't a replacement for am array since there's no random access.
Those aren't C-style casts, I think they're direct initializations. Anyways, it's more than excused since the OP took the time to come up with SSCCE, and it's a very real possibility that the rules would differ for C and C++ so the tagging is appropriate. While casts are a potential source of bugs (as the question shows!) they're also unavoidable at interface boundaries.
Are you aware of cling?
There are lots of alternatives to the "cppsh" thing. I made a post before and it was downvoted to oblivion. My favorite way of this is #/* output=/tmp/`md5sum main.cpp | awk '{ print $1 }'` # echo $output # check if source is newer than compiled file if [[ "$0" -nt "$output" ]]; then g++ $0 -o $output fi # exec runs command in current process exec $output # will not reach here cause exec has started $output in this process exit 1 #*/ #include &lt;iostream&gt; int main(){ std::cout &lt;&lt; "hello world\n"; return 0; } It works with g++, and the top part can be made into a script so it will be one line. Not only that, but this whole idea of "cpp scripts" is already used on servers and there are some apache modules where it will compile your c++ source files the first time they are invoked via http request. Because of the nature of C++, you can have very high level looking code with operator overloading. Ofcourse you loose speed, but it's faster than a scripting language and when speed is important (for many people it isn't but there are cases like where I work it is) you have the power to do some data manipulations really fast. To me this is really cool because sometimes just raw speed improvement in using a compile language is important with a difference of 10 to .1 seconds depending on the task.
Some background: I write a lot of C++ code, which has to be cross platform compatible, and often I just want to verify, that a code snippet behaves the same on all platforms without setting up a whole project. E.g. clang doesn't support std::chrono::high_resolution_clock properly, clang cannot compile {1,2,3} w/out &lt;initializer_list&gt; header or msvc crashes, if I want to use the format string "%F %T" with strftime. 
Glad, you like it. I'd rather recommend making 2-3 copies of cppsh in ~/bin called cppsh_debug or cppsh_strict with your favorite compile flags, so you can keep the argument list clean.
Oh noes :(
Good article: simple and complete, although I would add that the class Ray is a didactical example that It could be better implemented as: class Ray { Vector origin_; Vector direction_; public: Ray(Vector origin, Vector direction) : origin_(std::move(origin)), direction_(std::move(direction)) { ... // etc... };
I'm sorry Ponchedeburro. I must have misheard him.
Going to eat dinner, and I will be back to try some stuff.
I'm looking forward to CINT's demise.
As the sidebar points out, you should really have taken this to /r/cpp_questions. Btw &gt; type zero air trap that makes no sense. Are you misquoting?
 std::vector&lt;string&gt; names = {mild,hot,medium}; std::vector&lt;int&gt; sold = {45,...}; int index = std::distance( sold.begin(), std::max_element(sold.begin(),sold.end()); std::cout &lt;&lt; names[index] &lt;&lt; " " &lt;&lt; sold[index]; For lowest just use `min_element` instead. 
/r/learnprogramming
If you already have a programming background, I'd take a look at [A Tour of C++](http://www.amazon.com/Tour-In-Depth-Series-Bjarne-Stroustrup/dp/0321958314) or [Accelerated C++](http://www.amazon.com/Accelerated-C-Practical-Programming-Example/dp/020170353X/). Both should bring you up to speed pretty quickly on the basics, and from there you can learn more as you see fit.
Thanks for the help!
Pfft, "Concurrency in 5 Minutes"
C++ Primer plus just made a new version early this year. I liked it, written with a lot of the same ideas used in Accelerated C++, which is a book you'll hear recommendations for frequently but is a little older. 
&gt; &gt; type zero air trap I want that to be a thing.
Hm what about the link in the sidebar? Priceless username OP.
Should we be worried about there wasn't enough speakers to fill all empty hours?
I concur with Accelerated C++. It really gave me some aha! moments and you get to learn the algorithms and functions already available in the standard library
Accelerated C++ is an AWESOME book, shame there isn't a c++11/14 version. In it's place I recommend "The C++ Primer 5th Edition" which does.
Both of these, like every other online C++ tutorial I've seen, are terrible resources, don't use them.
I wouldn't bother with the Primer Plus. It doesn't seem any where near as good as "The C++ Primer 5th edition" (not plus).
Arghhh, such nice code ruined with using an `int` an index :(. `std::size_t` brother.
There is a learning series at channel 9 http://channel9.msdn.com/Series/cplusplus-language-library You may also want to check http://isocpp.org/get-started
I'm aware of this and it's really annoying, but there isn't a whole lot of choice. The set of overloadable operators in C++ isn't exactly huge, and quite frankly, anything beyond trivial monadic code won't be pretty anyway. Basically, I've found an even greater love for applicative in FTL than I already had from Haskell. There is a slight mitigation though, if you don't mind writing things in "reverse". You can use `operator&lt;&lt;=`, which at least gives you the correct associativity. I.e., like so: auto r = h &lt;&lt;= g &lt;&lt;= f &lt;&lt;= m; Which is equivalent of: auto r = ((m &gt;&gt;= f) &gt;&gt;= g) &gt;&gt;= h; Anyway, if you have a better suggestion than `&gt;&gt;=`, I wouldn't mind hearing it. However, I don't want to overload any of the logic operators, because there are definitely monadic types I'd expect them to do contextual bool conversions on. Also, bitwise XOR and OR are already used by monoids and alternatives. Obviously all the other assignment operators (`/=`, `|=`, ...) have the same associativity and priority issue. So, bitwise AND? Comma operator? Division?
For the love of god, please learn with a tutorial/book written to the C++11 standard! If they aren't using "auto" for variables, run away!
i'd love to see clang backend...
urghh the snow on the webpage is really annoying. Also just because auto func(int x, int y) { return x+y; } is legal, I seriously hope that it does't become overused.
Well, that's kind of no information. Even less information on how this speeds up anything. But at least, I now know how to checkout and build qbs and how to contribute.
Well you can't use it for declarations (because there's nothing to deduce the type from), so hopefully that'll limit usage.
Good point. You'll probably just end up with: // stupidmath.h int add(int x, int y); // stupidmath.cpp auto add(int x, int y) { return x + y; }
Right, and since you can't overload on return type this is always safe.
When I was learning I found yahoo useful. You kids have google. It's better.
My first reaction to that is that it'd be really dumb to actually do that, but wouldn't that result in a compilation error if you try to return something of a different type which could be implicitly converted to the declared return type? That could be useful sometimes.
&gt; In general, I do not like std::shared_ptr. My personal goal for shared_ptrs is to only expose them in public APIs if they're of the form shared_ptr&lt;T const&gt;
Well at least it works for someone. I had actually been mixing up Primer 5th edition and Primer Plus, Haha. 
It will be useful for templates for sure, but I can imagine it being used where for other things as well. vector&lt;double&gt; some_function() { vector&lt;double&gt; result; /* do some stuff */ return result; } why specify the return type twice? Also, I can now change the container type and the compiler will chug along happily. Of course typing vector isn't that big of a deal, but the real benefit here is that I'm not repeating myself unnecessarily. 
 int readStudentFile(int,int,int); int inputStudentRecords(int, int, int); int readStudentFile(int studentID[], int testOne[], int testTwo[]) inputStudentRecords(int studentID[], int testOne[], int testTwo[]) There's a difference here: one has arrays, the other has not. readStudentFile ( studentID[], testOne[], testTwo[]); That's wrong (and should be a compile time error (?!)): You should pass without the braces: readStudentFile ( studentID, testOne, testTwo); 
 The issue is I have to pass the what is read in from the files to an array, then pass the student records into the same three arrays. even after removing the brackets i still get the same errors on the build reports. 
Well, that's not what is linked here. Also, that "benchmark" does not really offer any insight in what is actually tested.
TIL that Sun still exists.
Rephrasing. Your declaration: &gt; int readStudentFile(int,int,int); does not match your definition: &gt; int readStudentFile(int studentID[], int testOne[], int testTwo[]) {...} Furthermore, your call in main(): &gt; readStudentFile ( studentID[], testOne[], testTwo[]); is just bonkers. If you want to pass arrays, you don't add the [] at the call site. So it should be like: readStudentFile ( studentID, testOne, testTwo);
Thanks for the comments and help guys. I ordered Accelerated C++ and C++ Primer :) 
thank you so much for your help.
Oh, very much so. It's owned by Oracle, but you wouldn't know how much shit still runs on Solaris.
you're correct, "Sun" per se, as a brand, it pretty dead, but so much of it is still out there in the wild
&gt; int fn_factorial(int i, int n) { for (i = 1; i&lt;=n; i++) return(i*i); } This isn't going to do what you want. This loop's body is a `return` statement. On the first iteration of the loop, the function will return (1 multiplied by 1), and you'll never get to the second iteration of the loop. Worse, if n is 0 or negative, the loop will immediately finish without executing its body, and you'll fall off the end of an int-returning function, triggering undefined behavior. 13 years ago, I was where you are now, so let me offer some advice - first, try to write your program with everything in main(). Yes, really. Focus on getting the loop and how it modifies your local variables correct. Once that works, then figure out how to move that code into a function. (I have a number of... disagreements with how C++ is usually taught. One problem is that tutorials try to focus too strongly on the abstraction techniques that are important for real programs. Those techniques are necessary, but what's even more necessary is having a solid foundation in how to manipulate state, write loops, handle boundary cases (like n being 0 or negative here), etc. Usually it's classes that are introduced too early, but even functions are confusing until you can write a certain amount of code.)
I love the feedback. I can definitely write a code that figured a factorial all within int main(). Trying to work on what I viewed as the "next step". Just can't the damn function workable.
I mean, technically that would work, but I don't see why you would go to all that trouble. You can do it perfectly well with one function. Honestly, you could do the whole thing in main if you wanted to. 
Somewhat off topic, I find the '-&gt;' syntax for type deduction not very idiomatic to begin with. I wish something less cryptic was used instead. I mean, things like lambda functions look messy as it is. Perhaps something like 'return_as' keyword would have made more sense? auto Foo = [](int x, int y) return_as int {return x + y;} Better still, devise a new way of declaring functions... particularly lambdas.
Although it does seem like some of their search infrastructure will remain on C++, judging from [this lecture series](http://www.youtube.com/channel/UCYEYhkwzNWRsUkTCpTmChCg).
OP deleted his account and comment. Can you post his link?
I've recently seen people using: auto methodName(int foo, int bar) -&gt; int; In their class headers. Why would you do such a thing? What's wrong with just delcaring the type at the start? I find the arrow doesn't improve readability and also increases the amount of text in the header - it's essentially fluff.
I'm pretty sure you can use it in declarations, but the definition also has to use `auto` and you can't call it until the definition has been seen: auto foo(); int x = foo(); // error at this point. auto foo() { return 10; } int y = foo(); // ok at this point.
Probably for consistency. When you're `const` overloading things also line up neatly on the right.
aaaaaaand still no support for VS2013 with the VSAddin. :( http://bugreports.qt-project.org/browse/QTVSADDINBUG-172
Can I develop QML applications for Windows desktop?
Yes, Qt is crossplatform so the apps you develop run on GNU/Linux, Windows and more.
I can wholeheartedly agree with the "disagreements with how C++ is usually taught". Prior to attending university I had spent a lot of time teaching myself C and C++ through the conventional means (websites and books) and I found that both paid education and self education through the material available usually lead to the same problems. - The extent of C++ isn't really covered as much as "C with classes" is. This teaches you the most basic benefits and uses of C++, while shoehorning many bad practices left over from C onto you - There's a significant level of misinformation posted around. I remember looking through a friend of mine's work, who was also learning C++ at the time, and seeing unwritten rules broken, such as the use of system("pause") extensively. He stated that that's how the tutorial taught him. - The best tutorials and examples are all written for complex features, functionality and idioms within the language - great if you're already a capable C++ programmer, not very good otherwise. - There's a common belief that C++ is this unwieldy and impossibly hard language that requires decades of labor just to understand at a primitive level and this transitions into the tutorials through hints of difficulty or alternate methods of completing the tutorial or "this actually has a flaw which is resolved later in the tutorial" etc. This is very off-putting to people when they first start. The list could go on, but I find that the hardest part of learning C++ isn't the hard parts of the language - it's finding the right tutorial to introduce you to the right concepts in a reasonable amount of time while ensuring you don't fall into the "C++ is just C with classes" trap and avoiding the common idea that C++ is extremely hard. Once you've been programming in C++ for a few years, the newest features (such as those introduced with C++11 / 14) seem to come naturally, even if they're brand new concepts to the programmer. Of course, this is only my personal opinion that I've based around my experience with learning C++. This was 5 years ago now, so I can totally understand if it's improved over that period.
I made the mistake of moving to VS2012 too fast. So I'm not making the same mistake with VS2013. But thanks for the heads up.
The goal was to learn the process of defining, declaring, and calling functions. I mean, I know I could do that in main.
Thank you. How about QML itself? Back in the days of Nokia, if I remember correctly, QML supported only UIs for mobile devices. Is it possible to develop desktop UIs in QML now?
&gt; It's a bad idea to rely on calling a nonstatic method through a null-pointer. Yeah, no shit.
I don't think that should be a priority, to be honest.
Yes, there is now support for QML on the desktop. But it still has a few things to learn. For example afaik most standard Dialogs are not yet implemented in QML. But Qt5.2 makes it easier to integrate Qt Quick/QML in QWidget based Applications, so you can go with the best of both worlds...
Thank you.
it looks like the code is sitting in the master branch already, so all they would have had to do is pack up a release.
just tried to install the linux 64 bit version, the installer gave me a bunch of nonsense errors and failed to install android kits. 
Shouldn't you just get it from your repo anyway?
Yes, it even says so in the update notes.
if you're actually going to develop something with qt, I highly recommend compiling your own Qt toolchain. being able to step from gdb all the way inside qt source code is invaluable.
i tried QtCreator, but it's just not comparable to VS on an IDE Level. 
if you mean the actual desktop and not Metro, then yes
Well there is still [Eclipse](http://kmix5.wordpress.com/2013/12/11/eclipse-kepler-kmix-productivity-boost/)
Yeah. I meant the actual desktop. Thanks.
Thank you.
Eclipse is multiple levels worse than QtCreator and in no way even comparable to VS. o_O It's either VS or VIM, and on WIndows i still prefer VS, although i can see QTC going in the right direction...some UI tweak are in order, though.
Are you developing for Windows?
&gt; I can definitely write a code that figured a factorial all within int main(). Show me.
`-&gt;` doesn't do type deduction, it's part of a trailing-return-type. In C++11, `auto meow() -&gt; int { return 1729; }` is valid (although pointless).
How is better C++11 support not a priority?
What do you mean by desktop UI? Obsviously you aren't talking about interfaces running on desktop. If you are talking about desktop controls on QML, look for [Qt Quick Components](http://qt-project.org/wiki/Qt_Quick_Components).
installation is running. :) Although i doubt they changed the UI too much. And i just cant get to terms with how they handle several files being opened at once. I want a tabbed interface.
Thank you. I am thinking to develop a Windows application that will read the GPS co-ordinates created with my mobile's dash cam software, and display along with the captured video and Google maps, and may be some other data. Whether I do it in .NET or Qt doesn't matter as far as learning is concerned (I have to start from scratch for either of these.) I saw the cool transition effects in QML demos. So I was thinking whether I can use QML for developing this app's UI. That was the basis for my questions here. If I can use the same code base for my Android tablet, it would be even better.
Usability. Proper code highlighting (yes i tried to customize it). I gave it a shot for several month, but it#s just not the same thing.
Yes, i'm using VAX. ;) But even without it#s better (although it takes some time to set it up properly).
Does VS has refactor, h/cpp file switching, creating methods/functions bodies in place/cpp file, change current method signature in h/cpp, etc? I miss all those and other features in VS, but it's true I didn't review last versions of it.
the h/cpp switching is something i really liked about qtc. And the refactoring. MS is in the process off adding refactoring (and there are addons), and the rest is handled by VAX quiet well. I havnt actually seriously used anything above 2008sp1, though. i wouldnt even say hard features are missing in qtc, it's more the overall usability. Take the list of opened files, for example. Why cant they just have a tabbed interface, like the rest of the world? And why are there buttons that only appear when i hover over them? I find myself searching for buttons with my mouse.
It makes sense when the return type depends on the function, such as: my_class::my_type my_class::my_method(); becomes auto my_class::my_method() -&gt; my_type; Not that my_class has been omitted in the second line.
Just to wade into this argument... :) &gt; Take the list of opened files, for example. Why cant they just have a tabbed interface...? Using tabs for file names is bad because once you've got a few open you can't see the names properly in the tabs. You end up with something like: myclass.cpp myclass.h myclasste... myclassim... mockmycl... When they are vertically stacked you can see the names properly. You still have keyboard shortcuts to switch between them, which is the best way obviously. But you can actually read the names. 
MinGW comes with its own set of bugs too. For example, its `std::random_device` isn't very random. As in, at all.
The null pointer has always existed. `nullptr` is a new name for it in C++11, but it could be referred to by `0` in all prior versions of C++. When `0` is used or compared as a pointer it is implicitly converted to the same null pointer now named by `nullptr`.
Pointless? I'd like to see you come up with something pointy-er!
I love the games list. He'd be better off listing the set of 3 or so modern AAA games not largely written in c++.
The VirtualBox drivers are still signed by Sun Microsystems, if I remember correctly.
Indeed VC++ is the best debugger out there for C++ as far as I know
Did you try ctrl + D in Qt Creator? It opens a "find me things" type combo box where you can search for things like files, classes, functions/methods, current file functions/methods, etc etc. Anyway thanks for the answers, I see VS team is adding much needed features to VC++ :)
Thats from 2001. A bit old...
This trick and much more can be found in [a lecture by Jon Kalb](http://exceptionsafecode.com/).
Just updated myself to check if other default themes were also effected (as I use dark personally). yes, the formatting is completely bogus throughout. I can only assume that they managed to lump all string representations (include single character enclosures) into 1 colour option - comments. Poor show VS IDE team, poor show. edit: to reinforce this, changing the colour of the comments through the IDE settings, will now also change the colour of all the incorrectly formatted items.
To be honest, I kind of expected this to be integrated into Qt Creator 3 in the new and shiny Qt 5.2.
Maybe you should try doing your own homework
Hey all, I'm the author of CPM. It's a package manager for C++ built entirely in CMake script. CPM acts like decentralized package managers you see in the VIM community, like Vundle, and uses Git to clone repositories. When using CPM modules, CPM allows you to statically link against multiple different versions of the same module, similar to node.js' NPM. I'd like to hear any of your feedback regarding CPM and feel free to direct any questions my way. You'll also find a list of currently registered modules and externals at: http://cppcpm.org . 
I went back to 2012 when I read that boost::serialize was not compiling in 2013. Edit: Down-voted for stating a fact, awesome! :) 
In C++11 I'd prefer to just wrap the body of the function in a lambda and pass that to a function that calls it within the try block. Slightly less boilerplate, less error-prone and IMO simpler.
Given how many points I got for [suggesting it](http://stackoverflow.com/questions/5590381/easiest-way-to-convert-int-to-string-in-c/5591169#5591169) you'd believe people had re-discovered the Graal :)
Why do you think you need to set i to 0? Do you get a compiler error, or wrong behavior?
Just to spread a bit of fear... This is a tempting trap to fall into -- I'm not convinced that current compilers and debuggers are quite up to supporting this. You end up with a unnamed lambda's on your call stack which is pretty painful when you end up analyzing crash dumps and the like. I also suspect that not all compiler optimizers are able to do a great job with these constructs as well. Before committing to something like this it's worth checking whether there are any real-world issues like this that'd get in the way.
The earliest version of CMake I've had access to and tested is 2.8.7, which CPM does work on. But it will likely work in older versions of CMake, I just haven't tested it.
The API entry point is always two levels up from the lambda. Lambdas only result in confusing stack traces when they escape the scope they were created it. The optimizations required for zero-cost lambdas in this sort of use case significantly predate lambas, since lambdas are just syntatic sugar for function objects.
No clue. That's literally the only way I could get it to work.
&gt; save_start_pos = qi::omit[boost::spirit::repository::qi::iter_pos[phx::bind( &amp;CurrentPos::setStartPos, this, qi::_1)]]; ...so much `::`.
 std::string time; std::cin &gt;&gt; time; Now you have the time in a string as either `1:00[am|pm]` or `1300`. Should be pretty easy to figure out what comes next, like checing if the string has `:` in it and determining if its `am` or `pm`. http://www.cplusplus.com/reference/string/string/
What OS and if some POSIX what does `ulimit -x` report? Also wrong subreddit → /r/cpp_questions. 
As written above, I don't see any reason for it to crash. You probably should consolidate the two file count variables and use an array instead of map. If your tweaking one count variable and not the other, you could shoot your foot off. Instead, have something like: const size_t num_files(200); FILE* files[num_files] = { nullptr ]; And then the final loop body to close becomes: fclose(file); Other than that check that fopen is actually able to open the file. MSVC will crash on fwrite if it's passed nullptr.
Thank you, I didn't think of checking the fopen, and you are correct it returns null on and after the 125th file. Is there a way to increase this limit?
No idea, but for splitting a text file you don't really need to keep every output file open. Just output to one file, close it and move on.
How is this different from ExternalProject? 
MSDN claims there is a default limit of 512 at the level of `fopen()` and 2048 at the lower level of `open()`, and it has a function [`_setmaxstdio()`](http://msdn.microsoft.com/en-us/library/6e3b887c.aspx) that claims to be able to bump the `fopen()` level up to the `open()` level. If you're using MinGW, there might be a different limit, although I would expect they would reproduce the `_setmaxstdio()` API as well. You could also just skip using the C library entirely and speak directly to the Win32 APIs (i.e. `CreateFile()`) which should have no limit. 
Not on 2013, you need to force include &lt;algorithm&gt; to get Boost.Serialization to compile. Unfortunately, VS2013 was released very close to Boost 1.55's release date, and they didn't want to make it work fully with 2013 and block the release (which is stupid IMHO since it was just a simple header include fix).
&gt; or sometime ((void *)0) Sometimes it would be, but it wasn't a valid definition. This would be done in compilers that were both C and C++ and didn't adequately distinguish the different languages within the headers.
I think we're speaking past one another. There is a very specific reason I mentioned "When 0 is used or compared **as a pointer**" (emph. added). I am well aware that `0` is *also* the integer zero (it is a bug that has bit me with varargs), but as long as you remain within a pointer context the null pointer derived from `0` is exactly equivalent to the null pointer named by `nullptr`, including the idea that it is any *pointer* type. The advantage for `nullptr` is precisely that it can't be confused by the compiler as an integer. For instance: #include &lt;iostream&gt; class Temp { int a(float); int b(float); int c(float); }; int main() { void *a = nullptr; void *b = 0; std::cout &lt;&lt; "Same? " &lt;&lt; (a == b) &lt;&lt; std::endl; // Outputs 1 // Pointer-to-member works too! int (Temp::*foo)(float) = nullptr; int (Temp::*bar)(float) = 0; std::cout &lt;&lt; "Same? " &lt;&lt; (foo == bar) &lt;&lt; std::endl; // Output: 1 } `0` even names the same pointer-to-member function that `nullptr` does. `0` is in every respect the name for the null pointer (of any pointer type) pre-C++11. It happens to be the *worst possible name* for that, which is why that's fixed in C++11, but that doesn't invalidate the fact either.
This a good but difficult question as they appear similar on the surface. At its core, CPM tries to solve a different problem than ExternalProjects. The concept of modules in CPM is very different from any notion in ExternalProjects. In a CPM module, namespaces must be created and managed in order to allow multiple different versions of the same code base to be statically linked in the same executable. This is done in order to avoid naming conflicts and to allow proper management of large and complex dependency hierarchies. There may be multiple references to different versions of one module in the dependency hierarchy, which mandates that we be able to handle multiple different versions of a module. On the other hand, CPM's idea of 'externals' is similar to an ExternalProject. But there are some differences. CPM externals are slightly easier to use since someone else will be figuring out the necessary build steps and multiplatform configuration for you. In fact, I use an external project in the my MongoDB CPM external. There are also some differences between ExternalProjects and CPM externals regarding when code is downloaded and configured. In CPM, download, update, and configuration happens at configure time, while building occurs at build time. With ExternalProjects, download, update, configuration, and build all happen at build time. CPM was initially built using ExternalProjects, but the ExternalProject mechanism proved to be a bit too restrictive. When using ExternalProjects, a cmake+build+cmake+build cycle was required to detect all dependencies.
You are correct. I just checked my boost installation and I have no serialization libs. Though, for what it's worth, they didn't compile with Intel C++ 14 either (in fact I'm missing a few more libs than my MSVC version, but nothing I use) I will fiddle with this tomorrow.
Had the same problem. I thought it was a bug due to my having Viasfora installed, but after repairing and other things, it was clear it was an issue with the update. So I rolled back. Not a big deal, it's not like there was anything in the update that affected me (LIKE FIXING THE PROPERTY PAGES LAYOUT RANDOMLY HAVING A SEIZURE).
This is weird, I tried your code and it's working. Is it possible that your issue is caused by another application that intercepts your file operations?
I actually just tried runing the same code in Visual Studio 2013 and it runs fine. I had to change fopen to fopen_s but that was it. Originally I was using C++ Builder xe5. I just this will work for now. I'm still interested in why it wasn't working before though. 
Ah, I see. It might be a limitation of the C++ Builder run-time library, then? What is FOPEN_MAX defined as in your stdio.h? **EDIT**: Nevermind, in VS it's 20.
Both VS, Notepad++ and many other editors have found good ways to make this possible (variable tab length, multiple lines of tabs, ...). With QTC, i have to keep and extra docking windows open for the filenames. In addition to my standard code/class view docking window it takes away two 'columns' of docking windows...which is too much imo. I#d much rather see more code instead. :)
What do you think of CMake after diving in extensively?
Interesting idea. After I started using tools like maven, and systems that already exist for python, perl, latex, etc. it is nice to see something like this. 
I have a question along with this around an area I have spent way too much time researching - when using G++ on Windows, what UI and simple data storage approach do most people prefer? Do you try to use the default Windows APIs or use a framework like QT or wxWidgets? I often times get the desire to go back to C or C++ coding and find myself wanting to write a simple application that needs a UI and some basic data storage that I could use on Windows but don't want to restrict to Windows. So I start looking for a UI package that is clean and simple and capable of being statically linked (I also don't like DLLs). For external storage of my data for these little applications I like being able to simply serialize objects/structures to an XML or JSON format written to a file and not worry about binary formats or databases. After a while I get discouraged trying to get some of the various libraries to compile to static libs or trying to figure out how to do basic forms and I most often fall back to doing a quick Java Swing application that uses XStream to serialize/deserialize my data objects and then I simply create a runnable jar file. I guess I've gotten too used to the "batteries included" Java JDK environment and a few 3rd party tools I've used often, like XStream, but I would prefer that some of my little apps didn't require a runtime and were simple standalone programs. My investigations seem to point to QT being a framework closest to what the JDK offers but the standard downloads don't appear to include static builds of QT, only dynamic libs. But there are instructions for compiling QT static with MinGW. Is this the best option? 
&gt;Winamp :(
There was a lot of sentiments about not wanting to add support for a compiler that was released "so recently" (in early November) on the dev mailing list in response to VS2013 bug reports when the 1.55 RCs came out. Apparently they didn't consider the RP or RC to be official releases, despite the Go Live license Microsoft provided. I can't imagine 1.55's proximity to their Git transition helped things either.
At the beginning I wasn't enthused and leaned more heavily towards scons. After working with CMake for a while, however, it grew on me. I was surprised at what I could do after I got passed the somewhat rough exterior. My biggest insights in CMake were how to effectively manage scopes and creating maps using CMake variables. I learned a lot by browsing through CMake's share/cmake/Modules directory. Especially the ExternalProject.cmake module. Now I tend towards CMake rather than any other build system when I'm starting a new project. I have been using CMake for a couple years and I've been using CPM with CMake for the passed 4 to 5 months now. I do enjoy the leverage I get by splitting my code into small reusable components. In this regard, I've been influenced by the ideas forming in the node.js community, and I wanted to see the construction of a similar ecosystem in C++. After doing a bit of research, I determined that using CMake combined with the notion of decentralized package management might be a decent approach. I felt that, out of all of the build systems I've encounted, I could pull something like this off most quickly in CMake and still help a large majority of the C++ community. Slightly off topic, but if you're interested in some of the philosophy backing CPM, see substack's video: https://www.youtube.com/watch?feature=player_embedded&amp;v=DCQNm6yiZh0 and his blog entry [many_things](http://substack.net/many_things) (a bit vitriolic at the beginning though), as he summarizes some of the philosophy behind this kind of package management well. The video was released after I had already started work on CPM, so I didn't pursue his idea of C package management in NPM but some of you may like it. It is very similar to the driving idea behind CPM modules. All in all, CMake, for me, can be a love / hate relationship. Similar to my relationship with vimscript, but not quite as sour. CMake may need its own 'learn CMake script the hard way'. 
I did find this - http://ejohn.org/blog/asmjs-javascript-compile-target/
Yes `to_string` was overdue and even now it's a underpowered, I wish `std::to_string` would be extended considerably. So that it basically did this: namespace std { template&lt;typename T&gt; std::string to_string(const T&amp; v) { std::ostingstream oss; oss &lt;&lt; v; return v.str(); } } This way an ADT with `op&lt;&lt;` would automatically get a `to_string` function. With specialisations where optimisations can be made (like for PODs). This would get 90% of the functionality people need from the likes of boost lexical case.
iOS developers complain a lot about getting 1-star reviews because their app doesn't quite work correctly on an iOS beta that they haven't even finished downloading yet, but it does have the nice effect that nearly all apps actually do get updated for new versions by the time the final release is out. Without that incentive, most developers seem happy to wait to get started until well after the final release of new versions of things.
I skimmed the spec and read the FAQ from http://asmjs.org/ and I am still cluelessas to how linking to native libraries work? How does asm.js make system calls? How can one get an OpenGL context (WebGL?)?
I replaced a CatchAll macro that provided special handling for 3 different exception types with a call to this sort of function. Interestingly enough it reduced the binary size by several megabytes (this was a large macro!)
Your reply to point 2 is slightly wrong. Using FindXXX.cmake packages with something from ExternalProject_Add is a PITA. However some libraries are starting to offer XXXConfig.cmake modules, which are like findxxx.cmake files but provided by a package. What I do in my little cmake package manager is use ExternalProject_Add then get_property(project install_dir) then set(CMAKE_PREFIX_PATH ${install_dir})
Asm.js can't link to nativr system calls. It's a subset of JavaScript so it can't do anything JavaScript can't. So yes it uses WebGL. Actually asm.js is not he most interesting piece in this puzzle (it doesn't do anything outside of Firefox). Emscripten is where the real magic happens.
Oh, I think the javascript is sufficiently optimized/obfuscated to prevent reverse engineering 
oh god javascript on the C++ subreddit, the plague is spreading
*prevent* ? No. Make it darn hard ? Yes.
You raise an interesting point. I'll start by *asm.js* and say it is not an issue. The very name (asm) is short for assembly and indeed an asm.js program is about as friendly to read as an assembly language; thus it is about as hacker-friendly than a DLL already was. On the other hand, indeed assets seem an issue. Without specific optimizations I could imagine the first time trying to enter the game being especially painful, and any change of level/zone requiring new textures/sounds would once again trigger an excruciating lag. On the other hand, careless optimizations (such as "just in time download") might prove worse, by inducing lag at critical instants. This might, indeed, be a tough challenge.
Here is the blog of the author: http://mozakai.blogspot.hu/
(I know, OP asked for a C++ way, but here are my two cents anyways) C# will be the simplest route for what you need, for the following reasons: 1. Excel interop support in C# is actually quite good, 2. C# is extremely easy to learn (at least the basics for what you probably need), 3. There are _many_ examples of how to fetch and modify data in Excel workbooks online, especially stackoverflow, 4. VSTO support is quite good for working with Excel, 5. MSFT's documentation for Excel on C# (and VBA) is decently good. I found myself in a similar situation, handed a project that had to use C# to scrape and process data from a bunch of Excel files. I tried Python/C++ libraries, but in our case it needed to be an embedded component within Excel that could be triggered transparently, so not much choice but C#. While I had never done any C# programming before, I was able to wrap up the project in about 3 weeks since it was fairly straightforward and the language resembled C++, Java, and Python (in some loose ways of course). Overall, my experience with C# was quite positive. If you really want to avoid it at all costs, then I would suggest minimizing the C# component responsibilities. For instance, you can always create a very minimal C# component that extracts the data from a worksheet and sends it to another C++ process listening for input... Hope that helps...
That's sort of what I was thinking the VBA component would do. It would extract the data from the worksheet and send it to a C++ program for processing. I could do that component in C#, sure. But I wasn't exactly sure how to go about creating the C++ part of it. One option might be to read in a .csv file in C++, right?
Sounds like you are looking for https://developers.google.com/native-client/dev/
I'd recommend to consider XLW (a wrapper for the Excel API) for this: http://xlw.sourceforge.net/ For a quick demo, see the videos: http://xlw.sourceforge.net/YouTube.shtml
Thanks! Great stuff here!
Why would anyone possibly prefer this over using their system's package manager? I actually think it's a feature of C++ to not have any kind of package manager. It's such a pain to package up Ruby and Haskell packages to play nice with the system because they bring their own package manager.
You should submit it!
Nice! I tried it with 4.8 and it did terminate (though if output goes to a terminal it sure looks infinite). Eventually it says "template instantiation depth exceeds maximum of 900" and the fun's over. $ g++ --version g++ (GCC) 4.8.2 20131017 (Red Hat 4.8.2-1) Copyright (C) 2013 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. $ time g++ error.cpp 2&gt; error.out real 0m0.447s user 0m0.364s sys 0m0.032s $ wc error.out 5424 1250660 5177191 error.out 
The LLVM compiler in xcode is a bit boring. Limits the recursion depth to 128. 
Few programming bloggers have the inclination to go and implement a red-black tree to show a technique, or run their ideas past class acts like Eric. I enjoy reading your blog immensely, please keep it up.
I'm guessing the next video will discuss moving over to smart/scoped pointers from the raw pointers you were demonstrating here?
I wonder if a CRTP would generate some nice things.
The loop's not technically infinite; if you limit the template instantiation depth to a small number like 30, you'll see it hang for about a minute and then terminate. However, the hang time appears to be exponential, so with the default depth of 900 it'll take a while to finish.
Looks like the Expected&lt;T&gt; Andrei presented at C++ and Beyond in 2012. https://skydrive.live.com/view.aspx?cid=F1B8FF18A2AEC5C5&amp;resid=F1B8FF18A2AEC5C5%211158&amp;app=WordPdf&amp;wdo=1 
When ever I get a huge amount of (unhelpful) compiler errors caused by a trivial typo I often wonder what single character change in my code would give the most errors. This could be an alternative competition, given a source file you are allowed to change a single character and then submit the length of the error messages, the longest error message wins.
The limiting factor there is obviously template depth. This (derivative, so I won't submit it) version ups the amount of error output significantly by increasing the length of the type names, while still staying within the 256 byte limit. namespace how_much_wood_could_a_woodchuck_chuck_if_a_woodchuck_could_chuck_wood_how_much_wood_could_a_woodchuck_chuck_if_a_woodchuck_could_chuck_wood_how_much_wood_could_a_woodchuck_chuck_if_a_woodchuc{template&lt;class T&gt;struct C:C&lt;T&gt;{C&lt;C&lt;T&gt;&gt;l,r;};C&lt;int&gt;_;} ___ gcc --version gcc (GCC) 4.8.2 20131017 (Red Hat 4.8.2-1) wc error.out -c 241150933 error.out 
Yes, also, all errors comes from the linker, not the actual compilation, so I'm wrong.
So far I managed to create some code that recursively creates a function with more arguments, but apparently GCC can't handle a function with 2^1024 arguments. How much memory do you have on the testing machine? On a machine with 16GB of ram I get a 1GB error; so do you have that much? :-) That's a 2.9 million score by the way... I'm off optimizing this one :-)
We have a machine with 16 GB of ram. If that runs out then we'll think of something else.
Would you mind explaining the meaning of that code for those of us less template proficient? Where does the infinite loop come about?
I just obtained a rubik's cube and I feel that the thumbnail image of this post is mocking me. :(
What does this last line do: &gt; C&lt;int&gt;_; I've edited the entire piece for whitespace: template&lt;class T&gt; struct C : C&lt;T&gt; // inherit from itself { C&lt;C&lt;T&gt;&gt;l,r; // two variables, called 'l' and 'r' of type C&lt;C&lt;T&gt;&gt; }; C&lt;int&gt;_; // what does this do? 
(Responding to my own comment). It appears that C&lt;int&gt;_; declares a variable called `_` of type `C&lt;int&gt;`. It's no surprise that this is needed to force instantiation of the type. Nor am I surprised that `_` is a valid name for a variable. But what confused me was that I was expecting that whitespace would be required between the `C&lt;int&gt;` and `_`. In hindsight, it's clear enough that it isn't really needed. The `&gt;` is obviously the end of a token and there isn't any danger that `_` would be interpreted as being part of the type.
I guess it depends if the ratio is linear or any other kind of ratio (like logarithmic).
Indeed, however we can think about it another way: - submit an entry that compiles cleanly - + a single change that provokes an error And we now measure how long this error is compared to the original source length.
Well, as pnKYe4IIA reported things get fun whenever you go the recursive way with templates; so `template &lt;typename T&gt; struct C&lt;T&gt;: C&lt;C&lt;T&gt;&gt; {}; C&lt;int&gt;_;` would probably be nasty.
That's not a good answer for me ;-) I already had the code that generated a function with 2^1024 arguments; that won't even run on a theoretical computer as there isn't enough matter in the universe to hold that function call. Already have a 21GB error on the 16GB machine though, so I guess you can be expecting a submission from me :-) How big is your harddisk? Also, please fix this: Starting measurements for type bare hands. Traceback (most recent call last): File "./measure.py", line 212, in &lt;module&gt; run() File "./measure.py", line 199, in run bare_times = measure('barehands') File "./measure.py", line 174, in measure res = pc.communicate() File "/usr/lib/python3.3/subprocess.py", line 922, in communicate stdout, stderr = self._communicate(input, endtime, timeout) File "/usr/lib/python3.3/subprocess.py", line 1557, in _communicate stderr = b''.join(stderr) MemoryError That's for the 21GB error on a 16GB machine.
 template &lt;typename... args&gt; static void d(args... a) { d(a..., a..., a..., a...); } int main() { d(42); } This is my insubmissible one. On GCC it attempts to make a function with 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216 ints as argument. This, of course, does not fit within memory. It would generate a *HUGE* error if it would. Right now it only says: g++: internal compiler error: Segmentation fault (program cc1plus) Please submit a full bug report, with preprocessed source if appropriate. See &lt;file:///usr/share/doc/gcc-4.7/README.Bugs&gt; for instructions. 
This idea can be used to generate an error that is exponential in input size. Sadly, memory use is also exponential in input size. It might help build a good submission for one of the higher limits. template&lt;class S, class T&gt; class _{ _(S&amp;,T&amp;); }; using A = _&lt;int,int&gt;; using B = _&lt;A,A&gt;; using C = _&lt;B,B&gt;; using D = _&lt;C,C&gt;; int main() { D _; } 
The measurement script has been altered to use wc. It should not crash any more. As recently posted at the official site, we are trying to work out how to limit memory and CPU usage in a fair and impartial way.
Did you put it on Git yet? It says I'm up to date... [edit] Nope, it's me being stupid with Git. Sorry! Testing it now. [Edit 2] Yes, this one works. Thanks! I'm off to create bigger failures!
And please *do* submit a bug report! 
You could run a 32-bit version of gcc. It doesn't solve the CPU usage problem, but I think it's a fair way of limiting memory usage.
First checking on gcc 4.8.2.... as a good bug submitter would :-)
Notably, this would only result in valid C code, not valid C++ code. `void*` can be cast to any pointer type in C. With C++, that would require an explicit cast. Therefore, the only correct macro definition for `NULL` in C++ was `0`. That's obviously an invitation for ambiguous code, so thankfully we now have `nullptr` as well. :) EDIT: words. I can write them.
&gt; I surprised that _ is a valid name for a variable. Identifiers in C++ are defined thusly: [_a-zA-Z][_a-zA-Z0-9]* So an ident of one character, including underscore, is completely valid. That said, it violates every coding standard imaginable.
Asm.js isn't supposed to do what web browsers have historically been used to do. Its not a highly tuned javascript engine, it's a VM for running a low-level intermediate language that can also be run by javascript engines. I'm not sure that putting battlefield on the browser will ever happen, but there's no going back from applications. Many require some code be executed quickly. Though there are other paths forward to this, asm.js is a strong contender.
Huh... so it's a kind of "Error Explosion Golf?" I like it.
whoa, i think i'm tripping out a bit here. is this anything at all like aspect oriented programming? "If" is the aspect, and "Square" and "Circle" conform to the aspect? This is the coolest thing ever... Edit: oops, meant "concept" programming! I always mix up the words aspect and concept.
And surely if `push` is going to take an argument by value it should allow to move-construct it into `Slot`, and if not it should take by const-ref. 
I don't think VC cares, but you're right that it's UB by the standard.
I feel like this is exactly the pattern that gets the C++ committee on board with move constructors. Still have no idea if a move constructor will actually be invoked, though. Feel free to help me out!
is there any downside aside except three move constructors per object creation? Also is there there easy way to use something similar to dynamic_cast&lt;&gt; with this?
Underneath it all this is still a vector of pointers to a base class, so sure, you can do any of the normal RTTI stuff. 
As written there are no moves. To get a move you'd have to write `push` like this: template &lt;typename T&gt; void push(T shape) { shapes.emplace_back(new Slot&lt;T&gt;(std::move(shape))); } (The `emplace_back` removes the need to copy or move the `unique_ptr`, not the `T` which is what we care about.) However, let's remember here that there will necessarily always be a copy operation -- that's what it means to be a value-semantic container. There are two copies of each shape object -- one as each of the local variables in `main()` and one contained in each `Slot`. So each call to `push` is either two copies (as written originally) or a copy+move (as above.)
Right you are - the warning I expect is [off by default](http://msdn.microsoft.com/en-us/library/23k5d385.aspx) but the behavior is as you expected.
That's quite interesting! There's a Bjarne quote that I think is relevant, but I can't find the source, so I'm going to paraphrase: "Only a programmer would think that performing a copy and then immediately destroying the original would be a good idea. Even a child knows that you should just move the original!" Can't help but wonder when C++ will be expressive enough for us to be able to write code more or less as it's written in this example and let the compiler figure out where in memory the store instructions should actually happen (in this case, immediately to memory on the heap*, rather than initialization occurring on the stack, followed by a copy to some memory on the heap). I guess the [load elimination](http://blog.llvm.org/2009/12/introduction-to-load-elimination-in-gvn.html) pass might catch it... hmm.. more to think about. *ok, in this case we could just do everything on the stack because the owning vector immediately goes out of scope, but let's pretend it is returned or something.
[Another](http://pastebin.com/9Q4pLDzY) implementation, which I submitted here before.
It's not a matter of compiler brains or optimizations or emitting better code or anything like that. The code as written *demands* a copy, because `s` and `c` are lvalues -- they continue to exist in `main()` after the call to `l.push(s)`. If you didn't make copies, then you would have to hold on to pointers to `s` and `c` in the container, which ties the lifetime of the container to the lifetime of those local variables, but with nothing to enforce that coupling. For example, if you returned the container from the function (pretending for a moment that this doesn't transpire in `main()`) but let `s` and `c` go out of scope, then the container is now useless, but with nothing preventing the person holding it from trying to use it and having it blow up in their face. "Here you go, enjoy this grenade that I've just pulled the pin out of. Gotta run, see you later..." That's a recipe for disaster, and it's a total abandonment of value semantics. Avoiding the copy is trivial if you instead pass rvalues, i.e. `l.push(Square())`. With the addition of `std::move()` in `push()`, there are no more copies, only moves. But since there were no copies, you don't have your `Square` object in `main` any more, as the sole copy resides in the container. You could also explicitly specify that you're okay with `s` becoming a zombie, i.e. you could write `l.push(std::move(s))` with the understanding that `s` will be cannibalized, put into a valid-but-empty state after having its contents moved out. Either way, any data in `s` is no longer usable in `main()`, unless you go through the container to access it. That's the price you pay for avoiding a copy. In languages like C# and Java where object lifetime is automatically managed, you can freely abandon value semantics to avoid copies. That's not really an option in C++ because without a garbage collector it is extremely easy to make a mistake. `std::shared_ptr` can partially fill that void but it's not exactly ideal. But value semantics avoids the problem in a much cleaner way. The downside is that the language becomes very eager to copy everything, but if you are careful about how you write code you can mostly eliminate them.
Also discussed in great deal here recently: http://akrzemi1.wordpress.com/2013/12/11/type-erasure-part-iii/
&gt; shapes.emplace_back(new Slot&lt;T&gt;(std::move(shape))); This is **leaktrocity**. If the vector has to grow, but it can't allocate a bigger chunk of memory, it can throw an exception without ever constructing a unique_ptr from your raw pointer.
Correct, I've added a virtual DTOR. Thanks for pointing this out.
That's a good point. I've updated push() to support move (using the snapshot you posted in your other comment). Thanks
Is there an official proposal for something like this? I like the idea but find the syntax pretty confusing: In the declaration of `foo` it is explicit that `object` models a concept `IFoo`, while in `bar` it looks like `IFoo` was a type rather than a type class. 
What about: shapes.emplace_back(std::unique_ptr&lt;Slot&lt;T&gt;&gt;(new Slot&lt;T&gt;(std::move(shape)))); Am I correct in thinking that this is exception safe but kind of silly because it's going to first initialize a temporary unique_ptr and the move construct it into the container, negating any reason for using `emplace_back` in the first place (but it doesn't really matter either way because moving a `unique_ptr` is as cheap as it gets)? And what about: shapes.emplace_back(std::make_unique&lt;Slot&lt;T&gt;&gt;(std::move(shape))); Does this too defeat the purpose of emplacement? How *does* one safely emplace a `unique_ptr` in a container, or is that simply an oxymoron? 
No, these are purely my personal wet dreams so far, as far as I'm aware. :) I'm unsure if concepts are even the right fit for a feature like this, but the point is exactly to provide a syntactical bridge between types and type classes. A type class in this case would essentially become an abstract interface.
Well, thank you. Good to know that ... makes the language future proof. ;) 
&gt; but there's no going back from applications. Maybe I'm just getting old and 30 is almost dead in Silicon Valley years but ... what browser apps do people use? I don't use any I'm aware of. The most "appy" thing I do with the web is using the web client for Gmail for a few accounts I only occasionally check for email. Everything else is done with native software (be it text editing, the occasional photoshop job, audio recording - even playing games). So maybe I'm some backwood redneck who hasn't seen the light but honestly I can't see where "web apps" won over native software - or where this will ever happen. 
I'm doing x86 reverse engineering from time to time and disassembly is easier to read and understand than obfuscated JavaScript. :)
Yes, each method has to be listed in both `If` and `Slot`. This more than doubles the amount of code involved in defining an interface.
I agree that "concept support" should not infect the bar method (as it does in the current proposal: forcing bar to be a template). I'd consider a non-implicit conversion `Foo` &amp;rarr; `IFoo`. Otherwise, a rogue concept included from a 3rd party header could change existing code to call the wrong overload, depending on where concepts occur in overload resolution. Now `bar(concept_cast&lt;IFoo*&gt;(&amp;foo))` would be in the spirit of existing casts but is sonewhat unwieldy. Alternatively maybe void bar(explicit IFoo * object) to force the explicit, and remain implicit by default to appease both camps, though now implicit seems to be the wrong default. 
Your title is ignorable, while the real title is noteworthy.
&gt; And what about: &gt; shapes.emplace_back(std::make_unique&lt;Slot&lt;T&gt;&gt;(std::move(shape))); That is in fact how you should do it. &gt; Does this too defeat the purpose of emplacement? Not in this case, since unique_ptr is designed to be zero-overhead over blank pointers. Actually there is no real difference between push_back and emplace_back if your container just contains unique_ptr&lt;T&gt;.
Ignoring the list itself (I would prefer exposing a standard container), I've taken to call the idea of those shims *external polymorphism* (by opposition to inheritance-based polymorphism which is internal since it requires access to the class definition). The basic is: struct IShape { virtual ~IShape() {} virtual std::unique_ptr&lt;IShape&gt; clone() const = 0; virtual void draw() = 0; }; template &lt;typename T&gt; struct Shape: IShape { template &lt;typename... Args&gt; Shape(Args&amp;&amp;... args): t(std::forward&lt;Args&gt;(args)...) {} virtual std::unique_ptr&lt;IShape&gt; clone() const { return std::unique_ptr&lt;IShape&gt;{new Shape&lt;T&gt;{t}}; } virtual void draw() { t.draw(); } T t; }; // struct Shape template &lt;typename T, typename... Args&gt; std::unique_ptr&lt;IShape&gt; makeShape(Args&amp;&amp;... args) { return std::unique_ptr&lt;Shape&lt;T&gt;&gt;{new Shape&lt;T&gt;{std::forward&lt;Args&gt;(args)...}}); } And then you can combine it with a value-like pointer: template &lt;typename T&gt; struct Id {}; // // A value-like single-slot container for T and derivatives. // // Requirements: // - if copy-ability is desired, then T should implement a "X clone() const" method with "X" convertible to "std::unique_ptr&lt;T&gt;". // template &lt;typename T&gt; class ValuePtr { public: // Typical special methods ValuePtr(): data() {} ValuePtr(ValuePtr&amp;&amp; other): data(std::move(other.data)) {} ValuePtr&amp; operator=(ValuePtr&amp;&amp; other) { assert(this != &amp;other &amp;&amp; "How is it than a temporary object is the target of an assignment ?"); swap(*this, other); return *this; } ValuePtr(ValuePtr const&amp; other): data(other.data-&gt;clone()) {} ValuePtr&amp; operator=(ValuePtr const&amp; other) { if (this == &amp;other) { return *this; } // self-assignment is not buggy, but better avoid useless new/delete. ValuePtr tmp{other}; swap(*this, tmp); return *this; } void swap(ValuePtr&amp; other) { std::swap(data, other.data); } // Would be useless if you could not store anything else than the base type template &lt;typename U&gt; ValuePtr(U&amp;&amp; u): data(new U{std::forward&lt;U&gt;(u)}) {} template &lt;typename U&gt; ValuePtr(std::unique_ptr&lt;U&gt;&amp;&amp; u): data(std::move(u)) {} template &lt;typename U, typename... Args&gt; ValuePtr(Id&lt;U&gt;, Args&amp;&amp;... args): data(new U{std::forward&lt;Args&gt;(args)...}) {} // Finally getting on to interesting methods explicit operator bool() const { return data.get(); } T&amp; get() { return *data; } T const&amp; get() const { return *data; } T* operator-&gt;() { return data.get(); } T const* operator-&gt;() const { return data.get(); } private: std::unique_ptr&lt;T&gt; data; }; // class ValuePtr And now we can relatively easily combine both: std::vector&lt;ValuePtr&lt;IShape&gt;&gt; vec; vec.emplace_back(makeShape&lt;Square&gt;()); for (ValuePtr&lt;IShape&gt; const&amp; s: vec) { s-&gt;draw(); } *Note: unlike `IShape` which is very specialized, `ValuePtr` is generic and can be reused anytime you want value semantics on a polymorphic interface.*
The gist of it all is that there's a lot of benefit to using a desktop or laptop as a dumb/thin client, provided you have internet access most or all of the time. The key here is that some benefit goes to the service provider as well as the user; the industry pushes it as much as people build demand for it. It's the whole "software as a service" thing. User Benefits: * Automatic software updates - in many cases, service software updates are remote * No needing to manage local filesystem or local resources * Possible to run applications with non-local resources - less emphasis on local computing power and performance specs for some things Provider/publisher benefits: * Easier to monetize model, with pay-per-use and pay-as-you-go working well here * Easier to support - less stuff running on client machine * Harder to pirate - requires provider controlled infrastructure to function * "cloud" infrastructure is now a commodity, making scalable deployment easy and cost-effective Feature-rich web applications and phone "apps" fit well into this model. Performance and control be damned - we have "normal" people using computers nowadays, so having complete control of one's computing environment is a bottomless time sink best avoided for these folks. Yeah, engineers, musicians, game developers, videographers, etc. will still need local stuff for performance reasons, but they're not even close to the majority of all computer users out there.
&gt; should not compile in this case, this seems to be impossible If the type can be changed at runtime, it is. &gt;So far I am returning a void* A terrible idea. What you can do: class shape_list { struct shape { ~shape() = default; virtual std::unique_ptr&lt;shape&gt; clone() = 0; // the interessting shape-methods... }; template&lt;typename T&gt; struct shape_impl : shape { T value; shape_impl(T val) : value{std::move(val)} {} std::unique_ptr&lt;shape&gt; clone() { return make_unique&lt;shape_impl&lt;T&gt;&gt;(value); } // implement shape-methods }; std::vector&lt;std::unique_ptr&lt;shape&gt;&gt; shapes; public: // ctors, adders and stuff... template&lt;typename T&gt; T&amp; get(size_t index) { return dynamic_cast&lt;shape_impl&lt;T&gt;&amp;&gt;(*(shapes.at(index).get())).value; } template&lt;typename T&gt; const T&amp; get(size_t index) const { return dynamic_cast&lt;const shape_impl&lt;T&gt;&amp;&gt;(*(shapes.at(index).get())).value; } }; int main() { shape_list shapes; shapes.add(circle{}); shapes.add(rectangle{}); shapes.get&lt;circle&gt;(0); //works shapes.get&lt;rectangle&gt;(1); //works shapes.get&lt;rectangle&gt;(0); //throws std::bad_cast } Edit: fixed bugs, should work now (or at least be close to workable) Edit2: A working version with the last minor bugs fixed and example code is here: https://gist.github.com/Florianjw/8028785
Wow. I know some folks like to be explicit, but this is an obvious case for using a typedef if I've ever seen one. typedef boost::spirit::repository::qi repository_qi; That, or judicious use of the 'using' statement: using boost::spirit; // like putting ice on a bad burn
Google docs and maps are the two that most easily come to mind, both hugely popular.
&gt; If &gt; 1 elements could be the largest, iterator to the second is returned. I think you mean "last".
This was a bug which was fixed in VS2013, which outputs: min element at : 2 max element at : 6 The standard says: &gt; Returns: make_pair(first, first) if [first,last) is empty, otherwise make_pair(m, M), where m is the first iterator in [first,last) such that no iterator in the range refers to a smaller element, and where M is the last iterator in [first,last) such that no iterator in the range refers to a larger element.
Thanks for that, will fix it
&gt; That said, it violates every coding standard imaginable. Including the coding-standard, that is mandated by the standard itself if you want to use the library: Any identifier in the global namespace that starts with an underscore is reserved to the implementation, if you want to use any standard-header. YES, that means that an include-guard that starts with one is undefined behaviour in the first line of any header. I'm looking at you, opencv (well, and countless other libs).
Why? C++ shouldn't be the kitchen sink. Graphics is in no way a language feature.
Well, C++ isn't the language only standard anymore as it used to be, it moved on to have also a better library support for a couple of things that aren't Language dependent. So, for now we have SGs on stuff like networking, filesystem, database, reflection, ..., and a new one on (simple/2d/primitive) graphics. I think its a good approach to add those libraries and abilities to the standard, still it will take years till this stuff can be used in anything else then examples. But its a good sign that C++ keeps evolving, with C++11 a new era has begun.
Start by writing a loop that prints out the numbers to be summed.
int a = 1+2+3+4+5+6+7+8+9+10; cout &lt;&lt; a;
/r/learnprogramming
Yep, I fixed this one, as I mentioned in [my VCBlog post](http://blogs.msdn.com/b/vcblog/archive/2013/06/28/c-11-14-stl-features-fixes-and-breaking-changes-in-vs-2013.aspx). Also see [LWG 2325](http://cplusplus.github.io/LWG/lwg-active.html#2325) where I filed a Library Issue begging for a footnote (I probably should have just filed an editorial issue).
What F-J-W said - when the types match, push_back and emplace_back are equivalent, so I go with push_back which is less typing.
It's being worked on. (But that's another study group.)
Yeah ASIO is really the only option unless you want to use curl with curlpp. TCP iostreams are great though. Just really wish the committee would hurry up and get networking down. I thinks it a little more pressing then graphics. 
are poco's net libs a viable alternate path?
Thanks for the input. I've been looking into my options w.r.t syntax highlighting code. I also b0rked the formatting last night when I tried correcting a typo on from my phone :(
I'd like to see it integrated as well. Just based on the compile output and the lack of excessive rebuilding alone it's worth it. I love not seeing a wall of Gcc output anymore.
I disagree with that: C++ definitely lacks library-features and a possibility to create basic images is something that could really come in handy from time to time.
I see nothing wrong with standardizing common things people want to use the language for. I'd love to be able to open a graphics object and draw some text in a font in a large size, or display a bitmap and know that whichever platform I was running my code on it would work. The entire point of the standard is to find common things that people do and define a standard way of doing them that all implementations should provide. A language without a decent library you can rely on is not very useful. 20 years ago the c++ standard library was sufficient. These days just writing text to a stream isn't sufficient.
Instead of starting a new thread I should ask here. I am reading the latest book "Tour of C++", and in that he says that a loop for accessing arrays can be used simply like for(auto i:array) Is this feature just introduced in C++11??
&gt; Linus the initiator of the project who said about C++: &gt;&gt; “inefficient abstracted programming models where two years down the road you notice that some abstraction wasn’t very efficient, but now all your code depends on all the nice object models around it, and you cannot fix it without rewriting your app.” I'm pretty sure Linus was trolling there. We really should forget about [his email](http://harmful.cat-v.org/software/c++/linus). He's probably sick of people trolling him ("Y U NO USE C++, LINUS?") and decided to troll harder. Anyway, enough about Linus, and back to this blog: &gt; *Encapsulation:Class vs File* For C++ the encapsulation is defined as the process of combining data and functions into a single unit called class. Using the method of encapsulation, the programmer cannot directly access the data. Data is only accessible through the functions present inside the class. Why would anybody think this is true? That might be the Java way of doing things, but *C++ isn't Java*. Files ('translation units') are a common way to encapsulate things in C++. You can use namespaces as well to be extra tidy. And, at a low level, you have the *option* of using classes to restrict access to the innards of certain sensitive data structures. But it is not true to say that class-based encapsulation is the *only* way, or even necessarily the *conventional* way to do encapsulation.
Agree, it seems the keyword *class* is a pavlovian reflex among developers linked to java styles, object oriented, code design. Even when every bit of the language and the standard library are toward data oriented design, with a clear distinction between data and algorithm. I wish there were more design training that work on differentiate Data and State variables...
thanks, I will use this, although I should probably stop doing *dynamic_cast* all together.
One major argument put forward to include (simple) graphics in the standard library is that it would help beginners. Currently a book on C++ can't provide a simple cross-platform hello-world-like GUI example since it would all depend on which toolkit and platform you choose to use. The reality is that it doesn't have to be that way. Cross-platform GUI apps aren't that difficult if you just limit yourself to the basics. 
To be pedantic I think you need to start with an underscore followed by an uppercase letter to be reserved, just one underscore is fine as long as it is the ONLY underscore in the type name. Still. Best to just not start with underscores. I also point out the _BLARGBLARG_H_ thing people do as being a reserved name.
I'm glad they're most likely looking to standardise something very similar to Cairomm. The Cairomm library on my system is just 140 KiB. It's a very thin wrapper around Cairo, which is without a doubt the best portable 2D drawing API out there right now. Long ago I also had the pleasure of talking to Murray Cumming on IRC, who I believe maintains (or did then) a lot of the GNOME C++ bindings (including Cairomm). From what I remember he's really nice, and pretty enthusiastic about C++. It's also exciting because it means Microsoft may end up having to play with the Cairo project, which is LGPL (or write their own backend) Also I don't think Cairomm is unmaintained, it's just not not been updated to the Cairo 1.12 API yet. There are a few commits in the tree from 2012.
It is always reserved if it starts with an underscore followed by a capital letter or *contains* double-underscore anywhere in the name. However: If you are in the global namespace, then every identifier that begins with an underscore is reserved: --- 17.6.4.1 Overview This section describes restrictions on C ++ programs that use the facilities of the C ++ standard library. The following subclauses specify constraints on the program’s use of namespaces (17.6.4.2.1), its use of various reserved names (17.6.4.3), its use of headers (17.6.4.4), its use of standard library classes as base classes (17.6.4.5), its definitions of replacement functions (17.6.4.6), and its installation of handler functions during execution (17.6.4.7). --- 17.6.4.3 Reserved names The C ++ standard library reserves the following kinds of names: — macros — global names — names with external linkage If a program declares or defines a name in a context where it is reserved, other than as explicitly allowed by this Clause, its behavior is undefined. ---- 17.6.4.3.2 Global names Certain sets of names and function signatures are always reserved to the implementation: — Each name that contains a double underscore _ _ or begins with an underscore followed by an uppercase letter (2.12) is reserved to the implementation for any use. — Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace. 
Yes: en.cppreference.com/w/cpp/language/range-for‎ 
I don't really understand why the asymmetric treatment of min / max in std::minmax_element would be a direct consequence of the choice of algorithm. E.g. [Boost.Algorithm](http://www.boost.org/doc/libs/1_55_0b1/libs/algorithm/minmax/) has 4 different algorithms. It will let you select the first/last of both the min and max element. All 4 algorithms have `O(3N/2)` complexity in the number of comparisons (and N-1 iterator increments). Their default is that `boost::minmax_element` selects the first min and the first max. This corresponds to `std::pair(std::min_element, std::max_element)`, which is probably the least surprising behavior. The `boost::first_min_element_last_max_element` corresponds to `std::minmax_element` and selects the first min and the last max. It has the nice property that it returns `std::pair(first, last)` of a stably sorted input sequence (in similar vain, it would have been nice if the Standard had originally defined `std::max` and `std::max_element` to return the second or last element in case of ties). BTW, it's not trivial, the author of Boost.Algorithm remarks: "I had to think for a while to find a way to perform only three comparisons per pair and return the first min and first max elements. For a long time, it seemed any attempts at doing so would consume four comparisons per pair in the worst case. This implementation achieves three." 
When C++ first gained popularity it was the hot thing to learn about and I imagine there was a fair amount of nervousness from C developers. I certainly remember lots of C developers being very keen to learn C++ in 1994. Since Java, C++ has lost a lot of its fashionability and a lot of C programmers have found they can simply stick with what they know. Poor C++ compilers helped form the myths that we still(!) live with today, such as using templates is asking for trouble and exception handling drastically reduces performance. I think that trying to convince *any* group of developers that a different technology is better these days is somewhat of a fool's errand. The advantages that C++ offers are simply to subtle for most developers and the flaws too glaring (no standard networking library, no standard database library for example). Personally, C++ will remain my favourite programming language until something genuinely better comes along. That language will not use garbage collection in its standard library.
I am taking a break from my multiplatform C++ programming to make this comment. C rocks for two reasons. One is that it seems that only the better tend to programmers use it. Regardless of the language this is going to make things better. The other is that C pretty much forces you to make your architecture cleanish. Needless to say we have all seen horrible C code but even then the architecture tends to stay clean. But to me the worst part of C++ is not the language but the type of programmer who often uses it. The worst C++ programmers are still trying to impress some CS professor they haven't seen in 5 years. So they pretty much use templates for absolutely everything. The &gt;&lt; keys must be pretty well worn out on their keyboards. Again templates aren't evil (as used in things like vectors and maps) but they are often taken way way too far. Plus these same people tend to wrap everything in many many classes. I am almost shocked when these people don't wrap an int in a class with multiple inheritance. When you ask them why they made something so complicated they will basically say, "I did it that was because it is how you are supposed to do it." I will then say but why is it better than (fill in simple code here)? And they will say but your way is old C style code. This is OOP programming. Then we will go in circles where I say how does it benefit the customer if their product is filled with OOP and templates? Needless to say this argument is a huge waste of time. I am not saying that OOP is bad or that C++ is bad. I see C++ as C with classes. I see modern C++ as C with Classes plus cool stuff stolen from other languages. I see the abuse of templates as some sort of way to make C++ as impossible to think through as Haskell or Lisp. My suspicion is that the abusers of classes and templates learned C++ after learning to program in Java. And the people who write clean architectures started with C and discovered that the occasional class and the awesome C++ iterators can make some parts of programming cleaner and easier. Oh, I don't really like exceptions too much either. 
I was very disappointed to see Mr. Sutter say that this isn't considered a bug (after he hinted on `operator auto` being considered for standardization). My understanding always was that part of the power of expression templates was that they could be used as optimizations so that a library author may add or remove an expression template without breaking client code. While the OP's suggestion is interesting it still means that the user of the library must be aware of the existence of the expression template which in my opinion undermines the value of having it to begin with. I wonder if anyone with real experience with writing expression templates cares to comment on whether it's practical to make expression templates `auto` safe.
&gt; Since Java, C++ has lost a lot of its fashionability Maybe, but you might agree that you're just talking about 'fashionability'. The 'cool kids' aren't as relevant as they think they are :-) &gt; I think that trying to convince any group of developers that a different technology is better these days is somewhat of a fool's errand. Definitely. It seems to a common trait among inexperienced programmers to be 'evangelical' about the one language that had the (mis)fortune to be first exposed to. I definitely went through that phase, but I grew out of it about 10 years ago :-) If I have the opportunity to correct a misunderstanding about a particular language, I'll do so, but otherwise I don't get too bothered about it. &gt; That language will not use garbage collection in its standard library. Up until about a year ago, I think I would have disagreed with you. But I've since changed my tune entirely. I've been programming full time for 15 years, the last five of which have been exclusively C++, and I'm still changing my mind on some things! It's an amazing journey - God knows what I'll think after another 15 years.
&gt; Needless to say we have all seen horrible C code but even then the architecture tends to stay clean. Not...even...close. Sorry there bub. In fact, bad C code often doesn't even have a discernible architecture.
Yep, my suggestion was to allow something like this: class some_proxy_type { public: some_other_type operator auto() const { /*...*/ } }; auto x = some_proxy_type{}; // x is an instance of some_other_type I asked whether something like this was considered and [Mr. Sutter said:](http://herbsutter.com/2012/04/03/reader-qa/) &gt;Yes, and even exactly that spelling has been suggested. I’ll take that as a +1 for discoverability if we name it that!
I am not sure that C makes you clean up your design, frankly I think that languages should not be optimized for going right from design-&gt;implementation, nobody can get the design right on the first try. The thing I really like about C is that it separates data and behavior, you can cook up some data structures and than implement algorithms over them. I really do not like the idea of tightly binding data and behavior, although it is nice in stuff like vector. C++ gives you a lot of freedom to kinda get something going without really understanding your problem, the same project in C would probably start to fail sooner if you have a rotten design. Also, error codes are a PITA.
For C++'s self-described intent as a systems language, something like a graphics library seems superfluous. What if I'm developing for a platform that doesn't have a display? Perhaps we need a new namespace for library utilities like this. ext::? util::?
Yup. Bad code is often just bad code. But I find that people tend to keep things within reasonable reach layer wise. But with C++ you might have objects calling objects for many many layers. A common design I see come over from Java is an object for every table and virtual table. None of what I said is an absolute. Just a sort of trend. Sort of like people who are throwing up are sick. Sometimes they are drunk, sometimes they are bulimic. But usually the people that I know who are throwing up are sick. 
It's just your opinion and it's not really worth all that much. Confirmation biases are everywhere and people are convinced by them all the time and of all kinds of silly things. Unless you have some REAL data to back your claims...you're just spewing nonsense. Some random duck saying, "Thems C++ guys write bad code more often...it's like a trend and stuff," isn't really worth anything to intelligent people. Blathering about some utterly unrelated thing about sick people doesn't help either.
This appears to be a homework question which is why you are unlikely to get any serious replies. Also, it's a vaguely worded homework question, so.... Anyways, a for loop in c++ is declared as such: for(&lt;variable initialize&gt;; &lt;condition&gt;; &lt;loop operation&gt;) { } It's syntactic sugar that makes code easier to read and less error-prone. The equivalent using a plain loop: &lt;variable initialize&gt; while(&lt;condition&gt;) { ... do loop stuff ... &lt;loop operation&gt; } What it says is: "assign some initial values to some variables before starting the loop. Then while the condition is true, execute the body of the loop. At the end of the loop, before checking the condition again, do some extra operation" Very commonly, you'll want to do something x times. So for example: for (int i = 0; i &lt; x; i++) { } Create a variable i for the duration of the loop. It will enter the loop with a value of 0. The loop will execute it's body x times. At the end it will increment i by 1 before checking the condition again. Thus you have to figure out how to write a for-loop to sum the values from 1 to 10. One common error in for loops is "off-by-1 errors" where you're loop counter has a value 1 away from what you expect. This is usually because loop counters are 0-indexed (i.e. start with an initial value of 0) and use &lt;. Sometimes it's more readable to use a different index &amp; to use &lt;= rather than &lt;. Good luck.
One big problem with C++ is that it has a lot more tools in its toolbox than C. This is a very big problem for open source software that is shared between many developers. When developing C++ applications, one needs to be very careful in using only the features used by the other developers. C doesn't have that problem, because its toolset is minimal. So, although C makes many things more difficult to achieve than C++, it is preferable over C++ for the kinds of projects Linus created. 
That's trivial though. Make a huge error about an undefined function, then rename an existing function to match it. Single-character error, fixes huge error.
&gt; Because in presence of multiple inheritance, the base class pointer’s address may be different to the object’s address in memory. I had a similarly weird bug caused by this a few months back. Been using C++ for 20+ years, and every now and then it still throws me a curveball.
What I'd like to see is pointer type syntax overloading. For example: class Foo {}; ptr_alias shared_ptr&lt;Foo&gt;; Foo* foo = new Foo; The foo type would be shared_ptr&lt;Foo&gt;, not Foo*. 
That would lead to very hard to read code, a pointer should stay a pointer. make_shared/make_unique is IMHO the right way.
What is hard to read about this? Foo *foo = new Foo; 
how to know if its an aliased ptr or not? For the reader in the code this is just a normal pointer. Also it makes it impossible to use different smartpointertypes with your type, as new will always return shared_ptr.
When? Always.
Why? Because people need to understand what the actual code does. And if new returns a normal pointer, who holds the shared_ptr? So if I use a different, lets say unique_ptr, I get a pointer thats held by two smartpointers?
The typos and grammar errors in this article make it unreadable for me. I have no idea what half the sentences in the second paragraph are even trying to say.
If there's a possibility that your product might become popular, someone will request a Mac version, or a Linux version. Since the development effort is the same for both, why not just use Qt?
Actually, I would prefer for the exact opposite: class foo{}; manually_managed_ptr&lt;Foo&gt; foo1 = make_manually_managed&lt;Foo&gt;(); auto foo2 = make_manually_managed&lt;Foo&gt;(); exempt_ptr&lt;Foo&gt; non_owning_foo_ptr = foo1; foo2.free(); // delete foo2 and set it to nullptr_t the name of manually\_managed\_ptr is as long as it is to make it easy to find. exempt\_ptr may be shorter (I used the name since it is actually a proposal), but it should state in the type, that it doesn't own anything; it should be possible to create one from every pointer-type. My personal opinion is that if you need many pointers (of any kind), chances are, that you did something wrong with your design. As a result of that I think the value of stating very clearly in your code what the semantics of a certain pointer are is worth much more than saving a few letters. Also: I think that make\_XXX&lt;type&gt;(...) looks better than the new-syntax.
BTW, non-commercial Qt will not allow you to link it statically to your EXE as it is LGPL.
&gt; Why? Because people need to understand what the actual code does. So you're probably not a very big fan of typedef or operator overloading. &gt; And if new returns a normal pointer, who holds the shared_ptr? So if I use a different, lets say unique_ptr, I get a pointer thats held by two smartpointers? No one. A shared pointer is not instantiated if you do: unique_ptr&lt;Foo&gt; foo = new Foo(); 
A comment from Sebastian: &gt; The other requirement is that the operator delete corresponding to the dynamic type of the object is used. That is, if you have a class Derived with an operator delete, and you delete it through a Base pointer, the compiler cannot statically determine that it should call Derived’s operator delete, but the spec says it has to. More specifically, the Standard specifies that the version of `operator delete` that is called is resolved at the point of definition of the destructor of the dynamic type of the object. Whilst this may seem rather surprising, this means that I can: - create a `Derived` class from a `Base` in a 3rd party library - and have my `Derived` class use my own library's allocation scheme - even when `delete base;` is called within the 3rd party library code (which obviously has no knowledge of my allocation scheme) I wonder how this code would fare if the OP had used the C++11 notation `= delete` to hint to the compiler that `Derived` could be neither `new`'ed nor `delete`'d. *Side note: it's a lost battle to try and prevent dynamic allocation of your type without preventing its construction; if I can construct it, I can embed it as an attribute of my own class and dynamically allocate that class...*
If you are dependent on any third party libraries/widgets/user controls, which platform are they better for?
Trying to think of a good case for disabling heap allocation. Makes total sense for simple RAII object so that they do cleanup on scope exit. If you embed it into a heap-based object then it is naturally your responsibility (or another RAII class's) to ensure that delete (scope exit) gets called. Embedding the class could event be interpreted as a misuse. Got any more ideas why one would want to disable heap allocation?
What is so hard with writing this? auto foo = make_shader&lt;Foo&gt;(); Edit: Hell, you can even be fancy and do this. auto make_Foo(Args&amp;&amp;... args) -&gt; decltype(make_shared&lt;Foo&gt;(std::forward&lt;Args&gt;(args)...)) { return make_shared&lt;Foo&gt;(std::forward&lt;Args&gt;(args)...); } And then do auto foo = make_Foo(); But I see no need for syntactic boilerplate in this case.
but can the .dll's or .so's be distributed along with the program? i think EA does that with origin, they just include the Qt .dlls needed while dynamic linking them.
Well you do get them. std::thread:: std::chrono:: Don't see why this would not get it.
As a daily C++ programmer, the more C++ "improves", the more I like C. I've seen so many C++ pointer fixes come and go that I'm not likely to try a new one until it hasn't been replaced for ten or more years. If pointers are really that hard to deal with, maybe you're in over your head and need to choose a higher level language. 
Especially since with C++14 this will become: auto make_Foo(Args&amp;&amp;... args) { return make_shared&lt;Foo&gt;(std::forward&lt;Args&gt;(args)...); } 
&gt; The RAII side you can take care of by making the constructors protected/private and then providing public static methods that return smart pointers. Can't you capture the smart_prt via a heap allocated class (e.g. vector&lt;unique_ptr&lt;lalal&gt;&gt;). Like you said, its hard to prevent RAII missuse. &gt; I would imagine that one might disable heap allocation for objects that had certain implicit realtime guarantees about allocation/deallocation, security needs that for some reason prohibit heap allocation, perhaps you want to ensure they get allocated through in a custom address space using placement new/delete (say, in shared memory), or in some way they were bound in to managing the heap itself so you want to avoid infinite recursion. &gt; &gt; &gt; &gt; Still, it is highly unusual. Aye, mutex_locks would be bad if you were to do them on the heap and something throws before the lock is deleted. 
So are you opposed to using inheritance/polymorphism as a general rule? That tends to mean you're using a pointer of one sort or another any time you need to hold a polymorphic object, no?
&gt; I'm not likely to try a new one until it hasn't been replaced for ten or more years. Well you can happily use `shared_ptr` and many others so. 
AFAIK this way is valid or not depending to whom you ask it, there is some disgrameent on that. The safest and easiest way is to put those qt*.dll side to side to your .exe and you are done.
This is a waste of time. Meyers' "Effective C++" proved years ago that you can't prevent people from heap allocating your class. More, it's really unclear why you would want to even if you could - because you're going to prevent all sorts of useful patterns that way. Take the example below - a mutex_lock. Well, there are perfectly good reasons for wanting to heap-allocate a mutex lock: unique_ptr&lt;mutex_lock&gt; lock; if (useLocks_) lock = make_unique&lt;mutex_lock&gt;(); // Code which might or might not be locked, depending on useLocks_ Try writing that code if you can't allocate `mutex_lock` on the heap - best solution forces you to extract out that block of code as a separate method or function, which might get really awful if there are a lot of local variables already...!
If you would have read my post carefully, you would have seen that I wrote “if you need **many** pointers (of any kind), chances are, that you did something wrong with your design”[emphasis added], not “if you need a pointer your design is unconditionally fucked up”. But yes: While Inheritance is a nice solution to some problems, I believe that it is heavily overused and try to avoid it if their are better solutions (and most of the time there are). Value-types are a great thing and if you need polymorphism, type-erasure is often a much cleaner and better solution (granted, it is *implemented* using a unique_ptr and inheritance, but those are extremely local in a way that greatly reduces usage of explicit pointers in the whole program).
There are still uses for raw pointers, and I think there will always be uses for raw pointers. For example, if you have some sort of tree structure where your the children were aware of their parents, the parents could store the children with unique_ptrs while the children would have a raw pointer for their parents. A ref wouldn't work because it would make it so you couldn't move any node to another parent, and the root node would essentially have a null-reference, which kinda defeats the point of having a ref in the first place. A unique_ptr for the parent wouldn't work because the parent's parent would already have a unique_ptr for the child. Of course, if you wanted to allow sharing of nodes through shared_ptr, then the parents would need to store their children as shared_ptrs as well. In that case the children would need a weak_ptr back to their parents to prevent reference cycles. But if you're not allowing access to children for clients (or are only allowing access by reference or value) then there's no reason to incur the overhead of a shared_ptr over a unique_ptr.
i just experienced using curl and jsoncpp for reading a json file and it wasn't pleasant
Dude, calm down. Let me rephrase my question. Does "many pointers" means "many types passed by pointer" or "few type hierarchies that you instantiate/pass around a lot"? I've never heard of type erasure with a unique_ptr of an inheritance class. Off the top of my head, it feels like you're just wrapping a unique_ptr, which already has value semantics, in an external type without "ptr" in it. I'd be interested in seeing an example if you have one handy.
Herb pretty much says this [here](http://herbsutter.com/gotw/_100/) in point 4. I think really it's raw new/delete that should be disappearing from most code, not pointers.
&gt; Dude, calm down Sorry, I guess I read your post a lot harsher then it was meant to be. &gt; Does "many pointers" means "many types passed by pointer" or "few type hierarchies that you instantiate/pass around a lot" Both, though with priority on the first: Pointers are a pretty low level and therefore shouldn't be a common thing in user-code. Value-types that are passed by const reference have many advantages and almost always make for cleaner code. Concerning type-hierarchies: In many but certainly not all instances templates make for a cleaner solution. I use them if you have to, but I really think a while if there isn't a cleaner solution. &gt; I'd be interested in seeing an example if you have one handy. Since this topic came up yesterday in another thread, I have: https://gist.github.com/Florianjw/8063182 Things you may note: 1. I can pass everything in, that implements the required methods in a compatible way (If I don't use the returntype of I method, I don't force one on the class that way) 2. I can clone every copy-constructable type! That's just awsome. 3. If I implement the required semantics for the outer class, I can trivially add one to itself. (No problem thanks to deep copies (which were made possible by (2.)) 4. Very comfortable interface: No pointers anywhere in the user-interface; just passing values which are moved if possible and otherwise copied 
I suppose.
I believe your proposal would allow { { 1, 2, 3 } , { 4, 5, 6 } } meaning it would have to be checked at runtime instead of compile time, which is less than ideal to me. 
That would make the constructor declaration for `std::vector` a big fat confusing lie. It doesn't really want an initializer list of initializer lists. The outer one is only there to allow this syntax you suggest, but it's only ever going to care about its first element. Sure, it would be nice if we didn't have these special cases to deal with (you really could come up with a new initialisation syntax in the *language* with no ambiguities or special cases), but uglifying some standard library class interfaces would not be a good idea.
I for one don't see the need for the change or the ambiguity in the STL with vector&lt;int&gt; i(5); and vector&lt;int&gt; i{5}; I could if they did the same thing between C++98 and C++11 but they don't; the first one creates a vector with space for 5 integers, the second one creates a vector with one with the value 5 for both versions. In cases where a constructor takes initializer_args I would expect the transition to go smoothly, so I guess I don't really understand the shortcoming.
(Responding to myself) That can be fixed. Now, I would suggest that it should take something like: std::just_one_member&lt;std::initializer_list&lt;T&gt;&gt; where template&lt;typename T&gt; struct just_has_one_member { const T m_one_member; just_has_one_member(T x) : m_one_member(x) {} }; We could then define template&lt;typename T&gt; using Initializer_List = just_has_one_member&lt;std::initializer_list&lt;T&gt;&gt;; and then use `Initializer_List` in the interfaces of the containers. Then `vector&lt;int&gt; v{ {5,6},{7,8} };` will be rejected at compile-time, as desired. *In short*: `initializer_list` should never appear (directly) in a constructor arg. It should always be wrapped up to some extent.
I think the idea was that future C++ textbooks, aimed at beginners, would simply say: &gt; We always call constructors with `{ }` The old syntax, even with library improvements, couldn't support simple initialization of containers with a literal list of values. Therefore, "something had to be done" to the core language. The initial idea was, as I understand, to *entirely deprecate* the `()` syntax for constructor call and design a new syntax around `{}`. This new syntax would be designed differently and better, and could be used to call all constructors (the new literal-list-of-values constructor, as well as the old constructors). (This would then deserve the name 'universal initialization syntax'!) More advanced users would be aware that `()` exists for compatibility. But the simple rule would be a good coding standard. If your code is going to use lambdas, and other c++11 specific things, then why not just use `{}` for *all* constructor calls. This would be a simple, consistent, rule for new and old programmers alike. It would make the most-vexing parse less of an issue. And some of us might even like compiler warnings if we used `()` for constructor args! But that backfired because, as we know, some constructors *cannot* be accessed via `()`. I'm trying to fix this; but I guess you're saying this isn't a problem. (If it ain't broke, don't fix it?) Edited: edited a lot!
You can add `tr1::shared_ptr` to that list.
&gt; That would make the constructor declaration for std::vector a big fat confusing lie. Fair point. But, in [another comment](http://www.reddit.com/r/cpp/comments/1td0dt/why_vectorint_v5_isnt_the_same_as_vectorint_v5/ce6pude) here, I suggest a new (`using`) type template, called `Initializer_List`, that would be used in interfaces and which would 'do the right thing'. Software documentation wouldn't be any more confusing than now, as a result.
C++ lets you do *anything*, it's powerful and the better choice.
I agree it's a waste of time, but as far as your example goes I would suggest writing it using an std::unique_lock using the defer option as follows: std::unique_lock lock(mutex, std::defer_lock); if(useLocks_) { lock.lock(); } ... There are other ways of rewriting that depending on your coding style/preferences, but they all have the same end result. Associating every lock with a memory allocation and every unlock with a memory deallocation is a serious performance penalty. Now let's say unique_lock did not allow policies like std::defer_lock, or in general you're working with some expensive resource that you may or may not make use of, then even in that case using heap allocation is the wrong choice, instead the right data type for that is to use std/boost::optional. Basically heap allocation should only be used when you really have no way of statically determining what the extent of your object is, or you're working with polymorphic collections of objects. Otherwise boost/std::optional provide excellent pointer-like objects that can optionally be constructed.
I think you meant to say "non-commercial Qt will not allow you to link it statically to your EXE as it is LGPL if you don't want to distribute the source of your program along with it".
Making changes that break popular existing code is infeasible. 
I would be in favor of changing the Standard to mandate first-first again, but with 3N/2-ish complexity. When we talk about 2325 I'll bring it up.
I actually like your proposal. It lends itself to an easy rule: Always use {} for construction and if you want a sequence use {{...}}. Also it solves a problem where you might want the default constructor and the std::initializer_list constructor to be different. A real life example is the dynamic class in the Facebook folly library. If you look in that file, there is a comment explaining why dynamic cannot be default constructed. Here is the excerpt from dynamic.h * Note: dynamic is not DefaultConstructible. Rationale: * * - The intuitive thing to initialize a defaulted dynamic to would * be nullptr. * * - However, the expression dynamic d = {} is required to call the * default constructor by the standard, which is confusing * behavior for dynamic unless the default constructor creates an * empty array. * * Additional documentation is in folly/docs/Dynamic.md. You technique would resolve this problem and allow dynamic to be default constructible, and differentiate from the empty array via {{}}
There's another reason that this is a terrible idea - you shouldn't be using `shared_ptr` as your default memory management class - you should be using `unique_ptr`, which is significantly more efficient, but more, it's conceptually more solid. Life is much easier if you know who owns each pointer. Nearly always, when I see people's designs with `shared_ptr`, it's a code smell - it leads to a problem that can be fixed.
C++ got clownshoes 
This is probably because you're using VS2013, not VS2005 or VS.NET like he is, and the FTLK libraries aren't compatible.
Okay I'll check into another version. 
&gt; Can't you capture the smart_prt via a heap allocated class (e.g. vector&lt;unique_ptr&lt;lalal&gt;&gt;). Like you said, its hard to prevent RAII missuse. I'm not sure I grok the problem with the vector&lt;unique_ptr&lt;lalal&gt;&gt; example. RAII isn't about avoiding having things on the heap. Sure, a non-RAII compliant allocation of some object breaks RAII for all other objects contained by the violator, but if you imagine *all* classes using the protected constructor/static method allocator idiom I described, the problem case wouldn't compile. &gt; Aye, mutex_locks would be bad if you were to do them on the heap and something throws before the lock is deleted. That's not the scenario I was describing. That's exactly the kind of thing you address by preventing construction without concurrent construction of a smart pointer. There's no problem with the heap allocation of mutex_locks per-se, but you want that heap allocation be tied to the initialization of some object. class LockUser { unique_ptr&lt;Mutex&gt; foo; MightThrowWhenConstructed bar; public: LockUser(...) : foo(Mutex::heap_allocate(...)), bar(...) {} }; That's not a problem at all.
Ya, I have looked around there a few times. This is not my first attempt to learn C :P
I stopped reading before the author made any sort of point.
The Qt DLLs are quite large, if you just need a commandline app. Furthermore there are some features you don't really get with Qt but with Boost like Spirit, Graph, compile-time checked variants, MPL and so on. Actually I think the overlap is not that big, Qt just does some things which also STL does, but in a Java style...
Well most systems nowadays except for Windows will have qt installed anyway so library size is not really a concern. In the other cases you mention, I agree, qt doesn't have that but they also arguably more niche cases. Boost is a monster. ;-) 
Yes, you're right in that concern, but by procentage, how many of the systems are running Windows? It is still the mayor player... 
You could use boost::optional and keep it stack allocated.
To be honest, I like the standard behaviour just fine. Why should using {} for old constructors and {{}} for initializing be better than () for old constructors and {} for initializing?
I think the motivation is to be able to tell students of the language to always use `{ }` for initialization. However, the proposed cure is far worse than the poison. You can still give students a consistent statement by saying to use `{ }` when you want to give a literal list of initial values. Other forms of the constructor where you aren't giving a list of values need to use `( )`. And let's not forget that it isn't just `std::vector` that's affected here: std::string foo(33, '.'); // a string of length 33 std::string bar{33, '.'}; // a string of length 2 ("!.") What's being proposed is a full-on API gut and remodel. Not going to happen in anyone's lifetime. If there was a time for this discussion, it was 2007/2008 when `std::initializer_list` was being debated by the working group. OP is about 6 years too late. 
- if you don't want anyone to decompile your code easily
&gt; This was supposed to avoid bizarre, difficult-to-debug-and-explain situations such as the most-vexing parse[1] No. It was supposed to allow aggregate initialisation of containers, similar to what already worked (even in C) for arrays and PODs. That `{}` gives us a uniform initialisation syntax was almost certainly an afterthought. The current behaviour is exactly as intended. It’s a pity that all this talk of “uniform initialisation” causes people to misunderstand this, but that’s an issue of communication, not of syntax. *That said*, I agree that it would have been nice if the standard had introduced the distinction you make, i.e. using `{…}` for true constructor calls, and `{{…}}` for `std::initializer_list`.
How is this &gt;“Discussions, articles [or] news about the C++ programming language or programming in C++.” ? This really should go to /r/cpp_questions or /r/learnprogramming.
&gt; No. ... I'll admit I'm not aware of the history of this. I'm just "reverse engineering" a justification based on my, limited, knowledge of where c++11 ended up. I should be more careful. Anyway, I *think* I've got it sorted now. As far as I call tell, *Three* changes were introduced. First, a simple way to specify a literal list was introduced. This was a really simple extension that, as far as I know, didn't risk breaking anything. auto x = {5,6}; // this is an initializer_list&lt;int&gt;, verified with typeid(x).name() (all my experiments done with clang 3.3) This first change has nothing to do with constructors. You could use these to call functions. `void foo(initializer_list&lt;int&gt;); foo({5,6});`. Also, these literals can be used to pass an arg to an old-style `( )` constructor without any further languages changes. Just define an extra constructor vector&lt;int&gt; v( 5 ); // five elements vector&lt;int&gt; v( {5,6} ); // calls the initializer_list constructor That code above works, as expected, in c++11. It's has it's disadvantages, but at least it's very clear about which constructor will be called, *In other words, if a constructor call uses `(` around its args, then we know that the initializer_list constructor will be used if, and only if, the next character is `{`.* The second change was to allow `{ }` to be used instead of `( )` to enclose constructor args. (But they cannot be used for args for other functions or methods). Now we can write, vector&lt;int&gt; v{ 5 }; // five elements (Read on, the meaning of this has changed in "full" c++11) vector&lt;int&gt; v{ {5,6} }; // calls the initializer_list constructor *However*, a further change was introduced which further changed the meaning of this. If they had stopped here, they only possible justification (IMHO) would be that it would avoid the most-vexing-parse. Let's call this language "c++10" - it is c++03 with two non-breaking extensions: literal initializer_list, and the *option* to replace `(` with `{` around constructor args. This language, c++10, is essentially perfect I think. And solves all the problems anyone had. *But*, some people might find the double `{{` to be slightly wasteful. "Why does C++ require two braces all the time?" Anyway, The third change (distinguishing my hypothetical c++10 from the real c++11) is the complicated, and perhaps controversial, change. The first two changes introduced 'new' functionality, but this third change actually *modifies* the meaning of the second change. Informally, if you have two braces `{{` in a constructor call, you can (optionally) drop one of them. More precisely, if the compiler sees a constructor call with a brace, it will first attempt to rewrite the `{ ... }` as `({ ... })`. If this is valid under c++10, then it is used. If not, it will rewrite it as `( ... )` and then proceed. &gt; That said, I agree that it would have been nice if the standard had introduced the distinction you make, i.e. using {…} for true constructor calls, and {{…}} for std::initializer_list. Assuming my breakdown of the "three changes" is correct (a big assumption!), then the surprising this is that they already had the functionality you (and I) want, but they introduced more complicated stuff, simply in order to break this functionality! The approach we want would have led to a simpler standard, not a more complicated one! Extra: Basically, I like the c++10 defined above. It does require `{{` or `({` to use initializer_list constructors, but I consider that a feature, not a bug. I think the third change should not have been made. However, I will close with a compromise: if the compiler sees `{ ... }` it will attempt to rewrite it as `( ... )` and as `({ ... })`. If both are valid, this *should* be deemed ambiguous and the user should be forced to disambiguate. If only one is is valid, then it will be used. The problem with c++11 is that it introduces a tie-breaker where one wasn't needed. We're back to the most-vexing-parse again, an unnecessary tie-breaker!
C#/WPF/WinForms practically tie you to one platform, this is a deal-breaker for me.
Please don't. I've seen so many broken, unsafe, horrible implementations of vectors. Unless you really need that one last bit of performance, your vector will almost always be worse than a std::vector. And most of the time, just using a custom allocator or emplace_back() will be enough for getting more performance.
Ok, they wrote a big piece of software, noticed they were running into performance issues with `std::vector` and so designed their own. Discussing **that** would have made for an interesting article. Instead they give us **this** article, full of hand waving with only one weird benchmark. And I say weird because they lose out to Clang 3.0's `std::vector` by more than x2.6. Only when they change the semantics of the operation do they get a performance benefit. But then even that change is dubious, personally I can't think of any use case for resizing a vector without initialisation which is not covered by `reserve()`. Maybe my imagination is limited here, but I'm not writing the article, if the author had a good reason why `reserve()` isn't sufficient then why not share it. But then it gets worse, the author openly admits &gt; but to be quite honest I actually wasn’t aware of this aspect of `std::vector` behaviour before we switched (elements being zeroed on vector construction or resize) and so was already writing code as if element values were undefined. So this guy is encouraging us to consider rolling our own vector classes when he doesn't even know how `std::vector` works. 
Ah, it seems this article is a post about a post. The original, with comments, is at [Roll-Your-Own Vector](http://upcoder.com/3/roll-your-own-vector/). Seems in those comments Herb Sutter basically raises the whole `reserve` issue anyway. There is a followup post [Avoid resize()?](http://upcoder.com/4/avoid-resize/) which acknowledges this. It and the comments are worth reading too for whole story.
I better article would detail how to use `std::vector` efficiently, rather than showing how to reinvent the wheel. Also their coding style is absymal. `c` prefixes really? 1990? The use of `&lt;stdlib.h&gt;` and `&lt;string.h&gt;` rather than the C++ equivalents.
For the lazy: /r/cplusplus --- I provide direct links to lesser known subs mentioned in the title if one isn't already provided. Let me know if I need to try harder: /r/LazyLinkerBot
Stuff like this is almost pointless with things like move semantincs and noexcept features available in C++11. 
&gt; Constructors are called when calling a function void f(Class&amp;&amp;) as f(Class(42)), but not when called as f(std::move(c)). Honest question: how is that a pitfall? The first code literally has a constructor call in it while the second doesn’t. The code does what you tell it to. Certainly that cannot be surprising. I’d find any other outcome way more surprising.
When presented a choice in making an application that has a potential to use a lot of resources, I choose C++ for computations and GUI written in C#/WPF. Interop isn't complicated in most scenarios, and I **personally** think that WPF is superior to Qt in regards to GUI (both aesthetic and productivity).
Did you know about the one with [universal references and the copy ctor](http://ericniebler.com/2013/08/07/universal-references-and-the-copy-constructo/)?
They are also misusing rvalue references. It should just be `void f(Class);` and then you can either copy the object in with `f(c)` or move it in with `f(std::move(c))`. It's `Class`'s move constructor that takes an rvalue reference argument. You should rarely have to use an rvalue reference argument for a function that is not a move constructor.
~~Luckily the code does what it should -- nevertheless I found it surprising that a difference is made. I expected some sort of isolation between the exact call of a function and its behavior (I expected the compiler to not make a difference between a `move`d rvalue and a real one).~~ ~~But you're right, it's not really a (dangerous) pitfall.~~ obsolete as mistake in post has been fixed.
Expect `f` to be a function which has reasons to only accept rvalues.
You expected to create a temporary object without calling its constructor? I don't see that being intuitive.
Ugh. Every time in my career so far that somebody tries to reinvent the STL it always ends up like this. The real problem is that they just didn't understand how to use it, they are profiling with checked iterators on, etc. It's possible that like back in 1997 there were crappy STL implementations, but at this point if there was a general purpose way of writing std::vector that was more efficient don't you think that's how std::vector would be implemented? Don't even get me started on re-implementing your own allocators, memcpy, etc. This stuff is like "old programmer's disease". Oh so you have some special insight that the person implementing the OS didn't have? Show me the benchmarks or else I don't believe you!
Pointers to member function's are not like other function pointers: http://stackoverflow.com/questions/12006854/why-the-size-of-a-pointer-to-a-function-is-different-from-the-size-of-a-pointer Also just because your compiler align's everything on the stack to the word size does not mean other compilers do. (Visual Studio aligns char arrays to the processor word size, Clang does not) Generally programmers tend to rely on the (undefined) behavior of their favorite compiler, this is not as bad if it results in compiler errors but can be pretty bad if it breaks the run time in exciting ways.
&gt; f(**Class(42)**) What would you expect `Class(42)` to do other than call a constructor for Class? This has very little to do with `f`.
`Class(42)` is a C-style cast. It could do a variety of things.
Yes, that is also a C-style cast.
`Class(42)` isn't valid C. In C++ it's called a functional cast.
It has exactly the same effect. It is _not_ a constructor call.
A C-style cast and a functional cast can both call constructors though. I was mostly pointing out the name difference.
Yes. That is one possible outcome. Thank you.
True, sorry for my too short explanation ;)
Perfect them, we have a way to statically link Qt without the need to open app's code. Thanks for the information.
&gt; at this point if there was a general purpose way of writing std::vector that was more efficient don't you think that's how std::vector would be implemented? Yep. There's only one thing vector won't do, and that's storing stuff on the stack. Such a "Small Vector Optimization" is forbidden by the need for swap() to be non-iterator-invalidating. Allocators are also forbidden from returning memory inside themselves, so you can't be sneaky. However, allocators are allowed to return memory that happens to live on the stack in a separate object.
Might be a borderline beginner issue, but calling a virtual function from a constructor [doesn't do what you'd expect](http://stackoverflow.com/questions/962132/calling-virtual-functions-inside-constructors) and can be a pain to debug if you're not familiar with the problem.
The Most Vexing Parse has bitten me a few times. It's never taken me more than a few minutes to diagnose, it's always just a F9 -&gt; "huh?" -&gt; read message -&gt; "god fucking damn it" -&gt; use brace initializers.
No, don't do that. Even if it 'sort of works' then breaking object on purpose by going against given API is _way_ worse then rolling your own whatever. By using reserve instead of resize, you would also have to keep track of the actual elements count. Please, don't use reserve when you want non-initializing vector. Roll your own and follow the API. 
Eh? You just must not index the yet to be created elements. All it is, is a change in how you write code. Reserve when you know you will be adding elements soon, initialize only when needed via push/emplace_back and only iterate up to [0, .size) or [.begin, .end). 
Seem to me you are forcing std::vector to do something peculiar rather than the other way around. But I can see how both views can be correct. What I mean: std::ifstream(file_path, std::ios::binary); std::vector&lt;uint8_t&gt; f((std::istreambuf_iterator&lt;char&gt;(ifs)), (std::istreambuf_iterator&lt;char&gt;(ifs))+100); Late edit: I "missuse" vectors all the time. As long as you know what you are doing so you avoid the bullets.
Heh. These are the *fun* bugs - the soul-draining bugs invariably involve locales.
I'd be a fan of having a small-buffer optimized vector in the standard library (I once considered using `std::basic_string&lt;Foo*&gt;` before I stopped being dumb and just rolled my own), but it seems like far too situation of an optimization for `std::vector` even if it was allowed.
That's what the dynarray TS is for.
Slicing is pretty non intuitive.
There is a reasonable (albeit small) use case for having separate overloads for `f(T&amp;&amp;)` and `f(const T&amp;)` instead of simply `f(T)` when *moving* `T` is expensive. Typically you accept by value when you plan to move the argument into internal storage. Doing so requires the contents of the object to move/copy into the formal argument, and move once more into the target internal storage. By instead overloading on both `f(T&amp;&amp;)` and `f(const T&amp;)` you can reduce that to a single move/copy to the internal storage.
http://home.roadrunner.com/~hinnant/stack_alloc.html
Thanks didn't know they existed.
&gt; Also there are very few compilers that support c++11 (that's what I believe) You believe wrong. The first C++11 features began trickling into gcc [starting in version 4.3](http://gcc.gnu.org/projects/cxx0x.html) (released March 2008), only it was called C++0x then because the standard had not been ratified, but certain features had already been identified as being approved for the standard even in 2008. Preliminary C++11 support [began in Visual Studio 2010](http://msdn.microsoft.com/en-us/library/hh567368.aspx) (released April 2010), although [a few features were included in VS2008 (VC9)](http://blogs.msdn.com/b/vcblog/archive/2010/04/06/c-0x-core-language-features-in-vc10-the-table.aspx). [C++11 support in clang](http://clang.llvm.org/cxx_status.html) is excellent from version 2.9 (released April 2011) onward. Today the current version of each of those compilers all support the vast majority of C++11, some even declaring it feature complete except for very obscure features that few people will need. You can find a fairly good although slightly outdated comparison table [here](http://cpprocks.com/c11-compiler-support-shootout-visual-studio-gcc-clang-intel/) that also includes the Intel compiler version 13, which supports the major C++11 features. The current work is on adding C++14 support, although it's still technically C++1y since we can't be sure it will be ratified next year, but it almost certainly will. [gcc has a separate C++14 status page](http://gcc.gnu.org/projects/cxx1y.html), and the vcblog has a [C++14 status post](http://blogs.msdn.com/b/vcblog/archive/2013/06/28/c-11-14-stl-features-fixes-and-breaking-changes-in-vs-2013.aspx). In short, the idea that tools don't support C++11 is complete nonsense. It might be the case if you're forced to use outdated tools, but the current version of all major compilers has excellent C++11 support. I would definitely read the 4th edition. 
GCC and Clang have full C++11 support and MSVC 2013 has great coverage as well. TC++PL book is not a guide or tutorial to C++ but a reference book. If you find Tour of C++ difficult to grasp you will struggle with TC++PL too. What is your experience with other languages and with C++? How well do you know other languages? Frameworks? 
by all means go for c++2011. https://github.com/ahupowerdns/cplusplus2011-tour has a little list of "here's how the coolness works" that be more accessible than the grand tour. There might be environments where people will hate you for forcing them to upgrade their compiler, but it will pass soon enough. Go for 2011!
Unless you are forced to work with a very old compiler, go with the 4th edition and c++11. It looks like a completely new language and book. 
Now I know what you meant: I wrote "constructors" instead of "destructors". (now fixed)
Well, interesting enough -- didn't know that one either.
Fixed mistake in post: I wrote constructor instead of destructor :P
I do know that. I just mixed "constructor" with "destructor" in the post :P
Thanks a lot for clearing many doubts!! just shows I am come to the right place!
I have coded almost all these three years in C. But I have also grasped OOPS concepts, design patterns, data structures etc. They seem to be easy to learn but difficult to implement. I have done some web development using PHP and JS. I know basic concepts in programming. And I have struggled in Tour of C++ with respect to why these new concepts has been introduced. The answer is simple, as I have not programmed upto that level which requires me to work in tight memory constrains. If I would have had some experience there, the C++11 concepts should have made sense to me. Nevertheless, I am understanding all aspects so far, syntactically!! It will make sense only when I put them to a good use!
Thanks for your valuable advice, appreciated!
as far as FOSS is concerned, gcc is used and it has full support for C++11, as said by Rhomboid ( just cam to know :P ) So i'll go with the fourth edition of the book!
This happened to me while ago: auto fut1 = something_async([]{ return connection1.close(); }); auto fut2 = something_async([]{ return connection2.close(); }); fut1.get(); // block until ready fut2.get(); // block until ready // cleanup done, exit program // ^ mean bug: fut1 and fut2 are actually `future&lt;future&lt;void&gt;&gt;` 
The upcoming 3.4 release of clang (due before Christmas) not only supports all of C++11, but also all of (what will almost certainly be called) c++14. See http://clang.llvm.org/cxx_status.html for compiler status and http://libcxx.llvm.org/cxx1y_status.html for library status.
Ok, but for every call to a constructor there will be a corresponding destructor call, unless there is a memory/resource leak. So it's still not really a pitfall.
I always is a fan of linux/unix and open source tools!!and i always use g++ with vim!! :) 
How about C++ Primer?Latest Edition?
&gt; It might be the case if you're forced to use outdated tools, but the current version of all major compilers has excellent C++11 support. Not a grammar quibble (even though I really wanted to :-) ) but just a note that Visual Studio doesn't yet support _all_ the C++11 features. [Here's](http://msdn.microsoft.com/en-us/library/hh567368.aspx) a list of what's supported and what isn't. Note that all the STL stuff IS there, with the exception of C++1y's `make_unique` (but it's really easy to find implementations of it online...) Do note that VS2013 isn't quite ready for prime-time - at least, the first version was pretty buggy, haven't had a chance to check out the most recent one. I'd suggest planning to use VS2012 and perhaps you'll be happily surprised when 2013 becomes mature. That said, you'll notice that nearly all the important features of C++11 _are_ supported, even by VS2012. Things like "inheriting constructors", "variadic templates" or "initializer lists" are useful, but easy to work around if you don't have them. I strongly agree, you should be using C++11. If you are planning to compile for VS, you should be trying that out fairly early, just to make sure you don't happen to run into a missing language feature. EDIT: downvoting without commenting? Hmph. Corrections are always welcome, but I'm pretty sure that what I wrote is quite correct...
I try not to go overboard tbh. 
What year do you think this is?
&gt; Here's a list of what's supported and what isn't. I posted a [prettier colored table](http://blogs.msdn.com/b/vcblog/archive/2013/12/02/c-11-14-core-language-features-in-vs-2013-and-the-nov-2013-ctp.aspx). &gt; Note that all the STL stuff IS there, with the exception of C++1y's make_unique Huh? We [shipped make_unique in 2013 RTM](http://blogs.msdn.com/b/vcblog/archive/2013/06/28/c-11-14-stl-features-fixes-and-breaking-changes-in-vs-2013.aspx), because [I designed it](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3656.htm). &gt; Do note that VS2013 isn't quite ready for prime-time - at least, the first version was pretty buggy **Argh, no!** There's a huge difference between the Nov 2012 CTP (an alpha build), 2013 Preview, and 2013 RTM. Comparing 2012 RTM (or any Update) to 2013 RTM, *2013 has significantly fewer bugs* and no major regressions that I'm aware of (in the compiler and STL; I don't really use the IDE). The significant compiler bug that I'm aware of (temporaries in initializer lists lead to silent bad codegen) is not a regression because 2012 didn't support initializer lists. None of the significant library bugs (facet allocation mismatch - fixed for the next major version!, call_once() being horrible, the clocks being horrible) are regressions. Upgrading to 2013 RTM immediately is the best thing to do. As Microsoft's STL maintainer, I am acutely aware of our compiler and library bugs (as I report the former and fix the latter for the next major version). I'm not saying that 2013 doesn't have any bugs - I'm saying that it is way better compared to 2012. &gt; Things like "inheriting constructors", "variadic templates" or "initializer lists" are useful, but easy to work around if you don't have them. Having worked around the lack of variadic templates for 6 years, here is what I have to say to that: **No.**
It looks like everyone is recommending the 4th edition, but I'm going to have to be the odd man out. I think you would be better served by the 3rd edition. Not because of language features, but rather the writing style and the target audience. To quote the Preface of the third edition: &gt;This third edition is the result of a rewrite of even larger magnitude. It offers something to even the most experienced C++ programmer,; at the same time, this book is easier for the novice to approach than its predecessors were. Meanwhile the fourth edition states: &gt;This book assumes that its readers are programmers. If you ask, "What's a for-loop?" or "What's a compiler?" then this book is not (yet) for you; instead, I recommend my 'Programming: Principles and Practice Using C++' to get started with programming and C++. Furthermore, I assume that readers have some maturity as software developers. If you ask "Why bother testing?" or say, "All languages are basically the same; just show me the syntax" or are confident that there is a single language that is ideal for every task, this is not the book for you. I own the 3rd edition, but not the 4th. I'm just going by the above and various information I've gleaned from various sites about the 4th. Preparing for the onslaught of downvotes...;)
I'm def going to pick up a copy. I have the third and loved it, but need the updates on C++11 Does the 4th preserve the instructional style that was prevalent in the third? For instance, the Advice and Exercise sections at the end of each chapter?
In my opinion it's a great book. It covers everything important (except std::thread) and explains it very well. It's also easy to read for non-english people.
But I know all the questions he has asked in the preface of the fourth edition. But still, thanks for an honest reply! :) 
C++ Primer 5th edition is a great book for learning C++11. It's more readable than Stroustrup's book in my opinion. I see the latter as more of a reference book.
Looks like this works out real slow (vector construction from stream iterators). See the discussion in my follow up post here: http://upcoder.com/4/avoid-resize/ But apart from speed, it seems a bit inflexible to have to recode your whole construction code path with an iterators paradigm just to avoid resize() calls. And what if you need to interface with some third party code that takes a pointer to a typed buffer to be filled? One of the cool things about C++ for me is exactly that it _can_ interface with all sorts of lower level code (as in the file read example).
Yes I am also thinking the same. I will read that book first followed by TC++PL 4E. Does C++ Primer has sufficient examples?
I test my software with both gcc and clang, on both Linux and MacOS (and occasionally the other OS), so I end up using both gcc and llvm. Once you learn the slightly different syntax, it's essentially the same experience for me.
I have a very different question (sorry to hijack this thread!). I already (think I) know a lot of C++ - I've got a few thousand points on StackOverflow from C++ questions. But I've never read a programming textbook on it, and I'm always worried that there's some huge part of the library that I'm not aware of that would help me greatly. Is there a good book that does a thorough, but non-patronising, tour of C++11? And maybe even has some advice on design? Just because I think I can answer any question on StackOverflow, that doesn't mean I should be writing important software :-) (One 'known unknown' for me is threading. I've done a fair bit of parallel processing, via MPI, but there's a whole lot more that I should have some awareness of.)
I have a somewhat similar background: I learned C++ via bad web-tutorials and searched together my stuff. So I never recieved a solid education on it but over time I dug deep into the topic and became good enough to be now known as someone who really knows much about C++. So my personal recommendation would be: * “Modern C++ Design” by Andreij Alexandrescu. That book really gave me a few new insights about what can be done with templates, even though it is now somewhat outdated since it only covers C++98 * “Effective C++” by Scott Meyers: Read it if you have some spare time (it is a much lighter reading than the above and relatively thin), But if you have been using C++ for a while and read articles about it, you are unlikely to learn many new things. * “C++ Coding Standards” by both of the above: Somewhat like Effective C++: The table of contents tells most of it and most of it is nowadays somewhat common sense. I never read more than one or two chapters of TC++PL. The reason for that is that I know the vast majority of what it tells me and if I need to look up I either use http://en.cppreference.com/ or directly the standard. The result is that I see little gain in reading many hundred pages for a very small gain in knowledge. One thing that I read much are the standardization-papers (available at http://www.open-std.org/JTC1/SC22/WG21/docs/papers/) but that is unlikely to teach you much about todays C++ (even though you can get knowledge about the future-directions).
Thanks! I've seen a couple of talks and blog post by Meyers, he's a really good communicator.
How you learned the language then? Do share your experience here. Maybe it will be helpful for people who want to learn quickly :)
Indeed.
I'm by no means against calls to resize, especially if the resulting code is faster and still safe. I just try to stick with "heavy" and safe mechanisms and start replacing them with low-end when I profile and identify the choke points. A few days I replaced a stringstream used to convert strings to doubles/floats to just a atof call and cast it to float if necessarily (a few structural changes, but nothing significant). Instant 6x speedup (from 5minutes to 50seconds). The other choke point is reading via getlines. Will probably use a large-ish buffer and manually find new lines. What I'm trying to say is, code safe first, recode to be fast later when the app is running OK and speed is needed.
I won't even be quarter of your age now. Thanks for the polite version of "There are no shortcuts kids!!" :) Thanks for taking out valuable time for answering me such brilliantly! :) 
&gt; I won't even be quarter of your age now. Actually, I'm only 33. Born in 1980, so yeah I learned a little Commodore BASIC when I was only 8 or 9 years old I think. Although, I guess I exaggerate. I know I did a Tetris clone on the C64, but I guess I would have been a bit older when I did that. At 8 years old, I probably wasn't doing anything useful with the language. &gt; Thanks for the polite version of "There are no shortcuts kids!!" :) Well, I think there are some shortcuts nowadays. I didn't have the internet to help me all the time. For example, I had to go to the university's labs to access (very slow) internet. Nowadays, I can access good blogs and references and video tutorials. [This video](http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11) is useful if you want to know a bit more about r-value references, for example. Those resources didn't exist even 10 years ago, and it wasn't easy to access what little there was. Nowadays, it's easy to go online on and pick up little bits of information, if you already know what your question is. But there is something more comprehensive about a good book to fill in all those gaps (things you didn't know you didn't know), and I think that's what I'm missing. I think I will buy those books that have been recommended for me elsewhere in this thread.
I think in that particular case only the first element is initialized to 1 and the rest are default initialized. So that would look like: {1,0,0,0,0,0,0,0,0,0} But I agree that is something I have considered. If you want a similar effect using make_array you'll have to write out each argument: make_array(1,0,0,0,0,0,0,0,0,0); // yuck!
Exactly. It might be done along the lines of make_array&lt;10&gt;(1) -&gt; {1, 0, ..., 0}, make_array&lt;&gt;(1, 2, 3, 4) -&gt; {1,2,3,4}... or something similar.
Yes it would be nice to do this. Fortunately there is already proposal for this -&gt; [N3824](http://isocpp.org/files/papers/N3824.html) And implementation -&gt; [make_array](https://gist.github.com/lichray/6034753) It also support this code: make_array&lt;long int&gt; (1,2,3); Not sure how it is compared to you implementation ...
(**Update: Turns out my idea here isn't new. The code referenced by /u/remotion4d does the same thing, using `{{args...}}` to construct an array**) This, surprisingly simple, piece of code seems to do the same thing #include&lt;iostream&gt; #include&lt;array&gt; using namespace std; template&lt;typename FirstType, typename ...Others&gt; struct first_of_many { typedef FirstType type; }; template&lt;typename ...Args&gt; auto make_array(Args&amp;&amp; ...args) -&gt; std::array&lt; typename first_of_many&lt;Args...&gt;::type, sizeof...(args)&gt; { return {{args...}}; } int main() { auto a = make_array&lt;long int&gt;(21,53); for (auto e : a) { cout &lt;&lt; '\t' &lt;&lt; e; } cout &lt;&lt; endl; } The trick here is to use `{args...}` to use parameter unpacking to build an initializer list which is used in the constructor of the array. Also, because it's an initializer list, the compiler forces them all to be the same type anyway. No need to explicitly test for this. You'll get a warning something like `template.cpp:14:11: error: type 'double' cannot be narrowed to 'int' in initializer list [-Wc++11-narrowing]` (clang 3.3) Also, I've done some limited testing with `make_array&lt;long int&gt;(1,2);` in order to force the element type. Seems to work, but needs more testing. *Any feedback appreciated. There may be problems with this. I haven't tested it much.*
Considering all the possible ambiguities in the definition (just look at the other comments), it will do more harm than good. In this case, *keep it simple* actually means keep it as it is. Besides, it would introduce another possible asymmetry in usage: std::array&lt;int, 3&gt; get_array() { int a, b, c; // do stuff with a, b, c return { a, b, c }; // vs: return std::make_array(a, b, c); } This already exists with `std::pair` vs. `std::tuple` and it's ugly (there is a proposal to fix it, IIRC).
&gt; You basically need to lock the weak_ptr into a shared_ptr, then convert. How does that work? Do you temporarily bump the ownership counter or something?
The refcount control block actually contains two refcounts: strong and weak. The strong refcount is incremented every time a shared_ptr is copied (etc.) and controls the lifetime of the owned object. When the strong refcount hits zero, the object is deleted. The weak refcount is incremented every time a weak_ptr is copied (etc.) and controls the lifetime of the control block. When the weak refcount hits zero, the control block deletes itself. This is how weak_ptrs can sense that the object has expired, because the control block will still be alive with a strong refcount of zero. (shared_ptrs need to keep the control block alive too, so you might initially imagine that the weak refcount is the number of shared_ptrs plus the number of weak_ptrs. This would mean that shared_ptr copies would have to increment both refcounts. But as an optimization, it's easy to say that all shared_ptrs share one weak ref. That way, as shared_ptrs are constructed/destroyed, only the strong refcount needs to be incremented/decremented. When the strong refcount hits zero, then the weak refcount is decremented once, because all the shared_ptrs are gone.) weak_ptr::lock() is special, because it allows you to take a weak_ptr and get a shared_ptr to the object if it's alive, or an empty shared_ptr if it's expired. This happens *atomically*, even as the refcount is bouncing around due to other threads creating/destroying shared_ptrs to the object. lock() essentially says "I want to increment the strong refcount if it's already nonzero. But if the strong refcount is zero, I don't want to touch it". Such a conditional atomic increment can be implemented with compare-exchange compiler intrinsics. Once lock() has been implemented, weak_ptr conversion just temporarily locks to get a shared_ptr. If the shared_ptr is empty then it stores a null pointer (the object is dead, nobody needs a pointer to it anymore), and if the shared_ptr is nonempty then we can do the pointer conversion, followed by releasing the strong ref.
You know what's really silly? std::unique_ptr&lt;T[]&gt; exists, but std::shared_ptr&lt;T[]&gt; doesn't. So if you have an array that needs to be properly deleted, not only do you need to manually provide the custom deleter, but you also can't use std::make_shared since there is no overload with a deleter (not that it would be possible in the first place as the variadic args are fowarded.) Seems like a little slip from the standardization committee as I don't see a valid reason why it wouldn't be in there.
If you go with the fourth edition make sure to get the third printing, many typos/errors in the first two.
Hm, a tad worrisome that the unit constructors are not explicit, can enable mixed mode passing instead of enforcing unit notation calls. Edit: Anyone know how to get in contact with the author?
Hope they do something like Go does, where a typedef is a *new* type and not just a type alias. Maybe using MyNum:int; since I doubt they will introduce a new keyword. Usecase: int foo(MyNum){} int bar(int){} int main(){ foo(1); //Error, can not convert int to MyNum bar(1); //OK bar(MyNum{1}); //Allow type to decay?? bar(decay(MyNum{1})); //Explicitly decay the type, similar to std::move, only different semantics at play }
How does that get you anything that a wrapper class wouldn't (say with an explicit constructor and explicit operator int)? Other than the extra boilerplate code, I guess. For that you could always define a generic class PrimitiveWrapper&lt;typename UnderlyingType, typename SomeTag&gt; that would reduce the boilerplate to declaring an empty tag struct to differentiate the particular uses of the wrapper. 
Ulrich Drepper &lt;drepper@gmail.com&gt; 
Knowing the size of an array is a very common thing in programming, though I admit knowing the instantiation values is a little less common but it still comes up. Video games can make use of a function like this since a number of statistics can be known at compile time (in a 2D game perhaps you know the tile size of a board, in a 3D game perhaps you want an array to hold all of the textures for a specific model). Also if you really need it, once you instantiate the array with default values you can always use `std::allocator` or `::new(place)` for constructing objects in place if you really need it.
Just to clarify, isn't he that crazy nut job that deliberately retarded gnu libc until they eventually got rid of him? 
Ah thanks. Started writing a test case to submit, found it behaves OK (in VS2010, expect that the behavior is the same in G++) If you call it as auto ve1 = european_bsm(0.4_volatility, 5.0_months, 50.0_dollars, 50.0, 0.1_percent_peryear, 0.0); Since args #3, #4 share the template type the compiler will complain about the ambiguity (is the type double or u_dollar). Though I'm still not sure if its fine to leave implicit conversion enables, since this call should compile and run just fine: auto ve1 = european_bsm(0.4_volatility, 5.0/12, 50.0_dollars, 50.0_dollars, 0.1_percent_peryear, 0.0_percent_peryear); The args that are doubles are implicitly converted inside the european_bsm function to u_unit types. Worse still is the #2 argument which represents months, which will on implicit conversion be *again* divided by 12. The problematic line: auto di = sigma * sqrt(T); If T is of type double and sigma is type u_sqrt_ratio_peryear this is the transformation of types: auto = u_sqrt_ratio_peryear * sqrt(double) auto = u_sqrt_ratio_peryear * double Best match for operator* is inside the u_sqrt_ratio_peryear struct auto operator*(const u_sqrt_years&amp; r) const which involves one implicit conversion from double to u_sqrt_years, which will again divide the double value by 12. Thus giving you a PITA bug to track down. 
I wouldn't call him "crazy nut job", he just doesn't suffer fools easily.
As major_domo said &gt; Luckily the committee seems to agree that distinct types for units are a Good Thing, and are moving towards making this easier. This was just a speculation on my part how it might look. And yes, its the same as well implemented wrapper classes, just less junk code.
The problem is that these technologies can go out of date (imagine if you had a graphics layer 15 years ago, it would look very different to one today). Nailing the future of C++ to features that can go out of date quickly seems like a great way to sink the language. It's fixing a problem with C++ that doesn't exist.
This is the kind of awful code C++ encourages. This is a simple function! you shouldn't have to octuples the code to make it "safe". Document the function parameters and move on.
Awesome, a new Ulrich Drepper's blog. OP, do you have RSS link by chance?
Given the end result auto ve2 = european_bsm(0.4_volatility, 5.0_months, 50_dollars, 50.0_dollars, 10.0_percent_peryear, 0_percent_peryear); is so elegant and easy to use, I fail to see your hatred being justified. Your logic of document and move on leads down a road of no type checking.
It's atrocious, there's at least 4x the code to maintain and carry around, and you have to understand all of it to use this trivially simple function. What's more you've removed what little type information there was in the function declaration with template parameters so you can't even tell what the function requires. It's basically a poor reinvention of duck typing via auto and overloading operators for things that are just floating point numbers! It's an abomination.
Might want to check out [Boost.Units](http://www.boost.org/doc/libs/1_55_0/doc/html/boost_units.html).
&gt; there's at least 4x the code to maintain and carry around Most of that would go in a library. The function `european_bsm` hasn't changed much at all, that's the bit an end user would be expecting to be writing themselves. Now I admit, I'm not sure about this particular implementation, but units libraries have been discussed a lot. I prefer the idea of my program not compiling when I make a mistake, rather than happily running and giving a wrong answer, *that's* difficult to debug. &gt; This is a simple function and &gt; you've removed what little type information there was No, it's a rather complicated mathematical function which takes very specific parameters. Calling them all floats is throwing away the type information.
You'd be 100% correct (in that this is unnecessarily complex) if and only if this didn't have other applications. This is just one tiny example to show how units might be used. But where it would be so much more convenient is in physics or chemistry calculations/simulations. It would disallow incorrect conversions between units- currently, you could have a `double mps`, a `double mass`, and a `double impulse` and you could just add them all together or assign `mps * impulse` to `mass` and nothing would catch the error. Again, the simple example might not make sense right now, but when you've got a ton of objects interacting as in video games or simulations and the calculations might be using several different units (checking momentum of one thing and energy of another and the normal force for some object on a slope and the... and having it all interact somehow), then it makes a lot more sense to have the computer check for your errors than manually go through every single calculation without a clue where the error might be. What I mean to say is that although the setup might be ugly, if you're going to be using it a lot and it greatly decreases the margin of error, then it's most certainly worth it to use this sort of system.
But that's almost *exactly* what the author does. He creates a few simple `struct`s that could practically act as POD types and defines literals for them. And it's easier to read literals than cast/construct everything. It's the difference between std::shared_ptr&lt;Entity&gt; E {new Entity}; ///when the entity is done get rid of it //... accelerate(E, MetersPerSecondSquared{20}); and std::shared_ptr&lt;Entity&gt; E {new Entity}; //... accelerate(E, 20_MetersPerSecondSquared); IMO the second version is much more readable in that it flows and reads logically. Instead of "accelerate E by Meters per Second Squared, 20" it reads more like "accelerate E by 20 Meters per Second Squared". Easier to read means it's easier to maintain. I just realized you could even use the same sort of system for vectors- have `_vertically` and `_horizontally` e.g. `accelerate(E, 20_MetersPerSecondSquared_horizontally)`. Verbose in code, but so descriptive it removes the need for a comment. You could probably shorten it and make it match the style of the rest of the code if you want (`20_mps2_hor`).
+1 Boost.Units is just awesome, period. It is fast, easy to use, easy to extend, and catches unit mismatch errors at compile time.
You're completely right, sorry, I got halfway through the article before giving up. I should have read the whole thing before commenting. My real gripe is with his zealous use of auto. Inside of functions, fine. When you start using it as a return type, the function declaration becomes useless and you have to read the code to figure out what types you're expecting if you ever want to not use auto elsewhere.
&gt; There's only one thing vector won't do, and that's storing stuff on the stack. Unless you use a stack allocator, right? I use stack allocated vectors *a lot* and they work just fine. I prefer them to std::array since they allow switching from heap to stack and vice-versa by just changing the type.
&gt; Funny enough the "stack allocated vector" could easily have its storage represented by a std::array. Indeed, I'll give this a try. Thanks for the tip!
&gt; Hope they do something like Go does, where a typedef is a new type and not just a type alias. Here you go: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3741.pdf
The reason they std::array class takes a template parameter for the array size is because it fixes the size to the program code to highly optimize this container. At runtime, this class doesn't have any data members that aren't the underlying c-style array. I think changing the std::array to something that is suggested would undermine this optimization. You'd have to track the size in-memory and at runtime. If this is what you want to do, just use a std::vector. The std::array class wasn't made to look nice, it was made to have a C++ standard low-level array container that is templated and safe, not necessarily pretty.
Or just try saving the return type to an int and read the compiler error on what the type is :-P I kid, I kid
Why not make `std::array` a type alias for a homogeneous tuple (forcing correct memory layout)?
Because it offers additional facilities (iterators, operator[], probably others). Other than that, it can be used exactly like a homogeneous turple, see http://en.cppreference.com/w/cpp/container/array/get 
I develop multi-platform shrinkwrap applications/apps in c++. I am fairly certain that I could write a test in 5 minutes that I would then proceed to fail. Name all the uses of the keyword const. Or even just: Name all the keywords in c++. Also if I need to do many things I need to google them. So do I know C++? Here is a test that you could self administer. Make a game in C++ in some platform. You don't need to make GTA VI, just pacman or asteroids. If you can make a working Asteroids then you can program in C++. To go on a bit of a tangent I would say that knowing C++ is handy, knowing how to program is much more important. The difference is subtle in words but huge in practice. If you know how to program then even if you don't "know" the language you are using you will know what it is that you don't know and will be able to find and learn it in two seconds. Learning patterns is sort of the correct direction, but patterns are best learned just as you need them. Trying to learn them before you know you need them is great for tests but really hard to retain. Good luck! 
I'm probably most comfortable using C++, and yet I always feel uncomfortable claiming that I know or am "proficient" in it.
No, you will need to put down a few thousands of lines of code before you learn C++ and start to understand what RAII is. I have seen enumerable amounts of people fail at when they started from a book instead of a project.
I like Qt.
[cppquiz.org](http://cppquiz.org) is a fun way to kill some time and see how well you really know the language. 
http://norvig.com/21-days.html -- seems absolutely relevant here. 
My advice: learn Java first, then get into C++. Java is a great language to learn for concepts (and also very useful), and learning C++ afterwards won't be such a hurdle.
I dunno, there's a heck of a lot of patterns you'll have to unlearn. Most people I see coming from Java end up way overusing `new` and completely missing the point of value semantics. Even though first learning Java will teach you control flow, it seems to me like you'll still need a book to learn how C++ fits together.
I am aware, but sites like learncpp don't mention that. :)
http://asset-e.soup.io/asset/0723/4939_e615_500.png
Yes, the tutorial is a horrible learning resource. Which is a pity, since somebody obviously spent a lot of time writing it.
&gt; Crazy users might overload op,() At this point i said "fuck crazy users, you cannot forsee what else they'll invent" :)
The standard is truth, knowing it will make you write better "real" code. 
The Standard describes what users are and aren't allowed to get away with - although I will admit to screaming in agony when I heard about the comma operator.
Nineteen years here, and I still gain enlightenment from time to time. C++ is like an old friend. 
Much of what makes C++ a great language is not revealed in a 100-line program. The strength of C++ is that it gives you tools that will help you craft a 10,000-line program and keep everything so well structured that when you need to reorganize your code, the process is not painful.
I've used Lynda for Android programming (java) and it was quite helpful. However, it seems that wherever I go on reddit, everyone has referred me to literature as my best bet. I am probably going to read the book and do the lynda stuff at the same time, but I wanted to know why the lynda material is so crappy to reddit. Thanks! edit: thanks for the good feedback ya'll
... That's like SimCity 5 DRM on your development environment... No connection? Good luck finding the entry point to _abort.
I've never used them, but ALYWAYS be weary of online tutorials for C++. Very rarely can you find a tutorial that really explains the power and pitfalls of C++ effectively. I will also say that, in my opinion, C++ isn't just a language but is tied to a philosophy...and you need to talk to a C++ programmer in person to get a feel for what it's all about.
Look! Someone discovered Stackoverflow.com 
Why are you posting stack overflow questions? 
Seems to follow most of the bad practices of the other on-line tutorials I've seen for C++, so I'll just post the link to these. Watch out for (TL;DR: introducing C before C++ signifies a rather profound level of confusion about both; nowadays I'd also add sticking C++11 into a separate section at the end as another suspicious sign): * http://www.reddit.com/r/cpp/comments/1j3fpu/c_beginner_programming_tutorials/cbapb7c * http://www.reddit.com/r/cpp/comments/1encfj/im_taking_intro_to_c_this_fall_what_can_i_hope_to/ca1x29n 
SO username: Raman Sharma, reddit username: /u/rasharm_, so I guess it's for greater exposure. In any case, /r/cpp_questions would have been a better fit. Oh, and a less spammy way of posting half a dozen questions at once.
Some of the questions are asked and self answered almost immediately. More like someone is trying to game SO and reddit.
Are you sure you want to invest the time to learn something like XAML? It seems like a Windows only fly by night technology that will be obselete / remade in a couple of years.
&gt; Fortunately, though, you can tell from the first thirty seconds that this guy is a crack-smoking moron. Using namespace std, using Eclipse, covering both C and C++ in the same course, calling it the Standard Template Library... stay away. I haven't watched the courses, but I don't see how any of these make him a crack-smoking moron, unless I'm missing the sarcasm here...
question: why is `using namespace std` poor practice? I just finished my first college c++ course and we used `using namespace std` in pretty much every assignment. edit: nevermind, I followed one of the [links](http://www.parashift.com/c++-faq/using-namespace-std.html) that /u/mttd posted further up, and that's the first thing it covered. It was what I thought it would be, conflicting namespaces. Having mostly used visual studio and intellisense, I never ran into that as a problem, but also was never introduced to an alternative until now. I'll try and make use of the using-declaration.
using the `std` namespace is perfectly ok, `using namespace std;` is problematic.
sorry, yea that was what I was asking. I clarified my question(and previously didn't know you could put inline code formatting on reddit), and have since found a more in depth answer as to why it is problematic. Thanks. this is why I sub to this subreddit. I'm still very new to this, and even though I finished top of my C++ class, I've become quite aware that I was taught a lot of bad practices in the name of keeping young college students interested. My professor had a lot of things that were labeled as "Walter Cronkite", for his famous quote, "That's the way it is". Things that would require entirely to much base knowledge to ever let us produce anything to wet our pallet of what we could make, and would require more time than a single semester to teach.
Read these C obfuscating contests. Especially the short ones where a line or two of code have wildly fantastic results for code that I can't parse in my head at all. Or those contests where people would write stuff in 512 byte boot records. People had basic working versions of space invaders. But as I discovered if you pound away at a small section of a large knowledge set you soon become an "expert" and people will assume that your knowledge has breadth as well. 
XAML actually has stuck around long enough and is now being used to build a part of Windows itself. So clearly there is some future to it
I am not trying to game either of those. Answering self question is actually encouraged on SO. I am just trying to spread awareness around some common issues. See this: http://blog.stackoverflow.com/2011/07/its-ok-to-ask-and-answer-your-own-questions/
That is correct. And it's not like you can't debug your own code. You need to debug CRT sources only in some special cases.
Right. I've heard "pointers are dead" now longer than I heard Dewey beat Truman. Not gonna happen.
Pointers will never totally die, but I do like the trend towards hiding them. I mean, I'm not suggesting going full Java, but if you have a raw pointer and you're not implementing a data structure, you're probably doing something wrong.
lost me at "it self"
Your loss. The actual content was pretty good.
&gt; problems caused by people not knowing how to use them correctly. This is my main complaint with tacking more and more on top of C++. Either learn to use the language or switch to another language you do understand. Those of us that have to fix your code would appreciate it.
Although I completely agree people could go a long way to actually learn the language they're trying to write in, I don't think that excuses undue complexity. I'd like to think I understand implicit ownership through raw pointers. I'm responsible (along with my team) to maintain well over a million lines of code written in the 90s against VC6. That said, when I'm implementing new features I have better things to worry about than verifying code follows implicit/subtle/invisible/tribal ownership conventions. Throw on some smart pointers and, that's one less thing to worry about. The beauty is that I can pop the hood and use raw pointers when I need. But, honestly, I don't like to pop the hood any more than I *have* to.
I think it would be nicer to write this: std::array a {1, 2, 3}; And it was already proposed for C++1y. Relevant paper is here: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3602.html I'm pretty sure it was adopted.
Computer graphics is a very specific field and is extremely broad (within that field). Not to mention graphics technology will evolve rapidly and will make current library implementations obsolete quickly. Also, including only a one small subset of tools as part of the C++ library is will fall short of the specialist needs that many graphics programmers will demand for their projects. So they will use external libs anyway. I think any new library addition to C++ should have as much general purpose application as possible, have a stable feature set, and not face premature obsolescence. As for SVG support, something like a general purpose XML parser would make more sense. You can not only parse SVG with it, but a whole heap of other formats based on XML. I would much rather see new mathematical features, such as matrix computations, native vector computations (not to be confused with std::vector), etc.
"Windows 8 has reimagined the deployment model for Store apps." Yes, and they try to make this sound like a good thing... 
Why not link to [the actual article](http://www.meetingcpp.com/index.php/br/items/cpp-future-and-the-pointer.html) instead of this useless page?
You seem to be implying that if you "know how to use the language correctly" then you don't need to use smart pointers. That couldn't be further from the truth. There is maybe 1 smart pointer type missing (which I think is in C++1y), and that's the "Trust me I know how to use raw pointers" type. Once that is there, it allows you to quickly and easily communicate all of the lifetime decisions you made in your design to anyone wanting to use it. If you really think you don't ever need to use shared_ptr/weak_ptr or unique_ptr in your code then... I think you're just too subborn to learn a new feature. Just because I know how to write code that properly manages lifetime using nothing but raw pointers doesn't mean I shouldn't use shared_ptr. Why **waste** time writing that code when a great solution already exists? Just so you can tell younger programmers to get off your lawn?
Actually I think that smart pointers are a good solution, and it especially helps those, who learn C++11 as new language today.
Say hello to undefined behaviour.
But then it would be a repost. /s
lost me at: "you don't have to understand how pointers work anymore to use C++"
'cos it looks fucking ridiculous
I don't think this is very well said: &gt; Both shared_ptr and unique_ptr act as value semantic types When you modify an object via a shared_ptr, any other shared pointers that see the same object will see the change. That, to me, is reference semantics. To me, the clearest example of 'value semantics' is where, once an object/pointer/reference/whatever is passed to a function, any changes made by the receiver are visible only to the receiver. The obvious example is to just keep the object directly on the stack (which should be the default storage for everything until you have a good reason to do otherwise). Therefore, at a stretch, you could say that unique_ptr has value semantics. The receiver has the only copy, therefore changes it makes are not visible elsewhere.
I enjoyed [Olaf Dietsche's response](http://stackoverflow.com/a/20804586) which shows both that -Wall will warn about the undefined behaviour, and that the generated assembly code implements the simple swap regardless.
I'm sure there's plenty of resources out there but I personally used learncpp.com to learn. I found it very good since I had not long started learning programming. I can't compare it to other resources though.
Books. I learned the basics of programming with JavaScript and Visual Basic back in the Windows 9x days then picked up C++ by way of Visual C++ (using Visual Studio 6). Back then I used C++ Primer Plus however that has fallen out of favour these days. Here is what I will suggest, pick whichever suits you best. If you have never programmed before then get a copy of Programming: Principles and Practice Using C++. It teaches you how to program using C++ as the language. If you have programmed before, say in C or Java or C# then check out C++ Primer (not Primer Plus). Some find the Teach Yourself C++ in 21 Days type books are ok too. I have no idea about them though. 
Take a look at the [C++ FAQ](http://www.reddit.com/r/learnprogramming/wiki/faq_cpp) from /r/learnprogramming. Also, did you read the sidebar: &gt; For C++ questions, answers, help and advice see /r/cpp_questions.
School was where I really got good at it. I was lucky enough to have a prof who was a wizard with C++ and willing to show us all the tricks and nuances he's learned throughout his career. I think it's important to have someone who knows their stuff take you through it and explain not only the language itself, but what your code is actually doing on the CPU and in memory.
I learned mine from various sources -- books, blogposts, cplusplus.com/forum/beginner and source codes from OSS. Although some websites claim to "teach C++" proper, they attempt to teach in the Pure (old?) C way, which I find really odd. So my suggestion is: (1) Grab a really good textbook--C++ Primer(Barbara Moo et. al, 5th ed). (2) Don't depend fully on the textbook's methods as "the only way it can be done" -- explore. (3) Visit http://cplusplus.com/forum/beginner/ often to view/ask questions. (4) Test your skills by writing various code. Write codes in the form that comes "naturally" to you. Then, keep looking for alternative methods it can rewritten. (5) Read blog posts and source codes(get them from github.com), there are countless OSS codes.
I learned from various online tutorials, books, videos, etc. One Youtuber that I always recommend to anyone wanting to learn C++ is [AntiRTFM](http://www.youtube.com/watch?v=tyVhn0FWWB4).
* http://en.cppreference.com/w/ * Effective C++ books * Coding in C++ and working with people who knew more about it than me * http://en.cppreference.com/w/cpp/memory/shared_ptr And, if you have your doubts about why such a baroque language like C++ exists or you're wondering if Stroustrup is a maniac you can try this, it's quite enjoyable: * http://www.stroustrup.com/dne.html If you want to laugh: * http://harmful.cat-v.org/software/c++/I_did_it_for_you_all
Actually, I think at that you are right.
I learned C++ during my internship/first job. I learned C and Java on Unix in college and found myself dropped into a C++, OWL, MFC Windows environment. Had to learn quickly and picked up *The C++ Programming Language* to help me do so. Nothing like a deadline to focus the mind.
Thank you (:
I learned most of what I know from [Stack Overflow](http://stackoverflow.com/questions/tagged/c%2b%2b), by reading the C++ standard (this is what changed everything for me), and by reading articles. Stick [isocpp.org](http://isocpp.org/) in your favourite RSS reader. Now I'm among the top 50 on SO for the C++ tag! I've not had *any* professional working experience with C++, so it's certainly possible to learn a lot just by spending lots of time reading.
If you search /r/learnprogramming and this subreddit you'll find longer posts that motivate this point of view; someone should write them into the wiki, but nobody's just found the time yet.
Friend. I met with him at a club at school and liked to converse with him for hours on what he did with the language. I talked about the language with him so much I eventually just took it up myself. Oh yeah, and it was all online resources for me. 
I wanted to laugh... Is that real?
I second the Primer 5th edition (not plus), it covers C++11. 
I knew a little bit of C# and almost no C++. Our teacher gave us an unfinished space invaders created in SDL. It only had moving enemies in it and no player. He basically said "Ok, there is the struct for an enemy and some basic enemy logic, now figure out how to make a player, how to make it move and how to make it shoot". He gave us no real instructions or any good introduction, but the exercise itself wasn't very difficult. It was mostly just copying the existing enemy struct and changing minor things to it to make it work for players. With that, I learned how to work with C++. It was actually really bad for me, because I had no idea why I was doing certain things. It got even more confusing because of strange differences between C# and C++ (ESPECIALLY the 'new' word and how to use it). After a while I started reading the C++ book that we were supposed to read and suddenly, nearly everything I had been doing started making sense. Reaching that part gave me a great feeling. Personally, I still think it's very important to actually do things, rather than to just read about it. I could read C++ stuff for hours but I won't really remember anything if I don't use that knowledge soon. 
I wanted to learn to program since I was 8 (now 13) and always thought that C, C#, C++, Obj-C were all the same until last year when I started learning instead of researching of where to start. 
I learned by being thrown into it. As a science grad student, my professor said to go get his other student's code and change it to do what I want. (This is entirely feasible since we read files in the same format and essentially want the output in the same format the other student used.) So I learned essentially one way to do things from that piece of code, and then as I got more interested in what the language itself allows/disallows/provides I realized just how horribly bad at C++ the other student was. I've read through most of Stroustrup's book. Depending on your style, you may find it reads like a reference manual. Personally I think it is a very good way to learn, but I also favor that sort of style where you build a contrived example to show the feature. You may favor other books that are more task-oriented and effectively build-up a program through the course of the book. My peers favor the task-oriented approach. I may point out "C++ allows you to define a class with function signatures but leave them undefined to create an interface." To which I would be asked "Great, when would I ever fucking need that?" More often than you think - basically any time you notice you have the same code in more than one class. But go on, waste your time and wait till you change anything short of all the copy/pasted code sections and see how well your program runs.
I'm still in middle school and I can't really be thrown into it. I would love learning it on my own but I lack the motivation to do so, there's no short term rewards of learning it, only long term ones. Being shoved into it at school gives you the short term reward of getting a good grade and impressing your peers, but it's not socially normal to go around your 13-14 year old friends showing off what you know in C++. When people throw me with suggestions of what language that's the kind of language they throw at me "C++ allows you to define a class with function signatures but leave them undefined to create an interface." Well...what does that mean? It doesn't help me decide what language to learn. A reference manual type book would be helpful, and I haven't seen one yet, but I will definitely take a look at it soon. All I have are books filled with examples and books that use that "language," if you will. Could it be that I'm just not old enough? I have attempted to learn several times over the years and kept thinking to myself that I might not be just be old enough and put it off until I'm older. Now I'm 13 and I'm decent with every other part of the computer, why not programming? And I still don't do that well with it. 
[Stroustroup's keynote at GoingNative 2013](http://channel9.msdn.com/Events/GoingNative/2013/Opening-Keynote-Bjarne-Stroustrup) was ready good. It wasn't *too* advanced, but more importantly he's a good communicator. The purpose of that talk isn't to teach you the language, but to give a flavour for the kind of things he thinks about when thinking about programming languages.
[Here's a list of suggested books from stack overflow.](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list)
It is true. For example, this is true: &gt; that object-oriented programming is counter-intuitive, illogical and inefficient.. (Sorry. I couldn't help myself. I happen to be going through a phase of getting *very* cynical about OO. Or perhaps about the OO that's available in modern mainstream languages. This isn't the place to debate it, I just wanted to get that off my chest! )
Don't let people tell you that you should learn C first, as if C++ is some sort of "advanced C" that can only be learned later. (That's a popular misconception at the university I work at.) C++ is more "advanced" than C in the same way that Java is more advanced than Cobol. It's just better all round. In fact, if I was given a few years to teach C to a complete beginner, I'd probably start them off with C++, and then gradually expose them to C.
Why is the code a screenshot?
I read that you should learn C before C++ and another article proved that wrong. I also heard that you can never finish learning C++ because of all the stuff (functions?) but you can finish learning C, is that true? It's kind of hard to explain but there was an article about it. 
My advice: find out what you want to do and follow it. I loved the world of viruses and malware, so I went to rohatib.com forums. I learned so much about C++ from there that I began reading everything and anything about C++.
I do have a lot of experience with malware and even did a "bit" of it myself. This forum I go in is notorious for coding crappy malware that requires the machine to have a .NET framework, while the rare malware on there coded in C++ or Delphi is praised over a million times. I have gigabytes of malware source code in C++ and C#, some worth in the tens's of thousands range. They're just all gibberish to me though. 
You've really got to hand it to the diseased brain that came up with this -- invoking undefined behavior in two completely separate ways at the same time is quite a feat. That will definitely get you a trophy at the Crap Code Awards.
We actually had a professor teach from www.learncpp.com. It was an interesting approach and a lot cheaper than having a textbook. I would only recommend this site for absolute beginners.
So much controversy, someone said that learncpp.com is discouraged as it provides inaccurate and missing information. http://www.reddit.com/r/cpp/comments/1ttsuv/learning_c/cebenja
That's awesome! What are you trying to accomplish by learning C++? 
And properly integrates into the main text instead of shoving it in an appendix!
- code to interfaces - composition &gt; inheritance the end unless you're doing more than "enterprise" programming YMMV ---- Oh, and: http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29
PS Real definition of legacy code is code for which you have no unit tests ;-)
haha yeah, like the "Plus" does with vector too.
I always tell people learning C++ and pointers to watch this video. The video kind of helps but mostly I just enjoy it. http://youtu.be/mnXkiAKbUPg The other thing I would recommend when attempting to teach yourself any programming language is to pick a project to do. It doesn't have to be anything crazy but it will help. The first project I did in C++ when I was learning was a console black jack game. Having a goal to work towards and problems to overcome will help keep you motivated.
They doubled down too - later in the article they attached the source code _as a PDF_. Why people don't share using github for public things like this is beyond me. 
Your biggest problem is that you have no need to know the language other than that you just want to know it. You need a reason to know it so that you can actually use it. If you want to learn "web languages" then just start with Python or Ruby. Sounds like you picked C++ because you heard it was "cool". 
Just because you can plug in a few components to a motherboard or edit the registry or install Arch doesn't really mean you are any good with *computers*. Sorry it that seems harsh but it means very little when it comes to programming. Sounds like you are trying to learn concepts way beyond your currently technical ability. I would advise you learn about **logic** and **maths** as these are important when programming. Learn a simpler language such as JavaScript or Python to understand the *concepts* and the problem solving aspects of programming. Once you *really* know what a variable and a loop is then look at moving onto a more complex language such as C++. 
You can't "prove" learning C before C++ is wrong just like you can't prove learning C++ before C is wrong. In reality it doesn't matter. Do you want to write device drivers? [Linux] kernel development? Hardware level development? Then C is what you want to learn. Want to work in the application development domain? Then C++ is going to be the better place to start. C is a tiny language and the C Standard Library is nice and compact which means *learning* it is quicker/easier in certain respects whereas C++ and the STL is **huge** and even the creator of C++ only puts his knowledge at about 7 out of 10. Very few people really *master* any language as they will not need to *use* every aspect of a language and its standard library as they will mostly use the language in a specific area so they will become excellent at using those areas but know very little in comparison to other areas. Try not to believe too much in articles related to programming opinions but form your own instead. For example Linus really isn't a fan of C++ as he finds C the best for his tasks so he will always post about how C is better than C++ but that is due to the areas he works in (kernel dev, etc). That doesn't mean C is actually *better* than C++ just that Linus prefers it. I love C, just check my post history, however I am of the opinion that unless you have a specific *reason* to learn a language then don't bother learning it. I *know* about two dozen languages but I *use* only 3 regularly and I would say I am only proficient in 1 and I am 29 years old and first learned to "program" at 9 years old on a BBC computer in primary school using Logo. 
Malware source is probably the worst code to learn from (unless you are trying to learn about specific exploits) as they are full of crazy, nasty hacks. Do yourself a favour and just delete it all. You are not going to learn anything from it for the next few years if ever. 
I was going to say a lot of what I read in the hoax did in fact make a bit of sense. I'm not an expert at C++ though, I find it pretty annoying (I'm used to C)
Excellently put :) 
 vector&lt;int&gt; c; for(int i=0;i&lt;10;++i){ push_back(c,2*i); emplace_back(c,3*i); } At this point couldn't you just use function overloading?
OK.
I really wish there was a standard way to support compile time introspection. Would make replicating the interface trivial and would keep operator. in the non-overloadable set. Regardless, really like the idea how you can trivially wrap classes and monitor function access. Why did you go with the given syntax? Did you try emplace_back(c)(1,2,3); I like it a tad better since you delimit the container from the actual arguments. Edit: Also like how this reads with the begin() and end() functions from std. If no arguments are needed (possible to check in compile time), just do a direct call, otherwise return a proxy object with a reference to the object and a single operator() that will forward the args to the selected slot function. Edit: Slut function. Interesting typo. Late edit: Behold, the compose function! template&lt;typename Cont, typename Slot&gt; class proxy_call{ Slot token; Cont&amp; container; public: proxy_call(Cont&amp; cont, Slot tkn): container(cont), token(tkn) {} template&lt;typename T,typename ...Args&gt; proxy_call&amp; operator()(T&amp;&amp; t,Args&amp;&amp;... args) { container(token,std::forward&lt;Args&gt;(args)...); return *this; } } template&lt;typename Cont, typename Slot&gt; auto compose(Cont&amp; cont, Slot slt) { return proxy_call&lt;Cont, Slot&gt;(cont, slt); } int main() { vector&lt;int&gt; c; auto emplacer = compose(c, emplace_back); emplacer(1)(2)(3); }
Then what does being good at computers really mean? Sure I can build a computer, take apart one, do any small modifications or changes to the registry and install any sort of Linux I want but please keep in mind that I am only 13 years of age... 
 template &lt;&gt; struct Vector&lt;4&gt; { union { float data[4]; struct { float x, y, z, w; }; }; }; I assume that the intent is to store/access using `x`, `y`, `z` and `w` and execute SIMD operations using `data`, but [isn't this undefined](https://stackoverflow.com/questions/11373203/accessing-inactive-union-member-undefined)? 
Answer me these questions if you can. 1. Why did you not find Python enjoyable? 2. Why do you want to learn C++? 3. Why do you want to learn to program?
It is, but like the author says, it works as you'd want it to on most platforms or compilers...for now. I wouldn't rely on undefined behaviour for that reason alone - you dont know if it'll work in the future, even if it works now.
&gt; Why did you go with the given syntax? Did you try &gt; &gt; `emplace_back(c)(1,2,3);` &gt; &gt; I like it a tad better since you delimit the container from the actual arguments. It's a possibility, of course, I just went for the simplest possible scheme. On the other hand, your proposal breaks the symmetry between objects and slots: you have `c(emplace_back,...)` but `emplace_back(c)(...)`. At the end of the day, a matter of taste, I guess. Your `compose` construct can be emulated (for functions with fixed number of args) with `std::bind`: auto f=std::bind(push_back,std::ref(c),_1); f(100); // push 100 to c f(200); // push 200 to c 
In my opinion using templates for the size isn't really worth it. While you have to repeat some code I'd rather prefer to have the best possible performance in debug builds.
In graphics programming you actually do so people usually optimize for those cases.
Note that this is particularly centered around the needs of *Graphics* where people know ahead of time whether they are working in a 2D, 3D or 4D universe.
You are right, SO do indeed encourage self answers. I apologise for misjudging you.
To be honest, Zed Shaw does make a point: as much as I like C++ its streams are just horrendous. At the time they were conceived they might have been *best of the breed* but they have a lot of problems: - mixed concerns: formatting and memory management all baked into one, and no it does not work with an allocator - formatting "flags": some are transient, some are persistent, please read the doc... oh and there is no "pop" operation for the persistent one so you have to memorize the previous state yourself (outside of the stream-like interface, it requires a normal function call) - a stream-like interface is great for logging, but does not support internationalization (because when you translate, dynamic elements move relatively to each other...) Oh, and of course there is all the runtime overhead induced because of the attempt to do everything and anything (such as interacting with `locale` and its myriad of facets). Locale facets which do not support multi-bytes characters and multi-characters conversions anyway (so are actually pretty much useless for localization!). Frankly, of all the Standard Library, streams/localization is the worst part, right on top of the monstrous `string` class.
That's a good point, but it wasn't Zed's point. The line he was complaining about was bstring test = bformat("I want %d ponies", count); and here's no streams necessary there, you can just do string test = "I want "+to_string(count)+" ponies"; But he doesn't know this because he hasn't used C++ is over a decade.
Right, we can all agree that streams can go out of hand pretty damn fast. But bitching about RAII, exception handling and const (wut?) seem a bit strange to me. And as for the string construction, like he said, use boost::format :) Edit: Title is a bit harsh, don't you think OP?
This is why we have variadic templates. Write your own formatter. Bonus points for calculating necessary string length up front and reserving space in the returned string before writing to it...
&gt; string test = "I want "+to_string(count)+" ponies"; How is this actually better than the equivalent using streams? It's not the same as a format string, ala printf or his "bformat". 
&gt; Please show me how to implement a generic container without templates that is type-safe. FTFY. 
I do want to learn though and I believe I can but time is just a major factor here and I don't have any of it. I'll try to start tomorrow and take a look at all the resources you guys have provided me, thanks. 
I didn't find Python enjoyable because I felt it was bland for the lack of a better word. For some reason, I didn't find it enjoyable writing extremely short lines of code. Not lines, but the amount of characters in each line, I felt like I was accomplishing nothing. I was told that Python is versatile and can be used for a lot of things which could be true but I never found it used in very many programs and applications, besides Reddit and stuff. I want to learn C++ because it's a more popular language and will provide more use to me in the future and would look better on college and job applications. Because I strongly believe that people have heard of C++ much more than Python or any other programming language. I want to learn to program so that I can combine it with my graphic design experience. I know application languages won't help with that but I do find application programming much more entertaining than something such as PHP or HTML. But if I ever do learn C++ to a state where I can code competently in it, then I will move to web languages. 
It's nice when an idiot gives themselves away so early in an article. It turns the rest of it into a comedy piece.
As a WPF fanboy, I'd have to concede that since MS is so awfully coy about its future, it just seems that QT is a safer bet for now. Also note that if your UI is going to be complex in any way - i'm sure QT would scale better than WPF. 
Actually, **no**. This would *also* suffer from internationalization issues. The only way to deal with internationalization issues is to have format strings and the ability to pass information purely for internationalization; for example: format("%{1, =1:This is 1 horse, _:Those are %1 horses}", nbhorses); Because plural forms are complicated, and gender forms are complicated also etc... As for `"I want " + to_string(count) + " ponies"` it is also probably suboptimal allocation wise; even with move semantics chances are that the string created by `to_string(count)` is too small to contain the whole final sentence so a reallocation will be necessary. With a format string however, one can anticipate how much memory is required (or at least have a good estimate) and thus in average have a single allocation. On the other hand, there *are* variadic templates toy implementations of `printf`.
Some sugar: More freedom to overload operators, in particular to define new operators with arbitrary precedence. Some more syntactic sugar around smart pointers and scope control. I don't really have a clear idea here, but typing `shared_ptr&lt;&gt;` is a lot of work compared to `*`. (I have a few more 'fundamental' ideas, but I'll put them in a second comment, as I don't know the jargon well enough to communicate them!)
I'm tempted to suggest 'type erasure', but that will just lead to a debate about what 'type erasure' means. (This is what happens on StackOverflow). So it would be good to avoid the term 'type erasure'. Anyway, my understanding of Java Generics is that it does not, in any way, change the bytecode that a particular method is compiled to. Instead, it allows more subtlety to be expressed in promises made by a method in terms of its interface. *Update: The example I gave here is bad and incorrect. Just ignore the rest of this comment! This [other comment by me](http://www.reddit.com/r/cpp/comments/1tyawn/what_are_features_that_other_languages_have_that/cecrskv) is a better example of my intention.* ~~Imagine a `vector&lt;Shape*&gt;` and the method `.at(int)` which, currently takes an integer index and returns the `Shape*` offset at that offset within the vector. In the particular case where the caller knows that all objects are `Circle*` (or subclasses thereof), the caller should 'know' that `at` will also return a `Circle*`.~~ // this example is incorrect! vector&lt;Shape*&gt; vec; .. populate the vec with many Circle* Circle * c = vec.at(5); // currently a cast is required, but a smart compiler with support for generics would know this is safe. Currently some sort of cast is required, but it would be nice if the compiler knew that a particular `dynamic_cast` would always succeed and could therefore be safely skipped. This would lead to easier-to-read and safer code. (Note: I want this to work for *all* types, not just `Object*` types as in Java! Also, I don't know if I'd actually use this feature, it just seems cool!)
Well, exceptions (and in general error-handling strategies) can be very subjective. But I admit I did not understand the issues with RAII and `const`...
No headers. Looking at the latest version of Xcode and its support for modules in Objective C, it looks like there's some hope modules will eventually come to C++ as well.
&gt; To be honest programming and graphic design don't really go together in any natural way. Then what does a web designer do? 
Compile time introspection, via which you could enable runtime introspection on a per-class basis.
&gt; More freedom to overload operators, in particular to define new operators with arbitrary precedence. No, no, no. This would quickly lead to everyone making their own DSLs. &gt; Some more syntactic sugar around smart pointers and scope control. I don't really have a clear idea here, but typing shared_ptr&lt;&gt; is a lot of work compared to *. Shared_ptr is easily searchable, * is not. You can define aliases if you wish shorter names? 
&gt; In anything at all, perfection is finally attained not when there is no longer anything to add, but when there is no longer anything to take away. I don't understand this idea of designing a language as an accretion of features picked left and right, this gives you some soggy mess like... C++.
&gt; in particular to define new operators with arbitrary precedence. I can already smell the 3rd party libraries combination hell when two different libraries happen to define the same operator with different precedences... *no thanks*
You are actually deviating from static typing at this point. If you want only `Circle`s in there, constrain the template parameter more thoroughly and your wish shall come true.
Algebraic types with pattern matching.
GCC is doing *something* like this with devirtualization. https://docs.google.com/presentation/d/1-K0ahFIAip12TJxAPJtQCpxZ4l6l19MneQMmKPQ-SjQ/edit#slide=id.i0 And unsure that its a good idea for the compiler to smart it out and remove the need for the cast. Let the dynamic_cast stay, and if the **optimizer** sees it fit to replace it with a static_cast, then so be it.
They design :) There is a world of difference between a web designer and a web (front end) developer and a web back end developer. A web designer does just that. They *design* the page. They are normally very skilled in Photoshop and Illustrator and similar applications, know a decent about of HTML and a lot of CSS (at least in my limited experience they do). A front end web developer will work a lot with HTML, CSS and JavaScript with JavaScript being *the* biggest language in front end web development AFAIK. A back end web developer is a full blown developer. They will work with any number of languages with the most popular being Java, Python, Ruby, ASP.NET, etc. You can use any languages you like so you *could* write a web app in C if you really wanted too and this was how things were done back in the 90s a lot of the time. Facebook uses a shit load of C++ as they need serious performance which you just can't get with languages such as Python. Java is very close/the same as C++ for a lot of things these days as well however it seems to be falling out of favour with a lot of places. I believe Twitter uses Java extensively for their back end systems. A lot of developers will know how to design and vice versa however I know many back end web devs who know only a handful of HTML and CSS as they leave all that to the designers. You have probably seen the term "UX designer" or "UX engineer" throw around a lot recently. UX is User Experience. When you hear of UX designers they are problem who specialise in designing natural and logical user experiences. Jeff Atwood has a good post on why you shouldn't let a developer design the user interface/UX :) http://www.codinghorror.com/blog/2006/11/this-is-what-happens-when-you-let-developers-create-ui.html Edit: I should point out again that I am not a web dev with only passing experience with most web technologies so I probably am wrong on some bits however I think most of what I say is correct ;)
It is an interesting thought, and actually I have implemented compile-time inspection of attributes using a fairly heavy-handed macro approach + some templates (taking a SO answer as a starting point). But unfortunately this little trick completely bypasses the accessibility, so I am not too satisfied about it. I know that introspection is fairly often demanded, but I am still on the fence on the subject. Yes you can do some cool tricks with it (auto-printing!) but many times it only falls apart (auto-serialization yeah! without versioning uuuuhhh!). Did you have specific usecases in mind ?
Duck Typing, like Go.
I am yet to find a better I/O library than C++ I/O streams. I believe its only major flaw was leaving so much of the interface optional (showmanyc/in_avail and even setbuf!) and relying on OS vendors to supply the locales: Microsoft C and C++ still has no Unicode support (except through MS APIs) because the OS does not provide those locales, but when C++11 spec required locale-independent Unicode codecvt facets, STL provided them even before libc++ did (and GNU still hasn't, for shame) &gt; mixed concerns: formatting and memory management all baked into one, and no it does not work with an allocator Formatting, buffering, and conversions are completely separated, and are separately extensible, used to great benefit by boost.asio, boost.iostreams, boost.date_time, to name a few. Allocations made by the buffers go through allocators. Are you referring to the allocations made by iword/pword? (those are not allocator-controlled, which is indeed a flaw, but iostreams is not alone in that: even the algorithms library has two algorithms that don't use the allocator interface) &gt; formatting "flags": some are transient, some are persistent, Only one "flag" (the input/output width) is not persistent, which, I agree, is confusing. &gt; Locale facets which do not support multi-bytes characters and multi-characters conversions anyway Of course they do, how else do you read/write UTF-8 or GB18030 files?. And when multibyte conversions aren't required, they are even optimized away, which is why istream::read() simply calls the POSIX read(2) (or equivalent) PS: internationalization of output is hard whatever way you slice it and streams don't make it easier, I agree. But what does? Not message catalogs, if that's what you think of.
&gt; I can already smell the 3rd party libraries combination hell when two different libraries happen to define the same operator with different precedences... no thanks How is that any different the situation where two libraries define two conventional functions with the same name? Isn't that the problem that namespaces are supposed to solve?
&gt; No, no, no. This would quickly lead to everyone making their own DSLs. A similar response could be made to many features in C++. Just because a feature exists, it doesn't mean you have to use it, nor that you are forced to use somebody else's badly-designed library. The C++ ecosystem should be intelligent enough to do the right thing here, for example only allowing such operators into the standard library with great care.
You have static duck typing in C++. Runtime dt can be achieved, but not really in a pretty manner. I'd advise you to listen to a few latest Sean Parent's talks you can find. (especially if you see 'inheritance' in the title)
ARC has been built into Objective-C because all objects have the same resource management model. In C++ the 'universal' model is instead the simple 'by-value' semantics of primitive types enhanced by RAII to allow applications to implement more complex semantics as needed. For example if you want reference counting in C++ you can use `std::shared_ptr`/`std::weak_ptr`. In short, C++ already has an opt-in ARC for those areas where it is appropriate, but it wouldn't be right to force ARC as the universal model on the broad range of domains C++ is used for.
One case is to make it trivial to make proxy objects. Just inherit the target class interface and put hooks on needed functions. Auto serialization is nice, but I would be fine with only publicly accessible members/functions being introspected, all others (protected/private) do not exist. Don't have much experiences with auto serialization, so this is where my mind drifts off. Implemented compile time introspection via SFINAE and macros. It works great, but its a mess implementation wise. Used it to establish links between a pure virtual class that has many functions and target classes which only have a subset the functions, non existing functions are replaced with noop functions. All binding classes are constructed via template SFINAE macro hackery, but it is at least maintainable compared to having to copy paste it each interface class and manually fill in noop and forwarding functions.
ADL would bite you in the ass so much harder. If you haven't encountered cross-namespace ADL problems before, count yourself lucky.
&gt; I am, however, slightly bothered with `extern begin_s begin;`: I prefer to avoid global variables, so I would add in a `const` here just to make sure nobody is using global state inappropriately. You're right, but I'm concerned that having `const begin_s begin;` (which has internal linkage) can result in ODR violations if some template code takes the address of `begin` and is instantiated in different translation units (as it's often the case with template code): I've got to think this over.
If the compiler can prove that the dynamic_cast will succeed, then you could write it so a cast isn't needed, right? I think the only cases where that isn't true are multiple inheritance or deep inheritance, and only if you need to cast to different base classes at different times.
Modules ! Fortunately there is worn in progress in clang compiler for this. Of course Compiler-time reflection/introspection. Here is prototype implementation based on Clang: https://bitbucket.org/remotion/c-reflection 
Stepping thought templated code is a joy. Stepping thought macro-expanded code is hell. Edit: But, agreed, that is why I asked if he can explain.
&gt; macros No please no macros! IMHO macros should be used or required as rare as possible. 
Now sure about this but overloading Dot(.) operator would be great and is necessary in some cases. https://www.youtube.com/watch?v=Gy9ITl1AWRY http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1671.pdf 
An exhaustiveness check for a `dynamic_cast` cascade might help with that as well. Unfortunately, mutable values of algebraic types would reduce memory safety even further (even Ada 83 could not avoid that).
Boost.TypeErasure gets you dynamic duck typing in I'd say a very satisfying manner. 
No elegant way to implement introspection otherwise. I only used them for X Macros. Really nice macro use-case
A usable subset which provides memory safety in a way that can be checked mechanically in practice. (The subset should include the standard containers.)
Clang's already implementing the same module map system for C++. Some things to note: The module map based system is geared toward getting legacy code to work as modules. It doesn't eliminate headers, just requires them to be systematized in a particular way. Those requirements mean that even legacy code may still have to be modified if they do particularly non-modular things. For example duplicate declarations have to be unified so that every declaration has a single module as its source. Legacy code frequently does awful things, and the clang documentation has a section on issues that can be encountered when converting legacy libraries into modules: http://clang.llvm.org/docs/Modules.html#modularizing-a-platform The module maps system requires an extra file to be written on the side. Apple tells developers that only Apple code works as modules rather than pointing them at the clang module map documentation and encouraging them to write their own module maps. Presumably this is because module maps are not as nice as a native module system would be. Although bringing legacy code into the world of modules is important we really do want a native system for creating modules so that newly written code can start out as modules rather than having to be written as headers+module map. So far I don't think clang has done anything about a native system, although obviously much of the same infrastructure used for module maps would probably be used for native modules.
Automatic Reference Counting (previously called 'Automatic Retain / Release') refers to no longer having to manually write `retain`,`release`, and `autorelease` messages: With `shared_ptr` you've never had to manually indicate reference count increments and decrements, so it already has that 'A'. 
How would that work in conjunction with object orientation?
I'd like to see that as well. If you haven't already seen it you might find this paper interesting: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3449.pdf
&gt; Implicit stuff should be IMO strictly controlled by the standard committee and never given to users. By that logic, nobody should be allowed to propose any new library. Or more precisely, nobody should be allowed to use it until the Committee OKs it. Should Boost be allowed to make better containers?
&gt; If the compiler can prove that the dynamic_cast will succeed, then you could write it so a cast isn't needed, right? Well, there are situations where a human reading the code can prove a cast will never fail. But humans ~~are~~ can be, in very limited situations, more intelligent than most compilers. I want compilers to be a bit more intelligent, and for us to be able to help the compilers.
If your code has 100 `dynamic_cast`s, and 98 of them are trivially correct and guaranteed to succeed, and one of them is more complex but correct, and one of them is buggy, then it'll will be hard to find that bug. But if we can remove those 98, then the code will have fewer casts. Imagine, for example, that explicit casts were needed to add `const` to a type. It would be ridiculous, with casts all over the place, and the code would be very buggy. But, as it stands, const_cast is only needed to remove const, and therefore there are fewer casts and everything is more readable and easier to debug.
A standard Matrix lib.
That’d be awesome, but `boost::variant` together with `static_visitor` already fills a lot of that – albeit without such a nice syntax.
Better string library, I kinda like what Python 3 does but it certainly isn't perfect.
Java doesn’t allow this either. Java allows you to specify covariant or contravariant generic subtypes but that’s completely unrelated to type erasure, both in the context of C++ and in the context of Java/C# generics. In particular, your sample code would be illegal in Java as well because it’s *not* safe, despite what’ve said. You’d have to type it as `ArrayList&lt;? extends Circle&gt;`, and for your particular use-case an `ArrayList&lt;Circle&gt;` would do just fine – the equivalent of `std::vector&lt;ptr_type&lt;Shape&gt;&gt;`. There are other situations where generic co- and contravariance would be useful in C++. However, it’s less useful than in Java and C# since C++ uses different sorts of interfaces (e.g. mainly iterator based ones, where this is a non-issue).
&gt; ... casts between types may actually make changes such as pointer adjustments. These can't just be skipped or the pointers will become invalid and the code will do bizarre things. Casts that don't involve such adjustments have no runtime impact anyway, and so efficiency cannot be improved by 'skipping' casts. 'skip' isn't the right word. I just meant the compiler could insert them implicitly. Anyway, here's a much simpler example. The following method, given two shapes, will return the shape with largest area. Shape * getMaxArea(Shape *, Shape *); But given code like this: Circle *c1 = ...; Circle *c2 = ...; Circle *biggestCircle = getMaxArea(c1,c2); // won't compile as is, but I think C++ should accept it as is Currently, this code won't compile. A cast is necessary. We, as intelligent humans, know that it will succeed. We know that the dynamic return type of `getMaxArea` will be equal to one of the types of the value that's passed in.
In vector math you do know the size. Even outside the boundaries of computers the size of vectors are always known in maths. No?
Not a big one, but switching on types other than int (like strings). I'm all for adding lots more stuff to the standard library, but adding core languages features to C++ should be heavily scrutinized. I love C++ and write it for a living, but you can't deny its syntax is hard to swallow at first, and this is only made worse by feature creep.
Is `pow(a+b, 4)` really that big of a problem? Most compilers will inline constant int exponents.
A sane macro-system that obeys scope and namespacing: namespace foo { macro synchronize@@else@(ExpressionArgument lock, Statement true_case, Statement false_case) { if(lock.try_lock()) { evaluate true_case; } else { evaluate false_case; } } } int main() { std::mutex m; foo::synchronize(m){ // do something } else { // do something else } } Also: Named arguments
You can (kind of) switch on strings and other types, as long as you make them constexpr convertible to int. [Example](http://dev.krzaq.cc/switch-on-strings-with-c11/). I agree that it's a tad too complicated though.
This is possible using the [ROOT package by CERN](http://root.cern.ch/). At compile time you specify classes you want to enable reflection in; then during runtime you can do things like calling a member function by name, serialize a class, list possible functions to call, import your shared library into python and call your c++ code, etc. As awesome as all this is, beware, it comes of having to deal with ROOT. Although ROOT 6 that is just coming out promises to be much nicer in terms of dealing with templated functions and hopefully less evil. Unless I'm already using ROOT for a project, the introspection/reflection capabilities don't typically make it worth using. 
Yeah, the quote is a bit old, but still fun. You're correct about the inlining. std::pow is not particularly optimised, particularly compared to gsl_pow_x, so the rest of the statement is still valid.
As for your last point, that really depends on the use case. Deferring finalizers can improve responsivity in, say, UI applications, which is the primary target of current Objective-C.
? I said implicit stuff. a*b+c is implicit syntax i.e. sugar for either a.operator*(b).operator+(c) operator+(a.operator*(b),c) operator+(operator*(a,b),c) operator*(a,b).operator+(c) assuming a,b,c are objects. User defined operators and arbitrary ordering would clearly make behavior *library* dependent, not standard dependent.
I seem to misunderstand something. If 98 of them are trivial why store them in a generic (Object*) container in the first place? Avoid the upcast and you don't need to cast anything, store them in a container of Circle*
If its hidden behind a function call, what difference does it make if you use a dynamic cast? It's hidden. Edit: Wait what, you pass a container of T's into the function and return the first one as a T? Is the example correct? 
I gave an awful example, and it's incorrect. I've edited my original example to retract it. The simpler example is that this C++ method: Shape * getMaxArea(Shape *, Shape *); could be declared in Java as: public static &lt;T extends Shape&gt; T getMaxArea(T , T ); The latter is a slightly better declaration. In both cases, the two parameters much each be Shapes (or subclasses thereof). And the return type must also be a Shape. But the latter version can be slightly more specific as it basically promises that the return type will be as specific as one or other of the two parameters. Given two `Circle`s, then compiler knows that a `Circle` will be returned. I guess this is what you mean when you say: &gt; Java allows you to specify covariant or contravariant generic subtypes .. The question then is "what is type erasure"? &gt; ... but that’s completely unrelated to type erasure ... 
Better standart library. Type classes.
To the best of my knowledge, deallocation is never actually deferred enough to be particularly relevant. The autorelease pool is drained at the end of every cycle of the event loop, so the only real difference it makes is things not running on the main thread get kicked off slightly earlier.
You can separate a template declaration and definition and make a clean header. Just takes some work. E.g. foo.h struct foo{ template&lt;typename T&gt; T bar(const T&amp; that_val_we_need_for_stuff); }; #include "foo.impl" //Important foo.impl template&lt;typename T&gt; T foo::bar(const T&amp; val){ //shorter name for val return val; } 
&gt; Is the example correct? That was my intended example. But following is better: Shape * getMaxArea(Shape *, Shape *); But given code like this: void foo() { Circle *c1 = ...; Circle *c2 = ...; Circle *biggestCircle = getMaxArea(c1,c2); // this is the problem line } In this example, the last line is the problem. Currently, it won't compile. We would need to do add a cast, under the current language. Circle *biggestCircle = dynamic_cast&lt;Circle*&gt;(getMaxArea(c1,c2)); There are two problems with this. First, once you add explicit casts there is a danger of making errors. You might put the wrong type inside the `dynamic_cast&lt;&gt;` and then get exceptions at runtime which you aren't dealing with properly. By analogy, if casts were required to *add* `const`, then the code would be full of casts, including some buggy casts. Best to make all provably-safe casts implicit (e.g. removing `const`). The second problem is speed. An (implicit) `static_cast` is safer. A developer might prefer `dynamic_cast` over `static_cast` because an unhandled exception is better than undefined behaviour.
&gt; generic&lt;T extends Shape&gt; T * getMaxArea(T *, T *); isn't the above equal to this? template&lt;typename T&gt; T* getMaxArea(T* a, T* b) { .... } So when you call it with Circle *c1 = ...; Circle *c2 = ...; Circle *biggestCircle = getMaxArea(c1,c2); it will compile and run as you expect. But with this: Circle *c1 = ...; Square *s1 = ...; Circle *biggestCircle = getMaxArea(c1,s1); it will fail to compile due to type mismatch. It T a circle or square? If you want it to compile, just introduce a generic non-templated overload Shape* getMaxArea(Shape* a, Shape* b) { .... } Late edit, full code example, works fine in GCC. #include &lt;iostream&gt; using namespace std; struct Shape{ virtual ~Shape()=0; }; Shape::~Shape(){} struct Circle : public Shape{ }; struct Square : public Shape{ }; template&lt;typename T&gt; T* getMaxArea(T* a, T* b){ cout &lt;&lt; "Generic T - both types match \n"; return a; } Shape* getMaxArea(Shape* a, Shape* b){ cout &lt;&lt; "Shape - types do not match\n"; return a; } int main(){ Circle c1, c2; Square s1; Circle *biggestCircle = getMaxArea(&amp;c1,&amp;c2); //Ok, types match Circle *biggestCircle2 = getMaxArea(&amp;c1,&amp;s1); //Error, cant implicitly convert return type Shape to Circle Shape *biggestShape = getMaxArea(&amp;c1,&amp;s1); //Ok }
I've recently edited my comment to retract my example. It was bad and incorrect. Thanks for your response. I essentially agree with all of it! Basically, in C++ you can implicitly cast from `int **` to `int const * const *`, but you cannot do this in C. A more boring example is that C++ will allow an implicit cast from `Circle*` to `Shape*`. The list of implicit casts should be made a bit larger. More implicit casts means fewer explicit casts, which is safer. And it can be faster if that means a `dynamic_cast&lt;&gt;` has been replaced with an *implicit* static cast. I've put a simple example [in another comment](http://www.reddit.com/r/cpp/comments/1tyawn/what_are_features_that_other_languages_have_that/cecrskv) of a situation where the standard should (IMHO) allow an implicit cast, but currently does not.
Concepts Lite is planned to be released as a Technical Specification around the same time as C++14 is published. If successful, it should make its way into C++17.
Named arguments sound awesome but have the unfortunate side effect of reducing pressure to use minimal arguments in a function. I've seen so much task life code that ends up as a bunch of arcane calls to AddToParent(parent, true, true, true, false, nullptr) etc. Named args can make that much more palatable but in the end it is a symptom of something worse. I would still like named arguments or some sort of scope within function call arguments etc. As a way to pass flags / enums which usually seem to be the case. Like ParseToken(no_whitespace | skip_empty); without having to use an entire namespace or other tricks. Sadly I can't envision a sane way to do this and it seems more like an itch than a necessary feature. 
How does the compiler know what getMaxArea returns? For all it knows it could create a new object that is not a Circle and return that, unless it can see its implementation in the same comoilation unit, In which case it depends on where the function is defined if the code compiles or not. Templates can nicely handle that function anyway.
That example makes much more sense. And in fact you can implement `getMaxArea()` so that this works. You just have to tell the compiler how you want to compute the return type. For example in this case we can say 'if the two argument types are the same then return that type, otherwise the return type is this known common base class.' template&lt;class LShape, class RShape&gt; typename std::conditional&lt; std::is_same&lt;LShape, RShape&gt;::value, LShape *, Shape *&gt;::type getMaxArea(LShape *l, RShape *r) { if (l-&gt;area() &lt; r-&gt;area()) return r; else return l; } int main() { Circle c1, c2; Rectangle r; Circle *bigger = getMaxArea(&amp;c1, &amp;c2); Shape *bigger2 = getMaxArea(&amp;c1, &amp;r); // Circle *bigger3 = getMaxArea(&amp;c1, &amp;r); // error: cannot initialize a variable of type 'Circle *' with an rvalue of type '[big long type]' (aka 'Shape *') } What's good about this is that you can implement whatever rules make sense for your specific application instead of using generic rules that may not make sense in your case or just eliminating static type checking altogether.
Garbage Collection Just joking ... What a pile of horseshit. 
Sane error messages from compilers.
Even deferring to the end of each event loop cycle could theoretically be beneficial — it could for instance increase i-cache locality of finalizers, even d-cache as well if the release mechanism is smart enough. Whether this is actually faster than releasing immediately, I couldn't say.
I've often wished for some sort of reverse-ADL that drags in things in the function's namespace for things like `std::bind(foo, _1)`, and that'd also cover flag arguments. Of course, I suspect that even if it made code nicer 99% of the time, the other 1% of the time it'd be enough of an utter nightmare to entirely negate the benefits.
It's funny, the usual complaint about C++ is that it has too many features...
gettext does in fact have a simple scripting language for handling plurals. In the case of Polish, you have "Plural-Forms: nplurals=3; plural=n==1 ? 0 : n%10&gt;=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2;\n" in the header, and then you define three versions of each string that involves a possibly plural word. It doesn't handle multiple quantities in a single translatable string, though.
The worst offenders are usually bools, which can be replaced by scoped enums: AddToParent(parent, ResizeParent::Yes, UpdateUI::Deferred, ICantThinkOfAnExample::Heh, nullptr).
~~Yes. I had considered writing that at the start of the discussion.~~ (Update: I had merely considered the 'naive' template solution. Looking again, the solution here from /u/Plorkyeran satisfies my desire that the final implementation is *not* a template) There are two downsides to that, which are basically just the standard objections to templates. First, if there are a large number of different types then the compiler will waste time and space building a large number of identical functions. Perhaps some compilers can optimize this, and arrange to share the same binaries where the code is identical - anybody know of this? Second, it requires putting the code into the header file (there is another approach, but either way it's not entirely as straightforward as a non-template function. I sometimes really dislike having to do this, even when I'm prepared to ignore the first point above. There might be other, more subtle things, where the template version mightn't be as powerful as the java-generics-style non-template function. Any ideas anybody?
Finally. I’m all for RAII, but sometimes I’m using a legacy system, and I don’t want to create classes to clean-up things when I could’ve just used a finally block.
&gt; even the algorithms library has two algorithms that don't use the allocator interface Three: inplace_merge(), stable_partition(), stable_sort(). The STL's convention is that *persistent* allocations can be customized by allocators, but the algorithms use temporary allocations (and in fact they're specified with out-of-memory fallback implementations, so they always succeed).
Only the trivial wrapper is duplicated and has to be defined in the header, and if it's not inlined out of existence then your compiler is a POS.
I've updated my comment. I should have mentioned the template possibility. I had thought of it long ago, but discounted it because templates aren't very desirable in many cases. This is an example where we could avoid all that, if only C++ borrowed an idea from Java. (I assume Java didn't originate this idea. In fact, I wouldn't be surprised if it was proposed for C++ some time ago! It's a pretty clean idea.)
&gt; How does the compiler know what getMaxArea returns? It's quite safe. In Java, for example, the declaration will be something like: public static // this nonsense is required to declare a free function in Java &lt;T extends Shape&gt; // a generic function, where T is a type parameter T getMaxArea(T,T); // the actual declaration Callers of this function will get the behaviour I'm talking about. And when the compiler is actually compiling `getMaxArea` it can verify that it satisfies this. It will reject any code, as in your suggestion, which just `new` a `Shape` and return it directly. This declares one (non-template) function, compiled once and leading to one block of code in the final binary, which just happens to have a very intelligent type signature, allowing the compiler to do a better job of predicting the 'dynamic' type of the returned object. &gt; Templates can nicely handle that function anyway. Yes, but there are problems with templates. Unfortunately, I've been repeating myself a lot in this thread - I should have been more careful and organized in my comments! See [this for example]. (Sorry again!)
Scoped enums are definitely an improvement, but enums can still be annoyingly redundant for flags, eg (Layout::Resizable | Layout::NotifyParent | Layout::DeferUpdate | Layout::RenderOffscreen) Still a minimal issue though :) I wrote an XP wrapper for Vista taskdialogs that used an options struct which returns a ref to *this: TaskDialog dlg; dlg.Title("stop!!!").WarningIcon().MoreInfo("this is dangerous").OkCancel().DoModal(); Which ended up nice but cumbersome. 
That seems to be the case with a lot of these ideas. Rightfully so I'd say -- c++ is already full of gotchas. 
Sorry, I didn't notice you had two `getMaxArea`s, one a template and one not. That is a great solution. It's very verbose compared to the Java-style solution, but it does the trick. Will edit my comment accordingly. I would still like something like this built into the language, even if it is just a concise syntactic sugar around your solution.
I'd like a standard way to refer to packaged resources within the compiled binary. External files are not always the solution. Windows resources have their caveats but something standardized like that could be great like localization DLLs on windows. 
 if (32 &lt; T &lt; 212) { }
&gt; sometimes software misbehaves &gt; a program decides to use one or two (or more) algorithms I forget where I read this, but an author once noted that people frequently talk about software defects in a way that obscures their true causes. Oh, they're "random bugs". The "software misbehaves" for some reason. The "program decides" to do this or do that. **Wrong.** These are *mistakes* made by *programmers*, who are invariably human. Talking about "bugs" can make it sound like your programs suffer from factors that are outside of your control. But mistakes are just mistakes, where somebody screwed up. (I'm not saying that "bug" is a bad word that should be avoided; I use it frequently. I'm saying that it can be misused.) As a professional code reviewer and defect fixer, I pay attention to both program structure and programmers. I would say that many mistakes (perhaps 70%-80%) can be found before compilation and execution, by inspecting the code carefully and reasoning about both normal cases and boundary cases. (These aren't limited to runtime values - when working with templates, types also have common and uncommon flavors. For example, integers versus cv-qualified ref-qualified pointers to member functions.) Of course, some mistakes will be missed because they're too subtle. Part of how I improve my programming skill is by keeping track of the mistakes I see myself and others making, and learning how to avoid them in the future. As for paying attention to programmers, because individual humans are responsible for mistakes, they have personalized patterns of mistakes. People have varying strengths at ordinary runtime correctness, error-handling runtime correctness, compiletime correctness, performance, and various domains (e.g. integers, floating-point, I/O, multithreading, etc.). So when I'm reviewing code from a familiar programmer, I pay special attention to their weak areas. (And I know my own weak areas, so when I'm writing code that involves multithreading/etc. I try to be extra hyper careful.)
You have a point there. My thought was of uses in variadic function-templates that need some defaulted arguments. template&lt;typename...T&gt; void debugf(const std::string&amp; format, const T...&amp; args, named std::string function = __CALLER_FUNC__, named std::string file = __CALLER_FILE__, named size_t = __CALLER_LINE__) { ... } Granted this case could be considered somewhat abuse, but
Or better yet use free functions and ADL: template &lt;int n&gt; float length(const vec&lt;n&gt;&amp; v) { return std::sqrt( std::inner_product(v.data, v.data + n, v,data, 0.0f) ); } Thanks to ADL you don't have to fully qualify each length call, it will be resolved based on arguments. So you can put your vectors in a funky namespace and as long as there will be `length` free function defined in it, it will be resolved correctly. my_vector_lib::vec&lt;2&gt; foo; length(foo); // doesn't need my_vector_lib:: Safe and clear. You can always overload for specific vector size, should you need to. 
&gt; having to put the implementation in a header file The problem there is headers, not templates. &gt; This idea here is to allow a more intelligent specification/computation/prediction of the return type, so that the non-template function works well. Well, you've shown how you want to use functions, but not how you want to specify them. It sounded to me like you just wanted some generic rules so that the compiler would figure out if it could get rid of casts. Of course one of the big problems with that, since you don't like headers, is that the function body would have to be visible at the point or use (so that the compiler could do its proofs). I.e. you'd have to put the function body in a header.
That's sort of like writing the RAII class for managing the resource over and over. Why not just do it once? Or you can just use something like boost scope exit. 
lol MATLAB. Just kidding, that's only for every major function.
Obviously if I needed to use it a lot, then writing the class is worthwhile. So, I’m talking about when I just need it once.
scope(exit) is about 10 lines of fairly simple code in C++11.
Does "stop adding crap" count as a feature request?
The ability to flippin' jump past variable initilization while using gosh-darn goto or switch. I know why this is the way it is, but two thirds of the places I would use goto run into this problem and it sucks. Also a carry flag. ^(hey I can dream)
Clang is getting better with this. So there is hope.
I am sure [it's bound to happen](http://gcc.gnu.org/ml/gcc-patches/2013-04/msg00998.html), but I am really hoping to see literal string template parameters. Boy would that make a lot of things more fun then some variadic templates yadda&lt;'a', 'b', 'c', 'd'&gt;.
just the garbage collector from java
Scoped function definitions. I don't want full first-class functions, because C++ object lifetime is so strict, but the ability to define a function within a scope and use it as a function pointer within that scope would really come in handy.
Fun fact: POV-Ray doesn't have an exponent operator because of the disagreement between people who insisted that all unary operators should have higher precedence than all binary operators (like C!) and people who insisted that exponent should have higher precedence than unary minus (like normal math).
I assume you have heard of export. Which did not turn out so well. Given that prior attempt it seems getting templates to work well with headers (and possibly any module system) is almost impossible. At least while maintaining their current semantics (and expressive power). (Yes, the one implementation of export did kind of work, but - in my understanding - wasn't really good at actually separating interface and implementation.)
&gt; Named arguments You'd probably get that for free (well, for a struct definition and a set of braces) if C++ included designated initializers from C99.
C++ does not preclude a garbage collector. 
Why are you typing `shared_ptr` and not `auto`? 
Just create scopes around the variables if you want to jump over their initialization. 
Not only are templates good, but compared to compile time polymorphism, run time polymorphism is kludge in the same use case. 
How would it destroy legacy code, when this isn't legal in C++, or is it?
Modules. And a better standard library that does more real world stuff. It's a bit embarrassing that there isn't any way in standard c++ to create a window and print hello world in it without using 3rd party libraries. But really I wish it was much simpler and had less undefined behavour cases.
It is, actually. Unfortunately. It works like this: ((int)(32&lt;T)) &lt; 212 Example: $ cat | gcc -x c - #include &lt;stdio.h&gt; int main(int c,char** v){printf("%i\n",(int)(-2&lt;-1&lt;0));return 42;} ^D $ ./a.out 0 edit:better example
I had to use that once, it's a crappy solution.
Are concepts supposed to be powerful enough to encode the sorts of typeclasses Haskell and scala do?
Declaring a method to accept `auto` instead of `shared_ptr` doesn't work. void foo(auto); But when we get polymorphic lambdas in C++14, I expect to be writing a lot of (top-level) functions as: auto foo = [](auto x, auto y) { .... }; in order to minimize typing. An even more concise syntax is [discussed here](http://cpp-next.com/archive/2011/11/having-it-all-pythy-syntax/), with an [implementation here](http://pfultz2.github.io/Pythy/‎).
&gt; but don't appear to recognize the shortcomings of Java Generics at all, and you certainly haven't explained why Java Generics are better than templates despite the problems with Generics. Don't worry, I am *not* a fan of Java. And I am not, in any way, suggesting that existing C++ template functionality be removed or changed. I'm looking forward to Concepts Lite for example, and I expect I will be making use of that. &gt; you certainly haven't explained why Java Generics are better than templates despite the problems with Generics. I *never* suggested *anything* like this. Now that's cleared up, we can return to this issues. &gt; but you're not comparing one solution not using templates to another solution using templates: you're comparing using templates to adding a completely new feature. It's not "completely new". The functions I'm talking about are not function templates - we agree on that. These are 'conventional' functions, in the sense that it is quite straightforward to keep the implementation in a normal `.cpp` file and compile it once to be linked in a straightforward manner. There is no need for the implementation to be put into a header file, as is needed with templates. (There is another workaround for templates, but either way it's slightly awkward.) My proposal does involve a more subtle way to express a declaration for this single function (non-template). It's still one function non-template, with one implementation, and with one straightforward parameter list -- this is why I wouldn't say this is a completely new type of function. The only difference is a more complex rule for computing the return type, a rule which is based on the knowledge the compiler has about the types of the variable within the caller.
You're in the wrong neighborhood. :) Seriously though, C++ is a language that started from C, maintained backwards compatibility, and *added* additional capabilities from there. With backwards compatibility being a core philosophy, there's no hope of ever modifying the grammar or libraries back to a minimal working set. The future of C++ will *always* be to add more to the language.
Is it there any benchmark with current WIP of modules in C++? What can we expect to gain with that feature? I think building time is one of the weakness of C++, even on its "marketing" side where people from other languages see that as a clear sign of outdated technology or language.
&gt; Of course one of the big problems with that, since you don't like headers, is that the function body would have to be visible at the point or use (so that the compiler could do its proofs). I.e. you'd have to put the function body in a header. Not true. **TLDR: [This comment from /u/Plorkyeran](http://www.reddit.com/r/cpp/comments/1tyawn/what_are_features_that_other_languages_have_that/cecwewn) demonstrates this very clearly. It's an implementation of this idea in C++. In particular in that example, the implementation of `getMaxArea` is a standard non-template function that can be put in its own cpp file. It does not have to go into a header. That code demonstrates a very lightweight template wrapper function that gives us the declaration I would like. If C++ embraced this, with a little syntactic sugar to make this more concise, then it's an extra feature I would like. In that example code, there is a risk of the developer incorrectly writing the wrapper and introducing a bug, but that risk would go away if the functionality was fully included into the language.** Currently, we could put this in a header file, declaring a function which takes two Shapes and which returns the Shape with the largest area: Shape * getMaxArea(Shape *, Shape*); with a suitable implementation in a cpp file Shape * getMaxArea(Shape *s1 , Shape *s2) { if(s1-&gt;getArea() &gt; s2-&gt;getArea()) { return s1; } else { return s2; } } where Shape is an interface with a virtual method `getArea`. In my proposal, we could change the header file to declare it some way like this: generic&lt;T extends Shape&gt; T * getMaxArea(T *, T*); and the implementation would be generic&lt;T extends Shape&gt; T * getMaxArea(T *, T*) { if(s1-&gt;getArea() &gt; s2-&gt;getArea()) { return s1; } else { return s2; } } When compiling this, the compiler could verify that the implementation is correct and satisfies this declaration. It can prove it for all `T`, there is no need for recompilation for each different `T`. (To be precise, the declaration says `T extends Shape`, so I should say "for all `T` that extends Shape".) It's relatively straightforward for the compiler to see this is correct quite generally and therefore this can be done once, when compiling the translation unit containing the implementation (just like any other non-template function). If this all seems a bit 'magical' or 'dynamic', then don't panic. It's quite straightforward and fits into C++ quite well. It's a standard non-template function where there is more subtlety in the declaration. (To fully support multiple inheritance, I think an extra offset would need to be implicitly passed and returned. Although, actually that could be done at the call site itself, so as to keep the implementation of `getMaxArea` as simple as possible. In fact, `getMaxArea` will then be implemented *exactly* the same as the old `Shape * getMaxArea(Shape *, Shape*);`) === If you ignore the return type, it's essentially the same as the original declaration: generic&lt;T extends Shape&gt; .... // return type ignored here getMaxArea(T *, T*); `T` must be equal to `Shape`, or a subclass of it, and `getMaxArea` takes two parameters of type `T*`. Basically, this means that `getMaxArea` will take two `Shape*`. There is no change in which sets of parameters can be passed *to* the function. The parameters don't have to be of the same type, but they must both be `Shape*` (or a subclass). If, at the call site, the lowest common superclass of the two variables that are being passed is not exactly equal to `Shape`, but instead is a subclass of `Shape`, such as `Circle`, then `T` will be equal to `Circle`. Finally, the return type is basically just `Shape*` as before. But the compiler is *willing* to make a slightly more specific promise as to the type. It says "not only is it a `Shape*`, but I can say the return type is the lowest common superclass of the two parameter types". This is useful at the call site. (It's always useful to make as many *safe* inferences as possible, at the call site, about the code). And when compiling, the compiler can guarantee that this is safe.
&gt; I agree that it's a tad too complicated though. That's actually not too bad, especially with the user-defined literal approach, even if it does look strange to coders new to C++11. It's a sight easier to read than the equivalent template code. In my experience, partial specialization + metaprogramming (which you would need to calculate hashes at compile time without constexpr) seems to give some programmers fits. Instead, flagging a function as "this runs at compile time" is easier for some to handle.
I gather that you do this using closures?
&gt; More freedom to overload operators, in particular to define new operators with arbitrary precedence. This would introduce a curious problem. C++ provides very poor isolation for template and header code; they are compiled every time at the point of inclusion, since there is no concept of a module in the language. Redefining operators with a different precedence could easily disrupt such code in ways not detectable at compile time.
Sure but you could template the method and then operate on anything that supports pointer syntax. 
I am not suggesting that we can change the precedence order of existing operators. But if somebody wants to make a new operator that comes between `+` and `*`, then I don't see any such problem. Such declarations would not change the meaning of existing code - is this your worry?
The problem you run into with C++ is that templates permit primitive types as well as classes and structs. So, unlike Java, there's no common root type that can be used to correctly express generated code after erasure. Also, C++ trends towards being specific, rather than implicit, so it makes sense that the programmer be required to call dynamic_cast&lt;&gt; explicitly in such cases. At least then, the template is understood to apply only to class types; primitives aren't allowed.
&gt; &gt; Locale facets which do not support multi-bytes characters and multi-characters conversions anyway &gt; &gt; Of course they do, how else do you read/write UTF-8 or GB18030 files?. And when multibyte conversions aren't required, they are even optimized away, which is why istream::read() simply calls the POSIX read(2) (or equivalent) Actually, I was thinking of the upper/lower conversion of the locale facet `ctype`: http://www.cplusplus.com/reference/locale/ctype/tolower/. Just because I have a `std::string` does not mean it does not contain utf-8.
Any time I thought I was more intelligent than the compiler when wondering why an optimization had not been applied, it just turned out the compiler had considered a situation where that optimization would break the code and I had not. Note: except de-virtualization of method calls, because the fact that an object dynamic type only changes during constructors and destructors calls is so hard to model in IR.
You could get rid of the `static_assert` and just introduce temporaries: Shape* aa = a; Will produce the necessary conversion without issue.
I suggest you read http://www.reddit.com/r/cpp/comments/1tw0l5/objects_slots_functors_duality/ It addresses exactly the issue of proxy objects, and although it seems weird I remember the days where template meta-programming sounded weird too :)
Only for newly created operators? Okay, that could be interesting. Of course, an easier way to get such a concept off the ground would be to use simple left-to-right ordering and accept the lowest possible precedence. &gt; Such declarations would not change the meaning of existing code - is this your worry? IMO, that's the thrust behind most of the C++ consortium decision making: not breaking existing code. The more I use C++, the more I find myself thinking along the same lines with this stuff. As a practical engineer, I'd be hesitant to embrace language/library features that have the potential to re-write existing code.
I did, see the comment section. This would not have helped to ease the implementation though, just a different (maybe more elegant) way to go about it. The major point was to keep interaction exclusively though the pure virtual interface. All implementation details are kept in precompiled lib.
That is what I was attempting to sketch with the expression `=1` :) At one point though, one really wonder if it is worth having such clumsy scripting attempts within the translation string and if we would not be better off asking translators to learn an actual programming language and provide methods to format the string in the target language directly. I know not whether it would be effective or not, though.
Not by people who use it.
I think I get it now. You're saying that the compiler really needs to know the precedence as soon as possible. But if the precedence of a new operator `====` is going to be different depending on the types either side of it, then things will get very difficult. Assuming I have understood that, I can see that it would not only be *very* difficult to implement, but actually very difficult to even define what behaviour we would want. So, fair enough, I reluctantly withdraw this. It seems to work very well in Haskell, leading to quite readable code. But I guess C++ is too complicated. In Haskell, the precedence doesn't depend on the type. If two different definitions of the same operator are given, they are separated only by namespaces. In case of ambiguity, the developer must specify the namespace (or include include one namespace in the first place) and then the precedence is OK. The code can be parsed, up to and including precedence and building the AST, quite easily. Could something like this be made to work in C++?
&gt; So, unlike Java, there's no common root type I know, but that's not an issue here. In the particular example, generic&lt;T extends Shape&gt; T* getMaxArea(T *, T *); Shape is the common root. The implementation of `getMaxArea` needs to call `getArea` on the parameters and needs a guarantee that each parameter is a `Shape*` (or a subclass). An even simpler example, that doesn't involve any inherticance, is: Circle * biggestCircle(Circle *, Circle*); We can't pass `const Const *` to this, therefore we could try: Circle * biggestCircle(const Circle *, const Circle*); but the *implementation* of that would refuse to return a `const Circle *` as a `Circle *`, therefore we would have to change the return type: const Circle * biggestCircle(const Circle *, const Circle*); This final version isn't perfect though. The following usage *should* work, but doesn't: void foo() { Circle * c1 = ...; Circle * c2 = ....; Circle * big = biggestCircle(c1,c2); } As it stands, this code would not compile. One option is to `const_cast`: Circle * big = const_cast&lt;Circle*&gt;( biggestCircle(c1,c2) ); but most of us would probably simply have two implementations: const Circle * biggestCircle(const Circle *, const Circle*); Circle * biggestCircle( Circle *, Circle*); It's frustrating to have to copy and paste identical implementations for these two versions (four if you include `volatile`). And a template solution isn't entirely ideal. In this case, you want to say "this method will not modify its parameters, therefore it can take them as `const`, and both parameters must be Shape (or subclasses thereof.)" but we also want to say "the return type can be more intelligent. The caller knows more about the types of the parameters, and that information should be used to allow the following to compile": Circle * big = biggestCircle(c1,c2); const Circle *cc1 = ...; const Circle *cc2 = ...; const Circle *cbig = biggestCircle(cc1,cc2); where `biggestCircle` is a *single* non-template function that just happens to have a very intelligent signature. (The point of this `const` example is to make this more like C++ than Java.) I'd like a declaration that says "The return type does not need to be any more `const` or `volatile` than the type of the variables at the call site that are passed in."
Algebraic data types are more of a functional programming thing. It is possible to use fac-simile algebraic data types in scala AFAIK.
http://the-witness.net/news/2012/11/scopeexit-in-c11/
1) Precise tracing garbage collection with movable objects. 2) automatically generated proxies. 3) automatically generated remote procedure calls. 4) runtime discovery of properties and methods (called reflection in other languages). 
Lambdas already give you this (you can cast a lambda to a function pointer if it doesn't capture anything).
The `static_cast`s already will result in compile errors in the same situations. The assert is mostly just there for the sake of compiler-enforced documentation.
Component-based programming. For example: class EntityType { void updated() = 0; }; class Kinematics2d : public &amp;EntityType { public: void update() { x += vx; y += vy; updated(); } private: double x, y, vx, vy; }; class Kinematics3d requires EntityType { public: void update() { x += vx; y += vy; z += vz; updated(); } private: double x, y, z, vx, vy, vz; }; class EntityBase : public EntityType { public: void updated() { getEntityManager()-&gt;setEntityUpdated(this); } }; class Entity2d : public Entity, public Kinematics2d{Entity} {}; class Entity3d : public Entity, public Kinematics3d{Entity} {}; class Entity2d : public Entity { public: Kinematics2d{Entity} kinematics; }; class Entity3d : public Entity { public: Kinematics3d{Entity} kinematics; }; The above would be statically compiled, no virtual calls would be defined, allowing the mixing of components statically without inheritance and templates. 
Some kind of partial class system, to permit much more streamlined separation of private and public portions of the class. One should not have to rely on the horrible hack that is PImpl just to avoid having to rebuild everything when you change private sections of a class.
It is technically legal, it just doesn't do what you think it does. if((32 &lt; T) // a &lt; 212) // b {} Say `T` is 50. `a` evaluates to a boolean, which can implicitly be converted to an integer for the next comparison (`b`). `true` implicitly converts to the integer 1. So in this case it "works". But if `T` were, say, 20, `a` would evaluate to `false`, which is then converted to 0. Then `b` would evaluate to `true`. 
You had me at: &gt; generic&lt;T extends Shape&gt; I completely missed that what you're also pitching here is better/stronger template parameter support. Under the current template specification, it's not possible to restrict types in this manner, hence my confusion. Yeah, the compiler *should* be able to figure out what base types are in play in such a situation, much like it would with any non templated code.
For Linux a close workalike (besides the obvious `lddtree` command) is a Qt-based "[ELF Lib Viewer](https://github.com/sergey-shambir/elflibviewer)" by Sergey Shambir (I'm biased as I wrote the [base version](http://www.purinchu.net/software/elflibviewer.php) of this tool). It's doesn't visualize the dependencies much better than a treeview but then again integrating GraphViz/dot support can't be that difficult either.
Actually, you can do a lot better than this IF you know the list of possible types/values that will be used to instantiate the template by using [explicit template instantiation](http://publib.boulder.ibm.com/infocenter/comphelp/v7v91/index.jsp?topic=%2Fcom.ibm.vacpp7a.doc%2Flanguage%2Fref%2Fclrc16explicit_instantiation.htm) in a .cpp file. It turns out that most of my template functions/methods are near-trivial (one or two lines) and I don't care - and about half the time I have big template functions/methods, I can use this trick to completely hide them.
I know it doesn't work in C++ as it stands. My point was that if it was changed to work similarly to how Python does (where `x &lt; y &lt; z` _does_ work mathematically), legacy code which relies on the current behavior would break hard. &gt; which evaluates `x op y op z` as either `(x op y) op z` or `x op (y op z)` depending on the associativity of op I'm not 100% sure whether Python does this translation or if there is a shortcut it uses, but `x &lt; y &lt; z` in Python is logically equivalent to `(x &lt; y) and (y &lt; z)`. It's really just syntactic sugar.
I think the current direction C++ is going, including Concepts Lite for example, will make an easy path for this Java-Generic-style approach to be included in a future C++. In fact, I now suspect many on the committee already have this in their plan. Even now, with `enable_if`, we can write a template function declaration that insists that `T` is a subtype of `Shape`, or perhaps (equivalently?) that `T*` is convertible to `Shape*`. Concepts Light, in C++14, will introduce cleaner support for these sorts of restrictions. I'm a bit rusty on my Concepts Light syntax, but I think it's something like: template&lt;typename T&gt; T* biggestShape (T* s1, T* s2) requires( is_subtype_of&lt;Shape,T&gt; ) { if(s1-&gt;getArea() &gt; s2-&gt;getArea()) return s1; else return s2; } (There is also going to be some syntactic sugar to make this more concise in some cases.) Normally, with templates, there is very little analysis that can be done on the template before a specific type `T` is specified. But now, thanks to the `requires( is_subtype_of&lt;Shape,T&gt; )`, the compiler can be sure that `-&gt;getArea()` will resolve. It might be interesting then to have a compiler flag that will ask the compiler to analyze each template 'generically' and to give a warning for any template where it can't prove that it will work for all suitable `T`. Basically, we want want it to be the case that, for any type that makes it through the declaration, template&lt;typename T&gt; T* biggestShape (T* s1, T* s2) requires( is_subtype_of&lt;Shape,T&gt; ); // this means &lt;T extends Shape&gt; in Java-style language that same type should work with the definition, and a warning should be given on the definition if there might be a problem. This would allow such a template to be made available in a library with confidence that, as long as such warnings were not present, the function will compile no matter what crazy type is thrown at it by the developer. Also, if the user tries to call `getMaxArea` with a non-`Shape` type, we'll get a sensible error message about `requirement is_subtype_of&lt;&gt; fails ...` instead of something about a failure to find `-&gt;getArea()`. So, with C++14, we'll get good error messages if an unsuitable type is used. I'm not aware of any plan to give warnings in the case where the *template definition* isn't general enough to support its *template declaration* - but I hope it is done as an extension by the implementations! In many cases, such as that given here, all instantiations of the template are effectively identical. This allows an optimization which is supported well by Java Generics. In that case, even before there is a single instantiation, the compiler can compile the definition once (and it doesn't need to be a header any more, so it also doesn't really need to be a template). So really, this feature isn't a huge leap for C++. It's C++14, with more warnings (and errors) where a Concepts Light function template can't be proven to be very general. And finally, an observation that, in many cases, the function doesn't *really* need to be a full template. Not only can the various instantiations share the same "binary" (an optimization trick), but the "pseudo-template" can be defined in a single translation unit and it can actually lose almost all of its "template" properties. For example, you could then have a function pointer type for `generic&lt;T extends Shape&gt; T* (func_ptr_t*) (T*,T*)`, or some such syntax.
&gt; I'm not 100% sure whether Python does this translation or if there is a shortcut it uses, but x &lt; y &lt; z in Python is logically equivalent to (x &lt; y) and (y &lt; z). It's really just syntactic sugar. I would *really* like to know how Python makes that leap, since its comparison operators are implemented to yield boolean results. Perhaps it's a special case in the compiler?
Language-level support for pure functions (not just unchecked empty promises to the compiler like currently proposed). Yes, I am paranoid and think everybody is fundamentally incompetent. And yes, everything in my code starts out with `const`. And no, I am not happy with what can currently be done in `constexpr` functions.
&gt; As awesome as all this is, beware, it comes of having to deal with ROOT. Given how full of subtle quirks CINT is (e.g. support for deeper nesting of namespaces with classes of same name is very subtly and deeply broken) this basically means that one really shouldn't recommend ROOT if it isn't already used. They again seem to go for bundling cling with the rest of their all-and-everything framework which makes reuse and extern support less likely. Hopefully they will fix that later.
I assume you're talking about something like the following, since it's the only thing not doable with lambdas or global functions: void foo() { int x = ...; void bar() { printf("%d\n", x); } function_taking_a_function_pointer(&amp;bar); } This would require runtime code generation, since if `foo` is called simultaneously from two different threads, they need to see different values of `&amp;bar` (since there's no other way to tell `bar` which `x` variable to use). That's a pretty significant requirement for a feature that's useful only in a single very limited case (working with poorly designed APIs that take a function pointer and no context pointer and don't need the function stay alive after they return, but do need to be reentrant). 
Don't get me wrong, I'm not trying to make it C. I like the basic improvements C++ has had for years. Some of the additions just seem like the committee is giving themselves a reason to exist though. I've joked repeatedly about "if you don't understand C++ and need special pointers, maybe you're using the wrong language" but seriously, just write a new language with those new ideas so that C++ users can grasp as much of the language as possible. C++ isn't missing anything that is required for daily use. There is a lot of benefit to not being on a treadmill of additional features such as improved standards compliance, stability and familiarity. It's a real shame that language research has stagnated to the point that we just keep heaping new features onto old designs rather than experimenting and growing while leaving the "completed" languages alone for daily grunt work. 
IMHO, that's not a language, that's more of a meta-platform like QT or .Net. If that's what we want, that's fine, but in that context I think you'd still want more than one language so we're back to QT-like toolkits.
I sort of agree that C is not a hard prerequisite for C++, and in fact the two are very much entirely different languages. Learning C will not make you understand C++ (core syntax aside), nor will it necessarily make understanding C++ easier. But C++ is a meat grinder of a language. If you step in any of a myriad of subtle language quirks, you can spend days wondering why your program doesn't do what it should. Knowing something about the C memory model at the very least can't hurt your chances of persevering far enough to get past the [learning curve from Hell](http://farm4.staticflickr.com/3088/2335016192_44938cf481_o.jpg). Now all _that_ said, if you were to use materials focusing on modern C++, I whole-heartedly agree. The problem with "learning C++" is that you still sort of need to be able to look at older C++ code, which all is the horrific parts. Disclaimer: I love and use C++ almost exclusively; I am not Linus Torvalds' doppleganger. But I've spent 5+ years getting to the point where I've finally realized how fucking crazy the language can get at its depths.
Yea, I use this trick to "precompile" common template parameters in a cpp. Much faster compile times :) But then again, this limits you in some ways. Works for some situations.
Nope, you cannot do this with CRTP, because CRTP requires inserting pointers to members of the enclosing class. 
I learned with The C++ Programming Language, which I think did a great job explaining why the language is designed the way it is. I've heard good things about Accelerated C++, which might be a bit faster-paced, but I haven't tried it.
If you want to learn it quickly then I can recommend "Accelerated C++". It's only down side is that it does't cover C++11, but you can pick that up afterwards.
The bright side was C++11 wasn't covered in the course. 
It's worth learning anyway. But in that case AC++ is probably your best bet, it's very concise at 300 pages.
Yep, that's the one. He also wrote a more beginner-friendly one, but that's kind of out of date and it sounds like you already know how to program.
Thanks. Its worth the shot to read and the other books I have are like longer so its doable. 
You have also the 180 page A tour of C++ from language's creator himself: http://isocpp.org/blog/2013/12/a-shared-view It's not a in deep book but you will get a overall, estandard and C++11 view
If you split this into a first element, and all following elements, then you can make this even simpler: #include &lt;array&gt; template &lt;typename T, typename... Ts&gt; auto make_array(T&amp;&amp; t, Ts&amp;&amp;... ts) -&gt; std::array&lt;T, 1 + sizeof...(ts)&gt; { return {{std::forward&lt;T&gt;(t), std::forward&lt;Ts&gt;(ts)...}}; }
A larger standard library. (XML, threadpool, process, parallel algorithms, web, image manipulation, database access, audio, advanced math, testing, crptography, etc...)
I recommend [The C++ Standard Library](http://www.amazon.com/The-Standard-Library-Tutorial-Reference/dp/0321623215/ref=sr_1_1?ie=UTF8&amp;qid=1388490883&amp;sr=8-1&amp;keywords=c%2B%2B+standard+library). It shows you the STL throughly, and takes you from understanding the language constructs to what you really need to know to use C++. Don't get an older edition. This one covers C++11 and features enough explanation of new features to make you miss them if you go back to C++03.
First off; I just want to say, as a cross platform QT developer, the developers area having that shitty Windows 8 theme? Gross. As for the project itself, this sounds amazing, and may be what gets me to fire up my compiler and try to integrate this into one of my projects. (My personal projects have fallen by the wayside)
Could you please repeat this without all the business bullshit lingo?
What part do you consider gives off that feeling ? Being developpers ourselves, we try to avoid business lingo in development centered communities. :) That being said. As we just opened the beta, we're actively updating tutorials to get the gist of writing multi-users applications with Zeecrowd. The purpose is specifically to not lose time with the various technical dev you have to do to sync all the participants of an application. The documentation is online, if you are more interested in it (see first post). In fact, we're currently working on the tutorial to integrate C++ only apps directly info Zeecrowd. We're happy to answer any further remarks You have. Thank you
It's not crossplatform???
The client has been initially developped under Windows with Qt/c++/qml and javascript. Now, thanks to Qt, the client should be compatible for all platforms :)
Downvoted. * It is not especially useful to simply count percentages of features. Just like how a queen is worth more than a pawn, variadic templates are worth more than extended sizeof. * Given that percentages of features will be counted, this feature breakdown is garbage, which I can say because it was clearly derived from my own work (the terminology "magic statics" and the feature version numbering is mine). If you're set on counting features, then calling lambdas v1.0 and lambdas v1.1 separate features is silly. (And this is definitely being done, because VC 2013's "68%" is 32/47.) Only lambdas v1.1 is Standard C++11. (Again, given an insistence on feature counts, the right way to do it would be to assign partial credit for pre-C++11 implementations using human judgment.) Note that as of my [latest table](http://blogs.msdn.com/b/vcblog/archive/2013/12/02/c-11-14-core-language-features-in-vs-2013-and-the-nov-2013-ctp.aspx) I have dropped the detailed version numbering as people care about final C++11 now. * The data for VC is wrong, I haven't checked the other compilers. Briefly: the Nov 2013 CTP has alignof/alignas (and they are one feature, proposed in one paper - if GCC and Clang implemented them at different times then they simply get partial credit over time), the CTP's support for constexpr is very much partial, extern templates are even older than VC6 (I heard they date back to like 2.0 but I can't swear to that), local/unnamed types as template arguments date back to VC8 last I checked, long long is super ancient and definitely not new to VC10, the CTP supports rvalue references v3, crediting VC8 with type traits is perhaps too early; compiler hooks were added around that time but &lt;type_traits&gt; didn't appear until VC9 SP1. Also, noexcept is apparently missing.
There isn't really such a thing as an accredited course in a specific language. There are courses on intro to programming, or data structures, or operating systems, which may happen to be taught in a particular language but they are designed to teach concepts, not languages. If you want college credits for online courses you typically enroll in a college which offers courses online, earning credit towards a degree at that college. If you are looking for a la carte Intro to Computer Science credit, consider your local community college. But be aware that "college credits" aren't really worth anything until you apply them toward a degree.
Thanks. I might use this as a reference book.
Maybe we get full C++11 conformance with the next paid update to Visual Studio :3
&gt; Downvoted Of course, because you're biased. But that doesn't change the fact that two open source community efforts outperformed your multi billion company backed team. &gt; Just like how a queen is worth more than a pawn, variadic templates are worth more than extended sizeof. With the difference that one party gets 100% of the pieces while the other only gets 68%. It's cool that you have the queen - but the other guy has her, too. And a bunch of pawns to help out. 
VS is quite awful when learning the new standard... I've tried something, it did not compiled. I though it was my fault, but it appeared that it was good C++11 code, but VS had (and still has) a bug. Link for the bug: [at stackoverflow](http://stackoverflow.com/questions/19269345/initializing-map-of-maps-with-initializer-list-in-vs-2013) and [http://connect.microsoft.com/](http://connect.microsoft.com/VisualStudio/feedback/details/792006/c-11-initializer-list-bug-visual-studio-2013-preview)
You are completely neglecting library features, like regular expressions. gcc 4.8 does not support C++11 `&lt;regex&gt;`, so it's quite a stretch to say that it's at 100%. ([gcc 4.9](http://gcc.gnu.org/gcc-4.9/changes.html) does, but it has not been released yet.)
I don't find your comment helpful or constructive. I think STL should be given the benefit of the doubt here given that he is striving to be technically correct, which of course we all know is the best kind of correct. But mostly I find your comment about &gt;your multi billion company backed team to be disingenuous. Clang in particular is backed by at least *two* multi-billion dollar companies. Whereas an awful lot of VC++'s C++11 support was implemented by just one guy.
On the right hand side of this page, there's a small "tabbed" section that starts with "Get Started", it has some beautiful links where you can get resources if you REALLY want to learn the language. There's my favorite link to SO where you'll get reviews on good C++ books.
That would be what is in the current CTP. So do not think so. Maybe full C++11 and 14 support by VS2015/16.
According to this [interview with Tanveer Gani](http://channel9.msdn.com/Shows/C9-GoingNative/GoingNative-21-Visual-C-Front-End-Compiler), two-phase name lookup for templates is still difficult to implement inside the MSVC front end, so even C++98 support is not quite complete.
Will be strange if they implement all 11 and 14 features before two-phase lookup. Depends on the urgency, which is probably low for TFL.
&gt;Whereas an awful lot of VC++'s C++11 support was implemented by just one guy. Are you sure about that ? How do you know ? Do you mean the compiler features or the library part ? 
Ok thanks. Also Happy New Year. Enjoy it!
Dead on STL. I groaned when I saw the word "Random" in the link.
In addition to the famous books others have cited, try peeking through MIT OCW. They had some good notes that can easily be read all the way in a few days. If you have tons of extra time then maybe start coding up a little project for some hands on experience.
Observe that double-counting auto, decltype, lambdas, and variadic templates *improves* VC's displayed percentage, and yet I complained about the inaccuracy. Read my comment again - nowhere did I complain that this depicted VC as being behind GCC and Clang. (I edited it a minute after posting, adding the bit about noexcept missing, otherwise I haven't changed it).
Did you report the bug? If not, as a favor to you, I will report it. Mail a *self-contained repro* including the compiler command line and error output, to stl@microsoft.com .
As a template programmer, I would say that VC's lack of two-phase lookup is a minor annoyance. Primarily, VC doesn't enforce the associated rules by default (i.e. unqualified name lookup shouldn't reach into dependent bases). Also, because VC doesn't really parse templates before instantiating them, "stealth build breaks" are easier to miss. However, I've got workarounds. We have the EDG front-end doing Intellisense now, and I use undocumented options to drive it from the command-line and make sure the STL's tests compile (people are unhappy when VC accepts code but Intellisense squiggles it). I have more undocumented options that tune EDG away from VC bug-compatibility (their usual goal) and towards stricter conformance, including two-phase name lookup and the dependent bases thing. This catches problems that would otherwise go undetected and cause trouble for other tools parsing our headers. Note: our copy of the EDG front-end is physically unable to be used for actual code generation (that would require a whole lot of work, we're not disabling it).
MSVC doesnt build an AST?
Excuse my ignorance but how does this relate to the fact that gcc doesn't implement atomic compare and exchange operations for std::shared_ptr that are listed on references such as [this](http://en.cppreference.com/w/cpp/memory/shared_ptr/atomic) ? Is that part of a standard? 
Well, although generally tied, Standard Library implementations and Compilers *are* different. If you look at gcc/libstdc++ and clang/libc++ you will quickly realize that: - those are 4 projects with 4 development teams (although there is some overlap) - they are more or less inter-compatible in that you can pick either compiler with either library implementation and it should work (in theory) On the other hand, I agree that a breakdown of the library implementations readiness would be helpful.
Like I said in another comment, these comparisons are only looking at language features, not library features, which means they are giving a very distorted view of things. [Here](http://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.200x) is the current libstdc++ C++11 status table, and it's helpfully annotated by the section of the standard. If you scroll down to &amp;sect;20.7.2.5 you'll see that it's marked partial.
Thanks a lot for this clarification. I really appreciate it :)
it appeared to be a [well known bug](http://stackoverflow.com/questions/19269345/initializing-map-of-maps-with-initializer-list-in-vs-2013)
No thanks. Use a legacy compatibility compiler flag and your code now does something completely different.
what do you suggest to do with "feature versions" - like "lambda v1.0" and lambda "v1.1" in the table? Maybe just collapse it and use latest version of given feature? But what to do with compiler that support v1.0 but not v1.1?
Well you know what they say about two turds and shininess and all that.
Partial credit - I'd say lambdas v1.0 are worth maybe 80%, while decltype v1.0 is worth 99%.
This doesn't seem particularly useful without the visitor machinery that Boost provides. That said, I'm guessing this has better error messages than boost provides, which would certainly be welcome. (Recursive structures seem to be missing, too; those, together with catamorphisms, would be a very strong argument.)
This is probably the worst idea I've heard this year. You are basically trying to reinvent a part of the language and breaking the rest. Just as an example: take a look at how you [just broke](http://coliru.stacked-crooked.com/a/680498b75f452fdd) inheritance.
std::tr1::regex shipped in 2008 SP1. Note that we've squashed many bugs over the years; you should upgrade to 2013.
Note that Dinkumware's master sources are portable to the Big Four, but Microsoft requests VC-specific drops with code for other compilers stripped out. (We also ask for C++11 to be enabled unconditionally, because Modes Are Evil.) This is primarily to make our headers more readable (users occasionally debug through them) and preserve code reviewer sanity (i.e. mine). Although we (blessedly) target a single version of a single compiler, my policy is to use VC's non-Standard behavior only when absolutely necessary. For example, we need __declspec(dllexport) for DLL stuff, various pragmas to silence warnings and occasionally work around compiler bugs (e.g. the vtordisp thing), and type traits compiler hooks. I consider unnecessary use of non-Standard behavior to be a bug, since that makes life more difficult for third-party tools processing our headers, and also it makes it difficult to increase VC's compiler conformance in the future. We try to be good about saying this-&gt; everywhere and doing the other things, but I appreciate reports when we've missed something.
&gt; Java's generics provide such a tiny subset of the functionality of templates, and Not true. It's possible to take a function pointer to a generic function, but not to a template function. This is the most clearcut example of an advantage of generics. More on this later. So, yes, there are lots of things that templates can do that generics cannot. But that doesn't matter. Nobody is suggesting that templates be removed or deprecated. In fact, given a choice between templates and generics, I would vote to keep templates. One of the reasons I *hate* Java is that it doesn't have templates! Generics is an *optional* feature that nobody has to use. Generics and templates are not mutually exclusive, they can play nicely together. Anyway, let's call these things "c++ generics" not "Java generics". Bringing "generics" to c++ will do some things that Java generics can't do. And it might be best to leave the word "Java" behind as it brings baggage with it. So, to recap. If we can identify something that generics can do, that template cannot do, then we have a good reason to add it to the language. (Function pointers is one example.) (**Update:** That link to Diet Templates does look very interesting. It reminds me of the code that was posted [here in this thread](http://www.reddit.com/r/cpp/comments/1tyawn/what_are_features_that_other_languages_have_that/cecwewn). But I still feel there are dangers in having to write extra boilerplate like this. Mistakes will be made by developers. But if generics are fully incorporated into the language, we can get the compiler to do the hard work of proving correctness and giving us an error if there is a problem.) &gt; That example only works with polymorphic types. You said you wanted a feature that didn't have that limitation of Java's generics. I should have been more subtle here. Obviously, generics can't have total freedom over types. (Java) generics are limited to polymorphism. But in c++, we have `const` and `volatile`, so we have more "convertability" to play with. Given a function that takes two `int*` and returns the pointer which points to the largest `int`, then it would be nice if the return value was `const` if and only if it *had* to be `const`. The basic idea is "more specific common supertype" - this doesn't just apply to inheritance-based polymorphism, but also to `const` (and `volatile`). Given a function that takes two circles (by pointer), and returns the biggest of them, we might write this first: Circle* biggestCircle(Circle*, Circle*); But, we would want to be able to pass in `const Circle*` to this, because sometimes this all we would have, therefore we could try this instead: Circle* biggestCircle(const Circle*, const Circle*); But, when implementing this, we can't return a `Circle*` from either of the `const Circle *`, so we need to change to this: const Circle* biggestCircle(const Circle*, const Circle*); Everything is const there, which is fine example when we want to write code like this: Circle *c1 = ...; Circle *c2 = ...; Circle *biggest = biggestCircle(c1,c2); This will, at the moment, fail to compile. A current compiler will require a cast: Circle *biggest = const_cast&lt;Circle*&gt;( biggestCircle(c1,c2) ); It's reasonably obvious to us that this cast is safe, because both `c1` and `c2` are non-`const`. But it would be nice if the compiler could see this also, allowing us to delete the `const_cast` from the code. Explicit casts should only be required where the compiler can't prove the cast is safe. (For example, if it was necessary to use an explicit `const_cast` to cast from `T*` to `const T*`, then we would all be angry about this and demand an implicit cast!) You say that generics are a strict subset of templates. For the moment, I'll kind of agree and allow that this code (superficially) provides the functionality I want: template&lt;typename L, typename R&gt; auto biggestCircle(L *l, R *r) -&gt; typename std::remove_reference&lt; decltype( (l-&gt;getArea() &gt; r-&gt;getArea()) ? l : r ) &gt; :: type { return (l-&gt;getArea() &gt; r-&gt;getArea()) ? l : r; } That is *almost* perfect. But we can't take a function pointer to a function template. Before I talk about function pointers to generic functions, I'll tidy up another loose end. &gt; The issue with templates and code size is mostly overblown, I can't really disagree here, I must admit! In my own programming this has never been a problem for me. But, for some sufficiently complicated program, there may be millions of instantiations of the template, and it could be very problematic. Anyway, I'm happy to withdraw that. === Anyway, finally, I'm ready to talk about (template/generic) function pointers. Imagine, we had `biggestCircle` and `smallestCircle`, and we wanted to have a function pointer that could point to either of those, we could use this following function pointer type: typedef const Circle* (*selector_type) (const Circle*, const Circle*); Then, we could do selector_type current_selector = &amp;biggestCircle; // if biggestCircle is *NOT* a template or selector_type current_selector = &amp;smallestCircle; and call them as: current_selector(c1,c2); But, this has limitations. If we use a (non-generic) (non-template) function, then the return type must be `const`, which leaves us with casts all over the place. We want a function that return the most specific type possible. So, when passed two non-`const` `Circle*`, we would like a non-const returned. So, one alternative is to use the template I defined above. But of course, we can't take the address of a template: selector_type current_selector = &amp;biggestCircle; // error if biggestCircle *is* a template The tidiest solution to all this is to allow generics into the language. === So, how exactly could this new feature work in C++? Well, we can start of thinking of a generic as being a "very special" kind of template. In fact, it is so special that it starts to pick up some of the advantages that normal functions have (such as the ability to take function pointers). I feel that it stops really behaving as a template (but still retaining all the good stuff that came from templates!) Anyway, let's introduce a new keyword `generic` that can be put into template declaration generic template&lt;typename L, typename R&gt; auto biggestCircle(L *l, R *r) -&gt; typename std::remove_reference&lt; decltype( (l-&gt;getArea() &gt; r-&gt;getArea()) ? l : r ) &gt; :: type requires is_subtype_or_constvolatile_version_of&lt;Circle,L&gt; requires is_subtype_or_constvolatile_version_of&lt;Circle,R&gt; { return (l-&gt;getArea() &gt; r-&gt;getArea()) ? l : r; } In that code, I have have used a (bodged) version of `requires` (coming up in C++14's "Concepts Lite") to replicate the `&lt;T extends Circle&gt;` logic in Java generics. Basically, it's to provide a suitable constraint on the types - we need to be sure that `-&gt;getArea()` will work. What would `generic` do to this? First, it would need to verify that all possible instantiations of the template will compile successfully. In other words, that all types that make it through the declaration: generic template&lt;typename L, typename R&gt; auto biggestCircle(L *l, R *r) -&gt; typename std::remove_reference&lt; decltype( (l-&gt;getArea() &gt; r-&gt;getArea()) ? l : r ) &gt; :: type requires is_subtype_or_constvolatile_version_of&lt;Circle,L&gt; requires is_subtype_or_constvolatile_version_of&lt;Circle,R&gt;; will lead to a successful implementation. So yes, every such `L` and `R` does have a `getArea()` method. Also, crucially, it needs to verify that *every* instantiation of the template will lead to *exactly* the same binary implementation of the function. This is true here. It's not just enough to be sure that `getArea` exists as a method in the types, it's also important that it exist at the same offset in the vtable. (Anyway, these are just gory details.) Once it is proved that all instantiations can share the same implementation, then they *can* share the same implementation. It can be compiled once, and that single function can be used to provide the address for a function pointer. This address is the *value* of the function pointer, and the *type* of the function pointer is the generic type. So, yes, generics are a subset of templates. But, by being a special subset, we can do some extra stuff. 
Seems, I got it pretty much right a year ago :) http://meetingcpp.com/index.php/newsreader/items/c-in-2013.html
I already technically got my "degree", but I was short by like one or two credits...I've been putting it off for a while. Thanks for the advice.
Definitely more readable by orders of magnitude than the build-in syntax.
If any beginner C++ programmer is reading it, please let me know if my writing style is too complicated / too easy / too boring or whatever :)
I kind of like the linked approach more, much more. - it sanitizes input though a enable_if, to ensure T is a function type - it adds the pointer decoration - most importantly, the name conveys its intent. id says the thing inside &lt;&gt; is what it it, whereas with func_pointer&lt;&gt; the thing inside &lt;&gt; is a function signature. IMO. 
&gt; In C++ there are two things that we can use: C++98/03 also has deque, while C++11 has forward_list. vector's still the best. &gt; There are some differences between the two, which are far too complicated for us to worry about. Argh, no. &gt; If we would want a list of boolean values, we could use: std::vector&lt;bool&gt; v; vector&lt;bool&gt; is a notoriously weird partial specialization; this subtlety should be mentioned, but not immediately. &gt; Adding Elements to a List This "list" terminology is really terrible (it tends to be a shibboleth that distinguishes C++ experience from experience with other languages). In C++, "list" connotes "doubly-linked list". You should say "vector" when you're talking about vectors, or "sequence" if you want to be more general. &gt; Note: we can also access list elements by using v.at(0). What's the difference? (Answer: at() is an abomination.) Don't introduce similar-but-different things without explaining the differences. Additionally this doesn't mention op[]'s precondition, which is crucial to understand. &gt; Now its our turn to keep our list correct by removing the Zebra from the position 2 in the list: v.erase(v.begin() + 2); Augh - doing this is inefficient in general for vector.
Hm, no. _tmain isn't a good start, neither is VS 2008, but you got balls to ask in 2014 clearly. If you teach C++, teach C++, understand that it is a free language, don't make people install some IDE or compiler for following your teachings. Don't exclude those who are on iOS, Linux, Windows or on their mobile, point via links to the choices to use for C++ like clang, GCC, Visual C++ or maybe some online compilers, and then focus on the language. On C++11 and what was before: ofc you also can choose to teach what was before, but C++11 is what will define the future of C++, and with this year, C++14 will be finished. We didn't put up those lighthouses for nothing, their meant to be waypoints guarding us into a better and more advanced usage of C++. So while I regret for everyone that is left behind, I think its better to have a helping hand for all those wanting to join us on this trip.
If there's only a single element, ~~that won't work.~~ (I was wrong. It *will* work. (Thanks /u/Yuushi.) I was sure I had come up with a problem in the past involving empty parameter packs. But I was wrong!) But I think you can simply add a single-element template and it will be OK. template &lt;typename T&gt; auto make_array(T&amp;&amp; t) -&gt; std::array&lt;T, 1&gt; { return {{ std::forward&lt;T&gt;(t) }}; }
Works fine for me with a single element under gcc 4.8.2 and clang 3.3. Variadic template parameters can be deduced as empty. In that case, it will effectively decay into the above automatically.
&gt; This is probably the worst idea I've heard this year. Given the time you posted your post, and under some reasonable assumptions, chances are between 99.59% and 99.89% you end up the year hearing worse ideas than this. 
Thanks! Edited my comment.
&gt;Note that we've squashed many bugs over the years; you should upgrade to 2013. :-D Yep, this is happening this spring!
To be painfully honest tho: CTPs are are absolutely worthless for anything serious. It should not even be considered in this comparison.
I have mixed feelings. This tutorial glosses over a lot of important facts and at times gives incorrect information (like telling that `0.5` is a `float`), but, for a complete beginner, most of that information is irrelevant. To me, it's like letting a first-grader get away with mixing digits and numbers. I like the art (though it gets things wrong as well at times, like misplacing copy in [this image](http://noobtuts.com/content/01-programming/01-c-plus-plus/tutorial-for-noobs-part-5-functions/call_by_value.png)) That said, I don't think C++03 is a language I'd recommend for complete beginners, for that exact reason. Some of mistakes I didn't see reported by others: Someone forgot their breaks (I don't understand how you can put examples without testing them yourself first): switch (day) { case 1: std::cout&lt;&lt;"its day one!"; case 2: std::cout&lt;&lt;"its day two!"; case 3: std::cout&lt;&lt;"its day three!"; default: std::cout&lt;&lt;"its a day after day three!"; } This is **wrong**: `char* s = "I love noobtuts.com";`. Any decent compiler will warn you that this is deprecated, and for a good reason - it's marked as deprecated in C++03 and I couldn't find any mention of such conversion when I skimmed n3337. Overall, the worst thing about this tutorial isn't the vendor lock-in, nor the incorrect information provided, but the fact that it teaches an outdated standard and reinventing the wheel (`round`, `to_string`, `stoi` have all been reimplemented as part of the course).
Of course - they're alphas that aren't even licensed for production use ("go live"). I mentioned the CTP only because it was already in the table.
Unfortunately for us both, yes, I'll hear worse idea than this. Much worse.
&gt; C++98/03 also has deque, while C++11 has forward_list. vector's still the best. I've been using deque more and more as my go-to random access container. what situations is vector 'better,' apart from when you need contiguous memory? 
vector is more efficient. Given the modern memory hierarchy, processors really *really* love contiguity. vector has the densest elements and the simplest iterators (equal to array, obviously). You should use deque only when you actually need push_front, or its (unusual) invalidation guarantees. I've used it once or twice in real programs.
&gt; I couldn't find any mention of such conversion when I skimmed n3337. Correct - this evil conversion was removed from C++11. VC 2013 still accepts it silently without warning, but you can request enforcement with the compiler option /Zc:strictStrings . Unfortunately, although I originally requested a warning/error, by the time it was implemented in the compiler, it was too late for me to change the STL. As a result, the STL won't compile with this option in debug mode (we were unintentionally being bad kitties, jumping up on the counter where we're not allowed and passing \_\_FILE\_\_ to char *). This has already been fixed for the next major version, and the other libraries are being cleaned up too.
I thought that (almost) ever deque implementation allocated multiple fixed sized arrays and used those for storage, giving some contiguity. Is having the entire data set in one contiguous block really that much faster than multiple, smaller, blocks?
Yes, because blasting through a vector results in purely sequential accesses to memory. Main memory is slow and far away - it has pretty good bandwidth but terrible latency, masked by layers of caching. Caches love sequential accesses and hate jumping around. Deque blocks require some jumping around. Additionally, incrementing a vector iterator is just a pointer increment. Deque iterators are more complicated.
&gt; Why do you want to create wrapper for? What would `shared_ref` or `smart_ref` do? It looks like they serve the same functionality as std::shared_ptr. `shared_ref&lt;T&gt;` acts a drop-in replacement of `T&amp;` with shared value semantics. `shared_ptr&lt;T&gt;`, on the other hand, acts as a drop-in replacement of `T*` --not the same thing. In the absence of `shared_ref` you can use `shared_ptr` instead but you will be forced to substitute `-&gt;` by `.`. &gt; I'm sorry, but I don't see a single benefit in this. If you are creating a class that needs the same interface as another class + some extensions, what you probably need is inheritance. The wrappers shown in the blog do *decorate* the interface of the wrapped object, not merely expose it, which is what inheritance does. You can't, for instance, implement `logger&lt;T&gt;` just by making it inherit from `T`.
How would you declare `qsort` then?
You mean templated function ? I will go either specifiying directly the argument type in the typedef, either for template alias: struct test { test() { func = &amp;test::get&lt;decltype(vec)::iterator&gt;; t_func = &amp;std::sort&lt;decltype(vec)::iterator&gt;; } template &lt;typename T&gt; static int get(T value){ return 1; } std::vector&lt;int&gt; vec; using function_ptr = decltype(&amp;test::get&lt;decltype(vec)::iterator&gt;); template &lt;typename T&gt; using t_function_ptr = decltype(&amp;std::sort&lt;T&gt;); function_ptr func = nullptr; t_function_ptr&lt;decltype(vec)::iterator&gt; t_func = nullptr; }; I don't have a proper C++11 to test this one (working on windows), but it should work =)
No, I mean [`qsort`](http://en.cppreference.com/w/cpp/algorithm/qsort), which is a function that takes a function pointer as one of its parameters. It's declared as follows: `void qsort(void *ptr, size_t count, size_t size, int (*comp)(const void*, const void*) );` With the alias from my post, it could become a tad more readable: `void qsort(void *ptr, size_t count, size_t size, function_ptr&lt;int(const void*, const void*)&gt; comp);` I'm not sure what you wanted to achieve with the code in your comment.
I think one of the main reasons programmers go down to C is to be as close to metal as possible without loosing sanity. I don't understand why would some use C and not be interested in the memory layout. Why not simply use some high level language, say Lua?
Just in case anyone stumbles across this post, I did happen to find a course that I think satisfies my original question: http://continuinged.uml.edu/CSCE/Current_Semsearch_detail.cfm?coursenum=90.268&amp;secnum=-061
There are plenty of highly performance sensitive things that aren't memory bound. Eliminating struct padding typically does not improve performance (and sometimes hurts it), and making a program that's using 100% CPU and 100 MB of ram only use 95 MB of ram is not very useful.
Sure, I'm not advocating using function pointers everywhere. But if you do need one, you have a saner syntax available. That's all.
Out side of the embedded enviroment, if you're program doesn't fit in memory you need more memory.
Although I do agree with you. A good reason is that so many people appear to have an aversion to anything non standard and end up writing their own incredibly shitty linear algebra code.
I work in embedded land with sub 32kB ROMs and packing like this drives me, at least, absolutely insane. For instance, someone comes in, and adds a member to this struct in the "wrong place". It's used everywhere and suddenly the memory footprint blows up because it's been carefully packed. Embedded dev rarely means scrounging bytes anymore (though I've definitely been there) and typically you'll save more space with a good refactor than esoteric designs. That's not to say it's not important to know that members are aligned, and why they are but `__attribute__((packed))` I find to be a far more sane and maintainable way to achieve the same goal if need be, ~~and I was surprised the article didn't even mention it.~~ (it is mentioned under `#pragma pack` which is the same thing, thanks /u/IN_STYLE) That's not to say its perfect, since it can be costly as he says, but rarely have I found a scenario where I needed size and speed. I guess I'm mixed on the article, since it's a good source of information on a "dark secret" of C (at least to the relative newcomer) but like you said, he seems to put a bit too much emphasis on just how important it is.
"Manually packing to save few bytes" is *why* we would use C (other than, say, C being the only really supported environment.) These few bytes saved may mean the difference between a cache hit or miss, which in a tight loop or on a vector of a few million vertices can make all the difference between functional and nice try. And yes, nonwithstanding this not being a hire-or-not decision, I do expect an advanced C programmer to grasp this concept. 
So you're saying its never worth reducing your programs footprint? I'm not saying you should be spending months doing this, hell you could probably write a script to try all possible ways to pack your struct and benchmark it when it finds a new solution and have a performance boost that gets you 99% of the way there. Once again, this optimization is context dependent. If you are trying to optimize a struct thats used 5 times, you're wasting time. If you program handles 100's of thousands of instances. Maybe getting rid of that padding is worth it. 
It wasn't the program that didn't fit. It was the data. It would have been useful if he explained his rationale for choosing to reduce the data structure size instead of limiting his allocations. In other words, why was the program allocating so much and was it necessary to do so? It sounds to me that packing was a quick and dirty solution.
Learn to use pahole: http://linux.die.net/man/1/pahole
The order things should be in is really quite simple actually. You are not bin packing you are just sorting. Indeed some languages such as c# do reorder struts for you but C does not because of the way the memory model works. Programmers expect stuff to be in the order they say because that way they can do things like hot-cold splitting and casting void*s around. Compilers /can/ actually emit warnings when they insert padding into a struct but these warnings are very noisy particularly in c++ so they tend to be off by default. In MSVC /Wall does it, in gcc it is -Wpadded
&gt; In cvs-fast-export, for example, one squeeze I applied was to use the knowledge that RCS and CVS repositories didn’t exist before 1982. I dropped a 64-bit Unix time_t (zero date at the beginning of 1970) for a 32-bit time offset from 1982-01-01T00:00:00; this will cover dates to 2118. And then you discover a repository where somebody used a poorly-written custom import tool that left the date fields set to 0, or a developer who set up the repository on a system with the date set incorrectly. It's assumptions like that that break systems. I've seen people use time\_t to store a _date of birth_ and then store it in an _unsigned_ field...
Sometimes cache effects can make caring about structure packing a worthwhile thing. 
This is the array of structs, structs of array issue. Typically if performance is a serious consideration you would arrange your data into contiguous sequences of the same unit. This is not also as if not more space efficient it also allows for the compiler to apply better vectorisation optimisations.
I don't get this mindset. Unless we're talking about a struct that is going to be stored millions of times in a data structure, who gives a shit? Are you really so strapped for memory that you're willing to venture into "I know better than the compiler" territory?
In this specific case templates force you write either a loop or introduce function call which may get optimized away in release builds but not necessarily in debug builds. Since you only have to add two additional implementations per function which are pretty much one-liners anyway I don't feel the generic solution is really worth it.
Support for [LINQ](http://msdn.microsoft.com/en-us/library/bb397926.aspx) would be super
it's better and more secure than the traditional free-for-all which was abused by many
Has anyone tried out the WinRT support in this release? I was able to build it for WinRT but don't yet know how to get some samples building and running. Any instructions out there?
This is not quite true, the tradeoff can be space/speed but it is not because of packing on word boundaries. In fact C offers no standard way to have struts that are not aligned to natural boundaries (#pragma pack is a common non-standard extension). unless you are trying to fit some members into a cache-line the smaller struct is pretty much just better.
Yesyesyesyes.. I am not saying that float is much better than int or double, I really couldn't care less about being 100% correct. The important thing is that people can learn C++ in an easy way. If they don't understand the difference between int, float and double - so what? As long as its fun, who cares really?
Hey, thanks for your feedback! Which op[]'s precondition are you talking about? Other than that, I totally agree with your points, as long as we are talking about expert-level C++. If you never heard about C++ (or perhaps even programming) before, then you don't really care if v.erase is efficient, or if there are ten kinds of sequence data structures - a beginner is happy as long as it works.
&gt; This doesn't seem particularly useful without the visitor machinery that Boost provides. Could you elaborate on this? I added an (esoteric) use case to illustrate the usage: [Fake Algebraic Data Types](https://github.com/apunktbau/variant#fake-algebraic-data-types). &gt; Recursive structures seem to be missing, too In fact, the implementation uses recursive structures. 
If you're that strapped for memory, stick it on disk and employ a lookup
&gt;If they don't understand the difference between int, float and double - so what? You must be trolling.
I like how this was downvoted, apparently whoever did it, didn't even look at what pahole does. Cheers!
&gt; Could you elaborate on this? I like being able to define a visitor and do the work there (type and member names may be incorrect): struct my_visitor : visitor&lt;int&gt; { int operator()(Nil) const { return 0; } template&lt;typename T&gt; int operator()(Cons&lt;T&gt; const&amp; c) const { return apply_visitor(*this, c.tail) + 1; } }; This saves me the trouble of checking and casting, and I suspect it can be checked at compile-time whether all cases have been handled. &gt; In fact, the implementation uses recursive structures. ~~I mean, I see no support for `using list = variant&lt;struct nil, pair&lt;int, list&gt;&gt;;`. The way you do it above fixes the length of a list at compile-time, which isn't necessarily what you want.~~ Hang on, investigating your list example again... I must have missed something in the implementation. Oh! I completely ignored the fact you're actually physically newing things up all the time. But then why use a union? A simple `void*` would have done the job just as well. You did motivate me to try my own hand at it: https://github.com/jesyspa/toy-variant :)
&gt; This saves me the trouble of checking Good point. I'll try to implement the visitor pattern as well. &gt; and I suspect it can be checked at compile-time whether all cases have been handled. But thats not always desired, e.g., consider implementing partial functions like `head` on lists head xs = case xs of Nil -&gt; undefined Cons y _ -&gt; y &gt; But then why use a union? A simple void* would have done the job just as well. * IIRC, deleting `void*` doesn't call destructors, so this leads to memory leaks. * I'm not sure whether `variant.set &lt;SomeType&gt; (someData)` gets statically type-checked when casting to `void*` &gt; You did motivate me to try my own hand at it Nice.
Some people are shrugging this off as not important with as much memory as is available in modern computing, but this information isn't just relevant to memory usage. It is important to understand byte alignment and how memory is utilized in a lot of networking applications. Particularly when designing binary communication protocols.
&gt; -Wpadded Oh thank you. I just checked the man page and it wasn't included in `-Wextra`. I thought extra contains everything, but it seems I was misinformed.
Didn't he mentioned packed in the beginning and showed this as an alternative to it?
&gt; Which op[]'s precondition are you talking about? The index must be within [0, v.size()). &gt; If you never heard about C++ (or perhaps even programming) before, then you don't really care if v.erase is efficient, or if there are ten kinds of sequence data structures - a beginner is happy as long as it works. No. No no no. A billion times no. Today's beginners are tomorrow's new hires. They need to be given a solid foundation so they can build their way up to intermediate and expert understanding. This means avoiding teaching them really bad habits (e.g. erasing in the middle of vectors, new/delete on raw pointers, etc.), mentioning when you're simplifying things or introducing somewhat suboptimal techniques, and explaining as much stuff about the tools they're using as they *can* understand. This last part is *especially* critical for C++, which dramatically rewards deep/correct understanding and dramatically punishes superficial/incorrect understanding (for both correctness and performance). With only diagrams made of boxes and arrows, I can effectively demonstrate the difference between an array, a vector, and a list. (Also a forward_list, but I wouldn't bother, since it's ultra-obscure. deque is too complicated and too obscure to diagram this early, so I'd mention its existence but not much else.) I'd probably do this even before pointers have been introduced, because they don't need to be taught how to implement the things, just a basic idea of the major differences between their representations. These differences are directly reflected in the STL's interface and are important for understanding which operations are friendly to the container and which aren't.
&gt; I also doubt that anyone who is new to C++ cares about compiler warnings They should. &gt; or the difference between C++03 and the recent one. They should.
He's trolling. Just like Linus Torvalds in his famous rant. Just ignore him
&gt; C does not because of the way the memory model works. Ultra nitpick: C++ compilers are permitted to reorder members between each `public:`/`protected:`/`private:`. So if you say `private: int x; private: int y; private: int z;` they can be freely reordered. However, I am not aware of any compilers that have ever taken advantage of this rule.
Ah I missed that. He does mention `#pragma pack` which is the same thing, will edit my post.
The 'up/down' ratio is fuzzed. The sum of votes is what matters and is correct.
Well the author is http://en.wikipedia.org/wiki/Eric_S._Raymond
-Wextra is merely the recommended set that's commonly useful and is far from everything. Clang has -Weverything to enable all warnings, and it's really not something you'd want to use for much other than finding out about new warnings (it turns out there's usually a good reason why a warning isn't in -Wextra).
Compiler warnings are super important from day 1. They're like free signs that say "hey you probably screwed this up here dude!" And even if newbies don't care about them as much as they should, one should always strive to present correct information.
There is an extra section 3.5 on C++ specific warnings, and the `-Wsign-promo` is also very picky about *promotions* from unsigned or enumerated type to a signed type. Note that Clang has an even stricter warning level with `-Weverything`, which you can turn on and then selectively disable some false positive or otherwise unintended warnings (e.g. `-Wno-c++98-compat`).
&gt; I hope not. Setting a value causes no (explicit) type conversions in my implementation, so I assume it's statically well-typed. But retrieving a value does a reinterpret_cast &lt;U*&gt; to the intended return type U, so this, in fact, breaks statical type safety. Tough luck. Basically all your operations take an `int` and then call the right function depending on the value. Those functions have different types; getting the right functions requires passing the right value, and that's not something you can (automatically) check at compile-time. &gt; implicit type matching... Hmm, interesting. I'll have to see whether I can hack something like this together for mine, too; I've implemented the exact same interface that boost has so far. I don't like the idea of requiring `std::functions` (performance), but all in all, this actually looks quite doable. (On the downside, there's no way to handle multiple cases at once this way.)
not when there are only a few votes
&gt; Basically all your operations take an int and then call the right function depending on the value. That's correct. The key is to compute that integer during compile time using a `constexpr`: &gt; constexpr unsigned int index = VariantDetails::GetIndex &lt;0,U,Ts ...&gt;::index; [source](https://github.com/apunktbau/variant/blob/master/variant.hpp#L221) Because the index is known at compile-time, the types are in fact statically well-typed. &gt; I've implemented the exact same interface that boost has so far. Good work. I guess both approaches are equally powerful. &gt; (performance) I assume, anonymous functions are simply transformed into top-level functions (thats why you have to specify the captured variables), so there shouldn't be any runtime penalty. But I don't know how recent compilers handle this, so I'm not completly sure whether this is true.
True. But if you want to increase the speed of your program, you can benefit quite a lot from reducing the memory footprint for better cache utilization. (Slapping on a #pragma pack() might not give you that boost though)
&gt; Because the index is known at compile-time, the types are in fact statically well-typed. I still wouldn't say so. The type-correctness of the program relies on you computing the index correctly (at compile time or not). If you compute it incorrectly, the resulting type errors will not be caught statically; in fact, I strongly suspect that they won't be caught at all. (Of course, I may be misusing the term type safety here.) **EDIT**: Oh, I think I see. I agree that the *interface* is type safe; I'm saying the implementation breaks it everywhere (and that's where the `void*` would be). &gt; I assume, anonymous functions are simply transformed into top-level functions (thats why you have to specify the captured variables), so there shouldn't be any runtime penalty. The lambdas aren't a problem -- the fact you are turning them into `std::function`s may be, as those are quite expensive. You're also copying the `std::function`s around, so I'm not sure how well stateful visitors will work.
Yeah, I am fully aware. But saying "your not a master until you know what I know, and until you can write what I've written" doesn't sound any better coming from him.
Don't take this personally, but I cringe when I hear people say things like that. Who writes your code - you or the compiler? A compiler may try to optimize instruction flow but it won't reorganize poorly designed data structures. A good compiler + lousy programmer results in highly optimized core dumps. 
&gt; I'm saying the implementation breaks it everywhere I disagree. The implementation of setting a value in `VariantDetails::VariantUnion` is statically well-typed as well. This VariantDetails::VariantUnion &lt;bool,int,std::string&gt; variant; variant.set &lt;0,bool&gt; (true); compiles fine, but variant.set &lt;1,bool&gt; (true); gives a compilation error: error: cannot convert ‘bool*’ to ‘int*’ in assignment So does variant.set &lt;9999,bool&gt; (true); because 9999 is no valid index. There won't be any run-time errors when setting a value. `Variant` is only a wrapper to compute this index, it doesn't add any type-safety. Of course this does not hold for getting a value from the variant, because this depends on the run-time state of the program. So, this can not be statically type-checked.
I write the human readable code, compiler writes the machine code. I know a whole lot more people who think they can outperform the compiler in optimizations and data layout than I know people who actually can. In fact, I know a LOT of the former and none of the latter.
TBH, he's always been a bit of a blowhard.
http://channel9.msdn.com/Shows/C9-GoingNative/GoingNative-21-Visual-C-Front-End-Compiler goes into more detail on why - the C++ frontend dates back to the early 80s and the entire design is focused around working with the amount of ram you had then. They're working on modernizing it, but it's an incremental process since no one would be particularly happy with them just going dark for two years.
Mountain View is not San Francisco.
Why not link to the [actual article](http://slashdot.org/topic/bi/comparing-c-compilers-parallel-programming-performance/) instead of the /. discussion about it?
Perhaps OP thought the /. discussion added extra value?
Let's not get bogged down in terminology disputes. I'd still say you could better use a `void*`. If you want to ensure `U*` is convertible to `T*` you can simply static assert with `is_convertible`.
Life would have been so much easier for me when I started coding if I actually read the errors and warnings... Most of my issues are resolved just by reading the damn error messages! There should be tutorials for reading error messages.
Score: 5, Funny
Hmm, I'm not sure I'm worried about value-preserving promotions that simply change the type's signedness. Thanks for the pointer, though.
Jesus christ, the standard was finalised nearly three years ago. Do we really need so much of peoples' time to be wasted on guide after guide after guide on how to use the new features?
But that's **NOT** the point. NOT AT ALL. It's an **alternative**. Not a replacement.
He took the time to make this tutorial in the hopes of helping someone. Either offer criticism / support towards the project or keep it to yourself. Show some respect.
Thank you for making these! It's always good to see activity in the community. I'll be watching them and reviewing them shortly.
Thanks for these! Any chance for translittered versions?
Destructors are invisible unless you look at the disassembly. Const is poorly implemented with (char) pointers. 
Stop encouraging video tutorials.
Videos have their place, but in this case, I'm inclined to agree. Video is fantastic when the content is graphical, and animated, in order to better convey the topic than static text or pictures. For something like program code, it's almost always better to use text: * It's indexable, searchable, and can be easily referenced. * Supports cut-and-paste * It can be reviewed anywhere, anytime, including offline. * It's clear how to skip past irrelevant content, and to stop where the relevant sections start; some students are ahead of the class. Scrubbing for a minute to find the good bits in a video is particularly time consuming.
Thanks a ton man, I learned a lot about the new std pointers. I always just used boost pointers before. I also really appreciate how you comment your code such that I can just read through it, since I view these on my phone and don't want to use bandwidth on videos.
Try Netbeans, I had the same issues as you. As for library installs, try HomeBrew: http://brew.sh/
I have it installed on my mac. ./configure CC=clang CXX=clang make &amp;&amp; make install header and library are in `usr/local`.
Oh jesus you want to use the CDT.. Whatever floats your boat I guess. Have you read through the [setup guides?](http://max.berger.name/howto/cdt/cdt.jsp) Otherwise, I do suggest you switch to a better C++ IDE. Nothing personal and I'm sure you've got lots of experience with CDT but if you can pick up an alternative you'd probably be glad of it when the time comes to use more features. I originally switched from CDT to [Code::Blocks](http://www.codeblocks.org/) and still use it for certain things as it is a pretty great IDE all round, which you can download [here](http://www.codeblocks.org/downloads/26#mac) but for most development I use [QT-Creator](http://qt-project.org/downloads#qt-creator) (yes, even for non qt projects) because it's easy to use, good looking and highly functional (can't stress its functionality enough really, OOB you get a great debugger, excellent code completion, analysis (valgrind and perf) and even error highlighting on the fly.) Also, if you're planning on working long term on the mac, a lot of people give Xcode praise, so it might be worth picking it up. Up to you. Also: [take your pick](http://en.wikipedia.org/wiki/Comparison_of_integrated_development_environments#C.2FC.2B.2B)
Your arguments are valid - that's why I also uploaded all source code on GitHub. The source coded is commented in detail and can be used as a learning tool on its own without watching the video.
Thanks. I've got it installed/compiled successfully (I think, although I haven't used it yet). How do you actually use it in XCode? Something like add a new console target and then ...? 
just add `/usr/local/include` and `/usr/local/lib` to your include search path and lib search path in project build settings.
Huzzah! In that case, keep fighting the good fight.
We can already get good performance off a phone or a pi. There are lots of optimisations to be done though - chunk generation is a big load on the CPU and optimisations there would speed it up greatly. The chunk data getting a new data structure would also cut our memory usage to 1/3 of what it is now. However, compared to the java version it is certainly more efficient on CPU and memory. The JVM is a huge memory hog - today on my bukkit server it was consuming 5GiB with only 10 players on. 
the key here is real time and predictable performance 
To be honest, I use both VI and Netbeans. Homebrew is great!
When someone talk about performance, he open a pandora box Performance is primary be a human (so have the ability to create algorithms) and secondary a perfect knowledge about the hardware (current one, not a PDP-11) and the operating system (used one, not MINIX) You can't write any *performance oriented* code without this vast knowledge "This is OLD! JVM can do this for you!" Did you take any course about compilers? If you did, you must have learnt that compilers aren't omniscient Compilers can do only mechanical transformations to your code, so they are truly limited A compiler is not an IA. even if tracing, jit, hotspot, *...insert your shiny buzzword here* Only a thinking person with the right knowledge can make the code fast What is the meaning of this? That a compiler is only a machine that can do mechanical, easily provable optimizations. This is true in any programming language, even C++ And only a person with a brilliant mind and a solid knowledge about the hardware and OS that he will target can write *performance oriented code* What? Are you saying that is all about thinking and knowledge and not about the language? So why people are using C or C++ for performance critical software? Because it let the developer exploit every characteristic of the components that I said before -- and not only in userspace but even in kernel space Some famous commercial products ship with a kernel module to exploit what is in possible only in ring 0 mode, because the hardware is always limited for complex problems C and C++ consider the developer not a stupid, but a venerable person who can do what it has to be done Java consider the developer as a fallible person that cannot be trusted So in the end writing performance oriented code is put at work a great number of complex and high valuable knowledge and not be a stupid Is it possibile to not be a stupid? Performance is part of the *contract* that the software has with the client. If you work for Oracle DB, you have to do anything you can do to not be a stupid and gain the max that you can from yourself -- you can't "Sorry our DB now is slower because be are too stupid to write complex code" Unfortunately even a game server have a performance contract that have to fulfill even if open source, free, and so on: If a server became too costly to go on, you have to close If there is lags, nobody will play on your server If people are kicked out, they will be mat at you But if you overestimate yourself you also will fail: If your server crash, people will insult you If your server don't work correctly, people will insult you If you server lost data, people will insult you on FB/Twitter/G+/Reddit for weeks As always, a programming language is a mere tool, secondary but functional to archive a result (I know, my english in terrible)
Go manual clarifies their duck-typing is something like in C++ template.
1. Faster compilation. In any method! 2. Hygienic macros, compile time reflection and code execution. 3. Deterministic multiple execution context. In other words, coroutines. 
&gt; The JVM is a huge memory hog - today on my bukkit server it was consuming 5GiB with only 10 players on. That is especially terrible for virtualized servers - e.g. every gig of RAM costs $20/mo at Linode. (And I am not surprised, and indeed quite pleased, to hear yet another confirmation that Java is so memory-piggy.)
Given that MinGW exists, I don't understand why accommodating MSVC2008 was worth the trade off of writing older, less maintainable, possibly less performant and readable code. Given that performance is cited as a driving factor behind the project, why is select-based networking used? The naked pointers/new/delete everywhere make me very nervous. 
The Mojang server is a piece of garbage. Not necessarily because it's written in Java... 
2 years ago, it was 2012. C++11 was most definitely ratified.
&gt; C++11 was published as ISO/IEC 14882:2011[3] in September 2011 Project started on Oct 03, 2011. 
Well, iirc C++11 was ratified on Aug ~~11~~ 12, 2011
Move semantics are a good reason not to avoid C++11.
No feature is "bad" in C++11, just the pitfalls are not yet well understood and documented and I can see why some people will be sticking with 03 for a tad bit longer (also VS is not yet fully 11 compliant. gah). Though, once you start typing 11 code, 03 style is just a pain to write. And if nothing else, as more libraries start requiring 11, it will help migrate old users.
I don't see what the pitfalls are to the following (which, taken together, drastically change C++ for the much, much, much, much, ..., much better): - Move semantics - `std::unique_ptr` - `std::shared_ptr` I mean let's take it point-by-point here: **Move Semantics:** You avoid copies. You write more efficient code. You write code that's less likely to fail/throw exceptions. You use fewer pointers/heap allocations. **`std::unique_ptr`:** If you don't use this, you either use raw pointers and naked `new`/`delete` (which is bad), roll your own (which is time consuming at best, error prone at worst), or use `std::auto_ptr` (which is an abomination). **`std::shared_ptr`:** If you don't use this, you roll your own or use some sort of kludge around raw pointers and naked `new`/`delete`. I don't argue that there are features that are controversial about C++11, about which people have strong opinions, and which we can't really be sure of at the present time -- `auto` comes to mind -- but there are some features that are just so good, that if you have the opportunity to use C++11, I don't see why you wouldn't. Especially not if your "*reason*" is that some people like to use an old version of a trashy compiler -- i.e. MSVC.
I can't speak for him, but VC++ is by far my favorite IDE. At work we keep supporting MSVC specifically so we can develop in VC++.
Fully agreed, and MSVC shouldn't be an excuse not to use C++11. The first one is supported even in my old VS2010, and I take the other two from boost. Boost is a decent crutch until the rest of the standard is implemented.
Pretty nitpicky.
The list data structure described is pretty terrible and is probably responsible for serious performance issues if it's used anywhere important. Passing absolutely everything by value is also likely to be a nontrivial source of performance problems.
There's advantages to passing by value. I wouldn't make claims like that without profiling. They could easily be untrue or just not matter.
I just looked at it. The whole thing reeks of bastardized C code. Given the style they wrote the code in, C would've been a better choice.
not to say that their implementation is good, but some implementations of the standard library are actually very bad.
I haven't read the Gnome / Mono source, so I could be talking out of my a**, but couldn't this: &gt;List reimplemented from scratch and instead to make the List template the List is a standarad bidirectional implementation with Node hosting only the next/prev pointers and a virtual destructor (nice vptr overhead when not needed) then a derived class from Node a template GenericNode. The user of this class has to create his own class Inheriting from GenericNode (see EventObjectNode). be the result of intrusive lists (which do have useful properties)? Otherwise I agree that sounds like lots of amateur mistakes.
For basic types sure. But even for POD, the general recommendation is to pass by const ref and let the compiler decide what's best.
I love the comment on gnome in the articles comments.
To never write visitor pattern again.
Passing PODs by value can be (potentially significantly) faster, but pre-C++11 that was never the case for value types that own heap allocations (such as `std::vector`). It could potentially not be a meaningful performance issue, but that'd require that such types not be used much, which is itself a bad sign about the quality of the codebase.
https://github.com/mono/moon/blob/master/src/dependencyobject.h#L304 EventObjectNode at least is not an intrusive list.
From the linked rant: &gt; it is not clear we got any performance benefit and it is clear that we did worse with memory usage. OP should have really focused on memory usage. While the mistakes are amateurish, they don't seem to contribute to higher memory footprint in a substantial way. Of course, it would be nice to know more details about bloat problems from Miguel, but his rant is so vague that he should really have shut up for now and write a longer post when he has time to explain his gripe with C++ in more detail.
This is the first thing that comes to mind, but it still should be demonstrated from the code. I don't blame OP of course, because de Icaza's post was so lazy it didn't even deserved an answer.
Yea, 250k LOC is a lot of code to audit. 
I was hoping the same but I was continuing opening the code and same errors/mistakes over and over.
Can you please elaborate that?
That is far from being an intrusive list
just slow performance. at least too slow for games.
I would use the phrase not fast enough for games. Conveys the same message much differently :) And even with that there are drop-in replacements (EASTL).
&gt; Const correctness is "nice to have". [Well...](http://www.youtube.com/watch?v=ZWRRXP-XFvY)
I'm not attacking anyone, I was trying to understand his claims. If someone say tool X is behaving badly my first reaction is to see why. I did open the moon code today for the first time and what I find was unbelievable. It's clear that they adopted C++ when they had not but for other reason that the one they claims. Coding is matter of discipline, and if you miss those aspect flagged by you as "nitpicking" then imagine the rest. It's like entering in a restaurant and looking at how the floor is dirty, imagine the kitchen and the rest. For sure he is experiencing poor performance or memory issues (otherwise he is a liar) and instead to pointing the poor code quality they have produced then he points the finger to c++. Open yourself random files on that project, be honest and tell us what you see.
What does this do that the MS tool 'depends' doesn't? Admittedly I'm a bit out of date on MS Dev tools so there may be a good reason that I'm missing. Definitely a useful concept though.
Assert plays a different but complementary role to unit tests. It is self checking documentation for invariants within the source code. It asserts truths about the internal mechanisms of the code. 
&gt; The compiler doesn't care about you writing an initializer list. It doesn't care about its order either. It won't let you initialize non const members in the class definition. Default initialization for non static members is nonexistant. There is just so much missing in C++. A state of the art language shoudn't let you write this kind of code. You're a bit out of date there. [C++11 will let you define default initialization for non-static members in the class definition and will allow you to initialize members in the class definition](http://en.cppreference.com/w/cpp/language/data_members "C++ data member initialization"). Generally compilers will notify you if the order is wrong in your initializer list, but you are correct that initialization order is determined by the class definition, not the initializer list (which I'd argue is a good thing). More importantly, the compiler very much *does* care about you writing an initializer list not only for the initialized field reason, but it also means if an exception occurs while initializing member variables, the compiler will only invoke destructors on the initialized members. That's quite valuable. &gt; Const correctness is "nice to have". But lets face it: Many people don't get it. Actually, "const correctness" is one of the easier concepts to explain in C++... You may argue a language shouldn't default to let you modify input parameters, but C++ has a lot of poor defaults as a consequence of C compatibility. It's annoying, but pretty easy to fix with one's IDE. &gt; const functions: Well, this is nice to have. It goes hand in hand with const correctness in general. Immutability simplifies code tremendously, and as a consequence having const correctness really makes simplifying code much, much easier (and can have some significant performance wins). &gt; Not all classes have all their member initialized: Why on earth does C++ let you do this? Again: C compatibility. Most compilers will provide a warning for this. &gt; Unnecessary virtual destructors: Maybe the reason is that C++ does not warn you about not having a virtual destructor in the cases where you need it. Its likely done to prevent more severe errors. This is defensive programming sonething you learn rather quick when working with other peoples. If you are "doing it right", you can prevent or let the compiler prevent unnecessary virtual destructors. However, often you need to allow for the *possibility* that later on something will be subclassed. In general though, the codebase tends to overuse runtime polymorphism and therefore creates a lot of unnecessary memory and CPU overhead. In general, C++ is not a great tool if you don't know how to use it properly. &gt; While its true that the code should not look like this it is also true that compiled code should behave in a predictable manner. Unfortunately with C++ i can't tell you what will happen. I see you are unfamiliar with standards that allow multiple independent implementations. Pretty much any standard (including all the protocols the Internet is based on) have combinations of "Must", "May", and "Undefined". It's a good policy, and in fact in this particular case it is helpful that the compiler allows different settings depending on a developer's needs for this scenario. &gt; What the author of this blog fails to see is that his list can be seen as a validation of many objections against C++. It is also validation that most of those objections are based on ignorance. Not that it isn't important that there is a lot of ignorance out there or that it is hard to learn C++. That's a very important and valid criticism of the tool.... but *that* is not what most people got (including Miguel I suspect) from Miguel's criticism. &gt; And if we find no other reason lets burn him for Mono. Because mono is bad, because of Microsoft you know... Grow up people. I agree. That is silly. &gt; But since i have to maintain other peoples code i started hating having to work through code written by people clearly lacking a sufficient understanding of C++. Yes! It helps though if at least *someone* on the project has knowledge. It helps even more if they are willing to educate the rest of the people. &gt; I use the language for over 15 years and i don't have a complete understanding of certain parts. There are unfortunately a lot of reasons for this to be the case. Of course, I've been shocked how often I find the same phenomenon with other languages. &gt; But reddit seems full of experts these days. Experts capable of judging a 250 kloc codebase based on a flimsy review. In fairness, I think the critique was just pointing out the subtext about lack of understanding of the tool for people who weren't knowledgeable to perceive it in Miguel's original comments.
For the record, people voting this down ought to be chastised. Even if I disagree with most of what was written in this comment, it certainly added a lot to the discussion.
Icaza is a troll. Everyone should know this by now.
&gt;Unless your regret has to be read as the following: "We regret to have chosen C++ without having a deep knowledge of it and without any best practice to follow". Maybe that _is_ the way it should be read...?
&gt; It's a attempt to mount an ad hominem attack This isn't an ad hominem attack. If someone is complaining about a tool being useless and you notice they are using it completely wrong, then pointing that out is not ad hominem. 
&gt; However, often you need to allow for the possibility that later on something will be subclassed. I strongly disagree with that idea. There are very few cases where it makes sense to derive from a class not specifically designed to be derived from.
FWIW VS2008 supports `std::shared_ptr` (as `std::tr1::shared_ptr`).
Since you asked, I can say that iostreams in Visual C++ are horridly slow. I've actually had to switch to printf in some console apps because the program wouldn't print *text* to a *console* quickly enough. Actually using iostreams (or even C equivalents) for files is a joke compared to what OS APIs can offer. I can also say that STL, which I love, has minor but notable performance costs which can be difficult to avoid. But if you want really bad, you'd have to look at Boost. Holy shit, some of those libraries are bloat-fests. Use of the signals library alone has been known to triple the binary size of nontrivial applications. You should try debugging that code sometime, to see the 20+ function calls between emitting a signal and receiving it. Christ. The serialization library is also terrible. It's slow, and the non-optional overhead for each serialized object is just ridiculous. The numeric conversion routines are also dog slow compared to compiler provided routines. That's because all the other conversion routines use lexical_cast&lt;&gt;, which just isn't appropriate for performance sensitive applications.
It should be easy to see how much memory is allocated for various object types. I say should be, but I don't actually have a good method. Do you have a good way to visualize allocations by type?
Asserts protect you when you're actually using the program, as well as during unit tests. I've never seen complete unit tests beyond trivial programs, so this is important.
&gt; There are very few cases where it makes sense to derive from a class not specifically designed to be derived from. And fewer cases again to treat such a class polymorphicly, i.e. managing it through a pointer to the base class. 
Uninitialized members are useful, but they're also dangerous. I think zeroing should be the default behaviour, with syntax to explicitly disable it.
&gt; There are very few cases where it makes sense to derive from a class not specifically designed to be derived from. Yes, but there are many cases where a class is designed specifically to be derived from, but for which you have no derived classes at the time you create it.
I think these were just anecdotal points to the larger problem with the code base.
Why on earth would constexpr be covered before smart pointers and presumably the standard containers and algorithms.
spot on. as a rule of thumb, i think any code that doesn't fine tune the memory allocation shouldnt be written in c++. one of the major qualms i have with iostreams is that it clusterfucks memory with data manipulation. although the library is needed to simplify c++ and make it accessible, it also gives a very bad example of how c++ should be used. strings fall under this category as well another issue i have it OOP in cpp -- to be used, but with great moderation. 
Fine, I'll accept your argument.
What exactly do you expect him to do? A complete review of the codebase?
If you want to take the time to profile the problems, please do. The rest of us are trying to have a conversation without spending all week at it.
&gt;&gt; The numeric conversion routines are also dog slow compared to compiler provided routines. &gt; Don't use a hammer for your screws. Grab a screwdriver instead. Have you used the various conversion routines in Boost? There's no obvious sign that they're not appropriate for converting text to numbers, they're just slow.
iostreams are slow because the design is terrible; it's not an implementation issue. `lexical_cast` was horribly embarrassingly slow for a very long time, but that did finally get fixed. It's now reasonably fast for `std::string` -&gt; number.
That's true, and it's not like that software project is being maintained or anything. Seriously though, the only aspect of my feedback that is C++11 related is the stuff about default initializers, which is a silly thing in the first place.
&gt;The first one is supported even in my old VS2010 I could be wrong, but while MSVC supports move semantics per se, I don't think it supports automatic generation of move ctors/assignment operators, even in the latest release.
&gt; I also love Java There's your problem.
Only moonlight is C++, and that was started in 2009.
Yea - here's a comparison for integers http://www.kumobius.com/2013/08/c-string-to-int/ 
That is a fine point, and technically you only need the virtual destructor if the type is *destroyed* polymorphically (which means that the object owner themselves only sees the base class). Of course, the complicated bit is that unless you are passing the object around by reference *everywhere*, that likely won't end very well. So, not having the virtual destructor in that case basically declares a base class as never having value semantics, which is a really odd contract that will catch developers off guard. It's probably much better if the compiler is smart enough to identify the cases where there are no invocations of the destructor against the base class and does the optimization at compile time.
&gt; iostreams are slow because the design is terrible; it's not an implementation issue. Sure, but I don't think we're talking about different implementations of the same interface. Rather, we're talking about similar functionality provided by different libraries (or roll your own).
Yeah, I've always thought he was a total assclown. 
I wanna some lib to build parser as easy to use as [PLY](http://www.dabeaz.com/ply/) (check these [slides](http://www.dabeaz.com/ply/PLYTalk.pdf)). I also wanna some extensible/flexible libRPC with C++11 lambdas callback style.
The claim was specifically that "some implementations of the standard library are actually very bad". I don't know how to interpret that other than saying that some implementations of the interface specified by the standard are of low quality.
Your requirements are a bit ambiguous. What's the include directory? What does the "third party" directory look like? Why are you using a Makefile if you're using cmake? Anyways, here's my guess at something like what you want: CMakeLists.txt project(&lt;project name&gt;) cmake_minimum_required(version 2.8) list(APPEND CMAKE_LIBRARY_PATH "${PROJECT_SOURCE_DIR}/thirdparty/lib") list(APPEND CMAKE_INCLUDE_PATH "${PROJECT_SOURCE_DIR}/thirdparty/include") add_subdirectory(src) src/CMakeLists.txt find_package(Boost 1.52 COMPONENTS filesystem REQUIRED) include_directories(${Boost_INCLUDE_DIRS}) add_executable(&lt;exe name&gt; main.cpp) target_link_libraries(&lt;exe name&gt; ${Boost_LIBRARIES}) Then run from your repository root: mkdir "build"; cmake -D ../ -DCMAKE_PREFIX_PATH=../thirdparty You may want to put this in a script so that you don't have to switch to a build directory. It's also highly recommended not to do what I said above - your build directory should live outside of the directory where your repository root is. Boost is one of the more complex packages that CMake can find, requiring several configuration options potentially depending on your needs (e.g. static library, multi-threading etc). http://stackoverflow.com/questions/9254791/cmake-and-boost Most 3rd-party libraries are included via `find_package(&lt;package name&gt;)`. Some helpful tips: `cmake --help-commands` prints the entire manual. `cmake --help-command &lt;command name&gt;` prints the documentation for that command. CMake has pretty decent documentation, although it may be difficult to find. Also, you may want to avoid embedding third-party code directly into your repository. Usually a far better strategy is to just come up with a way for CMake to find the installed things on your machine (you can specify a custom directory for CMake to look for built libraries/source code). Your repository size won't be bloated with binaries &amp; you won't have to worry about incompatible licenses polluting your source tree. Other CMake tips: add_library - to add a library to your project. similar to add_executable list - manipulate a variable storing a list of items (i.e. ; separated). set - generic variable manipulation. space-separate items are treated as lists. use " properly to quote things. Many commands have a "verb" component that selects a particular subset of functionality (e.g. `file(READ...)`, `file(WRITE...)`, etc). http://www.cmake.org/Wiki/CMake_Useful_Variables
That's the best thing I've ever seen. I totally lost it at the last two lines.
gtkmm? Unlike Qt it at least follows most C++-standards.
Assert has *NOT* to be used to check client input, absolutely not. Assets will disappear in production code. Asserts are only meant to check internal status of your code.
Watching a video about coding is like dancing about architecture 
Interesting, thanks! 
FQA?
Working on it, should have preliminary version out in a couple of months at most.
Frequently Questioned Answers
Ah, thanks.
I think you are in violent agreement with @fkaginstrom (above)
Oh, cool. Thanks for the links. I've not done much in the way of C++ for a few years and want to have a look at the newer features.
I would *love* a library that does what Boost does, but is: 1. More opinionated. Sometimes it's nice to just have a simple, well-defined API that does what it's supposed to, without infinite pluggability and customizability. 2. Less of a template mess. It's sort of a consequence of (1), but the fundamental design philosophy seems to pretend that everyone is working under the most draconian constraints. 3. Less of a time hog to compile. It's sort of a consequence of (2). Boost does everything in templates to be maximally compatible, but it means that almost all implementations are in header files. Just return that `shared_ptr` pointing to a virtual interface. Just assume we're all using `std::string`. It's OK. When it isn't, people have other options. Don't try to be everything to everyone.
Zero of them. Some are not solvable; others simply aren't problems to begin with.
I kind of want to make a full class library for C++ as a fun project. I've got quite a bit of figuring stuff out to do yet because I'm crazy and want to be able to link entirely against code I understand (no magic libc++ or libgcc or whatever). So, I'm kind of stuck at writing my own C++ runtime. I am learning a lot, though. If I ever actually get more than an incredibly nonstandard CRT, I'll definitely release it under some open source license. 
There are libraries like Poco and some others... Qt comes to mind for example as well...The problem IMO with those libraries is that they don't mesh well with the STL. Even if they support the containters, etc, they use different naming conventions which ends up making your code look like it was written by toddlers.
What about the non-gui part of Qt?
wxwidgets? unlike gtkmm it's truly multiplatform, and not just a wrapper around a C api. or fltk, for that matter. though I haven't used any of these, I'm pretty happy with qt.
since I seem to be recommending Qt everywhere in this thread, why stop here. Qt has a nice parser generator called QLALR: https://github.com/qtproject/qlalr
If the elements do not need to be in any particular order then you can delete it as follows: template&lt;typename T&gt; typename T::iterator Erase(T&amp; container, typename T::iterator location) { auto index = location - container.begin(); if(location != container.end() - 1) { *location = std::move(container.back()); } container.pop_back(); return container.begin() + index; } The above algorithm will remove the bullet in constant time, as opposed to the linear time normally required to remove an element from a vector. If it's freeing the memory that you're concerned with, then store your bullets using either unique_ptr or if you're using an older C++ compiler use shared_ptr. std::vector&lt;std::unique_ptr&lt;Bullet&gt;&gt; bullets; // Newer C++11 compiler. std::vector&lt;boost::shared_ptr&lt;Bullet&gt;&gt; bullets; // Older C++ compilers.