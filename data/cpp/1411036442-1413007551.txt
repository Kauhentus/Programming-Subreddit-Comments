This problem has been solved by `boost::variant`. And would look something like: using inner_container=boost::variant&lt;std::vector&lt;int&gt;, std::vector&lt;std::string&gt;&gt;; std::vector&lt;inner_container&gt; l; l.push_back(std::vector&lt;int&gt;()); l.push_back(std::vector&lt;std::string&gt;()); http://www.boost.org/doc/libs/1_56_0/doc/html/variant.html 
We use Travis + cppcheck + clang-format in Open Transactions: https://github.com/Open-Transactions/opentxs https://travis-ci.org/Open-Transactions/opentxs While cppcheck isn't the best solution out there, it does provide some basic checks that pull requests aren't breaking things. clang-format is nice too, for forcing some basic consistency in the way your projects look. 
 Actually, you're right and I remember now why I can't use it. This particular piece of code needs to patch back to a product version compiled with 2003. `nullptr` doesn't add any value in this context anyway, certainly not enough to warrant two different versions of the code. We only moved to 2010 like a year ago or something. Very recently.
We use CruiseControl.Net, NAnt, and Boost::Test.
Why not keep using jenkins? I've got jobs setup to build an statically analyze a C++ project I work on which kick off every time someone pushes a commit to github. Jenkins has plugins for pretty much everything.
Why can't you use Interlocked* operations and a mutex? I guess you're doing x86/x64, so you should do InterlockedCompareExchange and compare to 0 to force the reading of table in all cases. Also, continue to use the mutex/CRITICAL_SECTION/whatever you're using for the case when the first read is zero. Either that, or just use an initialization object a-la-static initialization counter pattern, and never call this outside of main.
Pointless. In fact, rather stupid IHMO.
&gt; It's really that simple. You are underestimating the ability of some people to dig a deep hole for themselves. I have a codebase with a bunch of statics, some of whom start fucking threads, and thread functions use other statics. Nightmare. I suspect Crazy\_\_Eddie is in a same shit.
Neat, although I was upset to lose a point because I clicked on the second of two duplicated lines, instead of the first.
He talks about *C++14* concepts?
Jenkins is indeed perfectly fine for C++. The biggest problem with Jenkins is the learning curve, so if you already know how to use it there's not a lot of reasons to use anything else.
Make SFINAE less hideous looking, Concepts, Solutions for the elimination of macros and header files, Language extensions for parallelization I don't know. The most advanced topic in C++ is the one that hasn't been thought of yet.
Either template metaprogramming or cross-platform software architecture, although that's more of a general software engineering topic.
Jenkins is good. drone.io codeship.io are excellent and free for OSS. drone can be downloaded from and run locally. All linux though, if msvc then you can run msvc under wine. cmake can use ctest (we use ctest to as a runner and gtest as code in MaidSafe). There is also a dashboard which can monitor coverage and test timings (handy if a test starts going too fast or slow). We also run everything debug/release and use clang and gcc santisers as well as being able to use valgrind. All this is automatic and tied into pull requests. It's a load of work, to get right and then add in version handling and auto deployment of installer packages. Then you have of course the hassles of installers (fpm helps a little, windows advanced installer to). Hope some of this helps, it's hard to set up and get right. We are in the middle of hopefully releasing some scripts to help. You can see much at github.com/maidsafe and dash.maidsafe.net etc.
We use Jenkins, CMake, Google test. Each time has different test frameworks and CTS for their projects but they all come out in xUnit format for Jenkins.
Understanding compiler errors for template functions and classes.
Multi-threading, especially lock-free data structures. Not 100% specific to C++ though.
I find that most people have trouble with [this principle](http://en.wikipedia.org/wiki/KISS_principle).
I would say that the most advanced topic in C++ is the same advanced topic as in any language: the art of writing maintainable software. It's by far the hardest thing to get right, especially in your average development environment (businesses), and if you develop the skill you'll find that the other crap either comes fairly easy or can be completely ignored as not helping you achieve that goal.
The internals of STL.
Switch to clang/llvm. it's so much better. 
The } operator. So much happens every time you hit the end of a scope. We may as well start calling it an operator. If you do not understand what is going on it will seem like a weird kind of black magic. I think this was brought up in one of Herb Sutter's more recent talks. Close second: Memory access patterns.
On a related note, I'd love to see this as an IDE feature. Maybe as a plug-in for CLion? It would be cool if you could quickly generate the sequenced-before graph for an expression.
I would say overload resolution. If you haven't written a compiler, you don't understand how it works. I've been a C++ professional for 18 years. I haven't written a C++ compiler though, so I don't fully understand overload resolution.
`std::advance()`. Nothing is more advance than `advance()`. Not even `next()`.
The most technically advanced is lock-free programming with atomics, especially with relaxed memory ordering constraints. Most people are never going to touch that though. http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2 The most advanced topic that is commonly practised is template metaprogramming. Another good one is type deduction and its interaction with reference collapsing. http://vimeo.com/97344493 
https://www.youtube.com/watch?v=YQs6IC-vgmo
Instead of guessing at hotspots, load this up in a profiler. * OSX: Instruments * Linux: Valgrind or oprofile. Visualize with kcachegrind It could be something in your code. It could also be a limitation of lodepng.
From a first glance, it could be your usage of list. You almost certainly want to use vector instead.
You're also copying data structures all over the place. Either use const&amp; or explicitly convert to an rvalue with std::move. E.g.: return to2D(std::move(longImage), width, height); 
Thanks, I'll switch back to vectors.
I get it, I get it. I'm switching back to vectors. Is a 2D vector of pixels better?
TIL what references are. Thanks.
I think this solved it. Appreciated.
Why do you convert the image from a flat efficient vector, to a slow *component* list (thats 6.2 million nodes for a 1080p image) - then immediately convert that list to another structure. Just convert the flat vector directly without the indirection. Also your final structure should be a vector&lt; vector &lt; pixel &gt;&gt; which will almost certainly be much faster, especially if your compiler supports c++11. Do a search on move semantics. 
&gt; Increments given iterator it by n elements. If n is negative, the iterator is decremented. In this case, type of it must meet the requirements of BidirectionalIterator, otherwise the behavior is undefined. &gt; Complexity is Linear. However, if type of it additionally meets the requirements of RandomAccessIterator, complexity is constant.
Learn about auto vectorization, which is about how the cpu registers are utilized to speed up loops and memory opertions. Watch the 13 minute presentation of vectorization and then go back and fix your for-loops if they need to. http://channel9.msdn.com/events/Windows-Camp/Developing-Windows-8-Metro-style-apps-in-Cpp/Getting-the-most-out-of-the-MSVC-compiler-AutoVectorizer The links from the last slide: Detailed blog series explaining AV: http://blogs.msdn.com/b/nativeconcurrency/archive/2012/04/12/auto-vectorizer-in-visual-studio-11-overview.aspx http://channel9.msdn.com/shows/c9-GoingNative/goingnative-7-vc11-auto-vectorizer-c-now-langnext Edit: Think about changing data types IF it helps with auto vectorization (e.g. change uchar to int in your pixel class)
I probably don't understand either, but doesn't the compiler take the type given to the call, compare it against all overloaded definitions, and pick the one that matches? Matching is either exact or it falls into some rules for implicit conversion. If nothing is matching, compile error? That's how I imagine it working anyways... Type resolution sounds like the most complicated part, at least with errors that's the hardest part for me to translate.
Yea, this is where my vote goes too. As far as advanced topics in the C++ language. Its not the hardest part of writing C++ code though IMO. That goes to large scale maintainability and architecture of C++ programs for me.
I agree with designing big projects.
&gt; Yea, its hard because there is no obvious right answer. And there's multiple wrong answers. It's also different depending on what you are supposed to be targeting. Performance vs. scalability for example...getting something to run faster is not always the best way to scale, and visa-versa. Then you have to fit whatever that is into something that's not this massively coupled blob. I think the code smells and SOLID principles paradigm get you a long way there though. That and TDD, even if applied in an impure manner. I managed to lead at least one team to create an architecture that's survived at least 5 years. I keep asking my old manager if it's still easy to add new features and apparently it is so...musta done something right. It's fun, rewarding, and really fucking important. Only thing you have to really watch out for is getting into overarchitecting. I'm not entirely convinced there is such a thing, but if you spend too much time on the architecture and never release...well....then all you've done is waste a bunch of time.
&gt; vector&lt; vector &lt; pixel &gt;&gt; a vector&lt;pixel&gt; would be much better. 
It's so complex that partial specialization of function templates is not allowed.
A lot of this is getting built into the language now, fortunately.
This is not the correct subedit for such a question. Use the following: http://www.reddit.com/r/cpp_questions
&gt;many modern compilers still get it wrong, including MSVC. You say that as if MSVC getting it wrong is noteworthy. Wouldn't it be more shocking for people to discover: "*many modern compilers still get it wrong, not just MSVC*" ?
ADL lookup plays a big role as well.
This is not the correct subedit for such a question. Use the following: http://www.reddit.com/r/cpp_questions
The issue with clang, in my opinion, is that it just plain doesn't compile some of the same things that compile fine in GCC. I don't know why, compilers aren't my thing, but I've tried to compile a bunch of tools on Mac (clang by default, actually getting GCC can be a pain in the ass but can be done) and it didn't work while GCC compiled it fine. Also my university uses GCC exclusively so my projects won't always work on both even if they are strictly following standards. 
You're probably right, and there are static initialization order hacks you can use to bandaid the problem while you figure out how to undo the big mess.
Yeah last time I tried was over a year ago and it was C, not C++. It was the GBDK (first result on Google). There were a few issues with absolute path references for some things but once I fixed those it would compile on GCC but not clang. 
This is probably because the code is bugged and relies on non-standard GCC extensions.
Name lookup is a whole separate kettle of fish to overload resolution. 
Very well could be. I know clang is more adherent to standards and less forgiving than GCC. Would be a fantastic thing if that meant it supported C11 things like gets_s() but unfortunately only Windows has any support for those "optional" functions. 
The language just specified the memory model and provided some basic components. However, how to use them correctly and efficiently remains to be an advanced topic
Elements of Programming by Alexander A. Stepanov and Paul McJones. If you decide to get this book then check out appendix b. It contains all c++ features that you will ever need.
Glad to see I've earned a fan.
Totally agree, although I firmly also think that over-architecting is a thing. I've come to the conclusion that if something isn't required don't add it. It's much easier to add it later, then to change or remove it later when you realize it dosn't quite handle the situation when you do need it. For instance, how would you expose the ability to clean up local application data? The obvious 'correct' answer to me, is to expose the ability to delete files, requesting the local application directory and the ability to read all files from a directory. Then you implement the 'feature' (deleting all local content) by getting the local app directory, retrieving all files and deleting each file. But, if your requirement is only to clean local data maybe you should expose a function to delete local data. The reasoning might be, the initial requirements didn't call for any reason to access the filesystem so you never developed a solid framework for interacting with the filesystem. Just adding in functions that take a string for file or directory information might not be a good idea because when you do need real filesystem access, you want to present it to your user in a platform agnostic way (objects that represent directory and file heirarchies instead of plain strings) Now you have these old functions that you have to work around when designing a proper way to access the filesystem, with #ifdef's or platform specifc implementations that change the way directory strings are represented. If it was just a function to clear local app data, you could just fix the implementation of that function to use your new filesystem api. That might be a bit contrived but I think it demonstrates the point and I've run into stuff like this before quite a bit. You can't think of everything, yet you don't want a bunch of deleteFilesInSpecificDir() functions either. It's a fine balance and like you said, very rewarding and really fucking important :) 
Yea, like I said I don't know anything about the details, just my own presumptions. I've never written a compiler and C++ is complicated enough to read, much less parse. For templates, I thought that the compiler scans all object files with dependancies on the decleration and basically, just inserts new definitions of each templated function that accepts the types used in the invocations of those calls ahead of time. So before the high level logic i mentioned earlier even get's applied, the compiler flattens out all the template declerations then starts the 'well which overload get's called here logic' That doesn't sounds much more tricky, just another step before the process of selecting the correct overload.
That is basically the hardest part as I imagined it, determining which function to call given the type of arguments right? (Just took a quick look at the wikipedia for ADL lookup in C++) 
Fair enough, using your logic,which 'f' should get called in the following example, or more simply, what should the output be of the program below and why? Note that different compilers will produce different outputs of the following simple snippet of code. #include &lt;iostream&gt; void f(void*) { std::cout &lt;&lt; "f(void*)" &lt;&lt; std::endl; } template&lt;typename T&gt; void g(T v) { f(0); } void f(int) { std::cout &lt;&lt; "f(int)" &lt;&lt; std::endl; } int main() { g(0); }
&gt; Matching is either exact ... That can actually cause some rather unintuitive results: http://stackoverflow.com/questions/4704567/function-with-parameter-type-that-has-a-copy-constructor-with-non-const-ref-chose/4704741#4704741 
That's why Einstein's version was so much better. Keep it as simple as possible but no simpler.
Because they had to or be considered clunky and obsolete, isn't competition great.
Well, I would assume that g(0) would be type int. so this would be the pre-compiled c++ compiled (flatted I mean) #include &lt;iostream&gt; void f(void*) { std::cout &lt;&lt; "f(void*)" &lt;&lt; std::endl; } void g(int v) { f(0); } void f(int) { std::cout &lt;&lt; "f(int)" &lt;&lt; std::endl; } int main() { g(0); } Which since 0 is defaulted to an integer, would go to the only required definition of g(). Ohh.. interesting. So the definition for g(int) is placed after f(int) so technically, g(int) wouldn't know anything about any f() functions. This must mean that the compiler must expand template definitions after the non template definitions have been evaluated and they are essentially treated as declared first. Assuming your code compiles. Sooo.. I guess I would expect g() to have full knowledge of all overloaded versions of f() and make the correct decision to call the one declared to take type int. 
Competition is fantastic. I only wish there was more.
Well, too many competing open source projects can spread and thin out the development power. Two tends to be a good number for this kind of thing.
You're not pre-declaring new_wt, percent_wt1, or percent_wt2 anywhere.
The standard specifies that f(void\*) gets called. This is because f(int) is declared after g is defined, and so g is not supposed to know about f(int), only f(void\*). However, if f(int) was defined before g, then f(int) would get called. There's a good reason for this, which basically involves avoiding inconsistent behavior. For example, imagine if template g was defined in a common header file, but f(void\*) was in only in translation unit A, and f(int) was only in translation unit B. Then calling g(0) from A would print out f(void\*) and calling g(0) from B would print out f(int), despite the fact that it's the same function being called with the same parameters. Having said that, your explanation is still a reasonable one, and in fact it's how MSVC works. MSVC will print f(int), whereas GCC/clang correctly print out f(void\*). And if this seems some what complicated, one can create even more complicated examples by combining rules about how templates perform name lookups and how that interacts with inlined anonymous namespaces combined with argument dependent lookup.
It's not an "operator" though...
With name lookup a close second, in particular two-phase lookup for templates. Even the #3 professional compiler vendor (looking at you MS) hasn't been able to get it working
Priceless. I laughed out cout really hard.
Umm.... boost would like to have a word with you. (that word is several dozen lines long, in fact)
My only beef with clang is lack of openmp, at least in the non-experimental setup, and therefore on OSX. 
Unfortunately I am stuck with 4.2 for the moment. 
buhu if you implement std sort with quicksort you made a crappy implementation and crappy is terrible understatement... that does not mean HH is not great dev, but this it is actually sad that this actually was written let alone code reviewed...
Creating libraries intended for binary-only distribution.
Im gonna guess around $499 to make IDEA. I can't see it being much, if any, more than IDEA. 
Stack unwinding, destructors and local scope ftw.
Which.
It almost is. It takes every assigned scope l-value as an operand and performs destruction. It's like the delete operator but way more powerful and less obvious. Of course, it can take effect before execution reaches its line (in the case of early exit). That's not very operator-like.
Most of the "atomic" operations in the standard library are allowed to use locks. There isn't really anything certifiably lock-free.
&gt; Specifically, understand how much is too much with templates. Well how much is too much? This answer turns invariably up when somebody talks about templates. I’ve yet to see a non-toy example. Is Boost.Spirit too much? Because you can’t go much further, yet Boost.Spirit is the epitome of a good library for me. 
Fun fact: in R, which ostensibly has a C-like syntax, `{` *is* an operator, and you can redefine it: { 1 + 2; 3 + 4 } # [1] 7 `{` = cat { 1 + 2; 3 + 4 } # 3 7
I don't know about boost, I don't use it. What I have as a base of reference is internally developed code. It quickly turned into a nightmare due to the nature of templates to spread around. We ended up with stuff templated over stuff that was also templated. In addition to be generally unreadable and introducing a lot of troubles when you want to hold a generic reference (basically mixing generic programming and OOP), we also ended up with insane compilation times, having most of the code in the headers, and therefore triggering a cascade of recompilations when we changed the most minor thing. I do recognize that there are techniques to deal with these problems, but as I said in another comment, is it worth the price? 
&gt; type safety, but is it worth the price? Imho yes. That's the reason why I prefer Haskell over C++. But I'm not hating on virtual. :) Use templates were appropriate. The most important part of TMP is to know when you should use it. For example, for HPC code it's a good idea, for a reusable GUI application probably not. In addition, I've read that virtual performance is about to improve a lot in C++14. Eli Bendersky posted some performance tests on virtual vs. static dispatch and it looks like that you'll be able to use virtual without performance impact.
What a moveing comment
&gt; is it worth the price? From what I’ve seen, yes. I’ve had to deal with megabytes-long compiler messages myself, when debugging heavily templated libraries, so I’m not saying that the situation is perfect, or that it couldn’t be improved. But those templates invariable served an important purpose, and the price we paid was offset manifold by the benefits.
finFoil is a CAD application for designing surfboard fins. You can find more details and screenshots [here: http://www.swaylocks.com/forums/finfoil-v10-development-preview-4](http://www.swaylocks.com/forums/finfoil-v10-development-preview-4)
Agreed. I think it may as well be or should at least be treated/revered as one. Fun experiment - Write any code using an pre-compiled library where all you have are the visible headers. Now try to prove through source code review that the exiting of any scope where a class from that library is used will not: A) cause a deadlock B) cause a page fault or memory exception C) cause memory allocation Now realize that most device drivers still need to be written in either C or C++ and that Microsoft only really offers a C++ compiler. Yes, I know why it happens. I also know how powerfully this force can be used for "good." But it's hidden "gems" like that cause so much of the C++ hate.
&gt; i wish I had a power to summon /u/andralex so he could tell you that only insane person can claim: "and the added cost of determining if the sequence is already partitioned is virtually zero" Those are Howard Hinnant's words rather than mine. Furthermore he explains how this is and his explanation seems sound to me. &gt; Making sort work faster for sorted arrays to the detriment of all other arrays is a bad idea You've misunderstood; these optimizations do not help just sorted arrays. The patterns helped by this are common in practice. &gt; there is a terrible embarrassing bug, you are not fooling anybody by claiming it is a glorious feature I did not claim this. The bug that causes O( N^2 ) worst case performance turns out to have nothing to do with the unique features of libc++'s sort, and the patch offered to fix it does not appear to disturb libc++'s good performance characteristics.
Thanks!
Resources whose release can fail are IMHO quite rare (yet, fclose fails legitimately 😉). What happens more often is that the **bug** prevents resource release. If that is the case, core dump on a failed resource release is often not a bad choice. That allows, for example, using a modified (e.g. unoptimized) retail build to troubleshoot issues once one knows they are there. Finally, I share the opinion that logging resource release failure, but not signalling it to callers, is the correct "default" action to take.
I take issue slightly with the dicussion at 7m10s, when Dave takes over from Bjarne: "Parallel programming *is* performance programming" When done right, threading is something done to simplify programming. More speed might be a desirable side-effect, but it needn't be the primary goal. A good example is the generators in python. `yield` can be much nicer to use than `return` combined with complex state machines. `yield` is useful even if you have just a single-core single-processor machine. It might be implemented via threads, and it might work well when you have multiple processors. But sometimes it's just about simplicity and not about speed. So basically, "funky" computational models are not just about speed or multi core.
That's not a problem of Clang (the compiler) but a problem of the libraries you use.
considering that 3 years ago I was stuck with g95, I consider that an improvement.
Really cool! Do people often make their own fins or is that for surf shop types only?
I think you probably mean the [Curiously recurring template pattern](http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern)
I might remember this wrong, afaik not all processors have the instructions required to perform the operations atomically. If your standard library implementation uses a lock then it is either required by the hardware or it is badly optimized for the platform. 
I think it's that day when you're debugging template compilation output and you say to yourself "Man, I've really overdone it with templates". In all seriousness, you can go as far as you want to go with templates, but they present unique design challenges to your project. I think a lot of people are introduced to the template hammer, and every programming problem becomes a nail. Of course, I've never really liked the logic of "Well other people can't use the tools or language feature properly, so no one should use it. For me personally, 90% of template usage is for basic generic programming, and for everything else, boost usually covers it.
At least it wasn't f77 ... ;)
Why? It's way harder to wrap your head around for things like looking at one line at a time than a vector&lt;vector&lt;pixel&gt;&gt; is. If it's only going to save me milliseconds of time, I don't want to bother.
That's for MSVC. Does it work with MinGW?
Wouldn't that be usually associated with _concurrency_, though? http://msdn.microsoft.com/en-us/library/gg663528.aspx#sec8
On that I wasted 2 years of my life.
It's still bad to be honest. But I'm not complaining. Every improvement is an improvement!
&gt; getting GCC can be a pain in the ass brew install gcc 
Hmm, couldn't you just tune your PATH env? 
No. You have to create symlinks to GCC or else OS X will keep recreating the symlinks to clang. 
Err, could you cite a source? All I could find is http://eli.thegreenplace.net/2013/12/05/the-cost-of-dynamic-virtual-calls-vs-static-crtp-dispatch-in-c/ and this shows that his virtual benchmarks were as much as 7.5 times *slower* than static dispatch through CRTP. He mentioned devirtualization, but that optimization has a very limited set of cases where it can be applied.
It doesn't look like KCrash supports OS X which it looks like your project supports. Google Breakpad supports Windows, OS X and Linux as a suggestion.
Boost is the only issue I have ran into with trying to decipher error codes/warnings. The only reliable hint a Boost compile error (in GCC) gives me is the line of code in my own program that happens to be listed in the rats nest of error messages.
KISS doesn't have to follow any strict principles, it simply means that you avoid obvious issues like over-optimization of code that does not significantly impact performance, that you don't try to use niche and exotic programming tricks when you can just use the standard library or another library, etc.
I've been trying to find a good comprehensive book on template metaprogramming; does anyone have any suggestions? I can find plenty of short tutorials online but I'd love a full book on it (as of now I only see one book on Amazon for it).
Whhhooosh! Here I am. It's fine to attempt to detect already sorted susbequences as long as that informs later steps in the algorithms.
Wicked. Hope it works out for you.
I, personally, follow a mantra wherein if something that **shouldn't** fail **does** fail, you should throw an exception. **But**, you should throw that exception inside a `noexcept` function (i.e. a destructor -- I believe all destructors should be `noexcept`) so that `std::terminate` gets called, your app doesn't persist in a bizarre, leaked state, and there's meaningful information available (since the code stopped exactly when the failure occurred, not down the line when you ran out of memory et cetera).
vierual has always been more of a maintenance problem than a performance one. Especially when the hierarchy depth goes over '2'.
looks like you discovered the problems with taking templates way too far.
openmp is not a replacement for properly designed thread code!
i would say that correctness and robustness is probably a generally better goal that has KISS as a side effect.
dont do this inheritance template crap.
Good catch, thanks!
maybe allocators ?
For one, vector&lt;vector&lt;pixel&gt;&gt; kinda says to someone reading your code that an image can have different amounts of pixels in each row. Assuming the inner vector represents the columns (i.e. y values) of the image. e.g. with that representation, you could have the following: x x x x x x x x x where `x` represents a pixel. Also, with vector&lt;pixel&gt; all the pixels will be contiguous and therefore much more cache friendly. I bet you if you compare vector&lt;vector&lt;pixel&gt;&gt; to vector&lt;pixel&gt; you will more than likely see a notable difference. and what's so hard about using a 1D array to represent a 2D array? Multiple dimensional arrays in C and C++ are just 1D arrays with syntactic sugar.
I absolutly understood my compiler once. I somehow managed to make a simple error in template code which resulted in exactly 1 message printed by the compiler confused by earlier errors, bailing out 
Argument dependent lookup lookup
I see. Since, by then, I'll know the width and height of the image, I might as well create a pixel[][] array. Would that still cause problems? I'd *really* like to avoid using 1D arrays/vectors to represent 2D pixel maps.
Haven't read it, but this book has good reviews on amazon: [link](http://www.amazon.co.uk/Beginning-C-Through-Game-Programming/dp/1435457420/ref=sr_1_cc_2?s=aps&amp;ie=UTF8&amp;qid=1411241956&amp;sr=1-2-catcorr&amp;keywords=c%2B%2B+games+learn) There are some others. Look them up and see which one you like the most.
ODR violations are some of the nastiest bugs to deal with, so it's always welcome to have more diagnostics. 
This might be interesting for game developers. (Note: "interesting" does not mean that I agree with everything he says.) You might not want to repeat my mistake of [judging it](https://www.reddit.com/r/rust/comments/2gwi11/jonathan_blow_ideas_about_a_new_programming/) *before* having watched the *whole* talk. He has a kind of controversial view on the utility of RAII and you'll see rather pointer-heavy examples of structs that probably make you think "oh boy, he doesn't know how to use C++". But this goes on to a more data-oriented thinking where he's interested in allocating a bunch of arrays in a single block for data locality which makes implementing it rather ugly even if you have things like `std::vector` or `std::unique_ptr` at your disposal. So, what he's getting at is that he likes to see a language which makes these kinds of low-level memory layout optimizations simpler. The ideas he has about making it easier for developers to track down double-free and use-after-free errors sound interesting (basically: a debug mode in which stack/heap canaries with extra meta information are used to allow pointing the developer to the file and line where the memory was previously freed) but I'm not sure whether it's as trivial to implement as he likes it to be. Catching every use-after-free is hard if free memory is used again for storing new objects. So, it looks like he'd be fine with runtime checks that won't catch every error. A very good (critical) response to his talk is IMHO [this one](https://www.reddit.com/r/programming/comments/2gwkkp/ideas_about_a_new_programming_language_for_games/cknquj4) by /u/oracleoftroy
There are a handful of books out there, but [this one](http://www.amazon.com/gp/product/0321227255) is generally considered the definitive text. David Abrahams and Aleksey Gurtovoy are way smarter than I could ever hope to be, so I had to do a lot of work to get through this book and grasp the basic concepts.
Thanks! That's actually the book I was referring to haha. Good to know it's considered a good book.
You mean he wants a garbage collector?
No. He wants a built-in owning pointer syntax `T*!` and `T[]!` with deterministic de-allocation and optional range-checking. The motivation for having it as a built-in is the idea that a compiler/debugger knowing about what an owning pointer is allows for better error messages, warnings and a better debugging experience in theory compared to what `unique_ptr&lt;T[]&gt;` would offer (supposedly). But what makes the case a bit more compelling is the syntax sugar/magic he proposes on top of it that would make it easier to have multiple different things allocated in one block.
I only skipped it, but aside from all the other problems with his talk: * My personal impression is that words are often cleaner to read than special characters, so the syntactic sugar might even make it less readable * Implementing a template for a container that consists of an arbitrary amount of containers with adjacent memory, shouldn't be that hard at all and after that you could just write a few lines wrapper. Maybe I'll give that one a try.
How do you throw an exception inside a noexcept method? I always just assumed that that wouldn't compile.
&gt;Whenever an exception is thrown and the search for a handler encounters the outermost block of a function with an *exception-specification* that does not allow the exception, then, &gt; &gt;- if the *exception-specification* is a *dynamic-exception-specification*, the function `std::unexpected()` is called, &gt; &gt;- otherwise, the function `std::terminate()` is called. &gt; &gt;§15.4 [except.spec]
I only watch Alex because his delusional views are funny... I know I know I am terrible person :P
The things I found annoying: * Lets be empirical about why C++ sucks. No empirical data or even anecdotes provided. * Constructors are just for RAII and you only use RAII in 2% of the code. * All these languages (Go, D, Rust) suck but I've never used them so they might not suck. * Here are some nice ideas that I feel strongly about but I'm going to use the totally worst way anyone would do them in C++ to show you why you should use my way. * I don't know how to use allocators or placement new. I worked with the games industry only peripherally working on some middleware and some of their theories were pretty interesting. I never got to take a look at their code but after listening to this guy, I wish I had got a chance to look at their code. However, I did get the impression that there is a combination of DIY cowboys and serious engineers, with some sort of pull between the two, often in the same person. Generally they are distrustful of templates and the standard library. The complete dedication to their view of the world is enviable. They do accomplish heroic acts that can help them justify it to themselves and others. Just did a google search and he is obviously accomplished. Quite often, each game programmer had their own idea of a new language they'd create when they could. It was a common dream to "make it big" and then invent a new language (someone in the field can correct me if I'm wrong.) A lot of the things he said make sense: * Long compile times with C++. The next major version of C++ **needs** to do modules in a way that fix this problem once and for all. If you have to choose between concepts and modules, do modules. * Could there be a more terse syntax for std class types (pointers, vector)? Tied to above. Rust does this with the owning pointer syntax. * Better help with debugging memory failures * Obviate the need to write constructors. * "Refactorability": with a billion different ways to write the same thing (references are non-nullable pointers), it becomes mentally taxing to change a reference to a pointer and vice versa. Anonymous functions to named functions. C++ is pretty close. Fix the compile times (make them rival Java) and you will destroy the competition. I don't know if that's possible though.
No unfortunately you cannot create a raw 2D array with variable dimensions. You can make a 1D array look/feel like a 2D array, by wrapping it into a class/using functions (i.e. using a function to access (x,y) pixel).
Blow used to write a series of articles in Game Developer magazine, about a custom game programming language. I think it was called Lerp, and I think it was lisp-like and one concept was variables remembered their values over time. Source code was provided. 
&gt; Implementing a template for a container that consists of an arbitrary amount of containers with adjacent memory, shouldn't be that hard at all and after that you could just write a few lines wrapper. I totally agree and have been mulling ideas around in my head, though I haven't done much more beyond that. After considering his example for a while, I also started finding his use case less compelling, though I am only an amateur when it comes to game dev, and I suspect other use cases abound. The obvious win is avoiding two allocations when one will do, though I imagine most mesh creation is the result of reading in a data file, so the IO will already kill the performance saved from avoiding the allocation. Games generally avoid allocating in the main loop, but should that be necessary, the utility would be nice. The other potential win is avoiding a cache miss should accessing one of the pointers prefetch the data for the other. Yet I imagine that for AAA games with 100,000+ vertex meshes, the index and vertex data might be far enough away that two cache misses occur anyway. (This is not my area of expertise so it might be better than my instincts tell me.) And lastly, most meshes are loaded and dumped into GPU memory anyway, right? So who cares how you store it client side? You don't usually have too much control over how the graphics card stores VBOs. The one advantage should be if your game depends on highly dynamic mesh manipulation, but then it might be better solved at the allocator level. I'd love to see actual profile results though.
It's like he is wanting to create the high-performance PHP-tier language.
I agree with him about exceptions. But his dismissal of RAII is ludicrous. A feature that makes your code cleaner and less error-prone, for zero overhead. Arguably one of C++'s greatest contributions. That's what he wants to get rid of?
&gt; You might not want to repeat my mistake of judging it before having watched the whole talk. To be honest, that's proving a difficult proposition for me. I can't listen for more than a minute or two before he says something completely and objectively wrong, and I have to pause it and calm myself before continuing.
What are his views that are delusional and why?
He has delusional view of what RL programming is... In Stepanov's head:math IRL: getting sh*t done here Im talking about 99% of programmers, Im happy Stepanov and Bjarne know what a regular type is. :) , problem is that Stepanov feels every programmer needs to know it. 
What's "RL programming"? And what?
real life... not some academia theoretical BS about purity or math... every similarity between Stepanov and Haskell zealots is not coincidental... :D If you dont know what I am talking about watch about 30 hours of Stepanovs lectures on YT and tell me how much more *productive* it made you. 
Yeah, I don't know what you are talking about, and will check out his lectures. Idk though, if some approach doesn't work for you, nobody's forcing you to use it, right? If Mr. Stepanov thinks something to be true, it doesn't mean you need to follow. In any case, thanks for the explanation and input.
I didn't find the source code but the articles seem to be available at http://lerp.org/
if you are like me you will be super bored by his slow pace and lack of value of those lectures... then try https://www.youtube.com/user/BoQianTheProgrammer/videos he is very good imao
Yeah. I stopped after an hour the first time. But the stuff he said in the 2nd half about wanting support for simpler fine-grain control w.r.t. memory layouts (e.g. jointly allocating multiple arrays of different types in a single block) changed my mind about it a little. But don't get me wrong. If you can't bare the first hour, you won't probably like the second hour. It doesn't improve *that* much.
abstract ways of thinking lead to profoundly new ideas. what do you think the STL is? not everything has direct tangible value. i like boqian's videos though :)
like I said Bjarne Stepanov and Eric Niebler need to know their stuff... but problem is that Stepanov does not get that it is a niche part of programming community and he is convinced that learning how to implement STL or all the crap about types is useful for regular Joe. It is not.
I'll give all a go.
I think it's a nobrainer if you compared the 'skill' of a programmer that understands TMP and one that doesn't that the TMP on average is going to be better in just about every way. Same with functional or any other 'hard' paradigm that comes around. just pushing yourself to understand hard concepts can make other concepts become much easier. think back to school where you learn some math concept and you feel kind of confused. you then build a concept on top of it and feel the triviality of the original.
I didn't mean variable dimensions. LodePNG's decode function returns the width and height, so I could just make a 2D array pixel[width][height], right? That wouldn't be bad practice, or anything?
By variable dimension, I mean the dimension cannot be determined in compile time (as you have to load the file). So no you can't just make an array pixel[width][height]. GCC may or may not support variable length 2D arrays (although I'm not sure), but this is via an extension and thus it is not standard C++. 
I get that exceptions are problematic in a lot of ways but I don't see how checking return codes everywhere, even with language facilities to make that easier and enforced, isn't equally problematic. He describes the case of exceptions working well like he's complaining: the stack unwinds to a point where you can cope with the problem and resources are freed during the unwind. You'd rather be forced to handle every failure at the specific line where it happens? To manually propagate failures up the stack?
What you mean zero overhead? The moment you define a destructor for a struct you have to think about copy constructor, move constructor, how one return a local copy from a function etc.... see `std::fstream` for how it is 10x more troublesome to use than just a `FILE*`.
What about the verboseness of C++?
Honestly I just make it noncopyable 99% of the time. Resources don't need to be copied, value types do and even then a majority of the cases can rely on the compiler generated stuff, if done right.
You might find the [Rapperswil Trip Report](http://botondballo.wordpress.com/2014/07/17/trip-report-c-standards-committee-meeting-in-rapperswil-june-2014/) informative. It's definitely making good progress. It differs from the proposal in a couple of aspects, and that will probably elicit discussion and collaboration trying to make it better, which of course takes time. It just seems like something that would be ready for a TS by that time while the kinks get worked out and people actually get to use it. Something this big needs some testing.
I regularly program in multiple languages and while c++ can be verbose, it's not a level of verbosity that can't be dealt with.
You have to write code to disable copy constructor copy assignment, write more code to enable move constructor and its implementation, while getting nothing real done at the same time and turning a simple struct declaration and your code into a unreadable mess. If resources don't need to be copy, simply don't copy them and compiler cannot generate sensible move constructor for thing that does not itself have move constructor.
I mean I inherit from boost::noncopyable. Anyway, if I come across the need to move resources too often, I'll have to find an efficient solution to that as well. So far, so good.
Example?
I'd somehow missed the fact that the debug heap was used even in release builds. I always wondered attaching the debugger to a running process resulted in allocations being so much faster than launching with debugging enabled.
&gt; You have to write code to disable copy constructor copy assignment, write more code to enable move constructor and its implementation Once for every abstract kind of ressource: Once for memory, once for files, once for locks,… You cannot seriously mean that this is more work than writing that code everytime that you handle the ressource? btw, a noncopyable, but moveable class: class noncopyable_ressource { std::unique_ptr&lt;foo&gt; data; }; Where exactly did I have to define stuff? And if you want to do that explicitly, that really is difficult too \s: class noncopyable { public: noncopyable(int i): val{i} {} // actual work to make it movable but not copyable: noncopyable(noncopyable&amp;&amp;) = default; noncopyable&amp; operator=(noncopyable&amp;&amp;) = default; private: int val; };
$0.02: Some opinions on attempting to answer your question, while providing fodder for the discussion. Having done this both ways, here's how I've seen it play out in the *worst* cases: Exceptions: * There's a tendency to rely on stack traces for debugging and support. Coupled with *deep* call trees, this creates it's own kind of hell in some cases. When you need to reach for a tool that filters your stack traces to make them readable, you know you're in trouble. * Stock exception types are handy, but they usually don't have enough context when something blows up * If your language of choice doesn't have checked exceptions, it's hard to tell upon inspection that exceptions are done right - so exception handling mistakes tend to slide past peer review * Developers tend to make assumptions about how detailed the exception hooks should be in order to make robust code * Requires deep knowlege of the system to peer review and write, lest you fail to understand how to appropriately respond to any given exception that could be caught, and where to catch it. Rerturn Codes (C-style coding): * Unless you're in the habit, you're going to call a function and NOT handle the return code * Design tendency to move everything towards "everything in an if statement" * Not handling interacting error states correctly; like when to bail out of a loop/switch/if and when to stick around. * Tends to bloat the normal flow of the program (although "normal" here is a "sh\*t happens" approach) - it takes practice to read and write this kind of code * Requires use of logging in order to build context for errors, warnings, and other events; this in turn requires logging that can be filtered since your program may wind up a tad chatty. Stack traces do nothing for this approach, so you more or less have to build your own when something generates an error. * Nobody likes it since it forces more work to be done up front I'll add that RAII doesn't even have a dog in this fight. It's an orthogonal concept since it's a formal way of saying "map an event hook to scope exit"; that's literally all it's about. Exceptions are just one way we can exit a scope. Simply calling 'return' (in most languages) is another. Both of these error handling approaches yield tidy code when this is applied, as the developer *will* wind up with preventable bugs without it. To wit, I've used RAII with c-style returns and it simplifies things enormously. The best C++ could ever do for RAII (until recently) is to use "class destructors on stack-allocated objects" for this, so the overall concept is confused with a ton extra baggage. C programmers also took to using a "goto cleanup" idiom to emulate the same. Take a look at D's "scope exit" or Go's "defer" for a more conventional take on this. TL;DR; exceptions suit rapid development better, where c-style return codes are suited to more robust systems at the cost of a fixed engineering overhead. Exceptions also require deep knowledge of entire systems, whereas c-style return codes can be handled much more myopically since they're usually pass/fail in nature. The overall problem is that it's hard to get both approaches to a point of robustness, for these reasons.
To me the big problem with exceptions is that critical control flow requires no lines of code. In many cases that is a great thing. Your top level http handler can handle whatever exceptions your code dishes out without having to see error checks cluttering the rest if the code. In other cases when it is critical to provide the strong exception safety guarantee, every line of code becomes a razor blade. With compiler enforced return code checking, you at least see where the failures can happen.
I'd have to show you my own code. But some examples: 1) the lack of header files 2) the fact that everything is immutable by default means I don't need to `const` my code to hell and back. Seriously, I'm tired of typing `const`. 3) the fact that everything is private means I don't need to mess around with anonymous or hidden namespaces or pollute the header file with private declarations.
How are the compile times? The other things you mention sound pretty good.
Lightning fast. Install the compiler following the instructions here and play a bit: http://doc.rust-lang.org/guide.html
That's the article I was referring to. Sorry if I disappointed you, I didn't remember the details precisely. The devirtualization thing is coming in future versions and we'll have to see how it performs. 
I'm left wondering why the debug heap is opt-out and not opt-in. At least for c/c++ apps it seems like a bad default, and the case of custom (non CRT) heaps is much more rare - and the WDH would hurt less if actively added only there.
Tangentially related is the OANOCACHE environment variable which controls BSTR caching. And also this awesome chart with the various guard patterns: http://www.nobugs.org/developer/win32/debug_crt_heap.html
You omitted a lot of code to make your example work. I don't want to use `unique_ptr` to heap allocate all my resources and sometime I actually want to do a copy. Default move is not sufficient. By the time you wrote the destructor and move implementation it is going to be a lot longer than struct foo { int val; }; optional&lt;foo&gt; make_foo(); bool delete_foo(Foo f); `delete_foo` is only called a few places in the code base it is not really a big deal. 
The chart is linked to at the blog. Moreover, AFAIU the chart says nothing about dependency on the *windows* debug heap - don't expect to meet any 0xbaadf00d's in crash dumps, for instance.
Click the link to see the question. Thanks in advance.
This is clearly homework. Show us your best attempt. If you are seriously resulting to using answer websites for something this basic, you are going to fall behind quickly and probably won't become a good programmer. At least make an attempt.
His book: Elements of Programming is a fantastic read if you want to learn about how we can think about algorithms mathematically and represent them generically using C++.
I believe multiple people have said that it will take about a month for them to be edited. 
Yeah, that's what came in my isocpp feed (IIRC, in the very same article the OP linked to).
We don't really know as CppCon hasn't communicated anything clearly about this. To tide yourself over, you might find some of the [Strange Loop 2014 videos](https://www.youtube.com/channel/UC_QIfHvN9auy2CoOdSfMWDw/videos) interesting. Whatever they did differently, they were able to start releasing videos starting the very last day of the conference, and they've been pushing them out at rapid pace ever since starting. Much nicer than the scheduled release on InfoQ they did last year. Edit: Woah, /r/cpp is touchy. My point was that nothing have been posted on the official CppCon website.
The public version got updated, so I updated the post to match.
http://awesomescreenshot.com/0263iwzm09
Posted Sept. 15 by Herb Sutter: "As we return home in the afterglow [from cppcon, ed.], remember that all sessions were recorded and videos will be posted online in the next month or so." https://isocpp.org/blog/2014/09/trip-report-cppcon-2014
Everyone likes to echo the sentiment that "C++ is too big/complex". While I agree, I'm particularly interested in what people think are the good parts worth saving. Personally, I love C++. I just use the subset that helps me the most.
Thanks for making the world a worse place! You monster.
A total guess, but what about using a different syntax to pass in arguments? Doesn't MSVC use a different style? Maybe VS13 parses arguments that way and then passes them on appropriately? Long shot.
Unfortunately, [there is no other way to write them](http://clang.llvm.org/docs/UsersManual.html#id5). I'm looking at using the ~~-mllvm~~ `-Xclang` or the `/fallback` option at the moment. EDIT: Neither `-Xclang` nor `/fallback` help at all.
Typo alert: you wanted [whither](https://www.google.com/#q=define+whither), not [wither](https://www.google.com/#q=define+wither).
No way. I might be interviewing against this kid in a few years. Will make it much easier for me.
Be nice STL :D Oh wait, you are!
Part of the reason I didn't provide an example is because I couldn't make sense of where it was occuring in my code base, but I will try to narrow it down to the areas where I use atomics and provide a limited example. This is a limited example of all the references to atomics in my code base, and although not a complete picture should be the only invokes. error C2280: 'std::atomic&lt;EventHandler::WorkerState&gt; &amp;std::atomic&lt;EventHandler::WorkerState&gt;::operator =(const std::atomic&lt;EventHandler::WorkerState&gt; &amp;)' : attempting to reference a deleted function #include &lt;iostream&gt;//used for messaging in unrelated out of scope class #include &lt;atomics&gt; enum WorkerState { Active, Inactive, Uninitialized }; class GetAndSet { public: GetAndSet(){state_.store(WorkerState::Active); run_.store(true);} WorkerState GetState() const { return state_.load(); } template&lt;WorkerState set&gt; void SetState() { state_.store(set); } bool IsRunning() const { return run_.load(); } void Stop() { run_.store(false); } private: std::atomic&lt;WorkerState&gt; state_; std::atomic&lt;bool&gt; run_; };
std::atomic is not copy assignable. I would need more of an error message to be sure, but it sounds like you have an atomic that's part of a user defined type with a compiler generated assignment operator, which won't work. 
Perhaps at some point in your code you have something like: GetAndSet g; //... g = functionThatReturnsGetAndSet() // would cause error trying to perform the default assignment on a GetAndSet object For anything more than that I'd need more information about the error message, specifically the line that it is actually sourced from (plus a few lines of context around that line)
The problem is and what I accidentally omitted was that the error point to an operator&lt;&lt; in the iostream header, but I never attempt to pass by value to the stream operator or at all... :/
Try adding this to `GetAndSet`: GetAndSet(const GetAndSet&amp;) = delete; GetAndSet&amp; operator=(const GetAndSet&amp;) = delete; It will explicitly disallow copying of your `GetAndSet` class. This will not fix your problem, but may make the error message more explicit. Also, is that really the whole error message? I rarely use MSVC, but gcc usually gives much more context, including a call stack where you can see where something tries to copy your objects.
I don't know about Rust, but I just [ported 11416 lines of C++ into 3699 lines of Python](https://github.com/Grumbel/flexlay/tree/feature/python) (i.e. ~1/3 the size). That was a straight up conversion from Qt to PyQt, no language specific tricks or libraries. For most part I just needed to remove a lot of type declarations, header files and stuff, the underlying logic stayed the same. Now of course Python is a little lax with it's typing, so you might want some additional verbosity in a static typed language, but I think it's save to say that you could get the features of C++ in a language that needs half as much text without to much problems.
Don't remember where I read it (somewhere on Reddit), but the post said the videos would be uploaded to this channel in the coming weeks: http://www.youtube.com/user/CppCon Edit: Found the post I mentioned: http://hereticalcpp.blogspot.co.at/2014/09/cppcon-2014-is-over.html Reddit Link: http://www.reddit.com/r/cpp/comments/2gekq8/cppcon_2014_is_over/
I think his complaint about RAII wasn't directed at RAII as a form of code organization itself, but that you have to do it everywhere all the time in your C++ code if you want to stay exception-safe. RAII isn't an optional feature in C++, it's forced up on you.
Yep thanks man turns out that not having move semantics defined meant that when I tried to save my object into a std::pair&lt;&gt; it inherited all the default move constructors which in this case where deleted... Normally MSVC is a lot easier to use than this and a lot more clear on the trace of the issue, I haven't smoothed it all out yet but im breaking ground :D 
The build output window will usually give you more information about what caused the error (and you should also be given the filename and line where the error occurred). e.g. if you are trying to copy the GetAndSet class, they it should give you the following message after the error: This diagnostic occurred in the compiler generated function 'GetAndSet &amp;GetAndSet::operator =(const GetAndSet &amp;)'
This is what the compiler was telling me before I removed the copy semantics, now that i am implementing them properly i am getting more detailed information, but where it was point me was not helpful at all... :/ 1&gt;C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\include\ostream(198): error C2280: 'std::atomic&lt;EventHandler::WorkerState&gt; &amp;std::atomic&lt;EventHandler::WorkerState&gt;::operator =(const std::atomic&lt;EventHandler::WorkerState&gt; &amp;)' : attempting to reference a deleted function 1&gt; C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\include\atomic(669) : see declaration of ' std::atomic&lt;EventHandler::WorkerState&gt;::operator =' 1&gt; This diagnostic occurred in the compiler generated function 'EventHandler::ThreadHandle &amp;EventHandler::ThreadHandle::operator =(const EventHandler::ThreadHandle &amp;)'
Maybe he was referring to Raymond Chen's hand.
I hope they're doing the thing where they edit out the parts where someone from the audience asks a question and it's completely inaudible and you have to just wait for them to stop blabbering on and on so the speaker can summarize the question in 5 seconds. I was watching some videos from another conference that did this kind of editing (I think it was a Microsoft sponsored conference, maybe Going Native?) and it was glorious and heavenly and made watching much less annoying. I don't care if it takes six months for videos to appear if there's that level of attention to detail. 
I have found the issue and it is address in one of my other comments :)
There is QTest for userinterface testing in PyQt, but I haven't really looked into it.
Happy to hear about the level of quality control going into the book as it's something that I have found lacking in other O'Reilly titles. Interesting point as well about expecting it to render as well on digital devices as paper. I'm constantly hearing bad things about digital editions of technical books.
You're right. CppCon itself hasn't really said anything that I know of. You have to listen to the whispers of the cabal. Of that there's numerous sources saying, "You know, around about a month." &gt; Woah, /r/cpp is touchy. Welcome to reddit. It's all this way.
&gt; Raymond Chen's hand What's wrong with his hand?
&gt; [*You're](http://www.troll.me/images2/grammar-correction-guy/-youre.jpg) 
Vinpad, you are a life-saver. Chanz, I know this is probably something simple, but so was high school Spanish class, and I barely passed THAT. I'm well aware I'm not going to be a good programmer, but it's too late to change my course, so I'll finish it and take up a more suitable course later.
It sounds like you should be using `shared_ptr`. Somebody who gets a `shared_ptr`, then stores a long-lived raw pointer/reference, is being grossly negligent and will get what they deserve. (I've done this in my own code, with `shared_ptr&lt;sprite&gt;` and so forth.)
Agreed with STL. `shared_ptr` is a contract, and storing a reference to the internals is breaking that contract. You bring up not wanting to use a factory because a derived class could expose the constructor - make the constructor private, not protected, and you won't have to worry about any pesky derived classes :)
How about having an `addFrame()` method? It could return a reference to the newly created frame which you could use to make modifications. Having the potential for dangling references is a common issue. For example, It occurs throughout the standard library. You just have to make the users of the class aware of when the references become invalidated.
No, no. I want to use the factory. It was the Pane class I was referring to when I was talking about exposing the constructor. I can't make the constructor private because the class needs to be able to be derived from.
So basically, if the developer is being dumb, let them? I'd really prefer to stop things before they hit runtime, but I suppose you're right.
Forgive me, onto which class were you referring to when you were talking about adding an `addFrame()` method? 
Well said. Edit: As an aside, do you know if it's valid OOP technique to have a derived class have a compositional relationship with it's parent class?
Mind that when using shared_ptr&lt;&gt; to store children you should use weak_ptr&lt;&gt; (or even just raw pointer) to the parent to avoid strong circular references.
&gt; Rust compiled slower than C++ when I last tried it. Now that's a feature i wasn't expecting from any language out there ...
github dot com slash BenHanson slash parsertl.
or as Herb Sutter phrases it: defend against Murphy, not Machiavelli.
I meant `Frame::addFrame`, since it sounded like only Frames could have children. I'm not sure if Pane is a concrete class. If it is, then you would have `Frame::addPane` as well. The idea is that the Frame class would create the object internally and manage its lifetime. The methods would take no parameters, or perhaps they would take parameters that were passed to the respective constructors when the objects were built inside the class. No copying is necessary, and the users of the Frame class only obtain references to the child panes, regardless of how the panes are stored internally in the frame. If you need this design to be extensible, then you can have an a member template function instead of having individual methods for each type of child.
 * addChild(pane&amp;) I don't see the problem with this. It assumes the caller is managing lifetime. The dangling pointer could happen if you mismanage the lifetime, but that's on you bud. How about: * Pane Frame::addChild(height, width, x, y, etc...) This way the frame is managing all lifetimes. This is basically your manager class.
&gt; Google has some internal solution for Chrome - their solution would be very appropriate to the games industry. Though I don't doubt it's possible, how do you know this?
Some information is [publicly available](https://code.google.com/p/chromium/wiki/LinuxFasterBuilds#Use_goma). Distcc, incredibuild, and [fastbuild](http://www.fastbuild.org/docs/home.html) are the non-proprietary solutions, but the amount of parallelism they can safely achieve is limited. IMHO primarily because the only convenient memoization they can do is at the object file level. This both limits the number of jobs that can be performed and creates hugely redundant workloads in each job (see PCH bullshit).
This sounds a lot like PowerPlant, an old framework from Metrowerks. It's written in older C++ (pre-smart pointers), but has similar concepts. Still available as [OpenPowerPlant](http://open-powerplant.sourceforge.net/). Many Macintosh apps were built on it.
Gotcha, so they are working with C++ as best as they can. You're in games development? What's your take?
I am highly suspicious of concrete inheritance to begin with.
the ctor needs to be PROTECTED if you're going to derive from it ... doesn't have to be PUBLIC.
Often the trick is to decide on a set of constraints; don't allow the api to be used in any old fashion, impose rules upon it. This doesn't have to be a limitation. Eg, Make the child panes always be owned by their parent. To make a pane you specify it's parent, or you ask a pane to produce a new child to use. Destroying the parent always destroys the children.
I'm not going to suggest this is the correct choice, but you have another option too: addChild(Pane&amp;&amp;) This interface transfers ownership of the pane to the frame (and the the caller no longer has a useful Pane object after the call).
API design 101, good API's make it easy to do things the right way, and hard *but not impossible* to do things the wrong way. If someone wants to do something *bad* with your API, *let them*, the punishment is on them. They might actually have a legitimate reason for doing what they are doing and stopping it entirely effectively cuts off the option to do these 'bad' things. It's just important to make it easy and obvious on how to do the right thing.
prefer composition over inheritance whenever possible, this provides an extra 'seam' in which to manipulate the structure for testing or future expansion and is generally more flexible (inheritance is designed to cause a point of 'rigidity', it's the purpose. a point of inflexibility by type constraint)
 if ((Nameplayer1 = ' ')) { cout &lt;&lt; "ERROR: Illegal name given, using default"; In C++ `=` is for assignment, `==` is for comparison. Further, `' '` isn't a string, but rather one character. if ((Nameplayer1 == "")) { cout &lt;&lt; "ERROR: Illegal name given, using default"; would work, or if(Nameplayer1.length() == 0) 
For the future, I'd suggest either /r/cpp_questions or /r/learnprogramming as more appropriate areas to get help on this sort of thing.
&gt; if(Nameplayer1.length() == 0) Instead, prefer if (Nameplayer1.empty()) Also, you get faster, more thorough help from [r/cpp_questions](http://reddit.com/r/cpp_questions)
&gt; if(Nameplayer1.length() == 0) You can also do: if (Nameplayer1.empty()) { ... } At least if Nameplayer1 is a string. In the OP's code it seem to be *char*. 
char Nameplayer1; is just a single character. You should probably use std::string (#include &lt;string&gt; in this case). 
Your player names should be strings. 'char' only holds 1 character. [AsGadgetfairy pointed out](http://www.reddit.com/r/cpp/comments/2h99he/please_help_me_on_this_c_i_am_a_beginner/ckqjr8o), you need to use == for comparisons. Don't forget to close your if-blocks. In your typed example, I see openning braces, but missing closing braces. **Now as for defaults**, you just need to assign the default name in the if block (which will now require braces). For player 1 this would be: if (Nameplayer1.empty()) { cout &lt;&lt; "ERROR: Illegal name given, using default" &lt;&lt; endl; Nameplayer1 = "Player 1"; } Hopefully you will be able to finish your program now.
 class Foo { protected: Foo() { //Quick Zhu Li, do the thing! } }; class Bar : public Foo { public: Bar() : Foo() //Not necessary, but meh, there it is anyways { //More unnecessary text! } }; Is perfectly valid code.
It's a valid OOP technique and in fact crops up in a number of places. The decorator pattern is one formal example.
Except that it's not always easy to tell the difference.
&gt; On every allocation the memory manager initializes every allocated DWORD to 0xbaadfood, and on every deallocation sets the memory to 0xfeeefeee – in addition to some bookkeeping just after the allocated chunk. That 'some bookkeeping' can be much more useful than it appears. When configured correctly, it can: * Report buffer overflows for whole heap; * Report use of deallocated memory; * Report any memory leaks (yes, it scans all your pointers looking for one to allocated memory). It can be configured using this: http://msdn.microsoft.com/en-us/library/5at7yxcs.aspx
I think the issue of 'every line of code becomes a razor blade' is pretty well addressed by Jon Kalb's guildlines for writing [exception safe code](http://exceptionsafecode.com/). For example most of the criticisms of exceptions are based on writing exception safe code using what Jon Kalb refers to as "the hard way" and "the wrong way": &gt; _The Wrong Way_ &gt; - Carefully check return values/error codes to detect and correct problems. &gt; - Identify functions that can throw and think about what to do when they fail &gt; - Use exception specifications so the compiler can help create safe code. &gt; - Use try/catch blocks to control code flow And I think Jon's comparisons of code that uses error codes vs. using exceptions correctly really show the value of using exceptions to produce code that is more readable and less bug prone. I think ultimately exceptions are not invisible `goto`s. Far from being less structured, exceptions and RAII are a _more_ structured method of handling certain errors.
A code for what ? If you mean a compiler error then you need to tell us compiler/version you're using. You should also post the code that causes the error. 
[No](https://richmond.craigslist.org/tch/4665347676.html), it's definitely a [Java](http://reddit.com/r/java) code.
I'm just trying to figure out what it is. It is a code that needs to be cracked 
true. i just wanted to know
[Reference](https://richmond.craigslist.org/tch/4665347676.html), thanks to google.
Thanks for the reply! But i supposed to see the "ERROR: Illegal name given" blah blah when typed white space or enter in the cin line of nameplayer1, but it just really typed into space or entered not to say give Rocky for his name!
Thanks for the replies! But i supposed to see the "ERROR: Illegal name given" blah blah when typed white space or enter in the cin line of nameplayer1, but it just really typed into space or entered not to say give Rocky for his name!
Phone numbers have 10 digits. Why is that too big? i thought it was obvious, since the 32 was a smaller case.
It's 09D6EEAA hex, or 9 214 238 170, so (921)-423-8170 right? Edit: Nevermind that's not right...
Raw pointers are perfectly fine when they are non-owning and you have a lifetime guarantee. If a parent always owns and outlives its child, then the child can have a raw parent pointer. weak_ptr, which has minor costs, is necessary when you do not have a lifetime guarantee.
But OP explicitly states the following: &gt; `addChild(Pane&amp;)`: ...the frame could wind up with a dangling pointer if the passed in Pane object winds up living longer than the Pane So children can outlive their parent, and therefore suggesting using a raw pointer is incorrect
[Hanlon's razor](http://en.wikipedia.org/wiki/Hanlon's_razor): "Never attribute to malice that which is adequately explained by stupidity."
Fair enough, good thing 921 is not a valid area code
You're mixing the CRT debug heap (which does all this magic and which your link configures), and the *Windows* debug heap, which the post was about - which is pretty much a redundant duplicate if you use the CRT.
I'd argue that for non-CPU bound computing C++ is probably not the best choice to start with, but even that is not my point: if you use C++ and stick to new/delete, you pay for the heap-integrity checks *twice*, once by the windows layer and once by the CRT layer. Negligible or not, it is redundant for the vast majority of apps and should be opt-in, not out.
Interesting. I'll have a look at this when I'm ready to do the android port of my thing. Currently I'm using an ObjC++ bridge to C++ services. One difference I have to their model is that I have adaptors to low level services in the native platform language (e.g. my AppleAudioProvider provides audio stop/start as an objective C++ service wired into the services like any other - under Linux this is JackAudioProvider). The reason I do it like this is so that lifecycle dependencies are done in the appropriate order. Looking at this talk, I may have to rethink that when I start porting to JNI. 
When was that?
He suggested "doing it everywhere" entails writing lots of special member functions for your classes. This is, of course, not *generally* true. See [Rule of Zero](http://flamingdangerzone.com/cxx11/2012/08/15/rule-of-zero.html). But then again, he's focussing on high perf game engines where I wouldn't be surprized to see the occasional hand-written special member function (eg. for your own memory allocation / subsystem management framework or something like this).
Like a couple of months ago. It was the first thing people noted when I showed Rust to friends. Running `rustc` took quite a while for a simple Hello-World-program. But maybe this is due to a higher fixed cost and it scales better. I don't know. So far I havn't compiled very big Rust projects with it, only toy examples. And toy examples are still somewhat slow to compile (at least in an x64 linux environment).
&gt; if ((Nameplayer1 == "")) { ...and that would be an error as well, Nameplayer1 is declared as char...
Avoiding boost in C++ makes about as much sense as only using just the System namespace in C#!
Did you perchance have this problem: http://stackoverflow.com/questions/4383602/how-to-force-inclusion-of-unused-object-definitions-in-a-library
Hmm, that might be the same issue I was running into, although not on Windows. I'll have to pick that code up again and retry it.
There is no limit to how much is too much! ;-)
Yes, I didn't see that. As others have corrected that I decided to just let it stand. 
Since last release there is native desktop UI controls in QML too if you prefer QML over QWidgets. That being said i would probably not do a native desktop UI in QML, even tho I like QML a lot. You can also mix both QWidgets and QML and use your QML canvas as just another QWidget.
If qtqickcontrols work properly now that does change things.
Totally! :) QML as xml, json, ... these days is what *language* virtual machines were decade or two ago.
Could I say that QGraphicsView is inspired by Evas? Could I say that QML is inspired by Edje? Could I say that Qt Quick Controls is inspired by Elementary? We should remember to credit the Enlightenment/EFL developers that have been researching fully themeable interfaces for 10+ years.
Are these official high-quality video of the conferences as they promised? I am asking this as I remember they told it would take some time to release these videos.
Wait a minute. I have confused [cppcon](http://cppcon.org/) with boostcon. I guess we still have to wait for [cppcon videos](http://cppcon.org/cppcon-video-recording-2014/)
 The original factory function seem intentionally very inefficient. A more efficient way and i think a more lazily and noob friendly is to to have a bunch of "if" and "else if" with a final "else" that return NULL. 
Yes, but thinking of it as one is actually not a bad way to get your mind looking at it the right way.
This seems like something that should be pretty easy without a complicated pre-processor. Assume you have a function: bool Factory::register(std::string className, std::function&lt;std::unique_ptr&lt;Base *&gt;()&gt; generator); Then in the Factory header: #define STRINGIFY(Derived) #define REGISTER_FACTORY_CLASS(Derived) static bool _registered_ ## Derived = Factory::register(STRINGIFY(Derived), []{return std::make_unique&lt;Derived&gt;(); }); Then: class DerivedA : Base { }; REGISTER_FACTORY_CLASS(DerivedA); Now you have significantly less code you have to write at the expense that you have to remember to add some extra pre-processor magic when you declare the class. Actually, upon further consideration, you can also do this in pure C++11 with CRTP without any pre-processor magic: bool Factory::register(const char * mangled, std::function&lt;std::unique_ptr&lt;Base *&gt;()&gt; generator) { int status = 0; auto demangled = abi::__cxa_demangle(mangled, nullptr, nullptr, &amp;status); if (demangled) { std::string demangledCopy {demangled}; free(demangled); return register(demangledCopy, std::move(generator)); } } class Base { } template &lt;T&gt; class RegisteredBase : Base { private: static bool registered = Factory::register(typeid(Derived).name(), [] { return std::make_unique&lt;Derived&gt;(); }); } class DerivedA : RegisteredBase&lt;DerivedA&gt; { }; This should work even in C++98 if you implement demangling on the platforms you care about. This also lets you use namespaces for your types.
How are any of A-C addressed with any other language?
templated functions/methods can overload just like other functions/methods. Not really any different. The only part of it that gets a bit "strange" is that an overload can prevent a template from being instantiated. So: template &lt;typename T&gt; void foo(T t); void foo(Bar t); //this will prevent foo&lt;Bar&gt; from being instantiated 
Ah, I see what you did there. ;-) Is this really about overloads though? Anyway, the correct output is f(void*) unless "void f(int);" appears somewhere above the declaration of g.
Since C++ is a systems programming language I can't disagree more with you. You can implement thread-level locking with atomics, but not the other way around. Besides, there are perfectly usable locks in the standard library, so what's the issue?
Care to elaborate on the inefficiency? Shouldn't a map perform better than, say, 100 if-else-branches?
This is something I ran into when I was reading through the existing solutions. I needed to have the factory in the executable project, so I didn't test whether it works in static or dynamic libraries, but I don't see why it wouldn't. I thought of doing the macro dance as well, but ended up writing the utility tool. I'm not very keen - or proficient - in writing macros, and in my opinion a separate tool is easier to maintain and doesn't clutter the main project. :)
I personally think many programmers tend to ego-boost themselves by showing off their knowledge of language features and their coding skills.
One of the most common anti-KISS things I keep seeing is the suggestion of Boost for small, ordinary tasks, usually faced by newcomers or programmers with less experience. Sure, Boost can do a lot of things, but it's a huge hammer to hit a tiny nail.
Constant interruptions made me unable to finish. Arguing over extreme hypotheticals for half the presentation was not necessary IMO. 
I believe Rust 0.10.0 was the current release when I tried it.
Alright... that's one fixed area. While Qt is the best C++ GUI framework, it just feels dated. Part of me really wishes that Qt6 could make a clean break and go for using standard data types where appropriate (ex: std::mutex instead of QMutex), standard containers (ex: std::vector instead of QVector), use smart pointers to correctly indicate ownership, handle move semantics, get rid of the need for moc's, etc.... I know I'm dreaming because it would break so many existing apps. However, I feel there is a big need for a modern C++ GUI framework.
Can you try it again and tell us how it went?
I think the stack overflow thread /u/Crazy__Eddie posted did a good job of explaining why it doesn't always work if it's not directly linked to the executable. It's actually pretty easy to make this with macros: https://sourceforge.net/p/cppregpattern/code/ci/master/tree/registry.h
This is true for me in most C++ talks actually. Too many people trying to be the smartest person in the room. 
That's not a bug in Boost, that's an integration issue. Changing from boost to std blindly is just foolish. Even if it wasn't , a bug here and there doesn't mean throw the baby out with the bath water. I can pretty much guarantee you that you will have fewer bugs with Boost than without even if there are cracks here and there. Boost is a defacto standard C++ library. If you're doing serious C++ development and not using Boost, you're missing out on a huge amount of free functionality. For example, the OP mentions staying away from boost, but then says iterating directories in C++ is hard. But it's not if you use boost.filesystem. 
No you don't. And MinGW has much more than " limited support " 
No I don't what? MinGW doesn't support std::to_string let alone std::thread or std::regex. I'd call that limited support.
I've also seen a lot of "people misunderstand XYZ concept in Qt and everything is subtly fucked" in our code. Threads and concurrency? Disaster, and the Qt documentation on the subject is disjointed and unclear so no wonder things are haywire. Calling delete instead of deleteLater so the event loop can properly clean up an object? Scattered throughout. Qt is great when you get comfortable with their way of doing things, but if you use it casually and don't delve deep into the API docs it is too easy to abuse without clear signs of the problems you're seeding. Hopefully the next major release gets on the c++11 train, reuses a lot more of the standard library, and provides much more compile time/debugger notification of programmer error.
You have such a bummer attitude. Programming is tough. But if you put in the time, you can do amazing things. You could have easily figured it out had you spent an hour. How many hours have you spent just playing games instead?
How are the header only libs awkward to use? There's nothing to compile, all you need to do is point the compiler at it. 
&gt; Qt is great when you get comfortable with their way of doing things, The point is, we don't want to do things the Qt way, we want Qt to do things the C++ way so it fits in with the rest of our projects.
QML is pretty stable for basic things, but controls will continue to evolve. Embrace that. Don't be afraid to create a hybrid. For example, [here](https://i.imgur.com/BKLph7G.png) is a screenshot of a configuration dialog which is fully specified in QML but clearly uses native controls. It's still a WIP but you can see the code here: http://ix.io/eun In my experience, it is very difficult (impossible?) to embed QWidgets in a QML scene. This is one problem I can't seem to crack. Compared to QWidgets, QML is a blessing.
&gt; 'new' without 'delete' in your code? That's unacceptable. Oh... it's Qt code. Nevermind! You could always use smart pointers to manage your QObjects if you wanted. It's just not necessary once you manage the root object yourself.
yep, the only way to use, then strip away all the Qtness for any of the actually core code.
This talk continued for more than 30 minutes after it ended. It was like a brainstorming session in which people discussed the tools in standard library and how they relate to category theory. [Bartosz's blog](http://bartoszmilewski.com/) is a good starting point for people who missed that part.
Fair enough. 
I doubt that part would have come through nicely on video. This is is a complaint we've seen about other C++Now 2014 videos. Some presentations were constantly being interrupted by the audience, which we couldn't hear and hence the recording didn't make much sense.
Worst was that you couldn't hear anyone but the speaker so it was silence for a minute followed by five words to repeat from the speaker and a sentence response. Also the pedantic crap about whether you can call a const int a constant made my blood boil.
But if I redistribute software, I want to include the boost headers (the subset that are relevant for my app). I don't want to have to explain to users, who may be on multiple platforms, how to install boost.
That's not the point. I'm not going to distribute all of boost with my open source software. Just the bits my software depends on. I want the simplest possible way to do that.
This. A line from the Princess Bride comes to mind: "Yes. You're very smart. Shut up."
This is great. Been using PhpStorm and PyCharm quite extensively the past year at school.
Try here: http://www.reddit.com/r/learncpp
&gt; Never claimed anyone should not use boost. Read what I actually typed. ... Tons of downvoting in this sub, and people extrapolate claims to extremes that were never made. It looks worse in context than your post alone would indicate. The article mentions preferring to avoid boost completely and the comment you replied to is critical of that stance. You replied with some nitpicks about boost integration, and in the context of this thread, it reads like you are offering them as reasons to support the article's stance and avoid boost. Your conclusion sounds like you are sticking to boost a bit begrudgingly. Honestly, its a bit hard to fathom why you would respond the way you did if you didn't want to sound like you are recommending avoiding boost.
Early in the video it mentions that Church "failed" - there was "some kind of problem." There was a problem, but he didn't fail. He found something deep. The "problem" was that a lambda calculus "program" might not terminate (well, normalize, but that more or less means the same thing). Just trying to prove the equivalence of two lambda expressions could get things stuck in an infinite loop. And since he was trying to create a logic that could be a mechanical foundation of mathematics, rather than a programming language, that meant something was amiss. Church's problem was pretty fundamental and he knew it. We call it the Turing Halting Problem after another mathematician who also worked on finding an algorithmic basis for math, who also found a problem, and who also didn't fail in exactly the same way. What Church and Turing had done was find a very deep hole in the very idea of finding an ultimate machine for doing mathematics. Such an ultimate machine exists (conceptually), but sometimes it will get stuck in a loop and there's nothing you can do about it even with another such machine. The talk then goes on to say Church fixed the problem with types. That's true-ish. What he did was explore ways to prevent the kind of self reference that lead to his looping problems. But don't focus on types, they were just the mechanism. In our terms what he did was turn the lambda calculus into something that wasn't Turing equivalent and no longer capable of getting stuck in an infinite loop. Which was interesting, of course, but can no longer be considered a mechanical basis for all of math. In fact, his simply typed lambda calculus is so painfully limiting that it's hard to do much of anything with it. Some more modern variations of typed lambda calculii also have the property of guaranteed termination, but have enough sophistication that they can encode a lot of useful stuff. Anyway, types didn't so much fix the problem as lead to another line of research. Besides, language designers have know for a long time exactly how to bring Turing equivalence back to typed languages and as a result we still have exactly the same problem that Church had with his untyped lambda calculus. The rest of us only wish we could fail as successfully as Church and Turing.
Actually, /r/learnprogramming is probably a better choice. More people, plenty of C++ experts.
you need to increment count put count++ inside your loop and you'll stop getting 0's.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void main(){ int count = 0; while (++count &lt; 200) { if (count % 2 == 0 &amp;&amp; count % 7 == 0) printf(" %i ", count); } system("pause"); } or [x | x &lt;- [0..200], mod x 7 == 0, mod x 2 == 0]
there is a /r/cpp_questions where people like me answer questions like this....
 [x for x in range(200) if x%7 == 0 and x%2 == 0] range(0u, 200).filter(|&amp;x| x%14 == 0).collect::&lt;Vec&lt;_&gt;&gt;();
For such a beginner to lower-middle-level aimed series, are concepts really appropriate? Why confuse the matter with a non-standard extension (though I see you've provided a `concepts.hpp`) that readers are not likely to see anywhere in the wild?
One day Boost will be modular...
This is a really interesting idea, but I find it surprisingly badly written.
&gt; Honestly, its a bit hard to fathom why you would respond the way you did if you didn't want to sound like you are recommending avoiding boost. Mostly because I don't agree with either extremes. I think that sometimes there are good reasons to avoid boost.
Cache misses are slow, and since each of the objects pointed to are not guaranteed to be in contiguous memory, once you're processing enough objects of a small size I'm not sure even pipelining could save you from the number of times you'd have to pull different cache lines into cache from memory. Consider that fitting several elements in the same cache line is always better than not having that guarantee. Maybe if you were processing data as big as a cache line itself it would perform better, but even then you'd really want empirical evidence (which I don't have).
Any reason for this pattern: if(cmp(a,b)) return a; return b; over this one: return cmp(a,b) ? a : b;
Turbo C++ was totally obsolete before you were born. Download for example Qt SDK from here: https://qt-project.org/downloads This environment is modern and multiplatform, so you will have the very same in any operating system.
No way! Are there schools still using MS-DOS systems in 2014?!? Do what Cyttorak suggested.
Don't be scared, all of these programs are just glorified text editors with a built in button to compile the code. Just figure out how to create a project (talking xcode, qt, whatever), put your code in a new file and hit build.
 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;numeric&gt; #include &lt;iterator&gt; std::vector&lt;int&gt; numbers(200); //allocate 200 integers bool isDivisible(int number, int divisor) { return ((number % divisor) == 0); } int main() { std::iota(numbers.begin(), numbers.end(), 0); // fill 'numbers' with a sequence starting with 0 std::copy_if( // perform a conditional copy numbers.begin(), numbers.end(), std::ostream_iterator&lt;int&gt;(std::cout, " "), // output integers to standard out, delimited with [](int number) { // the condition should be that the number is divisable by 2 and by 7 return isDivisible(number, 2) &amp;&amp; isDivisible(number, 7); } ); }
It makes a lot of sense to teach introductory programming on a simpler platform. This whole attitude of "it it's not the latest thing, it's wrong to use it" is stupid.
 #include &lt;iostream&gt; // for std::cout #include &lt;algorithm&gt; // for std::copy_if #include &lt;vector&gt; // for std::vector #include &lt;numeric&gt; // for std::iota #include &lt;iterator&gt; // for std::ostream_iterator std::vector&lt;int&gt; numbers(400); //allocate 400 integers bool isDivisible(int number, int divisor) { return ((number % divisor) == 0); } int conditionalAdd(int currentSum, int newValue) { if (isDivisible(newValue, 8)) return currentSum + newValue; else return currentSum; } int main() { std::iota(numbers.begin(), numbers.end(), 100); // fill 'numbers' with a sequence starting with 100 int sum = std::accumulate(numbers.begin(), numbers.end(), 0, conditionalAdd); // perform a conditional add on all numbers std::cout &lt;&lt; sum &lt;&lt; "\n"; // output the result }
True, a full project IDE can be overwhelming. For a bare minimum IDE which just compiles a .cpp and some .h files there is this little gem: https://code.google.com/p/pocketcpp/
In those cases let their package manager do it, and in the case of windows then they can just use the precompiled version as the number of targets is far fewer.
As someone who was taught Turbo Pascal in school so I could learn programming "on a simpler platform" I say that it's a horrible approach, because I could be taught the same concepts while learning a language that actually is used nowadays. Learning obsolete stuff just because it's "simpler" (how exactly it is simpler?) was a waste of time.
The _concepts_ of programming haven't changed especially since the 1960s. The C++ language may have moved on a bit, but 99% of what you were taught using Turbo C++ is still entirely relevant, unless you poured a particular amount of effort into learning the details of the DOS API or using Borland's graphics libraries (which I doubt). You're supposed to _learn to program_, not _learn a specific language/API_. It makes a lot of sense to start to program in a language/platform that you won't use later, as switching early helps you detach the concepts of programming from the details of the platform you're using.
 template &lt;typename T, typename U&gt; inline auto min(T&amp;&amp; x, U&amp;&amp; y) -&gt; decltype(x &lt; y ? std::forward&lt;T&gt;(x) : std::forward&lt;U&gt;(y)) { return x &lt; y ? std::forward&lt;T&gt;(x) : std::forward&lt;U&gt;(y); }
I completely disagree. While the *concepts* may not change much, a beginner cannot really separate concepts from implementation. Modern C++ is a completely different beast than the C++ of Turbo C++. In Turbo C++ you will struggle with memory leaks, use after free, buffer overflows, and think that C++ is that way in general. Turbo C++ is a horrible learning environment. Much of the work that has gone into C++11/14 is to make it more beginner friendly and do the right thing. See http://www.stroustrup.com/new_learning.pdf I think a good book for students is Programming -- Principles and Practice Using C++ by Bjarne Stroustrup. Make sure you get the Second edition.
Write it down on paper in english. For every number between 0 and 200 inclusive (I assume you meant positive integers under 200) do the following If modulus( number, 2 ) == 0 And modulus( number, 7 ) == 0 Then output( number ) End If Next Then translate it into the language. Also, if you are programming c++, don't use printf. Use std::cout or some type safe method that outputs. 
i like codeblocks myself
And in C++14 I think you can lose the `decltype`.
Although using a older IDE is not that bad, the TurboC++ is like twenty years in the past. I recommend you strongly focus yourself in learning only the programming concepts because the syntax will be as useful as if you were learning how to write punchcards. So learn only the minimum needed to pass the tests and then you can go elsewhere and maybe learn true C++, using a modern IDE as xcode, visual studio or some free one as Code::Block or Codelite. Damn it, if you were programming using vim and makefile you would be in better situation.
Who cares about an our ordering relation for min? For sort it's important because it changes whether the results are correct and even whether the algorithm terminates, but for min just run my operator definition, ordering be damned.
You don't have to be mean.
For some very disturbing values of "cleanly".
I expect most of what's taught using Turbo C++ is actually C programming. I highly doubt anyone is trying to use it to teach modern C++, nor anything that's particularly C++-specific. In introductory programming; the actual language is largely irrelevant.
&gt; The rest of us only wish we could fail as successfully as Church and Turing. No kidding!
Good, otherwise there would still be two copies - one in the decltype and one in the body. :)
Technically he is just honest, but it should be mentioned, that every single one programmer on the face of the planet started out writing shitty code and that there is **nothing** wrong with that. People who learn to write will usually start out with a terrible handwriting and that is a much simpler task.
A version that works with VS 2012 (what I am constrained to currently): template &lt;typename T, typename U&gt; struct undecayed_common_type { typedef decltype(true ? std::declval&lt;T&gt;() : std::declval&lt;U&gt;()) type; }; template &lt;typename T, typename U&gt; inline typename undecayed_common_type&lt;T, U&gt;::type min(T&amp;&amp; x, U&amp;&amp; y) { return x &lt; y ? std::forward&lt;T&gt;(x) : std::forward&lt;U&gt;(y); }
WHAT YEAR IS IT???
Where can I find the code for this talk? Edit: Found it https://github.com/camio/sbase/tree/master/include/sfrp
Will that work for different T and U, say "const&amp;" and "&amp;"? I thought "?:" required both branches to have the same type.
&gt; is a really interesting idea, but I find it surprising Are you referring to my English? Oh, sorry, I'm not English speaker, I did my best. I accept suggestions and corrections.
I started a QML desktop application on the release of Qt5, and it hasn't really changed since then. Mostly new features. Versus 4, it clearly is very different. 
How can you have a run-time expression in decltype?
[Do you not?](http://media-cache-ak0.pinimg.com/236x/f8/29/c7/f829c755f8ed3bf2e652948cd94c6256.jpg) decltype provides the *static* type of the expression.
I'd force them to let you use whatever you want. I'm going off to college for CS in a couple years. I'd die without my vim and C++11. EDIT: I should also mention that I'm trying to transition to emacs. It's bumpy, but I see the light.
&gt; I expect most of what's taught using Turbo C++ is actually C programming. While that is probably true, I think people are decrying the fact that it is *presented* as C++. After all, OP posted in /r/cpp...
I never heard of vim at that time, now for me, vim is love vim is life!
Still quite a bit of it (although at least he seems to be requesting it more than others)
The crowd interrupted a lot, especially towards the end. Most of it you can't really tell what the "question" is. Still, I thought the portion of the presentation actually given by the speaker was interesting, and I've possibly got a slightly better idea what FRP is. I've been confused by it a couple of times in Haskell already - you get the impression there that lazy streams are fundamental, whereas here there are no lazy streams, so that "fundamental" aspect is suddenly just a detail of particular implementations. 
&gt; Who cares about an our ordering relation for min? If reading the first articles has not been clear, I suggest you read the documentation of STL (the original STL, SGI STL, or the C++ Standard), or better yet, read the "Elements of Programming" book
&gt;My program allocates and deallocates memory all the time I think I found your performance problem ;) &gt;*! terse ownership std::unique_ptr?
The STL implementation of min doesn't care about ordering, it only cares about operator&lt;. That's my point. There's no context where min having this prevents a bug.
I thought on something like this: AddConstIf&lt;T, AnyIsConst&lt;T, U&gt;&gt; min(T&amp;&amp; a, U&amp;&amp; b); Because I wanted to make explicit (or almost explicit) the return type. Anyway, I had not thought on combining the conditional operator with decltype (or C++14 auto return) It is a good idea. Thanks! Maybe I will update the article. ...Although... does not convince me the idea of: auto f( /*...*/ ) { return COMPLEX_EXPRESSION; } ... for designing API's. 
&gt; mplementation of min doesn't care about ordering, it onl It is impossible that the STL **implementation** of min cares about ordering in C++98, 03, 11 and 14, because the lack of Concepts in the language. But, see the STL documentation, ordering is part of the design of min. When Concepts is part of the language, then, ordering will be part of the implementation of min. The idea is that the Concepts that today we have in the documentation become part of the code. 
&gt; m one concept to the other without Thanks! I appreciate your comment. Are you referring to the last article or all? Obviously I'm no expert in narrative, but I'll check it. Maybe my next article will be titled "Going back to School" :) Thanks!
To the first question. Why not? To the second question. Because I wanted to share a message that I found interesting: "Do not focus on TMP"
Out of the box, Vim is the better editor. Emacs is the better "program" if you can even call it that. Emacs can be extended to be better than vim. Evil mode is amazing.
What will a strict weak ordering concept be able to enforce other than the presence of operator&lt;? I think even with concepts it's useless for min.
Yes but x &lt; y is a run-time expression, so it can't be used to determine the static type.
I get what you're saying, but it's not what you think. You're interpreting it as "If x is less than y, then the static type should be std::forward&lt;T&gt;(x), otherwise the static type should be std::forward&lt;U&gt;(y)", that is a reasonable interpretation but it's not what actually happens. What actually happens is "Forget whether x is less than y, the static type is just whatever type std::forward&lt;T&gt;(x) has in common with std::forward&lt;U&gt;(y)" Basically the ?: operator has some fairly complex rules about what the resulting type will be. For example it will try to find a common type between them, converting one expression to the other if need be. For example the following always results in a double, regardless of whether x is less than y: auto v = x &lt; y ? 5 : 3.14;
I wonder if this is why I've never been able to get a stable experience out of KDE since version 2.0. KDE is riddled with tons of subtle data race bugs and memory leaks that make it impossible to use for more than a few minutes on my computer.
I bet they are using the 1992 or 1994 Turbo C++ rather than the 2006 short-lived attempt to reuse the old brand for a different product.
Ah, got it. It's obvious now, thanks.
Hello everyone! The posted is a tool for Emacs that allows for fast insert of #include and namespace expressions (i.e. using namespace boost::program_options ..), based off a very customizable dictionary of project dependencies and style conventions. Feel free to provide feedback via comment or issue post on github. Enjoy.
Just leave the `virtual` out: the `override` contains all the information that is required, and redundant clutter in your function signatures is just annoying.
This is super cool. I've just started working on C++ bindings for [duktape](https://github.com/svaarala/duktape) (a JS stack-based interpreter with C bindings), because its API is similarly *super* verbose. I might borrow some of your approaches :)
Looks interesting. Thanks. I'll try it out.
 &gt;I am learning to program in C++. In school I use TurboC++ and at home my iMac has Xcode but I am scared to use it because it seems so different. As everyone else has said TurboC++ is a joke and frankly probably did more damage than good as far as your education goes. Don't be a wimp, power up XCode and get started with some command line programs. As far as C++ goes you won't find a better C++ compiler so if you curl up with a modern C++ text you should be able to make huge progress. The big nasty here is that Macs are programmed with Objective C which is not C++ at all. So to program a Mac natively you need to learn Objective C or Swift as it stabilizes. &gt;Can some one tell me how to program on it like I do in school. I have no idea how you program in school! If they are using TurboC++, right now the best thing you can do is to forget what you learned. Pick up a modern C++ text and start over. I should ask though what is your goal here? Is it to learn C++ or learn to write apps for the Mac. It does make a difference because if you want to write apps for the Mac you might want to consider ObjectiveC or maybe better Swift. &gt;Also, if anyone knows a better compiler that is free please send me its name. The LLVM/Clang suite, sponsored by Apple, is currently the best free implementation of modern C++ out there. Error messaging is very good which is import at for a beginner and it even has a static checker. Just make sure you are running the most recent XCode. 
I personally do not use lua but this lib looks terrific. API looks very easy to use. Great work! I might do something with [CLua](https://github.com/NosBit/CLua/commits/master) now
I only learned about it today. Here's a simple write-up for you https://github.com/davidsiaw/luacppinterface/wiki/Comparison-to-Selene
As of Lua 5.1, when compiled as C++, Lua uses native C++ exceptions instead of setjmp() and longjmp(). Source: http://lua-users.org/wiki/CatchingLuaExceptions
On my machine, the breakpoint between linear searching and binary searching a vector of ints where binary search becomes faster is at around 70 elements. It's generally much lower for strings due to that they're more expensive to compare, but a `std::map` lookup is also a lot slower than a binary search of a vector. For 100 options a map is likely to be significantly faster than an if-else chain, but for 10 there's a good chance of it being the opposite. It's unlikely to be anything worth caring about, though.
I leave it in, makes it more visually consistent with the base class declaration. If "override" could be put in the same position as "virtual" I would not include it though.
I thought Google don't allow C++ anyway? Their Code Guidelines define a new language which is a subset of C++, more in lines with Java or the classical notion of "C with Classes". Confusingly though, they continue to call their new language C++, and since it's proper subset of C++ they are able to use C++ compilers. These C++11 guidelines seem to inherit from Google C++ guidelines, so it's hardly surprising a lot of them don't make sense for C++ programming.
Why don't you determine the function signature in the library instead of requiring the user type it all in? For an example of how this can be done, take a look at [`bslmf_functionpointertraits`](http://bloomberg.github.io/bde/group__bslmf__functionpointertraits.html) and [`bslmf_memberfunctionpointertraits`](http://bloomberg.github.io/bde/group__bslmf__memberfunctionpointertraits.html) in the [open-source 'BDE' library](https://github.com/bloomberg/bde).
Cross post to /r/gamedev ?
It seems like every dang school in India uses Turbo. I hate them all. 
I do this in my library, [sol](https://github.com/Rapptz/sol) but the issue is that it fails w.r.t. overloading and template operators/functions. So then the user has to provide them explicitly for those cases.
Explicit conversion operators [were supported](http://blogs.msdn.com/b/vcblog/archive/2013/06/28/c-11-14-stl-features-fixes-and-breaking-changes-in-vs-2013.aspx) by 2013's compiler and STL.
Note that if a class is final, marking its member functions as final is completely unnecessary. I say "virtual override" since I expect to see virtual on the LHS. This is one of the few times in C++ that I say something that's redundant.
It's interesting both style guides seem to take a narrow approach to r-value references. I don't think anybody could argue they are one of the most straightforward features of the language to use correctly.
They link to the following bug: [Bug in VS 2013 support for explicit conversion operator](https://connect.microsoft.com/VisualStudio/feedback/details/811334/bug-in-vs-2013-support-for-explicit-conversion-operators), which also links to [a forum post: Bug in VS 2013 support for explicit conversion operators?](http://social.msdn.microsoft.com/Forums/vstudio/en-US/af733e56-8045-4553-a9af-6555d02fc2f6/bug-in-vs-2013-support-for-explicit-conversion-operators), which remains active.
Well, they were solid enough for the STL to take a dependency on, although there were bugs. (Their competition was the C++03 pointer-to-member hackaround, which is deficient in several scenarios.) I just checked, and while VS14 has fixed a couple of similar bugs with explicit conversion operators, this one still repros. I'll ping the compiler team.
Well, Google is abundantly strict with their C++ guidelines. Usage requires explicit endorsement. At the top of the submitted page they specifically say &gt; Unless otherwise noted, no C++11 library features are allowed.
&gt; In particular, chromium/android is currently using STLport, and chromium/mac is currently using libstdc++4.2, which predate C++11. Yay, somebody else's fault.
Not really sure what your point is about that. Undoubtedly some choice are not going to be ideal, but my interest in submitting/talking about this post is just to take it as a data point. I'm certainly not arguing that they are the objectively right choices to make. Edit: Basically, all they're saying is that you can only use library features that compile across all toolchains they've chosen to use. It's not even a particularly interesting comment when you read it like that. Why they've chosen those specific toolchains is interesting, but the page doesn't say anything about that. Edit: Nevermind, the subtle point of your post evaded me at first.
why are delegated constructors not allowed? this is the kind of feature that should have been part of c++ since the beginning.
I found it interesting that the discussion for lambdas seemed to be heading toward disallowing them on the basis of a complete misunderstanding of how they work. They were apparently under the misapprehension that lambda expressions produce `std::function` objects and require library support.
Fucking Microsoft.
I'd wager this also falls into the category of do all aupported toolchains support it. IiRC, gcc was actually quite late supporting this particular feature while VC and clang more rapidly supported it. At the end of the day, feels like the guidlines aren't (without having read them) about supporting the lowest common denominator, which sadly is nothing new to c++ when you have a common codebase to be aupported on multiple disparate runtimes and compilers.
No. `constexpr` functions can be called in a runtime context; that is, where the values of the arguments are not known until runtime. In those cases, you can't use `static_assert`.
The way I interpret what they're saying is that you can't accept a lambda without making the function a template or using std::function, which is true for lambda's that capture.
This isn't about semantics. AFAIK, C++ doesn't provide for exceptions &amp; RTTI being optional language features. Some compilers support the non-confirming extension to turn them off. Furthermore, some libraries support being compiled with this non-conforming extension. I wouldn't go so far as say it's a different language, but it's definitely a different dialect that isn't what people refer to normally as C++11/C++14. Now the other things about which STL features are allowed isn't a dialect issue; that's just a cross-platform reality (although some of it feels contrived to me)
&gt; AFAIK, C++ doesn't provide for exceptions &amp; RTTI being optional language features. Correct. (There are some "conditionally-supported features".)
You are absolutely correct - for overloading and templates the user has to specify them. But if you try and infer it for other cases, the user would be relieved of the burden, and only has to `static_cast` the function pointer in the case where there is an ambiguity. Which you may or may not think is a reasonable requirement.
Is there any problem with a company creating a new language for themselves? No. Is there any problem with a company restricting themselves to a subset of an existing language? No. The only one issue I take, is when the subset is not acknowledged as a thing in of itself, but is referred to by the original language's name. &gt; I don't think you can call their guidelines a new language. Honestly, I think Google's C++ guidelines are restrictive enough that they constitute, practically, a new language. Mind you; within that restriction, I think they are perfectly reasonable.
Since you shouldn't catch `std::logic_error` anyways, throwing that would also be a solution.
Can you elaborate a little on this? Specifically, how is it that we're able to just disable rtti and exceptions and expect things to work? I know it's common (everywhere I've worked) and it does make sense (exceptions are hard and rtti should really be opt in only for hierarchies that need it), but when I think about it, it seems crazy to turn these things off and not expect bugs in the compilers. 
&gt; The only one issue I take, is when the subset is not acknowledged as a thing in of itself, but is referred to by the original language's name. What exactly would you prefer? That all these productions compilable by the standard C++ compiler each get their own name? Or only ones that cross some threshold of restrictiveness? What is this threshold, and how can it be identified?
But who knows this? Are you really going to trust people not to `catch(std::exception)`, or `catch(...)`? I certainly don't.
Nonlocal error handling is inherently hard. Exceptions make it easier. RTTI, while not something that should be used frequently, is very useful when it's necessary (e.g. std::function's target()). The Standard is not a compiler. If a compiler wishes to make parts of the language optional, then it tries to figure out how to support the non-Standard mode in a consistent way. Usually this can be done reliably, but it definitely takes work, and imposes costs on users.
If you don't use digraphs and trigraphs then you can't call the language you use C++. They're a core part of the language and supporting them isn't optional.
Richard Smith pointed out today in a std-proposals thread that Daniel Krügler is already working on a constexpr assert: http://cplusplus.github.io/LWG/lwg-active.html#2234
Hey, cool! I didn't know about that.
To add to what Eric said above, function arguments are never constexpr, so they would not be usable in a static_assert.
Perhaps you should do virtual /* obsolete */ void f() override; for a couple of years or so, and then just replace all to just void f() override;
Why is Microsoft so bad with full C++ support when GCC and Clang seem to be up to date almost all the time these days? Do they rather prefer to pour resources into C#? It's strange, I kind of feel like if I were starting a new project, I just wouldn't even target that toolchain as everything I read seems to indicate that they're always last to the party, if they arrive all. 
Yes in 03 and yes in 11. In C++11, I also add "override" together with "virtual" in derived class. The leading "virtual" is more noticeable than the trailing "override". 
Where can I find some sample application that uses this library? I'd like to see what using this library looks like in practice...
There's [this](https://github.com/camio/CppNow2014/tree/master/examples), i think the example could be a lot more readable if it used auto or not use fully qualified names every where but it's probably not using type inference to make it easier to learn what's going on. 
*Maybe you can ignore this comment here - exactly the same points have already been made in the discussion thread linked from above :-). And the good news is, if you follow through to the bottom of the discussion, the worry about std:: function has been accepted as invalid* You can accept lambdas as arguments, without std::function or any other library support. Standard library algorithms have accepted template-deduced parameters for some time - lambdas are not different. Somebody there claimed that `stable_partition` would require std::function if called with a lambda. &gt;&gt; 2. Given an array of integers, move all odd numbers to the front of the array: &gt;&gt; std::vector&lt;int&gt; numbers{1, 2, 3, 4, 5, 6, 7, 8}; &gt;&gt; std::stable_partition(numbers.begin(), numbers.end(), &gt;&gt; [](int n) { return (n % 2) != 0; }); &gt; This won't work without library support, which we don't have. The pre-lambda alternative would be to create a standalone functor class struct IsOdd { bool operator() (int n) const { return (n%2)!=0; }; }; And pass an instance of this to `std::stable_partition`. This does not convert to `std::function`. Using a lambda is exactly the same. Changing from `IsOdd` to lambda doesn't change anything. (Unless there's something else is the example that I'm missing, that does force `std::function`?) Extra: capture-lambdas are no different. The compiler create a new type for you every time you write a lambda. This constructed type does not inherit from std:: function, and is not related to the library in any way.
Thanks
That's taking what I'm saying to an silly extreme. I clearly said &gt; I think Google's C++ guidelines are **restrictive enough** that they constitute, practically, a new language. I.e. it's not simply about not happening to use certain features, rather it's about banning features which would be considered idiomatic and safe C++.
You have it backwards. There are basically no features VC has 'rapidly supported.'
Quite a bit of features are off limits because MSVC'13 doesn't do them. That's a shame, but reality of multi-compiler support.
Actually no. You *don't* want stack unwinding for logic errors. That would execute a pile of code when your program state is suspect. What you really want (IMO) is to bail as quickly as possible, without unwinding the stack.
One possible reason: C++/CLI and C++/CX get a priority and MS isn't omnipotent. (Whoops, was that two reasons?) 😉
Is there documentation?
I think that depends on the situation: If the software is for example used to control some kind of robot I want it to try to shut down gracefully enough to stop moving (1) in a position that is save for bystanders (2). This may be achieved by destructors, making this a situation where you actually want to terminate with stack-unwinding even in the case of very bad errors. I admit that this is a rare situation, but as is the situation where you would want to catch `std::exception`.
You can take a look at the wiki page : there is a tutorial, samples, and a cheatsheet documenting all features and their usage. Don't hesitate to tell me if something isn't clear!
Namespaces are a collection of functions and classes grouped together to prevent naming conflicts. Almost all of the standard library is put under the 'std' namespace. 
Nobody forces you to use Qt collection classes and others. You should use what best fits your particular case. I'm not going to shy away from boost::flat_map when I need it just because it is not Qt. The same goes for the std::unique_ptr, etc. As for MOC... C++ does not have all the needed features to replace it just yet. When we get proper introspection, things might change. Though, honestly, I have never seen why people tend to dismiss Qt because of MOC. It is IMO a better approach than creating your own programming language like some other projects have done.
&gt; writing code without those features would be infeasible Huh? I control what I type. Note that I specifically mentioned controlled code. I understand that exceptions can't be completely avoided, but you can enforce guidelines that say you never write code that throws. I don't doubt that the Chromium team is fully aware of what language and library features might throw, e.g. std::bad_alloc, etc.
&gt; Standard library algorithms have accepted template-deduced parameters for some time - lambdas are not different I don't know how well a very old (7+ years) C++98 STL implementation will handle capturing-lambdas. I imagine it will work. libstdc++ on OSX (which is what Chrome still uses for whatever reason instead of libc++) is from GCC 4.2, so I imagine that's something they have to double-check. &gt; You can accept lambdas as arguments, without std::function or any other library support I imagine the comment about STL requiring std::function for accepting lambdas to algorithms is just a misunderstanding of how lambdas work. My reading of it was 1 concern raised in a longer thread. &gt; (Unless there's something else is the example that I'm missing, that does force std::function?) My understanding is the concern has nothing to do with the STL. I imagine having capturing lambdas with STL will work fine. The way I read the discussion was that they were concerned with passing lambdas within their own code (or with 3rd-party libraries). Without std::function, a capturing lambda can only be used in a template, which is non-ideal (increases compilation times, creates header dependencies). Of course, they could use their own std::function implementation or use boost. Looks like it's possible to implement std::function without RTTI, so they should be able to use it: http://probablydance.com/2013/01/13/a-faster-implementation-of-stdfunction/ https://svn.boost.org/trac/boost/ticket/3666 &gt; Extra: capture-lambdas are no different. The compiler create a new type for you every time you write a lambda. This constructed type does not inherit from std:: function, and is not related to the library in any way. That's almost true, but there are significant &amp; real differences between capturing lambdas and non-capturing lambdas. The code the compiler generates for the non-capturing lambda actually annotates the () operator as static. There's also magic going on (or something other mechanism I don't understand), that lets that lambda be cast to a regular function pointer (I'm guessing the compiler generates a conversion operator in the struct?). Thus a function like: void foo(void (*bar)(int a)); can be invoked: foo([] (int a) { // do something with a }); However, int someValue = 0; foo([&amp;someValue] (int a) { someValue = a; }); would not.
Looks very nice, a good alternative for Qt's state machine implementation, if you're not already using Qt :)
&gt; They enforce this at the compiler level by disabling exceptions &amp; RTTI Source? First I'm hearing about this. &gt; Also, I'd like to see you write any C++ code that doesn't use 'new' in some way Not what I argued. 
What are the differences with [boost::statechart](http://www.boost.org/doc/libs/1_56_0/libs/statechart/doc/index.html) and [boost::msm](http://www.boost.org/doc/libs/1_56_0/libs/msm/doc/HTML/index.html) libraries ? 
&gt; The code the compiler generates for the non-capturing lambda actually annotates the () operator as static. Agreed. But I think that's no different from a stateful functor type that might already be in the Chromium codebase somewhere. On the other hand, I guess the fact that the non-capture ones are marked static might cause a problem somewhere. Manually written functors wouldn't always be marked static (simple forgetfulness possibly), and the relevant libraries might not be able to handle them. And perhaps there is some code somewhere that assumes that is something can be converted to a pointer, then it "is" a pointer and is not to be treated as a function. [ I'm grasping at straws here :-) ]
When is target useful? This is my first time hearing about it.
I tried to provide the most easy way to create FSMs, so that the overhead is minimal to a point where writing a state machine is easier than going the spontateous way (which can quickly become a big blob of nested switch/case). boost::statechart and msm both require the user to write complex boilerplate code, define structures, instantiate templates and such. instantFSM uses a declarative approach that only requires the user to describe the state hierarchy and event callbacks, with no struct definition, no weird template construct and such. Another approach I encountered while looking for existing projects is code generation from a high-level definition. This solution brings on the developper the burden of integrating a specific generation step in his build process. I think ifsm provides a grammar at a level high enough that it provides the same clarity without the burden of a more complicated build process.
From the Google style-guide: &gt; Although you should not use exceptions in your own code, they are used extensively in the ATL and some STLs, including the one that comes with Visual C++. When using the ATL, you should define _ATL_NO_EXCEPTIONS to disable exceptions. You should investigate whether you can also disable exceptions in your STL, but if not, it is OK to turn on exceptions in the compiler. (Note that this is only to get the STL to compile. You should still not write exception handling code yourself.) http://guiquanz.gitbooks.io/google-cc-style-guide/ebook/Exceptions_to_the_Rules.html In other words, try to disable exceptions at the compiler level. You're only allowed to not do it if it's required to get the STL to compile (notice it makes no mention of third-party libraries, so it's not clear how they handle such third-party libraries). &gt;&gt; Also, I'd like to see you write any C++ code that doesn't use 'new' in some way &gt; Not what I argued. I was referring to it's not possible to write code that doesn't use exceptions since a call to new() may throw.
Somebody messing with a class should understand what they're doing.
If you store a functor in a std::function, and want it back later. You have to tell std::function the functor's actual type.
Maybe you want to modify the functor's stored state.
To me this is not news; every company I have worked at disables exceptions and rtti at the compiler level. When you do this, throw and dynamic_cast are compile errors. 
what happens if someone marks a destructor as `noexcept(false)`? 
The STL isn't required to deal with throwing destructors (i.e. dtors that actually throw). That's a good point though, if some evildoer marks a dtor as noexcept(false), then that could infect STL dtors. So marking STL dtors as noexcept explicitly is a good idea - I hadn't thought of it that way.
OT but I do have to ask: why - with all the resources in the world available - Microsoft won't throw more of them at the VS? This is always so baffling to me when you say that there is only bunch of you on the compiler and (even less on standard library) team? For many of us this is the most important MS product (and far from the cheapest) and yet it sometimes feels like it is not of very high priority at MS.
so how does the performance of your implementation compare with boost msm?
- Concepts are everywhere in the STL, and some Boost libraries are documented with concepts. So knowing about concepts helps beginners to better understand the STL and Boost documentation. - Some of Boost libraries use Boost.ConceptCheck, other use static_assert or roll their own concept checking solution. Modern alternatives to Boost.ConceptCheck (e.g. TICK) also exist. If you are using high quality generic libraries the chances of seeing concepts in the wild increases significantly. I know that not everybody likes STL/Boost, but the language is being driven towards STL/Boost like libraries since its inception. Concepts are a fundamental part of it and the Concept TS just pushes the language more into that direction. 
I wouldn't describe that as "pure C++ 11". I relies on abi::__cxa_demangle(), which is not universally supported, so this trick may work on GCC, but is liable to blow up using other compilers.
New EAP build now supports MinGW-W64 out-of-the-box: http://blog.jetbrains.com/clion/2014/09/new-clion-eap-build-import-project-from-the-existing-sources-toolchain-updates-and-more/
`new(std::nothrow) T()` doesn't throw; it returns a `nullptr`.
Additional examples: VC supported lambdas slightly before GCC. VC supported regex years and years before libstdc++/libc++. VC supported efficient make_shared before Boost/libstdc++, then I taught them how to do it. (I'd have to ask about the timing and behavior of libc++; I believe VC was earlier.)
Thanks!
&gt; To me this is not news Good for you? Not everyone knows what you know, you know? 
Well, you seemed shocked and demanded sources. I thought it was common knowledge that many companies do this. 
Because I have never heard about it. Shame on me for *gasp* not knowing something. Protip: look at how the other reply responded. It was... actually helpful.
Well, language support isn't the complete picture. GCC has been focusing on adding new language features, but their standard library has been lagging behind, whereas Microsoft has been keeping their standard library up to date with the compiler features they support. One example is &lt;regex&gt;, available in MSVC 2008, but only recently available in GCC 4.9. There is pain to go around if you want to use a language or library feature that isn't available on a platform you are targeting. I'm not sure if any of the big three compilers are 100% C++11 compliant if library support is accounted for, and I get the impression that library support is usually ignored because it is a lot of fun poking at Microsoft.
I don't really know enough to comment, but pretty much everything I've ready says that the GCC Library is up to date and C++11 complaint... is that wrong?
&gt; Tests are defined using ordinary C++ without the use of the C preprocessor I dont see that as an advantage. With the preprocessor, its nice having the file and line number where it failed.
It looks like GCC has [quite a few partial or not implemented features](https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.200x). Clang's library claims to be [100% complete for OSX, but not Linux and Windows](http://libcxx.llvm.org/) (see "Current Status"). It would be nice to see some side by side comparisons of library support like you can find with language support, but my Google skills are failing me.
That's easy to add, since the expect() function already lets you add a description, but in the medium-term, I plan to implement [std::source_context](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3972.pdf) in clang, which would provide a macro-free way of getting this information. It's definitely a limitation, and I've considered adding a macro to do that, but I haven't had a pressing need for it myself yet. The output from a failed expectation *usually* gives me enough information about where the failure occurred. Even so, I still stand by the goal of keeping macros to a minimum if nothing else, since macros modify the syntax tree in opaque ways (not to mention having problems with commas in template argument lists).
This seems like one of the cases where macro usage is totally fine and there is zero reason to avoid it.
Just gonna say catch.hpp is newer and is a vast improvement over anything else I've seen for smaller projects. Occasionally new stuff is good. 
That's a good question! Aside from syntactic improvements (which is why mettle requires C++14), one of the main differences compared to Boost.Test or Gtest is that mettle uses [matchers](http://en.wikipedia.org/wiki/Hamcrest) to test things. While there's a C++ port of Hamcrest (a Java unit testing framework that uses matchers), it seemed to be pretty much dead, and didn't take advantage of modern C++ features like variadic templates. I find matchers to be a *significant* improvement over the usual set of "assert_eq()" functions, since they're 1) composable and 2) provide useful descriptions of what they're actually checking. For instance, suppose I have a std::vector&lt;int&gt; that I want to ensure contains the element 0. In Boost.Test, you'd probably write something like this: std::vector&lt;int&gt; v = {1, 2, 3}; BOOST_CHECK(std::find(v.begin(), v.end(), 0) != v.end()); Aside from being rather verbose, you'll note that this will only *describe* the error because you happened to put the entire check inside BOOST_CHECK; if it were something complex enough that you'd rather do the calculations elsewhere, you'll lose the description. Boost.Test resolves this with BOOST_CHECK_MESSAGE, requiring you to describe your check manually. In mettle, you'd express the above like so: std::vector&lt;int&gt; v = {1, 2, 3}; expect(v, member(0)); // Or equivalently: expect(v, member(equal_to(0))); When this fails, you'll see the following output: expected: member 0 actual: [1, 2, 3] This is a lot more useful for me, and usually goes a long way towards debugging my code, since I can see the actual value in the error logs, along with what expectation it failed to meet. In addition, since matchers are composable, you only need a small set of core matchers to describe most things you'd like to test: why write "assert_foo()" and "assert_not_foo()" when you have an "is_not()" matcher to invert any other matcher? Naturally, you can also extend the built-in set of matchers with your own ones, and combine them with the built-in matchers at will. Mettle's architecture is also a bit different from most other test frameworks in that the main driver program is designed to aggregate the results from multiple, independent files. Currently, I only use this to keep compile times down (a full set of tests for a project will compile into several independent binaries that the main driver runs in succession), but in the future, I'll use this to aggregate different *kinds* of tests together. The next thing on the list is a framework to test compilation of your code on an arbitrary compiler; it can be very helpful to ensure that, for instance, your static_asserts are firing at the appropriate times. To my knowledge, there's not an existing test framework that does this for multiple compilers. The only examples I've seen are in the test suites for specific compilers (e.g. clang) and as such aren't very useful for testing whether your code compiles under multiple compilers. Of course, this architecture also comes with a (temporary) downside: it requires a POSIX system since it uses fork/exec. That's not terribly difficult to fix though, and I'll add Windows support just as soon as there's a working C++14 compiler for Windows (luckily, clang is getting really close to working well on Windows).
Well, if others find file and line number info helpful, I'm happy to add a macro to do that in the short term. My main reasons for not doing so were 1) I didn't miss it very much, and 2) I wanted to push C++ as far as I can without using macros in the public API. &gt; However, macros in C++ dont work like that. They are simple textual replacements that are fairly transparent. I'd argue they're only transparent if you know what the macro expands to. While a macro that expands to a function call is pretty innocuous, I specifically wanted to avoid the kinds of macros that expand to fragments of expressions that require the user to remember what's effectively a second language. In surveying existing test frameworks, I've seen all of the following (function names changed to protect the guilty): CHECK_PREDICATE( foo, (0)(a)("hi") ); TEST("My test", (int actual, int expected), std::make_tuple(5, 1), std::make_tuple(2, 3) ) { // Test code here... } class MyFixture { /* ... */ }; TEST_FIXTURE(MyFixture, MyTestName) { // Test code here... } All of these make my eyes water. I have to suspend my understanding of C++'s syntax and just type the macros in using whatever syntax the developer managed to piece together that would expand to the correct code. While the above examples are certainly better than a macro-free version written in C++98, I don't think this is necessary in C++11/14. I was especially concerned about how tests and suites are defined, since those are the places where the macros are the least transparent to me. Unless I know how TEST() above is implemented, I can't say whether I could, e.g., call it multiple times inside of a for loop.
&gt; I'd argue they're only transparent if you know what the macro expands to. Being text replacements, its trivial to expand. So it is always available. &gt; that require the user to remember what's effectively a second language. Yes, usually, a macro is a sign that a feature needs to be added to the language, since it is essientially extending the language. It always has been this way since the history of C++, from constants, inline functions, templates, and vardiac tempaltes. &gt; All of these make my eyes water. I have to suspend my understanding of C++'s syntax and just type the macros in using whatever syntax the developer managed to piece together that would expand to the correct code. And your eyes will water then when they add new features to the languages that will deprecate these uses of the macros as well. Ultimately, most developers have no problem understanding and using these macros. &gt; I was especially concerned about how tests and suites are defined, since those are the places where the macros are the least transparent to me. It is nice syntax in the library for defining the test suites, however, for me personally many times I dont use a name to define my test cases since I only care about the file and line where it failed, but I dont think it matches most peoples use cases. Also, it might make sense to separate the test suite and assertion part of the library. So someone else could define there own assertions(perhaps using a macro or something else). &gt; Unless I know how TEST() above is implemented, I can't say whether I could, e.g., call it multiple times inside of a for loop. The same could be said for any abstraction. This is not unique to macros in anyway. 
Only got one wrong on the first try
You might want your school to try - http://www.rhide.com/ (GPL) . 
The Mythical Meow-Month.
&gt; Being text replacements, its trivial to expand. So it is always available. True. But I generally don't want to expand the macro, since that should be an implementation detail. &gt; And your eyes will water then when they add new features to the languages that will deprecate these uses of the macros as well. Ultimately, most developers have no problem understanding and using these macros. I think it boils down to your familiarity with 1) the language, and 2) the test framework you're using. Both require you to learn new things, but in (1), the new things are part of the ISO standard, making them more generally applicable (and increasing the likelihood that a newcomer already knows them). My perspective is as someone who's much more familiar with the C++ language than with any existing C++ test framework, and so I strove to make a framework that used language constructs I was already familiar with, rather than defining new constructs via the preprocessor. Naturally, if you're only familiar with C++98, mettle's usage of generic lambdas would look pretty unappealing! However, if you *are* familiar with C++14, the syntax is (hopefully!) obvious, and there are only a few places where the syntax does something that's not idiomatic C++. &gt; Also, it might make sense to separate the test suite and assertion part of the library. So someone else could define there own assertions(perhaps using a macro or something else). That's actually possible already. The two parts (test suites and assertions) are pretty loosely coupled, and either part could be replaced with minimal effort. I've considered splitting them into separate repositories, but I'm not sure the benefits are significant enough. Again though, I'll probably just implement a METTLE_EXPECT macro and throw it into the default installation, since it wouldn't hurt anything, and would make life easier for people who rely on file and line info for debugging tests. &gt; The same could be said for any abstraction. This is not unique to macros in anyway. Well, an abstraction that requires me to know its implementation is, by definition, a leaky abstraction. While sometimes unavoidable, I think leaky abstractions should be minimized, since they require users to remember more things about an interface. Generally, when I'm writing tests, I want to spend most of my time thinking about the thing I need to test, and not about the test framework I'm using.
&gt;This seems like one of the cases where macro usage is totally fine Those cases don't exist. There are only cases where you have no other choice.
&gt;as soon as there's a working C++14 compiler for Windows What do you need support for that GCC 4.9.1 doesn't support?
Relaxed constexpr, but I should probably just drop that on non-clang compilers, since it's non-essential. Edit: Actually, there are a bunch of issues with libstdc++, such as lack of heterogeneous associative containers, missing constexpr on std::max, no &lt;codecvt&gt; (which is actually a C++11 header!), and possibly a couple others.
&gt; first WOOTWOOT!!1 :D
Too many pointless copy-and-paste error examples.
[cppquiz.org](http://cppquiz.org). Though the quiz is more on theoretical knowledge of language than practical one.
That must be some remains of my testings. I'll check necessary headers, thanks for pointing that out.
The videos that I sampled were of very good audio and visual quality. Really nice to see, thanks to whoever organized this.
Thanks! Your library seems very easy to use tho, so at the end of the day it is a tradeoff.
The quality of the videos is fantastic, but the editing makes some of them super frustrating to watch. For example, on [Scott Meyers' talk](https://www.youtube.com/watch?v=y7WSmCpWAuo&amp;t=15m58s) @ 15:58, it frequently jumps to a full frame of Scott gesturing at his slides while explaining them line by line, with the slides nowhere to be seen. There was no way I could memorize that code in the 10 seconds the slide was displayed before the jump cut, so I'm stuck either trying to figure out the slide with the video paused *before* his explanation or listening to his explanation sans code, and then rewinding to look at the slide. I think this is a good example of where the editing is too clever. A simple two-up view with the slides on the left and Scott on the right would have been just fine for the whole talk. The jump cuts make it needlessly hard to follow.
BTW, everyone can pull the [presentation materials](https://github.com/CppCon/CppCon2014) from github.
http://www.aristeia.com/hairpoll/
I agree, I had to download the slides.
The Q&amp;A was pretty painful to listen to though, especially when you realise that the guy really actually only likes C, and only uses C++ because of cultural/toolchain issues.
Since I did the job writing a common sample for boost::msm, statechart and instantFSM, I added a page where they can be compared, with regards to model declaration grammar : [here it is!](http://sourceforge.net/p/instantfsm/wiki/compare/)
&gt; To my knowledge, there's not an existing test framework that does this for multiple compilers. Absolutely true, I had to roll my own solution with a cmake project generating buildtrees for sub-cmake projects, and a driver calling "cmake --build .". I look forward to this feature!
BLASPHEMER!!! KILL IT!!!
Hate on rage comics at the end.
This makes little sense on most forums. But on reddit it's just asinine.
Awesome. My only regret is the fact that my internet is throttled until the next bill period. *sigh*, I'll just have to watch in 144p.
I definitely agree. The video of Scott Meyers' talk suffers from questionable editing (although the talk itself is excellent). Interestingly, Mike Acton's talk has really good editing (and the talk is inspiring as well). I guess the difference comes from the fact that Meyer's talk was held Monday whereas Acton's talk took place Thursday. That is, the film crew knew better what to film from the feedback of the previous days. However, the editors could always just have edited in stills of the slideshow later. I guess they just chose not to use that option for whatever reason.
The editing is pretty great, good choice.
Maybe the template expansion overhead every compile is greater than just having tools insert duplicated code?
The results can be found here: https://www.surveymonkey.com/results/SM-G89Y2FVL/ 
Has anyone answer for the question about speed of string setter function version #2 (`const&amp;` and `&amp;&amp;` overloads) versus version #4 (constrained perfect forwarder)?
&gt;Longer compile times. Can be true, especially if misused. However more and more work is being done on decreasing compile time especially by clang. &gt;Code bloat (in the number of instructions generated). Maybe in yeh olde days before anyone really knew how to implement them properly, but I have yet to see anything these day suggesting that an unnecessary instructions are generated or optimizations missed. &gt;Code complexity (templated code can be hard to read and even harder to write) Matter of opinion, library templates especially in the STL can be difficult to read but are usually trivial to implement. Usually it all comes done to documentation. I find templates very easy to design and implement around, I feel like the criticisms listed are just the 'C with classes' crowd not understanding 'modern' (relatively at least...) generic programming. 
For someone who hasn't done much C++ in the last 1-2 years and who missed the whole C++11 discussion: That was a really interesting video, thanks for posting!
Instruction bloat can be more related to getting iCache misses in games dev.
The constraint was incorrect (it shouldn't have been there, and it was expressed incorrectly), and it wasn't actually used in the performance comparison. Perfect forwarding (e.g. emplace_back) beats copy/move overloading (e.g. push_back) when types differ. The example is vector&lt;string&gt; v; v.emplace_back("purr"); versus v.push_back("hiss");. emplace_back() directly constructs std::string from const char (&amp;)[5], while push_back() constructs a temporary std::string, move-constructs the element, then destroys the temporary - that's an extra move ctor and dtor.
You're getting downvoted because /r/cpp is not the place to post your question. That said, check out the official ISOCPP.org FAQ on [How to Learn C++](https://isocpp.org/wiki/faq/how-to-learn-cpp#start-learning). It's heavily biased towards purchasing of a text of some sort (A Tour of C++ really is great!) and I do agree that this is the best path. I'm not aware of any good online guides, although I'm sure some do exist. The problem is that many bad ones do, as well.
Herb Sutter's keynote (Back to Basics) was one of my favorites for the week ... great recommendations, and some controversy too. What more could you want?! :)
I agree, they really need to simply have a split screen of slides on the left and presenter in small window on the right. I was just watching "The Canonical Class" and continually got frustrated when the presenter was trying to reference something on the screen and the video is solely focused on him.
&gt; the editing makes some of them super frustrating to watch I'm only ~7 minutes into Herb's talk, but I get the feeling they're making some jumps only because they have multiple camera angles available. Jumping from the front view to a side view didn't improve anything and was completely unnecessary. And then it jumps again to a close up view from the other side. It's funny because it happens in a part of the talk where he is talking about having C++ features doesn't mean we need to use them. Edit: It's getting worse. Out of interest, I rewinded a particularly bad portion and counted six jumps in a period of one minute. Nine jumps if I give it an additional fifteen seconds. Honestly, I could've gone with just having the view where the speaker is on the left and the slide on the right.
Does anyone else feel like the editing detracts from the talk? It's cutting to alternative camera angles far too often for my liking and I'm only nine minutes in. In one portion, I counted a total of six changes in one minute.
I believe the code bloat associated with templates can be largely mitigated by using C++11's extern templates: http://www.stroustrup.com/C++11FAQ.html#extern-templates
I remember having to deal with huge FSMs (&gt; 1000 states) and there were two pains: 1. The lack of "macro" actions (ie, nested FSMs) 2. The lack of guarantee that all events are handled (or, reverse, only events for which a transition exists may occur) Your implementation seems to handle the first point, but not the latter. Also, I was wondering if it handled "pauses" ? That is, with asynchronous external queries, the ability to "pause" the FSM, serialize it into some blob, restore the FSM from the blob, and "resume" execution. It is quite necessary for multiple processes to share execution (at different points in time).
In general I don't mind switching cameras arond, but if something happens on the slide, then please *always* show it! For example when he switched back and forth on the benchmark slides or the slide with the parameter guidelines. That was really annoying.
&gt; it's just asinine. So, being excited about learning resources I've been anxiously looking forward to watching since *before* they were even recorded is asinine? Hmm. Pardon me if so. Also, my little 'first' joke was for the sole benefit of my friend the OP. I discovered the videos on my own 1 hour after they began showing up, jumped over here and discovered that Vittorio had beaten me to it by 15 minutes letting you people know about the news. Hope you all enjoy the videos, and have a great day. :)
 youtube-dl -U youtube-dl -i https://www.youtube.com/user/CppCon/videos
Thank you Jon!!1 We all appreciate very much you: * Putting the conference together for the C++ community in the first place * Rolling out the videos to us, maybe even a little early The event was an ossum success, and I hope it's **3 times** as large next year! :D Thanks again to you, Herb, and Chandler especially, and total grats to **everyone** involved. Hope to see you all next year!
I wrote the article about [not using `auto` unless you mean it](http://josephmansfield.uk/articles/dont-use-auto-unless-you-mean-it.html) and I enjoyed the talk, but I am of course not swayed on the `auto` arguments. Both Herb Sutter and I know what we're heading for (code against interfaces - i.e. concepts), but we disagree about how to get there. Here's a quick summary of why I disagree with many of his arguments: - Template type deduction works in the same way, yes, but it also has its problems (hence why concepts are being introduced in the first place). - His names for the template types significantly help with the readability of his code. This is just emulating what concepts will do without the compile-time checks. You cannot do this with `auto` variables. - Unconstrained type deduction will accept any type. While it is true that this means you can, for example, change a `std::map` to a `std::unordered_map` and you won't have to change much code, you could equally change a `std::map` to a `std::vector` and accidentally break everything. Even worse, the errors caused by this are propagated into deeper parts of your code, rather than the declaration itself. - Using `auto` to mask the ugliness of C-style declarations is even uglier. It's an abuse of the keyword. That's not what it's for. If declarations hurt your eyes, then get your IDE to do something about it. The view of your code is your IDE's responsibility. - Because you lose type information in the actual type of a variable, you end up moving some of that information to the variable name. So instead of `Iterator person = ...;` (which we will do with concepts), you have `auto personIterator = ...;`. This, to me, is as bad as doing `m_someMemberVariable` or `bIsVisible`. - The suggestion that using `auto` is "coding against interfaces" is absolute nonsense. It's much more "coding against nothing". You put zero requirements on the interfaces of your objects. We can only code against interfaces (we're really talking about compile-time polymorphism here) when we have the functionality to do so (concepts). I'd rather not introduce all of the above problems into my code before that happens. - Lastly, I feel like we're going to be teaching code style that will become obsolete in just a few years. Most beginners will just lap up `auto` because it makes coding more convenient (especially in the absence of a good IDE) and then when concepts come around, we'll have the same problem we had over the last 5-10 years with people using `new`. Edit: Whether you're Almost Always Auto or Almost Never Auto, they're both only temporary code styles. I feel like ANA will have significantly less problems.
See read_bison.hpp for how to read an entire grammar from a single string.
I'm glad that we agree on the use of templates! &gt; &gt; Longer compile times. &gt; Can be true, especially if misused. However more and more work is being done on decreasing compile time especially by clang. Sure, compile times are always improving. Here's hoping that future compiler tech will void the compile time argument against templates. &gt; &gt; Code complexity (templated code can be hard to read and even harder to write) &gt; Maybe in yeh olde days before anyone really knew how to implement them properly, but I have yet to see anything these day suggesting that an unnecessary instructions are generated or optimizations missed. Like you, I think that the compiler tech is already very mature. Any function instantiated from a template gets the same optimizations applied as any function written out manually. The problem arises when a lot of functions are instantiated. This results in instruction bloat and thus instruction cache misses (as Samlin puts it in his comment). Again, here's hoping that future compiler tech improves on this. E.g., by merging template instantiations behind the scenes using void* like signatures [like we are used to from C](http://ixodoi.expertscolumn.com/article/c-programming-void-vs-templates). &gt; &gt; Code complexity (templated code can be hard to read and even harder to write) &gt; Matter of opinion, library templates especially in the STL can be difficult to read but are usually trivial to implement. Usually it all comes done to documentation. I completely agree! ...And let's not forget that we get type safety with templates. Contrast that to the void* signatures from C. &gt; I find templates very easy to design and implement around, I feel like the criticisms listed are just the 'C with classes' crowd not understanding 'modern' (relatively at least...) generic programming. Well, I love templates... But I do get why the long compile times and code complexity might scare people off. The fixes are in the *future* but the shortcomings are still here *today*.
That is a nice feature and thanks for pointing that out. I see that it even has decent compiler support already. However, it does take some freedom away since you have to explicitly instantiate all your templates. It's nice to have the option nonetheless if you're really scared about code bloat.
To me, the real code smell is this: networkBus::getButtonOneSignalX networkBus::getButtonOneSignalY networkBus::getButtonOneSignalZ networkBus::getButtonTwoSignalX networkBus::getButtonTwoSignalY etc... Why not just networkBus::getButtonSignal(int, int) (or even networkBus::getButtonSignal&lt;int, int&gt;())? The code would be so much simpler if each signal returned the same type. Do they *really* have to be different?
I don't see how concepts will obsolete `auto` variable deduction. IMO, that is a red herring. Concepts constrain function arguments and return types. Given those constraints, you still want `auto` deduction of those types. So `auto person = database.query("name");` The `query()` function you can conceptify all you want, but why do I need to type that `person` is an iterator into the database? The compiler *knows* this already. When reviewing such code, I don't need to be told that, just like I don't need to know in which register the variable is stored.
As for your second point, I'm not sure what kind of restriction you intend. For now, if you push an event for which no active state has a transition, nothing happens. I don't think I can refrain a programmer from pushing an event to which no active transition is listening, since events can be pushed from outside the state machine. How would that kind of restriction be defined, and how would it be enforced? If you have a use example for that, it would clarify your idea. As for serializing the current state, that's a feature I've had in my head for a while, since I had to use it on another job using Qt state machines. I postponed its implementation because it conveys a good amount of complexity (how do you get to the non-initial restored state with regards to onentry/onexit events related to initial states?) and I wanted to ship the first version sooner rather than later. But I'm glad to see I'm not the only one to see usecases for that feature, so I'll move that up in my todo list.
I agree...
He mentions that range-for loops don't support early break at this point. Does this mean that every element in the collection will still be iterated over, even if the block is not executed for every element? Because this works as I expected: #include &lt;vector&gt; #include &lt;iostream&gt; using namespace std; int main(int argc, const char* argv[]) { vector&lt;int&gt; c { 1, 2, 3, 4, 5 }; for(auto&amp; e:c) { if(e &gt; 3) { break; } cout &lt;&lt; e &lt;&lt; endl; } } [twitch@alambic]$ g++ --version Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/c++/4.2.1 Apple LLVM version 6.0 (clang-600.0.51) (based on LLVM 3.5svn) Target: x86_64-apple-darwin13.4.0 Thread model: posix [twitch@alambic]$ g++ -Wall -std=c++11 -o rfor rfor.cpp [twitch@alambic]$ ./rfor 1 2 3 [twitch@alambic]$
Check the examples there: http://en.cppreference.com/w/cpp/types/enable_if But this is basically it. A new proposed feature called Concepts Lite will make doing such things much easier.
Yes the compile times are awful, especially if you have to build on old compilers because C++ can't link across different compile flags much less compiler versions, and my API customers need backwards compatibility. If you have to support VC7 you're just happy if using a bit of boost doesn't crash the compiler altogether. And I haven't seen any case besides generic containers where there's any real benefit (meaning in production code rather than toy examples) over using standard OO or old school C techniques.
I agree and lean towards ANA because my team is pro auto. I feel like auto is way too easily abused for such negligible gain. I'd prefer to just ban it, all I see are problems with it.
The style "auto I = 3" provides more clarity than "I = 3". Using the auto keyword shows that the statement is a declaration. Allowing that last style would hide that fact.
I = 3 also hides the fact that you are declaring a variable vs assigning to an existing variable. I also have some suspicions that "I = 3;" as a variable declaration might be close to if not impossible to parse with all the other syntax rules in C++
Having a keyword makes it clear where you are introducing a binding to a given name vs trying to use an existing one. There are languages that don't have a keyword to introduce some variables, but they all have to solve the problem of what scope to put the variable in. if (something) { i = 3; // blah } else { i = 4; // blah } cout &lt;&lt; i; // is this legal? What value is it? Different languages solve that problem differently. Also consider this void foo() { i = 3; // lots and lots of code // imagine a page of it if (something) { x = 4; // new variable } cout &lt;&lt; i; } Now somebody comes along and says "I hate the name x, I want it to be i." The compiler has to assume you mean to reuse the existing i. But that changes the meaning of your program Or this. void foo() { complicatedName = 3; // blah blah blah complicatedNome = 4; cout &lt;&lt; complicatedName; } Here I meant to reuse the same variable but ended up with 2. So lacking a keyword elevates some of my typos into valid but incorrect programs.
It would be nice for IDEs to deduce the type too.
"I = 3" is also straying into the 'implicit declaration' territory of old Fortran, which was a big mistake IMO (variable name typos). It's also why I'm still a little shy about the use of 'auto' in C++11... sometimes it's good to be explicit about your intentions...
Would you like to be my editor? :) What I'm saying is "There is another way to do it, BUT DON'T DO THIS AT HOME" I didn't say that it is an improvement. In fact, I didn't show the code.
Oops, I realize now this was a specific question about variable templates, thought it was a more general question about enable_if, apologies. Another workable solution is: template&lt;class T&gt; constexpr T pi = std::enable_if_t&lt;std::is_floating_point&lt;T&gt;{}, T&gt;{ 3.1415926535897932385L };
Or rather, even more compact form: template&lt;class T&gt; constexpr std::enable_if_t&lt;std::is_floating_point&lt;T&gt;{}, T&gt; pi{ 3.1415926535897932385L };
VS2013 will show you the deduced type in a tooltip.
I find shadowing warnings to be more annoying than useful. Reusing names makes sense to me a lot and I've rarely encountered problems. (E.g., `class Foo { int bar, baz; Foo(int bar, int baz) : bar(bar), baz(baz) {}};` I don't want to use `m_`, `_`, etc.) Writing `for (auto &amp;&amp;e : range)` doesn't seem like that big of a deal. Adding a 'typless' declarator seems ugly when the only previous example of such snuck into the language by accident and would probably be best if eliminated.
Because declaring person with `Iterator person = database.query("name");` will allow the compiler to fail early with a reasonable error if the initializer is later changed to a type that supports some but not all of the `Iterator` concept (especially if `person` is passed to weaker template functions). So you'll still want type deduction, just not the `auto` keyword.
To my mind, it is really important to clearly demarcate object definition from assignment.
I don't know if it was just me, but it felt like there was a huge mood shift when he answered that question, almost to the point where it seemed it invalidated a lot of what he said. That is, he doesn't want to work in C++, but in C99, and it is only because of the rest of the unwashed masses he has to work with that he uses C++, so he shapes it in C's image. He had no positive thing to say for C++, which seems odd for a keynote speaker at a C++ conference. I'd be very interested to read or watch more information on applying DOD principles while still leveraging the things that make C++ great. I was also looking for some criticism of DOD from within the games industry to find more sides to the story, but couldn't turn up anything. If nothing else, it would be nice to see hard numbers around a template approach and a DOD approach, maybe std::vector vs hand rolled dynamic arrays, etc.
Shadowing might seem innocuous in a ctor's mem-init-list, but it's extremely dangerous in large member functions (where you might get confused about what you're inspecting/modifying), and also extremely dangerous between locals. Better to enable shadow warnings and be really clean everywhere, even when it's not really necessary. Many people forget to write `auto&amp; elem` or `const auto&amp; elem` because the loop is hiding the initialization of the variable from them. It's really awful that such a wonderful C++11 feature encourages the writing of less correct, less efficient code than C++98 (where nobody unintentionally copies elements). That's what the terse loop solves.
&gt; it's extremely dangerous in large member functions I'm a fan of Bjarne's advice to avoid functions that don't fit on one screen. Maybe compilers could have a warning for long functions. (I'm kidding of course, though I think it could be a good feature for a lint type program.) Here's another example of shadowing that is entirely reasonable: lambda captures. Indeed, shadowing here is so reasonable that I don't know of any compiler that bothers to catch this case of shadowing, even though it can certainly [be misused](http://coliru.stacked-crooked.com/a/84fe42e517b77f45). Notice the examples I've given so far involve variables that have clear relationships to the variables they shadow. Shadowing is a reasonable thing to do, and the false positive rate on shadowing warnings is far too high to be useful to me. &gt; That's what the terse loop solves. It just doesn't seem to me that there's an epidemic of people who don't understand how initialization works in range-for loops. If we can trust users to decide how to declare function parameters (`void foo(std::string &amp;s)`, `void foo(std::string const &amp;s)`) then why not for loops? Parameter initialization is 'hidden' in a way similar to the initialization in range-for loops.
I think you're over-stating how prone to breaking auto is. Changing std::map to std::vector is highly unlikely to result in runtime-breakage (I can't think of any such example). std::set to std::vector could maybe break stuff if you needed things to be ordered &amp; you didn't sort ahead-of-time. Even, then it would be unlikely as the intersection of available functions for std::set &amp; std::vector is quite small. Personally, I use auto when it enhances readability (i.e. the type can be deduced by reading code &amp; the code isn't overly verbose).
What could Herb Sutter have meant about it not supporting early breaks then?
It doesn't obsolete `auto` in general, just Almost Always Auto. Concepts as it currently exists only constrains function arguments and return types. However, the intention is for this to also apply to variable declarations.
Dunno, I would have to watch again to hear the context.
When I was a fortran programmer, we had to add 'implicit none' (or 'IMPLICIT NONE' :) to every 'subroutine' to be allowed to check in code, I think most compilers now have a flag to ensure it's there or produce a warning if it's not. Implicit decs are not a good idea.
&gt; That's what the terse loop solves. Thanks for the proposal STL. I think it's a great idea, and look forward to being able to use. Also, since it's simpler to write it will be easier for novices to 'do the right thing'. *"Make Simple Tasks Simple!"*
Your IDE should be able to tell you whether a variable is a member or not. I tend to prefer using `this-&gt;` but I do find it ugly also. I only wish references had existed when `this` was defined. To me, many things have clear cut responsibilities. The type of a variable describes what can be done with that variable (or similarly, what its value represents). The name of a variable tells what the variable represents in your business logic. Your IDE is responsible for presenting your code in a way that makes it easier to read.
You should almost always encapsulate calls to `new` with RAII. In fact, you can often let smart pointers do the resource management for you and never have to do any yourself. Here's a few references: - [Why should C++ programmers minimize use of operator new?](http://stackoverflow.com/q/6500313/150634) - [Why should I use a pointer rather than the object itself?](http://stackoverflow.com/q/22146094/150634) - [Rule of Zero](http://flamingdangerzone.com/cxx11/2012/08/15/rule-of-zero.html)
So what about the code-ripple effect that Herb talks about in his video? If `database.query()` is changed from `map` to `unordered_map` then all of a sudden `Iterator person = ... ` needs to be `ConstIterator person = ... ` etc. This is not good. `auto` tracks the type, as Herb eloquently put it. Also note that Andrew Sutton's talk did not feature any concept name on the LHS of any variable declaration. Concepts are for *defining* functions/variable template, whatever, but *using* those nicely checked interfaces can then be done with complete trust in your compiler. If anything, concepts facilitate Almost Always Auto.
&gt; this-&gt; I sometimes use it when I have a `swap` member or some other function that takes an `other` argument, e.g. std::swap(this-&gt;value, other.value) i.e., just for symmetry reasons. but otherwise, I don't bother.
If the code would have worked with an immutable iterator in the first place, it should have been declared `ConstIterator`. Then there is nothing to change when you move to `unordered_map`. On the other hand, if your code depends on the `Iterator` being mutable, then it's just not going to work when you change to `unordered_map` anyway - you'll have to change some code. Like I said, concepts do not yet include concepts as variable declarations, but I have seen Andrew Sutton himself say that this is an intended future step. It would unify the declaration of both variables and arguments so that both can be constrained as you please. I understand that you might think I'm looking too far forward, but I'm what I would call an idealist-coder and I can be patient!
Indeed, I suspect it's a trap since it made me twice more curious about it. The description on YT makes it clearer: &gt; Concurrency is one of the major focuses of C++17 and one of the biggest challenges facing C++ programmers today. Hear what this panel of experts has to say about how to write concurrent C++ now and in the future.
I just happened to read N3994, and it struck me that he might have been referring to having no iterator to inspect for completion after the loop.
Well, if you intend to lean on the IDE, keep in mind that it can show you what type "auto" will refer to as well. ;)
One reason would be that your proposition is not backwards compatible and ambiguous. int i = 0; { int i = 1; } cout &lt;&lt; i &lt;&lt; endl; int i = 0; { i = 1; } cout &lt;&lt; i &lt;&lt; endl; These two programs have different outputs (0 and 1) but would translate to the same code with your change.
Not in all cases. Consider when the initialiser depends on a template type parameter of the containing function. Nonetheless, the whole point of coding to interfaces is that you should never need to care what the concrete type is - only the interface that you depend on. I don't consider this something that the IDE has to care about.
I stumbled over the same thing, he said it pretty much exactly at the 10:00 mark of the youtube video. I thought he might have been thinking of using lambdas with std algorithms such as std::for_each. In that case you can emulate continue with return (which is counter-intuitive), but there is no way to break the loop, save throwing an exception (ugh).
I had been wondering about, if "for (const auto&amp; x : list)" exists what just regular "auto" would do. 
Why did they use auto instead of var? Was there something that would break?
Yeah... I'm not buying your ANA argument. Changing map to vector is so fundamental that you're not likely to get any silent breakage. And if you do (it is possible), then the generic code you wrote was not truly generic to begin with which is a problem in your style of writing template code.
auto was already a keyword which was repurposed. 
Yes! That was a thinko -- I've been so used to teaching std::for_each which doesn't have break. Of course range-for does. Thanks for C++17 extra crispy, STL. :)
AFAICS, 2) is almost a subset of 1). The almost is probably a collection of typos discovered between publication of 1) and 2). I don't think there is really new material in 2). 
&gt;Not in all cases. Consider when the initialiser depends on a template type parameter of the containing function. Aren't most modern IDEs use a compiler such as clang for type deduction? Can't they deduct the type in any case? 
^ I'm going to second this. C++11 has actually been a godsend (Godsend?) for me, as its made things much much simpler and straightforward. If your team isn't taking advantage of these changes, like the aforementioned auto and new containers, then it's definitely in your interest to expose them to these ideas. But, to further agree with /u/bstamour/ this is only useful if your codebase can handle the new features.
What I meant was if they are already using these features in the codebase then it would maybe be a waste of breath :-) However your point is good too: if the codebase is too old and crusty, introducing new language features may be a slow, slow process.
Move semantics, type deduction, universal references and perfect forwarding.
I've only read 2), and it's great, but depending on what you want, you could also consider 3) Programming: Principles and Practice Using C++ (2nd Edition), also by Bjarne. This one is the most updated of the lot.
I have both books (which I recommend to you as well). [Tour](http://stroustrup.com/Tour.html) is an introductory text for experienced devs (either C++98 or other languages), and an easy read. [The community](http://isocpp.org/faq) apparently wants to standardize on this book as the [*one* book](http://isocpp.org/blog/2013/12/a-shared-view) everyone else can assume any competant C++ developer knows, much like K&amp;R2 for C. [TC++PL4](http://stroustrup.com/4th.html) is a tour de force, effectively touching on every aspect of the language in it's modern guise. Neither an easy read, nor strictly a reference. This is *the* C++ book. Whichever you choose (or again, both) you should get the [excercises](http://stroustrup.com/4thExercises.pdf) and work through some of them. Hope that helps.
&gt; 2) is almost a subset of 1) It's an expanded, slightly update version of the first part of TC++PL4thE. It's more than just fixed typos. Anyway, OP clearly wants The C++ Programming Language given that he is an "experienced C++ programmer". No debate in my mind.
The results [reproduce nicely](https://chart.googleapis.com/chart?chs=520x240&amp;cht=lc&amp;chtt=OS%20X%2010.9.5%20SMART_POLITE&amp;chxt=x,y&amp;chxr=0,2,32,1|1,0,260&amp;chds=0,260&amp;chd=t:60.0934,90.2646,60.2302,75.2321,60.6907,70.476,65.4152,69.4358,73.8754,79.2428,83.939,89.9079,94.4682,100.069,105.244,110.11,114.818,119.598,125.188,130.888,136.966,142.182,149.655,152.314,158.586,164.06,170.354,175.095,184.202,189.872,191.463) under OS X, but I'd be curious to hear an explanation as to what's different about Windows that produces [these results](https://chart.googleapis.com/chart?chs=520x240&amp;cht=lc&amp;chtt=Windows%208.1%20SMART_POLITE&amp;chxt=x,y&amp;chxr=0,2,32,1|1,0,260&amp;chds=0,260&amp;chd=t:171.91,255.501,170.179,213.159,184.096,194.426,62.107,69.0453,73.8278,82.5026,87.8984,101.934,122.596,123.023,141.427,130.375,150.48,139.305,149.636,185.605,171.621,174.702,177.082,205.481,199.049,204.372,226.504,229.224,245.187,244.435,251.376). In fact all of the algorithms give similarly strange results on Windows. The only real improvement occurred when I tested VC++'s `std::lock()`, which still managed to somehow take 90 seconds for the N=2 case. The code is C++11 so it took a couple changes to [build under VS2013](http://pastebin.com/pY55bVQQ).
Why aren't you using `std::atan(T(1))*4`? I would rather use this than a hard coded constant. 
People have asked for it, but I haven't heard of anyone writing an actual proposal. I'm not planning to - I don't believe the benefit outweighs the cost. What I really think is that Evolution/Core should solve the temporary range problem (range-for keeps only outermost temporaries alive), which will allow this to be solved efficiently in the library: "for (elem : as_const(range))", in addition to "for (elem : reversed(range))" and whatever else you like.
&gt; this [PPP2](http://stroustrup.com/Programming/) is *by far* the best introductory programming textbook for any beginner serious about becoming a professional developer using C++. Not the easiest book to work through for a beginner nor is it intended to be imo. My #1 recommendation to mature learners trying to understand C++!
Regarding point 2, it's an open question. One possibility is to restrict to set of events (say to a given list of types) and then ensure that every single state has a transition for every single type. The latter can be done either with a runtime check at machine instantiation or with template hackery.
std::atan is not constexpr &amp; I have heard of no move by the standards body to constexpr'ify the trig functions. This might be do-able with compiler-specific extensions. One reason this may be avoided (aside from constexpr) is that std::atan(T(1)) * 4 could have numerical error (&amp; vary depending on HW/library implementation) whereas a constant will have guaranteed precision &amp; be computed offline using precise algorithms to however many digits are needed (http://en.wikipedia.org/wiki/Gauss%E2%80%93Legendre_algorithm).
Use [cppreference.com](http://cppreference.com).
Is is worth considering using C++ for embedded just to get references, bools, and extra type safety? On that note, do you know of any embedded projects riding the Rust hype train?
I use codebocks on my Mac. Just a heads up do not put a space in the file name or any folders or else codebocks will not compile. 
Just going to target embedded devices since your topic is huge. I work on software which targets Linux on ARMv5 and v7l. We use exceptions and the STL. In fact our ARM compilers have better STL support than some of the other shit we target like Solaris Sparc, AIX, HPUX. C++11 is limited due to legacy targets not due to memory constraints or STL internals.
Dealing with alignment is usually only needed for memory managers such as writing your own memory pool. The compiler is guaranteed to align classes and structures correctly and `new` will always give you memory aligned correctly for the largest built in type. When you are writing a pool though and your objects are say 14 bytes long but your first element is a dword, that's when you need to think about alignment. Casting also presents issues but I'm having a hard time thinking of a legitimate case when you should be casting in a way that will cause alignment issues. 
Just want to comment on number 2 - not all embedded applications are mission critical and neither exception handling or return codes prevent developer error. To many libraries abuse warn_unused_result so I often see that warning disabled.
A bool is essentially an enum'ed byte, a reference essentially a pointer. If you need a whole new toolchain just to abstract this away, then you aren't worth your salt as a programmer. As for type safety, C can be written to look and feel like C++ for many purposes: use typedef'd structs and enums instead of classes. And do you really have type safety when you have reinterpret_cast as a language feature? IMO, you need a very strong argument, as well as a very strong design, for choosing C++ over C for small, reliable embedded applications. I'm not saying it can't be done technically, I'm saying it's much more difficult to do as an organized team project.
Good stuff. This is why I read this sub.
Apparently I'm not good at intuiting at what symbol to click at to be judged correct. Clicking the != in a "review the A = B != C" question is wrong.
rybxjfpq, Thanks for the reply. My goal was to be vague and 'huge' - I want to know everything! ;) &gt;In fact our ARM compilers have better STL support than some... I'd love some more info on 'better STL support'. Does that mean that when the compiler in question is compiling ARM code, it does something special? Or is the STL implementation just suited better for ARM? 
&gt; redundant return 0 in main ...is not such a bad idea. Most compilers will warn you if you don't...
Papa_Formosus, Thanks for the classic reddit-style reply. &gt; IMO C++ makes it really easy for developers to produce unpredictable and inefficient machine code, in comparison to C. This makes sense and is backed up by most things I can get my hands on related to the topic. Though, maybe you couldn't tell, but *these* are the things I'm asking about. I guess I can look at the output of my optimizing compiler to see some proof - or learn ARM assembly. &gt;Memory alignment is most important for performance reasons: allowing memory controllers to operate on data members / structures in fewer cycles, fitting said data in fewer cache lines, etc. /u/rybxjfpq's explanation is clearing it up. &gt;2)... Which is why I've been avoiding `exceptions`. Hanging around the freenode ##c++ channel, some users convince me that in all cases, exceptions are 'the same' as other error handling mechanisms but provide better readability. This is silly though. Your comment helps. &gt;3)... After doing some tests, my assumptions/misconceptions have been cleared. Conclusion: `atomics` are sometimes better than managing sequential consistency yourself. &gt;4) I have no idea what you're talking about. Well, forget about it then. Since I don't know how every dark corner of libstdc++ or other c++ std lib inplementations, I guess I can't really ask this. I was worried that while I try to avoid feature `X`, that same feature might be used in feature `Y` - I'm sure there is a name for that. &gt; 5) ... Makes sense. I should read more of the implementations. I appreciate your reply. Apologies for the poor questions - these things are easy to ask when you struggle to define where you're having issues. 
The error handling mechanism I use most often is implemented throughout most of the Linux kernel: a "goto" to the end of the function, where clean-up is called. Once you get past the "OMG GOTO!" shock, you'll see that it is a very predictable and reliable way to handle errors. In fact, I suggest you read Linux source code for a myriad of reasons. It's ugly as all get-out, but it implements a number of idioms that translate very well into embedded designs. If you want a starting point, see how device drivers are implemented. Lots of gold nuggets in there. Another exercise to go through is looking at the output of the linker once you've written your code, and seeing how many libraries are being used, and how thoroughly they're being used (just for one function? many functions?). Check out how large some of these libraries are. Then imagine you only have 128 MB of flash on which to store your final binary. Then imagine you have to partition that 128 MB of flash into two: one production image and one "rescue" image (for failover / upgrade purposes). And be sure to leave headroom for future upgrades! This gets you into the mindset of embedded programming. There's likely lots of waste in your current programming (CPU cycles, bytes of memory, bytes of disk, etc.). Just the very exercise of finding that waste is great practice for being a good embedded engineer, or for that matter, a good software engineer in general.
Type deduction isn't foolproof. If you did float j = 0; You get a float variable. What type does this have? auto j = 0; It's a contrived example yes, but there are certainly cases where additional type information will *avoid* potential errors and improve code readability. There are still times where you will want to specify the type, and having explicit typing can at least help make your intent clearer to other programmers. auto was created more to deal with more verbose types such as std::vector&lt;std::string&gt;::reverse_iterator*
&gt; In fact, I suggest you read Linux source code for a myriad of reasons. I have and I do. I'm trying to figure out how much I should embeddify my userspace linux code. I understand `goto` and it's uses, and I don't hate its existence ;), I use it in C for error handling too. Moving away from C and to C++ &gt;= 11, it seems most people are using a very reduced portion of the language and I wonder(ed) why. &gt; Another exercise to go through is looking at the output of the linker once you've written your code, and seeing how many libraries are being used, and how thoroughly they're being used. ... only 128MB flash... Most of my external libraries have a license where I can statically compile them, which is nice sometimes. I only compile small portions and sometimes just use headers. I don't have the problem of having a small code space right now, but this does make sense. Eventually, having no library dependencies is the goal and using code-coverage is of course normal. I appreciate the response. 
As someone who lives in sydney I am disappointed in the lack of a local C++ user group.
yeah, 'embedded' has started to represent a pretty wide range of situations. Technically using something like the beaglebone or raspberry pi in a hardware project is still an embedded system, but it doesn't much feel like a traditional embedded system in terms of coding style and techniques.
Right. I guess to finalize this post, I should note that embedded design seems to be different from embedded *linux* design - what that actually means, I'll find out. Also, going to put my assembly hat(s) back on and start really figuring out what some abstractions are doing. I really appreciate your advice. And for the record, I'm not on a beaglebone or a Raspberry Pi, but a Xilinx SoC (zc706).
Any compiler which warns about no return statement in main is broken. It's explicitly allowed by the standard.
This is a complete conjecture on my part, but I'd wonder if it has to do with the [random boosting](http://en.wikipedia.org/wiki/Random_boosting) the Windows scheduler does that is designed to ameliorate any priority inversions that might occur.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Random boosting**](https://en.wikipedia.org/wiki/Random%20boosting): [](#sfw) --- &gt; &gt;__Random boosting__ is a strategy used by the [scheduler](https://en.wikipedia.org/wiki/Scheduling_(computing\)) in [Microsoft Windows](https://en.wikipedia.org/wiki/Microsoft_Windows) to avoid [deadlock](https://en.wikipedia.org/wiki/Deadlock) due to [priority inversion](https://en.wikipedia.org/wiki/Priority_inversion). Ready threads holding locks are randomly boosted in priority and allowed to run long enough to exit the critical section. If the thread doesn't get enough time to release the lock, it will get another chance. &gt; --- ^Interesting: [^Gradient ^boosting](https://en.wikipedia.org/wiki/Gradient_boosting) ^| [^Boosting ^\(machine ^learning)](https://en.wikipedia.org/wiki/Boosting_\(machine_learning\)) ^| [^Random ^forest](https://en.wikipedia.org/wiki/Random_forest) ^| [^BrownBoost](https://en.wikipedia.org/wiki/BrownBoost) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cky0vfz) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cky0vfz)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Is the flag `-Wcomplain-about-perfectly-valid-code`?
The STL container adapters are stack, queue, and priority_queue. They wrap underlying containers and restrict their interfaces (or in the case of priority_queue, call the heap algorithms), with zero cost. They have always worked this way (since C++98), so I'm not sure who would be saying bad things about them. The STL containers (vector etc.) are highly efficient implementations of their data structures. vector in particular is the bestest thing ever. (Of course, not all of the containers are so warm and fluffy. deque is very weird, you almost never want a list, and forward_list is by definition the least useful STL container.) Iostreams is terrible for performance. As an STL maintainer, I can tell you that its interface is highly resistant to having a fast implementation.
"I've only heard negative things regarding STL container adapters and iostreams with embedded processors. I've not sure how true those claims are anymore." This completely depends on the environment and the application. STL is really only a problem if dynamic memory allocation must be entirely avoided. That's only possible if your entire program and all state can fit in memory. If you have control of the final hardware, like some medical systems, then perhaps you can make the hardware fit your requirements and just allocate everything up front thereby avoiding any potential failed memory allocation. This is rarely the case though so dynamic memory allocation is usually inevitable but the memory manager needs to be special to avoid the problems that come with a generic heap. Typically this means a block allocator that needs to have its sizes tuned to the allocation pattern of your final code. If you have such an environment then STL usage won't be a problem. 
&gt;This line is optional. C++ compiler will implicitly insert a "return 0;" to the end of the main() function. At least they know that and explain it immediately. Can't really speak to the rest of their examples.
This should have been posted in /r/cpp_questions but since it is already here, might as well answer: &gt; Is C++ still a relevant language? Or am I better off with Java? Python? Yes it is. All of those three languages have their use cases and none of them is good for everyting. For example, it is being told (though I have no own experience) that for bigger projects in game development, C++ is still the standard. &gt; What would be the best place to start right at the beginning again? Entry level projects/codes I could work on, etc.? That depends on how long it has been and how experienced you were back then. For every programming language I would recommend learning a stable level of basics first, even more so for C++. So if things like templates, pointers and iterators do not mean anything to you, reading a book is the first step for you in my opinion. If you could handle the language fairly well but it was several years ago, you should not start at the very basics but still read about the new features introtuced in C++11 like auto and lambdas. And if both of these do not apply, do what you want. Write your own calculator, your own chat system, whatever you want to. 
C++ is great in my opinion, versatile for native apps on any platform I've worked on, but I'd say it depends on what kind of project you're working on or what your end goal is (for instance "career" or something.) If it were me I'd probably pick up Python as its kind of hot right now. Then again I'm well versed in C++ so I don't need a refresher.
It's definitively relevant to get a job in my field. Most of the companies/universities want c++ and python skills. Anyway, if you just want to use it for fun, why not try a newer language without the 10y+ learning curve, which learned from the mistakes in the language design of c++? Edit: The last sentence is only meant to be advice, not a bitter judgement about c++.
&gt; For example, it is being told (though I have no own experience) that for bigger projects in game development, C++ is still the standard. C++ is indeed used to great extent in game development. From my short experience, I can point out CD Projekt (developer of Witcher series and awaited Cyberpunk 2077 to give short resume ;)) that looks for C++ specialists almost constantly. Here are their [openings](http://en.cdprojektred.com/jobs/). EDIT: By the way, I am not advertiser/shill/headhunter/synonym. But if someone here would be actually interested I could answer some questions about Poland.
I think it's possible to strike a balance where function paramaters and return types are typed. Auto should really work when your return type is part of a long namespace. std::chrono::extremely_long_time_clock t1 = blah vs auto t1 = blah
Build something. And then build a better v2. Something that covers language features and libraries of interest to you.
I'm generally fine with this as long as it's still clear what that type is without relying on the tooltip VS provides. There are many times where you'll be reviewing your own / other people's code in diff tools where you're just looking at the text. This is where variable naming becomes significantly more important.
Looks like this wouldn't do too well in the presence of threads.
I am not a fan of teaching kids to program as a course, in that most teachers can't teach difficult things and thus are going turn many kids off programming. What I would like to see are programming/robotics clubs that are well financed where those who are interested could group together and learn together. From that I could see amazing things. 
Did you ask them why the question was answered that way?
Why ar eyou pissed? It's obvious it is a mistake, rather than the teacher not knowing what he is doing. In fact, I suspect every coder has made errors far more stupid than that.
You mean, you'd expect it to be "compile error: cout undefined"?
&gt; However, the STL sort is a non-parallel implementation ... Is this anything stopping standard library implementors from making it parallel by default, or at least include an option for it? Indeed, can we expect any of the standard library algorithms to be implemented using parallelism any time soon? I guess it might be complex/impossible to do that.
Did you confront the teacher about it? If so, and he/she doesn't agree with you, then right on, you should be pissed. If not, then chill, man! Talk to the teacher! Getting mad before sorting things out is counter-productive. The first thing you should've done is talk to the teacher about it. If you go through life getting pissed at everything that doesn't seem right, you're going to spend a lot of your life angry. Think of your blood pressure, man!
It actually works pretty well to produce the percent coverage statistics since each instrumented line is only incrementing a a single element in an array, and the statistics really only need to tell if the element is non-zero. I have already used it on projects with threads, and it works fine. In addition, the COV_IN macro is in a header file that can be modified to do whatever is needed on different platforms. So some locks or atomics can be used if accurate counts are needed for something more than the coverage statistics. Perhaps I will think about adding a flag to allow generating code for C++11 atomics. 
C++ for a language? We had to take Latin for a year. 
Isn't C++ for software development as Latin was for the middle ages? Every educated person must know some sort of C/C++ and it's still the basic thing thought in most classes?
IMO there is one answer to this, A tour of C++ (the new one, copyright 2013). It's clearly written with good examples, and covers the most widely used aspects of C++11 in less than 200 pages. 
C++ is a great teaching language. It is much more honest about how computers work. Teaching people that strings (dynamic allocation) and garbage collection are magic and always present hurts people's understanding. A better choice might be Rust since it encourages strong memory ownership.
You expect anything less from a user named "SexKnife"? XD
If you get pissed every time you find a bug then get prepared for a career of outrage...mostly at yourself.
&gt; This completely depends on the environment and the application. STL is really only a problem if dynamic memory allocation must be entirely avoided Which I guess was the point of my question, in which I failed to convey. I wasn't really concerned about their algorithms or complexity but mainly about their memory patterns. I've been messing with block allocators and found that using some of the STL is ok and easy to manage an allocator for. I appreciate the reply.
It would not hurt to ask about your options, regardless of language. Considering that university graduates in Poland must have at least B2/C1 English proficiency, it is likely not a strict requirement. Plus look at the sections 'We offer': &gt; Polish lessons for foreign employees. Considering their requirements, I doubt that they would decline excellent programmer on linguistic basis. They might be more picky when it comes to junior/intern positions though. Seriously, you can't lose anything by sending CV.
There's not 1 single STL implementation. http://en.wikipedia.org/wiki/Standard_Template_Library#Implementations In C++03 concurrency is not specified and it's left for implementations, which makes using concurrent algorithms generally non-portable. Something a particular implementation might provide (although not like in the example from the article, since it would add a full dependency on Microsoft's PPL. Namely, Microsoft could add this (in stdext for instance). The article is presumably comparing to the STL shipped with Visual Studio as it seems to be using its concurrency runtime. I've seen code using Microsoft's Parallel Pattern Library (PPL) "Concurrency::parallel_invoke" and Intel's Threading Building Blocks (TBB) "tbb::parallel_invoke" - interface-wise they seem to be very similar. Clang and GCC both use different implementations. In EASTL merge-sort has no in-place implementation AFAIK ( https://github.com/questor/eastl/blob/master/sort.h ) you have the option to provide a pre-allocated buffer to do the merges or have mergeSortBuffer take care of the allocation. I know libstdc++ (used in GCC) has in-place mergeSort but I don't think it's parallel currently. ( https://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-4.4/a01027.html ). I don't think libc++ (used in Clang) uses mergeSort, last time I checked it used quickSort. Google is not finding me mergeSort in libc++ except for third party code. So maybe it isn't there, not sure. 
I do code coverage testing on the x86 platform, then cross-compile to the target. For short or int sized objects, the increment operation is fairly atomic itself, and since the array is a global, it is probably difficult for the compilers to optimize anything away. I originally needed some coverage for a medical device, and thought about the simplest thing that could work. I wrote the first version in Python, but since I wrote a cheap parser that only worked for my coding style and not full C++, using CLang is an obvious choice.
Your last paragraph is a very powerful one. Where I used to work we transitioned from truly embedded systems to single board computers for most products. The hardest part about it comically was "taking off our leashes". Many of the developers would shit themselves when they would see some of the other developers code. It wasn't a case of shitty code, it was simply a case of "You can't do that, this is an embedded system!". You could almost immediately tell someones age by their code those first few months. It was a shining time for the young guys to show off actual features of the language. Sorry for rambling. 
I just purchased this book based on your post. It better be good god damn it! Just kidding. I have recently found myself doing a lot of double takes when looking at C++ code. I hope this book helps me get back in touch with my old favorite language.
This is not isolated stupidity, he just leaned c++ last year, and he's a terrible teacher. He also tried to argue that he was right. He gave up obviously, but he's an idiot. I guess I'm more pissed at how bad he is than this specifically.
The whole class talked to him, he gave us points for it, I'm mostly pissed because he can't teach for shit.
Is there any reason you use source code modification (producing new files) instead of using a Clang plugin to modify the source that Clang would read and compile ? The latter would let you seamlessly integrate with any building system (as long as Clang is used to compile).
how did his argument go?
Not sure if I understand your comment. In the former case, you are already independent of the build toolchain. So why use a clang plugin and therefore be dependent on (a specific version of) the compiler?
I believe Bjarne has been quoted as saying that his book covers everything he expects a C++ developer to know.
&gt; Iostreams is terrible for performance. As an STL maintainer, I can tell you that its interface is highly resistant to having a fast implementation. So what about the [2006 Technical Report on C++ Performance](http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf), which has an interesting section on IOStreams (p.68): "Since certain aspects of IOStreams processing are distributed over multiple facets, it appears that the Standard mandates an inefficient implementation. But this is not the case — by using some form of preprocessing, much of the work can be avoided. With a slightly smarter linker than is typically used, it is possible to remove some of these inefficiencies. This is discussed in §6.2.3 and §6.2.5." Are those suggestions for some reason not adequate to get good performance for IOStreams?
Are you in US? If so, you should be used to that already, man.
Parallel by default is really, really bad idea. But if you want your algorithms parallel by choice, [I have good news for you.](https://parallelstl.codeplex.com/) *(Some variation of this is very likely to be standardized soon(ish))*
For example [here](http://isocpp.org/blog/2013/12/a-shared-view), he says: &gt; What is the basic knowledge that we should be able to assume from a competent C++ programmer? So, rather "the minimum" than "everything", I'd say. ETA: He also says that the book is the answer ;)
I just ordered this book yesterday after seeing in mentioned in the latest CppCon Herb Sutter talk.
Remember that C++ was designed in the 80s and 90s, when PCs/servers were roughly as powerful (or significantly weaker!) than today's embedded/mobile systems. C++ is really quite friendly to such systems.
First year at community college and already can tell that something is way better here. But I had a couple great teachers in high school/middle school, usually they are the ones that have wives that make a much larger amount of money.
N3936 17.6.5.9 [res.on.data.races]/8 absolutely forbids STL implementations from observably autoparallelizing anything: "Unless otherwise specified, C++ standard library functions shall perform all operations solely within the current thread if those operations have effects that are visible (1.10) to users." Things like operations on user-defined elements and iterators are observable. So your copy ctors can still do things like increment global or static ints. Unobservable autoparallelization is theoretically permitted (e.g. sorting a range of int *, which involves nothing user-defined), but that's covered by the unwritten rule that STL implementers aren't crazy.
This code has a pernicious problem: missing `break` after the last `case` (which is `default` here). This is a time bomb for later maintenance - adding more cases to the end of the `switch` will trigger fallthrough. This is similar to why omitting braces around `if`/`for`/etc. is dangerous.
EoP (I'll refer to it by its initials as is customary with all great books) was an amazing, mind-expanding book. If you enjoyed it, you will probably like the lecture videos that Dr. Stepanov gave at Amazon (https://www.youtube.com/playlist?list=PLHxtyCq_WDLXryyw91lahwdtpZsmo4BGD). There are 38 of these great videos. I can't wait for his upcoming book, "From Mathematics to Generic Programming" (http://www.amazon.com/Mathematics-Generic-Programming-Alexander-Stepanov/dp/0321942043).
I will take this project as a learning experience... if I manage to pull this off, then great, if it doesn't work out, I still have my job. Any advice would be appreciated.
C++17? what is this?
For what it's worth, I added a METTLE_EXPECT macro that grabs the file and line number for those who find that information particularly helpful.
The future 
C++ is way to complicated though - people will end up struggling with syntax, abstractions and ambiguity. C++ is just too big a language - a language for large projects. If you want to teach newcomers how a computer works, I believe C is a much better choice.
I do not agree with this advice. For my day job, I'm working on a legacy c++ ATL &amp; VB6 application. I compile it using msvc2010, and therefore I use all the new c++ features available in this compiler. So take the advice published recently and use features like shared pointers, auto keyword, and all the other blessings introduced by c++11 and beyond.
But surely that means you have to deploy the application with the corresponding C++ runtimes which might be a problem on a legacy system?
OP is talking about being forced to use VC++ 6.0. You are talking about msvc2010. It's an entirely different beast.
Oh, stop the fear mongering. Pre-standard C++ was a very powerful and useful tool. He doesn't have to worry about portability. He should be fine.
It really depends on the size and quality of the code he has to change or extend, but in general I agree. I didn't have trouble using C++ with Visual C++ 6.0, or rather: I didn't have more trouble than I would have had with another language or tool. And VC++6 was used by a lot of people for a long time, and people managed. OP should just be aware that a lot of (recent) online resources will not apply/work for him.
A Visual C++ 6.0 codebase shouldn't use any complicated parts of C++. It probably doesn't even use STL. You should be able to master this. Here are the brief steps: 1. Quickly refresh yourself on the basics of C++ programming. Re-learn pointers, classes, instances, the rules around virtual functions, object lifetime management techniques, and static initialization. These are the techniques you're most likely to encounter. 2. Learn how to capture crash dumps, and ensure you have the files required to analyze those dumps (especially PDBs, or specific OBJs if you use the /Z7 flag). 1. Ensure you have the right versions of every library. Check deployed machines and double check which libraries they use. Track down DLLs in shared locations using dependency walker. 7. Ensure your project compiles and runs as-is. There may be an updated version of the source code hidden away elsewhere in your company. That would be good to know up front. 1. Thoroughly understand your requirements. What does management want to change in this software, and how much time/money are they willing to spend? Are they patching minor bugs, adding very minor features, or are they ambitious for more serious changes? 904. The code is bad. I can tell you this from years of experience. It's proprietary in-house code to run devices, from a company that isn't primarily a software house. Such code is always bad. As you make changes, you'll expose pre-existing bugs. Knowing this up front, you'll want to take precautions. 1. Get 2 of those industrial PCs. One for development, one for automated testing. 1. Make a complete list of what the software does today *in production*. Don't worry about things it's not used for. Worry about what it is used for. Take this list and write integration tests, so that you know right away when you break something. Which you will. I don't advise you to unit test everything; that's a time sink. But you do want to know when you've broken something important. Set up one of the industrial PCs to run through this test suite whenever you push a new build. 1. Do you have a version control system? You must have a version control system. If they have a pre-existing version control system, it's likely CVS or VSS. Never use VSS, it loses data. Don't use CVS either, if you can help it. For a single developer project, I suggest SVN. It's simpler than the DVCS programs, it's free, it does what you want, and it's quite reliable. Have IT set up a repository and figure out how to make backups. 1. Just for fun, see if your codebase compiles with a newer compiler. It probably does, or would with very small changes. The newest compilers aren't compatible with XP, but I think 2012 or 2010 is. The C++ language has many new features, some of which can be very helpful even for legacy codebases. 1. Now you're ready to start changing the code. I'm going to presume they want you to make minor changes, so you'll want to tread lightly. 1. Don't change code just to change it. That makes sense if you're making major changes, but for minor changes you want to get in and get out without making your life harder. 1. Make the smallest changes you can. This typically involves adding member variables to classes, adding parameters to functions, and making small changes to existing functions. If the function is untenable, I suggest keeping the function signature and redoing the code inside. If you can't get away with such cautious changes, then do what you must but it'll be more work. 1. In general, you will save time if you centralize any oft-repeated code. For example, if they have 5 different ways to store exactly the same data, and they must manually convert between these all the time, you're better off writing a small class to handle that logic. 1. If you have to deal with custom containers much, know that the STL containers are better tested and more reliable. Consider switching to STL containers when it makes sense, and use &lt;algorithm&gt; if you can, but you'd better understand STL first. It's great, but it's a huge mind-bender at first. You'll need books; do not rely on the internet for understanding STL. 1. Best of luck, and always remember that you have options. Use your judgement but don't be afraid to admit when you're wrong and go back to an old version. 1. If you don't take my advice about version control and integration tests, you'll really regret it.
I'm currently working on VC++6.0 and it's not hell as I supposed it when I was hired. Feel free to PM me some of your questions. First thing : it can run fine on Windows 7, although I work with XP, and the IDE is blazing fast compared to the modern version of VS(Express) or Qt. **Compiler caveats** The templates support is almost non-existant. Try not to use it. Look at the support page for known compiler bugs : http://support.microsoft.com/kb/195738 . The STL may also be missing, but I don't use it anyway. **IDE caveats** * There some missing keystrokes that irk me (close current file, switch back and forth between source and header) and the properties popups aren't rescalable, which is a pain in the ass when you want to update the includes paths in a project. * Other known "feature" : the Intelisense plugin can only accumulate meta-data, which sometimes slow the IDE into a crawl. To fix it, delete the .ncb and .opt files. * If you're using SourceSafe for versionning, the sync between the IDE and SS is shaky, take care. 
How cool -- you get to drive automation machinery! This is a win/win for you -- and those old systems are all over the place. You could end up with a skill that can make you A LOT of money just moonlighting... As for specific advise: don't learn modern / current C++, it will just make you sad with all the fancy tools from C++11 you can't use. As systems age, it is important to stick to absolute basics, avoid any fanciness. Simple is the watch-word for working with old code bases. To inspire you -- CppCon recently had some wonderful talks -- Mike Acton talked about how it is "all about the data!": http://youtu.be/rX0ItVEVjHc -- about avoiding world building, about keeping it simple and close the the data -- great talk! Herb Sutter also talked about the importance of simplicity and getting back to basics: http://youtu.be/xnqTKD8uD64 ... good luck! EDIT: Bonus Points for writing code so simple and consistent it works in VC++ 6.0 and modern C++. Also, remember toy projects are amazing for learning a new compiler: http://www.reddit.com/r/dailyprogrammer
&gt; Using MSVC++6.0 while you've used newer IDE's is like playing AgeOfEmpires1 while you've played AgeOfEmpires2. Sure it works, but you'll get frustrated about missing features. Yes.
Nope, best thing is: for (auto&amp;&amp; element : container) { dostuff }
Well, given your name and job combo, I think you are required by nature to implement efficient iostreams. My condolences. :-D --- Also, since I've already written this comment, will the deque in MS's STL improve to allocate more rationally sized chunks? IIRC, last time I looked it allocated either 16 bytes or sizeof (T), which seems rather suboptimal.
Hah, it's a NTU website! I thinks it's just this professor's personal wiki site.
jeetsukumaran, I just added the cppreference.com backend. Can you try it out and let me know what you think?
"(Another difference was that this installs the formatted documents as standard man pages rather than shipping a separate command line tool.)" This is not quite true. You can always add the manpath to system and use the default man command for viewing.
Well, you are only independent in as-much as you manage to somehow instrument the files. If some files are generated as part of the build process this can be painful... ... so, I guess, it depends whether you want to depend on the build process or the compiler :/
I hope we can soon switch to that. Given that you're forced to create a new scope regardless, I like that idea a lot.
Looks like they have re-uploaded some of the videos like that! Bjarnes keynotes for example, hope they will do that to all of the videos...
It's really not uncommon for a compiler to give warnings about perfectly valid code. Things like unused variables, possibly uninitialized, integer slicing, etc... Valid code by the standard but still deemed by some to be bad enough they want to be warned when they do it. I don't think return 0 qualifies as bad enough for a warning, but the concept of warning about valid C++ code is not without precident by a long shot.
[It's a reliable source of information](https://www.youtube.com/watch?v=HDoKyzHzP14)
&gt; The constraint was incorrect (it shouldn't have been there, and it was expressed incorrectly) So what should the constraint have been, assuming we want to follow Herb's advice to have one? Something like `class = enable_if_t&lt;is_assignable&lt;decltype(name_),String&gt;::value&gt;`? Herb never really described what his intent was with the constraint.
You'll get basically the same result out of `auto&amp;` as you do from `auto&amp;&amp;`
I agree. The holes were indeed set up quite well. Setting up a nice, *clean*, professional hole is tough work.
Going native was unbeatable in terms of video quality and the whole setup though. It was really amazing. But Microsoft has the money for it :-) I think cppcon gets pretty close, which is really great! 
EXCELLENT! Whoever read my complaint and re-edited the videos, I love you forever and owe you a beer. &lt;3
Only the first half of [Boris's talk](https://www.youtube.com/watch?v=mWcZkkBZF64) is currently up. Doh.
A list of the talks [is available here](http://cppcon.org/conference-program/). One of them does have Clang in the title: Bringing CLANG/LLVM To Windows. I'm sure other talks have some Clang related content though.
Math is too big. Integrals are too hard, so we can't teach basic addition. -_- Students don't need to know every aspect of C++ in order to learn how to program. And I do support C as a starter language as well.
Thank you! This is fantastic!! I appreciate the time you put into putting this list together... am printing it out now and will follow through with it :)
Thank you! I just found the service packs online through the MS website for VC++ 6.0... kinda surprised, and happy that they are still available for download. I like the idea of converting the project to VC++ 2013 so we can use more recent programming tools.
Out of curiosity I went and watched those talks you mentioned and they were great. Links if anyone's interested. 2012 : http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Clang-Defending-C-from-Murphy-s-Million-Monkeys 2013 : http://channel9.msdn.com/Events/GoingNative/2013/The-Care-and-Feeding-of-C-s-Dragons
&gt; It better good Hehe. It *is*. But ommm...actually it's really targeted at newbs. If &gt; *my old favorite language* is an indicator, you're probably far from that. Bjarne has written a short little book [Tour](http://stroustrup.com/Tour.html) much more squarely aimed at what seems to be your case. If you already know old-school C++ or another language, then this brief overview and introduction text to Modern C++ is probably better suited to you. Sorry about my wording causing a mix up. If you run across any software dev *beginners* however, then PPP2 would be the perfect gift for them if they have the fortitude to work through a thick college textbook. edit: indicated modern C++
Good on you! Bjarne's writing style is really geared more for professionals, but this book really stands apart currently as an exceptional resource for the serious beginner.
For most cases, but not all. 
Actually, it's [PPP2](http://stroustrup.com/Programming/). From the TC++PL4 preface: *If you ask, “What’s a for-loop?” or “What’s a compiler?” then this book is not (yet) for you; instead, I recommend my Programming: Principles and Practice Using C++ to get started with programming and C++.*
People have strong ideas about what will end up in C++17. So yes, you can already find people talking about it.
regarding STL you mention heap_algorithms... do you know why there are these weird free functions *_heap instead of just that being internal impl of priority_queue. are those algorithms so important they made it to public part of STL ? 
because MS is run for profit... and they can earn more money like this and selling X copies of VS than spending 3x money on it and selling 1.2 x X copies of VS. Not to mention that if the implemented C++11/14 when they "should" ppl would have less reason to upgrade. 
😉 &gt;You might be writing C++ code for years without ever seeing such an exception That's surprising! Everybody should have seen it! Well either that or, I would certainly like to see all those **geniuses** who never had memory leaks in their C++ code. Because that's a prerequisite not to see that pesky bad\_alloc. I, and any other C++ person I ever knew in my life did **not** have that prerequisite. &gt;But what if exceptions are turned off? The raw usage of new then will return a nullptr, but as new is in modern C++ now hidden and you mostly only will get a handle (e.g. smart pointer) , which you can check. But not always is this an option, for example std::vector::push_back will not give you a hint. For most users of C++, exceptions belong into modern C++, but as CppCon has shown, there is a large subset of C++ users which have exceptions turned off. On that, I see only two correct ways if one uses standard library: * you have exceptions turned on, period * you have designed everything so that, on a failed allocation, program dies on the spot (before returning that NULL). It might restart, recover or what have you, but it must **die** on OOM. That requires help from the OS (e.g. process isolation, which not all system have, think low level embedded). About turning exceptions off for performance: yes, but only for *some* (performance critical) compilation units, and those must have no-throw code only (typically: resource allocation is verboten there).
&gt;Many modern operating systems will in fact never raise bad\_alloc You're talking about OOM killer and similar facilities. That's a wrong train of thought. First off, for **all** such systems I know off, OOM killer is an option that can be turned off. Second, address space fragmentation is real and can cause OOM **even on systems with OOM killer activated**. To be frank, I have never seen it on 64bit systems, but most certainly have seen it on 32bit ones. Third (and arguably the most important), you're relying on non-standard behaviour: nowhere does standard prescribes anything about OOM and you can't therefore wrote platform agnostic code that relies on it. I'll have a look at SO later 😉
May i ask why you're not utilizing variadics for the registry class?
&gt; the much more dangerous problem of for (auto elem : range) being undesirable. Why is that dangerous? 
Variadic templates? Well, I haven't used them before, so I'm not sure on their details. My goal was to let the classes have any type and number of parameters in the constructor. I was under the impression that you essentially had to use recursion for with variadic templates and I didn't think that would work on constructors. However, simply setting your first constructor parameter to std::tuple can get the same behavior, I think. Do you have an example that uses them on constructors? I would love to convert them if possible.
There's issues that can crop up and such that may require more work, but if all you need to do is call a constructor it's pretty easy: template &lt; typename T, typename ... Pack &gt; T build_me_this(Pack &amp;&amp; ... pack) { return T(std::forward&lt;Pack&gt;(pack)...); } Obviously that's a useless function, but the pattern applies to a variety of problems.
Thanks, I'll give that a try and see if it can simplify things.
So I just watched this CppCon presentation: [Titus Winters "The Philosophy of Google's C++ Code"](https://www.youtube.com/watch?v=ApMxfaK8QZk). He states at the beginning that he is the person in charge of the C++ codebase at Google. In one of the first few questions in the Q&amp;A, he is asked specifically about exceptions thrown by the STL. Titus responds that in general they just don't catch them: &gt; "You can use all the STL containers just fine without using exception mechanisms. You lose (he shrugs) .at, but we have debug mode range checking turned on." The questioner checks his understanding: &gt; "So you look for examples where you're calling APIs that might throw exceptions and don't allow those according to the style guide?" Answer: &gt; "No. We just don't catch them." &gt; "I don't care about throwing out_of_memory exceptions. I've heard of one case where you can credibly recover from that." Nothing about this being enforced by "the compiler level by disabling exceptions &amp; RTTI". Although you quoted a source in another comment that indicates they use e.g. `ATL_NO_EXCEPTION`. Just wanted to comment that it's not as obvious as you and /u/cdglove made it seem if the person in charge of the style guide and the C++ codebase at Google says what he does in that video.
So I just watched this CppCon presentation: [Titus Winters "The Philosophy of Google's C++ Code"](https://www.youtube.com/watch?v=ApMxfaK8QZk). He states at the beginning that he is the person in charge of the C++ codebase at Google. In one of the first few questions in the Q&amp;A, he is asked specifically about exceptions thrown by the STL. Titus responds that in general they just don't catch them: &gt; "You can use all the STL containers just fine without using exception mechanisms. You lose (he shrugs) .at, but we have debug mode range checking turned on." The questioner checks his understanding: &gt; "So you look for examples where you're calling APIs that might throw exceptions and don't allow those according to the style guide?" Answer: &gt; "No. We just don't catch them." &gt; "I don't care about throwing out_of_memory exceptions. I've heard of one case where you can credibly recover from that." Nothing about this being enforced by "the compiler level by disabling exceptions &amp; RTTI". Although /u/vlovich quoted a source in another comment that indicates they use e.g. `ATL_NO_EXCEPTION`. Just wanted to comment that it's not as obvious as you made it seem if the person in charge of the style guide and the C++ codebase at Google says what he does in that video. This is why I hate comments that appeal to some sort of mythical common wisdom, and that something "is not news".
Oh thanks! That is very interesting.
&gt; why do you think that your code does not have leaks? Because leak prevention, in modern C++, is really trivial most of the time. There are other problems which are hard – such as avoiding dangling references – but avoiding memory leaks is simply not hard in clean C++. That’s the whole point of using value semantics and automatic storage instead of pointers to manage memory.
Just got it to work, thanks for the example.
Fantastic. Added to my Watch Later.
it is not polite to link to stolen content, it is freely avaliable on C9 http://channel9.msdn.com/Events/GoingNative/GoingNative-2012 http://channel9.msdn.com/Events/GoingNative/2013
Cool! I've recently written something similar for c++98, a "factory factory" or templated factory. Example use would be something like this. struct A : public Product&lt;A::id, A, DefaultConstructor&lt;int, int, int&gt; &gt; { A(int a, int b, int c); static size_t id /* = 3 */; }; struct B : public A, public Product&lt;B::id, child_of&lt;A, B&gt; &gt; { B(); static size_t id = A::id + 1; }; int main() { Factory&lt;A&gt;::create(A::id, 1, 2, 3); // makes A with A(1,2,3) Factory&lt;A&gt;::create( B::id ); makes B with default constructor, returns A* Factory&lt;A&gt;::template create&lt;A&gt;(); // compile time error, tries to use non-existant default constructor Factory&lt;A&gt;::create(A::id, "foo" ); // runtime error, can't cast DefaultConstructor&lt;int,int,int&gt; to DefaultConstructor&lt;string&gt; (actually error msg is just "no default constructor for these parameters") } I think the major differences are * I force static registration, i.e. deriving from "Product" instantiates the relevant Factory and registers the class * I can therefore only accept numeric IDs, in the current implementation only things that implicitly convert to size_t * IDs of classes are fixed at compile time. I've also made a serialisation thing based on the same idea. Next step: make serialisation a special case of factory creation. Anyway, it's kinda similar, which is surely interesting for you ;)
Cool, thanks for sharing! It looks like you can also support subclasses with different constructor parameters, which is something my solution can't handle. Believe it or not, I've never actually run into that case, but relaxing that constraint certainly opens up more use cases. Any chance you have the code hosted somewhere?
&gt;&gt; why do you think that your code does not have leaks? &gt; Because leak prevention, in modern C++, is really trivial most of the time. There's two things that are off with that: * not all code is modern C++; one is much more likely to have a mix of C++ 98, C++ 2003 and the modern C++ on their hands. There is friction between them and a risk of changing old code to bring it up is real. So this is where I think you need "geniuses" to get it right. * the fact that it's easy in modern C++ does not mean nobody will make a mistake, and you **still** need e,g, valgrind.
&gt; not all code is modern C++ I never claimed that; in fact, I’m convinced that most C++ ever written is rotten and leaks more than the Danaids’ bucket. But that wasn’t the point in this discussion: you were never making claims about badly written code but about *all* code, and then specifically about *my* code. &gt; the fact that it's easy in modern C++ does not mean nobody will make a mistake I have explicitly acknowledged that. But, to make this perfectly clear: in modern C++ there is no reason (most of the time) to make *any* mistake *when it comes to memory allocation*. It is possible, without much effort, and certainly without requiring genius, to write leak-free C++ code. This is a point on which I won’t budge. &gt; you still need e,g, valgrind. True. Valgrind is in fact tremendously useful. But it does more than leak detection, and in fact those cases where Valgrind has found leaks in my code were false positives ~~(which are [fairly easy to create](http://stackoverflow.com/q/5074308/1968))~~.
thank you. :)
&gt;&gt;the fact that it's easy in modern C++ does not mean nobody will make a mistake &gt;I have explicitly acknowledged that. I don't see it, where? &gt;But it does more than leak detection, and in fact those cases where Valgrind has found leaks in my code were false positives (which are fairly easy to create). You **really** need to look at those valgrind reports from SO report again. There were **no** false positives, that code obviously had two leaks. The problem was, rather, that valgrind claimed that the second leak was still reachable whereas in fact it was not. So... trust that this old fart knows this better than you: **do not** doubt your memory leak detection tools eaaily, statistically, they know better than you, orders of magnitude ~~better~~. In fact, now you really should show the code where valgrind claimed that you had a leak and you think it was a false positive. I bet you that you indeed did have it, but you didn't know why it was a leak.
Hmm, I get: ImportError: cannot import name get_lib_path 
First of all... the more you speak about valgrind, the more I think you never used it at all. Because if you did, you would have known what "still reachable" means and you would have known why valgrind would report it with standard library on your implementation. I am still waiting to see that code of yours where valgrind reported a false positive. In fact, I am not waiting, because I think that you don't have it. The best you can do, I think, is dig out a valgrind bug that has long been fixed. And I am thinking that because you tried to show valgrind being wrong **twice**, and failed as many times. As for addressing your central point (writing leak-free code is easy (in modern C++)), [I already did address it here](http://www.reddit.com/r/cpp/comments/2i6wpc/insights_into_new_and_c/cl0t13s) and see no reason to repeat myself. The fact that you answered something to that doesn't mean that my argument was wrong, because frankly, you were arguing past it.
While I certainly support encouraging linking to the original content, I would hardly classify the YouTube links as "stolen". The GoingNative site itself offers these videos up for download. The fact that someone uploaded them to YouTube to ensure they are forever accessible (and more accessible to things like Chromecast) is wonderful. Come on, now...
Hey guys. Thanks for all of your comments. Turbo C++ is recommended by by the Board so i can't change that, but I'm going to try each of your suggestions one by one at home. Thank You people. :D 
&gt;you didn’t give any specific argument at all I don't have any except that humans are fallible (which I said before). &gt; “[e]verybody should have seen” std::bad_alloc, and that it takes “geniuses” to write leak-free code Yes, I claimed that, and I also said that I meant it tongue-in-cheek. I was exaggerating to put the point across. I also explained further down what I really meant: everybody had a leak somewhere, and they didn't see a bad alloc only because their code didn't go enough time through a leaky section. I really don't see why you think this is rubbish, I find it perfectly reasonable and it is based on my personal experience. I also really don't see why you claim that I have given "no justification whatsoever". I think that you got worked up because I dared criticize your code, because I act as an arrogant bastard and because I exposed holes in your understanding of valgrind in the area of leak detection. I didn't not mean to criticize your code per se, I was trying to get the point across. I mean, honestly... you claimed that not having memory leaks is trivial in C++, but we all know that even in GC-ed languages people manage to leak. For me being an arrogant bastards, well, tough. But who cares, it's just an anonymous internet forum. I can't hurt you with arrogance, nor you can hurt me. As for valgrind, dig this: I don't use it day to day (I use other tools), and yet, I could easily prove you wrong about valgrind. **You think about that**.
Grand blogger.
&gt; I could easily prove you wrong about valgrind. You think about that. I don’t mind being proved wrong. I also don’t particularly mind you being arrogant; after all, so am I. For instance, I’m reasonably sure that my code is in actual fact leak free. Most of that is even proved by the static type system, since I rely on the type system to check my memory management. You’re right that this doesn’t in principle escape *all* kinds of leaks, and that (depending on your definition) GC-managed systems can also leak. All I contend is that these situations are comparably rare, can be isolated and dealt with.
Is there a procedure to deal with an incompetent board?
You can pay up at in Bellevue next September. 
It's probably just light-hearted trolling 😉
&gt; Would you rather we hold them all until they are all ready? NUUUUUU!1 
He might have a valid point. It really doesn't matter what the craft. Is if you don't keep yourself up to date or continuously improved you might not be as dedicated as you may think. 
Check this: https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ 
http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Standard-Template-Library-STL- If you've got a reasonable basic understanding of C++, then Stephan T. Lavavej's channel 9 series on STL is an incredibly useful set of videos. https://www.youtube.com/playlist?list=PL09Ke5-ligfmlkBZRHA3HbEQSU2LanWti I'd also really recommend the videos from GoingNative 2013, there's some great content there and the recording quality is really high. Scott Meyers' talk "An Effective C++11/14 Sampler" and Sean Parent's "C++ Seasoning" are good intermediate-level talks about writing modern C++, but there's loads of other awesome talks there. https://www.youtube.com/user/CppCon/videos I've also just noticed that a load of videos from cppcon a few weeks ago have just been uploaded to YouTube. I haven't had a chance to look through them yet, but I would bet on Herb Sutter's talk "Back to the Basics! Essentials of Modern C++ Style" being good!
nope. 1 and 2, I agree. 3, 4, and especially 5 are wrong in my experience. If you count only finance for instance which have most of the infrastructure developed in C++, you are well paid. RTB is growing and some people are considering again the C++ (what I'm doing for 2years now). This is still a problem of having the right tool for the right problem... The article in this sense is just bullshit.
One interesting, anecdotal sidenote. Every person that has placed "C/C++" on their resume and applied to our company has known little to none of both. I get the sense that this was written by a web programmer that can't crack into the systems programming market, especially since they've used PHP as an example in three of their five points, and [the PHP language is a terrible language to work with](http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/) if you have any compilers or systems knowledge whatsoever.
Embedded systems and embedded engineers which do most of the work in C/C++ are especially well compensated, at least from my experience. C++ is my day job, python and other more popular technologies are more of my hobby.
I liked how the article started, the difference in API design and how something which looks clear on first sight might not be as good in its particular use cases. However, the example used to compare speed was not as interesting since reuse of memory is a general concept which should be known to most C++ programmers.
I think there is more truth to 4 (lack of market demand). A couple of friends lost their quant jobs to PHP programmers! /sarc
&gt; think there is more truth to 4 (lack of market demand). A couple of friends lost their quant jobs to PHP Finance is not only quant but also market data, try to stream data using PHP :) I heard that C# and Java are also quite well spread. Python is used in commando from what I heard too. I'm still receiving several opportunity by week for C++ jobs. 
On another note, I'm curious, which doing you think is better PHP or Python when learning LAMP? I'm currentlty focusing on C++ myself but am reading stuff on LAMP as a side thing, and curious what "P" i shoudl focus on. 
I feel the only letter still relevant in LAMP is the L.
Please do it in pure PHP and let me know the memory footprint, the CPU usage and the latency. As a side note, I'm not trolling on PHP here, Python or Ruby would not be better. On some big traffic (let say 100K qps/sec) I can't see the PHP achieving something decent, let's say that it is possible I'm not sure that will be cheaper than doing it in C++.
Don't learn a language to find a job working in that language. Learn how to program in a number of languages and styles (imperative, functional and OO at least). Learn how computers work (how data is arranged in memory, how caches work, how function calls happen, how dynamic dispatch happens). Learn some Computer Science (complexity analysis, common data structures and algorithms, concurrency). Learn how scalable, highly-available distributed systems are built. Talented C++ programmers are very much in high demand, but just knowing the language doesn't get you there by itself. Be able to solve hard problems with the appropriate tools for the job. Be ready to learn new languages, new theory and new problem domains as you go. If that all sounds "well, duh" and you're looking for a job, PM me with your contact details and/or resume. 
What does a web programmer make these days? I mean a guy who does only straight forward business CRUD web apps that shovel data around to different DBs and reports like has been done for 30 years now. You'd think it'd be pretty well commoditized work at this point.
Thanks, yea I'm focusing on C++ i wanna know all there is to know. I'm just learning about more advanced computer science now, its taking a bit longer because I'm trying to get myself ready for a masters in CS while working full time. I really enjoy working with C++ I love creating simple programs and also like being able to read code in other languages and understand what its actually doing, what functions are being called, what those functions are doing. I find it helps me to just read about things that may be too advanced for me, bc it always leads me to new topics. Thanks for the offer but honestly I doubt that i am near where a hireable C++ would be as far as talent. I feel like if I had the time allowance to program 12 hours a day I would be pretty proficient in a few weeks. I feel like a lot of programming is trial and error and understanding how things are compiled how memory is allocated, the time it takes for a program to compute etc. Its difficult(not impossible) when you have a few hours each night to work on something and have to get to bed before you've had enough time with a piece of code to understand it fully. 
(author here) I agree that it should be known. But, even in the cases (unfortunately, not that common) where 'should be' can be replaced with 'is', people tend to miss out on those. I'd say that while doing API design, people tend to get blind on these issues, because they seem unrelated at that moment. It is not very easy thinking about all the fun tidbits of C++ while creating API. I'm pondering to write the next one about the list pop method that returns a value. Again, a known problem, a known issue, but most of us would actually write it instead of the STL's top/pop combo because it is nicer to use and seems more sane.
So in point 2 apparently business application == web application? And in point 4 desktop software are simply not written in C or C++? I wouldn't trust the opinion of someone that has such a limited view of the world of software development.
True to an extent but I believe that a good lecturer can activate the brain in a different way. At least for me there is a big difference between how I learn in a class room as opposed to a book. Videos by their nature don't deliver a lot of content like a book does but sometimes they lead to that moment where clarity strikes. So by all means grab a good book. As for YouTube lectures not much good is to be had there in the sense of a full course of study. There are some great videos as has already been mentioned for used on certain parts of C++. I just don't know of any that really could be considered a full course of study. 
Bullshit, yes - the demand for .NET, Java etc. programmers is probably higher, they're the trend nowadays and HR doesn't spend that much time researching what they actually want. They want a programmer, hear Java is popular -&gt; they want a Java programmer. A company that actually wants C++ programmers has a higher chance of knowing their stuff and you're much more likely to score interesting work (i.e. not repetitive database coding or Enterprise Java). Either way, if you do learn C++, you will definitely not have any shortage of work. I am looking for a project on the side so I've submitted my CV to a couple of work ad sites. I pretty much listed C++ and a couple of fairly obscure libraries (Computer Vision) just in case there was actually someone looking for that. Within 10 minutes I had 3 calls from HP and two other companies asking me to come for an interview. None of those were interested in the Computer Vision stuff, so that wasn't much of a factor. I should also say, that I have very few relevant references as I am still in school. If you end up freelancing, I think C++ a very good choice if you don't want to develop web apps, as you then get a chance of convincing the client it is a good choice yourself. And it is - cross platformness is not that much of an issue nowadays, speed is usually superior, you can touch the metal to a decent degree... Basically, it forces you to think about your software a little more. I've worked with countless languages, but with the exception of functional stuff like Lisp and hardware related languages like VHDL, I simply don't find any of them as intriguing as C/C++. I am glad I worked with Java for a while, but I really don't want to learn it in depth and I feel similarly about the rest. More importantly - there are countless libraries to choose from, amazing frameworks, bindings for absolutely everything, you can run it on anything from a calculator to a computing cluster and every imaginable problem has been solved in it ten times over. C++11 will bring some very interesting stuff to the table as well eventually. It is also worth noting though that it isn't the language what's really important. What you need to learn is problem solving, algorithms... basically get yourself comfortable with the idea of programming - the language is just a tool. Use one that fits the bill best. Learning another language well enough can take days to weeks after you know a few, every one will bring new ideas to the table, then you can safely forget them ~ and you will, I wouldn't say I know a language if I didn't use it in the last half a year even if I once mastered it. Cheers.
There's one string in stl case, there's two with qt (the object outside that readLine, and the result of readLine inside it). Compiler should use RVO and eliminate a copy, but it can't due to possible errors: imagine that it conflates the two, then starts working on the string, then error happens: the shared string is already broken, but the exception will be raised. So with qt, there **has** to be an additional string instance, meaning an allocation every time. In STL case, however, all gloves are off. The doc says: [The contents in the string before the call (if any) are discarded and replaced by the extracted line.](http://www.cplusplus.com/reference/string/string/getline/) Therefore, in stl,case, library *and* the compiler can work together to reuse that one string as much as possible (allocation is made on the next iteration only if previous capacity is smaller than line length). It should be noted that the stl case degenerates to qt case if, by any chance, the reader needs to preserve the contents of the string before the last error. That certainly looks like an odd duck.
Python! Seriously Python is a very versatile language and frankly a good compliment to C/C++. It is something that will remain valuable to you even if you loose interest in LAMP. 
The article does have the flavor of a programmer that can't handle anything complicated and has to strike out at the more intelligent developers out there. Beyond that much of Web development can hardly be called programming. I suspect that this character leaves the tough parts of web development to real programmers. 
To me, the article seems to be marketing strategy. C is fundamental system programming language. C++ is a complicated language, but can be very powerful if you know what you are doing. Both have their application, their market, and they are not going away anytime soon.
It might be advisable to go to the web sites root page and see for yourself whom they are trying to appeal to here. Frankly it doesn't even look like an appeal to what would be considered professional programmers. The site has the flavor of nasty marketing. &gt;Thanks, yea I'm focusing on C++ i wanna know all there is to know. It is pretty tough to know all there is to know about C++. Don't let that stop you though because it is very ears to use a subset of the language effectively. &gt;I'm just learning about more advanced computer science now, its taking a bit longer because I'm trying to get myself ready for a masters in CS while working full time. I really enjoy working with C++ I love creating simple programs and also like being able to read code in other languages and understand what its actually doing, what functions are being called, what those functions are doing. I find it helps me to just read about things that may be too advanced for me, bc it always leads me to new topics. I feel for you as I know exactly what it is like to work full time and go to college. Be careful burnout is an ugly thing. &gt;Thanks for the offer but honestly I doubt that i am near where a hireable C++ would be as far as talent. I feel like if I had the time allowance to program 12 hours a day I would be pretty proficient in a few weeks. Fresh out of school expect proficiency to come after years on the job. &gt;I feel like a lot of programming is trial and error and understanding how things are compiled how memory is allocated, the time it takes for a program to compute etc. Its difficult(not impossible) when you have a few hours each night to work on something and have to get to bed before you've had enough time with a piece of code to understand it fully. I'm not sure I like the idea of trial and error. Sometimes due to poor documentation you might fall into that and sometimes bugs in your code might perplex you but in general there should be a clean path to the code you need to write. A reference to trial and error has me wondering if you have a good grip on programming in general. 
The [full article](http://www.it-career-coach.net/2007/07/25/learning-c-programming-language-is-bad-for-your-career-c-programmers-cant-find-jobs/) seems to be 7 years old. Most of points are pure marketing (is a lot easier to train C#, Java, Python etc. devs than C++ ones) and just plain marketing... when I read that article it was like an evangelist was preaching for eternal happiness or a commercial about miraculous healing procedures.
This article overlooks that learning C++ is not a linear path... in that I mean I have NEVER met anyone who only programs in C++. Learning C++ takes years and is complimented by other languages.
&gt;I'm not sure I like the idea of trial and error. Sometimes due to poor documentation you might fall into that and sometimes bugs in your code might perplex you but in general there should be a clean path to the code you need to write. A reference to trial and error has me wondering if you have a good grip on programming in general. Sorry I didn't mean to make it sound like I was blindly programming. I meant that when I type something in error or misunderstand a concept it helps to have an example I am currently trying to run to understand exactly where and why certain errors are coming up, how to fix them, and how to avoid them in future. 
That and the blame on the API. Does the API cause the performance problem or the rest of QT? I'm not real familiar with QT, mainly because I have no need for it. Further I don't use any Linux software built around it as I find the stuff slow and garish. I'm just not sure that focus on the API is right. 
The problem as I see it is that APIs have underlying implementations that can vary widely in performance. At some point you have to either trust the library developer or switch to something else. Besides in real world software you might be doing something else while a file is being read. I'd rather burn a few cycles if it means clear readable software. In other words does it really make a huge difference. In some circles reading a line at a time would look foolish. 
I'm not so sure if it has to do with dumb people not doing research and going with the option that seems to make sense to them. I always believed it had more to do with that web related stuff is easier to support. Imagine you wanted some kind of cool program that would be used by your customers. If you want it to become a downloadable application, it needs to be tested on all kinds of machines. You might even want to offer support for tablets, phones and other things. Sometimes it's easier to choose a web application instead. It doesn't completely eliminate having to test it on different devices, but depending on the application, it may be much easier to support and maintain. 
Which is a good book you recommend?
Great article - not sure why these keep getting downvoted, if you like C++, then this is the sort of thing you like...
I agree. You need to have reliable upstream for your project. API does not matter if the implementation is awful, and vice versa, if the API is unusable, it does not matter if the implementation is perfect.
I think PHP is still the dominant P in LAMP but Python is much more versatile and has much broader applications.
There's a nice link on the sidebar to an SO question. I haven't bought any C++ books recently, but apparently Bjarne's is very good. And I will be getting Scott Meyers' new Effective C++ when it's out (I loved the 3rd edition).
One thing that hasn't been considered that much here are two other differences: * `QString`s safe their contents as utf-16, which might also be a reason for them to be slower. (This is not to defend Qt, utf-16 is a truly stupid encoding that nobody should use anymore.) * `QString`s are implemented using copy-on-write. This may be another factor here, though I'd like to point out, that libstdc++ currently does the same. (I really hope they switch with GCC 5.0).
Python is useful for web development, command line tools and random glue code. Learning it will teach some good practices and techniques that'll transfer to quite a lot of languages. PHP can be used for any of those things, but it's not great at them. The thing it's decent for is to allow low-skilled, low-paid coders to churn out inexpensive, insecure web pages. Learning it as a first language will ingrain some bad practices that you'll need to unlearn later, lest you end up using them when you're working in better environments.
What a crock. This is more about the difficulty of getting hired to fill a position for which the candidate has little professional experience.
Are they contacting you about C++ jobs though? I've found that many recruiters who contact me are hiring for C# even though my resume is filled pretty much exclusively with C++ experience.
As a senior game designer, I've been teaching myself programming to keep myself relevant. I started with Python and got as far as being able to write a simple text and ascii based games (Hunt the Wumpus and Battle Ship), but after talking with some programmer friends in the industry, it was recommend that I just jump straight into C++ since that's the majority of what games are programmed in (and also the language that they use). Since I was very much interested in joining their company, I took this advice. Perhaps game development has more of a need for C++ than other industries.
`std::string` is a Frankenstein monster of a type. It was designed before the STL's iterators and algorithms, then had the iterator interface bolted on. That's why it's so inconsistent. We could certainly have lived without the `size_t` overloads. But yes, with the Iterable concept, we can add range support everywhere without needing separate overloads for counted ranges.
Its funny that one of the first thing Bjarne discusses after this introduction is that it is unproductive to be a *language lawyer* 
The performance implications of the `std::getline` API are examined in greater detail [here](http://ericniebler.com/2013/10/13/out-parameters-vs-move-semantics/). *Disclaimer: it's a link to my site.*
I wasn't even aware of the prior art when I picked the name. But as it turns out, Iterable is used in Java, JavaScript, Python, Scala, Dart, Groovy, and Haskell to mean pretty much the same thing.
What is a SO question? 
Sorry, I was typing too quickly. By SO I meant StackOverflow. The link is at the bottom of the section on the right.
No worries. Thanks for the recommendations. 
This isn't entirely true. First, Python is good for a lot of things beside those you've listed. It especially shines if you can program in C, so you can work around Python's warts when necessary. Second, bad code isn't PHP problem, it's people's problem. I mean, it has such a low entry barrier, it's very forgiving, so it creates an environment where everything goes. But it doesn't really prohibit you from writing decent code. 
It would seem that way, but this work is always in demand and the deeper these shops go into an intermediate language implementation the deeper the monetary debt that needs to be paid to programmers to maintain these systems. But, to answer your question; from the market I'm familiar with. Starting devs (fresh out of a 4 year program) range from 50k to 60k USD. "Experienced" devs (5 years or more) can start at 75k to 90k.
I like these ideas, I am thinking of usage. This: vector&lt;int&gt; v(10); std::iota(v.begin(), v.end()); for(auto i : v) { ... } Using infinite ranges and counted ranges would become?: for(auto i : view::counted(view::iota(),10)) { ... } I am a little confused by the difference between take and counted though.
`take` and `counted` are similar. `counted` builds a range from an iterator and a count. `take` adapts a range by taking the first n elements. So, `counted` operates on iterators, `take` operates on ranges. `take` cannot be trivially implemented in terms of `counted` though. `take` cannot just keep the begin iterator of the adapted range and throw the range away. That might make the iterator invalid. It needs to store the range. EDIT: So your example would look like this: for(auto i : view::iota(0) | view::take(10)) { ... } I prefer this "pipe" notation, but you can also write it as `view::take(view::iota(0), 10)`.
Oh yea, the pipe notation is nice here, especially with a longer query you wouldn't have to deal with messy nesting. Piping gives a LINQ Lambda Expression feel. If you're not familiar with .Net's LINQ it allows you to write things like (I haven't written C# in quite awhile): List&lt;String&gt; names { /* a bunch of names*/ }; var ordered_brians = names.Where( a=&gt; a.Contains("Brian")).OrderBy(a =&gt; a); Anyways, thanks for putting in the time to explore the range ideas. I am going to get the source and try them out.
Perl of course!
If you're into game programming and want some good reference or just starting out material, [Making Games with Ben](https://www.youtube.com/channel/UCL5m1_llmeiAdZMo_ZanIvg/playlists) has some really good stuff. He covers the basics and takes you through console games all the way to programming with OpenGL.
Both has been covered, one in the post (by using QByteArray instead of QString) and the other in the comments section.
Some people would argue that, in this case, it is not only an out parameter. The former value is not used, but the former capacity is. I guess that a distinct syntax might prove handy, not only for readability, but also for the potential compiler optimizations.
That's exactly what I mean, syntax to explain that "I'm giving you this variable, I expect a logical result in it once the function returns unless the function throws or returns an error". I've seen people use raw pointers as a way to denote variables used as output parameters (refs/values for anything else), but that seems a bit kludgy.
Great one! I love to see that ranges are starting to get more attention lately.
Agreed. Though, as I said, in this case it might do more harm than good if the field is marked as out, especially for the "logical result" part. In that case, the compiler might think it is more optimized not to use the previous string at all.
I get very different results. I wrote up some quick and dirty testing code for three cases, QFile + QByteArray, QFile + QTextStream + QString and finally the STL approach of ifstream, string and getline. Code [here](http://pastebin.kde.org/phczejceu). As input I used a text file created with this python snippet: with open("input.txt", "w") as f: for i in range(500000): s = "x" * 50 s += "\n" f.write(s) I actually get the best numbers with QTextStream. On average the running times are as follows: | Method | Average run time | |:-----------|------------:| | Raw QFile| 1235| | QTextStream | 964| | STL | 2518| This is on Windows with MSVC2013 and a recent Qt 5.4 snapshot. Edit: typos
This reminds me this 2001 piece by Andrei Alexandrescu: Generic&lt;Programming&gt;: Min and Max Redivivus. I think it appeared in CUJ. Now available on Dr Dobb's: http://www.drdobbs.com/generic-min-and-max-redivivus/184403774 Note: beware, CUJ articles were migrated to Dr Dobb's by a broken script: you can see &lt; and &gt; characters in the HTML source that were not converted to &amp;lt; and &amp;gt; :) 
Anybody that says "C/C++" doesn't know C++. Well, OK, that seems a bit extreme. My point is that if you spend a few years doing modern C++ (we could have a long discussion on how to define 'modern' C++, I would "no pointers, no arrays"), then you C starts to look very very strange. I don't mean that C seems like an old, broken, C++. It just seems very different, when reading C now I feel as if I'm reading Fortran. Nothing wrong with modern C or modern Fortran, but C doesn't really feel like C++ to me now.
Sounds like pretty good cirucmstantial evidence that the concept should be considered fundamental... unless they all just copied Java ;)
No need for premature pessimism either.
Inheritance typically means heap allocation, on the opposite, tagged unions can be stored continuously in a homogenous container and there's also no need for additional memory fetch when dispatching through vptr. This memory access pattern makes the key difference in performance. I don't have any benchmark to prove this though :) For low level system with a limited set of types I tend to go with unions, otherwise inheritance is fine and usually more convenient.
That's a good point. I don't have exclusively C++ experience so maybe I'm not a good example. I have gotten a few requests exclusively looking for C++ skills, but it's not the majority.
I suggest you to go to /r/cpp_questions to ask this question ;)
$0.02: I've never benchmarked this. I would expect the tagged union approach to be slower on a benchmark, only because the real points where these approaches are different is a switch()-ing over the tag type vs dynamic dispatch. I'm pretty sure that a dynamic function call is faster than switch() in all but the most stringent cases.
You can get the same sort of storage efficiency with inheritance if you store containers of concrete classes, but process them generically. Something like: class X: thingy {}; class Y: thingy {}; vector&lt;X&gt; xs; vector&lt;y&gt; ys; void process(thingy&amp; t) {} ... for (auto&amp; thing : xs) { process(thing); } for (auto&amp; thing : ys) { process(thing); } Not quite as elegant as having an array of pointers, though.
Anecdotal evidence: I have a fairly good, C++-centered LinkedIn profile. I am contacted by recruiters about 4-5 times a week. Most of the time with relevant job offers.
`ifstream::open` will open the file in text mode, which is the default mode of operation. The `&gt;&gt;` operator will scan the file stream, skipping white space characters and only reads-in non white space characters. This is good if you want to extract white space delimited sub-strings from the steam. Generally you would use `std::string` with the `&gt;&gt;` operator to extract sub-strings, or an arithmetic type if you want to parse numeric string representations in the stream. `ifstream::get` and `ifstream::read` is good for reading in literal characters from the stream, including white space. 
You're only considering half of the problem. Using inheritance means that when you put these in a container you no longer have contiguous values (only the pointers/references are contiguous), and accessing each element requires an extra pointer dereference, and the allocation/deallocation overhead is much higher since you can't allocate the storage in bulk.
In addition to what minno said, you can also placement-new the objects into an untyped buffer for kind of a hybrid approach.
The `&gt;&gt;` operator when used with an input stream performs formatted input. It's designed for reading whitespace-delimited tokens. No matter what type you try to extract (e.g. int, long, double, char), it will always first consume any amount of leading whitespace. That's why you never read a space. `istream::get` performs unformatted input. It always reads a single character, no matter what. As to your second question, you get the last character twice because you wrote this loop wrong. You must always check whether each IO operation succeeded or failed. But you're not checking whether `inputfile &gt;&gt; character` failed before doing `cout &lt;&lt; character`. When the end of file condition happens, you want to stop the loop without outputting anything, but since you don't check for that properly, there's an extra output step before the loop ends. The canonical way to do an IO loop with formatted input is this: while(foo &gt;&gt; bar) { ... } That is how the library was designed to be used. You perform the input operation, then check whether it failed. If it did, the loop ends there. The body of the loop is only ever run if the extraction succeeded. 
I opened the first video listed under "Advanced C++". It turned out to be about `const`. Ok, I guess not everyone uses the same meaning of "advanced" when it comes to C++. Not a problem. However... At some pointer they explained how to write to a `const` variable if, in their own words, "[you] really, really want to change [it]". (https://www.youtube.com/watch?v=7arYbAhu0aw&amp;list=PLE28375D4AC946CC3&amp;feature=player_detailpage#t=268) The question is already wrong on several levels. If you really want to change it, you don't make it `const`; it's that simple. What happens next in the video, though? They write `const_cast&lt;int&amp;&gt;(i) = 6;` and explain how it works just fine with `const_cast`. Well, that's totally wrong. It doesn't work. The behaviour is undefined and it isn't even one of those cases where it kinda sorta works kinda sorta sometimes. It's actually one of my simplests go-to examples of an optimiser taking advantage of undefined behaviour. They even run that program with undefined behaviour and it runs successfully! Apparently. Sadly, running successfully in this case means... nothing. The program doesn't even have output! It does nothing. Defines a `const int` and (wrongly) assigns a different value to it. No output. Even without considering the undefined behaviour a compiler can and will just optimise it to `int main() {}`. The program running "successfully" is inherently meaningless, because the program has nothing to run in it. A simple `std::cout &lt;&lt; i;` would reveal the faux pas that was made with `const_cast`. That gives the idea that if a program ran without errors, everything is fine. I don't think that's a good way to teach, not even when you are actually teaching the right stuff. That was just the first video. It didn't leave a good impression on me.
Yes, you could use the sockets library to create a tcp connection, send the appropriate GET command and download the content. I'm sure there's also a http library that does all this hard work for you though.
I haven't used it personally, but you almost certainly could use [libcurl](http://curl.haxx.se/libcurl/).
Seems like you are missing some basic understanding about programming languages and how high level concepts can be implemented/used with them. Asking if anything is possible to write in C++ is something like asking if it is possible to write a poem in notebook with green cover. C++ is a programming language. It doesn't have built in mechanisms to support URL, HTTP and other high level concepts. Instead you can write any type of support you need for any concept or use something already written (e.g. in form of external library or OS/framework API). There are libraries and APIs for HTTP, URLs, sockets, TCP/IP, files, images, video, sound, voice recognition and so on. So your question should probably sound like what are recommended libraries for HTTP protocol and HTML parsing. At least I think this is what you meant. 
The 2014 videos are afaik all uploaded by the CppCon user. For other videos I don't know.
Thank you for your detailed answer! However, I need to apologize, because I realized that I do not have *literally* "C/C++" on my CV, but "C, C++" for the exact reasons you mentioned. Different language, different paradigm, different idioms. Being more precise with languages on my CV is a good idea, but I lack work experience. Otoh, I worked with every language I list on open source or uni projects. Maybe that would be a good start. At least some food for thoughts, thanks again! :)
I was a Google intern for two summers a couple of years ago. It sounds like nothing has really changed. I've stuck to the "no const reference" and "no exceptions" rule. It might seem restricting, but what he said is true, leaving the trail for the reader is a benefit that outweighs what you're giving up.
Videos: https://www.youtube.com/user/CppCon/videos Slides: https://github.com/CppCon/CppCon2014/tree/master/Presentations IIRC in time all of the talks are going to be released and I'm super excited.
I remain unsatisfied with his explanation for the banning of non-const references. To me, it's quite simple: use a pointer if null is legal; use a reference if null is illegal. Clear. Self-documenting. I don't buy the argument that it is beneficial to see that the parameter is being passed by address at the call site. By that logic, we should revert to Systems Hungarian Notation for naming all our variables (iCount, bEnable, etc.). Apparently, we can't be bothered to understand what something is or how it works before using it.
yes I understand that. I did not word the post correctly. 
thanks. looks useful 
&gt; That counted iterator type is bidirectional, and `advance` must increment it `n` times Maybe, maybe not. Have you tried running this into a sufficiently optimizing compiler? I would not be too surprised to see the optimizer look through all template layers and end up with something close to the manually optimized version.
&gt; The person who is using the API should certainly know how its used Yes, but requesting pointers is not providing them with the information and can even be misleading: auto p = give_me_apointer(); foo(p); // p is a pointer, but how can you tell? In fact, Titus agreed that some kind of compiler annotation would have been better than this rule.
I agree - I'd be all for it as well. I do think his view on annotation is more value than some here accept. I don't work at Google but I do work with a multi-million line code base. I also happen to be in a role where I spend a lot of time tracking down difficult bugs all over the place. There is huge value in having state changes line variable assignments be highly visible; there can simply be too many APIs to know. I'd love tool support here. I'd also it if my IDE had the merging/diffing capability of Araxis Merge built in as that is the other primary place people look at code without the support of an IDE. Incidentally, your example is why someone others in similar high level roles at my office have banned use of auto. They actually banned usage in in some of the C# code after seeing the longer term code readability and maintenance issues.
I definitely agree on the tool support front. I would be thrilled if my IDE color coded variables based on if they could be modified inside the function call. Or better, if there was standard annotation at the callsite for it. I'm not against documentation here but if, over the course of the day, I'm looking at several hundred to a thousand unfamiliar functions in a massive code base, being able to see what state is changes where without going to documentation a tremendous time saver - particularly if you are interested in where and why specific values change.
I was hoping multi-threading would be mentioned (at least more than a passing reference to thread sanitizer). The public style guide makes no mention, which seems odd considering the changes to the memory model.
You may be right. As another Redditor pointed out, the dynamic dispatch costs for data access after the function dispatch. Because of all this, I'm now changing my opinion: it's likely that a switch will win out in general usage instead. I think once you wind up with a "large" tagged union, the inheritance approach wins out since optimized switches (I think - don't quote me on this) are implemented using a hash of some kind. I'm guessing the tradeoff point is somewhere at or above a dozen types or so.
I always like(d) how Scott Meyers would often phrase his advice as "prefer to …" or "avoid …" instead of issuing a blanket proscription. While I can definitely see the point to have a demarkation between input and output parameters, I personally don't see why introducing something like the following wouldn't just solve the problem of "leaving a trail for the reader" (sorry to borrow terminology from Tcl) $ cat duff.cc template&lt;typename T&gt; struct Upvar { explicit Upvar(T&amp; t) : t_(t) { } T&amp; t_; }; template&lt;typename T&gt; Upvar&lt;T&gt; upvar(T&amp; t) { return Upvar&lt;T&gt;(t); } void f(Upvar&lt;int&gt; n) { n.t_++; } int main() { auto i = 13; #ifndef AVOID_COMPILE_ERROR f(i); #endif f(upvar(i)); } $ g++ --std=c++0x -o duff duff.cc duff.cc: In function ‘int main()’: duff.cc:22:8: error: could not convert ‘i’ from ‘int’ to ‘Upvar&lt;int&gt;’ f(i); ^ $ g++ --std=c++0x -o duff -DAVOID_COMPILE_ERROR duff.cc $ 
"To me, that seems like way more trouble than […]" Way more trouble how? "Making the coder put in the '&amp;' forces the coder to think about the possibility of side effects." How is forcing the coder to write "upvar" more trouble than forcing them to write "&amp;"? Or is it simply that one must type 4 more characters? &lt;shrug/&gt; Well, yes … you do have to introduce "upvar" but that cost is easily amortized. I do kind of wish that C++11 would have made the constructor for std::reference_wrapper be explicit, in which case one could just use that. Anyway, not like I bother to do this in my own code; I just avoid output parameters, too. But the kind of thinking which finds using something like an "upvar" to be "way more trouble" than ... void f(int* n) { (*n)++; } int main() { f(0); } … is perhaps a bit too concerned with syntactic niceness than compile time checks, I think.
If it works like shown, this is gonna be so good. Sadly, when I tried it didn't find the already installed JRE and I didn't get around troubleshooting it yet. Interestingly, this has its own parser and doesn't use Clang. And the parsing + hinting code is apparently rather strongly coupled with the internals.
I second this, only cause I know the guy who wrote it. ;-) Well, not only because of that.
I believe that 'someone' was Sean Parent: http://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning It might not be that instance of this presentation though. He brings up the code, but I've yet to see where he talks about google rejecting his change that simplified that massive thing into a few lines of readable code. He gave the same talk elsewhere and did talk about that occurring. I also found this video on google's justifications wanting. I guess it works for them, but I must seriously question anyone that would use google's style guide as any sort of general style guide for coding C++. Honestly I'm not sure why google would even publish it to the public. I guess it works to keep people who don't want to be mired in legacy code so bad that it requires the kind of restrictions that style guide has from applying to work there :P
It's kind of funny that he advocates tooling for formatting your code, but not promoting tooling that shows you the function declaration when you hover over the function call.
This is wrong: while(inputfile) { inputfile &gt;&gt; character; Your code should be doing: get a character and if we successfully get a character then &lt;---------+ output the character | repeat -----------------------------------------------------------+ Translated into C++ that looks like: while (intputfile &gt;&gt; character) { cout &lt;&lt; character; } Remember that you should pretty much always check user input for errors.
Unfortunately if you want to mix and match them, you'd end up needing to either do some void* casting nastiness or an additional vector of something that can address into an arbitrary one of those vectors. That code gets pretty ugly.
Second this. I have used libcurl in the past to do exactly this. It's just a few lines of code.
Difference engineers = different IDE, when using const ref vs pointer when one get's used to it the IDE doesn't matter. It's very explicit.
&gt; By that logic, we should revert to Systems Hungarian Notation for naming all our variables (iCount, bEnable, etc.). They do advocate an equivalent of systems hungarian for function "overloads", at http://google-styleguide.googlecode.com/svn/trunk/cppguide.html#Function_Overloading : "If you want to overload a function, consider qualifying the name with some information about the arguments, e.g., AppendString(), AppendInt() rather than just Append()." It's a wonder virtual functions aren't banned.
It was good to learn that the streams ban is going away and the reason two-stage copying via CopyFrom() is no longer a requirement as of last month or so (they apparently switched from grepping the source code to using an indexer). Still a lot of crazy nonsense found in the guide today wasn't mentioned, and the treatment of the two issues that were mentioned only reinforces the perception of being tailored for the people unfamiliar with the language.
Fair point. In that case you would have func(in1, in2, heap_out); or func(in1, in2, *heap_out); The latter still certainly isn't obvious to the reader that *heap_out can change. In this case, neither method serves the intended purpose. The reader is going to have to think a bit in this case no matter what. With the pointer method, they only have to look as far as the data type of heap_out, whereas with the reference method, they will still have to look at the function definition. I'll admit that the same clarity can be achieved with good variable naming and common sense, but when you have so many devs working on the same codebase, you can't always count on that.
I'm not convinced of Titus's arguments.... Passing a pointer to a function leaves no trace too: struct foo* f = (struct foo*)malloc( size of( struct foo ) ); ... i_modify_foos( f ); // no trace Really, code should be using value semantics anyway. WRT exceptions, his advice is antiquated at best. RAII and exceptions go together like peanut butter and jelly.... God knows it's possible to use exceptions incorrectly but I know for a fact it's possible to use them well too. What I really learned from this video is that Google has a LOT of old code that they don't want to change... And it may actually be the right call for them... But please don't try to force this nonsense on shiny new codebases... 
Without the --std=c++0x $ g++ -o duff duff.cc duff.cc: In function ‘int main()’: duff.cc:15:8: error: invalid initialization of non-const reference of type ‘int&amp;’ from an rvalue of type ‘int’ f(0); ^ duff.cc:2:6: error: in passing argument 1 of ‘void f(int&amp;)’ void f(int&amp; n) ^ $ g++ -DRUNTIME_ERROR -o duff duff.cc $ 
He seems like such a pleasant fellow. 
Anyone here worked with Cinder (or openFrameworks)?
See the micro-benchmark I wrote in http://llvm.org/bugs/show_bug.cgi?id=21201. On my machine, the performance is highly variable &amp; which implementation wins depends on the compiler flags &amp; iteration order more than whether or not it's allocated on the heap or not. I switched from virtual dispatch to boost::variant in exactly 1 spot in the code (to eek out a small performance win), but I bench-marked it first. Of course, with these results I want to go double-check because my app doesn't have LTO on.
Thanks for the tip on the /r/dailyprogrammer subreddit! Sucks that I can't find a list of all the subreddits available anywhere.. and always stumbling through posts like this to find the gems on here :) Appreciate the heads up on the C+11.. I will go back a little bit in the versions.. would you recommend C++98 or C++03? I agree, perhaps this project will set me on an interesting path of moonlighting on the side. From what I have heard so far, they have thousands of these machines out there in all of the Americas combined.
update - 10/8/2014 - Thanks to everyone posting some really great advice! I loaded up the old source code from the CD into VC++ 6.0 and did a straight compile, executed it on the workstation and it worked! so looks like the source code is good to go for modifications. 
&gt; I believe that 'someone' was Sean Parent: http://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning &gt; It might not be that instance of this presentation though. He brings up the code, but I've yet to see where he talks about google rejecting his change that simplified that massive thing into a few lines of readable code. He gave the same talk elsewhere and did talk about that occurring. It was an invited talk at A9, [Programming Conversations Lecture 5 part 1](https://www.youtube.com/watch?v=IzNtM038JuI). The comment about the Google manager's response to Sean's code review was: "nodobody knows what `std::rotate` does", and it is somewhere between 28:30 and 30:30.
I had the opposite impression of [this guy](https://www.youtube.com/watch?v=NOCElcMcFik).
I have started looking for a job as a C++ developer for 2 months now. I have exclusive C++ programming experience of about 8 years. I know a little bit of Python but C++ programming is my bread and butter. My experience so far has not been very encouraging in the job search. In UK the C++ job market is divided in Embedded C+ and C++ in finance and trading industry. I am not an excellent programmer but not bad either. The finance people won't take me because they need super intelligent programmers and there are few openings in Embedded. The point is if you are average or above average C++ programmer it is difficult to find a job. I believe if you are C# or Java programmer there is a bigger set of jobs. Also, new technologies like Big Data/Hybris/Salesforce are all related to Java or C# and C++ lags behind by miles here. 
&gt; will compute the result at compile-time (C++11 compilers only). Really, is that guaranteed anywhere? At least with 4.8 I've seen gcc only do things at compile time where it really had to, say to produce a template param or enum value, otherwise it still did the calculation at runtime. 
&gt; Really, is that guaranteed anywhere? It is guaranteed only when it is used in a constant expressions * When you assign the result of the function to a constexpr variable * When you use the result of the function in a static_assert * To set a non-type template argument * Probably other cases If you assign it to a variable non-constexpr, even if all the parameters are constant, you have no guarantee. Compilers tend to compute it a compile-time, but they have no obligation to do so. 
Yep. That be it. Thanks.
Note that you can force compile-time evaluation trivially as long as you are dealing with integral values: template &lt;typename Int, Int Value&gt; constexpr Int force() { return Value; } int value = force&lt;int, is_prime_func(11)&gt;();
Hi Herb (:
Speak for yourself. For me it is quite the opposite.
I certainly found the demos Andrew Bell gave during his talk inspiring. Is it easy to learn to use well? The demos looked pretty straightforward. I've played around with the samples a bit, but I seem to have a long way to go yet.
I suppose it depends on your background. I was a flash dev for 10 years so originally i was using cinder as a way to learn c++, already having a solid understanding of the principles of developing large interactive applications, whereas others might know c++ really well, but not be familiar with the fundamentals of graphics programming. What I can say is that it lowers the barrier of entry to both for a beginner, but doesn't get in the way of an expert either.
That's the point. Longer compile-time to gain run-time performances.
I don't buy the explanation either. When we receive a pointer (that could/should have been a reference), that means we need to know whether 0/nullptr is a valid argument. There are are two choices: * The *Design By Contract* choice, we assert the pointer shall not be null (the same kind of guarantee we have with references, but not at compilation-time) * The *Defensive Programming* choice, we test at the start of the function whether the pointer is null. In that case, two options, we hide the error by doing nothing (which is a terrible choice!), or we have the error go up (with no exception, as they are also banned here) till when we can do something with it. Now, let's put the maintainer/reader hat. In the first case, we still need to be sure the first assertion encountered is always valid. I do trust more codes where I receive a reference than codes where a pointer is used -- because I need to go into the code/preconditions documentation of the function called to see whether something that may be null is valid. =&gt; I loose time investigating the context where a function is called with a pointer. Moreover, I do take time to check whether the pointer in the function interface should have been an unique_ptr/auto_ptr. In the second case, the code becomes much more complex. Indeed because of the no-exception policy, the nominal code is already jammed with non nominal code. If we add a *Defensive Programming* (/*we don't know what we are doing*) policy, the non-nominal code is jammed, again, with code related to the management of programming errors. When I need to read such code, I really do waste time trying to follow all paths. Beside, with a aggressive use of const, there is no doubt when a function modifies or not its argument. const std::string v = "bar"; foo(v); The thing is, we need to make people use and abuse const in order to achieve a similar result : a variable declared without const becomes a code smell. And function calls on non const arguments means the arguments may be modified. They have been taught to never have functions that receive non const parameters, why can't they been taught to (almost) never declare non-const variables?
This is true. It works brilliantly in languages that have module support, like D; you have to do some pretty insane stuff to slow it down. In C++, you would be correct: changing a header where heavy compile-time coding is present is disastrous for compile times. One might be better served by knocking out another C++ program to write an .h file instead.
your right it throws a bad_any_cast. and if it is not found an empty any object is returned. (similar to null)
How can someone believe this article? No source? No proofs? Nonsense!
I also wrote a [microbenchmark](https://gist.github.com/twoodfin/56e3cf8e5bc218bed60d) to test this out. Essentially, it repeatedly randomly selects between two objects to call a member function that returns a value. The pair of objects are either instances of a parent/child inheritance hierarchy or a tagged union. Discounting the 35% of the benchmark runtime that's consumed by the random number generation, the tagged union form is about 67% faster compiled with clang on -O3. As I suspected, the big hit is the inability of clang to de-virtualize and inline through the virtual function call. There are no function calls in the tagged union version: Both sides of the conditional are fully inlined. The inability to inline is the real performance killer when using virtual calls. Everything else is typically noise.
That's because the whole thing is an advert for their static code analysis tool.
We actually use this convention, although without knowing that google advocated nor that some people really don't like it. In your example, there is actually a trace: the type of f. This type *is* present at the call-site. The point isn't that the trace is *exactly* at the call-site. It is most of the time, but even when it isn't, it's available *near* the call-site. If I have a review, I usually have call-site + some surrounding code. I can then easily tell what it is that i_modify_foos accepts a pointer (&amp; then I can also tell if it's const or not: non-const pointer almost certainly means non-null, const* requires more investigation). Another hint to me would be that the function name indicates modification of the argument. So it's about the amount of important information that can be gleaned at the call-site.
Except that there's still some information local to the call site: usually you know if the variable is a pointer or not. In the non-const-&amp; example, there is *no* local information that can tell you the object is being modified.
And on my machine with my clang, using your sample code, virtual dispatch is maybe 2% slower. With -flto, virtual is 0.5% faster. I stand by my statement: this is a meaningless micro-benchmark. Start with inheritance. If you have a strong profile-driven reason to switch, then do it (also get before &amp; after numbers to show the difference). Also note that your implementation only works for POD: if you want anything moderately complex and maintainable, use boost::variant. It's not a great micro-benchmark since the generation of the random numbers is going to pollute your measurement more than anything else.
Wow that looks really cool. Are you the author?
This article is from 2011, before C++14 `constexpr`. In C++14 the original code: static bool IsPrime(size_t number) { if (number &lt;= 1) return false; for (size_t i = 2; i*i &lt;= number; ++i) if (number % i == 0) return false; return true; } would be converted to a `constexpr` function by changing it to this: constexpr bool IsPrime(size_t number) { if (number &lt;= 1) return false; for (size_t i = 2; i*i &lt;= number; ++i) if (number % i == 0) return false; return true; }
Another key difference is that you omit the need for a vtable pointer, which can take up some considerable space in the cache. Without it you may be able to store more information in the cache and thus be faster again. This doesn't strictly need the union though, you can do it in other ways.
"little more than a glob of goto's and if/thens with cryptic variable declarations" Damn. I was hoping for magic. :(
Haha, just a few days ago, I had a huge discussion with the other guy [about using a pointer type in lieu of a non-const reference](http://www.reddit.com/r/programming/comments/2i1cw0/stubbing_dependencies_in_c_what_not_to_do_and_a/cky5rxv) for "output" parameters and acted like a total cunt (would do it again though, so I am glad to see that CPP reddit agrees with me :-)).
I do separate C and C++ on my CV, but do you remember "The C Users Journal", which eventually became "The C/C++ Users Journal" magazine?
You'll need to keep in mind the historical context for that magazine too, because I think they changed their name around the 90's, roughly after the C++ 2.0 standard. In those days, it was much more common to be a "C developer turned C++", and the differences between C and C++ weren't nearly as pronounced. Today, there is more than 40 years of C++ history, and C and C++ have deviated an awful lot.
When you see `C / C++` its almost always `C ∩ C++` that is meant. Its just that nobody really knows how to input all those bloody utf symbols ...
Yes, that is kind of true. They changed their around 1996 I think. 
Cool. Any particular reason you didn't use boost::any &amp; wrote (copied?) your own?
yeah i would have liked using boost::any but it did not offer callables. my extended version lets you use the call operator() to invoke the any if it is a function. replacing it with boost any and forfeiting the call operation would be an easy exercise however. edit: and yes I copied it from boost, I had written a version myself but is was much worse ;). 
Couldn't you just write a wrapper for boost::any &amp; add a manual operator() wrapper that checks if the underlying type is callable? You may also want to be careful with copying code. Boost uses the boost license, but your code says MIT. I don't know if Boost let's you change the license like that. I'm not a lawyer, so I'm not sure if what you did constitutes a change of license.... YMMV.
ida pro and the hex-rays decompiler are two separate things. IDA is worth its price 
That's cool, but it's probably not gonna change the world of binary inspection. For instance, the `_start` symbol in the example is completely illegible: func_4003f0(main, v1, (int64_t)"intrinsic"() + 8, __libc_csu_init, __libc_csu_fini, rdx2); Compare with this random binary's `_start` symbol that I just grabbed: .text:0x08048890 31ed xor ebp,ebp .text:0x08048892 5e pop esi .text:0x08048893 89e1 mov ecx,esp .text:0x08048895 83e4f0 and esp,0xfffffff0 .text:0x08048898 50 push eax .text:0x08048899 54 push esp .text:0x0804889a 52 push edx .text:0x0804889b 68c0960408 push 0x80496c0 .text:0x080488a0 6860960408 push 0x8049660 .text:0x080488a5 51 push ecx .text:0x080488a6 56 push esi .text:0x080488a7 6849950408 push 0x8049549 .text:0x080488ac e8fffeffff call func_080487b0 .text:0x080488b1 f4 hlt It's obviously more verbose, but I'm pretty sure that I'd figure it out faster than `(int64_t)"intrinsic"() + 8`.
&gt; IMHO, neither has output that alone could justify the price of an IDA Pro license, The decompiled C alone wasn't worth the price of IDA Pro IMHO. Someone only looking for an easy way to get C source from binaries would be disappointed.
quite possibly your right with the wrapper. I also chose to do it this way because I wanted to use my own type system instead of typeid() an which any relies. (I extracted the code from another lib i'm working on) as for the licensing issue: I did everything the boost license 1.0 expects of me (included the license in the project)afaik It is not forbidden to relicense boost as long as you indicate that you used the boost code and included the license.
Which -O flag did you use? And why should LTO matter? This is all in a single module. I agree that virtual dispatch is nothing to worry about until you benchmark and find it's a problem. But many folks are under the mistaken impression that the major cost of virtual dispatch is the the vtable lookup and indirect call. With modern C++ compilers, the inability to inline hurts much, much more.
It can be optional. Both can exist in your library. 
Don't try to apply sanity to chaos. VC++ 6.0 is... VC++ 6.0 -- not C++98 or C++03... or anything else. It really is its own thing... keep things really basic, things you know absolutely will work. 
How can I help? I'd be happy to get others to help too.
O2 &amp; O3 - no difference. I know LTO shouldn't matter here (especially when it's improving the static dispatch case). It's why I filed a bug.
Seeing the error list it seems a miracle how the f**k GCC manages to compile something. Is the situation as bad or it is just my wrong impression?
Anyone using this stuff yet? It looks very useful.
Your impression is wrong. Most (all?) of these are feature requests.
gcc is a very large program. Any large program will have a bug tracker with tens of thousands of issues. That's just the norm for large and complicated projects. There are always corner cases. Take Firefox — it has on the order of [100K open bugs](http://blog.gerv.net/2014/04/bugzilla-mozilla-org-stats-at-1000000/). Compared to Firefox, gcc is doing very well; gcc's bugzilla bug ID field is currently in the mid sixty thousand range, whereas Firefox crossed the million bug ID mark earlier this year. 
Seems like the IDE uses SCons instead of CMake. That's sad, all other features look promising, but without CMake support one may stick to QtCreator. I also remember that Eclipse was terribly slow (and memory hungry) some time ago.
GCC is such an old compiler that it suffers from a lot of cruft and legacy code stuff which makes it hard to develop things quickly and well. Not saying gcc is bad, it's actually better than MSVC according to my experience, but it has its problems just like any piece of software, even more so when its a tool like a compiler.
clang is extremely buggy ans teams are not that reactive from my experience, probably engulfed in tickets.
Which error are you talking about, I mostly see missing warning and diagnostics related bugs, nothing serious. Did you notice something else?
You could look into boost's type erasure library. It provides the capacity to have an any that has any number of public functions. I'm sure () is included.
How are you integrating the software into your product? Building it yourself or using precompiled binaries?
&gt; For C++ questions, answers, help and advice see r/cpp_questions or StackOverflow.
Building myself. The parts I've used are standalone so are easy to build separately.
But don't you think the llvm project (people) is(are) more reactive compared to gcc? Just for proper pinpoint error messages (especially when template meta-programming is involved) I would use LLVM/clang. Then again you might ask, "why do you have errors when compiling template code??".
I'm starting a new blog that's at a more accessible level. The focus in it will be to teach techniques that make writing maintainable C++ easier. This article is just the first step: teaching the very least you need to know to do unit testing in C++ with Boost.Test. This blog is going to be pretty beginner oriented. Crazy C++ is for the weird shit people who like to play with TMP and such can read, this one is for guys who just want to start working professionally in C++ can read to get going.
To do it right at the point of read would require that you implement your own string type that is limited to 20 characters and has its own input stream operator. That's a step above what you might be able to do right now. Your better bet might be to just complain after the fact if you've read too long of a name. I actually think this is the right approach here. Reading input should usually be greedy, especially with a text stream like cin. What would you do if the name is too long for example? Would you put the stream in an erroneous state? You almost certainly would need to, but then that might cause additional problems. 
I would recommend posting this to /r/cpp_questions ~ there are a lot of students there who wont get it but the developers will.
Don't copy-paste this for your homework assignment - *understand* what it's doing: C:\Temp\gcc&gt;type meow.cpp #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { string s; getline(cin, s); cout &lt;&lt; "You said: [" &lt;&lt; s &lt;&lt; "]" &lt;&lt; endl; if (s.size() &lt; 21) { cout &lt;&lt; "That was 20 or fewer characters, good." &lt;&lt; endl; } else { cout &lt;&lt; "That was 21 or more characters, oh no!" &lt;&lt; endl; } } C:\Temp\gcc&gt;g++ -Wall -Wextra meow.cpp -o meow.exe C:\Temp\gcc&gt;meow Brandon Sanderson You said: [Brandon Sanderson] That was 20 or fewer characters, good. C:\Temp\gcc&gt;meow John Ronald Reuel Tolkien You said: [John Ronald Reuel Tolkien] That was 21 or more characters, oh no! C:\Temp\gcc&gt;meow 12345678901234567890 You said: [12345678901234567890] That was 20 or fewer characters, good. C:\Temp\gcc&gt;meow 123456789012345678901 You said: [123456789012345678901] That was 21 or more characters, oh no!
I'm not sure how to explain all the ill will GCC has built up, but each of these posts I've seen has had a surprising amount of dissatisfaction shown towards the project. Maybe they should look into what is causing that. I gave up on GDB years ago, but GCC has always seemed functional and reliable, if not sexy. 
I prefer Clang, but GCC gives fine error messages, even when templates are involved. It's been a long time since the days of multi-thousand-line error messages caused by doing something like trying to make a `std::map&lt;int&gt;`. 
Hi, Alex! You wrote `It needs to have easy project navigation, which includes switching between files`. I found more easy way to do this. Clion already has "Go to Related Symbol" command that do right this thing - switches between *.h and *.cpp files. In windows it is Ctrl+Alt+Home, on Mac OS X it is Ctrl+Cmd+Up. You can find this page useful: http://blog.jetbrains.com/clion/2014/09/clion-answers-frequently-asked-questions/
heres wat is asking : this function prompts for and accepts a character as well as a string up to 20 characters in length. If the input is unacceptable for any reason, this function clears the stream and asks for input once more. The user must enter valid input or enter "0" as a name to quit.
How does one give up on GDB? I dislike the program, but what other alternative is there that works?
I tend to debug manually using printf as much as possible or if it builds and exhibits the bug on windows, using visual studio. Often I have no alternative but GDB, but I've given up on it ever being a tool I choose to use.
Just out of curiosity, why ? 
&gt; But don't you think the llvm project (people) is(are) more reactive compared to gcc? I only have experience with GCC, but IME they are extremely active and easy to work with, even when I just reported a stupid bug without a patch. especially considering the amount of traffic they have to deal with: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=59707
&gt; But don't you think the llvm project (people) is(are) more reactive compared to gcc? I've seen no evidence of that.
I'd really like to hear about dependency injection and stubbing out stuff in cpp. [I had asked a question recently but didn't get much of an answer on unittesting and RAII](http://www.reddit.com/r/cpp_questions/comments/2iclu8/unit_testing_and_dependency_injection_using/) If you have an answer I'd really like to hear it.
You sort of answered your own question there. That's more or less how you do it: pass in an object created via new (or make_xxx now). Using unique_ptr is quite appropriate much of the time. You can sometimes do DI via template parameters... I guess I'm not sure what the issue is. I find the comments you received there a bit confusing as well. I'll put DI on the list of things to write about though. Good topic. Right now working on one about primitive obsession.
If you are skimming, make sure to read section IV. This is about removing them from the standard only. Implementations will still have to carry these features in their standard library for quite some time for backwards compatibility, and that's expected. Removing them from the standard just means that it shifts the burden of deciding when a sufficient amount of time has elapsed from the standards group onto each implementation, which is free to decide on its own.
lldb, or VS debugger if you're on windows.
Removing of deprecated features will very often destroy the possibility to develop platform independent code. For example: We have a module with common functions which are used on embedded systems and also for simulation purposes on desktop systems. On top of it we are using modern c++ features on the desktop. Because for embedded platforms a lot of compilers are even not on 100% C++ 98 standard its common to use only the smallest subset of available features which we have done for our platform independent module. For some of the issues deprecation will bring up wrapper might be possible, but for some not (unary_function/binary_function, ptr_fun(), and mem_fun()/mem_fun_ref().).
Perhaps I missed it, but wouldn't it be nice to tell the reader, which unit testing framework you are gonna use, **before** you state: &gt; "Next you need to tell cmake how to find Boost.Test." ;-) After all there are many frameworks out there, so there should be some information about your choice.
On the other hand, one could argue that it's time for those compiler vendors to catch up and provide better support for modern language features. Providing legacy support is important. However, being completely fixated on the practice and even actively discouraging new adoption (which sadly happens in some dev houses) is just plain detrimental. 
Cool, thanks for the info.
First thing removed from standard was (i think) [`export`](http://en.cppreference.com/w/cpp/keyword/export) keyword. And there is also [N3981](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3981.html): **Removing trigraphs??!**
I'm sure that you meant function definitions. I've seen that practice before. C and C++ demand semicolons in certain places. And it ignores semicolons in other places. When you are first learning C++, you may discover that instead of learning what the semicolons mean you can apply them liberally and the compiler won't correct you. 
Surely, standard committee has better things to do than rendering perfectly fine code non-conformant. This also will make it awkward in future, when some names are sort-of kind-of taken, but not written anywhere in the specification ... &gt;Removing this stuff from the Standard will reduce the editors and LWG's burdens - slightly, but nonzero. I believe in owning my (even if 'my' is somewhat 'fuzzy') fuckups. I hope that std committee does as well (especially when perceived gain isn't even large here). &gt;More significantly, it sends a very clear message to authors, teachers, and the C++ community that this stuff shouldn't be used anymore. Send the message though standardized 'deprecated' attribute that requires a 'diagnostic'.
&gt;I'm sure that you meant function definitions. I've seen that practice before. Yes, my bad. I'm quite tired at the moment. &gt;And it ignores semicolons in other places. Yes I know, but it's unnecessary.
He is proposing that they remove already deprecated features from the standard. That won't magically make these features go away, but it will send a very, VERY, strong message (stronger than deprecation) that you need to get your code in order if you want it to compile in the future. Removing from the standard won't remove from compilers. Rather, it give the compiler writers an opportunity to chose when to remove the code and how to do it. He mentions that clang even has some tools to auto convert some of these things to a more modern syntax.
&gt; N3981 And it was accepted in C++14. Thank you.
Yup. It is almost crazy to think that someone would want C++ to keep every feature forever. One of the biggest faults and criticisms of C++ is that it has too many features and too much cruft. I think it is ultimately healthy for the language to start removing crufty features. 
&gt; This also will make it awkward in future, when some names are sort-of kind-of taken, but not written anywhere in the specification ... I suppose I could say that the names `std::auto_ptr`, etc. are reserved like `export` is reserved, but we didn't do that for `gets`.
I wrote this after using hex-rays decompiler http://sourceforge.net/p/winlirc/code/HEAD/tree/trunk/DLL/Streamzap/StreamzapAPI.cpp Since the company wouldn't release the source code to their dll for me. It had bugs in it that I wanted to fix, in the end I just talked to the hardware directly.
Is the intention to install libraries in standard locations and leave them there, or to compile them locally and statically link them into executables?
&gt; If your library has types with bogus values, I will hate you. What did the author mean by this exactly? *edit: thanks for the responses*
You are right! Unfortunately we want to sell our library and have nearly no influence on our customers compilers choice. I would be more then happy to always use the newest standards, which we do for other projects.
Probably magic values to indicate undefined state, e.g. // why not throw in a macro #define UNDEFINED -9999 struct MyInt { MyInt(int value = UNDEFINED) : _value(value) {} private: int _value; }; But definitely too much hate on the author's part where disgust would be just fine. 
As /u/dkixk points out that is valid c++98. You really have to juggle words with compiler error to get a c++11 rvalue reference (int&amp;&amp;) from it and ignore the explicit mention of the type (int&amp;). 
If the author of this post writes in an obnoxious and unprofessional style, I will hate him.
Actually, no, it does not impact platform independent code. If you wish your program to work with compilers that only support C++98 (wait, not even C++03?), then you tell your compiler to compile according to C++98 rules. In essence, each new version of the Standard is a *different language*, and most compilers therefore support *multiple languages* and let you pick the one you favor.
&gt; When you are first learning C++ Certainly, but I do not expect beginners to pose as language experts either :/ 
It's not clear from the documentation where/how fatso satisfies dependencies. Does it work exclusively with github, or can it the fatso.yml file be configured to use any http/ftp/path/repo to find what it needs?
As the author of cppman. I would say the rendering quality is much better than that of 'stdman'. Since stdman is actually just an snapshot of the elinks text browser. That is why the manpage by stdman does not resize with the terminal size, while cppman does. You can still use the system man command after executing 'cppman -m true'.
&gt;If functions in your library return error codes instead of throwing exceptions, I will hate you. So brave!
&gt; If the classes in your library have such clear responsibilities that you call them "managers", I will hate you. I'm not sure why having clear responsibilities would be problematic. Am I missing something?
I bet this guy started using ICU recently...
it's sarcasm. If the classes had clear responsabilities, they wouldn't be called "managers".
&gt; It would seem that only one operation was skipped. What is the point in removing it? But what if program have thousands and thousands of classes derived from one abstract class, removing one automatically generated command can significantly affect program performance. Moreover, it will. Do you believe me? Nope. I don't believe without benchmarks.
Hey STL, out of curiosity, do you know why there is even such an annotation? Is there a reason the compiler can't automatically apply this optimization when it's safe (e.g. when there's a pure virtual function in the class)? Is there any case where the compiler couldn't be able to figure it out &amp; it would actually help?
Hmm...I did justify the choice and mention a few others but it was part of the introduction that had gotten too verbose. So I tried to cut it down and gutted that part along with a bunch more. Guess I forgot to add it back. I'll go ahead and make that edit. Thanks.
That sounds... Awful.
Probably something having to do with the reason you're collecting Bs.
fantastic job, man. thanks!
C'mon, how can you entirely avoid collecting something in a program?! That's what vector, map, set, etc are for!
Or perhaps they mean value types that are not fully initialized by the constructor. So like you perhaps have to do something like so: Value val; // Don't use val yet, it's not ready and will do something stupid! val.initialize(blah,blah); // OK, now you can use val.
&gt; C'mon, how can you entirely avoid collecting something in a program?! 0_o "Houston, we have liftoff!"
The word "manager" appeared [769 times](https://github.com/torvalds/linux/search?utf8=%E2%9C%93&amp;q=manager&amp;type=Code) in linux kernel. Although some of them are in the comments, others are used in the names of structs
Don't understand what you are trying to say. Are you suggesting a way to avoid using private containers in any classes, laughing at my English, or something else?
I think he was pointing out that standard collections can be used for "collecting" objects and the specific logic should sit in a class named better. One example that comes to mind is Roslyn (the new C# compiler) having a "Compilation" class that describes a compiler invocation and its result. Contrast this to having a "BuildManager", a "ProjectManager", "FileManager"s, "FlagManager"s and so on. Check out http://objology.blogspot.com/2011/09/one-of-best-bits-of-programming-advice.html for a discussion on OPs original point. On the other hand, I've found myself tending to separate state from behavior, which goes against that advice -- and against OOP in general. Not sure whether it's because of being exposed to functional programming or I'm just a bad programmer :).
I'm laughing at you going from a suggestion about a better name for your "monitor" to, "How the fuck do you not use containers?" Was about the most random response I could think of. And I'm not so much laughing as going WTF and backing away slowly.
Concerning 6: That is of course, unless the library represents something truly hierarchical and doesn't provide anything besides that. (Probably never the case in reality.) Concerning 7, I'd like to disagree in that general form: meyers-singleton is a better alternative to global variables, which are sometimes, though very rarely, the best solution to a problem. (Though there usually isn't much reason to only allow the creation of these objects to the singleton.) Concerning 11: Personally, for my code, I agree. It is however an oversimplification to believe that this works everywhere. However most of the time, yes, not using exceptions is a bad thing. Aside from that: Pretty accurate.
On the other hand that is one of the reasons why the corporate world likes it so much.
&gt; whoever purchases the source should be responsible for getting it to work with their broke compiler. Presumably they just wouldn't buy it. Which is why he supports old compilers. &gt; Seriously, after it is built, so long as the method signatures are the same it really doesn't matter what tech you are using Headers, man. But C++ abis are very inconsistent, so probably the source is distributed.
Sorry. I misunderstood your first response.
Yeah, exceptional things. Like errors.
[expected](http://www.hyc.io/boost/expected-proposal.pdf) looks good for asynchronous and threading code and other places where the initiating function isn't the same that will receive the operation's result.
I tend to think that error codes are things that you would expect to happen and can recover from. Exceptions are for when everything has gone horribly wrong oh god its fucked
No, no - exceptions are for recoverable problems, that's why you can catch them (here's where Rust went a horrible way). For problems that make you react "oh god it's fucked" you call `std::terminate()` and just exit the shit out of the application.
BRepository if it just has a collection of B objects.
Instead of just being a dick about it, the author could offer alternatives for each scenario for those of us new or not as smart as this person
This is really cool. Thanks!
No. Don't call std::terminate(). If I'm using your library and your library goes haywire, I will decide what to do about it depending on what my application does/needs to do.
I really think it depends on the context. You have to ask yourself, am I in an exception-safe context in my code, or not.
I really think it depends on the context. You have to ask yourself, am I in an exception-safe context in my code, or not.
What annotation? It's a property, like being a plant or an animal. Some classes are trivially copyable and some aren't. In any event, classes with virtuals shouldn't be copyable at all.
"Exceptional" is in the eye of the beholder, which renders your first statement too vague to be useful for anything. Say that I have a file class. If I use it to read some mandatory configuration, that file class should better throw, because I would rather not check for any return codes (or god forbid, fail to check them) and then run uninitialized. If, however, that file contains some options, I would rather use conditional logic in lieu of a more verbose exception handling. These are the opposing forces that can't be reconciled "once and for all", and indeed, there's examples of APIs providing both forms *exactly because* [having only one form makes it too painful in some contexts](http://blogs.msdn.com/b/ianhu/archive/2005/12/19/505702.aspx).
If you are a library, and you do that, I will hate you 😉. The problem with your idea is, as usual, "define tucked (edit: fucked, wtf autocorrect?). What's fucked to you might not be to me. I also might not want to die on the spot *even if I agreed* that it's fucked, but would rather clean something up first.