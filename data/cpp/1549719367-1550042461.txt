Me personally, I find most users like to save long before the undo history length becomes a problem. When you save, a coherent file must be written out. That's the perfect time to cohere and "defrag" the spans as you write the save file, as you'll mostly wait on i/o in any case, so your CPU might as well do something useful as it parses the whole file start to end. Something I haven't covered is what to do about files with very long paragraphs. Most text editors, even ones happy editing 200Gb text files like EmEditor, get upset with multi-Mb long lines. Scrolling gets slow, for example. I would assume that if you don't word wrap, that could work quickly, but I haven't personally ever implemented such a thing. 
Unfortunately this is not true. If you have a look at the Student FAQ on the JetBrains page, it states: &gt; Licenses for students and faculty staff members are valid only for one year. Perpetual fallback licenses are not provided. It is true for regular subscription licences though.
That was the reason I started my research if this is possible to avoid :) 
CMake is the best. It's not perfect but it's the best. Also, it evolves rapidly and fixes the stuff we, users, complain about. Except its DSL, this we have to deal with. I wrote [a piece](https://medium.com/@julienjorge/an-overview-of-build-systems-mostly-for-c-projects-ac9931494444) a few months ago to talk about build systems I've encountered. Premake is to much of a WIP to be useful. Use CMake if you want something that works. Use it with the Ninja back-end if you want a fast compilation.
For something that would take like 5 minutes to read in text form: Yes an hour is a long time.
Oh, thanks for pointing that out
The language feature is just called "concepts" - not "template concepts"
This is fantastic. Having a fast divisibility test for odd values is something I was looking for.
I'm explaining how it's implemented so you should be able to write yourself. That's something which can't be done in 5 minutes.
These days I'm mainly experimenting with \`build2\` (https://build2.org), with plans for using it in new c++ projects.
What’s the code theme? I love the color scheme of the syntax highlighting.
Is there always an EAP available though? My 2019.1 version says it expires March 2019 
Link for build2 binary packages (for quick start) available on [Install](https://build2.org/install.xhtml) page (section "Other Installation Methods") at the bottom.
From my experience, saving a file won't clear the undo history in most editors, which means that either the old spans need to be copied somewhere, or the old file cannot be simply dropped. Would it be necessary to preserve all past versions of the file (plus appended data), in the most extreme case? As for long paragraphs, they're really hard to handle. Many mainstream editors (like sublime and intellij) tend to prefer enabling word wrapping in such cases so rendering won't be too slow. Long lines, combined with wrapping, code folding, and (not yet implemented) ligature support, gets really messy. Something else I discovered is that in my implementation, decoding takes longer than reading the file. Though this is probably because my implementation of the decoder is too slow (one virtual function call for each character, with additional handling of invalid bytes). Something I'm really proud of is that this architecture, inefficient as it is, is very versatile. You can see the handling of invalid bytes in the screenshot - and you can delete those invalid bytes and then undo it. And if two invalid bytes becomes adjacent and accidentally merges into a valid codepoint, it'll be handled correctly. Technically you can also edit one file both as binary and as text, side-by-side, and the changes will be instantly reflected on the other side. I'm still working on the binary editor, though, and this project is starting to seem too ambitious for me.
&gt; that in the second case there is a hidden pointer in the internal memory object layout with cost of 4 bytes + 4 bytes of some padding which is added. Are you sure it isn't just a regular pointer with a size of 8?
The compiler might be able to produce the same fast code if the modulo expression uses only constants that are known at compile time. But Lemire's implementation (and libdivide) also produce the fastest code for modulo expressions involving variables that are only known at runtime and this is what compilers don't do today as far as I know. It is possible to implement this optimization in any compiler but there will always be cases where the compiler cannot possible understand that it could use this optimization e.g. when you have an array of different divisors that you frequently iterate over to compute divisions. For this use case you have to use a library like lemire's fastmod (or lidivide) to get the best performance.
Oh, forgot about the expiration thing...
&gt; But the client code STILL would have to know what the node type is, one way or another, in order to call the right extraction method. And it would STILL need to know if it's a container or a value in many cases. When the client needs to know the concrete type, that's exactly a sign that variants are a better fit than inheritance; the whole point of polymorphic inheritance is hiding the derived type. &gt; The reason being that it's easy for the compiler to tell you if you failed to add new functionality. It's not at all easy for the compiler to tell you if you correctly checked the this or that type everywhere to deal with the new type. It actually *is* that easy. The way you primarily work with variant in C++ is via visitors. This will fail to compile if you don't handle all types. Have you actually tried to use variant, or std::visit? If this is *the* reason that you are insisting on inheritance, then I'm telling you that this reason is just objectively wrong. &gt; Mr. Lippert is obviously free to have is opinions. But I've been around as long as him, and probably have written as much or more code. So I feel like mine is pretty well founded in practical reality also. Years of experience is obviously not the only metric here... The guy's clearly a bona fide expert in OO having been a designer of one of the most popular and well regarded OO languages in the world. Your reaction here is a bit absurd. Years of experience can also actively work against someone, like when they refuse to learn something new. You came here and asked for a code review, you have multiple people with experience and a very good understanding of C++ giving you answers that have many similarities, yet you just argue. Why not keep an open mind and try to learn something? Otherwise what was the point asking?
The ranges stuff was actually compile times more than either final code size or performance (at least, optimizations on code size/performance).
This is interesting because I interpret it mean that the underlying problem is just the interface of the platform specific build tools, not the build system in itself. In other words, if there were simply a program that would only translate gcc compatible flags into platform specific build tool flags, we could still rely on the simplicity and familiarity of makefiles without having to introduce a higher layer of abstraction.
I've seen it [mentioned before](https://www.reddit.com/r/cpp/comments/7a1o7f/why_does_stdinitializer_list_prevents_using/) that there are proposals to "fix" this.
Didn't downvote, and I love KDE, but I don't think this is strictly C++ relevant.
Alternating background colors of every line is one of those subtle touches that greatly improves readability.
Thank you for clarifying. I was conflating that with recent topics I was looking at regarding `std::visit`.
Should I be learning how to use build systems?
It declares a lambda with no captures, no params, and no body to execute, and then calls it. [https://en.cppreference.com/w/cpp/language/lambda](https://en.cppreference.com/w/cpp/language/lambda) `[]` means no capture `()` means no parameters `{}` is the body of the lambda, no statements `()` calls the lambda itself
I use crayon Wordpress plugin with source code pro theme. glad you like it :)
If I read this right, you are defining a lambda that captures nothing from the parent scope, has no parameters, and does nothing, then you are calling it. 
What did you use to generate this? I've been looking for a good LP compiler that generates nice HTML documentation.
Do you know if this is possible in CLion or QT Creator or Visual Studio Code?
How does this library compared to rust ‘s for?
No idea, sorry. A quick google search shows that it's possible in VS, so hopefully MS has implemented something like it in VSCode.
It's something we've been working and have just put out a (sort of working) snap for. You should be able to install on most Linux systems using something like \`snap install webify --edge --devmode\` and then run \`webify.bundle\` passing it a source folder and a destination folder to use for the web site. It'll produce a output that can be used with docker build to make and run a web site of the source code. Still a long way to go to make this really usable. I just wanted to try it out a bit,
Policy based design first mrntioned approx 30 mins in
if you want to learn a bit about graphics, cinder is a nice tool. usually plots are really easy to render
&gt;&gt; The reason being that it's easy for the compiler to tell you if you failed to add new functionality. It's not at all easy for the compiler to tell you if you correctly checked the this or that type everywhere to deal with the new type. &gt; &gt;It actually *is* that easy. The way you primarily work with variant in C++ is via visitors. This will fail to compile if you don't handle all types. Have you actually tried to use variant, or std::visit? If this is *the* reason that you are insisting on inheritance, then I'm telling you that this reason is just objectively wrong. This. It's much easier to make a "forgot to implement something" mistake with the inheritance based implementation, because there's base implementations of methods. Not an issue with a variant based implementation. 
If you're on Ubuntu. I have a skeleton project that will configure vim for you + YCM. [https://github.com/ppetraki/cpp-skeleton-project](https://github.com/ppetraki/cpp-skeleton-project) &amp;#x200B; Just ./bootstrap.sh It will move your current vimrc out of the way. The following modules are configured: &lt;code&gt; " set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() Plugin 'flazz/vim-colorschemes' Plugin 'vim-airline/vim-airline-themes' Plugin 'scrooloose/nerdtree' Plugin 'Xuyuanp/nerdtree-git-plugin' Plugin 'Valloric/YouCompleteMe' Bundle 'ntpeters/vim-better-whitespace' Plugin 'vim-airline/vim-airline' " All of your Plugins must be added before the following line call vundle#end() " required &lt;/code&gt; I got sick of working in containers and setting up my env over and over again and finally resolved to script my entire config. Hope this helps.
like how?
If you need a project that is cross platform, yes. It's not the only reason to learn how to use build systems, but it's a good one.
While I agree with this, I think it's possible to achieve the best of both worlds.
/r/cpp_questions
Heh, I implemented something similar recently in my own ECS, but use structured bindings instead allowing me to write: for(auto [position, rotation, health] : cPack) The data type that allows me to do this is a mess to write, but boils down to a tuple of views into a continuous memory range. Strangely there are some scenarios that some compilers were able to optimize this better than keeping every component array separately and indexing into it, but in most cases it generated the same assembly as doing: auto positions = std::get&lt;position_comp&gt;(pack); auto health = std::get&lt;health_comp&gt;(pack); for(auto i = 0_sz; i &lt; pack.size(); ++i) { do_something(positions[i]); // etc... } And that generated the same assembly as just indexing into a std::vector (because it pretty much is).
CMake is readable, although imo it lacks consistency. For example: `cmake_minimum_required(VERSION 3.12)` Why must I write `VERSION`? Is this absolutely necessary? Ok, no big deal. Let's assume this is just the _proprietary_ CMake syntax. `add_exectable(NAME MyProject main.cpp)` Wait.. why isn't this compiling? Oh let me go check the docs.. # (⌐■_■) ## ( •_•)&gt;⌐■-■ ### (•_•) Ok maybe I'm exaggerating how detrimental this is, but regardless it still irks me. 
The source code is available at the following address: [https://github.com/PardCode](https://github.com/PardCode) 
Maybe, but as /u/lanzaio mentioned, consistency to me is very very valuable. I find it exhausting if I have to build a build system when I actually build a project, and also figure out how the hell this thing works if I need to tune the compilation or if a problem arises. There is a lot of value in something that's maybe imperfect but is "standard" enough so that many people use it. Especially since this is yet another instance of the XKCD about standards: all of these newfangled build systems that keep popping up (especially on this subreddit) usually solve a few specific pet peeves with CMake of the original author, and are wildly complicated to use for cases that the author didn't think of. Then there's lack of interaction with other projects, lack of documentation, code immaturity (in the form of bugs), not being available in common Linux distro channels, ... and worst of all: most have a [bus factor](https://www.wired.com/story/giving-open-source-projects-life-after-a-developers-death/) of one. Why would I entrust my precious project to a build system that might have one or two active developers behind them? All these things matter to me more than having to suck up some silly syntax, especially since you can avoid most of the silliness with the newer "target property based" CMake approach. 
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
I haven't used variants. But it doesn't require having used them to know that the compiler is not going to go find every reference to one throughout the code base and tell you if you handled the variations that need to be handled at that point in the code. It couldn't know that unless it made you handle every variation every time you accessed it. And if you have to handle every one of them in every place you do any reference, that's even worse. And of course you like it, but others don't. Here's a whole thread on what sucks about them: https://www.reddit.com/r/cpp/comments/703k9k/stdvisit_is_everything_wrong_with_modern_c/ And of course I DID get an understanding about the possibility of using variants from this discussion. So it's not like I'm not listening. And I will look into them to see what I think they are useful for in my own code. But, just because you like something, doesn't make it automatically superior. And just because some well known person likes it doesn't either. I mean Linus insists on procedural programming. He's a lot more famous than you, but I doubt you just take his word for it and go back to C, right? Some people will disagree. I didn't ask just so that I could blindly accept your or anyone else's word. Though of course I am noting those cases where more modern techniques are mentioned and storing them away for consideration. BTW, I think you might have not actually read beyond the header, because it struck me last night that some of what you were saying didn't make sense relative to the code. You were talking about a bool and a number and a string aren't related and shouldn't be presented separately via hierarchy. But that's not the case. There are only really three classes involved. There's a common node, a container, and a simple value. Technically there are two derivatives of container (objects and array) but they are just formalities. So all of the simple values are in one class, just stored as text as extracted from the file. Hence the enum, to let them know the actual data type if they want to actually convert to binary. Often they won't even bother, because the node type itself is sufficient information (null, true, false, and string is already represented a string.) So the only one that would need conversion is number really. Anyhoo, just wanted to make that clear. It's not like I have separate classes for every simple type. 
And of course in the time you've wasted complaining that I'm not giving you a foot massage you could have downed the file ten times over. I've never created a remote repository and don't have time to get into it at the moment. If you want to pay me, of course I'll do it. &amp;#x200B;
In order of importance: 1. Easy to understand 2. Portable to the targets you care about. 3-99. Also "Easy to understand" 100. Easy to write
 using arr_t = int[]; (void) arr_t{0, (vec.push_back(std::forward&lt;Args&gt;(args)), 0)...}; Reminds me of one of Linus's quotes, "That is either genius, or a seriously diseased mind".
Proposal? As in, link to a paper? I can't see that in the linked to discussion, but maybe I overlooked sth.? Seems std::initializer\_list is in an even sadder state than I feared it would be. This should most definitely be fixed.
I'm going to suggest [gn](https://chromium.googlesource.com/chromium/src/tools/gn/+/48062805e19b4697c5fbd926dc649c78b6aaa138/docs/quick_start.md). It has a *lot* of real-world usage (it is used to build Chromium and Chrome), it's fundamentally designed for cross-platform builds, and it's fast (see link above). The syntax is super-clean, and it has just enough scriptability in its rules to handle weird corner cases, without losing the niceness of a clean, declarative top-level syntax (which is much closer to Bazel than CMake).
Cool! I bet a parser is pretty straightforward to write, too.
Does EnTT make it possible to keep tabs on how much memory each component type is using? So you can be smart and dynamic with how you want to destroy them? From the looks of [this issue](https://github.com/skypjack/entt/issues/22) you don’t support custom allocators which is another way to reach that goal. This would be for case where you have very large worlds or scenes and you want to cache things in memory, but not run out of space.
I agree. I've updated the initial half of the review so that it does appear so abrupt. Thx for the feedback.
If you are adding a new virtual method to a class that is widely used, you just make it temporarily pure. The compiler will find every attempt to create a class of any derivative because it's no longer a concrete class. It's not going to find every use of the variant for you and tell you if you correctly handled the appropriate variations at every point where one of them is accessed. That's going to be a purely manual search and assess operation. Obviously, in something as small as this JSON parser, either scheme will work just fine, and neither is going to strain anyone's capabilities to update it and maintain it. But, in the larger world, where the hierarchy is not within a small package but is spread out all over the place, using something like a variant would be everything that OO was created to avoid. I took a look at variant and visitor. I mean, come on. It's a glorified switch statement, but just a lot less readable. It pushes the decision as to what variations need to be dealt with out to every access, repeatedly and redundantly. In a small thin like this parser, of course it would not be a big deal. But in the broader picture, it would be horrible and one of the key reasons OO was invented. &amp;#x200B;
"Clever is not a compliment" - Chandler Carruth
There was this proposal to loosen the const requirements od std::initializer_list - http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1249r0.html - but that would break the ABI. An alternative would be to create a new class that allows moving the objects it holds. Source: https://thephd.github.io/san-diego-2018-c++-committee-trip-report
you missed my point. I said that in that case the compiler does the same
ghetto fold expressions before folds were in the language...
why are you using a unique_ptr when std::string is already implicitly a unique pointer? that said, I understand if you needed just a class to test with just amazes me how intrusive pointers, which have never been seriously considered into the standard, would make all this discussion obsolete 
openal-soft, sdlmixer.
FMOD does have C++ bindings though... Otherwise Wwise or Steam Audio might be good choices, but I haven't tried them.
He just needed a non-copyable type to make his point that it wouldn't compile. 
Bazel is incredible. Open source. Super fast incremental builds. Can relatively easily be hooked up to a build cache in the cloud. I really hope it becomes the standard build system for every language actually, not just C++. But it excels at C++.
How does one obtain any GitHub stars without a repository, I wonder?
A memo to implement support for custom allocators is in the TODO file, but I didn't work on it so far because I don't really need it at the moment. Hopefully it will be one of the goal for the 2019. Btw components are packed in arrays of which you know the size. Moreover, you know the entities to which they are assigned. I think this is enough for your purpose. Kind of - how many instances of this type I have? Too much? Let's give me the entities and let's see what I can free.
If I have such things it's unknown to me. Maybe I had to create an empty one when I signed up in order to help the other guy in my company (with work for another company of his) who does use Github. But he does all of the remote stuff. I just do pulls. 
Right... That's fair, tbh. I could've actually just downloaded the zip folder, decompressed it and then opened up the folder in my IDE and configured all the include paths and deps to make IntelliSense work. But by that same token, nowadays, most people _don't_ want to go through all those steps. Instead, most people would prefer to lazily browse source code via some browser-based UI. GitHub is probably the de facto standard for this. Which is why the response to your original post hasn't been full of rave reviews. There's a culture shift that's happened. Nowadays, GitHub is king and so are all the "because we can" layers of abstraction. In fact, I _too_ am writing a "hip-n-with-it" C++ library, called Foxy. When you think web development in 2019, think _foxy_. https://github.com/LeonineKing1199/foxy
It’s literally the top comment. Can you clarify what you mean? There must be some confusion. 
 using arr_t = int[]; (void) arr_t{0, (vec.push_back(std::forward&lt;Args&gt;(args)), 0)...}; What's the point of the `using` statement here?
I like the name, which should be good for marketing. &amp;#x200B;
BASS. Wwise. What's wrong with fmod though?
I've looked into this further and found that Meson defaults to a 'buildtype' of 'debug'. I changed my value for that to 'plain' and reran the tests. That helped Ninja's results and the performance allure of Make has faded for me. I'm not sure, though if I should remove the Makefiles from my repo. I've heard there may be some environments where they would be helpful. And I'm wondering if there's a way to specify a buildtype of 'plain' in the meson.build file rather than on the command line. I couldn't find anything about that in the documentation. The best I may be able to do is to add a comment to that file mentioning the 'buildtype' option. Apologies to the CMake aficionados. I'm still on this Meson kick. One positive thing about CMake, though is that it can generate Makefiles.
I remember making a simple 2D game with SDL and OpenGL a while back. I thought to myself, "man I'm a programmer, why would I need to use someone else's engine, I can just make it myself!" Needless to say it was terrible and slow and buggy and barely worked. &amp;#x200B; I also thought to myself, "man I can use photoshop, I can just make all my own textures and artwork! Why would I use someone else's crappy stock assets". Those actually did turn out pretty well but took forever to make and weren't optimized at all. &amp;#x200B; I had orders of magnitude more respect for any game engine after that O\_O
Ha, I've actually used that before. Felt like I should take a shower afterwards.
But can I use single quotes ;)
This is fine until the end. Deducing the value type for mixed-type arguments with `common_type` is not advisable.
I'm more impressed by the modern C++ magic going on here. I'm stuck back in C++03, and I would *love* to have these cool toys to work with. \*sigh\* I'll have to learn more about what's available.
That would help a lot, yes. However, there are many differences between compilers that getting agreement is going to be \*very\* difficult. This isn't just about flag spelling, but meanings. GCC has not equivalent of MSVC's \`/MT\` flag. Doing debugging on Windows is \*very\* different than with GCC (\`-g\`): the libraries you link generally have different names, maybe even different \*locations\*. Oh, and you can't mix-and-match release and debug runtimes. macOS has universal binaries, so you get \*two\* architectures in compilation outputs. And that's just the compiler. Linkers are yet another can of worms that goes to OS vendors and \*their\* differences. I understand C++ developers looking longingly at Go, Rust, and other languages for "just build it" commands, but that ship sailed \*long\* ago and has so much patchwork that trying to get it back to port for a proper fixup is not really feasible since there's no port big enough to manage the beast it has become. Oh, and you're on that ship, so sinking it and asking for a new one probably isn't a good idea.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/aowag1/need_help_with_coding/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
What do you think it’s written in?
&gt; most people would prefer to lazily browse source code via some browser-based UI Well since we're on this subject, to be honest - I was taking a giant shit on the toilet and browsing r/cpp from my iPad so when I saw the .zip file I wasn't entirely happy. I had to wait until I got back to my desktop in order to properly view it.
It's written in Qt, which is a C++ framework, compared to the other competing GUI framework, Gtk, which uses C. Perhaps the announcement feels less noteworthy because I am not a GUI dev.
No github stars, no hand.
Many of the older functions were built in an ad-hoc manner. The newer ones (like \`cmake\_minimum\_required\`) were built with some thoughts to be extensible (though that one in particular had an issue because it errored on unknown arguments). However, no one wants to have to go and rename all their \`add\_library\` and \`add\_executable\` calls to do keyword argument parsing, so we live with that. Filing an issue requesting it might be useful for starting a discussion on a policy for more uniform command argument parsing in the builtin commands.
Ah I misread it. In terms of specific extensions I think it's best to just search for whatever you need. I have not yet stumbled over anything that improved my work flow in general. The automatic suggestions are often sufficient and I found the most popular ones for C++ and Python very helpful for debugging, linting etc.
&gt; For example, basing rebuild decisions based on file contents rather than just timestamps. More accurate and, if you use the timestamp-MD5 "decider", potentially actually faster than the Make way. Ninja could gain this behavior. See this issue: https://github.com/ninja-build/ninja/issues/1459 &gt; I'm not sure if others have though *doubt* it is accurate rebuilds in the face of most build script changes. For example, if you change the build script to change the flags passed when building `foo.o`, then it will rebuild `foo.o` and just `foo.o`. Ninja does this too. Make can do it as well (though CMake's generated files does detection at a target-wide level due to the overhead of a command-line flag tracking file per source).
I'd put "correct builds" at point #0 up there.
Looks like Boost.Build to me (`b2` or `bjam` are other names to search for).
Dang, I would have so preferred that you look at my code on the toilet. There's such a fine line between on the toilet and not on the toilet, you know? 
I have a video of me twerking in a gimp suit on Youtube. Does that get me any stars? &amp;#x200B;
A huge part of /r/cpp topics is about some library/framework written in C++. How is that different? Perhaps, it's not new, but it's also quite important. Personally I don't think that this particular topic is that useful but it is still rather relevant.
That probably get a bit more complicated once you need to support types other than string.
Wrap that up in a macro, and bam you're basically boost.
Please consider http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1221r1.html. It is a macro-like language feature that solves multiple problems including providing a means for lazy evaluation. 
Python did something of the sorts https://www.python.org/dev/peps/pep-0518/ I wish we had such a package description standard for C++
Yeah you've right, mate! indeed it's not easy to do something like ue4 or unity, complete of complex editors and so on. But it's not necessary, if your goal is to make a game from scratch! You have to make your game engine more simple than those, in base of the game you want to create. Maybe you want to make a game with only audio and graphics, so you don't have to make a physics system, big complex editor, and so on. You will have to do only the necessary things and nothing more.
Yeah you've right, mate! There is a lot of work to do a game engine! Especially for engines like UE4,Unity, CryENGINE, that try to handle almost any kind of games as possible! In this case, it will be made a game engine suitable for the game you want to create.
The simplest undo buffer, in this age of large hard drives, is as you suggest: you keep a history of edits from each saved file version. If they undo before that, you go back to a previous saved file version. So undo appears infinite. Don't get me wrong, there are far more disc space saving algorithms for infinite undo on large text files, but it'll be a thousand hours to implement and test properly, because they're quite complex and prone to corner case bugs. Many big corporations who made rafts of money from word processing software get it wrong over *decades*! Long lines last time I looked are fast if you don't word wrap and use a fixed width font. Just divide by screen width during rendering. I think that's fair if the line length is massive. A properly implemented text editor is several years of work full time. You can knock together a toy one in a few weeks. You can make a good one which scales badly in a few months. Past that it's a large undertaking. You'll be a much better programmer afterwards though. Incidentally I last wrote one for an 8Mhz ARM2 in assembler. Due to the very limited RAM - a few hundred KB - you had no choice but to page content in from storage for rendering as the user scrolled the window. That was nearly thirty years ago now, but it's stood to me. I became a much better programmer after getting it to work, and well at that. It's definitely a great choice for a self improvement hobby project.
Why salaries and bonuses are significantly low compared to other companies in finance sector? Not to mention FAANG...
Since you're a transparent organization, could you please mention the hourly rate for this role?
I couldn't help but read ```Beware of std::initializer_list!``` :D
Should I be evil and suggest an alternative: mCOI | reverseColour | resize | for_each(&amp;type::display) or if you like macros mCOI | reverseColour | resize | DO { _.display(); }
Why? Integers are usually pretty easy. Strings are the hardest ones in most interpreters.
As I don't see it mentioned here so far, I want to mention that nanogui should have some basic plotting support. It is a lot easier to install and use than for example Qt. [https://github.com/wjakob/nanogui](https://github.com/wjakob/nanogui)
&gt;Why would I entrust my precious project to a build system that might have one or two active developers behind them? You might know the person doing the work and be confident they will do a good job. Or perhaps they have an [offer to help you on your project if you use their software in the project.](http://webEbenezer.net/about.html) &amp;#x200B;
I had my mouth agape when I first learned this trick. Now I'm like, "oh yea, of course". I saw this today: https://stackoverflow.com/questions/16044514/what-is-decltype-with-two-arguments When ran into these early in my career, I thought "wow look at these C++ wizards, they're so smart". Then I hit the phase: "OMG all of this shit is just terrible hacks with convenient corner cases why don't they just add sane metaprogramming features instead of all this template garbage!!!" Now I've just resigned myself to "it is the way it is because it is that way". Every time a new feature gets added I go "oh...that's nice...okay". I guess that's what happens with age. I apologize in advance, future work mate.
could you clarify what you mean by decay in this context?
&gt;It's not going to find every use of the variant for you and tell you if you correctly handled the appropriate variations at every point where one of them is accessed. That's going to be a purely manual search and assess operation. It most certainly will fail to compile - that's the whole point. Check out the example: https://en.cppreference.com/w/cpp/utility/variant/visit. By the same token, pure virtual methods are not foolproof - you could still cast to a class without all it's methods implemented. It's a stronger guarantee. That being said, I'm not saying "never use OOP". Just that certain bounded problems like this can benefit from compile time safety. &gt; But, in the larger world, where the hierarchy is not within a small package but is spread out all over the place, using something like a variant would be everything that OO was created to avoid. Aw above, we're not talking about the larger world, we're talking about a single bounded use case: JSON. 
If none of these work, you might consider using PortAudio or RtAudio. They're pretty lightweight and if you really just want to do some basic playback, they'll get the job done easily. 
I’d just use fmod unless it’s a licensing issue - though I’d expect you to have mentioned licensing requirements if that was the case. I’ve used fmod in c++ and it was very easy to use. 
Accelerated C++ or A Tour of C++. 
I already looked at that. It's not apparent to me at all. That example uses a hand entered assert to catch not handling all scenarios. And in the other example he doesn't, which would mean unless you visited that one by hand and evaluated it to see if needs another variation handled, it's going to be a runtime error. Maybe I'm missing something obvious, and certainly point it out if so. And the thing is, you won't want to handle all scenarios in all cases. In most situations where you have to deal with some variation you don't want to handle all cases. In which case they would be like the one without the assert, and you have to find every one of these by hand and eye it and find out if the changes just made require that you deal with another variation at that particular point. I can't see how anything in that example would do otherwise. I also have to say that that is highly unreadable. If there was anything actually bad about doing it the OO way, I might take the hit to change over to some such thing. But of course there isn't. It works just fine, it's been done like that for decades, it doesn't generate completely indecipherable error messages from layers of templated code, and the performance is perfectly fine. 
Isn't Accelerated C++ only for C++98?
I strongly disagree with that notion (but agree with what it tries to say): It is very much not necessary to be clever to write complicated code, every idiot can do it. Writing simple, straightforward code that everyone can understand is what is really hard and requires all your intelligence. I strongly disagree with this famous quote by Brian Kernigham for the same reason: &gt; Everyone knows that debugging is twice as hard as writing a program in the first place. So if you're as clever as you can be when you write it, how will you ever debug it? If you are competent, the difficulty of debugging should be inverse to the difficulty of writing it. If I spend one day looking at a function to find a way that makes it even simpler, for example by removing yet another conditional branch, there is first of all a very good chance that I won't have to debug it, and if I do nonetheless, it will be so much easier than debugging a collection of 20 if-statements and 5 loops. Consider the famous slide-example by Sean Parent that just calls `stable_partition` twice: It was very clever to come up with it, but once you see it, it's completely obvious how it works and much simpler than stupid solutions. Being clever is about looking through things, recognizing their essence and finding the simplest way to treat them so that your mind can concentrate on other things.
A meson is a subatomic particle with a very short lifespan.
In my experience, Cquery is better if you’re able to generate the compile commands JSON file easily via bear or your build system. 
Is your manager keeping you on C++03?
An even higher power, I'm afraid.
Ah, nice I'll check that out
This isn't even using much of modern C++... just a bit of C++11... :-) This is like 20% of the cool, modern &amp; useful stuff^^
Well, with Boost Spirit X3 [you can parse entire string-only-JSON grammar in 14 lines](https://www.boost.org/doc/libs/1_69_0/libs/spirit/doc/x3/html/spirit_x3/tutorials/rexpr.html).
Yes, there is a lot of basic C++98 functionality that can be learned. Modern C++ is important to know but I believe that it's important to understand basic C++ functionality before understanding /appreciating the C++11/14/17 features.
You can't specify type aliases for constructors. But since C++17 you can write explicit deduction guides.
Do you have any reources on what/why CTAD + deduction guides offer instead of allowing to explicitly specify Ts in constructor calls?
What? TIL
&gt; There are a few hiccups in STL parsing Eclipse CDT does not [yet] support user-defined literals and most of new syntax in C++17.
Just spent an hour trying to get cquery to work on this meson project, I can't find any documentation on how to get it to find your compile_commands.json file. It is stuck at "cquery is loading project metadata (ie, compile_commands.json)"
Anyone who reads this will likely underestimate the thing. Recently I started to work on a hobby parser project with Spirit X3. Eclipse lets me browse 4400+ expansion steps of `BOOST_FUSION_ADAPT_STRUCT` that is used to create iterateable hetererogenous tuples. What is even better than Spirit -&gt; Fusion dependency is Fusion -&gt; Preprocessor dependency. Yes, Boost has an entire library that is purely devoted into preprocessor stuff, including macros that cause preprocessor to work like ifs and fors.
Oof that sounds prophetic.
mlpack implements [logistic regression](http://www.mlpack.org/docs/mlpack-1.0.8/man/logistic_regression.html) It is available in many distros like Ubuntu (libmlpack-dev) 
So it's still a long way to go for me, it seems. Thanks very much for your help :) Also, if you're interested in my project, maybe try it out for yourself? (The latest commit only works on Windows.)
Try /r/cpp_questions, they are more friendly You are being downvoted to hell because folks here are very snotty 
This should be coded to be c++11 friendly. Current version is not. std::string capitalize( const std::string &amp; str ); should be std::string capitalize(std::string str); with str being a move target.
You'd have to first put it in a github repository with an embedded player in README.md
The variant is 17 and I think the auto lambda is 14. It'd be significantly more lengthy and more ugly without the variant.
Not an unreasonable assumption when it is a proprietary module added onto an otherwise open-source project. Why isn't it in the main source code? It's suspicious, to say the least.
I believe you just need the compile_commands.json to be at the root of your vscode workspace. Also I believe there are limitations with respect to using more than one workspace. I’ve only tried with one but another guy at work said that it wasn’t working with multiple workspaces open in the same editor instance. 
Why isn't it advisable and what's the better solution?
How is it the same? I see 40 lines of output [GCC-trunk on godbolt] vs 46 lines of output [GCC-8.2].
I’m reading the book. I’m really enjoying it, but my minor criticism is I am somtimes struggling to understand not the “how” but the “why” I would use some of these techniques, monads for example seem a bit foreign to me.
The binary `common_type` is commutative but not associative, so the variadic `common_type`'s result is sensitive to the order of the arguments. It also can deduce arguably nonintuitive results in the presence of implicit conversions to built-in types. If we had it in C++03, it would have reported that the common type of `ifstream` and `istringstream` is `void*`. The usual suggestion is to only deduce if the arguments are all of the same type (after decay). This also matches the normal template argument deduction behavior.
I'm comparing optimized vs deafult - 20 lines of code for each 
How do you do that for variable number of arguments without already knowing the type? Or are you saying one should require the type to explicit (i.e. make it non-optional) to avoid this (potential) issue?
I make an internal logger that reports things that might give me insight into the problem if it occurs. The logger has a fixed length, say 100 events, where it dumps the oldest things. At some point where I can detect that the problem has happened I trigger the logger to dump it's contents.
I blame parallelism, and focus on techniques to debug, harden, and minamalize the parts of my code that are asynchronous. The book "C++ Concurrency in Action: Practical Multithreading" is a good read if any of your code is multithreaded. 
This article seems to imply that move iterators will also remove const. Or, at least, that move iterators wrapping const iterators produce values that are movable. Is this true?
To add \`double\` I think it'd be something along these lines: 1. s-expression variant also includes double 2. eval returns a variant over string and double 3. eval overload that returns the double when passed a double 4. Type safety or coercion to taste in built in library (probably with aid of some helper functions) I think that might be about it.... 
We're talking different things [that's not a problem, we just do]. I meant, less lines of output [trunk vs 8.2, both optimized, what else?] probably means better [as in faster].
This is highly dependent on the architecture.
"Log everything" Additionally I tend to pepper asserts everywhere and then compile with asserts enabled. It usually catches a few errors.
Good point, I updated my post's text.
Just out of curiosity, what is this? Code review, tutorial, blog? Anyways, why is *balance* private, but *deposit* and *withdraw* are public? Initial value is a 0, so wouldn't the first deposit be the initial balance? What happens if someone withdraws a negative value? Not sure what I'm looking at here, bud, but in the event you are a newbie showing off your first attempt, good job! Keep it up, bud!
[I'm loving it!](https://www.urbandictionary.com/define.php?term=i%27m%20loving%20it)
In addition to what you mentioned, you can also try thread sanitizer, address sanitizer (some overlap with valgrind), and ubsan. Static analyzers like Coverity and cppcheck may also help point out issues.
An static code analyzer may help. Those can help you to find some bugs, but your code must be clean of warnings and follow a healthy coding style, otherwise it will seem they are asking you to refactor everything. 
Lol I can see you know this problem. It's for a multithreaded server that is pretty much identical to a game server, so high speed is important. Fact is though the bug sometimes can't be reproduced and the OS kills the process due to memory loss (because each process can only handle so many clients/pthread_create() calls) sometimes, and when it can be reproduced it's when the OS is very low on memory and acting weird (testing on a cheap 1 core vps) and also - I'm writing on top of openssl, which valgrind complains about sometimes too, and openssl is known to be fairly weird, some would even say buggy with memory. But yeah, it's very asynchronous, mutex, shared memory, etc. It's really messing with my head though. 
Another option is to generate a core dump or invoke something like [`boost::debug::attach_debugger()`](https://www.boost.org/doc/libs/1_69_0/libs/test/doc/html/boost/debug/attach_debugger.html) to look around the process.
Thanks, I've done all that but it's literally a function that 1 in several thousand calls get triggered and I have very little to go on, it's like memory is magically being rewritten somewhere. Normally a certain pointer is this and now it's that poof vanish real smoke and mirrors type stuff.
 You are right. Gcc/Trunk has this optimization while gcc/releases and clang still not. Still, I actually was doing some measurements and it was so insignificant I could not understand. I believe there are pipeline/concurrency effects that are making both equivalent. 
I don't think it makes much of a difference in server-grade processors. There's hardware dedicated to detecting loops via the uop trace cache, along with the sophisticated branch predictors. The most I'd guess would happen is that the compiler might invert a branch or reorder basic blocks if it knows an architecture favors forward/backwards jumps. Also see here: https://software.intel.com/en-us/articles/branch-and-loop-reorganization-to-prevent-mispredicts
wat
Thanks very mcuh trying cppcheck now, I'd like to test coverity but it isn't free and I'm not going to buy something that may or may not work.
I have 2 warnings but it's related to openssl's code not mine - specifically the mutex locks that openssl requires to be threadsafe, and it's defined but not used so nothing that should affect program flow. Apart from that no static warnings from gcc no dynamic warnings from valgrind/gdb. Can you recommend good static source analizers? I've never used one. 
I'm already using gdb and I'm using a C compiler but could switch to g++ - would using a boost::attach_debugger() provide some insight valgrind/gdb wouldn't?
The idea would be to invoke the function when the program has misbehaved i.e. `if (bug_happened) boost::debug::attach_debugger();` - it might be more convenient/performant than starting the application under gdb and setting a conditional breakpoint.
It could be something like stack corruption. If you can break into a debugger when the issue occurs and view the backtrace look for things like variables with nonsense values or the debugger complaining about invalid addresses when attempting to print the call stack.
Yeah I'm using valgrind connected to gdb and it's definitely not convenient nor performant maybe I'll give it a shot thanks. 
Sure. Make sure to check out thread sanitizer too - elsewhere you mentioned it's a multithreaded server, it can definitely help at least rule out a bunch of issues.
That looks pretty neat. Unfortunately I'm using gcc &amp; a makefile on the server where the bug is and I see that needs cmake &amp; clang : ( thx for the tip tho.
Did you compile with address sanitizer and thread sanitizer? They can catch things that valgrind might miss. 
It's included in GCC 4.8 and above, same flag.
Hmm I'm not familiar with that technique but it sounds very interestings -fsanitize=thread compiled and I have my fuzzer running against it at 50% cpu but -fsanitize=adrdess gave this error - error: -fsanitize=address and -fsanitize=kernel-address are incompatible with -fsanitize=thread so I guess it's one or the other
Thanks yeah someone else below reccomended that to but it needs some more libs linked or something I need to read more about that to understand what's going on I thought it was just like extra symbols or something but thx.
I'll have to check out that book, but this is a very very good series on the topic too - http://ithare.com/64-network-dos-and-donts-for-game-engine-developers-part-i-client-side/
See, you have a specific problem but you're asking a general question, "how do you debug". From what you wrote, you didn't look in a specific direction **in your own code** yet. (And by "a specific direction" I don't mean code that might have a bug, I mean code where the bug manifests itself). Since context is key to questions on so many things in... life, really (and programming), I would tell you that you need to have more context to answer your question. And because you see your own context best, you're the best placed to work on it. Anyhow, about the bug... Do you have a crash dump ? If so, get people who know the code to look at it. Depending of what's in it, try to make a hypothesis of what could be causing it. Buffer over/underflow and trashed stack are the cause virtually all the time =&gt; and work on adding tooling to expose these things (compiler settings for stack protection and run under Valgrind or whatever other sanitizers you might have). (Or better, do you see segfaults etc? Are you sure you aren't hiding them somehow? To debug problems, one actually wants *as hostile environment as possible*, really. Debug versions of whatever libraries work hard to give you that, through asserts and usage of bug-unfriendly compiler options. Are you using these?) Do you have some data corruption? If so, you will probably need to find the code that wrote this data and work "backwards" to understand what caused it.
1. Add enough log around that bug. The logs are fine only for that bug temporarily. 2. Review any suspicious code again and again. If you have other partners, let them review it. Then "guess" where can cause the bug. This is quite efficient than you think, though this should be the last resort.
FMOD is a C and C++ library. What is it not doing for you? There's also SoLoud, libsoundio, and SDL_mixer.
Changing the hardware can change the reproduction rate (but in a way or another!). Especially the number of cores or even the CPU brand (different cache, etc.) A cheaper alternate path is to reduce the number of active cores for your application. Another solution is to put some short thread sleeping calls at various strategic points in your code, to "disturb" scheduling in order to reveal something, hopefully.
Post it! ...just not in a zip file.
It doesn't remove the const, and I'm not really seeing where the article would imply that. Essentially what std::move_iterator does is, it wraps the underlying iterator's operator* with a std::move (apparently, [it was changed](https://en.cppreference.com/w/cpp/iterator/move_iterator/operator*) to an explicit static_cast to an rvalue in c++17). Note that casting a const value to an rvalue reference (eg. with std::move) gives you a const rvalue, [which still can't be meaningfully moved from](https://wandbox.org/permlink/ZQRUvo9Va9P48xWo) (that is to say, the resulting value will not bind to non-const rvalue references).
I guess this is more of a "theoretical" question. I mean, my code base is probably 50K lines of code, I'm using valgrind, gdb, etc - everything you mention and still nothing. Honestly I can handle this so no crash is caused and the client needs to re initiate the login scheme and yes my dear, dear end user looses like 250 ms of his life. In an ideal world I'd see which frame in gdb causes the crash, edit the source then poof ping pow easy bro no error but in this one I just need to patch it and now it's a new feature that limits login attempts while the server is under stress! I've seen other major projects like openssl do stuff like this, it isn't ideal but we're humans. So I guess that was more what this general question was about...
You could start with this one: https://github.com/danmar/cppcheck 
It's a tender, you propose your own hourly rate like it says "including your financial expectations".
Build correctness really has more to do with the compiler than the metabuild system (CMake, Meson, etc.). The sort of ways that, say, CMake can affect correctness really are within #2 (library discovery, link sequencing, DT_RPATH vs. DT_RUNPATH, etc.).
Yeah they already told me about that and I ran it just style error unforuntately : (
And this is why I do everything I can to avoid Boost. It definitely has its purposes, but it's something I greatly prefer to not have to screw around with.
Thanks for the link, I'll read it! What do you mean by server-grade processors? Are you referring exclusively to Xeons or Opterons, or you used it to indicate the performance of the CPU? (i.e. compared to ARMs or other low energy CPUs)
If everything else fail. I would go back in time in git until this particular error stops reproducing and analyze code diff.
Somewhat relevant: luckily boost has utility to copy parts of the library to another folder so we can bundle only minimal set of headers instead of entire boost. Except everything depends on too many things and copying most of subsystems still pulls in close to half of other stuff. That is so boost.
So you suggest that current Development Mentors (same position) all have different hourly rates based on their suggestions? Doesn't sound fair, does it? Please disclose what are the current rates, like max, avg, min for the given position. Thank you.
congratulations! you have something like a heisenbug! it's not there when you go looking for it, but you can cause it to happen in a somewhat bounded timeframe. as you are currently unable to locate it directly with reasonable tools, your objective becomes iterative in nature: do whatever you can to decrease the time it actually takes you to run a test, so you can run tests faster. say it takes a maximum of 8 hours to occur. take a snapshot every hour or so until it occurs. then run your program from the most recent working snapshot, taking another set of snapshots until it bugs... and repeat until you get to a snapshot that when run will glitch within a couple of minutes. *now* you've got something you can consistently recreate in a timely manner and eventually step through a debugger and see what's going on. this is somewhat difficult to do if you have a synchronization bug, but can often put some better bounding conditions on it. i'll use this type of methodology when pretty much everything else has failed, as this is a pain in the ass, but it's gotten me *good* results, when all else has failed.
There are C++03 variant implementations- e.g. boost.variant
Qt is much more than a gui framework like GTK. For instance KDE frameworks provide stuff like cross-platform DNSSD support, cross-platform archive compression and extraction...
Since you mention you're focused on x86-64: For this platform this is completely unrelated to hardware; Intel CPUs have ignored branch hints since Pentium M and Core2: "Branch hint prefixes have no useful effect on PM and Core2 processors." -- https://www.agner.org/optimize/microarchitecture.pdf (the manuals at https://www.agner.org/optimize/#manuals are definitely recommended reads) The main use is purely on the software side -- to help compiler optimize -- primarily affecting code layout and instruction selection: - code layout: e.g., when we have `code_A; if (condition) code_T; code_B` the decision to make is whether the code is laid out in order code_A-code_T-code_B or code_A-code-B-code_T (which can make a significant difference if it ends up affecting whether your actually executed instructions fit in a cache line or not) -- see https://dendibakh.github.io/blog/2018/07/09/Improving-performance-by-better-code-locality and the discussion around `__builtin_expect` here: https://lwn.net/Articles/255364/ (code layout by itself can have occasionally surprising effects: https://dendibakh.github.io/blog/2018/01/18/Code_alignment_issues) - instruction selection: primarily whether to use if-conversion, converting control dependence (as in: conditional branch instruction family Jcc, say, `jnz`) to data dependence (as in: predicated execution; for x86 there's only partial predication, limited to CMOVcc and SETcc instructions) -- this is surprisingly tricky, since the decision here is strongly affected whether the branch is *predictable* or *unpredictable* (and not whether it's *taken* or *untaken*). A lot of branches are predictable (and `Jcc label, MOV A, label: MOV B` turns out to be cheaper than `CMOVcc A B` -- not just trivial cases like always-taken or never-taken, but also taken-and-untaken-in-an-alternating-pattern; similarly, taken-with-high-probability may be good enough to prefer a conditional branch to a conditional move) PGO as well as `__builtin_expect` (and `likely`, which is just a syntactic sugar for this) are understood by compiler in form of branch weight metadata (and can be subsequently used for basic block reordering and instruction selection); see: - https://llvm.org/docs/BranchWeightMetadata.html -- https://llvm.org/docs/BranchWeightMetadata.html#built-in-expect-instructions - https://llvm.org/docs/BlockFrequencyTerminology.html - GCC: https://kristerw.blogspot.com/2017/02/branch-prediction.html, http://www.ucw.cz/~hubicka/papers/proj/node8.html There are caveats and trade-offs to either one: PGO profile may or may not be representative of your application; the implicit belief of a programmer placing the branch hints is a "profile", too -- and may be even less representative than the said profile -- but it may also be the only thing that matters if you care about low latency of a particularly rare condition and are willing to pessimize the otherwise common case (which goes directly against the information a PGO-based optimization would have). PGO itself can be improved upon, too: https://arxiv.org/abs/1807.06735, https://github.com/facebookincubator/BOLT/ There's more to this, but these are also worth checking out: - GCC's 9 `__builtin_expect_with_probability`: https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#index-_005f_005fbuiltin_005fexpect_005fwith_005fprobability -- example https://godbolt.org/z/ModpUj (from https://github.com/nemequ/hedley/issues/15) -- patch with microbenchmark: https://patchwork.ozlabs.org/patch/948237/ - Clang's `_builtin_unpredictable` (cf. the above discussion when CMOVcc may be preferred for unpredictable branches): https://clang.llvm.org/docs/LanguageExtensions.html#builtin-unpredictable
guess and test is a *very* valid methodology, if used *methodically*, although not particularly efficient, except when it is. it's particularly good at finding limits on a bug when the boundaries of an undesired occurrence are completely unknown.
Never really needed it but you could try time travel debugging tools such as https://rr-project.org. Normally i try to zoom into the problem area and log a lot until i know enough.
This also works for appending vectors of unique_ptrs. Which I found very handy when collating polymorphic classes into a master vector
When faced with a bug like that, I built a shared memory-based system in which I tracked what the application was actually doing, with a second application just reading the shared memory and reporting on the final state when it detected the original process had died unexpectedly. Took me five years (the bug didn't occur very often), but eventually I realized what the problem was and fixed it. A stack trace would have done the job as well, but this was in production, and... reasons. I chose shared memory, rather than logging, because logging so many state changes is expensive, whereas just updating the shared memory is virtually free. And when the monitoring application raises the alarm at least the customer tells me about it. 
This is a goldmine. Cheers!
Can you see a sequence of events in a log file and using the expected code paths as a guide, reason about where it goes wrong? 
It also uses C++17's init statement for if's: `if (auto const fp = library.find(fname); fp != library.end())`
but in this programming assume that our balance is 0 and after do continues process
this is blog
understanding scope resolution in c++ programming language
and this program is only that how to use scope resolution operator in program.
Maybe this can help you: #include &lt;iostream&gt; class foo { public: foo(const int i) : i(i) {} template&lt;typename T&gt; operator T () { std::cout &lt;&lt; typeid(T).name() &lt;&lt; std::endl; switch (i) { case 0: return 0.1; case 1: return 1; case 2: return 'Z'; default: return 9223372036854775807ULL; } } private: const int i; }; int main() { double d = foo(0); int i = foo(1); char c = foo(2); long long l = foo(3); std::cout &lt;&lt; d &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' ' &lt;&lt; c &lt;&lt; ' ' &lt;&lt; l &lt;&lt; std::endl; }
Sounds a lot like xray: https://llvm.org/docs/XRay.html
Coverity is really good. There are false positives, but you can mark them as "intentional". It can't detect misuses of global pointers that lead to null pointer dereference, but other than that, it worked quite well for me. It is free for open source projects.
Once you've gone through the other recommendations here and you still see the bug, you can try using Mozilla's RR to catch it red-handed.
Thread-per-connection hasn't been relevant since the 1990's
Sounds like you have not tried Meson since? You might also enjoy this piece on CMake black magic https://izzys.casa/2019/02/everything-you-never-wanted-to-know-about-cmake/
I don't have a good answer to your immediate question (what are t j.g e concrete effects/benefits ), however, as a general recommendation, I wouldn't use them to mark "likely" and "unlikely" branches, but rather to - Indicate that you want a certain branch to be optimized even at the cost of others. E.g. in HFT, the path that is important (the one where an order is sent out) is actually less common. - You are fine with a certain path to be significantly pessimized. E.g. you might not care about the performance during error handling or you know a certain path will be very slow anyway.
Why?
At the moment I'm using it to mark branches that are very unlikely to happen. I.e. error handling that's most likely will never be triggered, but the code is there for correctness.
haha did not make that connection :)
True, that was easy to miss! Nice one.
I guess I've been using modern C++ for way too long, don't even notice those anymore... :)
Better use something more aligned with the standard and more decoupled like [mpark/variant](https://github.com/mpark/variant).
If you can afford error handling to be slow if it does happen, then that sounds reasonable to me.
Having different colors for every kind of token: types, methods, variables, parameters, enums,... improves even better readibility. So far I didn't found better than Visual Assist in Visual Studio at doing this job. 
That was a copy-paste error - I left cbegin/cend from the snippet above - I've fixed it as soon as I noticed.
&gt; Jeff Goldblums "Functional programming always finds a way" :D
I, probably like most people on Windows, am happy with Visual Studio and where it's too much of a sledgehammer, Notepad++ fills in. Notepad++ is a good example of a poorly scaling text editor written in C++ actually. Its find and replace regex in files is so slow I keep meaning to go inspect their source code just to satisfy my curiosity as to how it can be possible! It also doesn't cope well with text files beyond a certain size, long line length murders scrolling, and the project in general suffers from the too many cooks problem. But it's good enough I've never found reason to change, and that's what you compete against with text editors. So I wouldn't build a new text editor expecting anybody else to ever use it personally. Too much competition in a stagnant market leading to inertia. What you may not have considered is that a text editor is actually very similar to a market data aggregator used by hedge funds to do arbitrage. Funnily enough that will be my next employment, if a signed contract ever turns up - splicing edits of price updates into a versioned history of a collation of views. Very similar to a text editor, albeit one with hard determinism, so no waits, no atomics, no malloc, no memory copying. Oh and most of it runs on the ASIC on a network card right on the 40Gbit Ethernet wire. As I mentioned, that 8Mhz ARM2 few hundred KB implementation experience has stood to me!
Can you give examples of how you do that?
If you think what Fusion provides it can be really useful. Spirit uses Fusion to mock reflection features with minimal boilerplate. And macros do not impact compile time much.
As someone who is only passing through this thread - can you explain / link to the thinking here? It has no relevance to anything I’m doing but it might someday. 
Short Answer: If you are going to make copy inside the function anyway, why not take the parameter by-value? Longer Answer: https://stackoverflow.com/questions/10231349/are-the-days-of-passing-const-stdstring-as-a-parameter-over/10232761#10232761
It doesn't scale. If you have a server handling 100k conections you're going to have a very bad time if you create a thread for each of those. Maybe if your CPU had 100k core it'd be ok.
`std::visit` is a pessimistically defined visitor for a variant. This does not imply that the concept of variants and _visitation_ is bad -- just that the `std::visit` is less than optimal.
There are many different sanitizes that may help you catch sneaky errors: https://clang.llvm.org/docs/index.html https://github.com/mapbox/cpp/issues/41 But some are incompatible, i.e. can't be enabled at the same time.
Some sanitizers are also available on GCC but is there any reason you can't just chance $CC to clang? Unless you heavily really on non-conforming GCC extensions clang should be just a drop-in replacement.
First thing is to get it to repro more often. Try something like [dummynet](http://info.iet.unipi.it/~luigi/dummynet/) to simulate a crappy network connection. 
That's an excellent suggestion. Even if the reproducer is slow-ish, you can just let it run in the background and peek at it every so often during the day. Bisecting the last 100 changes only takes 7 iterations, so even if you have to let the reproducer run 1h to be sure it's not happening, within a day you'll have locating the change. *Of course, if like I suspect there's Undefined Behavior afoot, unfortunately the change which triggered it might be completely innocuous...*
Good to know. Thanks!
Last I checked, rr didn't seem to work with multi-threaded applications; has this improved?
Indeed, the sanitizers are generally incompatible. You can use nightly builds to build each and every one of them in turn and run your test suite against them; they really help.
There are two things that happen when running low in memory: - `malloc`/`free` can become *much* more slower, as the OS scrambles to find available RAM. - Swapping destroys performance. This should not affect correctness... unless you have a data-race/race-condition which is exposed by a normally fast operation suddenly being slower. You may want to try static analysis tools focused on thread-safety: Clang comes with [`-Wthread-safety`](https://clang.llvm.org/docs/ThreadSafetyAnalysis.html), if you don't use any lock-free data-structure, it should work quite well. 
According to their github it seems limited indeed. Microsoft recently released a tool for windows which i think does support it.
Thanks for responding. My question was more along the lines of “what is the alternative?”. 
I went in expecting a nonsense interview question and this was beyond what even I was prepared for. Who in their right mind would ask pointless brain teasers for interview questions? Programming is hard enough. I have no idea why it is such an exotic technique to have a conversation with someone about what they have done in the past, what problems they solved and how they overcame those problems.
For me, that you have a sensible default targets (release, debug, pch if you need, sanitizers) without having to spend time on them. Also, easy to consume dependencies and create them, but the creation part depends a lot on whether you want to install or not. I also consider important that you can statically link your full thing if you want to do custom deployments. If you need things such as protobuf and such, it is good to support some kind of custom generators. Cross compilation depending on your needs is also important. Concretely, in Meson, I save time bc of this default targets and because I find easy and uniform how to work with it. The scripting language in CMake and the more unstructured way to treat options was also time-consuming. If you want pch or unity builds, it also takes time to add those. 
Agreed, seriously what useful information can you gleam from watching a candidate squirm through this other than how they adapt to the “look how much smarter I am” scenario. How about an interview question like, how could this function fail(bounds/state checks, memory leaks), or a rea world problem that implicitly requires the candidate to know of a particular data structure to solve.
Ah this can actually be done in constant amortized time instead of linear by spilling (nice function name btw) only when necessary void push ( const T&amp; item ) { m_push.push(item); } void pop () { if ( m_pop.empty() ) spill(m_push, m_pop); m_pop.pop(); }
PM me, I'll tell you how asked such question ;) don't want to give out the company names in a public forum.
You could have the code reviewed by someone external (e.g. PM me, I can sign an NDA). But ina my case, testing on VPSs should come last. You should have a virtual environment set up where the testing fires a few VMs on your machine, or on a local cluster – VMs that are resource constrained. Then, when your process crashes, you can have an exception handler freeze the VM through the hypervisor API. That way you’ll have the state of everything: kernel, other processes, all of the memory, etc. 
The latter
What if t2 started executing before t1 and if e2 spuriously woke up? If so, the program could start by printing a "B". But I don't know what auto_event is, may it handles spurious wakeups? Here is how I would solve it: https://gist.github.com/bandzaw/4119eb44e7ba924a20e35e96cd17ce7a
Spirit is pure nonsense. You want a good parser (C, but C++-friendly), use Lemon (a part of SQLite). C++ is nowhere close to letting your write sensible and performant parsers within the confines of the language itself. 
I linked to the implementation of auto\_event in my post. it is implemented using condition variable and handles spurious wakeups :)
This actually how they implement queues in some pure functional languages.
If you're asking about the asserts, I just follow [these guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html#Ri-pre) and try to make sure the inputs/outputs of my functions are sane, instead of relying on "of course this will only get used in this scenario". I use cmake, and usually include [this](https://stackoverflow.com/a/42119938/1371191) in the top level file.
KDevelop's rainbow colors can do this, too, and it alternates color for every local variable. I find that level kind of distracting, tbh.
Ah, ok (y)
You wouldn't want to use `cbegin`, as in `std::make_move_iterator(dir_items.cbegin())`. Those iterators would produce `const &amp;&amp;` elements, I believe. It looks like the author noticed and the code has changed now.
Research "C10k Problem". Enough people have talked about the problem and alternatives that it has a name.
Notepad++ is essentially a last-gen editor. Not that it's a problem - people are still using vim these days, and they're pretty good for this task. I'm one of those who prefer their editors to look slick. You know, "doing the job while looking good". At the same time I find sublime's regular prompts irritating, but not enough to have me purchase it; I also find the stuttering and slow startup of vscode and atom annoying. That's one major reason I started this project. Who knows? Maybe I'll abandon it halfway. Maybe I'll polish it a bit and use it personally. Maybe people'll start using it too. It's like a gamble, only it's my own time on the line, which is not exactly precious. Soon I'll have to shift my focus onto my graduation project, and who knows where this'll go? Anyway, I'm grateful for all your help. Wish you a good time on your new job :)
What I would do is to write a test case that can reproduce the bug (I know, 3000-5000 times...) &amp;#x200B; When you have something like that, run it with an option like meson test --repeat --gdb (I am pretty sure CTest must have something similar). When the problem fires, you will be prompted to the debugger. Inspect the stack trace, threads, etc.
Ah, I see you're a man of culture as well.
In the first problem of finding a missing number from 1-n, the solution says: "There can be overflow if n is large. In order to avoid Integer Overflow, we can pick one number from known numbers and subtract one number from given numbers. This way we wont have Integer Overflow ever. " Can somebody explain how this works ? cheers
I can't believe I missed that the first time..
Well-stated, however some good news worth mentioning is that there have at least been some recent (and upcoming in the case of libc++ and presumably libstdc++) implementation improvements for `std::visit` that drastically improve codegen: https://www.reddit.com/r/cpp/comments/airalq/variant_visitation_v2/
How is this connected to c++?
That still requires C++11.
BTW, I realized after the fact that that might have sounded like it was supposed to be some sort of veiled snarky remark, but it was just intended to be silly.
So you do have a crash? Ok, so what did the crash dump say? Mind, the source code at the place of the crash often has **no** relation to the bug, it's a hapless victim of it - but you gotta start somewhere.
Okay, well - a bit of bad news, I have investigated your issue and I can confirm everything you wrote. The best course of action here is to rewrite the thing from scratch, with each component developed in isolation with unit tests, soak tests, 100% code coverage, code review, and documentation, and hope that you don't recreate the bug in the process.
Thanks for the reply, I like reading about these types of problems in case the solutions can be applied to things I’m working on. 
Already read this post :) There's indeed a lot of weird stuff in the language. Actually I wonder if the people working on it at Kitware are in a mind of "our language is awesome, people just don't understand" or if it's more "let's keep it this way, maybe fix it later". I don't know if I will have a real occasion to test Meson since I'm satisfied with CMake. On small projects it would not make a big difference and on a large project I would wonder at each problem if I should continue with Meson or switch back to CMake (and have other problems, because when a project is large enough there's always weird cases).
This leads me to wonder if there’s ever an acceptable time to call a pure virtual function (directly or indirectly) in the constructor of a class that’s meant to be derived from. If not, it seems like an easy enough clang-tidy check.
Please stop spamming the subreddit with your miniposts. There's absolutely no reason to post this in a ton of small parts.
https://gcc.godbolt.org/z/UgLnCb main: push rax call __cxa_pure_virtual If you don't want to fall off the cliff, shy away from every rim. 
Indeed, there's little point spending engineering effort on protecting something that isn't being explored yet, when you could use that time to fix bugs, new features etc that everyone will benefit from.
I was scanning for an actual link to a proposal, and didn't see any.
For hard to catch bugs I usually try to binary search it. It works for 'time' with git bisect, and for 'mass' by reducing the amount of executed code: e.g disable something or the comment something out. If bug is still triggered, remove something else too. If bug is not triggered, add that part back and remove something else. If I can't find the bug this way, I blame it on cosmic rays. 
nice one! mine was a debug build, that's probably why ;)
I've been trying to work with FMOD but for whatever reason I keep getting an internal error that I believe is coming from within my machine. So I wanted to try another audio engine to see if something's wrong with my computer or if it's the code
That was poor wording on my part, I was looking for another audio engine for C/C++ not because FMOD doesn't work in C/C++, but because I am having some bugs with it 
Googling "initializer_list move open-std.org", I find that the proposal number is P0065. https://wg21.link/P0065
Thank you! Following up now
excellent discussion of this: https://blogs.msdn.microsoft.com/oldnewthing/20131011-00/?p=2953 
Somebody buy those organizers some good microphones! 
Speed advantages (potentially avoid allocation).
New versions of clang don't even emit the llvm.expect IR instruction (http://llvm.org/docs/LangRef.html#llvm-expect-intrinsic)for __builtin_expect because it seems to harm/prevent some optimisations. See https://gcc.godbolt.org/z/fY8teb and https://github.com/rust-lang/rust/pull/36181#issuecomment-244207853
I guess you were faster to read the article than /u/Svitkona :)
Yes MPark has done some really nice things for variants. My favourite being https://github.com/mpark/patterns
for stging handling utf8 generalization my well kill this specific use case as utf8 capitalization might result in a string with a different byte size. Then the const ref is probably fine as the input can't be reused, only iterated over.
My initial thought was "where's the virtual destructor?!"
its Pointless criticisms. 1 client p/thread/process isn't ideal (which I never said) but More like 1 thread per X connections, similarly to how worlds most used servers like Apache are still limited to X numbers of clients p/X threads/processes and pretty much any server is going to be using some form of multithreading or multiprocessing both of which have similar resource constraints on the OS/hardware. This guy needs to go over to apache lists (and bind9, postfix, etc) and show those noobs writing apache server the right way to do things. If you're new to coding people who endlessly critisize things offering vague referencing and, and of course absolutely 0 source codes , on "the right way" are pretty common... 
Care to elaborate? Can you list what would be the benefits of a C code generator vs C++ compile-time parser generation?
Is it a logic bug or a crash? If it's crashing and you can reproduce it, even rarely, then enable dumps and reproduce it one more time so you can inspect the dump to see what went wrong. Sometimes if it's really hard to reproduce naturally but I understand more or less where the error is occurring, I'll write code to try to force the error so I can examine what leads up to it. Really all depends on the nature of the bug I guess. If it's really complicated I just buckle down and read through all the relevant code myself, knowing there is an error and looking for what could be causing it. Each time I find a potential candidate I write code to test my assumption and move on if that's not it. 
Sounds good boss we're on it rewrite from scratch gotcha hourly rate is the same no worries all good
thanks! I'll link to it in the post.
I don't care at all
if you’re talking about a crash, in general it’s all a game of honing in on the problem area. what I do is log the beginning and end of every single function. so now when the crash occurs, you’ll know the problem exists somewhere within that function, say. that’s 95% of the game. from there it’s about going line by line and printing checks. if you’re talking about something other than a crash, please describe in detail what’s exactly going wrong.
What's wrong with this question though? There is nothing exotic about it. It's not much harder than FizzBuzz (which admittedly many candidates fail on), if you know what stack is and what queue is.
You take the type of the first argument and compare it to the rest.
Reproducing in 3000-5000 tries is not so bad! At any good clip of stress, that's an hour between reproduction attempts. I tend to place "bad" at the level of when the mock/stress environment running at full tilt can hit it less than once a week. 
Address Sanitizer does wonders for this kind of bug.
Unless of course it's not supposed to be mutating, in which case it should take a `string_view` instead. :)
I don't understand the negativity I'm getting... all I'm trying to do is share my knowledge with the C++ community :(
&gt; similarly to how worlds most used servers like Apache are still limited to X numbers of clients p/X threads/processes Your making overly general assumptions about apache, its MPM offers many different ways of doing things and isn't exactly the legacy one thread per client &gt; This guy needs to go over to apache lists (and bind9, postfix, etc) and show those noobs writing apache server the right way to do things. If you're new to coding people who endlessly critisize things offering vague referencing and, and of course absolutely 0 source codes , on "the right way" are pretty common... I guess this attitude is why you use throwaway accounts. Spend some time looking at the C10k problem to see why thread-per-connection is not a great system. Not to mention you mention 'similar to a game server', using multiple threads per clients your just going to be fighting synchronization unlike something like Apache which does not have threads talking together.
TTD definitely works with multi threaded applications. The biggest downside of using it for something like this is that the trace files it generates are enormous. IIRC it has fancy compression strategies which reduce the overhead to around 1 bit per instruction executed, but given how fast CPUs are, that's potentially still several GB per minute of execution. 
Well, thanks for replying. I asked this question because many C++ packages uses CMake as build system and lots of those packages are also being consumed with CMake and many IDEs such as Visual Studio, CLion, KDevelop, QTCreator are providing support to CMake as a project configuration. So, CMake is becoming a major C++ standard quasi-building system.
That *felt* wrong, though I would honestly not have been able to explain why without running it. I can't imagine a reason why you would force anyone who derived to create a function which would automatically be called during construction. At that point, I would expect that the derived would perform any initialization in its own constructor rather than relying on some mechanism in the base class.
The thing is that you can never access a derived class member before you are done constructing the base. I think this post fails clarifying this.
I'm a 3rd year electrical engineering student and I'm also currently trying to explore the options one have for C++ development. I started to use vim 2 years ago and started to really love it during the last months. This week I put a lot of time into my setup to tune my YCM, learn how to use CTags and how to create compile data bases with CMake. What is really troubling me, is that I discovered two bugs, that really shocked me. Check this out: [https://bugs.llvm.org/show\_bug.cgi?id=20220](https://bugs.llvm.org/show_bug.cgi?id=20220) [https://github.com/universal-ctags/ctags/issues/1998](https://github.com/universal-ctags/ctags/issues/1998) Especially the libclang bug quite surprised me. People here are talking about working on multi-million LOC code bases and recommend to use vim setups with YCM or neovim with libclang. Still libclang is not even able to provide code completition for protected members of a parent class. It hurts my to say this, because I'd like to believe that vim setups are really nice, but I don't understand how those things are supposed to work properly if so fundamental things don't work. And maybe to mention this too, it's not that I discovered those bugs while some crazy complicated things, but while just writing down the code of a introductionary "Display Image" single file tutorial for OpenCV. I'd very much like to know how people that recommend vim setups deal with those kind of issues. Or is it just that IDE are full of bugs too?
Thanks and the best of luck with it!
This should be a diagnostic if the call is done from any chain of methods called directly by name, in the same translation unit (I.e. not via pointers). It’s a bug in the language spec as far as I can tell. No reason not to force a check. 
[removed]
Your comment has been automatically removed because it appears to contain disrespectful profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/ap0x2g/what_do_you_do_for_hard_to_reproduce_bugs/eg6pf3i/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
You're allowed to provide a definition for a pure virtual; this requires that derived classes override the function in order to be instantiated, but allows for some functionality to exist in the base that derived types may call. This definition may be in a different translation unit.
&gt; The first problem in the "The Payoff" section can be addressed more simply by allowing Python-like named arguments in functions Named arguments looks nice when you call functions with literals which is a really bad idea in many case(and is forbidden in many coding guidelines), the normal way is to use constexpr but then the function call look weird: draw_rect(width=fooWidth, height=fooHeight, filled=true, stroked=false) If you use strong types to distinguish with and height, then it becomes: draw_rect(fooWidth, fooHeight, filled=true, stroked=false) Much better no? Plus it works fine with literals too draw_rect(width{3}, height{4}, filled=true, stroked=false) As for the boolean options: they are bad for extensibility, use enum class instead. That said I like named arguments where types feel too much: when you have a function which draw something between two Points I don't think that therr should be a StartPoint and an EndPoint types.. Here named arguments are nice.
This is what I always say to people "surprised" that these bugs exist. "Are you going to fix it?" 
There is work going on in Buck to generate project files for various IDEs. So far I think they only support XCode and IntellJ. I might be adding support for Visual Studio soon. &gt; CMake is becoming a major C++ standard quasi-building system. The real question is: is this a good thing?
How would you define slow in this case?
&gt; Inside the constructor of Base, the type of this pointer is… Base. So the call to foo() inside bar() resolved to Base version of foo(), which is a pure virtual function lacking implementation. Though it's a virtual function's job to invoke its most derived implementation even when the static type of the object is Base. So the type of the `this` pointer shouldn't matter, should it? I'd have thought the reason this didn't work is that the Derived class' constructor hasn't yet had a chance to adjust the vtable by the time the Base class' constructor is run (since Base is constructed before Derived). 
This should be up voted more. `git bisect` saved me a lot of potential wasted debugging time in the past.
The first edition is very good. Considering how small the changes are between the two editions, this is a great chance for people who have been on the fence to pick up the first edition for just a few dollars. 
You could try to add some short `sleep` at random locations in your threads : for example, whenever something is transmitted via the server, add a short sleep *in the middle of the transmission*. Be creative when looking for places where you add them: your intent is to trigger many more thread switches than during a normal run, and to trigger them at various locations. This is a kind of fuzzing that can potentially make data races much more visible, if you have any. The pauses do not need to be long : even a 1ms second pause is enough in order to potentially cause a thread switch. &amp;#x200B;
I think it's really important that we have tutorial content in different voices, as some styles are easier to read or more appealing to some people than others. Likewise, I'm not sure being similar to Shahar's nice articles is a bad thing—unless you see some plagiarism? 
I was bitten by this once. I had a game with a `being` base class, which contained a `body` member, initialized in the contructor by calling a pure virtual `make_body()` function. This seemed like a reasonable way to do it since a being's subtype determines what kind of body it has, but of course it invoked `being::make_body` instead. However, it was easy to fix. I just changed the `being` constructor to take a `body` parameter, which I constructed in the derived class constructor like goblin() : being{make_body()} {}
That's the point: You usually don't know unless you measure, so I tend to be pessimistic and only use them, when I really don't care. Of course, the compiler will still try to optimize the code, but e.g. code outlining and hence the "cost" of an additional function call is not a completely unrealistic expectation- in particular if your code is still being used several years from now.
It is inevitable that you'll make more mistakes handling memory through raw pointers than a smart pointer would make. Because smart pointers make exactly zero mistakes unless explicitly abused. If you "hope" instead of "know" what a smart pointer would do you need to study them more. It is definitely worth the small time investment.
Two question I'd ask myself are: How much more code do I have to write in C to get to the same result? How much more or less likely am I to write a bug when writing the code one way or the other?
in other words, for all intents and purposes, the type of `this` is `Base` ;)
&gt;Should I maybe consider just learning the C++ way to do things? You will most likely appreciate the C++ features more if you learn more about them. Even if not, that will at least give you the ability to make an informed decision if you consider switching to C.
It's fine. Do whatever fits the work.
You don't "hope" that smart pointer will do its thing. You know it. Being good C++ programmer is to understand the idioms. Once you learn them, you'll stop being afraid to use a collection over C array (and hey, there is always std::array)
I don't think you are thinking about this clearly... &gt;No "hoping" that some smart pointer does what I think it does. Smart pointers behave in a consistent, predicable manner, and solve a specific problem that exists with raw pointers, most obviously forgetting to free memory. If they don't do what you think they do, then that's just a problem with your thinking and you need to learn more and hope less. &gt;Using a standard library collection like a vector or something to handle something that an array will do just fine seems too much to me. Well, no arguments there, if an array meets your needs then just use an array. However, a vector is a different beast that solves different problems, most obviously dynamically adding and removing items. If you need to do that, then vector compares favorably to malloc() + memmove(). Otherwise, feel free to use arrays.
With pointers my issue is that the libraries I use the most, like SDL, use raw pointers, so I'm not sure why I should make my time harder by having to switch between smart and raw pointers. But I get your point, and I'll definitely look into them more, since it seems like I haven't understood them well enough yet. Thanks!
For me it's more like "I want C, but object oriented with a few more bits and pieces", and I feel like C++ has no clear goal, it's just a load of features, so picking and choosing the way you like best seems like the whole design philosophy, no? Yes, the bug thing is true, but I've not run into any major issues using raw pointers, for example, whereas every time i touch the standard library, it feels like nothing quite does what I want it to do, and it's always that one feature that it's missing. Either way, thanks for the guide there, I'll definitely think about it more. 
I also code a bit like this.. I definitely understand the point of actually having control of memory and not just leaving everything to STL. The amount of horrible issues I've seen with unique_ptr etc.. It is an unpopular style but it really depends what you are aiming for. Writing this way is often better for performance critical or heavily threaded code that is for sure. 
After learning cpp at university including all the „fancy“ cpp things you are probably talking about (std, smart pointers, class, templates, polymorphing, etc. etc.) i used cpp for a personal project. I tried to put everything i‘ve learned into it. Few months after i started, i took a look at what i‘ve got. In the end, probably about 20% of what i have written was actually really needed. Point is: ask yourself if you really need the cpp things you are talking about. Just using classes and some minor additions isn‘t wrong either! Think about what you want to achieve with your programm. If an array with some pointers do the trick - good enough! Nevertheless, it is never wrong to broaden your horizont and take a peek into new things.
As long as you know the trade offs, you're fine.
The switch between smart and raw pointers doesn't really make your life harder. You simply have to append `.get()` where you want to use them as raw pointers or `.release()` to pass them into a function that takes ownership. Slightly more verbose, but also self-documenting. And you get rid of your `delete` statements not to mention the awkward clean-up code in case of multiple pointer initialization through methods that might return error codes or throw exceptions.
I meant those questions honestly: If you write less bugs by sticking to c-style c++, then stick to it (or invest the time to learn c++ "properly"). All of that is off course somewhat dependent on whether we are talking about your own private projects or about code that had to be read / modified / used by others.
C++ is definitely considered way too feature heavy by many developers, especially C developers. It’s really easy to write terrible C++ and it’s also easy to write C++ in a wide variety of ways, which makes maintainability amongst developers a bit more difficult. I’d recommend just writing C if you’re not relying on any C++-specific behaviors beyond classes. You can encapsulate data and function pointers into structures in C.
*I wanted to know what other developers think about that sort of style? Is it "okay"?* Yes. "C-style C++" is pretty common. But C++ is one of those languages where there are 1001 opinions on how to write it and none of them are particularly authoritative (unlike in languages like, say, Ruby or Python where there's usually "a way" to do things and a style to follow to fit into the community).
It's not making your time harder, it's making sure you understand the ownership.
Vector also frees the memory, and establishes a consistent ownership paradigm consistent with default generated special member functions... Even if your only need to populate it once that's very very far away from being a case for malloc/free.
Can you give an example of horrible issues you've seen with unique ptr? Or why you think writing this way is often better for perf critical code?
"C with classes" isn't a good way to write code. "C with simple templates, more type-safety, and maybe a few classes if you would otherwise reach for GObject or a ton of `stuff__do_thing(struct stuff*)` methods" is fine. You can use C++'s additional features in order to cut out things like macros (especially macro-based generics and code generation), function pointers, direct manual memory manipulation, and ad-hoc namespacing, but still structure most of it like C. &gt; My argument is that it's always very easy to fix issues and you can handle every part of memory yourself. It's even easier to create them. Are you sure that you correctly handled every point where your fixed-size arrays could run out of room, or your dynamic arrays need to be reallocated? You can be if you always use `vector&lt;T&gt;::push_back`. Are you sure that that pointer will eventually be deallocated and not leak memory? You can be if you store it in a `shared_ptr&lt;T&gt;` and avoid cyclic references.
Usually it is when people use unique_ptr together with threaded code and it introduces really nasty stealth bugs when reset() is called that are very hard to track down. For perf critical code it is mainly just the ability to actually see where allocations are happening. You CAN use STL in a way that doesn't allocate a lot for no reason, but you have to be very careful i.e. always calling reserve() on vectors, always passing strings by const ref - generally speaking it is just easier to not use STL or a performance concious alternative of it. 
^ this. . @OP: . A unique_ptr encapsulates the pointee's lifetime to the ptr's lifetime (it goes out of scope, the pointee gets destroyed). Can't be copied, but can be moved. . A shared_ptr just adds reference counting and allows you to copy it. As soon as the last shared_ptr pointing to some data goes out of scope, that data's destructor gets called. . Then there's weak_ptr which is basically a shared_ptr that doesn't affect the reference count; useful for breaking cyclic dependencies or if you want to store references to various instances of some object but not affect the lifetime (e.g. some Factory-like class that keeps tabs on the instances it produces, and instead of potentially creating duplicates for the same parameters checks if there already exists an equivalent instance—and if there is, it just checks if it has expired, and if it hasn't, it calls lock on it to create a shared_ptr from the local weak_ptr. . It's with owning raw ptrs that uncertainty is introduced, IMO.
There's absolutely nothing wrong with it. ignore the script kiddies and webshits that are trying to make C++ into pyuby.
This.
If you don't know how you want to structure your project yet, picking C++, but writing as C and refining it over time to be more C++ with the guarantees that make sense as you discover the needs of your project then that is fine. C++ has many clear goals. What matters is the goal of your project, and what sorts of abstractions and guarantees that you find necessary to enforce certain structural and behavioral invariants across your project. Those are revealed or chosen as the project progresses. With just C alone, you are drastically limited with your options. Also don't become too confident in using raw pointers. There is a "tepid" way to use them, in which it's easy to never let yourself get in a bad position. But that is an internalized fear that over restricts your usage, by basically avoiding having to take on the cognitive load that a more free use would demand. Try to learn and understand what is behind a pointer in C++, what sort of pointer a thing is, and what it offers you. I still think learning C first is better and helpful, and there is no shame in avoiding classes, but you should explore when and where C++'s many features would be appropriately used. Namespaces alone make C++ far preferable for any sizeable project, and that's just one example.
Oh boy
Using raw pointers wouldn’t make your code anymore thread safe. You describe being careful for performance because if you are unaware, using certain STL types may introduce additional resource overhead. The flip side is using raw pointers may introduce additional *bugs* that you have to be careful of. You are trading a greater possibility of bugs for a greater possibility of performance. 
&gt; I tried to put everything i‘ve learned into it. Classic mistake
Not sure what any of that has to do with unique_ptr. If you are not calling reset, you are calling delete on a raw pointer + assigning a nullptr, which can lead to the exact same problems. 
Yeah, I feel like for the projects I am doing right now, the C style of doing some things is making development quite fast and bug-free. But I do now feel like I should learn the C++ way properly, just to be sure that I am choosing the right tools for the task.
I think the best strategy to address questions like these by asking: "Am I using the right tool for this particular job?" This philosophy can be applied to a lot of things, even outside programming. The aforementioned "tool" might be choosing the right programming language; or in your case, choosing the right *language features* for the job. It's okay to write C code in a C++ environment, if there is an actual need for it. Typically, the need would arise when you are interfacing with a C library, or wanting to provide an C interface for your C++ code, or when you have ported legacy C code into a C++ environment and you don't have the time and resources to do a complete rewrite. Economics can and often will dictate such choices. However, if your goal is to learn C, then perhaps moving over to a pure C tool chain would be advisable. It is true that you can write C-like code in C++, but there are still few differences were the C same code would yield undefined behaviour in C++, and vice versa. Conversely, if your goal is to learn C++, and use its language constructs, then you should prefer learning the C++ in the most idiomatic way possible. C++ is a complex beast, but the good news is that you don't need learn every arcane detail straight away. Just pick up the best features C++ has to offer, the best practices, and learn about the few gotchas. I suggest you to check out [C++ Core Guidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md) for such matters. Search for Kate Gregory on youtube. She has a few good lectures that might interest you, [especially this one](https://www.youtube.com/watch?v=YnWhqhNdYyk). 
Have you looked at Rust?
That "feature-heavy"-ness has been what kept me away from learning "the C++ way". Because whatever problem I look up, I find at least three different ways to do it, and I have no idea what these features do in the background or how fast they are compared to each other, so often times i end up just looking for the "most C" solution and do that. Glad to hear I'm not the only one thinking that C++ is too feature heavy in many areas.
I feel like at the moment I am doing exactly that; using C++ because I'm not quite sure how much of the "++" I actually need. Thanks for your input
To be fair it’s really easy to write terrible C, as well. 
Thanks, this helps me a lot. I am so used to being able to just look up "how to correctly do this and that", and with C++ it's been kind of demotivating so far, a lot of answers that I don't understand because I don't know those specific 100 pages of the standard library documentation. Exaggerating here, of course, but there really are a lot of opinions and a lot of ways to do things, and it all leads to me just sticking to the way I know and avoiding the whole C++ feature list even more. 
Yeah, this is exactly what I have gathered from most comments here. Do it the way that works best, but also learn the "fancy cpp way", so you actually know what you *could* use.
&gt;whereas every time i touch the standard library, it feels like nothing quite does what I want it to do, and it's always that one feature that it's missing. You really should consider this a rather large chunk of ignorance over any other conclusion you might be tempted to gleam from it. Maybe look into and learn how these components work, because they are VERY well defined, predictable, and about as extensible as any piece of code I've ever worked with. It's got a huge number of extension points... There are certainly parts that suck, and they're being addressed over time, but as a whole the standard library is one of the best API's I've ever used. But sure, write whatever the hell you want. I don't know why you'd put up with the C++ compile times just to get OO though.
I feel that as you are learning, you should write in whatever way you feel comfortable. Do you like the convenience of C++ classes and inheritance but don't wish to use most of the STL or template meta-programming? That's fine! If you want to deepen your knowledge of C++ specifically I would encourage exploring those areas eventually, but plenty of competent software has been written the way you describe. Doom 3 was written this way, and it is considered a very beautiful code base: https://github.com/id-Software/DOOM-3-BFG/blob/master/doomclassic/doom/PlayerProfile.h#L53 Also remember that "beauty" is subjective. Some folks are going to despise what others may hold as best practice. Have fun, learn and work your way!
My point with the smart pointers is that I know exactly that a `*` pointer works for pretty much every case, I know what it does, I know how long it lives, etc. When I get into smart pointers, there's always a bit more thinking to do whenever I change anything. "Does this change mean I should make this into a *whatever*\_ptr to make it faster/better/whatelse?" "Does this change break my program? Better read up on the documentation!" "Do I use *this* one here? Or probably better *this* one?"
c++17 for that. Since MS can't write a performant threaded malloc implementation worth anything I'm currently stuck with 2015 as the compiler on that platform. I really wish it was easier to cross compile for windows from a real dev platform (linux).
P.S., I sometimes revert to pure C for quick quips and tools mostly as an academic exercise. There are fields of development where C++ isn't appropriate, e.g. the core Linux kernel and many embedded systems SDKs. I am in the camp that being a competent C programmer will make you a better C++ programmer.
I like to think I know a decent amount of template programming, but I’ve only really needed to write templates or constexpr a few times. Most of it was learning “in case I ever needed it” and learning to read the infamous template error messages. A lot of it is for programmers writing frameworks and libraries and larger systems. For an application meant to do a specific thing, you would rarely touch them. Ironically there’s tons of meta programming and quality of life ideas that would make things easier for everyone, but those tend to break a lot of backward compatibility, so you only get these quirkier corner case additions that don’t do a lot for the average person but also keep legacy code working as expected. 
I've never had such a hard time tracking down the issue when it was an early delete or double delete though - the crash always has an obvious cause in the debugger, though to be fair I am not sure why unique_ptr seems to cause this random memory corruption in other areas of code. For the record I am talking about fixing other peoples code, since I don't use unique_ptr if I have any control over the situation. 
If you're not going to learn the c++ standard libraries I would recommend leaving c++ off your resume. If you were to say to an interviewer that you code in c++ and then not able to do a simple std:array push_back, then you're probably going to lose all credibility. If you're going to say that you're a c programmer, make sure you know the differences between c and c++ code because they both have some basic fundamentals differences because the c++ compiler is a lot more lenient compared to the c compiler. 
Yes, I know that the standard library is reliable and fast. My problem is that it feel like it's somehow mandatory to use it. There's not a lot of good learning resources out there teaching the standard library features *well,* and it's so much stuff you will never need that it's very demotivating.
No, I have not! Maybe this is a good time to do so, though.
You can capture C resource pointers in a `unique_ptr` and give it a custom deleter that releases the said C resource. For example, here is how you can automatically cleanup the resource returned by `SDL_CreateRenderer()`: using RendererHandle = std::unique_ptr&lt; SDL_Renderer, decltype( &amp;SDL_Renderer ) &gt;; auto renderer = RendererHandle { SDL_CreateRenderer( /* Supply params here */ ), SDL_DestroyRenderer }; Not tested, but that is the rough idea. You might be able to use a cleaner C++ syntax, but I haven't explored that yet.
Step 1: Find your nearest goat farmer and buy a black goat. It has to be completely black. If it's got a blemish you're just killing a living being for nothing. Step 2: Hang the goat above the test server and let it bleed out over it. This will likely destroy the system but the hard drive should survive. If it doesn't, see the above requirement as you probably thought some grey hair or something was OK. &amp;#x200B; Step 3: Purchase new hardware to rebuild the system on. The first was a sacrifice and it's important it's as top of the line as you intend to use...or again...this won't work. &amp;#x200B; Step 4: Remove the goat's eyes and smear over the new server. &amp;#x200B; Step 5: Begin your test run as you cross your arms over your chest and chant, "Schroedener help us poor sinners," for 24 hours. Step 6: Cry because you're still stuck examining post-mortem logs and core dumps.
Thank you! I'll look into those videos
A lot of the time you can actually do everything without allocating at all if you just don't use STL (especially true for strings of known length), and in this case optimizing just means re-writing anyway. Of course having correct code is more important, but I am assuming OP knows how to code correctly. 
Depends on what you’re writing. I would write high performance stuff as “C with classes”, but managing a large code base like that is going to be difficult and tedious. If you’re comfortable with it though, then go ahead. Who gives a fuck what programmers on reddit think?
&gt; It’s really easy to write terrible C++ Using raw pointers that own memory is terrible C++
One big consideration: **Exceptions**. Are you planning to use exceptions? If yes, then "C with classes" style will lead to resource leaks. Exceptions are an (arguably) excellent way to make a program more readable since they allow writing the handling of exceptional code paths somewhere upwards the call chain instead of manually propagating the error state through every step of the chain. However, **exceptions are an all or nothing deal**. Unless you can prove that your function calls never throw, then you can never assume that there are no exceptions. And if you cannot assume the lack of exceptions, then you can not have C style resource acquisitions that are not protected by a destructor. Then again, I presume that your answer is likely "no, I don't want to use exceptions", since you want C. Even so, are you planning to use C++ libraries? Because most of those use exceptions. This includes much of the standard library, which you mention being one of your reasons for wanting C++ in the first place. I've read about people who use C++ in a compiler mode which disables exceptions. In this mode, writing C style is not so much of a problem, and may be a good choice for you. But you cannot use libraries that haven't made the same choice. &gt;The biggest thing is that I use raw pointers everywhere, and very little use of the standard library. &gt; &gt;I wanted to know what other developers think about that sort of style? Is it "okay"? It kinda depends. Are you re-implementing algorithms, data structures or utilities that already exist in the standard library? That's not much appreciated unless you have good arguments for doing so. Raw pointers themselves are OK. But if the raw pointers *own* resources, then it can often be very hard to prove the correctness of the handling of the resource - especially if there can be exceptions. &gt; My argument is that it's always very easy to fix issues It's sometimes very hard to find out that your program has issues in the first place when attempting to manage memory without RAII. Programs can appear to work just fine only to suddenly break when you least expect it because of undefined behaviour. &gt; No "hoping" that some smart pointer does what I think it does (Edit: this of course comes from not quite understanding all of them and which one to use when) There are only two standard smart pointers (ignoring the third one which is obsolete and no longer useful). Indeed, C++ is a language where one must learn intricate details and caveats before you can write safe and meaningful programs, and smart pointers are no exception to this. They are however quite simple to understand in context of the entire language. &gt; Using a standard library collection like a vector or something to handle something that an array will do just fine seems too much to me. By all means, if an automatic (or static) is sufficient, then there is no need for a vector. Thats what I would do, and I consider my style very "C++". But if you need dynamic allocation, then there is no need to make your life harder by not using a vector.
You’re conflating ease of grepping for an invocation and goodness of the code. However, this is personal bias for the same reason as yours. In my experience, it was far far easier to debug code using unique ptr than raw pointers. With raw pointers I had to manually trace ALL copies of the pointer to see who was actually deleting it when. With unique ptr I only had ONE code path to trace through, assuming I didn’t find someone misusing it. 
Using bare pointers in C++ is fine if you "loaning" access to a pointer. However, if a piece of code "owns" a pointer, you should almost always use a std::unique\_ptr. It is zero-cost compiler-checked documentation for pointer ownership. Ownership changes are made visible via std::move() or .release(), making the code much easier to maintain. If a fixed-length array meets your needs, you might also find std::array useful. It is basically a drop-in replacement, but the length information will never decay away due to being passed through APIs etc. Note that std::unique\_ptr works with both std::array and dynamically allocated arrays: std::unique_ptr&lt;int[]&gt; sizes(new int[4]); auto sizes = std::make_unique&lt;int[]&gt;(4); // C++14. auto sizes = std::make_unique&lt;std::array&lt;int, 4&gt;&gt;(); // C++14. When `std::make_unique` is used consistently, you should almost never need to explicitly new/delete or malloc/free. This is also good training for taking advantage of RAII in other ways, e.g. freeing file descriptors etc.
Sure it is, but at least a reader familiar with the language will generally be able to see what’s going on.
&gt;I make an internal logger to record events and state that might give me insight into what led to the problem. The logger has a fixed length of what it keeps, say the last 100 things. At some point where I can detect that the problem has actually happened I trigger the logger to dump its contents somewhere I can retrieve it. You roll a natural 1. Logging puts the bug into hiding. Management is convinced you fixed it and makes you move forward. Blows up on the first major sales pitch.
Of course I am able to use std::array, but my question is whether I want to use it everywhere.
If you're working with a team, then that would be a yes. If you're programming alone then that's up to you. 
Exactly this. When you `new` and `delete` things yourself, and shit inevitably goes wrong, your debugger or even just reading your code will find the problem quickly. If something breaks because of a smart pointer, good luck even figuring out *what* broke, and *where*. 
You don't have to abide by what someone else tells you to do. It's a programming language. Use it how you see fit
Fair. Thanks!
Yea, to be clear, I am absolutely a proponent of the simplicity of C, both for education purposes and for applications that benefit from it. Additionally, there is definitely less cognitive load when you are actually working on low level applications. Sometimes you really just want to manipulate bytes and pointers and do math. C++ is just a really big language, it inherently takes more effort to learn just compare the two standards. If you don’t need it and don’t want it, don’t use it. 
No I was strictly talking about debugging. unique_ptr issues caused corruption in random areas of code in a huge project, that is why it was hard to track. Also, you can overload new and delete (even globally) and make it print logs if you want to track those too. 
The one thing that I like when writing C-like code in C++ is the stronger types. C likes to view pretty much everything as an integer. Two enum types? Nope, one global integer type and enums are more or less the same as making macros for the names. This means you can easily pass the wrong enum type to a function and that results in a deep-seated bug that might take you a while to find. So what do I do to solve this in C? I wrap a lot of functions in macros that add the correct suffix to an enum symbol to make it into the correct enum type. Similarly, value that are single integers but I want to be distinct types I wrap in structs. All these things are just to compensate for C's weak type system, things that I don't have to do in C++, especially modern C++. And then let's talk about encapsulation. In C I'll often define a type as void\* to the user of a type and as the actual pointer type inside the module. This allows me to encapsulate the implementation of a module but still allow the user to carry the state with them. But that means I can't pass state as a value and it honestly feels like a hack. C++ has this baked in, of course, so even if you're not going full object oriented then you can still use encapsulation effectively without having to resort to things like this. There are just so many reasons to continue using a subset of C++ that there's probably no reason to switch to C from C++ unless you have some other requirements. &gt; My argument is that it's always very easy to fix issues and you can handle every part of memory yourself. No "hoping" that some smart pointer does what I think it does You should learn how to use shared\_ptr better then. There are very few times that I really, really want absolute control over memory. Abstractions are a good thing when it comes to memory management and correct use of those abstractions will make your life easier. &gt; Using a standard library collection like a vector or something to handle something that an array will do just fine seems too much to me. Arrays are nice, too. No one says you have to use everything C++ has to offer. Some people ignore the STL entirely and go with their own subset of data structures. It's up to you, use what you think is best, and what meets your requirements. 
Fizzbuzz is nonsense on purpose because it is used to weed out total frauds. This question is just nonsense. Have you ever made a queue out of two stacks for a job?
Dude honestly C++ to me is like a guitar you can either learn/use it the nerdy way with proper form and all of that, basically the perfect ideal way to do stuff with it, or just feel it out and find what works for you even if it might not be "proper". Don't sleep on all the fancy modern C++ stuff like it's definitely worth it if you wanna put the time into learning it but also don't feel pressured to use those features in personal projects if you genuinely don't want to. When it comes to personal projects you gotta write code that personally makes you happy and no one else, prioritize your own happiness above everything else friend
As much as I like C and C++, honestly Rust is designed more sanely for 90% of use-cases. HOWEVER there is definitely magic you won’t be comfortable with, like how pattern matching gets compiled, and its reference collapsing will make you squirm. Given that, I prefer a lot of its ideas, like no classes, just “traits” you can give a type, explicit lifetimes (which are usually subtle bugs we don’t notice in C/C++), and almost everything being an expression (it’s a lot nicer to directly assign a variable from the “result” of an if-else chain than defining it before, and hoping it got set inside). 
Everyone has tastes of their own. I found it fascinating enough to learn how a lot of it works inside, and how and why they did what they did. You're obviously different. But you might want to note that your entire response was to just defend your state of ignorance. I could direct you to GREAT resources on those topics...but you seem pretty locked in and I'd basically just direct you -&gt;
I use an extremely fast in memory logger with a lock free q so that doesn't happen. I don't have to roll.
I use Sublime Text 3 as an IDE. (also Clang++-7 as my compiiler, a Makefile, compiledb to generate a compile_commands.json file during building, clangd-7, clang-tidy). For plugins, I use: 1. GitCommitMsg, GitGutter, and GitSavvy for Git integration 2. LSP (running Clangd-7 as its server) for "Intellisense"-ish stuff 3. GLSL syntax highlighting (for shader programming) 4. Origami for panel/view stuff 5. Sourcetrail plugin for integration with Sourcetrail (for code analysis) 6. some C++ code formatters and linters (a clang-tidy one) Plus some cosmetic plugins and tweaks as well as a few quality-of-life ones (like non-universal zoom, PackageResourceViewer, etc). So, I can easily do anything git or build related from within ST3. And my makefile doesn't need any alterations, it just scans the project folder and does everything automatically. And any compiler warnings both link to the lines of code affected as well as embeds the errors and occasionally offers suggestions depending on the error. Currently I'm using this setup on a three man 3D game engine project, where the other two use VS on Windows while I develop with Clang on Debian. 450+ commits in and still no issues, clean rebuilds usually take ~15-20s on my laptop, and partial builds usually just take a few seconds unless there's been some major overhaul. And it's a nice bonus that I can just copy my plugins and template and work on any OS (with the small caveat that I might have to make an OS-specific keybinds config; and I'd have to make a few tweaks to the makefile to make it do a platform check). If anyone is interested in screenshots, more details, the makefile or whatever just hit me up.
The answer? It depends. If you are wrong basic applications? You are going to need to write more code than you may realize. C let's you do anything you tell it to do, it's a double edge sword. I love the language but I only write c when I'm doing systems level programming. For tools and scripts, I prefer to use python.
I've written C. I've written C++ code with full STL everything. I've written a mix of both worlds. I used to drink the OO kool-aid, but after working on several major projects in C - and seeing how they were successful when the received wisdom was that coding that way was too complicated to succeed - was enlightening. Half a million lines of code, two dozen developers, over two decades and it has been very successful with very few bugs. Contrary to popular opinion, there is no one right way to code. You have to look at your project at the start and decide how much abstraction and indirection is important, as well as how things like memory ownership will be handled, and then pick a modality that will work for you. I'm currently working on a project that is taking about 3x longer than necessary to code due to all the levels of indirection and abstraction due to "proper" OO design. Maybe it will be more maintainable and readable in the future. It's unclear if it will ever pay itself back. 
I would agree, except I would recommend std::array over C-style arrays. C-style arrays have basically no redeeming features. I think they should be a compiler warning. 
You don't have to explicitly abuse smart pointers to have issues with them. An easy example is a new programmer building a doubly linked list using shared pointers. 
Wouldn't it be more efficient to make a functor type that wraps `SDL_DestroyRenderer` to avoid making all instances the size of two pointers?
This is boolean algebra, not C++. Google it.
I guarantee you your development is not bug free, and whatever you think is fast development you are probably implementing things that a C++ compiler (and a domain specific library) already takes care of, in a much more bug-free manner. Judging by your other comments, I think you're mistaking "fast development" for "not having to spend time learning about a C++ feature". Sure, you can get code down quickly if you don't learn better things, but you'll be writing that same code over and over again, instead of letting the language and libraries handle help you avoid repeating yourself. Sticking with C, or jumping ship to Rust, won't help you get over the attitude of not wanting to have to learn things. You're going to have to learn, whether you like to or not.
https://en.m.wikipedia.org/wiki/Truth_table
Reset is equivalent to a delete call. If you have threaded code and you call delete on one pointer while another pointer still exists, you'll have the exact same problems. At least with modern code, based on whether a pointer is raw or unique_ptr you know whether it's owning, and it makes you at least think about whether some code with a raw pointer or reference is safe to assume that the object it's pointing to will continue to exist. Also, the best way to write performance conscious multi threaded code is to make use of the atomic primitives in the STL, so your comment is especially strange. As far as performance critical code goes, it's pretty easy to understand where allocations can happen in a container like vector. It's no harder to say "this code path shouldn't have push_back" than it is to say "this code path shouldn't have malloc". Similarly, it's not exactly hard to remember to pass strings by const ref (even easier in even more modern C++ where you are passing string_view). On the flip side, passing const char* all over the place can make things like concatenation or even comparison significantly more expensive on average. I write code such that there are absolutely zero allocations allowed in the critical path and I've never had a problem with using vector there, and only had very specific and rare issues with string. I don't think the things you've outlined here are real problems.
unique_ptr's destructor calls delete, you know. When you sit down and debug things, it shows up in stack traces, exactly the same. It really doesn't make things any harder, even once you are sitting down to debug. When you new and delete yourself there are just so many opportunities to write bugs, everyone will write bugs a decent fraction of the time, and you'll have a real mess. I've been writing with smart pointers in C++ for 5+ years, and I've never seen a codebase that used them consistently have any issues with new/delete. Just none, zero. There are of course other memory issues, but as far as leaks and double deletes go, once you start using smart pointers consistently they just don't happen. I honestly just don't understand what you, or other people, can find objectionable with unique_ptr in particular. It just makes life so much easier, it's so simple to understand, far harder to misuse than a raw owning pointer... It's just fantastic.
I would say a C compiler is more lenient than a C++ compiler. No need to cast between void* and the actual pointer type for example.
&gt; c++17 for that Not _terribly_ difficult to write a stand-in that does 90% of what the official C++17 one does, fwiw. I've had `string_view` littered across code bases well before C++17 was a thing (and without the monstrosity that is Boost, too).
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
[Item #9](https://www.aristeia.com/EC3E/3E_item9.pdf).
“And avoid cyclic references” - that’s a pretty big catch, as those are extremely difficult to debug. Regular leaks are easily introduced, but can at least be easily debugged with tools like valgrind. 
You are free to write C++ however you like. C++ explicitly tries to support multiple different programming styles, across vastly different architectures. That said, if you want to write with C++ classes and the STL, C++ has things that do C things better. C++ recognizes that raw pointer manipulations have been the cause of many, many security issues and bugs, and so offers many things to try to mitigate them (iterators for pointer iteration, unique\_ptr for ownership / RAII, collections, references for non-nullable pointers, new / delete instead of malloc /free for type-safe allocation, etc.) Understand that you'll be leaving a lot of useful tools if you walk away from decades of C++ work, and that historically, C code has allowed many CVEs to happen simply by virtue of being difficult to always get right. Certainly, there are times when you absolutely need C code in C++. (Microcontroller code, without room for a heavyweight memory allocator, has to forgo any stdlib collection and often uses static, flat arrays and pointers.) But that should not be an excuse to *always* use it. And if you work with a team on C++? More often than not, teams will lean on the language's features to reduce bugs in large software. I've recently worked on a project which didn't use STL containers (allocators), but allowed stdlib features if we understood how they worked. The standard library isn't (all) black magic. Many intelligent people have worked to make the stdlib work in many circumstances. And if you're not convinced? Become a C developer. The Linux dev community (and Linus Torvalds) will always appreciate a C programmer who hasn't fallen to the temptations of C++.
Don’t mix raw pointers with code that can throw exceptions, including containers from the standard library. It’s almost never safe and will result in leaks.
When you specify a custom deleter of type other than `default_delete`, `unique_ptr` will store two member variables, no matter what; one for the managed pointer and the other for the deleter callable object. This also true if the deleter is a lambda. Under normal circumstances, `unique_ptr` has zero overhead, because `default_delete` is implied at compile time and doesn't need storing. 
No they won't. They suddenly find themselves having to learn the project's own way of doing things over an already standardized, efficient solution. You mention encapsulating data and function pointers into structures in C. That's already a solved problem. But no, you force the developer to have to learn yet another homebrew object system with its own litany of cleanup bugs and performance hacks. So no, the reader familiar with the language won't see what's going on.
They’ll know what’s going on at a purely language level. Obviously every codebase is going to contain its own unique structures and logic, otherwise it wouldn’t need to exist.
What is the error?
And if you are stuck in the past with pre- c++ 11 tools boost::array fills that gap. 
vector also uses heap memory as opposed stack memory used by array / std::array. With desktop computing, stack is no longer a luxury but if you don't keep track of stack size, you can run into stack overflow. So my preference is to use heap for anything non-trivial in size, which in turn means using std::vector over array for me.
So what you're talking about is called mixing, and it's seriously not hard to develop. it'd take you maybe a week to create your own mixer.
Less compile time overhead.
Most situations don't require shared\_ptr in the first place, unique\_ptr will do just fine. shared\_ptr or no shared\_ptr, cyclic references require special handling. Understand weak\_ptr and it's relation to shared\_ptr, and you're good to go.
The deleter could potentially have zero-size if it's stateless (and the unique_ptr implementation utilizes the [empty base optimization](https://en.cppreference.com/w/cpp/language/ebo)).
&gt; Usually it is when people use unique\_ptr together with threaded code and it introduces really nasty stealth bugs when reset() is called that are very hard to track down. Not sure I see your point. The same bug would be present if you called delete at that location. 
&gt; I've never had such a hard time tracking down the issue when it was an early delete or double delete Key point to realize is that if you were using unique\_ptr, you wouldn't have had an early delete or double delete in the first place.
Ah yes, you're right, that works for ordinary function objects, but at the cost of extra boilerplate. I don't think you can do this for stateless lambdas though, as `decltype` on lambdas is forbidden prior C++20, so you'd have to use a C style function pointer for the deleter. Also, if you can void it, why bother wrapping stuff with lambdas and function objects, when you can just pass the C function directly without the extra baggage? The cost of a function pointer is well worth the benefits of code readability.
Yours has the boilerplate of having to supply the deleter function every time you create a new unique_ptr... I think the solutions are balanced on boilerplate. Additionally, mine makes pointers half the size and avoids an indirect call in the destructor. I think it's a clear win.
You still have to track all copies though, to make sure there is no use after free. 
Do you remember, what the bug was in the end/ how you fixed it?
If you want object-orientedness, perhaps use an entirely different language. C++ is not a specifically object-oriented language. It has some support for OOP, but it supports many other programming styles as well. Many programs and libraries don't use any object-oriented features of C++ at all. Main features that make C++ stand out from the rest are RAII and templates. If you are not using these, you might well just abandon C++. 
Quick question, Do iterations over groups/views get vectorised? 
If you’re using OO, then don’t beat yourself up, you’re halfway there! That said, the general rule is the assume that the STL was written by someone better than oneself (because the collection of minds that created it will always be better than one single thing). You can let go and trust the STL with confidence :) I recently took the plunge to properly understand and use smart pointers; so very glad I did!
Since there are many people here who buy heavy into object orientation and smart pointers, I want to leave a comment to show that there is a different way doing it. People like Casey Muratori or Mike Acton use C++ as „C with function overloading and syntactical sugar“, and it works very well for them. You definitely dont need smart pointers to write good code, neither exceptions or object orientation. So while the majority of C++ programmers would probably strongly dislike your approach, there are people who fl something similar to it, who are very skilled and experienced. A note on C: the syntax differs a bit, sometimes bad (typedefs when you introduce a struct), sometimes good (struct member initialization).
Almost all STL containers are ill suited for high performance code and there is very little you can optimize except to completely replace them (custom allocators can help somewhat depending on the container type and the situation, but are imho a royal pita). What people forget is that performance is sometimes not just nice to have, but part of correctness too: if it is too slow it may be just as useless as if it wouldn't run in the first place. Also, turning slow code into fast code is not necessarily easier than fixing buggy fast code. In many cases, it may actually be more difficult, because you have to completely rewrite your code. So while I really dislike the irrational fear of the standard library that some people show, let's not automatically assume that the STL (in particular it's containers) is a good fit for every problem and that code using the STL is automatically of better quality. 
This is more of a style choice than anything else. That said. std::array has zero overhead and allows you to track length as a compile time constant, which saves you tracking length in a variable. std::vector will probably out perform manually reallocated arrays and be less error prone. std::unique_ptr also has zero overhead if you're not using a custom deleter and makes it *much* harder to leak memory. The standard library gives you some excellent, thoroughly tested, tools to work with. You don't have to use them, but there aren't that many reasons not to do so.
There are only three smart pointers in the standard library to begin with (99.9% of the time you only need unique_ptr anyway), it is fairly obvious when to use them in the first place (owning pointers) and their semantics are pretty straightforward. If they seem to be such a mystery to you you should probably spend an hour or so learning about them properly. 
If your compiler is smart enough, yes. :-) I mean, it seems eg g++ and clang are good at doing it. On the other side, msvc falls behind when it comes to compiling template machinery. If you want to have finer control on these aspects, remember that EnTT offers a couple (T*, size) in most cases. The documentation contains all the details btw.
Smart pointers aren't magic things. They call delete, just as you would, so I don't know, why they should be so hard to debug. Can you give a concrete example?
The common joke is that when you write code only you and God know how it works, two weeks later only God knows anymore. Think about a complex project where a resource is owned by one entity but observed (through a pointer) by another entity. If the system is complex enough, and it's been long enough since you wrote it, you might wonder which class is ultimately responsible for the resource. At this point you have to dig through potentially non trivial code to find the owner. Unique_ptr solves this issue by making it explicitly clear which pointer owns the resource and which pointer only observes it. No digging through complex code or second guessing needed. This is the reason to use unique pointers, not magic, not complex scenarios, simply making ownership clear and readable long after you forgot how the code works. As for vectors versus normal arrays, they are not equivalent. If you can do it with a normal array then std::array is the replacement you want. It has the benefit of never losing its length information.
Which is little consolation, because only the whole codebase matters. If your language requires you to reinvent everything from the wheel everytime, that increases the size of your codebase unnecessarily. Your "language level" gives rise to a monstrous code base level, which is worse.
No, you are literally hitler.
If you're going to submit all three parts within 24 hours of each other, just submit it all in one go
“shared_ptr or no shared_ptr, cyclic references require special handling” - sure, but only if you’re using refcounting, which for simple scenario’s is overkill. “and you're good to go” - no you’re not. The relationship between shared_ptr and weak_ptr is easy to understand, but knowing when and where to apply weak_ptr is far from trivial.
Compared to most other languages, I'd say the standard library is rather small (or at least com pl aere to the set of libraries you are working with on a daily basis). You know about cppreference.com right?
Regarding the assignment from an if else: I'd like to have the same feature in c++ too, but if you wrap your code into a lambda, you get almost the same result already (plus the mandatory syntax noise in c++)
How is that different from c++? Or are you actually complaining that someone who is only familiar with c is not able to see what's going on in c++?
I share here the same comment I posted to the blog. Some time ago I needed to do a "strict" overloaded which breaks on any implicit conversion. For example: ``` overloaded ov{ [](int i) { cout &lt;&lt; "int " &lt;&lt; i &lt;&lt; "\n"; }, [](string s) { cout &lt;&lt; "string " &lt;&lt; s &lt;&lt; "\n"; } }; ov(10.0); // implicitly converted to int ``` The easiest thing to do was just adding a catch-all lambda, this way: ``` overloaded ov{ [](int i) { cout &lt;&lt; "int " &lt;&lt; i &lt;&lt; "\n"; }, [](string s) { cout &lt;&lt; "string " &lt;&lt; s &lt;&lt; "\n"; }, [](auto...) { static_assert(false, "not supported"); } }; ov(10.0); // fail ``` Do you have any other experience or recommendation about that?
Are you then also someone who prefers to write your own json library, because it is too much effort to learn how a well established one works? I mean sure - there is certainly a point where the overhead of learning c++ outweighs the benefits you get from it for a specific project, but on the other hand, that effort amortizes over the projects you work on.
Write code in the way that suits you best. Writing code in some other dialect will always be less productive and less fun than what you do by yourself. Keep challenging yourself to look at your code and see patterns of either bugs or duplication. Look for solutions to both - you'll often find something in C++ that's a behavior/culture fix on C to avoid whole classes of bugs and duplication. Keep learning.
I think you can just write \[\](auto x) { ... } the overload with "auto" will be selected as the last resort if the previous match fails. I think I wrote about something similar in [https://www.bfilipek.com/2018/09/visit-variants.html](https://www.bfilipek.com/2018/09/visit-variants.html)
STL vector is well-tested, easy to use. Unless there is a reason/constraint forcing you to avoid, using arrays instead of vector just because you are more comfortable with arrays is bad practice. Assuming obviously, you do not need a fixed-size container. Switching to c isn't going to help you solve any potential problem that comes with writing c-style code. You shouldn't switch to c, you should learn idiomatic c++.
I agree that if you're using a widely used and tested library (possibly folly or EASTL) instead of the STL and can understand why you're doing that, that's fine. But in the absence of that, if you're not using the STL then I'm prepared to say the code is automatically of worse quality. &amp;#x200B;
I work for a company that does a lot of C but some teams and projects have been running modern C++ for a few years now and hands down the C++ code is more reliable. When your codebase is large and complex memory leaks are inevitable and very hard to track down. It really sounds more like you’re just a bit scared of modern C++ because you don’t understand it. Everyone has their own style, personally I can’t stand C anymore, but the old saying “you can write shit in any language” is very true. To me C style is very procedural so the fact that you like classes would make you a filthy C++ developer in the eyes on some of my colleagues. Still I don’t think you need to change your style much. Just learn about ownership and how smart pointers work. You can pass raw pointers around all day if you want but in modern C++ you should never have to use new / delete yourself, and definitely no malloc / free (there can be rare exceptions but all rules are meant to be broken on occasion). That’s the only rule really.
It's fine. In fact that is pretty much what the early versions of C++ were (C++98 and before). I am always kind of torn on the subject myself, modern C++ has a lot of really nice stuff in there but for all that I find it a lot more clunky to work with than the older C with classes style. It also comes down to exactly how object oriented the system you are creating is going to be. If you are going very heavy OO then modern C++ just makes that a lot better, if the structure of your program has pretty simple object relationships and you just want that little extra syntactic sugar that C++ offers then old school C++ works perfectly well. If you are looking to get a job writing C++ however then it is quite likely they will expect a more modern style of C++ so if that is your end goal it is probably no harm to bite the bullet and start writing that way now. 
Totally agree. The posts are interesting but if they are a series of related interview questions put them in the same post so that people interested in them can see it in one go. &amp;#x200B; &amp;#x200B;
You're all right. If there was a problem, you would know it in pull request or code review.
Usage of std::shared_ptr is a design flaw in 99% of cases. 
Exceptions are hidden gotos. Well hidden behind a curtain of lies. They're anything, but definitely not an "excellent way to make a program more readable". Furthermore, it's incredibly hard to write correct exception safe code. 
Could you elaborate? I don't understand
A shared ptr indicates that you don't know who actually owns the object. Ownership is an important consideration in software design. Using a shared ptr instead of correctly deciding ownership relationships is the equivalent to throwing your hands in the air and saying "f*** it". There are certain special cases where it's the right choice, but these are quite rare. 
I wonder if were you allowed to check an API reference, especially for thread objects of cpp11.
That is the point (pun?) of shared_ptr. It is collectively owned.
Yes, I'm aware. And that's a design flaw. 
There are very few cases where a shared pointer is really needed: most of the time a unique pointer is conceptually the better option. For instance, in a double-linked list the forward and backward pointers are not really of the same type: the forward pointer realy owns something, the backward pointer is informational. So using shared pointers is the easy way out, but you should really use a unique pointer and a raw pointer. However, using unique pointers means doing explicit "move" which is a level of conceptual complication above. In exchange you get code that is more efficient. By how much I'm not exactly sure. I have not seen benchmarks.
It can mean that ownership of data has not been defined clearly. From my experience, in a lot of cases where shared_ptr is used, sharing of ownership is not actually needed. shared_ptr in thoses cases is used to circumvent having to think about ownership of data.
This is what I did and I think every developer should do at least once: Write the same application (full app, not prove of concept) from ground-up with C and C++. Sequential and OO. Do it at least tree times - with tests! Tests can teach you what maintainability and clear API really is! If you follow above you will gain experience - you will recognize what was 'right', what was 'wrong', what was 'just enough' and what was 'too much'. You can read as many white papers and forums as you want, but until you test it out in practice yourself, it is just pile of confusion.
In your multithreaded example it's even worse. The worst mistake you can do in such a situation is to share data amongst threads in undefined ways. Data should not be shared amongst threads, and if it's required only through carefully crafted means (like a queue, for example). 
If you completely reject the STL (and by that I mean the whole standard library) I totally agree (just like this "I don't like smart pointers, because I don't understand what they do" -nonsense here). If there are parts of the code that have requirements which are not met by the "appropriate" stl type/function/container then going for a specialized, hand rolled solution is most likely just good engineering (if a 3rd party solution is - for whatever reason - not appropriate either).
Nope. Sharing data between threads with no issues for years now. Mutexes are a thing.
The only things pointer ownership come into play with are who deletes the object, and who can mutate the object. The latter is for const to enforce, and the former, it either doesn't matter (shared\_ptr), is the caller (unique\_ptr), or is the called (weak_ptr, or const T* if conditions permit).
We should rename mutexes to std::bottleneck, to clarify their use case. 
Isn't "C With Classes" in line with RAII and therefore no resource leaks? In fact that is what I mostly thought it meant...
In theory I agree with that. But in practice I think attempts to do that will fall into the following categories: 1. 90% will be premature optimization. 2. 8% will reject appropriate 3rd party solutions based on NIH. 3. 1.99% will be horribly executed buggy garbage. 4. 0.01% will be arguably worth it. And I'm still pretty suspicious of category 4.
Now you have resorted to trolling.
I ran into a case where I was working close to the metal, and sometimes C structs come in handy
No, I haven't. Mutexes are bottlenecks. By definition. In good software design, they should be avoided. I write heavily multithreaded software (video games), and I can't think of the last time I have used a mutex. All communication between threads and systems goes through well defined channels (which might internally use mutexes, but they're generally implemented using lockfree data structures). Beyond the fact that it's bad design to use mutexes and shared ptr (not unique ptr, unique ptr has a well defined owner and decent performance characteristics), they're impacting performance quite dramatically, rendering them useless for most cases. 
&gt;I write heavily multithreaded software &gt;video games I don't think you really understand what a heavily multithreaded software is if your experience comes from video games.
I think having a good knowledge of pointers and how memory works is far more important than knowing how to use C++ standard library. There are some situations where it is not possible (or not recommended) to use the standard library. That being said, the std library is there to ease the pain of writing code, but in my opinion writing modern C++ code is more about OO programming, templates and other compile time features, modularity and mantainability of the code. Certainly not about using a certain library or not.
By the way: https://twitter.com/matropert/status/984010895654359042?s=21
I don't think you understand how video games are written. Or software in general. 
Come back when your video game scales to and over 128 threads and then come back. Remember to not use mutexes
I like EnTT, one of the best ECS frameworks out there. I wish there was some well-done benchmarks of existing ECS frameworks in C++ though.
I wanted to create such a repo during the last days, but I've not much bandwidth and failed to find the time. However, I'll create it soon probably, so stay tuned on my GitHub account. ;-)
It does, can I come back?
Sure, let me try it out first or get out
here's a problem i had recently (and i have no good way around it): i have some destructors which must run on the main thread. with plain pointers it's easy: i call delete from the main thread. if i made an error and the pointer is still accessed in other places i get illegal access errors quite quickly (valgrind is helping a bit, but it's so slow that the race conditions might not happen). with shared pointers: i can modify the destructor with an assert, but that's not always code i can change. and the problems are more subtle, most of the time it's no problem so it might not show up during testing. 
Why do you have std::string eval(std::string s) { return s; } Taking the parameter by value, and returning by value? Function parameters aren't able to be the subject of return value optimization, so the very best possible performance here is 1 move into the parameter, and then another move out of it. Barring heavy inlining by the compiler, which may or may not happen. If you instead define two versions std::string const&amp; eval(std::string const&amp; s) { return s; } std::string &amp;&amp; eval(std::string &amp;&amp; s) { return std::move(s); } Then no matter what the parameter, you're cost is only copying a single reference (which is implemented as a pointer on every platform that I know of), while still preserving the ability to move out of the string if the usage of the function allows for that.
You may be right although I'm not quite as pessimistic. Just to be clear: I'm not talking about reimplementing standard library containers - doing that better than the STL implementer is next to impossible for mere mortals with a limited time budget. However, there are suprisingly many cases, where the STL type/function is just a bad fit for your specific problem and as you usually only need a fraction of the full API anyway it can be relatively simple to write a custom type function, that is both more efficient and easier to use in that context. In general, the STL is the result of how the standardization process works, the desire to stay backwards compatible to decisions taken decades ago in a completely different eco-system, the need to work with all kinds of user types and the desire to cater to a very diverse user community with a very large range of different and conflicting requirements. Considering those restrictions, the STL is a marvelous pice of work, but your type on the other hand only has to satisfy a fraction of those constraints, which can open the dor for significant improvements in usability, compile time and/or performance. Personally though I've very rarely seen the need to avoid STL constructs and most of the time it was in some (semi-) embedded context.
Well I guess I'm just used to having bad glasses, my own bad handwriting and bad classroom projectors in school but you could just [click the included link for the slides you know](https://meetingcpp.com/mcpp/slides/2018/Engineering%20Software,%20integral%20types%20-%20slides.pdf) if those things don't apply to you.
I found this 5 part article series on implementing multivariate polynomials that might be a good starting point: [https://spielwiese.fontein.de/2011/11/25/implementing-multivariate-polynomials-in-c-using-templates-part-15/](https://spielwiese.fontein.de/2011/11/25/implementing-multivariate-polynomials-in-c-using-templates-part-15/)
OP has stated that they're using raw pointers all over the place, so that implies they're not following RAII design principles. Smart pointers are the easiest way to follow RAII when it comes to memory management.
Not understanding how to use something does not make it a design flaw
Can't help re. libraries, but for fun thinking aloud you could approach this with a template poly&lt;T&gt; where T is a ring (of coefficients) so poly&lt;T&gt; is of type T, and define poly&lt;poly&lt;poly&lt; ... R&gt;&gt;&gt; for a base ring R as a multivariate polynomial type, for a fixed number of variables.
Yeah, games and embedded are the only domains where I've seen this kind of thing done sanely. And even then I think you need to consider whether the investment in bringing your new hires / devs up to speed is worth the possible performance improvements. But if you're talking much of &lt;algorithm&gt; of similar, I agree that it's cleaner and easier to read 'normal' code than the STL equivalent. My biggest problem with the STL is compile time, honestly. 
It's super easy to scale when you don't have to share memory for writing. If you can organise your data so that the tasks run in complete isolation from each other the scaling is trivial. When you say you need mutex for multiple threads to do anything it tells me that your design might not be as well thought-out as you think. It would be interesting to get a more concrete example of the problem that you are solving to get some understanding behind your opinion.
Now tell me how the threads communicate and know what to do without mutexes?
I'm hoping someone with a better memory comments here, but a common theme I see in the world of C++ is that most C++ developers retreat into a specific "corner" of the C++ world and use the tools and syntax they're familiar with but without really scratching 10% of what's actually *possible*. So you get people who use Boost for absolutely everything possible, people who have no idea what Boost even is, people who live in the Qt world and rely on those libraries, people who write "raw" C++, people who write C flavored C++, people who just write C but compile it as C++ because they use one or two C++ features.. then there's the Unreal Engine crowd.. it's pretty amazing how diverse it is, but also how *okay* it is to be just one dot in that universe of C++ diversity. C++, more than any other language I can think of, is really a life-long learning exercise. It's like the guitar of programming languages. You can play it so many ways and all those ways are fine, even if you feel like you're the Nickelback of C++ sometimes :-D
As I said, it is best if they don't have to communicate (the tasks work in isolation from each other). Now you are describing YOUR problem; without knowing more about it than what you have told me, that they need to communicate with each other, I would probably pass messages in a lock-free concurrent queue which uses atomic CAS (compare-and-exchange) to synchronise access from multiple threads. The cxchg (x86) relies on hardware memory model to be correctly implemented, so any writes have to be synchronised between cores so I would implement the data structure so that I would minimise the cache lines that are touched. On ARM the mechanism is a bit different but luckily the C++11 standard library makes this more convenient to implement as they added the &lt;atomic&gt; header. I'd prefer lock-free, or even better, wait-free synchronisation and minimise the contention by having multiple concurrent queues internally when the order is not relevant, when it is, the synchronisation is slightly more expensive but if the tasks are ordered it is more convenient to start a new task as post-fix from previous task instead of queueing them through a congestion point. 
At this point even tagged unions are more pleasant to deal with than this shit which is an accomplishment.
That's nice and all, but it's a little disingenuous to call it two lines of code.
Depends very much on what you want to do with the polynomials: just evaluate them for different values of the variables, add or subtract or multiply, differentiate numerically, differentiate symbolically, what? Maybe an algebraic system like Mathematica would be better suited to your needs than a DIY C++ solution? 
Mm... They work implicitly in my eyes. There's something going on, but probably not this? let x = foo.into(); takes_bar(x); // x : Bar, through impl From&lt;Foo&gt; for Bar See [here](https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=9a1ef06e6f05cc33bc3bef5d99bca229). Sure, you need the `into` call, but don't all types have `From&lt;X&gt; for X`? So if you had `into` everywhere, that'd be the situation in C++, except Rust can handle the variable return type. It's probably something to do with no ad-hoc overloading + train constraints. You can find an assignment that satisfies everyone, if they can be satisfied.
If you want a pointer to an array you declare like: int \*\*int\_ptr; and use: int \*arr=new int\[2\]; int\_ptr=\&amp;arr; (\*int\_ptr)\[0\]=5;
One thing to add here that hasn't been mentioned yet is that smart pointers are 100% deterministic. The key thing to read about here (coming from C, as OP is) is ref-counting, scopes (one of the main awesome "features" of C++!), and RAII.
The two lines are overloaded and the deduction guide.
Lock-free design is overkill in most situations and very prone to cause bugs unless you use a robust library for it. Especially in video games where CPUs are barely utilized.
You should read up on scopes and RAII. I'd say they're a big piece of what C++ is. Many of the features C++ has help you avoid bugs.
OT: Reddit uses indentation for code blocks instead of backticks, 4 spaces or one tab. 
I really recommend that you go watch some of Sean Parent's talks. Start with this one, [C++ Seasoning](https://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning). The first half blew my mind :-)
&gt; Furthermore, it's incredibly hard to write correct exception safe code. Maybe if you're writing your own container classes, but if you're doing that often, then something's probably gone wrong. Other than that just RAII everything. The thing is the latter is great practice anyway because even in the absence of exceptions you get precise resource cleanup and you don't have objects in "this object is broken" states. &gt; They're anything, but definitely not an "excellent way to make a program more readable". If you have well RAII'd code then they're much clearer. You never see most of the error handling code.
How do YOU share objects then? Not in a multithreaded process, just in general? Some people just pass raw pointers to the unique_ptr around, and assume/hope everyone (today and 10 years in the future) knows not to delete it. I'm legitimately curious how you efficiently and safely share objects stored in a unique_ptr.
r/cpp_questions is a better subreddit for something lime this I think.
Thank you!
I've never seen template&lt;class... Ts&gt; overload(Ts...) -&gt; overload&lt;Ts...&gt;; I guess it's the same as (sorry, I'm on mobile right now) template&lt;class... Ts&gt; auto overload(Ts...) -&gt; overload&lt;Ts...&gt; { return {}; } Is the auto keyword and function body implicit? If so, since when is it? I haven't followed C++17's (or 14's) additions very closely, so maybe it's a stupid question. :)
I have been working with people with people that just use C with classes when they use C++ and frown upon more complicated features. It has been a slow battle, but they are starting to understand the benefit of abstractions such as smart pointers, lambdas, etc. It takes a bit of time to understand the point of these constructs, but once you do, you understand they are there to assist you and reduce the number of mistakes you make. However, the last mistake you want to do is use an advanced feature just because it looks cool. My experience with C with classes is that it is ok for small individual projects, but as your team grows, it makes the code very difficult to maintain. Features like std::unique\_ptr help your co-workers understanding who is responsible for managing a memory resource. It is also my experience that there are some types of problems where the advantages brought by C++ features are limited. DSP is one of those cases, as in the general case, very little dynamic memory is involved and the code tends to follow a very deterministic, linear path. Lastly, it is also important to notice that a lot of the advanced C++ features are more targeted to library developers. So it is good to have them in the language, although, you may never need to use them yourself.
&gt; I wanted to know what other developers think about that sort of style? Is it "okay"? No. This is exactly what C++ tries to avoid: writing C. &gt; No "hoping" that some smart pointer does what I think it does (Edit: this of course comes from not quite understanding all of them and which one to use when). Using a standard library collection like a vector or something to handle something that an array will do just fine seems too much to me. - There is no "hoping it works" - you either understand how and why it works or not. If you are afraid about using the standard library you surely need to learn the language more. - You practically can not to not use standard libraries in .NET and Python, so ... why you pretend you can omit the one in C++? If you did not know what a string type in Python does - would you learn it/look up documentation or rather implement your own Python module in C and bind it to your executable? - Using ad-hoc solutions is not fine. You reinvent the wheel, actually a much worse wheel with no testing and missing functionality. Don't you trust the code that was tested and improved over decades? &gt; I would switch to C, but I love my classes and inheritance and the occasional std::vector or, well, &lt;algorithm&gt; and all that. I recommend to learn the language then. With enough skill, there will no longer be "occasional vector"s, it will be your day-to-day bread, with `std::` on every code line. You will see that the more you understand what a standard library can do for you the less C code you need to write (even down to 0 pointers in the whole program).
Depends on the situation only you know about, so yeah, you are expert on your own opinion. I asked if you could describe your workload a little bit maybe we can find some fun engineering the shit out of it? And no, I am not saying you shouldn't use mutexes; they work and all that but a lot of times when I see them used they can be got rid of by re-structuring the data. At least to use reader-writer lock, or similar producer-consumer related pattern if nothing else, that already improves congestion by a margin quite often. But here I am, trying to imagine what the amazing workload is that scales to 128 concurrent threads and cannot be implemented with nothing but mutexed access to everything. Mutex is the first thing you think of, not the last, or should be anyway. I some how think this won't be going anywhere but more questions and no data to make informed decisions on, am I right? =) 
What does (\*int\_ptr)\[0\]=5; do ? I understand the rest of the code, yet I don't understand why there has to be a pointer in the last line. (\*int\_ptr)\[0\]=5; 
That sadly breaks symmetry; I'd rather have `poly&lt;S, Tags...&gt; often.
That’s why you generally you don’t need many copies or just use references when your ownership model allows it. 
My first projects were exactly like you described, I wrote "C with classes". Then I learned about the STL and watched many hours of videos (look for cppcon on youtube) and then I fell in love with Cpp. Its bloated, yes. But the STL is everything you need. Writing Cpp is more like "Writing with the Cpp-STL". And once you learn more about compilers and how they work (and how they optimize!) you will never want to write C anymore. There is simply no need to write "ugly but fast" code. Write nice code and let the compiler optimize the hell out of it. [https://godbolt.org/](https://godbolt.org/) is a tool which gives you live-assembly of your code. Let the compiler optimize with -O2 and see what the compiler creates (you dont need to read the assembly, a thumb rule is "smaller is faster"). You will see that it can optimize most of your code away. &amp;#x200B; These two are a must seen: &amp;#x200B; CppCon 2014: James McNellis &amp; Kate Gregory "Making C++ Code Beautiful": [https://www.youtube.com/watch?v=BiYliKliFvs](https://www.youtube.com/watch?v=BiYliKliFvs) CppCon 2018: Jonathan Boccara “105 STL Algorithms in Less Than an Hour”: [https://www.youtube.com/watch?v=2olsGf6JIkU](https://www.youtube.com/watch?v=2olsGf6JIkU) &amp;#x200B;
It's deduction guide ([https://en.cppreference.com/w/cpp/language/class\_template\_argument\_deduction#User-defined\_deduction\_guides](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction#User-defined_deduction_guides)) for class template `overload&lt;Ts...&gt;`.
The point was that completely avoiding mutexes is dumb. It might not be the fastest but sometimes it does not matter when you can do one line instead of thousands and gain absolutely no performance benefits. If a software is handicapped by mutexes only someone has really fucked up. The same goes with shared_ptr. It is slower than raw pointer or unique_ptr but it sure as hell is useful tool when juggling things between threads. Here is an example of what I have been doing lately. So lets say I have a part of a program that flows data continuously through multiple steps. Each step has one or more assigned thread to it which all reside in a threadpool. Data entries come from multiple different sources and sometimes are dependent on other entry to be finished first and is cached while thread works on other data. Data can but not necessarily accessed by multiple threads at the same step. Entries can be discarded at any step of the way. The next step can vary depending on the result of the last.
Thank you for the link!
I have something like that but much simpler that I used for tokenizing on data loading. With our code base (about 700k loc, high perf physics simulation), switching to c++11 got us automagically 20% speedup. Hand editing some of our matrix code and also using std::move with our loaders which required very little code change got us another 15%. Haven't seen that level of speedup with c++17 for anything. Initial attempts on the linux side to use string_view have been much more difficult to convert as it affects everything everywhere: it's going to be a much more difficult conversion across the whole code base.
Regardless, 1) C++ provides better capabilities of creating interfaces that can be more easily be refactored for a faster implementation if needed 2) this comment thread was started by the usage of smart pointers, which have virtually no overhead when used appropriately. 
Are you referring to Win32 or Linux or Mac? For Win32 (windows) if you own the window it is the color given in the winproc message WM\_ERASEBKGND You could also query the system settings (the default background color is based on your theme) &amp;#x200B; If you want more people to help, you should tell why you want to "check" something. &amp;#x200B; &amp;#x200B; &amp;#x200B;
&gt; quite does what I want it to do, and it's always that one feature that it's missing. Either way, thanks for the guide there, I'll Speaking of philosophy you could be interested in cpp core guidelines. It's an official document stating what cpp is really about. It's mainly focused on saying that using standard library relieves you from many mistakes you can make. Trust the compiler and library created by hundreds of smart people more than yourself. So for example don't risk runtime errors using C pointers. My personal opinion is that c++11 features are awesome and I feel like everyone should use them as much as possible. 
I always imagine my coworkers, who are are up to speed on modern C++, reading that and throwing a fit. So instead I just make a whole other inline function (if appropriate) that’s an if-else chain where each arm returns. I have to put up with clang tidy telling me a return in each is bad :( There’s also ternary operators but readability can be pretty piss poor. 
Our solution to that exact problem was: any 'thing' which has that invariant derives from "garbage collectible" which has 1 function "flag for delete" and a private virtual destructor with a friend-class of some class you deem ok to delete the objects. "flag for delete" puts the object into the (thread safe if neede) static vector of things-to-be-deleted. On the main thread, iterate and delete those objects through the friend-class. Anyone who wants to store an instance of something derived from that just uses a unique_ptr&lt;T, CustomDeleterThatJustCallsFlagForDelete&gt;; It's not built to be super performant (since it adds a virtual base to every type you use it with) but it solves the problem. Our typical use-case is graphics objects which can only be released from the main thread because rendering may be using those objects during the normal simulation.
Im just bored and I want to write a program that clicks if that color is present,just for my learning purposes.Windows.
yes. python is written in C as well as 90% of the packages in any distro for a reason. The Linux kernel is written in C for a reason. C code wriiten today is compatible with anything written 40 years ago while c++ breaks even across modern compilers. using pointers is actually ideal. by using pointers you are avoiding a LOT of issues, among them all the whole moving semantics mess and all the shared pointer overhead. if you can define well lifetime patterns and ownership then you dont need shared pointers. so my advice to you is to stick with whatever is simpler. using the latest and greatest shit on the C++ standards usually contributes very little to the bottom line. C++ as of late has become an exercise in futility to the point [Stroustrup considered the latest proposals insanity](https://www.theregister.co.uk/2018/06/18/bjarne_stroustrup_c_plus_plus/)
No. I’m strictly talking about teaching someone low level concepts or embedded systems where resource management needs to be much more explicit. Trying to explain pointers while also explaining constructors can be a lot for some people, so I’d advocate taking away the toys until they understand the basics. Like teaching someone proper lifting form and mobility before letting them loose on deadlifts and barbell squats. 
Turn off fancy editor mode and you can use back ticks. It’s a life saver. 
Have fun with FindWindow(), link it up to the cursor position then you can alter the window's properties of other applications. With the window's (child window's) handle you can change the style or "subclass" it's winproc. E.g: * give a textbox a title bar, SetWindowLongPtr() * take a screenshot of another window. getDC() * make a button bounce around another app. setwindowpos() 
\&gt; The amount of horrible issues I've seen with unique\_ptr \[...\] Can you give some examples?
I recently did a project using variants, and I avoided std:visit because of overhead. I used ‘get_if’ and ‘holds_alternative’ mostly. At the end it was less readable than just using tagged unions, at the cost of a little less initial boilerplate. It would be nice is something like the [lvariant proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0095r1.html) made it in, but that would be a loooooong ways off. Also I feel pattern matching is a bit antithetical to the verbosity of C++.
Usually you don’t need to write them explicitly if the class/struct only has one template parameter (in this case it’s a parameter pack so it doesn’t automatically get generated)
that's just not true
Not following well, could you expand a bit plz?
I prefer to have a structure like the following \`\`\` src src/include (private headers only) src/component\_1\_dir, src/component\_2\_dir ... src/component\_N\_dir docs include (public headers only -&gt; API) external (for dependencies) scripts tests \`\`\` This was discussed multitude of times here on this subreddit so you may want to have a look at those (e.g. [https://www.reddit.com/r/cpp/comments/8qzepa/poll\_c\_project\_layout](https://www.reddit.com/r/cpp/comments/8qzepa/poll_c_project_layout/)). My personal preference would be:
&gt;Within [C++](https://en.wikiquote.org/wiki/C%2B%2B), there is a much smaller and cleaner language struggling to get out. (Bjarne Stroustrup) &amp;#x200B;
Of course it would be. I said nothing about completely avoiding mutexes. The problem presented was that something has to scale to 128 concurrent threads and no more information provided. A mutex in such scenario would definitely create a congestion point, you would at minimum want to spread the damage to multiple mutexes. But it's hard to reason about a problem you know next to nothing about, right? I'm not so sure it's that complicated; the API I use in my hobby projects: ConcurrentQueue queue; queue.enqueue([] { ... work ... }); The queue internally is lock-free MPMC and has been tested up to 96 cores (sorry, didn't have a computer with more cores to test with) and scales perfectly. The difference between mutex and MPMC is ~250K transactions per second and ~50 million, 200-to-1, so I would prefer to use the MPMC's when doing task parallel solution with a fine granularity. The tasks could be kept larger, of course, but finer granularity allows to squeeze a bit of extra juice out of the CPU and added bonus is that the latencies are a bit finer. Works for me.. In the previous career was doing GPU microcode and drivers for 10 years, didn't really have mutexes on a Command Processor. All synchronisation was done using time stamps, counters and predication. Everything was happening simultaneously, literally, and had to be synchronised perfectly or NOTHING worked. The thing is, synchronisation with synchronisation points kills the performance completely. It totally trashes it. If you have to flush, you're dead (in the water). Literally and figuratively. I would have had to move after the work so our ways with GPU's split, but that's pretty cool, been doing great. Now working on a streaming technology and the previous job's lessons have been put into good use. :) Regarding your use case, it sounds fairly standard and if mutexes are not bottlenecking it, then you're doing great. Definitely no need to over-engineer it when you don't need to do it. :) It just sounded like it was something with cluster of something doing something or something. xD 
Unfortunately the slide recording didn't work in the tracks C and D. So its the general recording as the source then left. Working to reduce flicker in future videos. 
Usually a (const) reference to the underlying type is a good choice.
&gt;Taking the parameter by value, and returning by value? The overarching thing here was that I wanted the code to be clear and simple to follow with the minimum of visual "ticks". Performance wasn't at all a consideration. That reasoning pretty much covers most of the points. For `eval` I especially wanted the return types to be simple and the same everywhere to underline the similarity. This was being read by many non-C++ developers so it was nice to not to feel I had to explain all of the cases and thinking for the return types -- it allowed me to concentrate the explanation on what was going on. To that end, the use of `front` and `next` would both make the code simpler and clearer I think. I'll revise that when I get a chance (maybe have to wait for the weekend though). I didn't know the thing about parameters not being RVO friendly. I'll bear that in mind for the production code I write though, so thanks for pointing it out. 
Have a look here for input on the same topic: [https://www.reddit.com/r/cpp/comments/8qzepa/poll\_c\_project\_layout/](https://www.reddit.com/r/cpp/comments/8qzepa/poll_c_project_layout/) &amp;#x200B; \&gt; - Is using a lot of namespaces considered bad thesedays? No. Namespaces are good but as anything else they need to be utilized judiciously. E.g. deep hierarchies of nested namespaces are not very ergonomic to use. \&gt; - Are we moving away from separating into header and source files? Modules will introduce some new things but in principle no. Header-only libraries are a silent killer of your compile-times. \&gt; - Is it ok to use classes only for encapsulation and use structs for data structures? These two are basically interchangeable in C++ so whatever fits your bill. I like using structs for POD types and for generic programming.
Your statement &gt;how they were successful when the received wisdom was that coding that way was too complicated to succeed is a bit confusing - are you saying straight C is working better for you or the mixed world?
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
if you write everything in headers and only has one cpp file, it actually may optimize the build time.
Still won't work on old Reddit or half of the Reddit apps. Indentation works universally.
No, you can't.
No because std::array is implemented using C style arrays, any literal string is is a C style array. That would be one of the most useless and hated compiler warning ever. 
Yeah, I was referring to the person before you who said using mutex = bad. In my hobby projects I try to write everything myself excluding standard libraries and while a lock-free queue is faster and you'll only have to write it once, it doesn't make much sense when performance gains are negligible. There are many ways to achieve something and standard library is a tool to achieve it. Trying to avoid using some features when it would work is dumb. Right tool for the right job, right?
Yup, it's a good tool. But it's also a very easily abused tool since it can lead many beginners to neglect the up-front design WRT ownership for an easy out. Like a lot of C++, use responsibly!
Wot? wot? Here's 3 backticks ``` and some text and some more text and another 3 backticks ``` It works.
From reading everything you've said in this thread: C is a language where you don't have to actually learn much to use it. It's simple. C++ contains a lot of features from a lot of domain of PL design and as a result can be overwhelming. You're suffering a classic case of not knowing what you don't know, but trying to make a decision that requires that knowtlwdge. You have a lot of misconceptions about C++. Personally, outside of hardware, I find it downright irresponsible to choose C for any newer projects knowing that C++ will give me proper data types, RAII, stricter type and semantic checking, ownership aware pointers, etc. 
And...?
It works on the official reddit app 😅
Yeah, you're probably spot on with that. 
No. This is a pointer to a pointer. And that pointer happens to point to an object which is an array. Subtle difference, but OP asked for the specific type.
Unless it’s a const T shared pointer :) 
I don't think so. The compiler should just compile the sources given when requested and write to the specified output files. It is up to the build tool (with input written by metabuild systems) to create a correct build. I define a "correct build" as one where if a file changes *all* files affected by that output are regenerated. If compilers can optimize it file, but the compiler should be run.
It will certainly make iterating on ideas slower. One change and all the header files have to be reparsed.
[Great job!](https://i.imgur.com/IQSfCOy.png)
Sorry which HPC code are you working on that's making regular use of mutices? 
I would start simply and follow YAGNI if you don't have a lot of experience. Overdesigning the build system can be as much a problem as overdesigning the code. You can add complexity if it becomes unwieldy and large. You want to be able to prototype quickly in early stages. ``` root/ CMakeLists.txt README.md source/ src1.cpp src1.hpp src2.cpp src2.hpp common.hpp third_party/ Eigen/ Catch2/ ```
Good on you for asking, though! I hope this thread gave you what you were looking for. Have a beautiful day.
Oh shit what I have been doing this whole time lol. Goddammit reddit.
&gt;Have a look here for input on the same topic: https://www.reddit.com/r/cpp/comments/8qzepa/poll_c_project_layout/ The topic is a good illustration how build tool limitations (Makefile, CMake) force to use "split" style.
&gt; I am a little embarrassed about not being completely sure how to structure the source code No one really knows. I've had success, especially on small projects, with: 1. Putting all smaller data structure declarations in a single header file. 2. Putting all transformations from one type to another in a separate file (or at least its own compilation unit) 3. Larger data structures go in their own file 4. Keeping the primary loop as simple as possible. Though I will typically break it up into sections with a macro and let it get very long, if each of the sections is just something that will be used once. In other words, I won't make something a function just to name it and move it somewhere else, I make functions if they will be called multiple times. 
QM-damn the bloody "considered harmful" snowclone headline. It's not clever, it's not funny, definitely not original, definitely not factually true any time it is used.
It's worth mentioning that the problems are worst on x86 on Windows, and the situation is much better on x64 due to a changed exception handling model. And also that there are an awful lot of places that benefit from noexcept, and MS are actively working on optimisations relating to noexcept.
I don't know whether to laugh or be angry at the [Reddit markdown wiki](https://www.reddit.com/wiki/markdown) – `~` are 'twiddlydoodles'? Really..? There are quite a few headscratchers in there; it's amazing this site works at all.
It looks like, "don't use noexcept for inline functions"...?
The title was based on Terry Mahaffey (Microsoft) "noexcept is slightly harmful" (presentation: Please, Please Help the Compiler, 2017). So far the benchmark results appears to suggest a significant performance cost when 'noexcept' is added to inline functions, as compiled with VS2017 or Clang (Apple LLVM 9.1). However, in other cases a significant gain was observed. On GCC and Intel C++, I did not observe a significant performance cost from noexcept. Please give it a try!
I'll keep this in mind for the future. Thanks.
So is this a private boem with those compilers or a prboem with the cncept of 'noexcept'. I mean, both gcc and clang had bugs with improperly inlining functions that used TLS, this doesn't jean TLS is bad or 'considered harmful'
Given that c++ is a wholly larger language, I posit that there are more users of it that are unfamiliar with most of the language quirks than compared to C, which is a much simpler language in comparison.
I like you Vinnie, you're equal parts C++ expert and shitposter 👍
goto considered harmful was true tho
First of all, this was just an informal 5-minute lightning talk, presenting preliminary results. Please don't jump to conclusions! I hope that the idea that noexcept might possibly be harmful (when used as was intended) can eventually be proven wrong. Then it should be noted that I specifically looked at inline functions for which it may not be obvious to the compiler that they will never emit exceptions. 
And/But use of unique_ptr is good design in 99% of cases.
Thanks! I just glanced at this, which makes my informal theory kaput https://monoinfinito.wordpress.com/series/exception-handling-in-c/
Not understanding does tend to lead to design flaws, however.
Just formatting your comment below. --------------------------------- I share here the same comment I posted to the blog. Some time ago I needed to do a "strict" overloaded which breaks on any implicit conversion. For example: overloaded ov{ [](int i) { cout &lt;&lt; "int " &lt;&lt; i &lt;&lt; "\n"; }, [](string s) { cout &lt;&lt; "string " &lt;&lt; s &lt;&lt; "\n"; } }; ov(10.0); // implicitly converted to int The easiest thing to do was just adding a catch-all lambda, this way: overloaded ov{ [](int i) { cout &lt;&lt; "int " &lt;&lt; i &lt;&lt; "\n"; }, [](string s) { cout &lt;&lt; "string " &lt;&lt; s &lt;&lt; "\n"; }, [](auto...) { static_assert(false, "not supported"); } }; ov(10.0); // fail Do you have any other experience or recommendation about that?
My guess is you are only writing small projects, and working alone or on a small team. Because in these cases, it is easy to track ownership yourself - particularly when you make the rules ("I know all Foos are destroyed by Bars"), etc. C++ really helps with larger codebases, and team-based development.
Except the original name of the article by dijkstra is 'A case against goto' 
Didn't you just write &gt; With raw pointers I had to manually trace ALL copies of the pointer to see who was actually deleting it when. ?
&gt; definitely not factually true any time it is used Can we get an exemption for "Considered Harmful" Essays Considered Harmful.
&gt; I always imagine my coworkers, who are not up to speed on modern C++, reading that and throwing a fit. Sure, but they are probably not up to speed with rust either and lambdas are about 10 years old by now (compiler support in gcc since ~8 years). Maybe I'm reading too much into it, but I'm sometiems suprise that people suggest using RUST, which I believe had its first sable release in 2015, but at the same time claim "we can't use these "new" c++ features from c++11/14/whatever". That is not to say, that the value proposition for using RUST might be much bigger than using c++latest. In any case. I don't want to particularly advertise the pattern, because readability is not necessarily improved anyway (at least not, when you aren't used to it). As you said, you have to know your co-workers. 
I think you really want to read https://api.csswg.org/bikeshed/?force=1&amp;url=https://raw.githubusercontent.com/vector-of-bool/pitchfork/develop/data/spec.bs
Agreed. 
in my case it's also about graphics resources. my not so nice solution is similar (i place objects on a deletion queue, ensure ref count is 1 before releasing the last shared_ptr, or warn if someone still holds on to the data). gonna keep your custom deleter solution in the back of my head for next time i need something like this (can't be bothered to change my code. not happy, but it works good enough as is)
I'm certainly hopeful that things will further improve with respect to compiler support of noexcept. Also glad to see that my posting at the MS forum on this topic is marked "Under Investigation": [https://developercommunity.visualstudio.com/content/problem/425370/c11-noexcept-implementation-still-a-performance-lo.html](https://developercommunity.visualstudio.com/content/problem/425370/c11-noexcept-implementation-still-a-performance-lo.html)
Sure, the same is probably true for every other programming language. What is your point?
The layout of [Boost.Hana](https://github.com/boostorg/hana) is the gold-standard, IMO, and I have come to especially appreciate the fact that there is a forward-declaration for _everything_. (kudos to /u/louis_dionne)
considering the heavy template usage in modern c++, a simple modification may already trigger a long time compilation, and more cpp files only make it worse.
This isn't even a c++ question. Please post off-topic stuff elsewhere.
I’ve already stated it clearly, feel free to read my previous responses. 
Here's what Anthony Williams, one of the most world renowned experts in that twitter thread you just linked, actually says: &gt; Mutexes have their uses, and are indeed often faster on average than lock free equivalents. My point was that contended mutexes kill scalability. You're making something very black and white that is actually very nuanced and situation dependent. And I say this as someone who almost never uses mutex (pretty much always just lock free queues).
By the time you get tired writing destructors full of `delete ptr;`, you'll surely know what `unique_ptr` is for.
I'm also using three backticks for multi-line code on reddit... always rendered correctly on my browsers... what a surprise that apparently this fails on a lot of other clients? Wow... I really hate indentation for code, it's always such a hassle on stackoverflow. Such a pain to format code. Backticks are much easier.
No, but here's the original "considered harmful" document: http://aegis.sourceforge.net/auug97.pdf
For every programming language feature, there's some blog out there that says not to use it.
More almost pointless brain teaser type questions. At least these aren't testing someone's ideas of how to build the world's worst queue.
You're kidding, right? It's not the original by about 40 years. The original is Djikstra's "Goto considered Harmful", written in 1968.
&gt; Exceptions are hidden gotos. I can agree with this one, somewhat. &gt; Well hidden behind a curtain of lies. To what lies are you referring? (I'm not agreeing or disagreeing - I really don't understand what you mean) &gt; They're anything, but definitely not an "excellent way to make a program more readable". That's your opinion, and there are those who would disagree (like myself). Quoting [Stroustroup](http://www.stroustrup.com/bs_faq2.html#exceptions-why): &gt; Using exceptions for error handling makes you code simpler, cleaner, and less likely to miss errors &gt; it's incredibly hard to write correct exception safe code That's your opinion. I don't find it particularly hard. If you employ RAII correctly, exception safety comes easily (someone else said the same in another comment). Practice makes perfect I guess.
I thought that one was called ["A case against the GO TO statement"](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD02xx/EWD215.html) but I see it mentioned under the "Go-to statement considered harmful" as well, so my bad.
Although I've seen that certain people might get pedantic and be predisposed to pounce on this with disagreement either on technical grounds, or something philosophical, etc.... C++ is designed such that it is possible, if you wish, to treat it much like a superset of C. So if you want to avoid using classes, STL, other C++-specific features, then you can feel free to write code like simple C code, importing (where applicable) headers that largely match standard C library functionality. I'd actually recommend doing some of this initially.. since for understanding, it can be good not to introduce too many new concepts at once (since it can be relatively difficult to understand what is really accomplishing what, what is responsible for which problems, etc.).. and C++ functionality built on top of the C foundation, and the further you get into it, the more you'll appreciate that it's very much a living part of C++ (and certain industries - notably the games industry - is often criticized for writing "C with classes" code rather than 'proper' C++ code.. but continues to benefit from fast compile times and straightforward debugging, etc.. and embedded code is often written in that way whilst largely avoiding that criticism.. so code actually is sometimes written that way, with good reason).
A raw copy is implied not to have any ownership when using smart pointers, it's essentially a reference. If I'm looking at raw pointers to find a bug, then my ownership model is fundamentally flawed and I can fix that. It means either my `unique_ptr` was destroyed too early, or it means I should be using `shared_ptr` if I there is ambiguous ownership. That's it. Those are the only two problems. Those problems are the same without smart pointers implying ownership, except I have no way to enforce or check for these problems. Is this container supposed to control when it gets deleted? Does this event control deletion? What about that cached pointer? Oh crap did I do a double delete because I forgot it got deleted back here? This, as always, is my personal experience with the issue. 
For various reasons I type most of my comments in Sublime and paste it in the browser anyway, so I've personally never found the indentation to be a hassle. And I'm _positive_ there are browser extensions to let you indent in-situ. ;-]
Good point. As exemplified by [iosfwd](https://en.cppreference.com/w/cpp/header/iosfwd). This is also true for third party libraries, like fmtlib which gets included everywhere (which I assume is what you mean for optimized build times)
STOP.
Go take a look at [how ha-proxy handles performance and scale](http://www.haproxy.org/#perf). The short answer is: 1 process per core, async everything. It's not even a controversial opinion that thread-per-client is a bad design. I don't know why you bring up bind9 or the other Apache projects, either. They're definitely not doing thread-per-client. They do thread-per-core by default, which is a vastly different thing. 
My two cents: Minimize dependencies (esp. in headers/interfaces) if you care about build times, maintainability and code quality in general. In general, a clear separation between interface (declaration) and implementation (definition) is a good thing. Unfortunately Eigen does not help, as you tend to pull in lots of Eigen headers just to get the types, and the template magic can take ages to compile (I've seen examples where 50 lines of code take several minutes to compile). Other than that, classes are good to enforce certain behaviour. E.g. with pure structs/PODs it's very hard to guarantee state initialization and consistency, and can make feature additions &amp; refactoring a real pain (e.g what happens if you add a new field in a widely used struct? You may have to manually go through all the code that uses it and make sure that initializations and updates result in a correct state). With classes you can make members private and force initialization and updates to happen via constructors and methods.
You're conflating two different things happening in this comment chain. 1) I said I liked some of the concepts in Rust 2) I write code in a certain way to not surprise coworkers I also don't advertise Rust to those coworkers. It really depends on who I'm working with. I'll write different styles if it's a personal project, working with a couple other people who are familiar with C++, or if the source will be used in the future by those who are not "pure" programmers and will only know basics.
And another one that says to always use it. It gets pretty confusing doesn't it.
"Mommy, is it OK if I think for myself?" 
The question is about c/c++ compiler intrinsics.
String literals are const char *. I think std::arrays should be promoted to be a primitive type and C style arrays deprecated. 
People often say things like the C route can't succeed because it's too complicated to do certain things or because it's too hard to maintain, but the project was very successful. 
Thank you for your insights. Certainly, maintainability and code quality is important for me now. Working in research, material science/engneering, I see a lot of bad code and want to set a good example. It might also come to a point where code is to be included in published articles. For now, Eigen doesn't seem to cause too much trouble in compilation times. Thus far I've used both msvc and mingw-gcc on windows. But Catch2 linking is truly painfully slow using mingw. I wanted to use classes to encapsulate behavoiur, but try to avoid objects with states. Hence using structs with data and no methods. I actually wanted to avoid class objects overall, but it feels wrong to make heavy use of static methods..
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/apevvd/is_there_a_commonly_agreed_upon_class_which/eg8k90e/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
You're right. Try to avoid overdesigning at all costs. Have countless old projects from my early c++ days laying around which started naïvely with big plans for a structure. But when encountering various problems, the code eventually become almost unmaintainable and it was just easier to start over again. YAGNI was actually a new acronym for me! Looks like it's the opposite of my early days way of approaching things :) But, when Duckduckgoing for help with project structuring, I tend to be inspired by various (perhaps overly complex) way of doing things.
Does fmtlib need to be in headers? Does nobody use \*inl files anymore?
Sounds good!
Yes, VOP (instead of OOP). (Please make VOP a thing. "A thing" in the sense that more people do it, and "a thing" in the sense that we use that acronym.)
It's OK, but it's really not the best idea.
Thank you for good points! Also, less embarrassing to hear that "no one really knows". I'm a fan of abstractions and like to isolate behaviour into functions, even though the function sometimes is only called once. But i feel this works better in other languages, like Rust with its modules and where the position of definition doesn't matter. Writing function prototypes is not very appealing.
Thanks! This looks like a good read
I wasn't kidding
The shitty one that most people don't use? :P
I've had the same experience. It makes sense if it's there's a lot of disparate pieces and different teams may be working on those pieces at the same time (like the LLVM, the Linux kernel, etc), or maybe even if it has some plugin structure. But, if it's a "do one thing" project, I've always been happier with a simple structure, and restructuring never took more than a day.
I would go further, and say that I don't really know if there is an acceptable time to call any virtual function in the constructor of a class meant to be derived from. 
Then I have indeed misunderstood your intentions behind the last post. Sorry for that.
"Implement a queue using two stacks"
Copy four spaces. Ctrl+V, home, down, repeat :)
I hate these types of interview question. Nothing but pointless bit twiddling puzzles. Won't give you any valuable information about the candidate IMHO.
There only two types of language features: Ones that nobody uses and the ones everybody complains about.
2. Totally agree. 1. Half the problem is coming up with sane interfaces. To come clean, at the moment I'm integrating libraries that use STL, boost and folly containers and it's just a mess. The number of copies I'm forced into because of poorly thought out semantics all around is just ridiculous.
strong opinion == smart, for many people unfortunately
spdlog's use of shared ptr is the one use I've seen that's made sense, since it's not sure who's going to be the last one left logging.
Well, avoid putting your source files into a .zip file and posting them on reddit then asking for feedback that would be my advice.
linked list is a special case where you should do manual memory management. If you use `shared_ptr`, or `unique_ptr` and a default destructor, process will crash with stackoverflow.
That way all interview questions are just nonsense used to weed out someone. This one is just a level above FizzBuzz. Have you ever used thing A to implement thing B knowing how thing B and A works?
Aren't destructors noexcept by default? (comment on the end)
The bug was simply a guy calling reset on unique_ptr POTENTIALLY before a thread finished. In some cases external forces (network lag in this case) caused the thread to delay and try to access something in an already deallocated unique_ptr's data. The result was random memory corruption that could happen anywhere in the program... I fixed it only after a long ass time of combing the src I came across the threading issue. It seems like somehow the unique_ptr still stored a valid address, but just to random other data structures not the one the code expected. 
It's an error code 28, which stands for FMOD\_ERR\_INTERNAL. On their site it says "an error occurred that wasn't supposed to. Contact support. " After about a couple weeks or so going back and forth with their support team with no luck, I figured I'm better off trying something different 
Thanks, maybe I'll try to create my own mixer then
&gt; So if you had into everywhere, that'd be the situation in C++, except Rust can handle the variable return type No? In C++ you'd just have `takes_bar(foo)` and the cast would be __implicit__. Hiding the actual type between type inference doesn't make explicit `into()` cast into implicit. It just makes type being casted to implicit.
No, he's not.
even if you're right, it belongs in /r/cpp_questions 
I disagree. I felt that this is more of a discussion about a not well benchmarked issue, and in the past (many years ago) similar things have been brought up here, without any definite conclusion. Can any of the mods make a decision on this?
Yes they are :)
&gt; Modules will introduce some new things but in principle no. Header-only libraries are a silent killer of your compile-times. I will disagree with this. Header-only libraries trade-off some performance in exchange for others and it depends on how you've structured your project as to whether they will increase compile times or not. When you split into source + header every source has to instantiate and recompile every template it uses independently of every other source, furthermore the gain in compile time performance may end up getting lost at link time. C++ has a significant number of features that only work in header-only form, like ```constexpr```, templates, function return type deduction, inline variables. Having header only libraries significantly simplifies the build process... no need to make sure every library has been built with the exact same compiler flags and links to the exact same version of dependencies... it's just include and it works. While I don't have stats on this, my impression is that unless you release your library in a header-only fashion, many people won't bother even trying your C++ library. The amount of pain needed to properly structure your build scripts to get a library working properly in Windows, Linux and Mac, Android, etc... is enormous. Make your library header only, and you've pretty much made using your library cross-platform for free.
Yep, it's not embarrassing... no one knows how to structure a C++ project. Ask 10 people and you'll get 11 different answers.
I'd say that's a special case where you don't use the default constructor. You can still use smart pointers. I think. I'll code it out. But you have a point.
The overload it’s lambdas is more lines of code than the PrintVisitor version. All you’re doing is putting print each function on one line, making it look smaller. 
While there is a convenience aspect to header-only "libraries" there are a lot of downsides too. From longer compile times to issues with duplicate symbols. Just a couple of weeks back, I was trying to use `spdlog` in a set of shared libraries and executables. Painful. Sharing loggers between libraries is a convoluted pain, and it's painful solely because of the "convenience" aspect of being header-only, but it actually introduces additional limitations and inconveniences which a proper shared library would have avoided entirely. I think it can make sense, in some circumstances. But, it's not a panacea and I would generally avoid them if I could.
You could also use tools such as valgrind or any memory debugger to make sure the memory in the heap is actually deallocated. But yes, unique pointer should be default. 
Yes, overuse of objects with mutable state is often a mistake. I like to use classes for "micro types" (e.g. vectors, containers erc) but avoid complex classes. Regarding catch, you might want to try doctest instead: https://github.com/onqtam/doctest
There is no issue with duplicate symbols in header only libraries. If someone didn't mark a function as ```inline``` then they wrote a faulty library. As for inconvenience that can be subjective, I find figuring out how to build someone's library who assumed everyone just uses either GCC or clang to be inconvenient. As for objective matters, what limitation are you referring to? There is absolutely nothing you can build using separate source/header than you can't build using header-only. The most difficult thing you may have to consider when building a header-only library is dealing with circular dependencies, it's not impossible it just requires structuring your files in a certain order.
What do inl files solve? You still need to include them within the header.
I use valgrind religiously, I learned that. 
Great :) Here are 2 of my favourite resources for C++: https://github.com/lefticus/cppbestpractices http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines
No because it is apparent that they are not considered harmful either.
Thanks, looks quite helpful! 
I don't think there is anyone who says to use strstream. I think that one everyone is in agreement about. Also trigraphs.
The fact that your post has remained here this long is evidence of the mods making a decision already. ;-]
it is very frustrating to have to watch 8 minutes (or 4 at double speed) for what could be essentially a tweet or two
I could give three or four answers myself.
I use a variadic macro that does nothing and the good old scope brackets {} This means I can put arbitrary text in the macro, makes visual studio collapse it, and then creates an enclosing scope. Then all the out scope variables are available, yet whatever is done inside is isolate and labeled, which is what people probably actually want from functions if they are only being used once. 
Which implementation of std::visit had prohibitavely high overhead?
in what sense ? in that paper, Dijkstra certainly did *not* put a blanket ban on using GOTO, he just said that there are often better tools
Don't know if you are implying that I did this, but yes I agree with your advice :)
If you really are just writing C in C++, compilation time shouldn't be any slower.
Yeah, this one was a bit padded out.
&gt; It works just fine, it's been done like that for decades Discrimated unions are nearly the universal choice for implementing something like JSON, I’d bet even decades back. You seem very antagonistic towards new concepts. I understand that the extreme of “throw away all your OO, the paradigm of the week is X” is frustrating, but I don’t think you’ll encounter that too often. Like many things, you shouldn’t throw away your codebase and start with an entirely new paradigm, but experimenting a little with Rust or Haskell (IME) is incredibly helpful in improving how you think about any new code you are writing (or maintaining).
tl;dr: If you don't have a reason to have a destructor, don't have a destructor.
No, string literals are arrays, not pointers. [Proof](https://godbolt.org/z/6adkF1)
I'm not sure I'd be impressed with the brute force approach in the first question. It would be fine to point out as easy to implement, but I'd be looking for a far more elegant solution. 
Thank you for your answers! And thank you for mentioning the useful thread from last year.
Lib A used Version 1 of dependency D. Lib B used Version 1.1 of dependency D. Executable C uses both A and B. Oops, now you have violated the rule that inline definitions need to be the same, not just the same signature, across all compilation units.
Good to hear. Already stared to worry that the project got near dead after 3 month of no activity. P.s. How does the support for websockets look like. 
The scenario you presented is significantly easier to manage using header-only libraries than building libraries, in fact your situation is a nightmare to deal with using prebuilt libraries! Using header-only libraries the solution is very straight forward... you wrap the dependencies in their own namespace that includes the version number so it doesn't end up clashing with an older/newer version of itself, and that's it and that solution is cross-platform. Works on Android, iOS, you name it... With prebuilt libraries there is no cross-platform solution to that problem, every compiler has its own way of dealing with that situation and none of them are particularly good, Linux has one way of doing it, MacOS has another way, Windows has its own way, it's a nightmare that the top-rated answer is to just find a way to get one version of the library working altogether. https://stackoverflow.com/questions/10351215/c-two-libraries-depend-on-same-lib-but-different-versions
I'm not antagonistic at all. A awful lot of my time over the last six months has been devoted to integrating a lot of new stuff into my code base. I almost killed myself moving it forward to new style class enums, which was brutal in a code base the size of mine. And I've added lambdas and move semantics and new style typedefs and method deletion and various other things. Those all provide clear benefits, IMO. To me, this is a six of these, half dozen of the other thing, and I see no compelling benefit to changing it. 
\*\*Company:\*\* [VMware](https://careers.vmware.com/engineering) \*\*Type:\*\* Full time \*\*Description:\*\* VMware is hiring for building at-scale with Bazel ([https://bazel.build](https://bazel.build)). This includes advanced features like distributed caching, remote build execution, virtual filesystems, and more. While not C++ per-se, this team helps define how we build C++ and how we consume C++ open source libraries. This is a great opportunity for someone that is passionate about build systems and developer productivity. See the job descriptions below for more details. \*\*Technologies:\*\* Build systems, not necessarily Bazel. Ideally, you have deep knowledge of at least one toolchain such as C++, Java, Go, or Angular, and some experience with embedded or cross-target build environments \*\*Location:\*\* Palo Alto California \*\*Remote:\*\* We will consider remote for the right fit. The team currently has members in US Pacific and Eastern time zones. \*\*Visa Sponsorship:\*\* Yes. \*\*Contact:\*\* * Manager: [https://careers.vmware.com/job/palo-alto/engineering-manager-vcenter-dev-tools/1567/10748321](https://careers.vmware.com/job/palo-alto/engineering-manager-vcenter-dev-tools/1567/10748321) * Developer (multiple): [https://careers.vmware.com/job/palo-alto/senior-build-engineer/1567/10777645](https://careers.vmware.com/job/palo-alto/senior-build-engineer/1567/10777645)
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/apfez3/pointer_to_an_int_array_initialize_declare/eg9hzwq/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Added C++ on Sea flair manually (auto-flair recognizes only that spelling).
"rand Considered Harmful" is true.
This one is not about layout, but still relevant: CppCon 2018: Robert Schumacher “Don't package your libraries, write packagable libraries!” https://www.youtube.com/watch?v=sBP17HQAQjk
If you ask nothing but interview nonsense interview questions, what do you think you will end up selecting for in your candadites? The day I find out I've been paying someone to make a queue that performs like garbage because they wanted to use two stacks to reverse the order on every insertion, is the day I sit someone down for a one on one to see if they can be salvaged and actually get real shit done.
/r/cpp_questions is a better sub for this, I think. Please repost your question there with a full (but as small as possible) example of something you think should work fine, but doesn't. Also, use the "Code Block" button so Reddit knows you're posting code and formats it legibly.
Yeah, don't call virtual functions in your constructor or destructor. It's a recipe for death. 
Maybe I miss where he talks about these points, but the advice here seems really incomplete, and like it could mislead a lot of people. Not declaring a destructor is always better if your type is trivially destructible. That means that there's literally no code associated with destructing it and the compiler can use that information to help it. Declaring your destructor or defining it as anything but = default causes it to not be trivially destructible, taking away that nice property. So yes, the advice is good there (but also a bit, dare I say it, trivial, pun intended). Once your type is not trivially destructible, it's not that simple, and I think Jason's example is somewhat misleading. As he says, the only reason the code is worse is simply because the manual destructor disables the move constructor. You can re-default the move constructor quite easily though. So it doesn't really answer the question of what you should do once you are writing a class with a string member (say). What the video doesn't get into and essentially advises against, is that for non-trivial types, explicitly declaring and defining your special members *is* the most correct thing to do, at least if you care about things like compilation time and bloat. That's because when you write a type and follow the rule of zero, all of its special member functions are being defined in the header. So for example: // Foo.h struct Foo { std::vector&lt;std::string&gt; x; }; In every single translation unit where you say copy construct a Foo, you're going to fully instantiate and compile the copy constructor for `vector&lt;string&gt;`, and for `string`. A better approach, in most cases, if you're non-lazy enough to follow it, is this: // Foo.h struct Foo { std::vector&lt;std::string&gt; x; Foo(); Foo(const Foo&amp;); Foo(Foo&amp;&amp;); Foo&amp; operator=(const Foo&amp;); Foo&amp; operator=(Foo&amp;&amp;); ~Foo(); } // Foo.cpp Foo::Foo() = default; Foo::Foo(const Foo&amp;&amp;) = default; ... In this example it probably doesn't seem so bad and there's a decent chance that you are anyway using string and vector&lt;string&gt; in that TU. However, all this stuff recursively accumulates. So if you never use this technique, eventually the higher level classes in your code are going to have really bonkers sized special member functions (including destructor). People are more diligent about putting "real" constructors in the .cpp because they actually implement them, but when following the rule of zero they are leaving the rest in the .h, usually without realizing it. In some situations you may want these things inlined (maybe the move operations at least), but 99/100 I'd prefer constructors, copies, and destructors not to be inlined and not to be compiled multiple times. Unfortunately, this is yet another example where the easiest behavior in C++ (just follow the rule of zero, don't do anything!) doesn't yield the most optimal results.
Because constructors run in order, from most derived to least derived. So during the execution of the `Base` constructor, the thing you're dealing with _is_ of type `Base`. It _can't_ be of type `Derived`, because the constructor for `Derived` hasn't been called yet. Think of it like a multi-story building. `Base` is the first floor and the sign in the lobby about where to go for a given person is the vtable. When the `Derived` constructor starts, it adds another floor to the building and re-paints the sign in the lobby so the pointers are valid. 
"This is a string literal". const char *
One problem with these types of discussions is that different people work on different types of software. They may give you an answer that's perfectly valid for them, but utterly wrong for someone else. If you work on large scale software, almost anything you can do to keep code out of line is a good thing. When changing one line of code requires 30 minutes of rebuild, that's a horrible use of time. The modern thing of doing almost everything in templates is horrible from that perspective. I wonder how much of that comes from people who spend most of their time worrying more about the academic aspects of it and not so much time slogging out significantly sized code out in the real world. Also, though a lot of people don't think about it these days apparently, if you have inlined code, you cannot put out a 'patch DLL' or library or whatever it is in your world. When the code is inlined, then though it is ostensibly library code, it's not actually in the library, it's who knows where throughout the code that uses that library. That makes it impossible to patch and release. For people doing trivial software that may not matter. But for large products, where having to do a full release comes with a lot of overhead and risk, it matters. &amp;#x200B;
Are you assuming NULL == 0?
Yeah, I literally just skipped around the video (watching about a total of 20 seconds worth) and got the point. Tried too hard to make this a video.
Agreed. Unless almost every interview video out there is basically very unusual, interviewing for a job as a software engineer is a very, very broken process. They tend to obsess about minutia, and about minutia that is almost guaranteed to have nothing to do with what the person is going to be hired for. I guess that algorithms are important. But 99% of code has nothing to do with some super-tricky and/or uber-optimized algorithm. And you typically know when and where that code is, or can find out fairly easily (nature of the problem domain or performance profiling.) The rest of it is about a lot of other stuff that is ultimately far more important in the bigger picture. If they ARE hiring someone whose job it is just to write super-tricky and/or uber-optimized algorithms in the small, then fine. But that's seldom the case. &amp;#x200B;
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/apmnuf/visual_studio_windows_compiler_issue_c/eg9oga2/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
That's incorrect - variadic templates *don't* suppress CTAD. Observe: C:\Temp&gt;type ctad.cpp #include &lt;type_traits&gt; template &lt;typename... Types&gt; struct Meow { Meow(Types...) { } }; int main() { Meow m('x', 1729, 3.14); static_assert(std::is_same_v&lt;decltype(m), Meow&lt;char, int, double&gt;&gt;); } C:\Temp&gt;cl /EHsc /nologo /W4 /std:c++17 ctad.cpp ctad.cpp C:\Temp&gt; 
Again. Why do you think it's nonsense? Why do you think that the person that knows what stack and queue is and can implement one in terms of the other would use this solution simply because and not understand it's consequences? What questions do you want?
&gt; I guess that algorithms are important. But 99% of code has nothing to do with some super-tricky and/or uber-optimized algorithm. And you typically know when and where that code is, or can find out fairly easily (nature of the problem domain or performance profiling.) The rest of it is about a lot of other stuff that is ultimately far more important in the bigger picture. &gt; &gt; If they ARE hiring someone whose job it is just to write super-tricky and/or uber-optimized algorithms in the small, then fine. But that's seldom the case. Nothing about this question is even remotely "super-tricky". It's an entry level question that makes you think. And it tests whether you can think and apply even the basic programming knowledge (or would you call stack and queue "super-tricky" too?) at all.
I meant the general vibe of so many interview videos that I have seen. They are bad in various ways, but most of them seem to share the common problem of just asking the wrong questions, of digging into minutia that doesn't matter, or totally academic stuff that 99% of the time doesn't matter, or algorithms that they will never actually write if they are hired, or always asking whether its O(n-4^2) or O(n-3^2) time and things like that. So I wasn't talking about this one in particular. These've been a lot of these types of things posted recently. 
IMHO "considered harmful" doesn't/shouldn't put a blanket either. It's more like WARNING, huge misuse potential.
Or almost always use it.
So I read your question. I went back and changed everything to use `std::visit` (specifically the `if constexpr` arms in [the example here](https://en.cppreference.com/w/cpp/utility/variant/visit )) to see if I had succumbed to FUD. I got a 1% slowdown 😝
Hmmm. Thanks for the clarification. Why is it needed in this case? Does the guideline create a "fake" constructor for us, since it's an empty struct?
You are assuming only the worst outcomes are mistakes, smart pointers prevent near all catastrophic failures but they can't prevent wasting memory due bad design. I have seen a case where failure to reduce the scope mixed with a loop and a large enough file caused the application to grow its memory usage fast enough to slow down the system and crash. 
Changing the destructor to a different stateless one will create no overhead so it's still the best solution.
Depends what you want. It never promised cryptographically secure random numbers, just numbers that look random enough for an application that doesn't care much.
I assume it's another case of Program Ill-formed; Diagnostic not Required?
I approve (obviously)
The lack of nuance in the title and slides does damage to the C++ community. I hope the members of my team don't see this presentation and start quoting it, because the title and data are extremely misleading. &amp;#x200B; You mention Meyers guideline of "Declare functions noexcept if they won't emit exceptions", but the function you use for your inlining benchmark has a conditional throw! &amp;#x200B; You use the "considered harmful" click-bait title, when half or more of the cases in your benchmarks perform better with noexcept. &amp;#x200B; So yes, if you violate the reasonable guidelines, you will end up with bloat and performance penalties.
I've honestly almost never heard someone assume that. I think it's more of a caricature, or a straw man, than a view held by many people. Most people I know understand that map is very slow, unordered_map is pretty slow (for a hash table certainly), deque is pretty weird, etc. They are decent points to start and come back to benchmark because they have very well defined interfaces and nowadays most C++ hash table replacements provide a mostly equivalent interface, but sometimes you know in advance you don't want to use an STL data structure. I think most people accept this and people who think otherwise are in a tiny minority. That said, the number of people who will decry even using something like `unique_ptr` for "reasons", is not a tiny minority. Probably still a minority, but a very loud minority.
Ok, [here's a proof seven different ways](//wandbox.org/permlink/lYksTUrqvzHbBS9b) that string literals are arrays. [The standard](http://eel.is/c++draft/lex.string#6): &gt;An ordinary string literal has type "array of _n_ `const char`"
&gt;Good to hear. Already stared to worry that the project got near dead after 3 month of no activity. &gt; &gt;P.s. How does the support for websockets look like. Coming soon. The existing websocket project will be rewritten again!
https://wandbox.org/permlink/sCqAb6XqGKhWh0Z1 "Hello World" is a const char *
However, it is taken as a blanket ban. Now the blanket ban is probably useful for 10-20 years, but after some time, enough time has passed and the culture has changed sufficiently, that you can chill out.
Good job. How do you think it compares to other available solutions? (E.g. cpprestsdk)? 
Not to mention semaphores and designing the data layout and access patterns to minimize data races without ending up with lots of heavy sleepers.
`auto` applies array-to-pointer conversion to the right side of the assignment.
&gt; just numbers that look random enough Which `rand` doesn't, especially when `RAND_MAX` is a 16-bit value, as it is with MSVC.
Depends on your needs, maybe you just want to simulate one dice roll. Plenty of older games had a 8 bit RNG that you could abuse, but it looked random enough for most people.
&gt; To me, this is a six of these, half dozen of the other thing, and I see no compelling benefit to changing it. I don’t think discriminated unions are a negligable tool, I would bet they’re fairly common in C codebases as well.
How does `default`-ed destructors affect code bloat? Example, `~Foo() = default;`.
Could've trimmed it a bit, but still good if you are a newbie to the language.
Backing you up, if you try any templates anywhere, you’ll see that string literals are indeed C-style arrays. They carry their size information with them, which enables much constexpr / metaprogramming with strings.
I meant for this particular scenario that was being discussed. Obviously there could be other uses for them. Though, I've written a million lines of code and never used a single one. So they obviously aren't a requirement either. In the few places where I might have used one, memory usage issues didn't argue even for that extra bit of complication, and just the separate values as individual members were just fine, because there never would be enough instances of the containing thing to even worry about it (and in some cases using some of the other values as live alternate representations was also part of the scenario so they needed to be separate.) 
I guessed right, as I see you are upvoted. I include them with the header in a final / optimized build, but I *don't* otherwise. I make these functions out-of-line and include the inl file in the cxx file, thereby speeding up the build, by making less code "visible" in headers. The simplest manner is to just use `#if(n)def _DEBUG` to include them or not in the hxx/cxx. Doesn't work with templates, of course. 
&gt; for_each should be used instead of range-based for loops in most cases, because it encourages us to create correct abstraction levels. Ugh no? I mean, it does encourage people to think in functional way, but one shouldn't just use it for the sake of that.
The transform iterator caching its result seems to me to be the best solution. The filter may or may not return a reference, so it can't reasonably do it.
But it's so ugly. 
I've already answered all of this but again, it's nonsense because it is about figuring out a terrible way to do something with arbitrary restrictions that don't exist. There is no rationale for doing this, ever. When I interview people, I focus on projects they are proud of, what they did on them, what problems they faced, and how they overcame them. If I asked how to make a queue with two stacks that will for some reason have much worse scalability than the most obvious approach, and their answer was anything but ' why are you asking me this ' or ' I don't think I'll be a good fit here ' it would be a red flag. Do you think asking about how to implement a bogosort is a good idea too?
&gt; Is this function [`ctype::to_lower`] actually supposed to behave like this and not convert multi-byte characters? Yes. C++17 §25.4.1.1.2/9: "The second form replaces each character `*p` in the range `[low, high)` and for which a corresponding lower-case character exists, with that character." &gt; Because that makes it kind of useless. Yes, almost all the C++ text handling machinery's design is pre Unicode. Unicode was originally an attempt to provide a fixed character size solution for international text. That failed. &gt; It doesn't seem like there's any way to do this properly in C++ either except converting to `wchar_t ` Even with conversion to UTF-32 you're not guaranteed one value per logical character. So it essentially boils down to which character set you want to support. For plain ASCII the C++ `char` based facilities are OK, and for characters in the Basic Multilingual Plane, corresponding to original Unicode, the `wchar_t` based machinery is at least usable. &gt; praying that nobody comes across a 3-byte uppercase character on Windows. Right, but note that Windows itself has nothing to do with this. The problem is that C++ compilers for Windows (including MinGW g++) are very much deficient in their handling of UTF-8 as execution character set. E.g. currently no support for `main` arguments, or environment strings, or outputting narrow strings via wide streams, or just the C++03 functionality that involves filenames. It's near 0% support. 
Also `rand` often cycles the low bits in a way which _really_ doesn't look random if you just do `%` to get your number.
C++ has notoriously poor support for utf8, boost or ICU usually should do the trick, e.g. boost::locale::generator gen; std::locale::global(gen.generate("")); std::string s = u8"This Is Ä Test"; std::cout &lt;&lt; boost::locale::to_lower(s) &lt;&lt; std::endl; Partially, poor support can be excused because of how complex the problem is, I guess.
Trigraphs are gone!
&gt; That means that there's literally no code associated with destructing it and the compiler can use that information to help it. Maybe this is just me quibbling over semantics, but I think it would be technically more correct to say that there's no code associated with destructing the type aside from the standard behavior of destructing the member variables. Or am I mistaken on your meaning? &gt; What the video doesn't get into and essentially advises against, is that for non-trivial types, explicitly declaring and defining your special members is the most correct thing to do, at least if you care about things like compilation time and bloat. Could you clarify on how defining the special members improves compilation time and bloat? I assume you mean because it allows various container types to use more optimal versions of things. &gt; In every single translation unit where you say copy construct a Foo, you're going to fully instantiate and compile the copy constructor for vector&lt;string&gt;, and for string. A better approach, in most cases, if you're non-lazy enough to follow it, is this: In the example that you provided, while you're certainly not generating a new instance of every special member function in every translation unit, what you are doing is ensuring that the compiler has no idea whether your type has a defaulted constructor / destructor / assignment operator setup. Can you go into more detail here? While compile times are obviously a serious concern, I'd much rather not lose the runtime efficiency that can come from the compiler knowing that my type has a defaulted constructor / destructor / so on. Of course, every team has to make that decision for themselves, but I think people should be aware of the effect of doing it the way you showed in your example.
One thing that you can do is have a cache range which holds a copy of the current value. Here is how you would use a hypothetical ranges::view::cache ranges::push_back(results, numbers | ranges::view::transform(times2) | ranges::view::cache | ranges::view::filter(isMultipleOf4)); &amp;#x200B; The implementation of the cache\_iterator would look something like this &amp;#x200B; template&lt;typename T, typename Iter&gt; struct cache_iterator{ Iter underlying_iter; Iter underlying_end; std::optional&lt;T&gt; value; T&amp; operator*(){ return *value; } cache_iterator&amp; operator++(){ ++underling_iter; if(underlying_iter == underlying_end){ value.reset(); } else{ value = *underlying_iter; return *this; } }; This way the user can decide if it is worth it to cache or not (with times2 it might not be).
True, but having things that don't look random is still possible in real life. As long as it's not too blatant, people don't notice. Obviously if you need semi-decent random numbers, don't use rand.
&gt;Partially, poor support can be excused because of how complex the problem is, I guess. As almost every other popular and widely used language out there has better support for dealing with Unicode (beside C), I think you could still blame C++ for not having tools in its standard lib to deal with Unicode. You simply cannot tell a customer anymore that he can't use a German Umlaut because your software can't deal with it... Imho C++ lacks an internal Unicode aware string type. This could be the base for all basic text transformations. You switch to ``std::string`` by encoding your Unicode and transform it by decoding it with an appropriate encoding. Then you have a clear separation between byte based text representation (the status quo) and an *abstraction* for internal representation of text. No problem with backward compability and a simple solution.
&gt; Make can do it as well *How*? The only way I know of to get that would be to put a concrete, realized build target and command (i.e. no variables) for each `foo.cpp` into a `foo.make` file and then include those (a la the "vomit `.d` files everywhere" solution to automatic include dependencies), or additionally put each variable definition into its own file and then you can remove the restriction that prohibits variable use. Targets would then be something like `foo.o: foo.cpp foo.make`, and in the second case additionally `foo.o: CXX.make CXXFLAGS.make ...`
&gt; I define a "correct build" as one where if a file changes all files affected by that output are regenerated. It's interesting you mention this, because in C++, the "correct" (est) way to determine which files affect which outputs is to use the compiler's header scanning. (On gcc and clang, this is the `-MD` flag.) If your build system doesn't do this, then it needs the developer to provide stronger guarantees, tantamount to hermeticity (i.e., you have to somehow list all the sources and headers, transitively). This is a subtle point. Most metabuild systems get it at least _slightly_ wrong.
&gt; Even with conversion to UTF-32 you're not guaranteed one value per logical character. Not even after (composition) normalization?
* I'm not even sure if there's a precomposed character for every combination of composite sets out there * Composition can probably be considered a data loss * You need to support Unicode first to perform composition :\^)
There are some ways to get better assembly (no vtable with function pointers) and keep the visit functionality (not std::visit though): 1. The mpark variant ([https://github.com/mpark/variant](https://github.com/mpark/variant)) was changed to use switch based visitation not long ago. 2. You may use std::variant and roll you own visit function based on boost::mp11::mp\_with\_index function. I personally use the second option in my projects and I've never needed to visit multiple varaints though: \`\`\` template &lt;typename Variant, typename... Visitor&gt; constexpr decltype(auto) visit(Variant&amp;&amp; var, Visitor&amp;&amp;... vis) noexcept { auto fun = boost::hana::overload(std::forward&lt;Visitor&gt;(vis)...); return boost::mp11::mp\_with\_index&lt; std::variant\_size\_v&lt;std::remove\_reference\_t&lt;Variant&gt;&gt;&gt;( var.index(), \[&amp;\](auto idx) noexcept { return fun(\*std::get\_if&lt;idx&gt;(&amp;var)); }); } \`\`\` The upside is that the 'visit' functionality will give you compile time errors if the variant changes. The downside is that you may need to introduce new 3rd party dependencies to your project(s) and this may not be an option.
thank you for the feedback regarding the developer community, I'll pass it along and I'll get back to you on that, just to be clear, we're going to consider your feedback regardless, we had some internal discussions about it already one way to force it and basically get what you want is to change the cmakeExecutable in CMakeSettings.json to something that's not on disk, or leave it empty, and that should prompt the CMake install
Nope, not even then. A single visible character can be comprised of infinitely many [combining characters](https://en.wikipedia.org/wiki/Combining_character). See also: [grapheme clusters](https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries).
I assume by MRs you meant PRs, it's already in Kitware master and it'll be in CMake 3.14
"One Simple Trick for Reducing Video Bloat"
Use what suits best and get on with your life.
Range-based for loops become a lot more powerful with a couple of little range tools in your toolbelt: for (auto const&amp; element : reversed(container)) for (auto const&amp; element : range(container.begin(), container.begin() + N)) 
Can't we add a new function for iterating ranges `std::nextval(Range) -&gt; std::optional&lt;T&gt;` that by default does something like: auto it = std::next(r); return it != std::end(r) ? *it : std::nullopt; And then the view::filter can customize it to do: for (auto&amp;&amp; v : r) { if (predicate(v)) return v; } return std::nullopt; Then we would need to add support for it in the range based for loop, and all the current algorithms to use it. Or another option can be to add the suggested \`view:cache\` but now we would only need to add it at the very end of the range just to transform the iteration from std::nextval to the current ++ and \*
I have to say that comparing syntax to the [Qt Http server](https://blog.qt.io/blog/2019/02/01/qhttpserver-routing-api/) that was listed here recently is quite involved: BeastHttp: router.param&lt;http::param::pack&lt;int&gt;&gt;(boost::regex::ECMAScript) .get("/user/param[?]y=(\\d+)", [](auto /*request*/, auto /*context*/, auto args){ assert(std::get&lt;0&gt;(args) == 1992); }); Qt route("/user/", [] (int year) { assert(year == 1992); }); //or route("/user/", [] (int year, const QHttpServerRequest &amp;req) { assert(year == 1992); }); or is there an "easy-mode" I missed?
when the CMake install prompts and is accepted, it will install the bits we had pre-setup on a web location, they are not inbox with VS, so that means you can get the latest CMake version even if you use an older VS version; we keep close track of Kitware releases, so likely will be the latest, note this machinery applies only when targeting Linux; you also have knobs to specify your own version of CMake, in whichever location you had it installed at, using cmakeExecutable
Removed visit from my projects and changed to tagged unions. Much better! I think visit must be deprecated till inclusion of pattern matching to standard.
&gt; maybe you just want to simulate one dice roll. If I did, I would want something that offers uniform distribution. Which rand doesn't. Maybe you could try actually watching/reading the cited 'rand() Considered Harmful' before dismissing it, as it addresses _exactly this_...
I have to admit I've used `istrstream` more than once; sometimes the copy inherent to `istringstream` is just too expensive, and while it's not much code to reimplement in a slightly safer manner.. it's already there, and still works for now.
I just want to generate data that has a low compression ratio.
More so if you combine it with structured bindings: \`\`\` for (auto&amp;&amp; \[i, elem\] : ranges::view::enumerate(elem\_range)) for (const auto&amp; \[key, value\] : some\_map) for (const auto&amp; \[a, b, c, d\] : vector\_of\_tuples) \`\`\`
MSVC was also changed to use switch-based visitation, and libc++ is going to soon as well (I don't know about libstdc++). Point being: issues with `std::visit` appear to be a temporary QoI problem, and not a great reason to avoid it.
just don't refactor your code based on blogs
Hi /u/VinnieFalco, thanks very much for Beast! Are you planning to merge a high-level API such as this one into Beast?
Why does `stringstream` copy and why does your use case trigger it so often?
Wish something like this existed for Qt Creator. Catch2 is such a wonderful library.
I would say it's false in that it downplays the seriousness of the flaw. It's not just considered harmful. It is. The use of the snowclone headline makes it come across like an inflammatory opinion piece, as most other uses of the headline are.
How do you give an `istringstream` a pre-existing sequence without copying it? I can't imagine having string-like data that isn't in a `std::string` is that uncommon (`std::string_view` or `std::span&lt;char&gt;`, anyone)...
It's called MR on GitLab (Merge Request), not PR. :-) Okay cool, thank you, awesome!
Yes, but why are you doing that so often?
Using `malloc()`/`free()` or `new`/`delete` to manage memory yourself is basically guaranteeing leaks. Making sure `valgrind` or `ASAN` doesn't complain is not nearly enough. In C++ basically every function can throw, so unless you covered in your tests all combination of all exceptions thrown from all places you *will* get leaks, unless you do `-fno-exceptions` (or whatever it is called). Doing this is equivalent of loading a gun and aiming it at your feet.
You can absolutely use "transform" to get a reference, e.g. using it to transform a list of indexes into element references. IMO the problem here is the "filter" view's iterator calling `*it` _twice_ - once on `++` and once on `*`. It should be caching it if possible - which would require the returned type from the underlying *it to either be usable in an optional, or a reference (which could be stored in a nullable pointer, which is basically an optional reference (something that otherwise doesn't exist yet in C++)).
"So often"? I rarely use iostreams as a solution for anything; all I said was I've used it more than once, which is more than I can say for the vast majority of deprecated functionality. My only point was that it's not as utterly useless as you made it out to be. ;-]
That's the thing. `into` is a normal function from a normal trait (at least, I don't think `From` is supposed to have any magic in it). This isn't `Foo` being implicitly cast into `Bar`. This is `Foo::into` resolving overloads based on expected return type (expected here because it gets used by something that definitely needs a `Bar`, and there's an overload of `into` that satisfies that, so it's chosen). E.g. I don't think it'd work if you add another call to `takes_baz`, even if you have a `From&lt;Foo&gt; for Baz` implemented. Because `into`, here, can't resolve to a unique type. There's no implicit casting here. To be clear, this's something that _can_ be emulated in C++ by a wrapper, but it's a property of classes, not normal functions.
The author seems conflating vulnerabilities with bugs. 
Perhaps I should have worded it differently. My point was that using unique pointers instead of raw pointers will solve problems and will not introduce new ones. Indeed, they do not protect from all design flaws.
I agree that it's a QoI problem. You are right about the noexceptness. It's just that most of the time I start with noexcept and later make it conditional or remove it if it needs to support exceptions. However, this visitation is, kind of, generic functionality and it'll be better if I make the noexceptness conditional. The code base uses std/boost::error\_code and/or boost::outcome to report failures in most of the cases. Exceptions are used but mostly in the initialization phase of the application.
One more nitpick ;-] There's no point in `visit` returning `decltype(auto)` if the lambda you pass to `mp_with_index` doesn't do the same, since by default lambdas return `auto` (i.e. decay their return types).
I͝t̯̼̺̼͈ ̲d͈̣͍̼̥͡ḛ̰̖͝p̩̪͍̖̭̲ęn̼̯̰͕d̠̙͔̰s̤ a̛̱̗͔͔͇ ̘͎̱̖b͝i̴̜̦̹͎͇̺t̘ o͉͈͉n̝̗̰̯̘̘ ̝̺̥̤h̰̠ow͓̩͖͍̺͟ ͈̜o̳͍̹͈n̥͇͎͢ d̹e̸̖f̛̬̫̰̠̩̺ì̺̮̰̞n͉͉̯͚͔̤̫e̫͉͍̬̬͉s̬̹̫̤̻̖ͅ ̝͖͕̣̺͎͎̕"̷̙̩͉̹̭̰c̙͙͈̲͉h͔͈a͍̲r̺a̢͚̞̬͎c͔͖͖̝͎̕t͉͠e̦͕̱̫̹͓̺r͏͉̦"̜̯̙̳̹́,̡̺̰ͅ ͓I҉͎ ̖̪̺͉͝tḥi̥͖̻̕n͠k̝.̣ ͉͕I'̨͖̱̱͉̥̻m̴͎͍ ̜͚̝͓̭͚n͖̞͟o̡̻͙̠͙t̲̲̺̲ s̟̬̼͎̰͓ư̙̫͖̱͈r̳̻͕̮͕͕͠è.̥̣͔̜̺͈
A bug isn't necessarily a vulnerability but every unintentional vulnerability is certainly a bug.
Do modules allow circular dependencies? If they don't, Boost will have a hard time switching 100% to modules.
I think it is an important question, therefore I'll give it a try to formulate reasonable response :-). &amp;#x200B; I recommend learning about modern C++. There are so many features in the language which make developing C++ applications much safer. From features for multi-threading, reference counting (smart pointers) to syntactical sugar with lambda expressions, r-value references and much much more... The language you are probably used to (c-like c++) has little in common with what modern c++ is like today. &amp;#x200B; Also think about other people who have to work in the same team or have to later maintain the project. I usually use C only if it is absolutely necessary (e.g. a portable API, kernel module,...). &amp;#x200B; Regarding certain C++ features which were mentioned in other posts already. I'd recommend to ignore some of those posts. There are no general rules like "shared\_ptr is a design flaw in 99% of cases". Each of those smart pointers (shared\_ptr, weak\_ptr, unique\_ptr) have their specific purpose which is well documented on [http://en.cppreference.com](http://en.cppreference.com) . I recommend using them in general to avoid manual memory management. Which one, depends on the use case. That said reducing modern c++ to just smart pointers does not do this language justice. I only commented on this topic since the discussion in this thread is in my opinion particularly misleading. &amp;#x200B; &amp;#x200B; &amp;#x200B;
I think this is a great point, if "modules" (whatever they end up being) can't handle real-world scenarios look boost, they are dead in the water. "Consider if you will a spherical chicken ..." :-P.
No, I was asking what were you doing that you would have needed to change the underlying string so often on a stringstream as to become a performance issue? Sounds like a design problem on your end. It's not about useless. strstream is deprecated. It wasn't deprecated for no reason.
All the examples given can result in undefined behavior, which is generally considered bugs. Otherwise the argument is “works on my machine.”
Now why would I do that
Yes but I wish compile times were better ☹️
\*sigh\* &gt; No, I was asking what were you doing that you would have needed to change the underlying string so often on a stringstream as to become a performance issue? Who said anything about changing the underlying stream? It's an input stream – no one's mutating anything, simply extracting. The issue is _supplying_ the underlying data, which always involves at least one copy, or more if you don't have a `std::string` to start with. &gt; Sounds like a design problem on your end. Thanks for assuming! My usecases involved using other libraries, written by other people, that unfortunately took `std::istream&amp;` parameters. Bad design? Sure, now, in 2019. Uncommon? No. A design problem on _my_ end..? &gt; strstream is deprecated. Yes, I said as much. &gt; It wasn't deprecated for no reason. It was deprecated was because of the high risk of memory leaks for `std::strstream` and `std::ostrstream` – note which type _I_ was referring to. The bottom line is it's still the only option in the stdlib that offers a way to extract data from a string-like source without.. copying the string-like source. It's easy to reinvent to avoid the deprecation stigma, but again, I already said that. It hasn't been retained since C++98, even into C++20, for no reason. I'm not debating anything here and I've said my piece. Have a nice day. ;-]
Ok thanks. Just out of curiosity, did the project have a fairly comprehensive library or libraries of existing functionality that it was able to leverage? Generally when I see comments like what you mention regarding being "too complicated" those seem to come from someone who believes every program written in C only uses the basic libc and has to create all other capability by hand. This is often aggravated by not really having a central hub of available C libs or a dependency manager to use. 
I don't think the boost library is very 'real-world'...
have you heard of \[doctest\]([https://github.com/onqtam/doctest](https://github.com/onqtam/doctest))? almost the same features as Catch, but \[way faster\]([https://github.com/onqtam/doctest/blob/master/doc/markdown/benchmarks.md#compile-time-benchmarks](https://github.com/onqtam/doctest/blob/master/doc/markdown/benchmarks.md#compile-time-benchmarks)) for compilation.
I agree with /u/Leandros99 that use of shared_ptr is a design flaw, but I can understand why a lot of people see it as a magical solution to a lot of problems. The main issue I've found with shared_ptr (besides the direct performance concerns of the atomic increment when copying and the allocation/deallocation issues with the control block) is that they are infectious. Once you start using them, it tends to require that a lot of other things become shared so that lifetime is correctly preserved; this creates a tangled mess of ownership and often results in problems during destruction due to circular dependencies
Yes they do, but only if it's not interface circular dependencies
real world: Drawn from or drawing on actual events or situations I'd say boost clearly qualifies, also it's listed first here: https://en.cppreference.com/w/cpp/links/libs Now, if you mean "boost is written is a sort-of funky way", that's pretty non-controversial but you can be sure that modules will need to handle these scenarios and even more exotic ones if they ever intend to match up to their hype. 
Nope, Beast will remain a low level building block - there are so many ways of building a REST service library or application, that no matter what I do it will make some people happy and others not happy. So it is better to leave this task up to the community to build many different REST projects in different styles with different features, and then people can choose the one that suits them best.
Smart iterator not so smart
&gt; Who said anything about changing the underlying stream? You did: &gt; How do you give an istringstream a pre-existing sequence without copying it? --------------------- &gt; which always involves at least one copy, or more if you don't have a std::string to start with. That's what I'm asking about. It only takes at most one copy. That's cheap. You making it sound like the extra copy is so unbearable you have to resort to deprecated strstream. You can sigh like a prat all you want. You still haven't given a good reason for this: &gt; The bottom line is it's still the only option in the stdlib that offers a way to extract data from a string-like source without copying that entire string-like source. Who cares about one extra copy? You only need to copy it once. That's cheap. If that's not cheap, then I'm asking why are you making so many copies? Is it so bloody hard to understand?
Reflection will make it straightforward to implement this - you can just write a function that takes an arbitrary aggregate and prints a `{` then each of the members delimited by `, ` and then `}`. You don't need any core language changes outside of reflection.
&gt; It only takes at most one copy. Unless you have a `std::string_view`, or a `std::span&lt;char&gt;` – again, as I already said. &gt; That's cheap. Oh, you know the quantity of data in question for these applications you've never seen? I'm done replying to your idiotic fallacies.
I haven’t. Thanks!
&gt; Oh, you know the quantity of data in question for these applications you've never seen? If the quantity of data is huge, I DON'T USE IOSTREAMS IN THE FIRST PLACE. I assumed you were using strstream for something small and negligible because, for some stupid reason, I didn't think anyone could be so stupid. Given that's not the case, then, yes it is a design problem on your end. My idiotic fallacies. I was an idiot for assuming a rational person wouldn't use iostreams for large amounts of data.
You are right again. I really miss code reviews at my current company. Now I got one by incident :). Thanks.
Can the reflection functions then also create new member functions, so in the class itself something simple like`create_ostream_here()` suffices? And the time frame is definitely 23 and not like the C++11 modules time frame?
Even in C#, reflection is often not recommended for use due to edge case high impact bugs and reduced maintainability in many cases. So I agree with this sentiment unless someone can provide a succinct summary on why you would use reflection in C++ &amp;#x200B;
&gt; There is no issue with duplicate symbols in header only libraries. What's the basis for this claim? I just pointed out a specific example where there is a problem which is both known and explicitly documented by the author. Some libraries are fine. Examples could include `fmtlib` and `mpark.variant`. Others are not. Regarding convenience, it's rare that you should need to "figure out" how to build a library. The vast majority use standard methods so work with ease, and the most common ones are already packaged for pretty much every platform. With vcpkg, this now includes Windows. Using third-party libraries is not an excessive burden. &gt; There is absolutely nothing you can build using separate source/header than you can't build using header-only. This is demonstrably false. There are plenty of situations which require the use of variables defined in a single translation unit, which would no longer work when placed in a header. The above example is one of them; you have a separate registry of loggers for each library and/or executable including the header-only library. Ideally, you'd have only one, and if you had put that in a single translation unit you would have exactly this behaviour.
Networking
Considering the topic was about how boost is implemented, yes, I meant how boost is written... Boost is used in the real world, but people don't write Boost-like code in every day life... We may argue whether Boost is over-engineered and that's certainly another topic, but the way it's written is obviously not like real world code. :|
https://www.cs.utexas.edu/users/EWD/transcriptions/EWD13xx/EWD1308.html &gt; Finally a short story for the record. In 1968, the Communications of the ACM published a text of mine under the title "The goto statement considered harmful", which in later years would be most frequently referenced, regrettably, however, often by authors who had seen no more of it than its title, which became a cornerstone of my fame by becoming a template: we would see all sorts of articles under the title "X considered harmful" for almost any X, including one titled "Dijkstra considered harmful". But what had happened? I had submitted a paper under the title "A case against the goto statement", which, in order to speed up its publication, the editor had changed into a "letter to the Editor", and in the process he had given it a new title of his own invention! The editor was Niklaus Wirth. So, Dijkstra wrote the article whose title originated the "X considered harmful" phrase, but it was Niklaus Wirth who wrote the title itself.
I didn't say it would be a good roll. But maybe you don't care about that. Are you trying to misread my message on purpose? You can hardcode a result for your die and it still looks random the first time (even if it's not).
I would definitely NOT do that... This seems quite invasive and hard to get right, specially if you are dealing with cross-platform development. I'm used to work with clang plugins/tools, but this sort of reflection demonstrated here is usually required for cases where you need RPC or some other sort of serialisation. In those cases, it is better to have an third tool with some schema syntax, and isolate the types required for serialisation to specific targets... that's pretty much what tools like protobuffers do.
Even today you can mostly achieve that with magic_get: https://github.com/apolukhin/magic_get
&gt; But maybe you don't care about that. Are you trying to misread my message on purpose? No, I just don't see any possibility of me not caring about that, ever. If I care enough to write the code at all, I care enough to write the extra couple lines to do it right. That may just be me, but I doubt it.
I believe SG-16 will deliver a set first-class high-quality Unicode utilities over the next 6 years :)
Earlier I did some work with \[packs of packs\]([https://stackoverflow.com/a/50417140/3151829](https://stackoverflow.com/a/50417140/3151829)), but before \[P1221\]([http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1221r1.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1221r1.html)). It may be useful for your approach.
&gt;What's the basis for this claim? I just pointed out a specific example where there is a problem which is both known and explicitly documented by the author. You haven't pointed out anything. &gt;Regarding convenience, it's rare that you should need to "figure out" how to build a library. I see you have never had to use C++ on anything but Linux and vanilla Windows. Try building libraries to work on Android, Cygwin, PS4, iOS, Solaris, etc... and tell me with a straight face there's no issue building C++ libraries. &gt;This is demonstrably false. Your ignorance is not a form of demonstration. If you want a variable to be defined in every translation unit independently of every other translation unit, you declare that variable as static: ``` static Registry r = ...; ``` The ```static``` keyword ensures that every translation unit gets its own independent declaration of the variable. If you want the variable to be shared among multiple translation units then you declare that variable as inline: ``` inline Registry r = ...; ``` Those are the only two possibilities for how you can ever declare a variable.
It would be interesting to see the breakdown of security bugs vs language: C, C++98, C++11, etc. Are the use-after-free issues mostly related to hand-rolled malloc/free, or complicated construction/destruction chains, or ... ?
&gt; Those are the only two possibilities for how you can ever declare a variable. Uhhh... `extern`?
CMake does it by putting flags in a file and the rule depends on the file containing those flags. This implementation does batch these flag files by target rather than per file because the overhead of all the extra file management isn't worth it. Yes, `make` doesn't do it on its own, but it isn't impossible to implement (as proven by CMake).
There are some diagrams of the relations between boost repos/libraries here: https://steveire.wordpress.com/2016/08/21/boost-dependencies-and-bcp/ With some reorganization to address the cycles, granular C++ modules for boost would be possible. Of course, the extreme alternative to 'one module per library' is 'one big module'. There are are lots of alternatives in between, if C++ modules become a reality.
Yes, that's part of it. A tool that generates a build that doesn't remake `foo.o` when `included_by_foo.h` is changed is not trustworthy and (IMO) strictly worse than a hand-coded `.sh` script that always runs all commands. Whether it discovers this information with compiler help (`-MD`), manually (scan sources manually), magically (Tup with `strace` or DLL injection), or requires it to be spelled out by the build configuration author is an implementation detail. But it must be done. &gt; This is a subtle point. Most metabuild systems get it at least slightly wrong. If you know of somewhere that CMake does this, please file an issue. Note that running *extra* commands is fine (not running rules unnecessarily is an "efficient" build) in general because getting a perfectly efficient build may be unreasonably hard to guarantee (e.g., `Unix Makefiles` is known to not perfectly efficient even with just `add_library`, but I'd be at least slightly surprised if `Ninja` was outside of `add_custom_command` corner cases).
&gt; With some reorganization to address the cycles, granular C++ modules for boost would be possible. Massive reorganization has taken place in the last 2 years – how difficult would it be to regenerate these diagrams with 1.69 or master?
I can only speak from my experience of shoehorning [https://www.boost.org/doc/libs/develop/libs/outcome/doc/html/index.html](https://www.boost.org/doc/libs/develop/libs/outcome/doc/html/index.html) into Modules, but Modules don't improve build times over precompiled headers for template heavy header only libraries in the current implementation of Modules. Boost.Build already supports precompiled headers, so the cost benefit just isn't there to do an upgrade. For those Boost libraries which are not header only, or which can be configured to be almost entirely not header only (Boost.Test I look at you), those *could* benefit from Modules. And lots of effort has been invested into Boost in recent years to separate out its modular structure much more cleanly than from before. Ultimately, C++ Modules are "chunky" things. They only give benefit if they don't do much template work, especially SFINAE, and they are drawn around relatively large chunks of code well separated from its dependencies. They are *definitely* no panacea. The good news on Boost modularisation is that a day is coming soon when Boost.Core will be the only part you can't avoid dragging in when you cmake `add_subdirectory()` just the Boost library you want. It getting surprisingly close in fact, see https://gist.github.com/Mike-Devel/46d04409d6ae6053861706e3ad91e4dc (Note that Boost.Outcome has since added cmake support, but the graph hasn't been refreshed yet)
You never use ```extern``` linkage in a header-only library.
Looks nice. A few critics tho: * `const Args&amp;... args` should probably be `Args&amp;&amp;... args` (used with `std::forward&lt;Args&gt;(args)...` * `EntityManager` is a singleton. * `Iterator` isn't an iterator in the C++ sense. * `malloc` and `free` for arrays should probably be replaced with `std::unique_ptr&lt;T[]&gt;` * Your iterator implementation has to iterate over all entities to find the ones with some set of component. This is really bad if you number of entity ever grows big. You can work around this by storing arrays of entity per component type or by storing entities with the same set of components together. (But these probably require some sort of RTTI)
Even intended vulnerabilities are, objectively, bugs. The difference is that those in power over the codebase may disagree that it needs to be fixed.
Yes, I think everyone is aware of this; however that's a very different statement than the one I quoted.
You quoted me saying that there is only external and internal linkage, my statement stands and if you wish to argue this any further you can discuss it with yourself.
Does doctest have a Visual Studio test adapter like the one OP posted?
&gt; You simply cannot tell a customer anymore that he can't use a German Umlaut because your software can't deal with it... No one is saying that, the same way no one says they can't make a GUI or a networked program in C++
[https://gist.github.com/Mike-Devel/46d04409d6ae6053861706e3ad91e4dc](https://gist.github.com/Mike-Devel/46d04409d6ae6053861706e3ad91e4dc), just 17 days old.
&gt; Or am I mistaken on your meaning? You are mistaken. Trivially destructible means (it's a formally defined term, and a type trait) that there is no code associated with destructing the object. No special pass for member variables. Trivially destructible recursively requires all members to be trivially destructible. &gt; Could you clarify on how defining the special members improves compilation time and bloat? I assume you mean because it allows various container types to use more optimal versions of things. They are getting defined either way. It's just that if you do nothing, they are implicitly defined in the *header*. I'm explicitly declaring them in the header, and then defining them in the .cpp file. This improves compilation time/bloat for the same reasons why defining a function in the .cpp does generally. &gt; what you are doing is ensuring that the compiler has no idea whether your type has a defaulted constructor / destructor / assignment operator setup. That doesn't matter. There is nothing special about defaulted operators, unless the type is trivially (default) constructible/destructible/assignable. You can only be trivially \* if you default the relevant operator in the header file. In any other situation, special member functions are just code, like anything else. &gt; While compile times are obviously a serious concern, I'd much rather not lose the runtime efficiency that can come from the compiler knowing that my type has a defaulted constructor / destructor / so on. The consideration for whether you should make your non-trivial constructor/assignment/destructor defined in the header or .cpp is exactly the same as you would apply to any other function. That is, you would typically only define in the header if it is quite short, and in a performance critical path, so you want it to be inlined. Copying operations and destructors in particular are *not* going to be short functions as soon as you have a single non-trivial STL type like a vector, string, etc. So you shouldn't (if you are being careful) ever define them in the header. Default constructors and moves, you may want to define in the header. Although realistically for a class of decent size, especially considering the recursive nature of these things, you'll very quickly hit the point where it doesn't really make sense to define those in the header either. &gt; Of course, every team has to make that decision for themselves, but I think people should be aware of the effect of doing it the way you showed in your example. I did cover this a bit in the final paragraph but I guess I'm assuming that most people already have a basic understanding of trade-offs in defining in the header vs cpp.
Use a debugger.
You should have posted this over at /r/cpp_questions (as per the rules in the sidebar), but the correct implementation of quicksort in C++ is: #include &lt;algorithm&gt; #include &lt;iterator&gt; template&lt;class FwdIt, class Compare = std::less&lt;&gt;&gt; void quickSort(FwdIt first, FwdIt last, Compare cmp = Compare{}) { auto const N = std::distance(first, last); if (N &lt;= 1) return; auto const pivot = std::next(first, N / 2); std::nth_element(first, pivot, last, cmp); quickSort(first, pivot, cmp); quickSort(pivot, last, cmp); } see: https://www.bfilipek.com/2014/12/top-5-beautiful-c-std-algorithms.html
Serialization/scripting language integration.
&gt;Can the reflection functions then also create new member functions, so in the class itself something simple likecreate_ostream_here() suffices? No, that's metaclasses but it's related. &gt;And the time frame is definitely 23 and not like the C++11 modules time frame? Yes reflection is planned for C++23. Metaclasses however are not, but with a bit of luck we might get them too.
In that case it is probably easiest to use Qt. QString has real good UTF support. Internally it uses UTF-16 but can also read and write UTF-8.
visible characters are not necessarily related to grapheme clusters.
&lt;insert joke about the death tax on inheritance&gt;
Thanks for your response.I didnt know what a debugger [is.In](https://is.In) microsoft visual studio community edition which part should i download for c++ debugging features.Thanks
You should have debugging features in the default install. Take a look here: https://docs.microsoft.com/en-us/visualstudio/debugger/debugger-feature-tour?view=vs-2017 And here: https://docs.microsoft.com/en-us/visualstudio/debugger/quickstart-debug-with-cplusplus?view=vs-2017 Really though your course should be covering this.
No but perhaps it is something I should look into - just [submitted a request](https://github.com/JohnnyHendriks/TestAdapter_Catch2/issues/21) for it
what say? &amp;#x200B;
USA-specific joke, my apologies. Feel free to downvote 
please response of my comment
Where is that stated? No circular dependencies are allowed last I checked.
To be fair, looking at the [cppreference](https://en.cppreference.com/w/cpp/memory/shared_ptr) for shared\_ptr, it's extremely difficult to understand how to use it, what to use it for, when not to use it, and all that. The "example" presented there requires me to know (and care) about threading, mutex, etc.. That's the first reference people point to, and it lacks 1. an example that is understandable to someone without threading knowledge, 2. an explanation as to how to declare, initialize, and delete it 3. information on when to use it. It's easy to say that a good C++ dev who knows all that should be able to use it right, but trying to learn all that is a massive challenge, and honestly, most of the time I just want a pointer, and it seems less work to use raw pointers and cover every weird exception and edge case than to read pages of documentation that I don't understand.
Sarcasm? 
:=)
the examples on cppreference require advanced knowledge, often of threading and all that. Is there a better resource for advanced examples focusing only on the thing they're demonstrating?
This is not the place to post about C++ basics.
Easy enough. I can do that. However, I know that some of the cycles are deliberately not going to be removed. The maintainers don't want to remove them.
&gt; EntityManager is a singleton. Haven't taken a deep look at the code or anything (and I'm not an expert by any means) but I'm not sure how `get&lt;T&gt;()` could be implemented reasonably otherwise. This design at least seems to require a static collection for each entity type, which makes sense since there's no way that I know of to template a member variable. The closest alternative I can think of is taking a template parameter pack where each element is a component type, then doing variadic inheritance to inherit a container of each type from a helper class or something. Even then, though, the client code is required to pass in every single component type on EntityManager declaration. I've been sorta running over in the back of my mind how to implement a `get&lt;T&gt;()` that satisfies DRY AND doesn't rely on static containers. Don't think I've come up with anything though 
ok, but this post useful or not.please give the response.
There is some kind of a solution but it requires RTTI: [https://stackoverflow.com/a/49397130/6860744](https://stackoverflow.com/a/49397130/6860744)
No.
Hmm. I actually just realized you could probably use the ol' templated-address-of-static-struct trick to avoid using RTTI. There'd still be overhead though from the map lookup. Kinda interested in toying around with that now, thanks for pointing that out.
why
And some of them are in Rust.
Not if you wrap them in an RAII class. (Which may be what you meant). template&lt;typename T&gt; class Owned { T *p; public: template&lt;typename... Args&gt; Owned(Args&amp;&amp;... args) : p{new T(std::forward(args)...)} {} Owned(Owned &amp;&amp;other) noexcept : p{std::exchange(other.p, nullptr)} {} Owned &amp;operator=(Owned &amp;&amp;rhs) noexcept { if (this != &amp;rhs) { delete p; p = std::exchange(rhs.p, nullptr); } return *this; } ~Owned() {delete p;} T &amp;get() noexcept {return *p;} const T &amp;get() const noexcept {return *p;} operator T&amp;() noexcept {return get();} operator const T&amp;() const noexcept {return get();} };
I believe in C++23 you may be able to solve this problem like this: struct Hello { template&lt;typename T&gt; T&amp; get() { constexpr { -&gt; Hello::{ T _var_ ## $T.name(); } // injects into the Hello:: namespace -&gt; { return T _var_ ## $T.name(); } // injects into local namespace // "_var_ ## $T.name()" should be evaluated for example with T=float to "_var_float" }; } }; This is probably syntactically technically not correct but the idea should work. [https://www.youtube.com/watch?v=4AfRAVcThyA&amp;t=19m11s](https://www.youtube.com/watch?v=4AfRAVcThyA&amp;t=19m11s)
Ahhhh Big Ayyyy
Programmers hate it.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/apqb2s/why_big_ä/egbg4ng/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Thanks for your feedback :) I used malloc because i don't want to need to have a default-constructuctor. I'm not really sure if it's worth and maybe i will just use a std::vector. For big numbers of entities it is indeed not really fast. However, since i will probably not have more than 10'000 objects in one scene it will hopefully be good enough. (there is a little benchmark in `main.cpp` and it takes about 0.008 seconds to iterate through 1'000'000 entities (doesn't really matter how many components there are))
I mean, define "bug". Do you count "has a password form, but you can literally just navigate to the admin page by entering the right URL because this damn application doesn't actually implement any sort of auth" as a _bug_?
&gt; You are mistaken. Trivially destructible means (it's a formally defined term, and a type trait) that there is no code associated with destructing the object. No special pass for member variables. Trivially destructible recursively requires all members to be trivially destructible. Ahh yes, my mistake. Late night brain-fart. I missed the part where you were only talking about trivially destructible types, which obviously require all of their members to be trivially destructible, recursively. &gt; They are getting defined either way. It's just that if you do nothing, they are implicitly defined in the header. I'm explicitly declaring them in the header, and then defining them in the .cpp file. This improves compilation time/bloat for the same reasons why defining a function in the .cpp does generally. Ahh. I see where you're coming from here now. You're not talking about trivially destructible types. It almost seems to me like this is a good use of static assert. It's (almost) a shame we don't have a way to define behavior in macro-like ways based on compile-step information. * If you define your functions in a header file as = default, and you aren't explicitly trying to inline the destructor call for a member variable, then static assert that your type is trivially destructible. * If you define your functions in cpp file as = default, then static assert that your type is not trivially destructible. &gt; That doesn't matter. There is nothing special about defaulted operators, unless the type is trivially (default) constructible/destructible/assignable. You can only be trivially * if you default the relevant operator in the header file (implicitly or explicitly). In any other situation, special member functions are just code, like anything else. Yea, my whole comment was predicated on the wrong assumption that you were giving this advice for trivially destructible/constructible/assignable objects. My bad. Thanks for the reply, and the correction. I appreciate it.
You can though make up for it by posting a twerking video on Youtube.
&gt; I used malloc because i don't want to need to have a default-constructuctor. I'm not really sure if it's worth and maybe i will just use a std::vector. `std::vector` is a good solution, especially since you can `reserve`. Using `std::allocator&lt;T&gt;` directly might also work. `union` can also be used if you want typed uninitialized memory. &gt; it will hopefully be good enough. Good enough always is what you should aim for. But, 0.008s is 8 milliseconds. This means that with 1 million entities you can only run 2 trivial systems per frame and per thread. This scales linearly so with 20k entities it should take ~0.16ms. In my experience big games tend to have a shitload of systems active but most of them only operate on a small set of entities. In this case, paying 0.16ms per system might already be way too much. You probably aren't in that case, but then is the overhead of RTTI really worth optimizing? 
There is an alternative [http://www.cplusplus.com](http://www.cplusplus.com) but I can't tell you whether it is much easier to comprehend. In a lot of cases, especially after collecting experience as a C++ developer, you actually want and need those details. As an easier introduction to modern C++ you might want to read the blog posts on [https://www.fluentcpp.com/](https://www.fluentcpp.com/) and watch the youtube videos by Jason Turner: [https://www.youtube.com/user/lefticus1](https://www.youtube.com/user/lefticus1) . Another question maybe: On what kind of project do you want to work? Are you just at the start of your career? Or do you have a single specific project in mind? In general there is of course also the discussion of using the right tool for the right task. Writing just a small script or tool? Have a look at python! Do you need to be portable across mobile, desktop, embedded,... Have a look at C++. Do you plan on writing a new crypto library? You might benefit from having a look at rust.... and so on ...
Here was a post of some times ago : https://www.reddit.com/r/cpp/comments/83rgta/what_do_we_want_to_do_with_reflection/
Nice. I was just looking at this last night and noticed that something of this ilk was on your roadmap but not there yet, and that made me sad. Now I'm happier. :) Looking at the implementation of the test adaptor though, this might mostly be in doctest's court. The test adaptor uses command line arguments to extract the available tests (see [Discover/ListTests.cs](https://github.com/JohnnyHendriks/TestAdapter_Catch2/blob/master/Libraries/Catch2Interface/Discover/ListTests.cs)) or the XML output of the test command ([Catch2Xml.cs](https://github.com/JohnnyHendriks/TestAdapter_Catch2/blob/master/Libraries/Catch2Interface/Discover/Catch2Xml.cs)), and likewise creates command lines based on discovered tests ([Executor.cs](https://github.com/JohnnyHendriks/TestAdapter_Catch2/blob/master/Libraries/Catch2Interface/Executor.cs)). So long as doctest supports a fully compatible CLI interface to Catch2, the adaptor should Just Work(tm) from the looks of it.
There is a hint that there is a client interface, but I don't see it.
Oof, the /r/programming thread is being hardcore brigaded by /r/rust. Can we balance that out?
&gt; The "example" presented there requires me to know (and care) about threading, That's the point. You use shared_ptr when you care about threading
And what do I use otherwise?
Nice! I was looking into Catch2 Test Adapter a while back, but didn't get it to work. I'll give it a go again!
Imho use after free is just as likely when you use smart pointers as when you use manual memory management. Out-of bounds errors however are - in my experience - significantly less common when containers and ranges/views are used instead of manually allocated arrays and ptr+size interfaces. But of course that is just anecdotal and not a useful statistic.
They are defining bug as "issued CVE" meaning the thing is actively exploitable.
Well... either the doctest interface has to mimic that of Catch perfectly or the adaptor can be special-cased. I'll think about this when I get the time...
&gt; This isn't Foo being implicitly cast into Bar. This is Foo::into resolving overloads based on expected return type (expected here because it gets used by something that definitely needs a Bar, and there's an overload of into that satisfies that, so it's chosen). &gt; &gt; E.g. I don't think it'd work if you add another call to takes_baz, even if you have a From&lt;Foo&gt; for Baz implemented. Because into, here, can't resolve to a unique type. There's no implicit casting here. Yes? That's exactly what I said? This is not implicit casting so I don't see what argument you are trying to make here.
Whatever's appropriate: Values. References. Classes. Containers. Views. Raw pointers (when they satisfy [F.22](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-ptr)).. std::unique\_ptr (if you simply must new an object for some reason that's not part of a class), etc.
&gt; it's nonsense because it is about figuring out a terrible way to do something with arbitrary restrictions that don't exist. No? That's a real task with real restrictions. Would you act the same if the client came to you and said "I only have two stacks and I need a queue"? Would you explode in arguments as well? It's an entry level question. The interviewee might not have much experience to talk about and even after that you might want to see if he actually can program anything. It's not a bad small task that can be done on a piece of paper in less than 5 minutes but can give enough topics to talk about, like why it's not good idea to implement queue like this in practice/complexity and etc. If the Junior candidate's first response is hysterical confrontation, that'd be a huge red flag.
Why should we? C++ isn't memory safe. That is just a fact that can't be argued away. How much more buggy the average c++ vs rust code base is is probably next to impossible to say, because you are always comparing apples and oranges to some degree and I doubt there is a lot of hard data on it anyway. 
Yeah, I'm not a fan of google-style acm icpc interviews either. I just think that this one is not even remotely close. There are better questions, sure, but this one doesn't deserve to be so obsessed about. If you can program, it at worst would take you 5-10 minutes without any prep work. If you can't deal with it than that's your problem and you'd be rightfully rejected.
How is that? How do you maintain a reference to an object while having it deleted out from underneath you? Unless you're mixing smart pointers and native pointers in your code base, which I'd argue is worse than just using native pointers exclusively. 
First of all: Every code bases uses a mixture of smart and raw pointers (smart pointers for owning, raw for non-owning) and that is explicitly encouraged. Second, it doesn't make a difference if your "non-owning pointer" is actually a raw pointer or some custom iterator, a reference, a string_view, a span or whatever else you can imagine. All of them have the property, that the object they refer to can be "deleted from underneath them" (just consider an iterator that got invalidated by a push_back on a vector that caused a reallocation. 
include catch at empty file with micro then add this object to any test case will help help with compile time
In principle, modules offer a nice chance to prevent configuration conflicts. The current compilation model means that the same text included in different TUs, can have arbitrary different meaning when they are not compiled with the exact same flags which can lead to extremely subtle or real obvious problems. With modules however, a library is only compiled once and all other modules will import exactly that meaning - irrespective of what flags have been used during their compilation. If it will really work like that in practice remains to be seen.
&gt; and I doubt there is a lot of hard data on it anyway. Indeed. Rust has a much lower adoption, and therefore there are much fewer Rust programs actually used in the wild where CVE are usually reported from. Furthermore, saying that this wouldn't happen in Rust is just wishful thinking. In domains where C++ is used, Rust programs would likely use the `unsafe` subset of the language for performance or necessity. Less `unsafe` is likely to result in less CVEs, but there will be mistakes. How many of the 70% could be eliminated remains to be seen; though again even if it's only half, it's already good progress.
And we *still* don't have any languages that do "mandatory memory safety" without falling into the Garbage Collection trap. Rust is among the least terrible, but it is too opinionated to be something that will be widely used. We need a language that does something like: * Pointers are shared (refcounted). * If you ever create a cycle, trap (this is a *much* simpler problem than GC). * To avoid creating a cycle, use a weak pointer. * If you ever dereference a weak pointer, trap. It might even be possible to make a C implementation that meets these requirements. AddressSanitizer doesn't count, it's only a heuristic and is easily defeated.
We have a large codebase using smart ptrs in many places, along with some non owning raw ptrs. I honestly can't think of a single case of use after free bugs we've had. The smart ptr pattern has virtually eliminated this particular bug for us.
Thanks, this is fantastic! :)
"Stack unwinding may be skipped" is mentioned as a performance benefit. I feel that's wrong: incorrectness should never be considered a performance benefit. If it were, you could just abort straight out of main(), that's even better performance... "Instructions may be reordered by the compiler" That's debatable. If 'v' (in the example) is a local, then it doesn't matter if f throws or not, as there is no visibility on v after the call to f anyway (so the optimisation still applies). And if it is not a local the compiler can't know if f possibly depends on v having that specific value, and cannot apply the optimisation anyway. 
Looks cool, I'll try it later.
Or what anyone says on this subreddit.
Slides from the talk. https://github.com/Microsoft/MSRC-Security-Research/blob/master/presentations/2019_02_BlueHatIL/2019_01%20-%20BlueHatIL%20-%20Trends%2C%20challenge%2C%20and%20shifts%20in%20software%20vulnerability%20mitigation.pdf
Ok! In the future i plan to introduce this query service preforked/prethreated design server. (It was necessary for the work!) As you can see, only reactor(select/epool) design that provides Boost.Asio is now implemented. Beast provides the needed structures and capabilities that are used here. I have written samples of classes for the extension of this library to HTTP/2 protocol, order to implement it in the future.
Excellent. Thanks for the link. Wonder if there be a YouTube video in the future?
Thanks! I use Catch2 for my personal projects, and I find your extension very useful. Does this mean I need not provide a runsettings file anymore?
I did not set a goal to simplify the syntax!
I've been monitoring any news about QBS and finally, someone mentions it on reddit! Long live the QBS, *the one and only sane build system out there**^(TM)* (at least for C/C++)
That's really good to know!
I love the comment by M Wagner stating that the said statistics is Windows only, while probably all full-feature OSes shall have the same problem.
Yes, I have a couple of vids laying around. Will post link
Is it possible to make cpp more memory safe like rust? Is this proposed for standardization? E.g. something like Checked C 
**Company:** Microsoft Visual C++ **Type:** Full time **Description:** Join the Visual C++ Code Generation team with a focus on new platform development! Our mission on the Visual C++ team at Microsoft is to build the best tools and libraries for any C++ developer, any app, any platform. The Microsoft Visual C++ compiler team empowers a broad C++ ecosystem on multiple platforms impacting millions of developers and billions of users. We are looking for an experienced software engineer to help develop compilers and tools targeting new Azure hardware in addition to known hardware. You'll come on board as a core team member of this early-stages project, working alongside some of the best compiler engineers in the field. This is an opportunity to be involved in groundbreaking hardware innovations. Opportunities will be available to shape the direction of this project as you'll be directly involved in new platform bring up. You'll be interfacing with other internal teams such as operating systems, debugging, architecture, security, and cloud computing. Successful candidates should be comfortable in a fast-moving and dynamic environment. * https://careers.microsoft.com/us/en/job/569834/Software-Engineer-II * https://careers.microsoft.com/us/en/job/570239/Senior-Software-Engineer *Responsibilities:* * Contributing to the design and implementation of compiler back-ends for new and existing hardware platforms on both Windows and Linux * Participating in new platform bring-up * Helping to debug issues spanning the full HW/SW stack * Supporting the core C++ compiler team * Delivering product milestones *Qualifications:* * BS in Computer Science, EE, Computer Engineering or equivalent experience * 3+ years programming in C/C++ * Comfortable working with assembly - familiarity with one of the following is preferred: x86, x86-64, ARMv8 * Comfortable with algorithms and data structures * Excellent teamwork and communication skills * An instinctive appreciation of celebrating team success! *Prefer some combination of the following:* * Entry level compiler or language design course work. * Familiarity with compiler back-end technology (e.g. LLVM or GCC experience) * Knowledge of multiple processors and ISAs * Knowledge of modern CPU architecture fundamentals * Knowledge of operating systems fundamentals (Linux and/or Windows) * Strong skills with debugging, profiling, and/or code analysis **Location:** Redmond, WA **Remote:** No **Visa Sponsorship:** No **Technologies:** C, C++, assembly, LLVM, Linux **Contact:** Email IANB at microsoft.com (Principal Software Engineering Manager, Visual C++ Code Generation and Optimization) --- **Company:** Microsoft Visual C++ **Type:** Full time **Description:** Join the Visual C++ Code Generation team! Our mission on the Visual C++ team at Microsoft is to build the best tools and libraries for any C++ developer, any app, any platform. The Microsoft Visual C++ compiler team empowers a broad C++ ecosystem on multiple platforms impacting millions of developers and billions of users. The team is looking for passionate engineers looking to grow their skills in machine targeting/machine dependent code generation. This is a high impact opportunity in the Microsoft Visual C++ compiler, the compiler that builds Windows, SQL, and supports all Visual C++ development within Microsoft, as well as shipping in Visual Studio to the broader C++ community. If you're interested in generating assembly code, efficient use of machine resources, disassemblers, register allocation, or target machine specific optimization for x86, x86-64, ARMv8, as well as new hardware to support the cloud, this is the job you're looking for. * https://careers.microsoft.com/us/en/job/569834/Software-Engineer-II * https://careers.microsoft.com/us/en/job/570239/Senior-Software-Engineer *Responsibilities:* * Contributing to the design and implementation of VC++ compiler back-end * Participating in the full software life-cycle * Being directly involved with the customer experience * Delivering product milestones *Qualifications:* * BS in Computer Science, EE, Computer Engineering or equivalent experience * 3+ years programming in C/C++ * Comfortable working with assembly - familiarity with one of the following is preferred: x86, x86-64, ARMv8 * Comfortable with algorithms and data structures * Excellent teamwork and communication skills * An instinctive appreciation of celebrating team success! *Prefer some combination of the following:* * Entry level compiler or language design course work. * Familiarity with compiler back-end technology (e.g. LLVM or GCC experience) * Experience with debugging, profiling, and/or code analysis **Location:** Redmond, WA **Remote:** No **Visa Sponsorship:** No **Technologies:** C, C++, assembly **Contact:** Email RHADLEY at microsoft.com (Principal Software Engineering Manager, Visual C++ Code Generation and Optimization)
Sure, the most popular libraries with cyclic dependences not worth removing are informally labeled as "Boost.Core". It is a monolithic block of self referential code, it can be considered a single unit from a Modules perspective. The remaining libraries which won't be fixed tend to lack maintainers or be under maintained, though in one or two it's a case the maintainer has agreed to fixes but simply hadn't got round to it yet.
Given your post history, I'd say that this is OPs blog, probably. If so, please write about something slightly more interesting and fix your formatting. 
If anyone has time, help with the build error on xcode! Please ... \^)
Not seeing any of the "javascript sucks!" people in this thread :D
Your class looks like filling the same use case as `std::unique_ptr` but with different syntax for using it ? Sure, you can use a raw pointer if you're implementing a container of some sort where it's encapsulated and tested, and there's not any standard container that meets the requirements. This is a relatively rare occurrence however. The only time I've used a raw pointer in C++ in years is when I had to interact with third party libraries that deal in raw pointers. 
Hi @kalmoc, VC IDE team here. Please note that even with modern c++ RAII locking types you can still forget to use the lock, as shown in the following example. Concurrency checker detects this. We don't recognize all the standard locking types but we keep adding. Please let us know if you find an issue - we welcome your issues on dev community: https://developercommunity.visualstudio.com struct RequestProcessor2 { std::mutex m_; _Guarded_by_(&amp;m_) std::map&lt;int, Request*&gt; cache_; bool HandleRequest(int Id, Request* request) { std::lock_guard grab(m_); if (cache_.find(Id) != cache_.end()) return false; cache_[Id] = request; } void DumpRequestStatistics() { for (auto&amp; r : cache_) std::cout &lt;&lt; "name: " &lt;&lt; r.second-&gt;name &lt;&lt; std::endl; } }; 
When I made those diagrams there were only a handful of cycles, and they wouldn't be 'boost core' by any measure I'm aware of. Here are the cycles in the graph of the boost serialization library there: subgraph cluster_range { label="incidental range" range -&gt; algorithm algorithm -&gt; range } subgraph cluster_mpl { label="incidental mpl" mpl -&gt; utility utility -&gt; mpl } subgraph cluster_fusion { label="incidental fusion" fusion -&gt; functional iterator -&gt; fusion functional -&gt; iterator } subgraph cluster_spirit { label="incidental spirit" spirit -&gt; serialization spirit -&gt; pool spirit -&gt; thread pool -&gt; thread thread -&gt; date_time date_time -&gt; serialization serialization -&gt; spirit } subgraph cluster_math { label="incidental math" math -&gt; lexical_cast lexical_cast -&gt; math } http://www.steveire.com/boost/deps-august-2016/serialization.png http://www.steveire.com/boost/deps-august-2016/serialization.dot One of the ways to resolve the 'incidental spirit' cycle would be to refactor the serialization library a bit. That has a maintainer /u/robertramey, but he wasn't interested in such a change years ago. Maybe some other solution will be used there (or has already been implemented! I'm way out of the loop :) ) 
&gt;Your class looks like filling the same use case as `std::unique_ptr` but with different syntax for using it ? It's safer to use because `unique_ptr` can be null or constructed from a pointer that doesn't refer to an object allocated with `operator new`.
Hi /u/kalmoc, VC IDE team here. Please note that even with modern c++ RAII locking types you can still forget to use the lock, as shown in the following example. Concurrency checker detects this. We don't recognize all the standard locking types but we keep adding. Please let us know if you find an issue - we welcome your issues on dev community: https://developercommunity.visualstudio.com struct RequestProcessor2 { std::mutex m; _Guarded_by(&amp;m) std::map&lt;int, Request*&gt; cache; bool HandleRequest(int Id, Request* request) { std::lock_guard grab(m_); if (cache_.find(Id) != cache_.end()) return false; cache_[Id] = request; } void DumpRequestStatistics() { for (auto&amp; r : cache_) std::cout &lt;&lt; "name: " &lt;&lt; r.second-&gt;name &lt;&lt; std::endl; // unlocked access } }; 
I don't know about a bug breakdown and most of the code I work with here isn't C/C++, but most "C++" code I have seen has been "C style" (manual resource management instead of using even basic destructors, etc).
You can pretty much avoid them by sticking to smart pointers and avoiding copy operations of said pointers (which is dirty anyways). Impossible to enforce though... C++ maintains back compatibility, but requires better self discipline. 
why you shouldn't: here's a quick benchmark #include &lt;algorithm&gt; #include &lt;utility&gt; template&lt;std::size_t N&gt; struct type { }; template &lt;class F, std::size_t... Is&gt; void for_(F func, std::index_sequence&lt;Is...&gt;) { (func(type&lt;Is&gt;{}), ...); } template &lt;std::size_t N, typename F&gt; void for_(F func) { for_(func, std::make_index_sequence&lt;N&gt;()); } void f() { for_&lt;COUNT&gt;([] (auto t) { std::for_each(&amp;t, &amp;t, [] (auto&amp;) {}); }); } versus void f() { for_&lt;COUNT&gt;([] (auto t) { for(auto it = &amp;t; it != &amp;t; ++it) { } }); } used this script: #!/bin/bash rm -rf *.csv for CC in clang++ g++; do for i in `seq 1 100 10000`; do RES=$( { /usr/bin/time -f '%e %M' $CC -c -std=c++1z -pipe -g -DCOUNT="$i" for_each.cpp; } 2&gt;&amp;1 ) (echo $RES | sed 's/ /,/') &gt;&gt; "$CC-for_each.csv" RES=$( { /usr/bin/time -f '%e %M' $CC -c -std=c++1z -pipe -g -DCOUNT="$i" for.cpp; } 2&gt;&amp;1 ) (echo $RES | sed 's/ /,/') &gt;&gt; "$CC-for.csv" done done results: [here](https://i.imgur.com/keXci5a.png) - twice as slow to compile, twice as much compiler memory used. clang actually started crashing around n=9000. 
What now? You think there are professionals out there that tell clients they can't make a GUI or put networking in their program because it isn't in the standard library?
I'm not sure what is funnier, the idea that you tried to reframe someone saying ' I don't think I'll be a good fit here' as 'exploding hysterical confrontation' or that you think there are people who pay software engineers to make something already done a thousand times, but make it worse for no reason. 
The main takes a long time to compile but tests themselves are pretty quick to compile 
Sure, errors can absolutely still happen. I was just wondering, how common they are. My experience covers only a tiny tiny tiny fraction of the code out there and I'm sure you guys have seen much much more and can therefore better estimate what features are useful.
In general, I don't because it's harder to read. 
Sounds interesting but with no benchmarks or justification there's good reason to be skeptical of this approach.
Hi, I'm wondering how does it stack up compared to [progschj/ThreadPool](https://github.com/progschj/ThreadPool)? That seems to be one of the most well-known and most bug-free ones that I know of.
Alright, I might overreacted a bit myself, though it certainly seemed from the way you've responded. But you really want to go that approach, answer me this: how would you implement a queue in a purely functional language, say Haskell? That's a real task with real restrictions as you've wanted. It might've been solved by the time it's given to you but it wasn't at some point in time. &gt;or that you think there are people who pay software engineers to make something already done a thousand times, but make it worse for no reason. Would you respond the same way to the idea of writing any code during interview? If so, I don't think it's worth arguing with such extreme position.
"Every" code base? I know what you mean, but you could always write an app that uses shared_ptr everywhere. It'd be a bit cumbersome but you'd see a huge reduction in pointer stomps. 
oh wow! our implementations are very similar except I'm not supporting getting results back through use of features. shamelessly copying that :)
He says on his twitter that they should eventually become available.
I have experimented with extern template before and my results were pretty much inconclusive. The bottom line is that C++11 and later templates are amazing in many aspects, but they're terrible when it comes to compilation performance. Template overuse is a thing in C++. Extern template doesn't help you when you do constexpr insertion sort of variadic type packs for arbitrary orders (yes, I have seen this). Compiler vendors need a breather to optimize existing features instead of adding new ones, otherwise build performance won't improve.
&gt; I really hate to be that guy, but are the bugs caught by this tool common in "modern c++" code bases? &gt; &gt; I can't remember the last time, when I had to manually lock and unlock a mutex as opposed to use a lock guard/ unique_lock. And the "simple" sync requirements (you always need to hold mutex X when accessing variable Y) are rarely what leads to bugs and or are well encapsulated anyway. Most of the bugs I've seen revolved around "clever" synchronization strategies using atomics, lockfree datatructures or situations where you sometimes needed to lock the mutex and sometimes not depending on some precondition. &gt; &gt; One warning, that could become verz important is imho https://docs.microsoft.com/en-us/visualstudio/code-quality/c26138?view=vs-2017 Please feel free to share examples and suggestions with us, we are always happy to add useful checks. Please use https://developercommunity.visualstudio.com for suggestions so other people can join the ask. 
/u/Izowiuz and /u/theICEBear_dk: Have you folks created a DevCommunity ticket? We really want to make sure we get to the bottom of this in one of our upcoming Previews. Thanks!
You are not supposed to compile your code. Didn't you get the [memo](https://www.reddit.com/r/cpp/comments/ac3ntu/modern_c_ruminations/)?
I’m still astounded by how well optimizing compilers can ... well optimize. 
Standard C++ as opposed to non standard C++?
No need to get personal
The big problem with `extern` template is that it meshes very badly with std types and even more badly with dynamic linking. e.g. it would be very nice to be able to have a dll / so / dylib, with, say, instantiations of std::unordered_map&lt;std::string, int&gt; if it's something that you use a lot, but there's no real legal way to make it work - in particular, msvc, gcc and clang all have different rules regarding the various exporting attributes and what they do when applied to a type / an extern declaration / etc which makes the whole thing a pain. 
Standard as opposed to platform specific implementations.
Ah. Of course. 
I only had two criticisms about your post, that's all. I don't see what's personal about that? 
People in this thread seem skeptical, and rightly so: There are no numbers to back up the benefits! I can vouch for usage of `extern template`. Unfortunately, I don't have precise numbers, other than to say "big." The benefits of `extern template` may only start to show when your code itself is _big_. The experience I have in mind involves a MASSIVE amount of generated code (Generated from a WSDL for a SOAP API. Long sad story. Think tens of thousands of generated classes. Thousands of TUs.) For each of these, I was using `optional`, `boost::basic_property_tree`, and a few other in-house class templates, all of which are fairly heavy. Using the generated code caused trouble, but _not_ with compile times: Link times, link memory usage, and object file size were all **astronomical**. One of the first things I did was open up `bloaty` and take a look at what was causing the massive binaries. Individual object files were of reasonable size, but the archive `.a` and `.lib` static libraries had thousands of object files inside, each of which duplicated a few dozen Kb of code. `bloaty` revealed the culprits clearly: specializations of the aforementioned class templates. To solve this, I added a hand-written TU to the generated code that only contained `template class optional&lt;...&gt;`-style lines for the half dozen repeatedly appearing specializations. In the header, I added the corresponding `extern template` declarations. The result was night-and-day. The GB static libraries shrunk to just a few MB, link times fell through the floor, and link memory usage was now within a sane range.
&gt; It's also trivially easy to set up a US ACH to EU SEPA bridge Uhm, may I ask how do you do this? I found that nearly impossible. Until TransferWise came along.
&gt; EU single person incorporation is by far the easiest way out. The French citizen self incorporates, and the relationship becomes a business-to-business one with full French taxes paid French-side. But that changes a lot in terms of "social insurance" payments, or does it not? I mean things like health insurance, unemployment insurance payments, state pension payments, etc. Lots of this is mandatory by the state in many countries, where the employee pays a couple of percent, and the employer a few percent. Because with the B2B relationship, it's not employment anymore, but contractor work? And on top of that, isn't that also illegal in many EU countries, i.e. if you're contracted by a company 100% effectively you need to prove that you are an independent contractor and are free to work when and as you please and are not essentially an employee of the company, managed by them.
What's the salary range to expect for such C++ positions at Bloomberg? (positions for people with a few years (5+ or so) of C++ experience).
It's not my post, but commenting on someone's post history instead of the quality of the information presented is quite personal.
While appealing, this iterator cannot legally model a forward or stronger iterator, even under the reduced iterator category requirements in the C++20 ranges TS. Reference returned by an iterator are required to remain valid after the iterator is destructed. See the concept definition [here](https://en.cppreference.com/w/cpp/experimental/ranges/iterator/ForwardIterator)
The difference would likely be much bigger for us as our node-based containers like list, map, and unordered_map are nothrow relocatable but not nothrow move constructable because we need to allocate a sentinel node for the moved from container; while libc++ uses container internal sentinel nodes.
You know what I want? A `try_realloc` function in the standard library that returns either the pointer given to it if it could expand it, or null. This would make container allocators more efficient for types that aren't moveable, as you won't need tobcopy/move each element on every allocation. I've implemented it with std::string and std::vector analogs, and the performance for appending repeatedly was *far* better.
I'm sorry, I thought you were OP, missed the username. The only posts OP has made on Reddit are links to this blog post, so that's why I directed my criticisms to them. Still, I'm criticising the blog post OP made, not OP themselves. I think that's fair when they're promoting their blog post here. 
this.
thanks for bringing it to my attention I've updated my implementation to support features. I will update the blog post.
Because this is a forum for expert C++ users. It is filled with articles about advanced topics in C++. Inheritance is a basic topic. The primary users of this forum have nothing to learn from this article nor are they interested in critiquing an article about a topic that already has exhaustive treatment elsewhere from well known sources. If you have basic questions about C++ r/cpp_questions is probably the place to ask. 
That could be done. And it wouldn't be really upsetting to the library itself. That is, it's not a huge change. But it's not nothing either and any change to the library takes a lot of time and effort. And no one pays me to do it so it's hard to justify the required investment.
Basically every major event-loop (GUI or server oriented) already has a thread pool, but often requires that you use their whole framework (read: "library that does not play well with others"), and is often missing many features.
...
There was a talk some years ago (Sean Parent I think?) that went through all the additions to this kind of thread pool that were required to get 'optimal' performance. From memory it included multiple queues and work stealing. The simple implementation in OPs post gave surprisingly small improvements based on the speakers tests.
I can believe that it'd be common for a heap to maintain some extra space after an allocation we might be able to borrow, but vector grows geometricly. Having 1.5x or 2x sized allocations seems an unlikely case.
Shameless plug here, our Stensal SDK (https://stensal.com) is a quasi-memory-safe implementation of C. The C++ part is still a work in progress. We said quasi-memory-safe, it's actually memory-safe with very high probability. In practical, it can catch all illegal memory accesses. 
But the reason vector grows geometrically is to maintain amortized O(1) for e.g. push_back. Presumably if you're calling a hypothetical `try_realloc` function (which is already O(1)), you'd only ask for the 1 extra element you need rather than trying to double the capacity of the vector.
That’s probably a pessimization because it would be taking at least 1 lock per inserted element (in the heap implementation). Even with a “heavy” value_type it would enter the non-inlineable part of push_back on each element instead of lg elements.
Agreed, AddressSanitizer is a heuristic but practical approach. Our Stensal SDK takes a completely different approach by starting with a dynamic pointer typing system to enforce completely memory access checking. In theory, Stensal SDK cannot guarantee memory safety, but in practical it makes C code memory safe with very high probability. Any criticism would be highly appreciated. 
Claims of fast without benchmarks are baseless.
Not to mention AFAIK this approach performs horribly on multi-socket systems.
Depends on your target. On x86 cmpxchg and xchg both look like writes to other cores (even when cmpxchg fails) as I understand it, so not much can be better here. Missing spin/back off is suboptimal though.
Hold up. You implemented auto_event using a std::mutex, and this fast_mutex, which uses that auto_event as part of its implementation, is supposed to be faster? I find it hard to believe that it would be faster than std::mutex, which makes use of srwlocks in modern windows implementations.
Nitpick "C++ isn't memory safe", The current (or mainstream) implementations of C++ are not memory safe. It can be implemented with memory safety but at higher run-time cost . 
Dynamic pointer typing? So each region of memory gets a tag like {unallocated, char[], int[], etc.} ? So use-after-free can still happen if it ends up the same type?
What about Rust then? It also prevents some other unsafe operations like race conditions (can't have two non-const references of the same object).
&gt; You can pretty much avoid them by sticking to smart pointers and avoiding copy operations of said pointers (which is dirty anyways). &gt; Even if you do that, you still have things like iterator invalidation.
This is a simple mutex, and shows how atomics can skip calls into os sync primitives. It its not internally designed to be distributed. And it is NOT a rwlock. Btw, I know of two read write locks that are very nice. One created by me, and another created by Joe Seigh. Mine is loopless and I think Joes is as well; they are bakery logic in nature. Show me a read write lock without ANY loops in the code. Good luck. If you are interested, we can talk.
&gt; How much more buggy the average c++ vs rust code base is is probably next to impossible to say What about C++ vs Java or C# for instance? The latter two are memory safe, so theoretically should rule out an entire class of vulenrabilities.
As I said, Rust is "too opinionated". It is impossible to write many safe, sensible, programs, without resorting to a lot of `unsafe` blocks, at which point you're giving up the *only* protection Rust has. The whole "silent moves" is probably the thing that made me stop writing Rust, though.
I totally get your point, but you can't be safe without putting some serious constraints. You can try to spot lifetime issues in C++, but some will escape the compiler and the best checkers.
iterators should increment the ref count of the pointed-to object the world would be a much safer place because OSes would be too slow to be useful and thus not worth exploiting
What I'm saying is: don't bother to do a lot of checking at compile-time. Just detect violations at runtime and allow graceful bailout.
Only pointer is typed, but not the memory pointed by a pointer. In order to achieve memory safety, we only need to know the size of a memory pointed by a pointer and the liveness of the memory. The size and liveness are combined to type a pointer at runtime. Use-after-free can be detected, checkout this page https://stensal.com/bugfeed. The most interesting one is libpng, we simply rebuilt libpng and ran the regression test to expose a use-after-free bug existing in multiple versions of libpng. FYI, libpgn is heavily tested by the google oss-fuzz team. 
They were commenting on the topic and formatting; the post history only provided context.
I mean, if a future call to `malloc` returns the same memory, which is doomed to happen fairly quickly unless you `abort` all programs that live that long.
The problem is that it requires to have extremely good testing. Graceful bailout in production is often still a big issue.
You have rightly pointed out the tricky part of detecting use-after-free. the address of a memory block cannot be used to detect memory reuse. It has to be another id, since all ids has a finite range, there is a chance to reuse memory without being detected. But the probability is very low in practice. 
Now I understand - it would be easier for readers if you would have said that directly and not in a complicated way that need the right deduction to understand. Of course you can deal with almost everything by using libraries! It is a hard thing to decide, what should be included into a standard library and what should better left out. But I definitely believe that dealing with text is much more difficult, if you don't have a *standard* data type for Unicode support. Compared to your other examples (network and GUI) strings are almost everywhere in a program, which makes it much harder if you have a mix of different libraries that have different support for Unicode. Qt has its own string abstraction, so it is possible you have to recode between your domain model and the GUI for example. Other libraries might not be aware of Unicode at all or might require wide strings whereas you have established UTF8 as your internal representation - another recoding necessary. So this is very different from libraries that addresses topics, that cover some *technical* aspect like networking or GUI. Those topics aren't present in every program. A program without strings on the contrary is extremely seldom. So I definitely believe that the advantages outweight the growth of the standard lib. The same aspect arises for a *decimal* data type as well btw. You could always argue to keep the standard lib small. I definitely see huge problems with the status quo at this topic. (``std::string`` has other problems too btw, like mutability for example, so a new Unicode aware type could adress those shortcomings too) 
Sure, that would still leave invalidated iterators (at least if you want to use standard library containers), a significant overhead (both for the ref-counting and because much more things have to be allocated on the heap) and increased chance of memory leaks due to cycles. I'd probably prefer a GCed language at that point ;)
How does this compare to [Belle](https://github.com/octobanana/belle)?
How? How do you want to prevent people from dereferencing a nullptr or a pointer pointing to a deleted object/an object that went out of scope?
They are. I think you'd still have the apples vs. oranges problem most of the time, but at least there should be enough data.
The ID being some of the bits of the pointer, which you mask out on deref? One possibility: gives *all* allocations an ID of 0 until you are absolutely *forced* to reuse memory. Then, give all allocations an ID of 1, etc. In this case, IDs will cycle slowly enough to for abort()-on-wrap to be sensible, without relying on attacker being unable to synchronize the cycles.
&gt;Is it possible to make cpp more memory safe like rust? Basically yes. Technically, the Rust language has a memory and data race safe *subset*. C++ has a similar memory and data race safe subset. The difference being that the tool to enforce conformance to a memory safe subset of C++, the core guidelines lifetime checker, isn't quite complete yet. In the mean time, you can avoid using potentially unsafe C++ elements (like raw pointers) by substituting them with memory (and data race) safe [replacemements](https://github.com/duneroadrunner/SaferCPlusPlus) (shameless plug).
the libpng use-after-free bug is one example, its link is at the top of this page: https://stensal.com/bugfeed. This page https://stensal.com/test_your_code, has some pinned code snippets demonstrate the problems you just enumerated. 
I mean there's no need for a fancy event object. Just use an atomic flag, and a unique_lock per thread that explicitly unlocks before notify_one().
It's one possibility and I think it should work. The switching from 0 to 1 could simply be triggered by an counter-down counter which is randomly selected at the program start time. 
Thats normal. ANY is by default in java hence not written. You can see any more often in typescript
The read/locks in mind are general purpose, and not distributed. However, there are \_no\_ loops in the code. It does not use CAS.
The "fast" mutex is using a layer of atomics and membars to show one how to "skip" calls into the underlying slow binary semaphore, or auto-reset event built from mutex/condvar setup. It is a matter of fast-path, or slow-path... Think about it for a moment...