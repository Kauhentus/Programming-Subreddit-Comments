To be honest - I really don't care about east const or west const. I think it's great that the C++ Core guidelines settle this issue, so we can all be consistent, whether we prefer the one thing or the other doesn't really matter...
Quite right. The Windows C++ libraries from Borland, OWL and later VCL were a joy to use. The problem are those libraries that just look like plain C ones.
 template &lt;typename T&gt; using ptr = T*; int i; const ptr&lt;int &gt; my_const_pointer = &amp;i; ptr&lt;const int&gt; my_pointer_to_const = &amp;i; const ptr&lt;const int&gt; my_const_pointer_to_const = &amp;i; checkmate.
I use Synalize It! (https://www.synalysis.net/). It needs a grammar though (to describe the file format)
The survey mentions `boost.Expected, boost.Outcome`, are these already available? Didn't find anything when searching for them. Used my magic wand for a package manager, already regret that, should've waved it at pattern matching.
 // something.h #include "foo_impl.h" template &lt;typename T&gt; void foo() { foo_impl(); } // foo_impl.h void foo_impl(); // foo_impl.cc #include &lt;Windows.h&gt; void foo_impl() { // depends on &lt;Windows.h&gt; }
If other languages are allowed to use sum types, why wouldn't C++ be?
In which way modules preclude forward declarations? I mean, I think u can still list the exports only and implement somewhere else just as you do with headers. Is that right?
That's some really nice stuff. char being a full 32 bit unicode character _should_ be what C++'s wchar is, but unfortunately that's not universal (it's the abomination that is UTF-16 on Windows). At least we have an explicit unicode-32 `char32_t` now.
I know what you're describing since I encountered it with writing C# in MonoDevelop, but switching to a better editor alleviated most of my pain. ML does it right: interface files exist but are optional.
This is C++, bad devs can abuse anything, including unique_ptr and shared_ptr as well.
As far as I understand modules (and I haven't yet actually tried this feature, only read about it), you can, but not forced to, provide forward declarations (where? In a separate .cpp file? there is no designated place for them), while with the traditional headers, you are forced to do so if you want your library to be even minimally usable. I'm a big believe in people's laziness, so I'm sure as soon as it's possible to abandon headers, many library writers (especially of the 3rd-party closed-source libraries) will just refer you to the documentation if you want to see a list of function, which they will then fail to write, or write so badly as to be unusable.
Perhaps, but that's the motivation, to make the code more self documenting
Not going to answer everything but cmake offers an abstraction from to command line to call the underlying build whithout even knowing what generator was called. Usually you do : cmake -G "Unix Makefiles" .. make Whereas you can do : cmake -G "Unis Makefiles" .. cmake --build . It will call make. If you want to pass -jX you just do : cmake --build . -- -jX If you want to build with Release you do : cmake --build . --config Release If you want to build a specific target : cmake --build . --target benchmarks And for all of that you don't have to know the underlying generator. Cmake delegate it correctly. If I had -G Ninja, all of the above lines still stay valid. You also have a lot of options available with ctest (-C Release/Debug, -R label matching regex etc.) Imo for complex projects, you should first make the most out of the abstract layer offered by the command tool before coding it yourself in the CMakeLists.txt :-) .
But given `using ptr = T*`, then `ptr&lt;int&gt; c, d; ` creates two pointers
Can't we also have c++ compilers cache all include invocations? recompiling an include would be needed only if a dependency actually changed.
A is only useful for declarations. IMO this is one of the things that C did terribly wrong (together with implicit int and array notation syntax). Do you really need to ever declare `int x, arr[10], *p;`? I find asterisks on the left much more readable, especially for function return types. 1 declaration per line is also cleanr. And you can't use the right-side with folds/variadics (`Args&amp;&amp;... args`)
With the current situation, you have to write that if. Since operator-&gt; always returns T* without doing a check, and behavior is undefined when the optional is empty. and I don't think you can fix this with a library-only solution
Boost.Outcome is accepted recently and I guess it will be in the new release. https://github.com/ned14/boost-outcome 
&gt; Where a system package manager exists, it must be the primary source. This means the C++ package manager must a) not overwrite system packages Why any dependency manager would do things like this? All the dependencies are _project_ specific so it is natural that they would reside in the project directory IMO (or if you wish you can cache the deps in some other non-system directory known to the dependency manager). Using the system paths to download the dependencies to doesn't sound like a good idea at all. &gt; b) use the system package manager to install dependencies if a system package exists for that dependency, and Probably a good idea because there already exists a vast amount of available dependencies in distro repositories. &gt; c) refuse to install a package if there is a conflict with a system package (including if it requires a newer version of a dependency for which a system package exists). Not a problem if point under a) is approached correctly.
That's the most important advice. Writing raw CMake commands is like programming with assembly. You want high level descriptive constructs most of the time, or there will be too much noise and chances to mess something up.
But that has a slightly different meaning in English no?
If the package manager installs into a project specific directory, it's automatically failed the condition of supporting and using dynamic linking by default (by which I meant dynamic linking to system-wide libraries). Without this, you have to rebuild every time a dependency is updated (or more likely, you don't and most of your software is using an unpatched version of one dependency or another).
It's crazy complex to implement. It's a pretty basic building block of the language and should be easy to implement like in other languages
For the love of god, please do.
Awesome, thank you. I'm just here to poke you to see if you have done so. I am also in opposition but lack the experience from which you're appealing. Please send them your feedback.
In the standard library types it applies to, yes. I am saying that was a mistake given the cost benefit given current compiler technologies. The pre-17 fixed constructor design is much easier on compile times, for very little negative impact on developers. After all, we've all been writing code to a fixed constructor design until now without really noticing much. They should have kept things simple, kept compile times lower. 
Problem is macros won't be namespaced. Most of these old C libs are full of lines like **#define NUM_THINGS_IN_OTHER_THING 42** :(
Awesome, thanks! Been wondering how to set up tests for my clump of CMake libs. Would you do similar to this for the executable targets themselves? A 'test' dir inside the target dir set up the same way? Not sure if unidiomatic.
I don't believe it's possible with &lt;windows.h&gt;. If `_M_CEE` is defined (i.e. we are compiling under the CLR), then instead of macro redirection, it uses inline function redirection i.e. `GetClassName` becomes a real function and no macro of that name is defined. That seems to me what should be the default for all non-legacy Windows codebases. But only Microsoft know why it is not.
I gotta agree with this argument. I want the const-ness to be first so I see it. If it's second, I see it less. Hence all the code I write puts const first. (I use the same rationale for virtual functions, overridden functions still get a virtual before them so I can see they are virtual. It's totally redundant to the compiler, but first thing on the line means I see it quickly)
&gt; If the package manager installs into a project specific directory, it's automatically failed the condition of supporting and using dynamic linking by default (by which I meant dynamic linking to system-wide libraries). I am not sure I understand what you mean by this. What stops us from building the code with shared libraries if these libraries (dependencies) reside in the project directory?
&gt; Pretty much every language-specific package manager interacts badly with the system ones. It doesn't have to be that way. The reason they interact badly is because the only way to build a package by using the (language) package manager and thus building all its dependencies this way. In `build2`, the package manager is built *on top* or the build system (as opposed to being intertwined). This means that you can build any package by using the build system directly, provided you can supply all the dependencies. In case of the system package manager, the idea is that you first "system-package" all the dependencies anyway so there is no need to use the `build2`'s package manager. &gt; Where a system package manager exists, it must be the primary source. [...] In `build2`, right now (as in, this is already implemented) you can tell the package manager that a specific package comes from the system: bpkg build sys:libsqlite3 We also have a couple of ideas for the future: we can have an option to prefer system-installed packages which will make `bpkg` check with the system package manager (`dpkg`, `rpm`, etc) whether a system package is available (abd query its version). We can go even further and first try to install a *satisfactory* version from the system and only if not available, fall back to building from source.
Better editor is not *always* an option, though of course it helps when it is available (on the other hand, IntelliSense in Visual Studio is still a buggy mess, at least from time to time).
I too, am the west-const guy, but the dude has a good point. BTW... the const member methods **must** use east-const, what now!?
That sounds like what I'm looking for. Although if it finds a system package that is too old, I would prefer if it had a global setting to *fail* by default instead of automatically installing from source and potentially introducing bugs in other software. Now we just need to deal with the fact that almost all the large libraries out there use CMake, not build2.
Haha, didn't even notice any downvotes... The thing is, I really want it to succeed considering what it is supposed to do, and it feels like something that other people should want too. If people want a better build system, I think they should try to contribute to making one, if only by giving feedback. I had some ideas on things I think the build system needs in order to become really good, but I'll have to spend more time trying the build system out before I can provide constructive feedback. But the whole idea of integrating the build system with a package manager makes for very good opportunities.
I agree. "Integer constant", "Widget constant", etc sounds more aligned with the c++ language concept.
&gt; But the whole idea of integrating the build system with a package manager makes for very good opportunities. Yes, add C++ modules to this mix, and we are on the cusp of something big here...
I was using "east const" since 2005. I also write `int long` instead of `long int`, because reading out loud `int long const* p` type is the most natural (as long as you read it in reverse), so ¨pointer to const long integer". -A.
&gt; Package manager specific to the language (and not to the system) I believe should focus on providing a (cross-platform) way to formally describe the application's dependencies, make it able to query for them from multiple sources if possible and finally download them in order to make the build happen. Not more not less. By querying and downloading them to make the build happen, a language-specific package manager *causes* the problem. In the absense of this feature, it would simply tell the sysadmin building that XYZ dependency is unavailable, and they would then install it in the appropriate way. They then know that that library is installed, so they can update it if necessary. &gt; but not always a silver-bullet. i.e. when ABI breaks At least the ABI breakage is obvious, unlike a security flaw, which is invisible until it gets exploited.
You should read all types in reversed order, so cv-qualifiers and pointers and references in type description make sense.
Another example of why you want it undefined is the compiler can do cool optimizations such as with this void foo(MyType *ptr, int n) { for(int i=0; i &lt; n; i++) { bar(ptr[i]); i += baz(ptr[i]); } } assuming a 64 bit pointers, this can optimize it so that i doesn't even exist. The issue is that if overflow was defined (even by implementation) it would then need to check for the point where this would happen. This would not only pessimize the loop, but if it did get to that situation in this it is probably not what you wanted to happen anyway.
I don't know if it's a good example of CMake, but check out Ogre3D.
Constant (noun) &gt; Mathematics. A quantity or parameter that does not change its value whatever the value of the variables, under a given set of conditions. &gt; Mathematics. a quantity assumed to be unchanged throughout a given discussion.
Hello /r/cpp, I am the author of this programming language. I will gladly answer all questions related to this project. I have striven to get C++ feel into the language by incorporating all familiar data structures from C++ and by giving it a syntax as close as possible to C++'es. I have implemented everything in this project from bare C++ ground up, so it was a great learning experience for me, and it follows that this language allows for trivial embedding (Huginn into C++), though cross domain data transfer API is not perfect yet. I took the liberty of posting this here in hopes at least some of you will find this project interesting if not useful. Thanks and have a great day, -A.
So you like the East const rule because it is simple and consistent but you don't agree with the proposal that forbids it and states the reason as being that it has not been adopted and is therefore not consistent? ;)
Integer constant sounds much more static to me. Like a string literal is different from a const string.
Agree. Things like braces are important. Use original style pls. But const eh either is fine.
Didn't you get the memo from Herb Sutter?
`thier_ptr` (opposite or `my_ptr`)
It has brackets, we approve.
world_class_cxx != world_class_software_engineering
I've been reading through the ISO CPP guidelines and am liking it so far. Found the various other standards, e.g. Google, annoying due to their restrictions but I can appreciate why they have them. You can't really have a one size fits all coding standard
I started learning c++ with hungarian notation but it becomes worse with every day - especially when you have pedantic colleagues in codereviews. I can't convince my teamleader to get rid of it though.
snake_case is best case. 1TBS, spaces instead of tabs, indentation depth of 2. clang-format (and formerly gnu indent) to convert from what I like to a particular projects standards if it's different.
You're totally right; the build system knows all the dependencies, and the compiler/intellisense tool knows the types being used. There are a few tools that can remove spurious includes right now, but I'm having trouble finding anything that can automagically transform a header into a forward declaration. I would be willing to use a tool that does this wherever possible, and then it's on me to double-check the work to make sure that removing the header didn't also remove some other stuff I intended to include.
I cannot point you to specific examples, but I use CMake a lot, and have been using it for several large (closed-source) projects. Here are a few tips that might be useful: - Overall, do not hesitate to split your configuration in several files. In particular, put all your compiler flags in a dedicated CMake file; separated from the toolchain files. This has the benefit that you can use it to compile other projects with the exact same flags if needed (eg. Google Test). - Have all your dependencies searching in the same place, at the start of the project configuration. Hence, you don't have to browse tens of configuration files to find out what dependencies are used or how they are searched for. - The same applies to options and cache variables. Put all your options in the same file. For cache variables, what I do is I have a default.cmake in the top-level directory that contains the cache variables with the default values. In the top-level CMakeLists.txt, put: include(default.cmake) include(local.cmake OPTIONAL) That way, one can copy/paste default.cmake to local.cmake and make changes has he sees fit. The overarching concept is to put everything related to actual configuration (dependencies, compiler setup...) outside of the CMakeLists.txt files used in the project. For the multiple build variants, rely on BUILD_SHARED_LIBS, CMAKE_BUILD_TYPE, and CMAKE_TOOLCHAIN_FILE in your CMake configuration. To setup all the build directories, I personally use a Makefile in the source directory that generates several build directories. Hope this helps.
please tell me they don't
&gt; In my experience, any non-trivial application needs some form of application-specific abstraction, which you could argue becomes “library” code. Yes, but our library code that is limited to whatever is needed. You don't need to do something that works in all the cases, just something that work in all of your application's cases. This is not the case with std library writers, who have to conform to the spec regardless of what it costs. 
how does that make any sense?
I use PascalCase for custom types and camelCase for functions *specifically* to indicate my code is not part of the standard nor is it making any attempt to do so. In a large project with many users who only have a C background, it makes it easy to see at a glance where our code is being used. But that's just me.
But wouldn't this: //Returns an optional&lt;decltype(T::f())&gt;. None if optional is empty or o.get().f(blabla) auto ret = o-&gt;f(blabla); still require checking if `ret` contains a value or not in order to proceed further. If so, I don't see any advantage over the current situation. 
[removed]
I'll make sure to take a look at it! Thanks for the heads up.
Does that mean you use snake_case in Java and C#? By the same rationale you should.
The Google style guide is nice because it's comprehensive and gives details motivation for everything. It's bad because it's mostly written with legacy code in mind. They're quite open with the fact that it would be different if they started from scratch today.
Type is the most important thing. By. far. In fact, this is why another best practice is to put * next to the Type and not the variable name: int* x; // rather than int *x (note where the space is) I would hazard a guess that most people who use west const don't do much metaprogramming with types. True, you might use a library that does it, but you probably haven't written many type-based metaprograms yourself.
If I were on a Java or C# project, I'd conform to whatever the team is using -- the same as what I'm doing with my C++ code.
Type is the most important thing. By. far. In fact, this is why another best practice is to put * next to the Type and not the variable name: int* x; // rather than int *x (note where the space is) Which leads to yet another best practice, of one variable declaration per line, otherwise you have this problem: int* x,y; // oops.... y is plain int I would hazard a guess that most people who use west const don't do much metaprogramming with types. True, they might use a library that does it, but they probably haven't written many type-based metaprograms yourself. This is not meant to be insulting or superior... It's just that when you work with types even a little bit you realize (IMHO) that Type is the all-important thing and that east-const does us a favor by getting a mere modifier out of the way of the more important stuff.
Despite the authors saying that implementing this using multi-mapping of allocated memory is too hard on the TLB to be practical on x64, I'd be curious to see how bad it would be. Assuming four bits of colouring, every allocated page would need to multi-mapped fifteen extra times. Your remaining problem is then injecting the colouring checks around every load and store, something surely easy in any compiler supporting the sanitisers. Would be a nice little project.
Of course, but if you got to start fresh. Surely best is to keep it consistent (with the language)?
Absolutely, like I said you can't have a single standard to cover everything. Google's is interesting and understandably why it's like that. If you were writing C++ for embedded systems then your standard night be different to someone who's writing for the financial industry
In general, absolutely; I never said anything to the contrary.
To be honest, I find this name more confusing than `observer_ptr`. It sounds like it takes ownership temporarily from an owning ptr.
But how does it require textual includes? Many languages do just fine without them. See Rust, Pascal, Fortran, etc. 
(Unrelated to C++) Hardware designers need to reevaluate what their hardware is responsible for. The recent Meltdown/Spectre chaos should have been a wake-up call. The world has changed. The modern world runs on computers now. Sometimes I think that hardware designers don't fully grasp the responsibility yet.
I just want to underline that the NL section of the guidelines starts by saying "We present a set of rules that you might use if you have no better ideas, but the real aim is consistency, rather than any particular rule set. IDEs and tools can help (as well as hinder)."
[removed]
Obviously it's a very subjective thing. But I prefer to stick to what the original authors of both C and C++ do. That said, most of my scopes and functions are very short, often 1-2 lines for a loop as an example. Putting the opening brace on a new line leads to large amount of blank lines making it more difficult to read the code. Aligning braces seems like an attempt at making long and deeply nested scopes more readable. The real solution is to not do that in the first place.
Sorry it sounded in your first post that you deliberately made your code inconsistent with the language.
 #define NOMINMAX
No worries; it could have been worded better -- thus the edit. There is a section in their style guide that addresses this in a round-about way, though: &gt; As an exception, classes that mimic STL classes can have member names in STL’s style of lower-case words separated by underscores (e.g. `begin()`, `push_back()`, and `empty()`). Classes that provide multiple iterators should add a singular prefix to `begin()` and `end()` (e.g. `global_begin()` and `use_begin()`).
&gt; should be easy to implement Why? There's no support whatsoever for this statement given, it's just thrown out as being self-evident (it's not). `std::tuple` is allegedly a "*pretty basic building block of the language*," despite the fact that we managed without it for 20 or so years, and despite the fact that I (and I'd imagine others as well) rarely use it. But even if we accept this at face value (that it's a "*pretty basic building block*") this doesn't mean it ought to be easy to implement, it merely means that it ought to be available for wide use, which it is, because it's part of the standard library. Why does implementation complexity even matter? Your standard library is already written and provided. If anything the fact that it's a "*pretty basic building block of the language*" suggests that it's not at all relevant that it be "*easy to implement*." TL;DR: Citation needed.
Ok, but we should have this by default. I.e. the compiler itself should cache things as much as possible. 
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/80ktbj/is_anybody_know_the_tools_which_can_label_the/duwq13o/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
It has nothing to do with deeply nested scopes as I tend to avoid them. But the Allman style just looks more consistent and symmetrical and makes it easy to scan code when scrolling through it. I'd also argue that the added "blank" lines make it easier to read, rather than harder, as they help separate blocks from eachother. Interestingly, [this Wikipedia article](https://en.wikipedia.org/wiki/Indentation_style#Variant:_Stroustrup) claims that Stroustup encourages a more Allman-style layout as of 2015, but I don't understand the source for it, so maybe that's bs.
I told Herb.
Agree consistency matters. So stick with whatever style is already used in your project. And when starting fresh stay consistent with the standard library
Hello and thank you for your interest :) Well, it can be a little hard to explain as I did invent "backend" without looking into any books and I ended up with neither AST nor bytecode. In simplest words: parser generates long flat list of functors, those functors are calls to the "compiler", the "compiler" builds internal representation which is a tree of lists of functors (ToLoF?). This tree of lists of functors is an immutable "runtime" of the language, besides that there is program stack to handle run time state, built-in and user classes, built-in and user functions and packages. Those tree items (ToLoF, stack, and built-in/user definitions) make up the backend. I can gladly go into more details if you are interested. -A.
&gt; In the absense of this feature, it would simply tell the sysadmin building that XYZ dependency is unavailable, and they would then install it in the appropriate way. They then know that that library is installed, so they can update it if necessary. A package manager shouldn't change that, as it shouldn't be changing the build system, it should only be automating installing the dependencies. So a sysadmin can still try to build as usual and it gets an error that the dependency is missing. Alternatively, a package manager can be used which will install the dependencies and then run the build tool(just like the sysadmin would as well), and tell the build tool where it put the dependencies. That is, a sysadmin will try to install a library like this: mkdir build cd build cmake .. make &amp;&amp; make install But then would realize it needs a dependency that was installed in `/opt/foo`, so it updates cmake to find the dependency there: mkdir build cd build cmake -DCMAKE_PREFIX_PATH=/opt/foo .. make &amp;&amp; make install At the same time, a language-level package manager will install the dependecies in a local directory, such as `~/usr`, and then when it builds a package it will tell cmake where it installed the dependency: mkdir build cd build cmake -DCMAKE_PREFIX_PATH=~/usr -DCMAKE_INSTALL_PREFIX=~/usr .. make &amp;&amp; make install So, it simply automates the process, but does not prohibit.
In my case the better editor was Submime, that's how bad MonoDevelop was :P I do run into intellisense in VS crashing multiple times a dsy though, so point well takrn.
As with anything, it comes down to how many extra CPUs can they sell if they deliver some technology X. In that sense, SPECTRE will be a god send for profits next few years. Slap a sticker on a new CPU saying "SPECTRE safe", and expect to ship as many of them as you can make for whatever price you like. Very morally wrong though. But that's how lock-in in capitalism works.
CamelCase is by far the most popular naming convention. Used all throughout Microsoft, Google (check their style guide, we use pretty much the same thing we just ended up at independently), and big open source projects like Unreal.
Obviously this is designed according to my company's workflow, so whether it's idiomatic or not I can't say, but it works for us. Typically we structure our apps as follows: root/ +--- foo/ +--- test/ +--- app/ +--- foo.cc +--- foo.h +--- other_files... - The target within `root/foo/` is a static library, `foo.lib`. - The target within `root/foo/test` is a unit test which tests `foo.lib` - The target within `root/foo/app` is an executable which launches `foo.lib` The contents of `root/foo/app/main.cc` just launches the foo library inside a reactor style event loop, so typically consists entirely of: #include &lt;foo/foo.h&gt; #include &lt;app/event_loop.h&gt; int main(int argc, char* argv[]) { app::EventLoop&lt;foo::Foo&gt; a(argc, argv); return a.run(); } We finds this works for us because we can launch `foo` inside a unit test environment and simulate all the events a normal app will receive, and so the difference between that and the real app is nominal. One thing to note is that all our software is for in-house use only, so we're not doing any packaging or installation on client sites, we're targeting only a single OS/architecture (linux x86) (although we allow devs to build and test on Windows if they wish to, so our cmake scripts are cross-platform (although probably not in this particular project, as that was added later)) etc... so what works for us may not be ideal for other use cases.
&gt; How is one supposed to declare an immutable pointer that references a mutable int? I might do it like this: int&amp;.
This just shows how everyone means something different when they talk of a package manager for C++. You're talking about global installs into an extra directory (e.g. /opt) so it'll install packages there instead of using the system package manager. And let's not forget that if it's standardized, it has to work with every platform and compiler.
Hello. That is tough question. I started this project as an experiment in DSL grammar driven parsers, I wanted to know if I can create my own version of boost::spirit. To test this parser (actually as one of the unit tests) I first created trivial arithmetic expression solver, and because this expression solver looked very need I wondered how difficult it would be to create a proper programming language using this parser as a starting point. In all honesty I do not know what problems it is trying to solve. What I know is that I spent a lot of time polishing its REPL interface and it can be very useful for ad-hoc hacking in the terminal as it is a pleasure to work with if I (as an author) can say so. This REPL has tab completion, syntax highlighting, hints and sessions and starts really fast it also has experimental shell mode so after more polishing (and implementation of proper cross domain communication) it could be used as an interactive system shell with rather large programming capabilities. Besides that, I tried really hard to make the implementation both small in size and easy to understand and modify so anyone could built their own programming language if they were inclined to. Regarding purely practical matters Python is probably better choice. -A.
Well, I pretty much never manage to crash VS (unlike XCode), but our projects are on a smaller side, and we avoid heavy macros and templates outside of those that come with the standard libraries. However, Intellisense is perpetually confused by the simplest things. Like consistently going to the source of shared_ptr when you select "Go to definition" on a typedef'd pointer to some class, or randomly refusing to work at all. It did get better than it was a few versions ago, but there is still very much room for improvement.
Yes, I agree other language-specific package managers do interact badly with the system package manager, but for C++ its a non-starter. Furthermore, its rather simple to be able to interact friendly with the system package manager, which is why any standardized package management should not make manual or system installations difficult. Package managers like hunter or cget do not have a problem with working with the system manager. In fact, cget requires almost no changes to your build script, and it can already install many packages out-of-the-box.
I don't think I've seen people try to apply English grammar rules to a programming language until this thread
Huginn was heavily inspired by both Python and C++. The claim that Huginn and C++ have similar semantics is nowhere to be found, neither here nor at the language website. You can see in the title of this post that Huginn has C++ like syntax, but Python like semantics. Huginn also has equivalents of most C++ stl containers as a built-ins, so I stand with my right to have some kind of comparison to C++. -A.
&gt; This just shows how everyone means something different when they talk of a package manager for C++. You're talking about global installs into an extra directory (e.g. /opt) so it'll install packages there instead of using the system package manager. No, I am not. The installs can be a global install into another directory(like maybe a stsadmin would install globally into `/opt`), or it can be a local install into a local directory(such as `~/usr` or `$PWD/deps`). &gt; And let's not forget that if it's standardized, it has to work with every platform and compiler. First, I dont see a portability problem. This is what vcpkg and cget on windows do. Secondly a package manager invokes build systems, not compilers directly. So a standardized package manager would include not just a specification for a list of dependencies, but also would include a specification of the build environment or toolchain description, so there is a standard way the package manager can pass that information to the build tool.
I personally hate spaces instead of tabs. I've never comprehended a compelling reason for it other than 'some places print tabs ugly'. It is cumbersome to align text in the editor, annoying to 'backspace' indentation, etc. without a very sophisticated editor which basically tries to pretend you were using tabs all along. My personal style has always been 'tabs for indentation, spaces for alignment'. That means the code looks correct to everyone despite their editor tabstop, and then leaves the indentation purely as a user preference. The only reason against this approach I've found seems to be developer laziness. I'm curious if anyone who feels passionate about spaces over tabs and can articulate compelling arguments.
&gt; At least the ABI breakage is obvious Of course it is, it is not as if I had to spend a day debugging a build script that read the wrong boost headers for an already compiled library. In contrast to libpng on which some APIs will nicely abort on a version mismatch between run-time and compile time libraries. In fact I see absolutely no issue with making reproducible builds with a stable set of dependencies impossible. We should go a step further and adopt the npm model of installing pre release alpha libraries on update. 
I like what I see. Whitespace seems on point. I'd be happy to use that clang-format config. Too bad about the camelCasing. And in particular the insistance on using all uppercase for acronyms. I find XmlHttpWriter more readable than XMLHTTPWriter.
On my team we use a very basic form of Hungarian ('Hungarian lite'), where just a few types get prefixes for clarity. Basically 'p' for pointers, 'sp' for smart pointers, and a few others (primarily around string formats, i.e. char* vs. string). These generally help readability, and allow you to catch some obvious memory management mistakes or other inefficiencies ("Wait, are you returning a raw pointer, that might not be right"), but isn't a giant pain to follow as with standard Hungarian.
That's what it is, is not what is read at first sight. There's quite the disconnect here between "it is" and "is read". `const int* const` brings the "it is" much closer to "is read". No, it is not perfect, as this constant pointer to constant value is quite the hell to both represent and read regardless of east or west preference. But when you have only one thing that's const (either the pointer, or the value) it fits perfectly. 
I'm not sure how widespread the style is, but I'm very adamant about some sort of prefix for class member variables (we use 'm_' which is common in a lot of Microsoft code). I've seen code bases without any distinction between member variables and locals, and it drives me crazy.
&gt; Very morally wrong though. Citation needed. Everyone seems to assume that Intel should've done something about SPECTRE et al. without considering the cost/benefit of that. Seems to me that this is getting into the same issue as the Ford Pinto debacle: Ford decided that saving a human life wasn't worth some number of dollars, which everyone objects to, but what if the cost of saving a human life was much greater than that? We can project this argument out and say that not installing every conceivable safety measure in every car sold is putting profits before people, but clearly if that was done cars would be outrageously unaffordable for most people. Same goes for computers: How much cost should CPU manufacturers pour into their CPUs ensuring that they're bulletproof? To what degree is affordable, widespread computing technology worth the risk that those CPUs will have bugs?
I don't think that argument lasts over time. You would adapt to see it wherever you decide to usually put it. At least that's what I've found. You could argue that putting `const` closer to the variable name makes it easier to see and more important. People actually often ignore the type (either because it is `auto` or because it is obvious). Often you don't need to scan the entire line of code starting at the beginning. To a certain extent, you start at the variable (if well named, it tells you more than the type, as the type is obviously more general (used elsewhere) than the variable name which is specifically chosen for this very occasion.) The variable name should tell you most what you need to know. Then go left and/or right from there.
Maybe all of my editors are misconfigured? I use Vim all the time, and if I run with expandtab, insert a tab, then move over it (with h/l) I have to move over every space. Also, the default for 'smarttab' seems to off, which means that inserting a tab, then hitting backspace requires 'N' hits of backspace, not one. Also, Notepad++ (a fairly popular editor on Windows) doesn't seem to have any special handling to make 'expandtab' behavior equivalent at all. So my money would be on a significant number of editors having a significantly different experience between spaces vs. tabs.
&gt; Befunge code I don't read Befunge code. for anything more than a hobby or personal projects, I do expect the language to be easy to read. C++ can get a bit crazy at times with metaprogramming but that's just a skill to be learned. reading from right to left ... I guess i could, but why? I don't have to, then i don't. 
npm is about 50% of the reason why I don't think language specific package manager are a good idea.
Try mixing them. Put brackets on their own lines for large/important blocks, put them at the end of the line for small/unimportant blocks. It sounds like heresy, but it is nice when you get the hang of it. C++ syntax doesn't allow much room to express extra information; formatting, at times, can help. Also, you should learn to be comfortable with either style anyhow, eventually you will work somewhere or read code somewhere that uses not-your-style, and you can either be grumpy all day, or get use to it.
I also find m_ useful, but: Consider making your functions smaller. If your function fits on a single screen without scrolling, it is not hard to see where variables came from, and you probably have less variables to keep track of.
Unique, weak, and shared are adjectives. View is a noun or verb.
'tabs for indentation, spaces for alignment' is the best way to tab, but unfortunately hardly anyone uses it.
Good point, I didn't think of that. So it should be "viewing_ptr" (imho horrible idea).
Sadly, many pronounce it as "putter" (but more mashed together). "pudder" even. And "stud" or "stid" instead of "standard", for `std`. Sadly, STL (the person) is one of these people. And I had such high hopes for him. /shakes head slowly
I prefer east const. Changing function arguments or variables from values to const refs or vice versa is quite frequent. East const makes that a single action while west const means two actions separated by some navigation. One small but nice practical editing win. 
ephemeral_ptr, as it could go away at any time. 
I often fix the type of formal parameters expected by functions: beginner/unaware colleagues like to pass containers by value. When, I have 10 member function signatures per class to fix, twice (.h, .cpp), I rather paste "const&amp;" once instead of adding "const" before and the ampersand after. In the end, I'm the east-guy when parameters are concerned. I don't care, really, otherwise. 
Which hungarian notation? There are two of them: the original one ("Apps Hungarian notation") and the new/stupid one (the "System Hungarian notation"). See https://en.wikipedia.org/wiki/Hungarian_notation. Basically the apps people came up with the idea: well, a coordinate can be either relative to the window, or the page, or the document, so let's prefix the coordinate with the kind/type of it, i.e. (just assuming here): wX and wY are window relative coordinates, dX and dY are document relative coordinates, etc. Then came the system team: so you are prefixing every variable with it's type? Ok, let's do it! And then came the lpszMadness... 
the big difference is that with tabs I can decide to make my tabs look 4 spaces wide when all my coworkers, the heathens, use 2 spaces. 
All of the languages you mentioned need to be compiled beforehand. None of them has a runtime that interprets them directly.
&gt; I don't think that argument lasts over time. You would adapt to see it wherever you decide to usually put it. At least that's what I've found. Not for me yet in twenty years. But I suppose it could yet change. &gt; You could argue that putting const closer to the variable name makes it easier to see and more important. People actually often ignore the type (either because it is auto or because it is obvious). When I'm quickly browsing code, I'm usually looking at the function signatures, not the implementation. Types are much more important there. They say which overload it is, and indicate lots about the function's meaning. &gt; Often you don't need to scan the entire line of code starting at the beginning. To a certain extent, you start at the variable (if well named, it tells you more than the type, as the type is obviously more general (used elsewhere) than the variable name which is specifically chosen for this very occasion.) The variable name should tell you most what you need to know. Then go left and/or right from there. I'll accept this as a reasonable argument for function bodies. Not for function signatures. You could use a different east-west style for function signatures and bodies, but that would be kinda weird and anti-social.
&gt; Everyone seems to assume that Intel should've done something about SPECTRE et al. without considering the cost/benefit of that. I think people are annoyed because (a) they are losing something which they previously had and (b) it's not hideously hard to have avoided in the first place (cache needs to reserve space based on process ids so process A can't manipulate reserved cache for process B), so it's an example of poor engineering. And us being engineers, that upsets us, especially as they'll see outstanding profits for their poor engineering which just encourages them to do it again. 
https://youtu.be/ZsHMHukIlJY One of the most useful talks about code style, I highly recommend watching it.
I wonder how hard it would be to use this gcc prototype on a gentoo system and rebuild as many packages as possible? That might give you some interesting numbers.
There's Angelscript (http://www.angelcode.com/angelscript/). It's statically typed, looks _very_ C++-like, and integrates very easily in C++.
Because the integration between lua and the host code would have less impedance mismatch.
Hungarian is actually fairly nice when you use it to indicate scope: "m_" for members, "g_" for globals, "t_" for thread-local, "s_" for static, etc. Stack variables don't get a prefix. Maybe you can convince your boss to switch to this. Or, alternatively, make everything auto with corresponding prefix "a" ;-) 
Convert if to a function with if-return sequence FFS.
Please try adding the Oxygen updatesite [1] to the updatesites in Cevelop. This might help as DevStyle has a dependency that cannot be satisfied by its own updatesite alone. [1] http://download.eclipse.org/releases/oxygen
never use "using namespace std", or "using namespace" in general.
Mine: https://github.com/kmhofmann/cpp_coding_guidelines ;-) But also the C++ Core Guidelines, of course!
I've eventually found that consistency (particularly in APIs) goes in levels. You can't be consistent with everything, so you try to be consistent with what is closest first, then move outward from there. So self-consistency is most important, then consistent with "nearby" things (ie other things from the same library, when talking about APIs), or "same family" (ie variant/optional/any), etc. Then move outwards. variant/optional/any should be consistent with STL containers, but not as consistent as with themselves or each other (when you need to chose one over the other). Then again, I do `const int x;` but `int const * p;` And mix my bracket styles based on the size/importance of the block in question, so...
Good point about function signatures. Types tell you so much more there.
I strongly believe think that the success of Python is not because of python itself, but it is because of the success of its PIP!!!! And the requirement file of pip can make the life of c++ committee easier. For example, in python requirement file, you can write: BeautifulSoup==3.2.0 Django==1.3 Fabric==1.2.0 similarly, if we have a requirement for pip c++, we can write something like this: cppstd=2011 #suppose will deduce auto x{1} as initializer_list Then suppose we regret this decision in 2017, we can change it to cppstd=2011 #deduce auto x{1} as int see , we solve the issue easily and developer can select the version to be used 
There's actually a compelling reason (as far as I understand) to do this, especially in C++17. Legal: std::lock_guard&lt;std::mutex&gt; lock_mutex(bool b) noexcept { if (b) return std::lock_guard&lt;std::mutex&gt;(mutex_b); return std::lock_guard&lt;std::mutex&gt;(mutex_a); } Illegal: std::lock_guard&lt;std::mutex&gt; lock_mutex(bool b) noexcept { return b ? std::lock_guard&lt;std::mutex&gt;(mutex_b) : std::lock_guard&lt;std::mutex&gt;(mutex_a); }
&gt;When, I have 10 member function signatures per class to fix, twice (.h, .cpp), I rather paste "const&amp;" once instead of adding "const" before and the ampersand after. You need our Lord and savior, vim macros.
Yes. If you want an expression you can use to initialize a const then that's a much better way. Otherwise, there's nothing wrong with just leaving the `if`...`else` there in the code. `if`...`else` is easy to step through in the debugger, and it's easy to breakpoint one case rather than another. `?:`... not so much. I just don't see any advantage. 
That actually sounds like a sensible approach. I wish clang-format supported that behaviour. Open brace on new line for scopes larger than N lines. Generally I just autoformat all code on save.
Well the systematic one then. We have a complete styleguide page dedicated to mapping prefixes to types - some make sense as they for example also help intellisense to organize them more nicely in the autocomplete list (`s_` for static, `m_` for members, `g_` for globals) for others it's just becoming awful (`f` for float, `i` for signed integers, `n` for unsigned integers, `vec` for std::vectors, etc.) I've smuggled a few variablenames in, where the underlying type is irrelevant, since I don't care if I iterate over a vector or a set at a few places. But that was before we started code reviews.
I actually come from the standpoint that C++ should just require diagnostics on multi-variable declarations involving pointers or reference. Maybe even deprecate the feature, though it'll be many years before it could be removed. Even when one correctly writes `int *p, q, *u;` the result is still confusing. It's just bad grammar inherited from C that would never have been chosen were the language a clean break.
Yeah, one character of whitespace is worth having pointer types stand out from their base type.
&gt; but the reality is that I'm not using raw pointers The rule applies to references as well. &gt; const on the left just reads more nicely Not sure I agree. `const int` reads as "constant integer" and `int const` reads as "integer constant," either of which read smoothly.
My examples were contrived to demonstrate the issue and why function with `if`/`else` could be preferable.
Hm... so what? 
An `observer_ptr` doesn't exactly observe very much about the pointer, as I understand it. `std::weak_ptr` is much more observant. `raw_ptr` would better communicate that you can't expect it to be null if (for example) the pointer it is "observing" were deleted. `*_view` has become somewhat of a convention for "thing that doesn't own another thing." Maybe `ptr_view` or `value_view` or just `view` would work? (Not sure I like any of those either though.) 
Not ideal but flexible enough that I could love with it. Of course if it was me I'd drop all of that
We stumbled over the `tabs vs spaces`issue when we switched to git/gitlab with online codereviews. luckily we found a js snippet to switch tabs from 8 to 4 in all browsers. Since then I don't care about it anymore.
I don't follow your point about references; references themselves are always const (a reference can't be re-seated), so there's only one const and it references to whether the reference can modify the referent (referee?). There aren't two things that need to be const-ified, and therefore there can't be any consistency between them. Integer constant only feels correct because it's been used so much that it's basically treated as a compound noun. It's not really correct because integer isn't an adjective, it should be "integral constant". Ultimately in C++, `const` is something that modifies a type. Types are nouns. So `const` is an adjective. Adjectives go before nouns in English.
That would be interesting! Let me know how it goes ;)
In the C++ mode I use (Emacs), I don't think there's really a use case for something like smarttab. The editor knows the indentation style I use so I just hit tab and it adjusts the indentation of my current line as needed. Presumably there's something analogous to this mode in other editors? If you're always moved automatically to the correct indentation, I don't see much need to be able to delete multiple spaces in order to adjust your indentation in C++ code. (?) Certainly it is useful when editing a language like Python and that's how the Python-mode behaves by default for me... 
Nah. I've been using `:substitute` for more than 20years and still continues. I've never really been a macro vimmer. Yet, here I prefer movement + `p` over movement + `@@`.
I don't see how that follows.
Not my choice, but I could live with that since I pretty much only pass either by value or by const ref. 
Does this have any support for std::thread?
I'll see what I can put together. Maybe I can crowd fund my electricity bills.
Never use raw pointers unless you're explicitly handling memory. Case closed.
It sounds good in theory and works fine when there is only a few devs, but crashes and burns when meeting real life. Only a few bad devs is enough to ruin it with random mixed space tabs everywhere :(
Unfortunately, all standards are 99% a collection of someone's personal preferences. Discussions about standards are also that. They're neither a hindrance or a boon, the only benefit one gets out of a standard is homogeneity, not better code.
&gt; I don't follow your point about references; references themselves are always const (a reference can't be re-seated), east const: `int const&amp; cref` "integer constant-reference" west const: `const int&amp; cref` "constant integer-reference" C-style east const: `int const &amp;cred` "integer-constant reference" C-style west const: `const int &amp;cref` "constant-integer reference" &gt; Ultimately in C++, const is something that modifies a type. Types are nouns Which comes first *could* follow the rules of English, and I'd agree with that if C++ were exclusively a language for English speakers and if C++ were actually just English. Given that we're talking about writing C++ code and not writing an English novel, the rules of C++ take precedence and east-const makes more sense. ... usually sometimes maybe. :) Which is probably good, because English is weird. Adjectives don't need nouns to make sense, and they don't *have* to come before the noun. "The dog is wet and seeks shelter" is an example. Or "The dog, wet, sought shelter." You *really* don't want to try to apply the rules of English to programming. Bask in the regularity and strict grammatical forms of programming languages and *think* in them when you have the opportunity. The fact that C++ has arguments about east- vs west-const is a panacaea compared to arguments about the Oxford comma. :p Talking about English though, the phrase "const is something that modifies" makes me giggle a bit. :p Really, the confusing part is that C++ makes constness opt-in rather than opt-out. If the world were just and pure, we'd be talking about `mutable` keyword instead. ... and also types would always be postfix, since the *actual* noun is the declaration itself, and the type is an adjective of that noun, and the mutability is an . `let ref: &amp;mutable int` "ref is a reference to a mutable int". Alas, C++ is derived from C and not Haskell. :p
Gross.
It explains why in the naming guidelines : "it's common practice". It's a good way to let anyone reading your code understand, just by looking at the variable, that "this variableis a constant". For example const double PI = 3.14; should be preferred over const double pi = 3.14; and should DEFINITELY be preferred over #define PI 3.14; Like many people have mentioned, these should be considered as recommendations, not laws that you must adhere to. 
2 spaces is so gross. I get that we're trying to fit everything in 80 characters, but even if you're indented 5 times (at which point something is horribly wrong), what are you gaining, 10 characters? Just split the damn line up. 2 spaces makes everything look crowded and makes the blocks all blend together.
References are no different from variables... you can write east or west const but the meaning is always the same. The only place in the language where west const ever bites you is pointers, because pointers have two types of constness associated with them. References do not. When you use a pointer, you essentially *have* to use east const-ness if you want to make the pointer itself const. You don't have any choice. You only have the choice between east and west const-ness when deciding whether the pointee is const. Again, this just doesn't happen with references. I mean, all C++ keywords are English words or shortenings thereof, to start arguing that we should try to make C++ read well in German or Spanish even though it's clearly all English inspired, and it's obvious that English is the lingua franca of the C++ (and programming) world. As for your other sentences, the first uses "is", and the second is just very awkward. We can debate this endlessly but there's no argument that the standard, simplest way to add a describing adjective noun is to put it before. "A blue dog", "a const integer", "A fast blue dog", "a const volatile vector&lt;double". Etc. And yes, const-ness being opt-in sucks, but this is just a natural part of being backwards compatible with C, and then itself.
That doesn't work if `foo_impl()` depends on `T`.
Due to the preprocessor, I believe.
Cool - I'm not using MinGW anymore but appreciate STL's awesome work a lot :-) Out of interest: Now that WSL has become a thing (which includes gcc-7.x from the toolchain-r repo), what would the advantage of MinGW be?
The author glosses over the biggest issue with the ternary operator: both alternatives must be convertible to a common type, which can easily *not* be the type you are expecting. For a (slightly contrived example), consider something like this: class foo { public: // converting constructors (not marked explicit) foo(long long); foo(double); private: std::unique_ptr&lt;class foo_impl&gt; m_impl; }; foo build_foo(bool b) { if (b) return std::numeric_limits&lt;double&gt;::max(); else return std::numeric_limits&lt;long long&gt;::max(); } If you replace this with a ternary operator, the else branch will be cast to double, losing precision. You could construct similar examples where the if-else version is unambiguous but the ternary operator version fails to compile or where the wrong converting constructor or cast operator gets invoked. In my opinion, the (debatable) improvements in code clarity are not worth the weird corner cases of the ternary operator.
&gt; You don't have any choice. You only have the choice between east and west const-ness when deciding whether the pointee is const. I'm not sure if we're agreeing or not at this point, but yeah... and that is in part why, when one *does* have a choice, it makes some sense to choose east-const. &gt; make C++ read well in German or Spanish I never implied that to be a goal. I said C++ is C++. Applying English rules to C++ makes as little sense as applying German rules to English even though ~40% of the English vocabulary is Germanic, or applying Latin rules to English even though ~60% of the English vocabulary is derivative of the romance languages. :p I don't write `Let's suppose there's a variable named Mr. Index that could hold any machine-word-sized integral value but that starts out equal to five.`. I write `int i = 5;` :p &gt; As for your other sentences, the first uses "is", and the second is just very awkward Details. :p 
Now that I check, neither snippet compiles pre-C++17, and both compile in C++17. So there is no compulsion to choose either form. 
Seems like a leftover from the days when most constants were preprocessor constants, which for good reasons should be all caps. Ordinary variables marked as const however is probably one of the safest constructs in the whole language so it seems odd to have it UPPERCASE to make it stand out. And since in modern C++ we're supposed to make as many variables as possible constant you end up with most variables UPPERCASE, which is a bit silly.
I almost like it, especially when/if you can construct from a shared_ptr or a unique_ptr. Then the name makes sense. But if you're allowed to say borrowed_ptr( new foo ), it is a little weird. Borrowed from what? Maybe dumb_ptr, taken right from the paper title, or basic_ptr 
Variable declarations don't stand out so much in C++, new variables can be created anywhere (in contrast to, say, Pascal with its VAR block that appears only at the beginning of a block). After debugging 8 hours straight through unfamiliar code, not having to scan a function - even if it's just 20 lines - is welcome help.
The nest ternary operator version is slightly shorter / requires less typing: char displayedChar = (x + y &gt;= 30) ? '.' : (x + y &gt;= 25) ? '/' : (x + y &gt;= 20) ? 'o' : (x - 3*y &gt; 0) ? '|' : (x - y &gt; 0) ? '\\' : '_'; vs. char displayedChar = [=]() { if (x + y &gt;= 30) return '.'; else if (x + y &gt;= 25) return '/'; else if (x + y &gt;= 20) return 'o'; else if (x - 3*y &gt; 0) return '|'; else if (x - y &gt; 0) return '\\'; else return '_'; }(); It's also more readable in my opinion.
One thing I have found is that the more pages in a coding standard, the less it will be used. It won't be used for coding. If it is used for code reviews, the meat of the code won't be reviewed, just adherence to the standard. 
I just have rarely if ever seen it work right. Pretty much every file that used tabs somewhere, has multiple authors, and no central, pedantic moderator, ended up with a mix of tabs that align nicely in 4-space expansion, tabs that align nicely in 8-space expansions, spaces, and a complete mess that doesn't look right at either setting. 'tabs for indentation, spaces for alignment' needs either doing it all by hand, or an editor that can distinguish between indentation and alignment - do you have one? In contrast, the sophisticated editor you quoted only needs to find out how much to indent ("position of the '(' in the previous line"), insert as many spaces/tabs, done.
I think this is very on point. Package management, not a standard library, is the way to go for many things. One of the worst things about third party libraries at present is that declaring any dependencies is such a big deal, so usually they just don't. Why is `std::optional` entering the standard such a big deal when we have `boost::optional`, a perfectly good implementation, available for so long? (I'm sure there's improvements in the implementation/spec; before someone jumps on me). Other than knee-jerk anti boost'ism, the real reason is that if you are writing a library, making your library depend on boost just to have access to `optional` is kind of a big deal. People write a library (even an internal one in sufficiently large companies) and want it to be used, and they don't want to take a strong stance on this. So they just say: "ok, optional is nicer, but I don't want to have this dependency, so let's just make do with error codes". In C++ nothing can ever become even close to a commonly seen, "vocabulary" type, without being in the standard. With better package management, this could change. Something like the proposed Outcome could have been a package in a package manager, and slowly (or not slowly) become a dependency for many packages that liked its approach to error handling, becoming a de factor vocabulary type without being accepted into the standard. As it is, it's a great Boost library and one that I'll happily use but few third party libraries are going to use it (ask Titus if Abseil is going to start using Outcome; it would make me happy but I can't help but be skeptical). A package manager also helps avoid a catch-22 that I don't think this article directly mentions; often there's a desire to try to standardize things, but simultaneously they haven't seen enough usage that there is confidence about standardizing them. Yet, sadly, it's very hard for *any* thing in C++ to get very wide usage without being in the standard. Being able to more easily use non-standard would ironically not only reduce the necessity to put things in the standard library: it would also make it faster and easier to be sure you were putting the right things in the standard library.
Interesting, perhaps I was confusing the legality/illegality with which one qualifies for RVO (the latter does not as far as I can tell). The reformulation of prvalues in C++17 must've saved the latter despite the fact I don't believe it qualifies for RVO.
Neither snippet would compile pre-C++17 as `std::lock_guard` is not copyable or movable (and at least one was required to return a value from a function in C++11/14). I didn't think the latter would be saved, but perhaps I was thinking of the NRVO.
Nothing. But i can name my instance `MyClass` then.
I think you have a point. It is really ugly to have UPPERCASE words sprinkled all over your code.
Where do you draw the line for scripting languages? I certainly wouldn't call F# a scripting language.
Unfortunately, he uses logical arguments to defend his findings. And, AFAIK, you can't change developers' style habits with logical arguments because they didn't come to form those habits from logical arguments.
This so much! Much of code alignment and variable naming conventions I see are often just to better cope with overly long functions and scopes. A better solution is often to just have shorter and more focused functions.
This looks lovely, but I think it would belong better within clang-tidy which already has fixits and such.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/80q8zt/is_this_a_good_starting_book_starting_out_with_c/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Yeah, I feel that way for many things as well. Especially boost PP, I basically refuse to use the preprocessor for anything non-trivial without boost PP, if you can't deal with it, you're SOL.
I agree with almost everything Titus says, including the graphics library being inappropriate, and the need for a way to distribute libraries and their dependencies. But how would "standardizing" a way to distribute libraries and their dependencies be possible or practical? Is there a proposal for even a high level view of what that would really mean? Or even a blog post? I haven't though about it much, but whenever I do it seems much more complicated than many people realize, and impractical if not impossible for the ISO C++ committee to really tackle. Especially in any reasonable time frame. It _might_ be reasonable for them to standardize some common **format** for the meta-data necessary to build and link to a library. (i.e., something like `pkg-config`, but cross-platform) That alone might help quite a bit, but even doing that will be painful. Think of `Cflags` and how those flags are compiler-vendor-specific and not specified by any standard. Think of making it cross-platform. Then think about what "standardizing" actually means: to make the smallest change - even one minor new required flag - takes **years**. Would people accept that? So has somone got a concrete or even hand-waving proposal for how this stuff would work, and be successful? I _want_ to believe it'll be possible. I assume someone's thought this stuff through; but my google-fu isn't good enough to find anything.
I _love_ boost PP. I wish it were better documented, but the things you can do with it are amazing.
Bincrafters have summarized some of the new features in a blog post: https://bincrafters.github.io/2018/02/27/Updated-Conan-Package-Flow-1.1/
&gt; "it's common practice" It's also the "justification" for a lot of other rules... I think that document should really be titled "Codification of what I think are the most popular choices of style". And something being popular is not an argument for that thing staying popular. Nothing against you /u/nicobako. I've just yet to see a standard that bases its rules on logic rather than fallacies.
It looks like you just did it. Congrats!
There is no hassle-free way to run GUI applications in WSL - https://askubuntu.com/questions/993225/whats-the-easiest-way-to-run-gui-apps-on-wsl-as-of-2018
The ternary operator is a great tool which, when used well, improves the readability and clarity of your code. For example, it can put the focus on `return` rather than logic statements: if (hair == blue) return fat; else return average; Compare with: return (hair == blue) ? fat : average; Like any tool, you can use it well or you can make a mess.
We already have a few non-standard package managers and build systems for C++ that more-or-less solve the problems you describe, at least for the most common cases (and usually allow to handle less common cases via various hack and workarounds like writing out per-compiler flags by hand for a package that really needs them). The most basic possibility is to declare CMake the standard, and tell people to live with it. This won't be accepted by everybody, and won't be to everybody's liking, as CMake has its share of quirks and outright problems, but for most people, it's good enough in the long run. Sure, it might not quite work on more exotic platforms or compilers, but those are probably incompatible with C++2x anyway. Does that mean CMake (or CMake-like tool) *can't* standard? It's a hard question to answer. If we look at it from the point of some purism, then no: unless the tool can work on any platform with any reasonably modern compiler, it should not be a part of the standard, even if it covers 90% of use cases. However, from the point of practicality, bringing such a useful tool into the standard would make life easier for a lot of people over the time, as legacy build systems will slowly wither away (or so one hopes - just recently I encountered a library that uses custom Python scripts for building, and another one that can only be built with autotools even though it was written only a few years ago, and let me tell you, I was not a happy man). Of course, pretty much everybody would prefer CMake not to become the standard, including CMake's authors, as I'm sure they'd be happy to rewrite the whole thing from scratch using the experience they accumulated over the years, but can't do that because of heaps of legacy CMake makefiles that need to be supported. If CMake NG came out tomorrow, it would probably fail to gain any traction unless it was fully compatible with the old CMake. But if the Committee proclaims some new build system standard, and get buy-in from major compiler and IDE vendors, it should give it enough of a boost to begin replacing old build systems. *And* it might lead to compilers standardizing their compile flags - won't that be nice?! :) (Actually, clang and gcc are pretty compatible, it's MSVC that is Different in this case, and I don't know anything about Intel compiler).
Before making such patronizing statements you could have done a quick grep through the boost or stl.
This one is one of my favourites. Please never use 'using namespace'. And if you do, please not at global scope. Please use the smallest scope feasible.
I believe it does now. winpthreads was added a while ago... https://github.com/StephanTLavavej/mingw-distro/commit/0fae620dbfee1c3ce9b68c79b5a718037e09e076 I tested the openmp stuff and it worked in a toy example. not tried std::thread. 
I completely understand. I also completely agree with you guys. I feel like I'm getting crushed by a religious war... I was only quoting the naming guidelines. I'm not saying that that's what you should do. In fact, I even said that people should first imitate the styles of well written code, then innovate and come up with their own styles. In fact, the best place to go to find advice on writing clean and understandable code is [Jonathan Boccara's blog fluentcpp](fluentcpp.com). That's really what i should have recommended from the very beginning.
your post has been removed for not being in line with /r/cpp requirements. for c++ programming related questions, see /r/cpp_questions.
I would wrap the entire if statement in a function to clean up the calling code, and either use an if statement, or ternary. Depends on what's the best looking and easiest to read. Usually the ternary would be better. 
Lame
Thanks. It's been a while since I used this distro, and I remember not having std::thread. Glad to see it's supported.
I think at this point the real reason to use spaces is "you don't have to think about it". The editor handles everything for you and most editors allow you to increment/decrement indentations without having to do backspace 4 times. I used to like 'tabs for indentation, spaces for alignment' too but really it's just too much work and hassle to have to fuss with things like that for me now. I have learned to appreciate the simplicity of spaces only, and not just because they look the same across different editors, but also the simplicity in not giving any surprises (one backspace means one space less, use the editor to indent means aligned to N spaces).
This is very satisfying for me: You can write native Windows executable starting from `int main()`! No `int _tmain()` or `int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)`.
The clazy README says... &gt; clang-tidy support will be added after https://bugs.llvm.org//show_bug.cgi?id=32739 is fixed. ...which is an enhancement entitled "Allow clang-tidy to load more checkers from an external library/plugin". So, essentially, clang-tidy doesn't support doing that yet. However clazy basically acts as a Qt-specific clang-tidy with fix-its and all. It just means you have to do an extra separate build for now, until its checks can be incorporated into clang-tidy.
&gt; For stuff that started in boost and was later adopted by the standard, the boost version often offers more functionality or isn't 100% compatible with the standard version. My go to example is `boost::container::default_init`, or all the stuff in Asio (but not the Networking TS) related to SSL, signals, serial ports, and Windows handles.
&gt; Used all throughout Microsoft Definitely not! Unless you're limiting your statement to .Net languages.
That looks good, I hope they are able to implement that, though I know how hard plugins are for c/c++ to get to work *really* well. I'd be interested in seeing the rationale behind not adding them in tree. Good work none the less. 
What kind of optimizations do you have in mind?
I think this post is more confusing then it needs to be. The only conceivable reason to ever use an "optional reference" over a pointer, is for function parameters. Both for consistency with mandatory in/out parameters, which are passed by reference (unless you're a Googler), and more importantly for more convenient binding of optional const ref arguments. Outside of function parameters I can't see any reason to ever use this over `observer_ptr`, and I can see multiple reasons to use `observer_ptr` over this. It's also pretty confusing having `-&gt;` and `*` on a type which identifies as a reference. In C++ reference means a rather specific thing and it's supposed to provide access to the original type via `.`. I would follow an interface more similar to `std::reference_wrapper` in addition to the explicit bool operator. You also missed 2 major advantages of `observer_ptr`: it can't be compared to NULL, and more importantly, it's fantastic to start adopting in legacy codebases where sometimes raw pointers are owning. Every time you find a raw pointer, you make it either `unique_ptr` or `observer_ptr`, and you know that anytime you see a raw pointer it's something you haven't dealt with yet.
&gt; I'd be interested in seeing the rationale behind not adding them in tree. Good point. I assumed it was because it's non-standard C++ but, looking at the list of clang-tidy checks, there are existing ones that fall into that category already.
I don't think this is the place. For one, there's no reason a cryptocurrency needs to be done in C++. For another, the hard part of developing a cryptocurrency is working out the protocol and cryptography, the code comes later. What you need to is a whitepaper that lays everything out in crystal clear detail, and that may serve to get devs interested.
I always go for the if. At some point, you're going to want to put a breakpoint on one case rather than the other, and the if statement makes this possible. Last thing you're going to want to have to do when this happens is get distracted by having to edit code, recompile, run again, and get back to where you were.
ok, i was thinking of funding a dev in the future
4 is correct. Python.
F# can do either.
Inexplicable burying. This is a totally reasonable axiom.
&gt; I certainly wouldn't call F# a scripting language. Again, so what? ;-] &gt; [Scripts use the file extension `.fsx` or `.fsscript`. Instead of compiling source code and then later running the compiled assembly, you can just run `fsi.exe` and specify the filename of the script of F# source code, and F# interactive reads the code and executes it in real time.](https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/fsharp-interactive/) Looks like a script, smells like a script, REPLs like a script...
&gt; “C++ leaves no room for another language between itself and the hardware” OT, but I disagree. As soon as you really try to go down to the hardware level and treat bytes as bytes instead of objects you are running into a whole world of undefined (or if you are lucky implementation defined) behavior. At the same time, standard c++ offers no facilities to easily use most of the processing power of modern systems (read vector instructions and GPUs). Finally, the fact that the language expressed all kinds of low level details like memory addresses, there are a lot of optimizations that are really hard or even impossible for the compiler. Imho there is definitely room for a language that is closer to the machine as well as a language for better performance. The big advantage of c++is that it is an allrounder that allows you to write pretty efficient and maintainable software for microcontrollers as well as for server farms.
Please, tell me how I should use the `operator""`s in `std::literals` then. ;-]
On initial reading it appears dismissive/combative, but that's the problem with text-based communication: It's impossible to judge tone.
Why bake stuff into the names of my variables when I can just have my editor color things differently based on what they are?
Personally, I don't see the ternary operator as being useful in most situations. I like that the if/else statement is more generally extendable(multiple cases, making multiple assignments), which in my mind is a helpful for maintaining code. I also prefer it from a readability perspective, although I know many will disagree. The one case where the ternary operator comes in handy for me is for conditional initialization of a variable, especially a constant. 
I have always been against trying to force devs not to be stupid. See, stupid people are gonna be stupid no matter how much you try to restrict them. Your restrictions usually just hurt smart people. My idea would still provide header files, but they would be generated. So if you release a library, you'd still release your header files to go in /include directories, as well as (hopefully) your .cpp files. 
&gt; (and at least one was required to return a value from a function in C++11/14) Neither is needed if you return via list-initialization, even in C++11.
Is this just a minimal mingw-w64 (http://mingw-w64.org/doku.php) ?
*in headers
Since you're apparently trying to obfuscate the code, why not start with something like this: unsigned i = (x + y)/5 - 4; char displayedChar = (i &lt; 4) ? "o/.."[i]; If you *only* use a ternary operator, it'll throw a few people off, but some will still be able to read it fairly easily...
&gt; Adjectives go before nouns in English. But there are exceptions galore.
Nah, not worth it. "West const" is the overwhelming convention. Even developers who understand why "east const" might be technically better (for weird cases) might prefer "west const" (I do) because most of the time it's more naturally expressive of what they care about expressing in code. In the end, it's going to be easier to identify and not use broken code than it would be to change the convention. It doesn't really matter that the other convention makes more technical sense because it only makes more technical sense to people who know why it does in the first place, so IMO you're not buying anything except other people's confusion or annoyance by writing it the least-common way - especially when it only matters technically in a fraction of a fraction of a percent of the cases you might have to deal with. "East const" lost the war, and while nobody can stop you from flying its flag it would sure be a lot easier for everybody if you didn't ;)
`int&amp;` can't be null; `int* const` can.
&gt; We already have a few non-standard package managers and build systems for C++ that more-or-less solve the problems you describe, at least for the most common cases Yes I've seen people advocating to standardize CMake. I just don't know what that really *means*. Do they mean to literally standardize CMake **the application**? Which version? Who would administer it? Who would pay for fixes/improvements? Who would decide what new features it gets, how they work, and how their API looks like? Who decides what platforms it should support? It's open-source but managed/supported by Kitware, a private company - what happens if they close down, or get bought? Or maybe what people mean when they say "standardize CMake" is they mean standardize its current language/API or some subset thereof, and specify what that API logically (but not physically) does. Sort of like the STL is standardized from an API point-of-view but not how to achieve it under-the-hood. But that would likely be a herculean effort, and even after being done would still have the problem of even minor changes to it afterwards taking years. But even *that* API wouldn't be enough. Because there are known issues with depending on a library that was compiled with compiler X version Y with flags Z, in an application using a different one of those "X|Y|Z". The new ABI was one issue obviously, but [some](https://bugs.llvm.org/show_bug.cgi?id=19668) are far more subtle and only found at runtime. And as far as I know, CMake doesn't know what compiler+flags was used to build a given library - if it finds a matching library name, it's happy. (unless you manually told it otherwise) Or am I wrong on that stuff? Could easily be the case - I don't know much about CMake other than as a user of it, and I never look into the Makefiles it generates. So I'm kinda hoping there's some proposal or blog post or video or something, that explains how standardizing anything here would really work and make practical sense. 
Lol @ your example
&gt; The most basic possibility is to declare CMake the standard, and tell people to live with it. It doesn't seem wise to standardize something that is loathed by a substantial part of the C++ community (and if you don't think this is the case, here is a [snapshot](https://codesynthesis.com/~boris/tmp/cmake.png) from a recent discussion). Also, I think many don't realize that by "standardizing" on CMake you standardize on all the underlying build systems it targets (make, ninja, MSBuild/VCProj, XCode). This means, for example, that CMake won't be able to support C++ Modules until all these underlying build systems support them. And that can take a very long time.
I am extremely disappointed in those people. I pronounce std as "s. t. d."
Conditional breakpoints are anything from slow to really slow, so this isn't necessarily a great solution. What if this function is called a million times a second, and your program is interactive, and now it's unusable? You're stuffed! You're always much better off when you can just put a breakpoint on the case you want. There's also a non-zero chance that the condition will involve something that the debugger doesn't support. Like, the condition is `f==VALUE`, and `f` is static, and `VALUE` is in a namespace, and somebody did a `using namespace`, and the debugger can't figure out which of these things you mean, and now your condition goes from a simple copy and paste into `MyAmazingVeryLongClassName::f==fredlib::detail::constants::stuff::internals::private_parts::VALUE`. And then when you click OK the debugger says "cannot resolve value". And it cancels the dialog so you have to type that shit in again. This is also not much fun if the condition involves a function call or some rather involved condition. All in all, you're just much better off which you can put a breakpoint on the case you want. Out of all the things that don't work that you will meet when trying to use a debugger, putting a breakpoint on a source line is the one that's closest to working as you'd expect.
Hmmm I agree my comment could have been phrased better, sorry about that
It makes sense in C, because you can't overload functions so you will use names like `cosf` for `float`. But in C++, unless your some reason it's critical to know that you're going to use a `float`, there's no need to mark it. For integers, using `xxx_count` often makes more sense than `n_xxx`, because you have more semantics there.
I feel like that is the case with lots of the boost libraries. Compared to cppreference for standard stuff and the Qt documentation I always dread having to look up boost documentation. 
No worries - I took it a bit personally because I also do metaprogramming, but am a west-conster. The more important thing, however, striving for const-correctness, regardless of what camp you're in. IMHO, a good practice is to const all things, and something that is non-const and whose lifetime exceeds next 20 lines of code down, needs an explanation in comments on how the state is expected to mutate throughout the lifetime.
Sorry for the self-promotion here, but I've written cmany ( https://cmany.readthedocs.io/en/latest/ ), and I find it helps me immensely in my CMake workflow. With one simple command, it can configure build and install a combination of compilers, build types and build targets, toolchains, compilation flag bundles. For example: cmany build -c clang++,g++ -t Debug,Release results in 2 compilers * 2 build types = 4 builds. The build trees are placed under a local build directory, named conveniently after the specific combination (like triplets in clang).
Great post! I echo your sentiment for the graphics library as well. I'll rant just for a bit, because this keeps coming up. I don't understand how people are still complaining about dependency managent. I hear this time and time again. We have it. It's called conan. It works. I can create a project from scratch, on Windows, link or compile boost with no errors in about 5 minute. I can add bincrafters remote for a plethora of great open-source libraries and have a cpprest-sdk server up and running in **minutes**. The resulting project isn't some toy thing you hardcoded library paths to mess around with. It is a fully functional project ready for cross-platform development and fully equipped to deal with the pitfalls of dependency management. You don't need to fight with cmake on Windows, or deal with various library paths on OSX (native vs. brew vs. macports). The project you just created in 5 minutes can be cloned by colleagues and it will work. You might need a few tiny tweaks the first time you launch on an untested platform. Total time? Maybe 15 minutes for 2 platforms (including reboot time). Before conan? Abandon after a few of days, or don't support Windows. [slow-clap] I don't understand what people are waiting for. Some sort of magical fairy that will read their mind and fix all their problems. But as far as dependency management goes, it is a fixed problem. It's called conan. /rant
Yes, this is great advice. By using wrappers, I can tweak them to add tests, sanitizers, neatly organize my target names (and folders in VS), and have it all happen automatically, all while keeping the target creation code clean.
Yes! cmake --build is a veritable workhorse. I've written cmany, a tool that leverages cmake to apply to many build item combinations at once. (I've already linked to it below, but here it is anyway: https://cmany.readthedocs.io/en/latest/ ). &gt; you should first make the most out of the abstract layer offered by the command tool before coding it yourself in the CMakeLists.txt Yes, this is so true. It's exactly for this that's I wrote cmany for.
Functionally, there's no advantage in this example. I'm not really arguing for an `opt_ref` _over_ an `observer_ptr`, I'm just bemoaning the lack of `std::optional&lt;T&amp;&gt;` and the fact that `observer_ptr` gets you most of the same semantics but in a different syntax.
IMHO you can't really discuss this technique without also discussing immediately evaluated lambdas. Not only does this allow arbitrarily complex and multi line statements, but it also addresses the issue mentioned by /u/IncongruentModulo1 regarding same types by allowing you to specify the type explicitly. const auto x = [&amp;] () -&gt; desired_type { if (cond) { return expr1; } else { return expr2; } } If you're ok with the type being deduced you can of course omit the `() -&gt; type`. This also works for setting a value in both try and catch without initializing it to a dummy variable, and in fact for just encapsulating arbitrary logic that results in a variable you don't want to mutate further and use const on.
Yeah don't you like writing `std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::high_resolution_clock::now() - t0).count(); ` ?
Pointy McPointface it is! Thx reddit, never change &lt;3
&gt; so it's still useful to have a GCC that targets native Windows. isnt that called clang?
&gt; and since the first alternative in the ternary is the smart_ptr the compiler chose that type. That's not how it works. ;-]
Oh, my understanding was that for `x ? a : b` if `a` is convertible to the type of `b` and `b` is also convertible to the type of `a` then the type of the ternary is that of `a`. But I guess not.
At the very least it runs afoul of the [Self Promotion](https://www.reddit.com/wiki/selfpromotion) guidelines
That page is so hard to read :(
That page is so hard to read :(
Nope, it is a misunderstanding of this design goal. This design goal is about source code writing and program execution, not about compilation process. LLVM IR is an intermediate product during compilation. With such sloppy interpretation, you can absurdly say all intermediate products during compilation processes are languages between C++ and hardware. This is absurd.
MinGW can still run on earlier Windows, as some corporates are slow with upgrading the OS.
I don't know why Winters leaves out the catch of "except assembly language". It is such a important excuse...
The issue with conan is that it requires you to know like, three different languages. I want something like Cargo, where I can write my code in a declarative style, in a toml file or something like it. It also uses CMake, which is part of the problem. Even if you're trying to be declarative, it still requires something like 30 lines to do tests and the like.
Yeah, I finally added it after someone showed me how to build it. I don’t usually add things I don’t use myself, but this was a top request. I intend to keep building with this enabled, unless it breaks horribly.
Fairly minimal; I make a number of choices to simplify things and reduce bloat (e.g. no 32-bit), and I don’t try to build every library, but I do build a number of extra things that I use. Also, I have the simplest “installer”.
In fact, my home PC is still Win8.1. (I’ll install Win10 on my next PC, but upgrading in-place terrifies me.)
And note that my distro is static, so there are no DLLs to redist.
I c++ what you did there.
The biggest hurdle I had from quickly skimming was the slightly darker grey boxes and associated font. It feels as though the font has shifted and interrupts my scanning. On SO, you can see it's much more subtle when they have an inline "keyword" or whatever: https://stackoverflow.com/a/4813250/493106 The next thing I'd say is that your subheadings such as "Why did std::optional drop support for reference type parameters?" don't look much different than the "normal" text lines, especially the really long subheading name ones. I'd recommend some sort of graphic and left indentation to make them stand out more so if I want to skip to the next section quickly I can.
I think, C++ is not special in that "if it's not in the standard lib, it's not vocabulary", same goes for others, it's more that their approach is "more batteries!!!"
&gt; Are you referring to the inline code snippets like this yes.
You're fear mongering, stop it. If you hit some edge condition like you said, recompile. It's worth the risk of that small price for more readable code.
OK, I'm going to say this, despite the downvotes it'll attract: braces _are_ important, which is why you should **not** use original style. if by "original style" you mean K&amp;R or [Stroustrup style](https://en.wikipedia.org/wiki/Indentation_style#Variant:_Stroustrup). The opening brace should go on it's own line. Every time, every where. Kevlin Haney's [seven ineffective coding habits of many programmers](https://www.youtube.com/watch?v=ZsHMHukIlJY) talk explains why, but the tldr is it leads the eye to more clearly see control flow, and makes your eyes/brain actually work _less_. I had always used the K&amp;R style, until I joined my current company 4 years ago where they use the Allman style. It took a month to get used to, but I will never go back to K&amp;R willingly now. (of course if my next employer already uses K&amp;R I'll do it to keep consistent, but it will be painful - like going back to C++03 after using C++11/14)
I'm inclined to blame the implicit conversion :/
Well... the `asm` declaration is actually in the C++ spec and thus language, though it's "conditionally supported" and its meaning is implementation specific and obviously the assembly language to put in it is unspecified. But really that's still way too high level. Even viewing the binary as hex-ascii is pandering to text editors, and leaves the conversion back to binary up to the editor's interpretation. Who knows what it does with our hex? All _real_ programmers need is a keyboard with two buttons: bit set, bit unset. And I suppose one more button for deleting the previous bit, if you're sloppy.
`std::dumb_ptr` to complement the smart pointers.
Although I think the case's problem is the global state and not the ref, what's the problem in writing new projects using a different convention? The moment I've started writing const on the right, I never could go back, even if I tried, because I spent my time "fixing" the misplaced const, while the right did not require any thinking and felt natural despite other languages placing immutability on the left
This would have been much better if he hadn't tried to call his pet project "world class code". This would have been more compelling as "A safe alternative to runtime polymorphism" or something that actually dealt with the talk.
&gt;what's the problem in writing new projects using a different convention Getting other people to work on or with that project &gt;I spent my time "fixing" the misplaced const I'll be honest, even if it isn't worth very much: I can't remember a single instance of a problematic misplaced const in anything I've ever worked on. The dominant problem I've always experienced is missing const, not misplaced const. 
I've had a look at cmany and it looks really cool. I have the issue of handling multi-compiler very often and up to now, handmade bash did the job. I think it's time for to try a real robust solution :) . Thanks !
I'm the opposite in that I used to do Allman for many years and switched to K&amp;R. I'll never go back. The main visual structure showing scope is indentation and Allman just looks horrible and is highly distracting. Plus K&amp;R looks more like Python and for me the braces fade in into the background. But I admit it's highly subjective so I don't hate people who like Allman.
Kinda a noobie question here, but is there a way to write a tree-based data structures with smart pointers? You have to traverse the tree so I don't see how it fits unique_ptr and shared_ptr kinda has a quite a bit of overhead. I rarely use new and delete, but this is the part where it seems using raw pointers is the easiest.
If necessary I'll import std::chrono locally in the scope where it's used. But I'll probably just write it all out.
ALL CAPS should be reserved for macros and macros only
1) The term 'observer_ptr' is wrong in so many ways. 2) references are not nullifiable in c++, but they can be null, if a pointer to null is dereferenced.
In the future, leave it 24 hours before pinning. Pinned posts actually get _less_ visibility.
Actually, this is probably the first post from him/them that doesn't link to a blog promoting their tool.
&gt; I don't think that argument lasts over time. You would adapt to see it wherever you decide to usually put it. At least that's what I've found. Agreed. I used to place `const` first, but relatively recently started using "east-const" and after getting used to it, it scans even better for me. Before, I needed to skip over the leading `const` to read what the interesting part of type is, now I can quickly read that this method returns say `std::vector&lt;Foo&gt;` and then read on to see that it returns it as a `const&amp;`.
Yeah, but all the other build systems are bad as well, and not as common/supported as CMake. I will try conan, though; I haven't given it a fair shake. I do really think any kind of programming language as the default configuration language is a bad choice.
There's little reason to not do using std::literals. There's little risk of collisions since use defined literals aren't allowed to not start with _ in the first place.
I meant a misplacement from the style point of view. I've also didn't encounter misplaced consts that led to problems. 
Does is also link stuff like SDL2 statically?
That's why "do as the standard library" is a very good starting point. Together with clang-format and it's all very easy
Our counters are named `nCounter` or `nIndex` which is a wonderful example of bad Hungarian notation for me
It's very sad to read massive improvements over std::unordered_map and std::function are possible but they can't be implemented in the standard because of backward compatibility. What is the plan? Deprecate it and use std::sparse_map, std::func? Are there any such proposals?
Author of the library here. I wrote the lib out of necessity to deliver efficient updates of big files. Key highlights: * Dumb http server supporting `Range` header is enough to store files. * Clients do all the hard work. * Files are patched in-place. * Clients reuse existing data even if it was moved in the file. * Multithreaded! You may compare this library to rsync. Of course it is not as fast and not as efficient as rsync, however it works good enough already. You also get to own the code (MIT license) and do not need special server setup. If you have any questions i would be happy to answer.
hmm, what? I use Conan with Visual Studio project? Which Conan stuff isn't supported for VS? Maybe i miss smth...
Well, I said it's the "basic" possibility, not a "good" one. Even though personally I prefer CMake over any build system I've seen so far, I also agree it shouldn't become a standard if any better options are possible.
There is nothing inherintly wrong with using raw pointers. You should only never use owning raw pointers (e.g. memory allocated with "new" without assigning it to a smart pointer). E.g. the tree could internally use unique_ptr and expose raw pointers which is totally fine.
Yep.
You are completely right. MinGW and WSL are quite different actually. Btw, compilers do not target WSL (i.e. there is no WSL "target"). They produce native Linux (elf) binaries that run on Linux.
Yup, it is. But this man loves std so much so he want to drop all it's names to global scope, so I don't think he cares about any collisions. 
Completely agreed.
&gt; Do they mean to literally standardize CMake the application? well, why not ? for instance most of the coreutils are standardized: here's the standardese for `make` for instance: http://pubs.opengroup.org/onlinepubs/007904975/utilities/make.html 
When people (including myself) say "Let's standardize CMake" what they really mean (I think) is "Let's somehow force everyone to use CMake". It doesn't actually mean writing a standard definition of CMake syntax or anything like that (because, as you point out, that's hard and not ever very useful, since CMake evolves constantly), but more like sending hit squads to abduct authors of libraries that doesn't use it and force them to write a CMake file. Or, in a less violent scenario, magicking a team that will send pull requests with a working CMake file to every library in the existence that lacks one. It's a wholly rational wish with a wholly irrational implementation. Yes, if everyone used CMake, life would be much easier. No, we can't force them. Although a formal endorsement from the Committee might do something in that direction, but not really much. More realistically, we need an universal project definition language, with support from all major IDE vendors and open-source community, so that CMake is not needed any more.
Except that nobody actually writes makefiles for POSIX make since it is so basic as to be useless for anything real-word. Instead, most make-based projects require GNU make (except, perhaps, BSDs which are happy with their own make extensions).
&gt; Something like the proposed Outcome could have been a package in a package manager FYI Outcome comes in many convenient forms: (i) single header file (ii) Conan package repo (iii) git submodule (iv) traditional tarball (v) Boost 1.69 onwards. Source: https://ned14.github.io/outcome/build/ You should be aware that Outcome getting into Boost has had a big effect on WG21. They are concerned about the fragmentation of error handling approaches, and wish to do something about it at the language level before it gets out of hand. You *may* see something about it at Jacksonville, if the Standard C++ Foundation approves my funding request (hint: Titus, please check your email) then you'll *definitely* see something about it at Rapperswil.
In C++ 17 `std::unordered_map` and `std::map` gained Howard's node based API which is a huge improvement in efficiency. So the gap has been closed somewhat between sparse/dense hash maps and the STL maps. Last I heard, the plan was to implement sparse and dense maps using a Range view, so you'd take a vector, adapt it into a map view, and bang you're done.
If the types are different, and each is convertible to the other, the expression is ambiguous. What goes in the first vs. second alternative is not considered. :-]
Tried that with Boost, did not go well (to put it mildly).
No comments about pattern matching?
Excellent argument, thanks!
It does appear to be the source of nearly all keywords in nearly all programming languages, so it's not far fetched...
I believe they are reliving problems they had with exactly your construct. 
Assuming there's still no support for ```-fsanitize=address```? :(
I gave up on going for readability years ago. Nobody seems to agree on what it means, and the discussions are just endless bikeshedding. Instead I try, however imperfectly, to be a bit more data-driven about things. One metric I use is whether something causes an active impediment to my day-to-day work? No = it's fine; yes = it's bad. And by that metric, this particular thing is bad. This isn't fear-mongering, it's just exactly what happens. I've been doing this a long time, and this very thing has caused me an outsized level of annoyance. And after the level of annoyance over time reached some threshold, I drew my conclusion. And that's why I always go for the if statement. 
Is that high performancr code? If not, make it a data driven loop. If so, it is important enough to make it take up space: the comments explaining those bounds will take up more space than the code anyhow.
You're using a weird version of Hungarian Notation just so you can use PascalCase *everywhere*. You do you, but I just don't see how adding useless information to type names can be anything but distracting, problematic, and error-prone.
&gt; distracting, problematic, and error-prone. how would adding a C be any of that?
sure. usually locally in for-loops and the like.
&gt; Feature: `$ conan search &lt;pattern&gt; -r=all` now searches in all defined remotes. This is great! Searching for a specific package that could be on any of conan-center, conan-transit or bincrafters was a really tedious process.
I find your rationale really interesting, mostly because I have exactly the opposite opinion: on a declaration, whether a variable is const is the thing I'm least interested in. The auto keyword teaches us further that the typename is the second-least thing I'm interested in. In my opinion, by far the most important thing about a declaration is the name of the variable, because that's really what indicates the abstraction that I'm playing with. The rest is just telling the compiler to check my spelling.
Sounds reasonable. Thanks for the explanation.
RTL. In my head: "c is a constant integer". int *const p; // p is a constant pointer to an integer int const *p; // p is a pointer to a constant integer int const *const p; // p is a constant pointer to a constant integer
&gt; There is nothing inherintly wrong with using raw pointers Sure there is. A raw pointer `T*` can have these possible meanings: * A non-nullable pointer to a T * that you own (and must delete) * that you do not own * A nullable pointer to a T * that you own * that you do not own * A pointer to an array of T * that you own * that you do not own * A non-nullable pointer to an array of T * that you own * that you do not own * Uninitialized garbage that you can overwrite (i.e. declared but not assigned to) That's nine cases - and there's no way to tell which of these cases it actually is except by reading someone else's documentation, and relying on their accuracy. On the other hand, if you use the right smart pointer or reference, you can specifically identify exactly what you mean, _and_ the compiler will make sure that you always do the right thing and don't double delete or leak memory.
Exactly.
Use `/permissive-`
Thanks! Fixed.
Sure, everyone tries to avoid the preprocessor, but there's some things where it's still the least evil. If you're emulating reflection, if you want to be able to stamp out switch case statements, in certain cases where I've found that I needed some kind of dummy tag type, and probably others... You don't have a better recourse in C++ than the preprocessor.
* You have to stop and think to add a C or an S. * If a struct is changed to a class, its name becomes inconsistent. * You could accidentally forget the C or S. Now, let's say you forget the C on a class in, let's say, an open source library. People now depend on that class. You notice the error, but can't fix it without breaking everybody's code. You could deprecate the class and add a new one with the correct name, but now you have 2 identical classes with different names. This is all fine if your code is closed-source and only you or a small team will ever see it. Even so, I wouldn't suggest weird, unnecessary styles like this. It's so much simpler and cleaner to just use PascalCase for type names and camelCase for everything else.
Not really. It's hard to give examples from python because python's standard library is *so* inclusive, but lots of (3rd party) python packages seem to have become de facto standards for doing a certain thing. For instance, surprisingly the python standard library doesn't have really good timezone support (the support in datetime sucks). Pretty much everyone uses pytz for this; it's a dependency of some big packages like matplotlib and pandas. Pytz is the vocabulary package for timezones in python. Now imagine someone writing a C++ library that handled a dataframe like abstraction. IMHO, most likely they wouldn't touch timezones at all with a 10 foot pole. It would only work with utc times, or at best have some static/dynamic interface that let you pass some kind of timezone like object so you'd have to wrap whatever library you were using. That's more the mentality in C++ to desperately try to avoid dependencies, just often this has a high price for users in convenience.
That's predicated on not using idiomatic modern C++. Given the following rules: * If it cannot be null, use a reference. * If it owns memory, use unique_ptr or rarely, shared_ptr. * If it's a range, use gsl::span or a reference to a std::array. * Don't leave variables uninitialized. (and I really hope most people at this point are following all of these) Then, a raw pointer's meaning is unambiguous and unproblematic. It's a possibly null pointer to a single object which is owned by someone else. 
I don't know, but you can use it by including &lt;ciso646&gt;.
* unless in source files and local scopes (for an example, try writing a duration_cast without it) * unless you are importing a namespace that was meant to be imported with `using namespace` (std::literals, std::string_literals come to mind).
This distinction can be summarized as semantic annotations versus syntactic annotations. Semantic annotations would refer to what a variable means, what it is used for. Some examples would include: - prefixes to distinguish between iterating lines and columns in a matrix - lnIndex, colIndex - distinguishing between source and destination: void copy(srcData, dstData); - distinguishing between input and output: void copy_records(stream inStream, stream outStream); Syntactic annotations make no sense at all because: - the compiler already knows this information - it adds details that are not really required - require extra effort for refactoring. 
It seems to have similar semantics to a reference so `referring_ptr`
Not entirely clear what you're asking--It sounds like you are asking for help to express a sequence of delayed actions that need to be repeated indefinitely. Since c++11, time, delays, and sleeping can be done entirely via the standard library; prior to that OS specific APIs were required. The OS specific APIs still have some advantages for specific use cases such as event driven programming, but for the moment I'll focus on the standard library. Assuming that lines up with your use case, we'll need to look at: * expressing time and delays(std::chrono) * delaying execution(std::this_thread::sleep_for) * expressing actions (std::function) * organizing actions and delays(std::vector) **Time and delays** [std::chrono](http://en.cppreference.com/w/cpp/chrono) is a beautiful library that addresses several traditional pitfalls around working with time. It represents times via the [*duration*](http://en.cppreference.com/w/cpp/chrono/duration) template, which combines a std::ratio with a period to represent elapsed time with units in a *type safe way*. Likewise, the [*time_point*](http://en.cppreference.com/w/cpp/chrono/time_point) template combines a period with an epoch to specify a specific point in time. The standard library provides three time sources called *clocks*, which offer the current time via the clock::now() method: * std::chrono::steady_clock, time since the computer was turned on(not effected by leap seconds, NTP, user changing the clock, etc.) * std::chrono::system_clock, UTC time(may be effected by leap seconds, NTP, etc.) * std::chrono::high_precision_clock, generally used for precise performance measurements. Each clock has it's own *duration* and *time_period* types suited to the implementation. std::chrono provides a conversion function([std::chrono::duration_cast](http://en.cppreference.com/w/cpp/chrono/duration/duration_cast)) and several time types to make it easier to work with. Given the desire to work in absolute time delays, steady_clock seems like the most relevant choice--system_clock would be a better choice if the events were predicated on a specific date+time. As a concrete example, we can get the current time and create a time two minutes in the future: using clock = std::chrono::steady_clock; auto now = clock::now(); auto delay = std::chrono::minutes{ 2 }; auto later = now + std::chrono::duration_cast&lt;clock::duration&gt;( delay ); std::cout &lt;&lt; "There are " &lt;&lt; later.count() - now.count() &lt;&lt; " clock ticks in " &lt;&lt; delay.count() &lt;&lt; " minutes." &lt;&lt; std::endl; ** Delaying execution ** The standard library provides an easy function for sleeping for a specific delay: [std::this_thread::sleep_for](http://en.cppreference.com/w/cpp/thread/sleep_for). Example: std::this_thread::sleep_for( std::chrono::minutes{5} ); Sleeping isn't precise--the standard allows for the function to sleep longer than the specified duration. Between that and code execution time, it's possible for delays to accumulate and skew the overall time. If that's an issue, it can be avoided by setting up a reference time and operating relative to that: using clock = std::chrono::steady_clock; std::array&lt;std::chrono::minute,3&gt; delays{ std::chrono::minute{2}, std::chrono::minute{5}, std::chrono::minute{5}, }; auto reference = clock::now(); for( auto delay : delays ) { auto scheduled_time = reference + std::chrono::duration_cast&lt;clock::duration&gt;( delay ); auto sleep_period = scheduled_time - clock::now(); std::this_thread::sleep_for( sleep_period ); reference = scheduled_time; /* do something here */ } However, that's only important if precision over time is required. As a closing note, the standard library doesn't provide for doing event dispatching like epoll(linux), kqueue(bsd), iocp(windows). As you observe, threading is the only way to handle multiple event sources via the standard library. ** Expressing actions ** Now when the delay expires, some action is supposed to take place. Since I don't know how much modularity your use case requires, I'll suggest a *very* generic approach for expressing actions via [std::function](http://en.cppreference.com/w/cpp/utility/functional/function) and [lambdas](http://en.cppreference.com/w/cpp/language/lambda). It's overkill if there's a fixed set of actions that can just be hard coded; however that's almost never the case. Virtual interfaces are another alternative that works well when a rich vocabulary is required. However, they're not as concise, so I'll stick to std::function and lambdas. Let's assume there is a current lighting state that contains all the information that should be modified *struct lighting_state*. We can generically express an action that modifies that state via *std::function&lt;void(struct lighting_state &amp;)&gt;*, a function erasure that accepts a reference to a lighting_state to modify. That constitutes the interface for our action. We can readily populate the interface with a lambda to create a captured action: struct lighting_state { /* TBD */ }; using action = std::function&lt;void(struct lighting_state &amp;)&gt;; action example_action = []( struct lighting_state &amp; state ) { /* lighting change code goes here */ std::cout &lt;&lt; "example action ran!" &lt;&lt; std::end; } /* invoke the stored action at any time */ example_action( lighting_state{} ); Lambdas and std::function provide a flexible and concise way to run arbitrary code modularly. ** Organizing actions and delays ** Thanks for bearing with me, time to tie everything together. We've covered how to calculate and sleep for delays and store arbitrary actions generically; the only remaining task is to provide a data structure for the actions and to run them all indefinitely. While any sequence container will do, std::vector is quite often a better choice than std::list or other alternatives(plenty of discussion elsewhere on that). Having chosen a sequence container, we just need to select an element type that expresses delay and the action. While std::pair and std::tuple come to mind, in this case they both less expressive and more cumbersome than a simple user-defined struct: using clock = std::chrono::steady_clock; struct delayed_action { clock::duration delay; std::function&lt;void(struct lighting_state &amp;)&gt; apply; }; With that definition, creating a sequence of delayed actions is straight forward: using delay_cast = std::chrono::duration_cast&lt;clock::duration&gt;; std::vector&lt;delayed_action&gt; actions; actions.emplace_back( delay_cast( std::chrono::minutes{2} ), []( struct lighting_state &amp; ){ /* first action */ }); actions.emplace_back( delay_cast( std::chrono::minutes{5} ), []( struct lighting_state &amp; ){ /* second action */ }); actions.emplace_back( delay_cast( std::chrono::minutes{3} ), []( struct lighting_state &amp; ){ /* third action*/ }); Running the actions indefinitely just builds on the prior example: auto state = struct lighting_state{ /* user defined */ }; for(;;) { for( action : actions ) { std::thread::this_thread::sleep_for( action.delay ); action.apply( state ); } } Or, preserving accuracy over time: auto state = struct lighting_state{ /* user defined */ }; auto reference = clock::now(); for(;;) { for( action : actions ) { auto scheduled_time = reference + delay_cast( action.delay ); auto sleep_period = scheduled_time - clock::now(); std::thread::this_thread::sleep_for( sleep_period ); reference_time = scheduled_time; action.apply( state ); } } Hope that helps.
&gt; I'd agree with that if C++ were exclusively a language for English speakers and if C++ were actually just English Thank you so much for mentioning this. It seems like the argument a lot of people think is THE argument is that west const reads better/more naturally, but it reads better for English speakers only. You made my day.
You should set up your IDE to show local / member / global variables in different colors. It makes it very easy to see which one is which. I even use the same name for member variables and constructor parameters. So I have for example: class Point { int x; int y; public: Point(int x, int y) : x(x), y(y) { } };
You can write tree and other recursive structures (liked linked lists) using unique_ptr fairly easily actually. The problem is that your destructor and move operator (you'll have to write the copies by hand, unless you use a variant of unique_ptr that supports deep copies, which is probably a good idea) will use recursion. For something like a binary search tree this isn't so bad because the trees are guaranteed to be balanced. For linked lists this is horrible because your highest stack depth will be equal to number of elements stored, and recursion is far slower than a for loop.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/80vedj/c_using_time_in_simulating_a_lighting_control/duynw8t/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
&gt; you don't need to think - only execute according to if it's a struct or a class. Your style isn't common. In fact, it's bad practice. If I had to adopt your style, I very much would have to think about it. &gt; Also I really don't care if I break anyoelses code, if they're courageous enough to depend on mine ... I'd prefer to fix my typos and force everyone else to correct their code as well. Please never make an open source library with that mentality. You would screw over a lot of people by introducing breaking changes without thinking about it. Breaking changes are for major version bumps only and there should be a lot of them all at once. It's okay to change naming mistakes prior to release, but not after. At least not until a major version bump. &gt; ...and this would happen with any other typo as well. Sure, but mistakes like this are far more likely when you expect multiple people to adopt a weird style that nobody else uses. &gt; If I'd find a mistake in another library I'd be more than happy to have it corrected, regardless of how much code would break and will need to be adjusted. That's just evolution to a better future. Yes, it's important to fix problems like that. However, breaking the contract of your code is a very big deal. It's unrealistic to think that doing so won't have consequences. It's fine for small close sourced projects, but not large and/or open source projects. &gt; Is that how you'd fix any typo in your library? This would leave your library with a lot of legacy classes and structs. When would you remove them? I'd remove them as fast as I can. Depends. If it's an unstable version, I'd fix it. If I didn't notice the error until a stable release, then I'd simply leave it until the next major version bump. 
Apologies. Looked for /r/learncpp (similar to other languages) but couldn't find the cpp one.
And as you asked about the reason, this is under ‘/permissive-‘ so that it doesn’t break existing code that uses ‘not’ as a variable name. Also, note that if you elide the language specifier (de-de) from the docs URL it will come up in the proper locale. I always forget to do this too. 
Thank you. I’m going to try to implement this soon.
Have you tried shrinking empty lines? I prefer Allman style and I have VS set to shrink empty lines 25%. IMO this gives all the benefits of Allman while fitting more lines on screen.
Another possible option: https://github.com/graalvm/sulong "Sulong is a high-performance LLVM bitcode interpreter built on the GraalVM by Oracle Labs. Sulong is written in Java and uses the Truffle language implementation framework and Graal as a dynamic compiler. With Sulong you can execute C/C++, Fortran, and other programming languages that can be transformed to LLVM bitcode on Graal VM."
Awesome, haven't looked too deep yet, but I'm encouraged by your strict definition of scope. On my radar.
Thank you - couldn't have said it better.
It's the reason why I like to use `auto my_var = SomeType{10.0};` instead of `SomeType my_var(10.0);`.
I agree, but we also use `a` for local, `i` for input, `o` for output, and `io` for input/output. So instead of `it`, I have to write `aIt`, and their is lot of `aSomeTypeBecauseIDontDareToFindANameSinceItIsATemporaryVariableThatIJustNeedToPassToTheFunctionBellow`.
It's not usable in C++ because of classes (one extra level of indentation), but I love the justification of 8 spaces per indentation in linux source code + 80 char maximum: “If it doesn't fit, split your damn line!”.
For consuming packages, all you need is a text file. For writing your own package, then you do need a basic understanding of python. I've found it brain-dead simple honestly. I'm not sure what the third language would be though. It supports many other build systems than cmake. Ultimately, you can just copy the headers and binary libs in a predicatable folder and link to those however you want with whatever build system you prefer: [imports] bin, *.dll -&gt; ./bin # Copies all dll files from packages bin folder to my local "bin" folder lib, *.dylib* -&gt; ./bin # Copies all dylib files from packages lib folder to my local "bin" folder
Yes I understand why std::observer_ptr is a thing and it will improve matters for all those reasons (and more... It's easier to search for, too). What I have a problem with is telling people not to use raw pointers *today*, when their use is best practice for the reasons I gave. For C++20 I will update my practices. Though, that doesn't actually fix all the old code, whose meaning is left just as dependent upon context and documentation as it is now. Which is why it's important (and worthwhile) to use the current state of the art even when you know it could be improved upon. 
Since I've started using it (with the awesome bincrafters remote), I've been coding more and more. I get to do what I love, write code. NOT fight with my build system.
&gt; 1) The term 'observer_ptr' is wrong in so many ways. The technical term for this is "a travesty". What about having a pointer to something is "observing" it? As I argue elsewhere on this page, it should just be `std::ptr` - "a pointer". It's the least constrained pointer that doesn't have the possibility of undefined behavior in its default constructor. &gt; 2) references are not nullifiable in c++, but they can be null, if a pointer to null is dereferenced. (But of course, you can't dereference a null pointer.) I blinked at your statement for a moment but it's perfectly true. And we wonder why programmers of other languages call us mad.
OOP C++ in mid 90's view. by that standard, the most popular std::string should implement several interfaces with virtual method overrides.
If you are using MSVC you can do that anyway if you stick this somewhere in your source: #pragma comment (linker, "/subsystem:windows /ENTRY:mainCRTStartup") 
Why would you pronounce it P.T.R.? It isn't an acronym. 
Yes that threw me off too. First I saw it by name only, I thought, "where is the observer pattern?"
The third language is "whatever language your build system uses"; I guess if you use VS, then you don't have to worry, but then you're still not cross platform.
The code for it is tiny, and there's [an implementation](https://github.com/martinmoene/observer-ptr) backwards compatible all the way to C++98!. You could just drop it in your project and go. I brought `std::make_unique` into my projects for years before I could finally use C++14 - I know people who use `std::any` and even I think `std::variant` in C++11. 
I'm guessing what happened was that the smart pointer type was defined as something like this: template &lt;typename T&gt; class smart_ptr { private: T* m_pointer; public: smart_ptr(T*); operator T const* () const; }; When `T = char` and the ternary operator is invoked with: true : smart_ptr&lt;char&gt;(nullptr) : static_cast&lt;char const*&gt;(nullptr) there is an exact match with the `operator char const*` (invoked on the `if` argument). When it is invoked with: true : smart_ptr&lt;char&gt;(nullptr) : static_cast&lt;char*&gt;(nullptr) there is an exact match with the `smart_ptr(char*)` (invoked on the `else` argument). If `T` had been `const char` or if a non-const conversion operator had been defined, then there would have been ambiguities. As it was, there was a single exact match in both cases.
There is nothing C++ specific content... and it is kinda vague without telling something really new. 
https://www.reddit.com/r/cpp/comments/808c5z/bikeshedding_time_poll_for_a_new_name_for
Not really a fan of `ptr` to be honest, should be consistent with other pointer types and have a prefix explaining what kind of pointer it is. Personally, I disliked `observer_ptr` solely for reasons of length, so in my codebase I use it as `view_ptr`. I've heard some people object to this on the grounds that `string_view` and `array_view` don't allow mutation; this is a reasonable point but I still think it's all around the best name I've seen (in terms of a combination of meaning and length).
What do you mean by data-driven loop? Everything else being equal, taking up extra space just because the code is important doesn't make much sense to me.
It indicates possession though not ownership, which is fine. However what das possession mean in C++ terms?
Or `raw_ptr`.
`std::raw_ptr`. Everybody calls them raw pointers already.
You can still assign it to a `int* const` variable though, which makes it semantically different from `int&amp;`. I just searched one of my own projects and found something similar to: Foo* const ptr = condition ? get_ptr() : nullptr; I think that's a reasonable use case.
My own `optional&lt;T&gt;` only has a few constructors/assignment operators: default/copy/move, copy/move from `optional&lt;U&gt;` where `T` can be constructed from `U`, and a constructor that takes `nullopt` (and an `in_place` constructor for convenience when using emplace). The only way to create an `optional` without another optional is by using the factory function `auto some(T&amp;&amp;) -&gt; optional&lt;T&gt;`. Assignment is *replacement*: optional&lt;int&gt; i; i = some(42); replaces our empty optional with a filled one. Similarly: int i = 42; int j = 1; optional&lt;int&amp;&gt; o = some(i); // o = j; // nope, no such assignment operator o = some(j); replaces the reference. So how do you change the thing inside the optional? You unwrap it: o.unwrap() = 10; I see optional as a container with 0 or 1 element. You can't do `std::vector&lt;int&gt; v = 1;` so why should you be able to do that with an optional?
Except that it *isn't* a raw pointer, now is it? :P
Agreed. std::observer_ptr is just a confusing mess of a name. std::ptr all the way.
Possession is a concept that can be approximated by coding styles.
Well I hope you already know the language your build system uses. How would you build otherwise? That is what I mean by: &gt; Some sort of magical fairy that will read their mind and fix all their problems. That's not going to happen.
Stackless coroutines are impossible to implement efficiently without language support. That's because in the minimal case, a coroutine can be represented by a function pointer. Here's an example (assume the fake socket class `socket_t` is already registered with some multiplexing system and has it's own buffer): void receive_next(socket_t* socket) { error_code ec = co_await socket-&gt;async_receive(1500 /* buffer size */); if (ec) co_await handle_error(socket); else co_await send_response(socket); } You can transform this into a series of callbacks, none of which require state beside the address of the socket and the function to be called: void handle_receive(socket_t*); void handle_error(socket_t*); void send_response(socket_t*); void receive_next(socket_t* socket) { socket-&gt;async_receive(1500, &amp;handle_receive); } void handle_receive(socket_t* socket, error_code ec) { if (ec) dispatch(&amp;handle_error, socket); else dispatch(&amp;send_response, socket); } With native corountines, the compiler can transform the first example into the second one. It's actually is a little better with coroutines: the compiler can just generate jumps directly to the address within the function. So all that is needed is a pointer to `socket` for the argument and a pointer to where the function should resume running. Approximating coroutines without native support is a little worse. The implementation needs to create labels within the function wherever a call to `co_await` is made, and then it needs to keep track of which label to jump to when the coroutine is resumed. Boost.Asio provides stackless coroutines, and it does this with a switch (hidden behind a macro) and an `int` that needs to be kept alive (this approach poses some issues with stack-allocated variables). The whole point of this is that non-native coroutines are 25%-100% bigger than native ones: You go from a single function pointer (usually either 4 bytes or 8 bytes) to a function pointer plus an `int` (you could maybe get away with a short (2 bytes) but you probably going to use an int (4 bytes)). Stackless coroutines are nice because you can create tons of them without running out of memory. A 50% increase in their size undermines that. On the other hand, stackful coroutines keep an entire call stack around, which requires a ton of memory. There's not the same issue implementing them without native support. If you are allocating kilobytes or even megabytes per coroutine, keeping an extra int around to know where to resume it isn't a big deal.
I agree. I also thought it had something to do with the observer pattern. :S std::unowned_ptr looks alright and explicit enough for me.
If there's std::string_view which is a non owning view into a slice of "text" then how about using a word "view" instead of "observe"? Like we're viewing something pointed to, not observing. std::view_ptr? std::viewing_ptr? std::ptr_view? 
- Try to avoid names that cause spoken-out-loud ambiguity. "pass a pointer to that function". Did you mean std::ptr or T * ? - ptr doesn't imply any purpose. Are you going to use ptr interchangeably with T * ? Do they do the same thing? Are you going to use ptr to mean different things are different times? observer_ptr (yes, bad name) it meant to give meaning to a particular usage of pointers - the use where you are not the owner. It is not meant to be used as a generic pointer for all occasions. Whereas I would expect std::ptr to be as generic as a real pointer.
I disagree. It's not a general pointer, nor the "default" pointer, nor the least constrained pointer. Calling it `std::ptr` was as bad as calling what should have been ordered-map `std::map` and forcing the less-constrained `std::unordered_map` to have the long negation name.
There are other languages out there besides C++ that do a hell of a lot better than C++ does in the building and packaging department; many of them only require knowing one language. This is just more mental burden for very little gain. Give me something like OPAM, where I don't have to worry about turing completeness of my packaging layer, and I'd be happy.
It means that it is not guaranteed to be a valid pointer (it may be pointing to invalid memory). Also I believe beginners will avoid it just because it name.
+1. This is a case of missing wood for the trees - word 'pointer' implies observation semantics. To point at something is to observe it. `std::pointing_ptr` would be a synonym for `std::observing_ptr`. 
An observer looks at something without necessarily interacting with it. Seems legit. If you just call it ptr then it isn't really clear what type of pointer it is, where observer_ptr just says "here, look at this" 
Documentation of std::experimental::observer_ptr is talking all the time about "watched object". So why not just std::watch_ptr or std::watching_ptr?
I'm still proposing std::common_ptr; it's a simple, fairly descriptive name and doesn't clash with anything. If indeed it's just a wrapper to a regular pointer I don't see why the name should try to impose any usage over others.
I'd suggest `std::leaf_ptr`. * Not verbose * Avoids overly generic / authoritative (`std::ptr`) or scary (`std::dumb_ptr`, `std::unsafe_ptr`) terminology * Refers to a simple and well-known metaphor (the object graph). The ownership/borrowing metaphor *is* probably a better fit for C++, but `std::unowned_ptr` or `std::borrowed_ptr` are too verbose.
How about null_or_ptr?
This appears to be an upstream MinGW/GCC limitation (like the absence of filesystem support).
How about `std::aggregate_ptr` ?
Even if we ignore that rust's idea of borrowing is know to many non-rust programmers: Imho borrowing - independent of any programming language - implies that I'm temporarily taking something away and give it back later and that is not what's happening here.
Then how about `std::aggregate_ptr`
Exactly!
Still not clear enough, how about `std::smart_pointer_type_that_takes_no_ownership_responsibility_for_its_pointees`?
I called the one I did in my personal codebase many years ago "unsmart_ptr", found it funny.
[std::weak_ptr is a smart pointer that holds a non-owning ("weak") reference to an object that is managed by std::shared_ptr.](http://en.cppreference.com/w/cpp/memory/weak_ptr) Therefore it should be `std::weaker_ptr`
&gt; std::smart_pointer_type_that_takes_no_ownership_responsibility_for_its_pointees_but_im_not_like_my_brother_weak_ptr 
Because its an advertisment. Just look at that users post history
&gt; "pass a pointer to that function". Did you mean std::ptr or T * ? But actually isn't that almost a _good_ thing in a way? It makes you think "hey, using `std::ptr` makes sense here". Besides, I thought the "correct" way of pronouncing `ptr` was "putter". ;-) &gt; ptr doesn't imply any purpose It has no semantic purpose, other than to mean you won't be taking ownership. No one would use `ptr` to accidentally mean they're taking ownership, because if they're using `ptr` to begin with they're already in C++20 or later timeframe, and by then one would expect/hope that _taking_ ownership would be done with a `unique_ptr` or something like it. (no?) I mean if your code-base is starting to use `ptr`, wouldn't it only make sense it's using the current smart pointers too? The only reason `T*` would still be around in your code base is for legacy or C-code you don't want to change to C++20, in which case `ptr` doesn't apply anyway, because by definition it's code you don't want to change yet. Or at least that's what I've convinced myself in the past few days. Previously I was thinking `access_ptr` was the best, but since then numerous people advocated `ptr` and it's kinda grown on me.
Of all the suggestions I only found std::borrowed_ptr feasible. The rest is misleading or simply wrong.
Another ideas: plain_ptr ptr_wrapper
T* not being nulled on your behalf isn't a disadvantage; it's your choice to make. It is often better not to initially null pointers, because then you invite two-stage initialization. There are times when it is necessary and times when it is not. 
[removed]
Really? I had no idea that was necessary. I have always used int main() and it just worked.
`std::non_owning_ptr` seems to best convey the intent. I guess I'd be OK with `So, std::unowned_ptr`as a shorter alternative.
**Company:** [Morgan Stanley](https://ms.taleo.net/careersection/2/jobdetail.ftl?job=3106304) **Type:** Full Time. Associate to Vice President level. **Description:** We're hiring C++ Linux developers to join our low-latency trading development team. If you are excited about creating high performance code, working with open source, optimizing software for specialized hardware, and custom compilers - then we are interested to meet you! **Location:** London **Remote:** No **Visa Sponsorship:** No **Technologies:** Linux RedHat7, Clang/LLVM, GCC7, C++14, SolarFlare, Mellanox, FPGA, Informatica UME, Gemfire, Sphinx doc, Python3 **Contact:** https://ms.taleo.net/careersection/2/jobdetail.ftl?job=3106304
That's still too terse, I'm gonna need some type-traited templates for maximum comprehension
A key word there though is "necessarily". In common use, the word "observer" tends to emphasize that the observer is trying not to affect the system. With an observer_ptr though, it's quite possible that the stuff pointed to is going to be modified via that pointer. I wonder if perhaps the name "observer_ptr" was selected in a misguided attempt to discourage people from using such a pointer for the purposes of modification -- but what's happened is that people are using raw pointers instead, or alternatively people are using a misleading name for their pointers which implies that there is not modification of the data.
High standards are very important and they can make you improve over time. I tend to make sure ,y code doesn't get to complex, in order to save my time detecting errors. It's true that there are programs, such as checkmarx that helps with it but I prefer doing it on my own and it takes time most times. 
It's a typedef for `std::basic_smart_pointer_type_that_takes_some_ownership_responsibility_for_its_pointees&lt;std::responsibility_factor&lt;0&gt;, std::responsibility_traits&lt;std::responsibility_factor&lt;0&gt;&gt;&gt;`
In Qt land, this is called a QPointer.
Well, I think it's worth pointing out that using pointers to modify data is, from what I understand, considered bad practice, so having that convention in place makes sense because the cpp standards committee is trying to discourage bad practice. iirc the reasoning behind that is that using pointers to modify data results in data that may be used elsewhere by another pointer being modified. So what happens is that you point to the same data in a number of different places and then someone else points to it and modifies it, breaking the code everywhere else. 
Do you work at my company? The naming here is out of hand.
"Pass a standard pointer to that function"
`T*`
Why not have `owner` pointer and just enforce that the raw pointers are non-owning by default?
I'm not arguing that. But the industry has developed a lot of bad habits and it might be that future coders can learn better habits. While someone who has worked with and built those legacy systems using old practices and hacking to make things work without the best tool being available, they also have years of experience. If you're looking at new software developers and programmers however, then it makes sense that you want them to make use of the new tools that solve those problems, and learn better ways of doing things. My thoughts anyway. 
Not a class. Gotchya +1 for me
Wow, great project! I actually thought it would be an interesting project to implement zsync in C++, and understand the algorithms behind it. I find the rsync algorithms interesting, and I could have a use for this at work. Is HTTP transport mandatory or can a client/server be written using a custom transport?
seeing_ptr then, or seer_pointer
I got this one. Because it observes. +1 for me.
It's not just a simple wrapper in the sense that you can't use T* and std::observer_ptr interchangeably.
Borrow means something different though? Borrow sounds like you temporarily transfer ownership.
Why is it bad practice to modify something via a pointer?
`std::pointer`
Just like `this` is never null. In fact, GCC will remove checks for null this because it can never be null.
You mean a regular pointer? Or a library one? /s
Last time I built Qt, it was *full* of checks of `this != NULL`. Really harmed my confidence in their code.
that name sounds very similar to `weak_ptr`
I agree
Encode those formulas in a data structure. Run the tests, get the result. Iteration one would look like: using test_func = bool(*)(int x, int y); struct test { test_func f; char c; }; static const test tests[] = { {[](int x, int y){ return x+y&gt;=30; }, '.'}, {[](int x, int y){ return x+y&gt;=25; }, '/'}, {[](int x, int y){ return x+y&gt;=20; }, 'o'}, {[](int x, int y){ return x-3*y&gt;20; }, '|'}, {[](int x, int y){ return x-y&gt;0; }, '\\'}, {[](int x, int y){ return true; }, '_'}, }; for (auto t : tests) if (t.f(x,y)) return t.c; but the comparisons are still code here. struct test_func { int xf, yf; int limit; bool strict = false; bool operator()( int x, int y ) const { if (strict) return x*xf + y*yf &gt; limit; else return x*xf + y*yf &gt;= limit; } }; now we can have a table of the data that we use to decide between characters, instead of code. Maybe a bad plan. But I trust repeated data more than repeated code. static const test tests[] = { {{1,1,30}, '.'}, {{1,1,25}, '/'}, {{1,1,20}, 'o'}, {{1,-3,20,true}, '|'}, {{1,-1,0,true}, '\\'}, }; for (auto t : tests) if (t.f(x,y)) return t.c; return '_'; maybe worse. But in theory you can validate that table easier than code. 
I like std::watch_ptr
Well it's not interacting with the ownership, which probably the original motivation for the name
Many good ideas here, but most overlook the intention being: * non-owning * non-array * non-iterable The part about "not owning" is just a portion of what this type communicates.
Its purpose is to annotate the code, making it more self-documenting.
`std::indirection` `std::ref_ptr`
My impression was that it's truly zero overhead. Yes I agree if there is overhead people will not use it
So, I want to draw a comparison between OPAM and Conan, because OPAM has similar issues of having to support a lot of build systems, and being run on a legacy language that's been around for 20 years. Example OPAM file, from a library project: opam-version: "1.2" name: "pred" version: "0.0.1" maintainer: "Nicole Mazzuca &lt;npmazzuca@gmail.com&gt;" authors: [ "Nicole Mazzuca &lt;npmazzuca@gmail.com&gt;" ] license: "BSD" tags: [ ] build: [ ["jbuilder" "build" "-p" name "-j" jobs] ] depends: [ "jbuilder" {build} ] available: [ ocaml-version &gt;= "4.03" ] These are all easy to understand, and don't require me to screw around with python. They're also extremely self-explanatory. Now an example conan file (note; I'm still working it out, so I don't guarantee that this actually works) from conans import ConanFile, CMake, tools class AlgaeConan(ConanFile): name = "algae" version = "0.1" license = "MIT" url = "https://github.com/ubsan/algae" description = "Linear algebra library; mostly a personal project" settings = "os", "compiler", "build_type", "arch" options = {"shared": [True, False]} default_options = "shared=False" generators = "cmake" def source(self): self.run("git clone https://github.com/ubsan/algae.git") def build(self): cmake = CMake(self) cmake.configure(source_folder="source") cmake.build() def package(self): self.copy("*.h", dst="include", src="hello") self.copy("*hello.lib", dst="lib", keep_path=False) self.copy("*.dll", dst="bin", keep_path=False) self.copy("*.so", dst="lib", keep_path=False) self.copy("*.dylib", dst="lib", keep_path=False) self.copy("*.a", dst="lib", keep_path=False) def package_info(self): self.cpp_info.libs = ["algae"] What's all this stuff mean? Why do I need to tell conan about which directories to copy from and to, about how to clone it from github, about how to build it in such an odd way? Why can't I just write something similar to the OPAM file, which would be far less to screw up? What's this `copy` function doing, and why can't conan figure that out for me?
It depends what you are modifying and why, and whose code base it is. If it's all your, including what you are modifying then it shouldn't be an issue. If you're working on someone else's code base with a lot of other people, then it can cause problems because you can't know what someone else is doing with it unless you are working clisely with them, or you have extensive knowledge of the code base. Much like with addresses and pointing to an address; where someone else can modify or remove the memory at that address. Meaning it's generally not good practice to specifically point at memory by address in that case, bease you can't guarantee that someone won't modify or move it. It's not that you can't do it; you can do almost anything you want. It's just that it's not a good idea because it can result in bugs that could easily be avoided by not doing it. 
Viewing `T const&amp;` as a "const lvalue T" is the correct way to look at it, IMO. It might technically be a "`T const` lvalue", but thta's only because `T` lvalue has a conversion to `T const` lvalue - semantically, it's a read-only view of a `T`, NOT a view of a read-only `T`. West-const is both confusing to beginners, and creates a view of const lvalues that is syntactically, but not semantically, correct.
Only if one confuses property and possession. But I don't want to get philosophical...
Yes, only the pointer is null and it's illegal to dereference it. So any checks must be done on the pointer, not the reference. It's fair to assume that a T&amp; will always be something.
It's not necessarily bad practice to modify something via a pointer. However, with a new codebase that doesn't rely on legacy API's, it's quite likely that there is always something more appropriate to use than observer_ptr. My rough rule of thumb (as of a few years ago - I haven't been working with the latest C++ support lately) is that STL containers are better than pointers, actual values are nice if small and appropriate, unique_ptr is better than shared_ptr in cases unique_ptr is appropriate.. then shared is nice.. and there are lots of niche cases for other things, but that's less common. Following that kind of thinking, resource management is usually a breeze, code is shorter/simpler, and taking advantage of move semantics and widely supported operations upon STL types is relatively easy (eg. Plays well with stl algorithms), etc.
&gt; If indeed it's just a wrapper to a regular pointer Then I should be able to use it as an iterator over contiguous memory.
Implying that it's not _well done_?
Hussy pointer.
And if you want that you'll still have T* available.
What Java calls references are actually pointers. I don't know why they went with the terminology they did, but it's certainly confusing from a C++ point of view.
If you were making a tree data structure, your std::leaf_pointer may very well point to the node's parent.
What overhead?
It does not have any memory or runtime overhead. And I do have almost exactly the same thing in my code. 
It sounds like you might prefer weak_ptr for those uses?
It's not possible because the standard said so.
I wasn't disputing that at all in either reply. I'm not sure you got my point in the first reply.
Yeah, even if it _might_ do something useful with optimization disabled, it happily explodes the moment you have multiple inheritance: struct Base { void foo() { assert(this); } }; struct Derived : Foo, Base {}; Derived * p = nullptr; p-&gt;foo(); //Oops assert does not fire
&gt; Did you mean std::ptr or T * Unless there will be an implicit constructor (I sure hope not!) you will know soon enough.
One of the myriad manifestations of UB is appearing to work as expected.
So we settled for `std::pointer_mcpointface&lt;T&gt;`?
Well, the original comment didn't mention any classes either.
https://godbolt.org/g/Wv2B2M 🤔
`weak_ptr` can indeed play this role, to some extent. Of course the pointee has to be a `shared_ptr` in the first place, and not just any raw pointer.
I think it's fine to call it observer_ptr. Why? Think of it this way: if you delete it (the observer_ptr) the underlying (pointed) object won't be freed, so it's just observing the object and not controlling it. std::ptr would suggest you own the object and can completely control it (destroy it for example). 
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/810h6w/wanting_to_learn_c_and_programming_what_books_are/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
?: and IIFE also useful when the type doesn't have a default ctor.
The important point here is that you should never, ever, ever, ever check if a reference (or this) has the value of the null pointer. What could you possibly do that would be correct in that case? If you get to the point where a reference has the value of the null pointer your program is already borked. You can't fix it. Knowing how to fix it would imply that you knew about the bug somewhere else in your program that allowed the reference to contain the value of the null pointer. If you did know what that bug was you would simply fix that bug.
Not sure if you're a native English speaker, but 'observer' perfectly captures the semantics of that it is doing here. It's a pointer that merely observes another. It doesn't take part, it can't have any effect on what it's looking at, it's merely observing. Naming it ```std::ptr``` implies it acts exactly like a raw pointer, which is not the case.
Sure, and `QPointer`'s wrapped type has to be derived from `QObject` in the first place, and not just any raw type. And at least in Qt 4.8, the `QPointer`model used an actual mutex under the hood to perform the reference counting in a thread-safe way, as far as I can tell. Whereas shared_ptr uses an atomic increment/decrement to do so, at least in most implementations of the standard library. Of course whether this difference matters at all depends on the use-cases/users. (and I don't know if things changed in Qt 5.0)
I wonder why MinGW-w64 site still doesn't provide GCC 7.3.0 - https://sourceforge.net/projects/mingw-w64/files/
Is this recommended over mingw-w64?
Likely zero runtime overhead in optimised builds (this relies on optimisations which only an insane compiler wouldn't perform). But, there is debugging overhead. A non-optimised build has an extra indirection when accessing the pointer, making it slower, and also makes it more laborious to step through the code. As I understand it, this is important for games in particular. 
what does any of that have to do with modification via pointer? No one is talking about resource managment (to be more precise, the whole point of observer_ptr is that it doesn't manage resources). Btw.: The iterators you use to run STL algorithms on STL containers are conceptually identical to raw pointers (in some cases they even are native pointers) 
C++: The choice language of masochists.
"Pass an array to that function." "A c-style or std::array?" "std::array." "Oh okay, np. That was confusing wasn't it?" "Not really."
Do you pronounce the underscores with a sliding delay or a hum or something? Maybe a hand gesture? Do you make Capitals in CamelCase sound more harsh? (We tried this one in the past, it is kinda fun actually)
I like std::noptr :-x
Not if you are the one writing the API and you are discussing how the API should work. (That was the unobvious scenario I had in my head, as I spend lots of time designing APIs) Is there harm in an implicit constructor in this case? (I tend to _dislike_ implicit constructors, it shouldn't be the default, but it should be considered.)
It of course depends. If you have lots of mixed code, it could be quite annoying. "No, _this_ is an S T D colon colon array, this one takes a C array, this one takes a boost array, and this old code over here uses our old capital-A Array, why do we still have that class again?"
Back in the day with Delphi (Pascal) I abused this sort of thing by adding checks in methods for `self` (the `this` equivalent) being null. This allowed neat tricks like creating an immutable `List` class where a null pointer of type List would act exactly like an empty list. This way, a reference to a `List` was always a valid working reference even if it was null. You could call methods on the reference to check the list size, which would just return `0` if `self` was null, or methods to add a new element, which would return a new `List` object containing that element. The class would have all non-virtual methods, and be marked as "sealed" so that no other classes could descend from it. I don't recall if this was considered undefined behaviour in Delphi, but obviously it was a terrible hack regardless.
I didn't see your reply as my phone app didn't show it to me for whatever reason. I was just responding to the post it did show me. Now I've expanded the discussion I see yours. I also agree with it; I just disagree with the idea that people will do something else and ignore it is a good reason not to do it. From what I've seen a lot of programmers do things they shouldn't do ;) I think that's largely a result of moving from one language to another without adopting or necessarily even learning how the new one works. I.e. from java to C++. They just use the new language the same way they would use the old, and while it can be made to work, it's not necessarily how it should be done. 
Dereferencing the null pointer is the problem. The call to `inst.foo()` is perfectly valid.
As underscore and camel case effectively separate individual words, i guess yes, there is a slight pause between them. I don't know where you get the Idea of humming though - are you doing anything like that when reading normal English text? What exactly is your point? Or are you trying to raise a straw man?
Yes, I know the nullptr deref is the UB, but your wording is incorrect there.
I actually think this is close. It is a short name that doesn't quite tell you exactly what it is, but does give a hint. Maybe there's other words along these lines that might be even better.
I forgot the smiley face? 
Oops. I see now. My wording was ambiguous. I fixed it.
This is how I think of it as well, and one of the reasons I like east-const. The reference has a const view, the object itself is likely not const. This is probably why I do `const int x;` but `int const &amp; y = z;` The `x` really is const, the y is just a readonly view.
&gt; On the contrary, C++ affords the guarantee that a `T&amp;` *always* refers to a valid `T`. In the same sense that C++ guarantees memory safety, yes.
I guess I must be missing something here. Using a non-owning pointer is a gateway to having dangling pointers. Essentially the same as T*. Seems like you would want std::weak_ptr instead. (Implies non-ownership, but at the same time is safe.)
&gt; for very little gain hahahahahaha you made my day &lt;3
I'd like to vouch for std::pointer_mc_pointface from the poll. Just saying...
&gt; Java &gt; Outside of the C++ bubble, the term is more general (e.g. "call by reference"), it would be really confusing for Java to have called references pointers when they aren't really used like pointers at all. Actually java isn't a call by reference language either. Its a pass references by value language, sometimes called "call by sharing". All variables are values that either primitives or references to objects, these variables are copied around. The distinction is subtle between a true call by reference language and a call value language. Most of what we colloquially call The litmus test is "can you implement swap". http://javadude.com/articles/passbyvalue.htm
Does it support passing directives like `-DSOME_VAR=On` to all of the generated targets?
"very little gain" as opposed to a non-turing-complete configuration language, not as opposed to not having conan at all. conan is cool, but (just like a lot of C++ tooling) is hard to use for legacy reasons.
Why would you spell it out? That's a "stood" array, vs C array, vs boost array, vs "our" Array.
Just watch me int* _ptr = new int(4); int&amp; _ref = *_ptr; delete _ptr; Is garbage considered something?
But references in Java are not passed by reference :/
That always trips me up, if I have to use Java. It's weird.
I feel like this kind of pedantry isn't helpful and in fact to be blunt, I feel like this mindset indicates a lack of a broader understanding of programming language semantics. Furthermore I'd even say that it's a misunderstanding of C++'s own semantics as I shall justify below. Undefined behavior does not mean that something can not happen, it means that if it happens then the standard imposes no requirement on the behavior of the program from that point forward. The fact that the C++ standard imposes no requirement on program behavior does not mean that a particular compiler may not define the behavior instead. In fact the C++ standard explicitly states that implementations are welcome to translate undefined behavior "in a documented manner characteristic of the environment". Basically the primary reason undefined behavior is present in C++, as well as other languages, is because its type system does not allow it to verify certain properties of the program prior to its execution, and so rather than impose runtime checks to verify those properties which would impact performance, those properties are instead said to cause the behavior of the program to be undefined. That's all there is to it. The idea that undefined behavior implies that something is impossible is just an ill founded idea that has no justification in either the standard or any formal, academic literature on the topic of program semantics. It's basically a C++-ism that somehow undefined behavior is not possible or not permitted. Even C developers don't have these ideas about undefined behavior as C developers often leverage undefined behavior in their programs in a manner documented by their compiler so that the resulting program is well behaved (the most common ones involve various forms of type punning). So, can a reference be null in C++? Yes it can as C++'s type system is not expressive enough to forbid it. Is it undefined behavior? Yes it is. Now depending on your domain and what you use C++ for, maybe you don't care and you have the luxury of being a language lawyer by simply declaring that a reference can never be null by fiat, as if just declaring something makes it true. But if you're working in domains using C++ for safety critical systems, or financial applications where undefined behavior can result in actual consequences, then you quickly learn to drop that kind of attitude and adopt a more pragmatic approach to development where you take your programs and you run them through various profilers and memory debuggers etc... Then you'll see very quickly that references absolutely can be null, null pointers absolutely can be dereferenced, and that any non trivial application will most certainly exhibit undefined behavior.
That makes sense. Why can't there be a dynamic_bitset&lt;&gt;::const_iterator, though. Wouldn't that be ok? Mark Stankus
This is accurate. Whether you care about it or not, UB doesn't mean impossible. Most people, in most cases, should not bother checking for null references even though they are technically possible, because the idioms of references should prevent it from accidentally happening. A null this pointer is more likely but still so rare that checking for null this is essentially admitting that the code is terrible and broken but practically unfixable. For an example of UB as a feature, offsetof is often implemented as a technically-illegal null pointer dereference that never executes. Gcc made it a built-in, but Visual Studio still does it that way I think. 
std::view or std::thing_view would be more appropriate.
reference is just alias in c++. As an alias, it's not necessary to be a pointer underlying. The compiler may simply replace it with the actual object.
You can convert anything pointer-like in an array if you try hard enough.
I started the poll on strawpoll.com with the only ones that made sense to me (at the time), but posted in the reddit comments to put up whatever name made sense to you in the comments. (and many have!) Unfortunately there is no way to edit/modify strawpoll.com polls as far as I can tell. :( I will *not* be using it again in the future, because it gives misleading/skewed numbers I think, since it only offers those choices immediately.
I like the naming it `reference_ptr`, because it's like a `reference_wrapper` but with a pointer interface.
`offsetof` is required to work in the presence of overloaded `operator&amp;`. I don't think that can possibly be implemented without compiler built-in.
This is not a particularly interesting example, since branch probabilities won't do much for you here. The code is basically going to be the same regardless. Let's do the compiler's job for it a little and get a sense of what it might do here: for (int i = 0; i &lt; 100000; ++i) { if ((pattern &gt;&gt; (i % 8)) &amp; 0x1) ++v1; else ++v0; } First, let's unroll the loop (8 exactly divides 100,000, so this is easy): for (int i = 0; i &lt; 12500; ++i) { if ((pattern &gt;&gt; ((8 * i + 0) % 8)) &amp; 0x1) ++v1; else ++v0; if ((pattern &gt;&gt; ((8 * i + 1) % 8)) &amp; 0x1) ++v1; else ++v0; if ((pattern &gt;&gt; ((8 * i + 2) % 8)) &amp; 0x1) ++v1; else ++v0; if ((pattern &gt;&gt; ((8 * i + 3) % 8)) &amp; 0x1) ++v1; else ++v0; if ((pattern &gt;&gt; ((8 * i + 4) % 8)) &amp; 0x1) ++v1; else ++v0; if ((pattern &gt;&gt; ((8 * i + 5) % 8)) &amp; 0x1) ++v1; else ++v0; if ((pattern &gt;&gt; ((8 * i + 6) % 8)) &amp; 0x1) ++v1; else ++v0; if ((pattern &gt;&gt; ((8 * i + 7) % 8)) &amp; 0x1) ++v1; else ++v0; } Now we can simplify `(8 * i + k) % 8` to just `k`: for (int i = 0; i &lt; 12500; ++i) { if ((pattern &gt;&gt; 0) &amp; 0x1) ++v1; else ++v0; if ((pattern &gt;&gt; 1) &amp; 0x1) ++v1; else ++v0; if ((pattern &gt;&gt; 2) &amp; 0x1) ++v1; else ++v0; if ((pattern &gt;&gt; 3) &amp; 0x1) ++v1; else ++v0; if ((pattern &gt;&gt; 4) &amp; 0x1) ++v1; else ++v0; if ((pattern &gt;&gt; 5) &amp; 0x1) ++v1; else ++v0; if ((pattern &gt;&gt; 6) &amp; 0x1) ++v1; else ++v0; if ((pattern &gt;&gt; 7) &amp; 0x1) ++v1; else ++v0; } Next, we can note that since `pattern = 0b01100011`, we can calculate these `if` conditions now: for (int i = 0; i &lt; 12500; ++i) { if (1) ++v1; else ++v0; if (1) ++v1; else ++v0; if (0) ++v1; else ++v0; if (0) ++v1; else ++v0; if (0) ++v1; else ++v0; if (1) ++v1; else ++v0; if (1) ++v1; else ++v0; if (0) ++v1; else ++v0; } Now we can eliminate the if statements altogether: for (int i = 0; i &lt; 12500; ++i) { ++v1; ++v1; ++v0; ++v0; ++v0; ++v1; ++v1; ++v0; } Since `v0` and `v1` are volatile, we can't combine the additions (`++x, ++x;` is difference from `x += 2` when `x` is `volatile int`). This is as far as the compiler can go. The point is that there are no branches to predict in your code. (I haven't confirmed that the compiler does this, but I'd bet it does.)
[No explosions here](https://godbolt.org/g/SBeqxp). Sure, C++ has corners and edge cases, but null references aren't one of them.
It certainly does seem that way.
Thanks for the well thought-out response. It's welcome after some of the other commentaries here. &gt; Onto my justification; undefined behavior does not mean that something can not happen, it means that if it happens then the standard imposes no requirement on the behavior of the program from that point forward. I should clarify that I don't say it *can't* happen so much as it's difficult/impossible/not useful to talk about it happening in practice. (Barring, as you mention, implementations that define a null-reference.) Regarding C programmers relying on implementation of UB: For any case I can think of, they use implementation-defined behavior (like GCC's `-fwrapv`), or the implementations have succumbed to people doing to wrong thing for too long and needing to support legacy. C defines proper ways to do type punning, but too many people do it incorrectly. &gt; Now depending on your domain and what you use C++ for, maybe you don't care and you have the luxury of being a language lawyer by simply declaring that a reference can never be null by fiat, as if just declaring something makes it true. You don't need to be a pedant to enjoy that `T&amp;` is non-null. Checking that a reference is non-null *isn't even possible* in some cases. If define a `void foo(Type&amp; t) {}` how would you check that the `t` someone gave me is non-null? If I, as a library writer, have to worry about my clients dereferencing null pointers, how am I supposed to get any work done? That would be akin to worrying that `2 + 2` might add up to `5`. If I can assume nothing then all the world is anarchy and we're living in a false vacuum that's going to evaporate us all into esoteric matter at any moment.
ummm... but the current `std::experimental::observer_ptr`_can_ affect what it's looking at. It is not a pointer to const. For example it is free to invoke non-const methods on the pointed-to object. If you are given an `observer_ptr&lt;int&gt; p`, you can do `*p = 42`, and the int's value changes to 42. That's not really "observing".
For those thinking "if not modifying a memory area, why de-referencing a null object create an undefined behaviour?" one example would be the virtual functions. In memory layout of an object, the virtual functions are kept as pointers. When you are dereferencing a null-ptr and call a virtual function, you would jump to a random location in memory and execute what ever data was residing there and probably get a segmentation-fault. And it is hard to debug this because you won't get error immediately when UB occurs but at some point during execution of garbage code.
Oh ok I didn't know, my bad. I'd have to agree that its poorly named then.
Really? https://onlinegdb.com/SJ1WvWHdM 
Sir you are full of... yup, that's correct ;-) https://onlinegdb.com/SJ1WvWHdM 
AFAIK, throwing from `extern "C"` functions is well-defined behavior. The trouble comes when the caller has no knowledge of C++ exceptions.
Is dereferencing a nullptr itself already undefined, or *reading* from a dereferenced nullptr?
I hope I **never** see this in production, but since Foo:Bar() has no member access, **this** is practically 0x0. struct Foo { void Bar() { printf("Hello %p!", this); } }; int main() { Foo* f = nullptr; f-&gt;Bar(); return 0; } 
*dereferencing* is undefined. By default, Asan works by checking reads. Your code never actually reads from `nullptr`, so Asan doesn't catch it.
&gt; Basically the primary reason undefined behavior is present in C++, as well as other languages, is because its type system does not allow it to verify certain properties of the program prior to its execution, and so rather than impose runtime checks to verify those properties which would impact performance, those properties are instead said to cause the behavior of the program to be undefined. I was actually wondering why UB even exists and isn't treated as an error because it's such a pain, but unfortunately this makes sense.
&gt; C++ type system is not expressive enough to forbid it. I take issue. It's rather, C++ type system is permissive enough to allow it. A pointer type is (obviously), "null or a reference to something". It is mighty useful to go from/to a pointer to/from a reference. But the "null" part then has to be made right. How is the type system supposed to express this, in your opinion? Optional&lt;t&gt;? That just changes the form of the check. Functional style? That changes the form of the code completely, but *still* just changes the form of the check...
I don't understand what you're saying. There's a segfault there, and doesn't that imply UB?
Actually, C++ says that your program was dead at the `*` on the second line. You never created `ref`, you just didn't realized you were dead sooner.
&gt; C++ affords the guarantee that a T&amp; always refers to a valid T Not at all, references can dangle the same way pointers can. A* a = new A; A&amp; a_ref = *a; delete a; // both a and a_ref dangle at this point
Well, it's implementation-defined ordering, but I guess `std::not_meaningfully_ordered_for_any_expected_use_case_map` was too long. :p
If his example is taken literally, I think any ternary operator problems pale in comparison to the bad choices he's already made.
Exactly: in terms of the Standard, a reference is not even an object, i.e., the compiler doesn't need to allocate space for it. A reference to X *is* X by another name. No indirection. References are to pointers what hard links are to soft links.
For greater effect. When it gets so confusing you need to spell it out for someone to understand what's going on. Normally I say "standard".
Well, you also can't abandon raw pointers if that's the way to access memory mapped hardware registers...
[Are you sure about that?](https://godbolt.org/g/aQvrXF)
The compiler will likely optimize that check out.
Depends whether you like my choice of components, frequency of updating, and simplicity of packaging.
The problem isn't that there is no meaningful action you can take. The problem is that you have told the language that you don't feel like handling the possibility that the pointer is null. 
As I understand it, `std::auto_ptr` was an attempt to implement `std::unique_ptr` before move semantics existed. Without move semantics, the implementation was a mild disaster.
How about `std::tee_star`?
Usually that would be immediately, as it is very unlikely that you would jump into a valid executable page of memory.
It is about the 'dereferencing the null pointer' comment, it might be misleading. https://stackoverflow.com/questions/4955198/what-does-dereferencing-a-pointer-mean Dereferencing a pointer is about accessing the contents, but in this case, e.g. "int &amp;lvalue = *rvalue;" it is just about taking a reference to the location pointed to, there is not an actual pointer dereferencing, more like a pointer to reference translation (not a lawful C++ standard term but just to put it in a simple way). The actual memory access comes when using the reference as you can see in the example. What happened when you use it might be UB, but in practical terms function returning NULLs or nullptr are still common (e.g. legacy functions returning them as "no result" values). IMO, the "-Waddress" is giving you a nice default, "the compiler assumes...", but if I'd be mixing up pointers (that might be nullptr/NULL or in invalid memory space) with references, I'd rather better be prepared... which might be as simple as checking the returned pointer from a function before translating it into a reference, then the compiler assumption is right again.
I think your example needs `auto&amp;` but otherwise yeah, happens well too often. IIRC dangling pointers and references are UB so it's not a valid C++ program from the standards point of view. 
It is theoretically possible that the runtime may not map the virtual memory address 0x0 to anywhere useful, and thus attempts to read from it may cause a trap causing your program to crash. It's a valid result of invoking Undefined Behaviour. It's also perfectly valid for this behaviour to be different on a release build vs. debug build. It's UB. The Standard doesn't dictate what's going to happen. (The Standard does disavow responsibility for anything your program does since that UB could be _anything_ as far as the Standard is concerned.)
 (void*) It was an array all along!
*super pedantic language lawyer voice*: Technically the indirection isn't UB, but forming the reference or doing an lvalue-to-rvalue conversion would be. See this CWG issue: http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232
Wow. TIL. Funnily enough, mere minutes ago I learned of [`std::to_address()`](http://en.cppreference.com/w/cpp/memory/to_address) to address those use cases.
&gt; References are no different from variables... you can write east or west const but the meaning is always the same. Consider: #include &lt;type_traits&gt; template &lt;class T&gt; using make_const = const T; static_assert(std::is_same&lt;const int &amp;, make_const&lt;int &amp;&gt;&gt;::value, ""); This will fail, because the const is not applied to the left, despite being written so. Now consider: #include &lt;type_traits&gt; template &lt;class T&gt; using make_const = T const; static_assert(std::is_same&lt;int &amp;, make_const&lt;int &amp;&gt;&gt;::value, ""); This succeeds, because the const is applied to the right (and then dissolves because references have an implicit const to the right. This is much more visible with pointers, but the same happens with references.)
Good point. But who wants provided_ptr? :)
I dunno why you feel a need to rant about this. It feels like you miss the point of people saying "references can be null". They statement is not meant as a reason for building your code around it and do null checks for references, that doesn't make sense indeed and I've hardly ever seen anyone do that. The point is more that cpp had two dudes to it: the standard, and the implementations. When you work with the implementation side in practice, it certainly happens that references become null accidentally. It's commonly seen when debugging. In that sense the "references can be null"is just a pragmatic reply to people who seem to think that by using references, you're water proof against null dereferencing errors which is false. That's all
That was my first thought in the other thread, and I will be dissapointed if it doesn't make it.
Ah, that makes sense when legacy code base maintance is important (which probably is for MS itself)
Thanks for taking interest! ;) &gt; I find the rsync algorithms interesting Indeed! This library is built on same core idea. Except that in zinc case client does rolling checksum over the local file where with rsync server does rolling checksum. I am not sure how core much algorithm is similar to rsync or zsync as source code of these projects isnt straightforward to follow and i did not invest time into studying them in depth. &gt; Is HTTP transport mandatory or can a client/server be written using a custom transport? Library does not impose any constraints on to user other than hashing algorithms. Even they could be made pluggable though. You may use any serialization method as `zinc::get_block_checksums()` returns a vector of checksums for remote file and `zinc::get_differences_delta()` takes same vector of hashes. No assumptions on serialization. Likewise `zinc::patch_file()` takes a callback for fetching remote data at specified file position. This callback can use any transport you like. Http was used as a most convenient update hosting example. After all whole point of the library is to lift any constraints on update server so we can just use dumb data store like S3 for delivering updates. If you end up using this and finding it useful drop me a note some time. I would love to know in what projects people apply this code :)
Just saying: A pointer can be non-null and still not point to something (dangling ptr)
I think tweaking your statement a bit could lead to much less confusion and arguments. Instead of discussing whether or not references can be null, which means different things to different people, better be more specific: a) There is no LEGAL way to create a null reference b) There is no reliable way to check if a reference is null from inside the c++ program. 
&gt; Of course, all of C++'s guarantees have a caveat: Every guarantee goes out the window if any part of a program contains undefined behavior. Exactly true, though it's still useful to have diagnosis-and-debugging intuitions for what can cause certain common patterns of symptoms - such as those (annoyingly common) cases where in practice you ended up with a null reference. &gt;there is no use in worrying if a client has dereferenced a null pointer in order to fulfill a reference parameter on your API. There's no meaningful action that you can take That's not simply not true. First off, particular implementations can guarantee behavior that the standard doesn't. Taking the address from a reference and testing it for null is guaranteed to always fail according to the principle that a reference is never null, so a compiler can legitimately assume that check always fails, but it doesn't have to. Obviously - by even having a null reference you're in nasal demon territory - the compiler can do anything it likes. It can *even* do the nice thing and ensure that your sanity checks do their job, since presumably they were written for a reason. In any case when you take the address from a reference without null-checking, and pass that pointer to a C API, that may well have null checks. 
The standard doesn't say it's not possible. It says it's UB, which means it _is_ possible. Amongst many other things. :p
&gt; undefined behavior does not mean that something can not happen, it means that if it happens then the standard imposes no requirement on the behavior of the program from that point forward. To add to the pedantry: Not only doesn't the standard impose any requirements from that point forward, it doesn't even impose any requirements from that point backwards. The reason is essentially, that thanks to optimizations, the statement invoking UB can actually have effects before it's logical position in the program. E.g. if a compiler can prove that a certain expression will always result in UB, it can assume that the branch leading to that expression will never be taken and hence remove all instructions (even when they have side effects like a printf) in that branch and the check that would cause the branch to be taken.
I misremembered - it was actually a stack reference that became null as the object was swapped out, this was not nullptr, but it might as well have been as it no longer existed. [reference](http://rextester.com/XNC38065)
I just had to scroll up to see if I was in r/programming humor as I was laughing so hard at these names. Fine work, handshakes and high-fives all around.
This would be the name in Objective C.
I agree wholeheartedly, but `like "this" is never "null"` is just not accurate statement. It won't be in valid program, but it is very easy for a programmer to make mistake (much easier than to with `reinterpret_cast&lt;&gt;()` due to the fact how often you work on pointers) and get himself to a point where it *is* `null`. It's better to know that something like this "can" happen then be oblivious. Of course it's good to know that GCC optimizes it away too!
Apparently. Or I s just too tired when reading it ;) My apologies.
std::just_looking_ptr or std::look_but_no_touch_ptr
The original proposal was even titled "The dumbest smart pointer" or something like that
You cannot modify an object through a view, but you can through an `observer_ptr`
From a perspective of a person who has no real experience with either OPAM or conan the later is not too bad. Both have some options I don't understand without reading the manual. Conan file is longer that's true but it's because it does more - it fetches sources from github, runs CMake. OPRAM seems to do a local build only. The python is a bit annoying for windows devs because many of them don't have it installed but I don't think it's such a big deal - if I see conan is useful I will gladly install it. The right question is if the conan experience can be further improved. For example to use defaults such as for the settings = "os", "compiler", "build_type", "arch" line. Another great idea is to install the files to default folders bin/lib/include automatically as you mentioned. In most cases the defaults will be probably enough
`foreign_ptr` As from another country and mostly uknown, yet a pointer that you can work with. The downside is that the word is a bit difficult for non english (foreign) speakers. 
Problem is, both view and observer imply const access.
Easy. I store a reference to an object that gets deleted later. I think when people refer to the reference being "null," I always interpreted it in the sense of whether the reference points to a valid object (and also, the object it is supposed to point to).
This works, thank you.
Personally, I like the idea of removing it and just going with `std::optional&lt;T*&gt;`...
&gt; by emitting code, all compilers do ultimately define some kind of behavior. That is like relying on a dice throw returning 4 because that was your result when you tested. Of course compilers should give repeatable results when you give the exact same inputs, which doesn't help much unless your code suffers some extreme form of DRY violation. &gt; If the null check is stripped out, as compilers are permitted to do, at least that's no harm done. Except cluttering up code and confusing novices that see a NULL and think its valid. 
Why, there is `std::reference_wrapper` and we use it all the time (actually we don't).
&gt; It's not possible because the standard said so. And yet I have several times in the past sat in a debugger/used print statements and seen that `this` was in fact null. Yes, each time it was due to someone's undefined behavior, basically dereferencing null, and yes, each time it was because I was debugging someone's bug, but the fact is that I have observed `this` to be `nullptr`. What about, "The standard says that _in the absence of undefined behavior,_ `this` cannot be null"? I think we can all agree on that.
Correct, which is why one wouldn't do `ptr &lt;int&gt;c, d;`
&gt; it should just be std::ptr Totally agreed. &gt; I blinked at your statement for a moment but it's perfectly true. I've seen the above reaction so many times.
&gt; That is like relying on a dice throw returning 4 because that was your result when you tested. No, because the choices that the compiler makes can be documented and maintained as a matter of policy. In this case it's not relying on anything other than what the standard defines. The QT check itself has no undefined behavior - either the compiler will omit the nullcheck based on the proof that the pointer should never be null, or it will emit code as if the null case were valid (as I said, very likely for a debug build). Both are valid. Both are useful. Given that compilers provide options for debug builds, and do so for valid reasons, both are useful and usually deliberately supported. Unless you're still looking at there being two ways that nullness is somehow asserted, I don't see how DRY is relevant. And since we know as a practical fact that one of those ways is extremely fragile and unreliable in practice - that despite it being undefined behavior, null references do sometimes happen, and methods are sometimes called through those null references - I don't really think having debug checks that work in practice for debug builds counts as repeating yourself. Actually, AFAIK the C++ standard doesn't define that C++ developers make no mistakes. &gt; Except cluttering up code and confusing novices that see a NULL and think its valid. The "clutter" is a trade-off - I personally wouldn't include it in my code, but my code isn't Qt and isn't used by huge numbers of developers with a huge range of levels of ability. As for newbies reading code - that's always a concern. Way back when I was learning C, I saw include guards in standard libraries using identifiers like `_THIS` and didn't realise they were reserved for language/library implementers, I just assumed it was a standard convention for include guards. That misunderstanding actually survived quite a while before I was corrected. If it was the primary job of source code to teach programmers how to use the language, C and C++ would be very different languages. But in practice, that's another trade-off. It's nice if the code we use is a good example of everyday programming style, but it's also nice if that code detects and reports the errors we make while using it. And both apply particularly to newbie developers. It's very rare to have one perfect balance that's ideal for all contexts. See, for example, [this section](http://legacy.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds) of Python PEP 8. Wording is unfortunate, but the point is valid. 
www.cppreference.com or www.cplusplus.com They are your friends. I know reading documentation is exhausting, but after that you will be well versed in how it all works. Just read up the specific page for a thing if you are in doubt. For more info, usually some of the first 10 links on google search are good blogs which describe the functionality. 
it would definitely help if you would actually literally make a point...
Seems like you don't have programming experience. C++ is very hard language for beginners. I recommend that you start with something simpler like python and then when you grasp the concepts of programming you can advance to C++
Just because it's semantically different doesn't mean it's not a code smell.
&gt; The standard says that in the absence of undefined behavior everything the standard says is considered from the point of view of absence of UB
`std::map` is very natural; `std::unordered_map` should perhaps have been called `std::hash_table`
&gt; Code is portable when it works on all platforms. C++ code is portable when it targets the abstract machine outlined in the language standard; actual platforms are incidental. &gt; There's nothing non-portable about checking for null where it "can't" happen. That in itself is fully defined behavior. Sure; `if (true) { ... }` is well-defined, too, but equally as pointless if you're trying to do anything sensical.
&gt; and then having my colleagues tell me that this was not possible... ... are your colleagues high-schoolers ? that's, like, basic if you ever tried to decompile a function
In case you're being serious: `operator""` is quite clearly the only thing in that namespace – what exactly is the point, other than dogma..?
&gt; why should i do it trying to learn a language without any idea of project is a bad idea. Try to create a software, any software, a calculator, a software that puts text in capitals for instance.
One more thought about the implicit vs. explicit constructor. I *think* the biggest benefit of using a dumb-smart pointer is that it is a vocabulary type, i.e. expresses the intent. An implicit constructor makes the usage of it less visible, so that takes away from the benefit.
This is one of the problems i have with std::reference_wrapper, useful type, incredibly verbose to use std::vector&lt;std::reference_wrapper&lt;int&gt;&gt; is just silly
I love a variant of Hungarian notation. The problem with Hungarian notation is that you can have abbreviations for what the variable is used for, that is **bad** The prefix should be used for variable type in a general way Sample: int iName; int16_t iName; int64_t iName; unsigned int uName; uint64_t uName, size_t uName; The prefix is used to make the variable readable 
Not the same thing, as `true` is extremely unlikely to turn out to be `false` in practice, whereas dereferencing null pointers is obviously one of those bad things that happens. Although some people do use `if (true)` vs. `if (false)` as a way to easily enable/disable a chunk of code, similar to commenting code out. I'm not one of them, I don't know reasons, but I don't believe what I do is the one and only true way to program so... 
learning 2 languages is not a waste of time. Actually as a programmer you'd want to know lots of languages to be able to choose the right tool for the job. To learn game development I would recommend Lua+[https://love2d.org/](LÖVE) and Python+[https://www.pygame.org](PyGame) Recently on /r/programming there was a great article about game programming and Lua. https://np.reddit.com/r/programming/comments/7xip6o/i_wrote_a_tutorial_on_how_to_make_a_complete_game
&gt; Hopefully nobody disagrees when I say that C++ is a language that prioritizes efficiency and performance above pretty much everything else - including user-friendliness, ease of use, etc. I guess that's true, but I've always seen that as a result of legacy buildup and new insights into what works and what doesn't. Working at a reasonably sized C++ business where we rarely need the raw speed that C++ provides, I welcome all changes towards ease of use and user-friendliness. I'm even willing to sacrifice performance, although rust is showing us that the two can go hand in hand.
&gt; dangling pointers and references are UB No they aren't; that would prevent you from ever freeing an object. Using them is, though.
Some link to the OP ccpcon 2014 video about DOD. That guy had very different approach.
chill dude 
If you are into game development and C++, I would recommend that you start off with a simple, yet doable project. And what better way to learn a language than building a game in it :) If you really want to stick with C++, give [SDL2](https://www.libsdl.org) a try. Make Pong in it. Make Break-out. You would do it once with lots of mistakes, but the knowledge you would get is just priceless. Then do the projects again and see where you can improve! Here is a cool starting point: [intro to game programming with SDL](http://lazyfoo.net/tutorials/SDL/) 
You just posted straight against parent post. Did you even read it?
`hash_*` names were thrown out for historical reasons.
What's the origin and reasons for spelling "stood"?
`unsmart_ptr`? `plain_ptr`?
I really do not understand this post. References in c++ are not nullable, but they can be null if created from a null pointer. What does it matter if it is a result of undefined behavior or not? in non-trivial programs, a pointer may result in being null and then dereferenced, creating null references. A type system has non-nullable references only it statically makes it impossible to have null references, and C++ does not fit in this category. 
Dude, your post horizontal length breaks RES.
Dereferencing the null pointer returns a reference though. 
Aren't regular raw pointers not very difficult? I get it, smart pointers are slightly easier to deal with, but good lord it feels like this shit is going way overboard. I just don't see how it's so difficult to initialize your variables and delete your pointers. And if you keep running into trouble, just write a RAII wrapper for whatever you're doing. I'm fairly new to C++, and I haven't worked with large projects with it yet, so I must be missing something, because I really don't get all this hoopla about pointers being difficult for people. I like the unique/shared/weak wrappers, I get the reason for them and it's nice to have some official syntax to do that... but I kind of feel like that's more than enough.
Do you know Java? It would be easier starting there IMO
`&amp;inst == nullptr` might be meaningful if `inst` overloads `operator&amp;`. Actually I have worked with smart pointer classes that do do this in the past; and `&amp;inst` actually yields the address of the wrapped pointer, or null if it was not currently wrapping a pointer.
Large legacy codebases are always full of awful code because they were written in days where standard compliance was not so good (or even before the first C++ Standard came out in some cases), and they had to do a bunch of arcane rubbish to have the product work on the junk compilers that were out there. Nowdays people are happier saying "If it works in gcc, clang and msvc then that's the end of the story, if other compiler X fails then too bad"
Indeed. Derefencing that, however, is the same as with null :-).
If you want something that gets you used to a syntax similar to the C++ one, consider Squirrel instead of Lua: http://www.squirrel-lang.org/ Lua is more popular, but I know many game devs (including myself XD) that can't stand its syntax. 
Your code is valid; `auto` deduces to `B` (not `B&amp;`) and a `B` is copy-constructed from the `b` member of the temporary returned by `get_a()` -- whose lifetime lasts for the entire full-expression. 
The discussion you link to is from the year 2000; in the current wording (C++17) there is much less ambiguity: &gt;The unary `*` operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points. Clearly this sentence only defines the behaviour of unary `*` for the cast of the operand pointing to an object or function. There is no other definition of unary `*` in the standard, so it is undefined by omission what happens if it is applied to something other than a pointer to an object or function.
The linked site is pretty confusing. **MinGW** and **MinGW-w64** are *different projects*. However the site says things such as &gt;MinGW's official website mingw-w64.org which is patently false. I'm sure we'd all like to *pretend* that mingw-w64 is the only one of the two projects that exists , but IMO this sort of conflation doesn't help anyone. 
&gt; If the null check is stripped out, as compilers are permitted to do, at least that's no harm done Except for the case when a user sees the check and thinks that their problem is not related to null-pointer dereferencing because the code looks like it would have caught it but doesn't. Given that a significant portion of the programmers who call methods on null pointers are likely to be relatively new to C++, this check can do more harm than good.
Your link isn't working for me, but if you install via either the official installer, or MSYS2 package manager, you get 7.3.0 . 
&gt; This appears to be an upstream MinGW/GCC limitation (like the absence of filesystem support). MinGW-w64 supports Filesystem TS as `std::experimental::filesystem`, this has a few differences from C++17 filesystem. g++ doesn't get `std::filesystem` until version 8. (Latest MinGW-w64 build I'm aware of is 7.3.0)
If you throw an exception or fail an assertion then you would figure out the source of the code by inspecting the call stack. So I don't think you would be unable to locate a bug that way and that is not the reason not to use those checks. The problem with checking whether unnullable objects are null is that the compiler will happily but silently remove the checks so you get absolutely no information if the checks didn't fire.
&gt; That is like relying on a dice throw returning 4 because that was your result when you tested. I think this is more like making sure a dice roll is somewhere between 1 and 6 because you don't know if the compiler is a big pen&amp;paper fan.
I have the perfect name, now! `std::smart_but_dumb_ptr` Or maybe `std::your_brain_gets_smart_but_your_head_gets_dumb_ptr` Alternatively `std::all_star_ptr`
How does a member function having no member access imply this being 0x0? int main() { Foo* f = nullptr; f-&gt;Bar(); // UB here return 0; } I believe that because compiler can expect `f` not to be `nullptr`, it can omit the assignment of `nullptr` to `f` and leave any random value there. Or it may just wipe out your disk.
Eeeeh, not really. References in C++ cannot be reassigned but you can still assign to the object referred by the reference. This isn't allowed in Java: final int b = 1; b = 2; But the "equivalent" in C++ is just fine: int a = 1; int&amp; b = a; b = 2 `final` is closer to C++'s `const`.
I'm having a hard time understanding the root difference between the observer_ptr and a weak_ptr. In any case, you do not own nor can keep alive the object (unless you get the shared_ptr from the weak_ptr) 
Is it safe to throw in `extern "C"` function that is called from C if that C function was called from C++ that catches the exception?
I don't think that doing comparison for `int` is valid because reference semantics doesn't work for primitive types in Java. If you do comparison for `class` it would work in C++ because of existence `operator=` of which there is no strict equivalent in Java, but if object has some mutating method let's say `copyFrom` its contents would change with `final` reference in exactly the same manner as with `operator=` `final` for non-primitive types makes chaning object reference pointing to to be allowed only in constructor, and this I think is very similar to how reference in C++ behaves. &gt; final is closer to C++'s const With non-primitive types it's similar to `const` but not with pointer to `const`, but with `const` pointer which is very similar to reference in regard to lack of ability to change the object its pointing to.
To the eyes of the compiler, UB never happen, so any checks related to null this will be removed ;)
I can see this being useful for startups or new c++ developers who want to play with threads. Thing is, how can this plugin detect runtimes of the libraries being called? How could it detect runtimes dependent on dynamic sizes? You're claiming to help with performance. Does your plugin generate a thread pool code? All I really see on your website is a syntax checker for race conditions.
I have this problem with a lot of things in C++. Why is `std::string_view`, a useful type, so long? Why is `std::reference_wrapper`, another useful type, so long? Why is `std::mem_fn`, a very rarely (in my experience) used function, so short? Why is `std::map`, the slow map, shorter than `std::unordered_map`, the fast map? Why is `std::list`, which should almost never be used, shorter than `std::vector`, which is most of the time the right choice of container? I know some of these are due to legacy, but still.
&gt; Well, I think it's worth pointing out that using pointers to modify data is, from what I understand, considered bad practice, Why? If you have a non-const, nullable pointer, why wouldn't you want to change data it points to?
Whenever C++ (the standard) guarantees anything, there is always the implicit (sometimes mentioned explicitly) assumption that the program doesn't have undefined behaviour. C++ guarantees that a reference is never null as long as there is no undefined behaviour. If there is undefined behaviour, the C++ doesn't guarantee anything about the behaviour of your program. The program that you show has undefined behaviour.
I dunno, if someone wants to use it and they get a compiler error then we need to ensure that the error is 500 pages long. Better nest it 50 times.
 std::you_are_the_weakest_ptr_goodbye
Each time someone tells me that C++ is portable it reminds me of this anecdote: https://youtu.be/3-UgraLNC2g?t=5m40s After I've seen C++ done in Opera browser I never gonna do bigger work in that language again.
I was using GCC 7.3.0 from Msys2 (they added it the day it was released!), I didn't know it was also available through the official installer.
I disagree, the reality is that "this is never null". As the poster you are replying to showed in his code, the compiler will assume that "this is never null", so code that does ```if (this) { /* blah */ }``` won't be executed.
I don't know why headers aren't generated by the build system. In the source file, we could have public and private section (public == extract the prototype in the .hpp).
Why not std::we_named_it_for_the_concept_even_though_its_always_going_to_be_a_hash_map :p
It's still very different, even for an object that doesn't define `operator=`(explicitely). Take this for example: // struct B {}; B b; B&amp; bref = b; // okay bref = B{}; // okay With const point this wouldn't work: B b; B* const bptr = &amp; b; // okay bptr = new B{}; // error And that mirrors Java's `final` behavior. Basically: assigning to a C++ reference means you assign to the object referred to. Assigning to a Java variable means you assign to the variable (which final prohibits). That's a fundamental difference which is why I think they're not very similar. On the other hand, a const pointer is practically equivalent to a Java final variable. At least I can't think of any important differences in behavior.
Yeah, I encountered that. A function call was deleting the object the member function was called. Doesn't make it null though, only dangling.
A space bar is a space bar no matter which editor/viewer/diff tool you're using. A tab means different things to different tools so the layout is never consistent between tools. That's why you always use spaces for everything. Most editors should inserts spaces when you press tab and go back by "n" spaces when you press backspace on a tab.
Why would you use C++ in web dev? 0.o
What about a pointer reference? ``` void func(void*&amp; ref) { // ref == nullptr } int main() { void* ptr = nullptr; func(ptr); return 0; } ``` I know this has virtually zero use case, but the reference is null.
Sure, but you don't say `print with format` as the spoken word version of `printf`: in code, abbreviations *matter*.
Of course you don't define `operator=` explicitly but there's still some auto generated function of class `B` called when you do line `bref = B{}` which is totally normal function just like `copyFrom`. I think the only difference is in special role and syntax for `operator=`. My point was that reference that cannot change object it points to is not super unique and alien concept for other language users. Special role of `operator=` and copy/move constructors on the other hand may require some additional explaining (but I don't think it relates to concept of C++ reference) 
&gt; Not sure if you're a native English speaker, Ouch! I'm not just a native speaker, I'm actually English! Is my grammar really teh badn355? &gt; It's a pointer that merely observes another. I don't see how holding a pointer to something _observes_ that thing. Generally in computer science an [observer](https://en.wikipedia.org/wiki/Observer_pattern) is when "an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods." Even in [English](https://www.google.nl/search?client=firefox-b-ab&amp;dcr=0&amp;ei=DQuYWomoD86iwALjh76gDA&amp;q=define+observer&amp;oq=define+observer&amp;gs_l=psy-ab.3...6115.7927.0.8334.13.9.0.0.0.0.332.755.0j1j1j1.3.0....0...1c.1.64.psy-ab..12.1.156...0i7i30k1.0.0Y7uUFPWepg), I don't see how a non-owning pointer "watches or notices something", or "follows events closely and comments publicly on them". These seem closer to the "Observer Pattern" again. Finally, `std::observer_ptr` can absolutely have an effect on what it's looking at.
Username checks out :D Nice vid, and nice headphones :P What mic did you use to record that?
In Opera? I worked on the browser. Which was based on Chromium. Which kind of shown me all kinds of problems with C++ and portability: * toolchains are platform specific * compilers (in general) are not compatible with each other * many basic libraries were one-platform-only - so to make it workable Google wrapped different implementations with common interfaces and designed their own tool for fetching the right one for current platform and building against it * when you make a bug (which is easy) it might be unnoticeable on one platform (e.g. your) and break immediately on the other (e.g. one that you cannot debug directly) * everyone knows how it looks with package managers and build systems Basically the whole issue with C++ and portability is that there are 2 definitions of portable: * C++'s - you can use the same language to make 2 implementations for the platform specific parts * other-language programmer's - if I wrote it on one platform and it works this way, it almost certainly will work the same on the other platform with little to no changes Theoretically, it is possible to write a C++ code, that do not need rewrite, but I quickly came to conclusion that in C++ it is a property of a programmers and project discipline more than that of a language, and I am not genius enough to maintain such effort. But yeah, now I work as a backend dev, so I only need to care if code works well enough on my server. I sleep better now.
References are not rebindable, so you cannot always replace a non-nullable pointer with a reference. 
Your proof _relies on undefined behaviour_, and as such has no validity whatsoever. The original statement was that you can get into a situation where `this` is null. That's true. Just try printing the value of your pointer in the code above; you'll find it is in fact nullptr. There are certainly compilers that will not eliminate the if-statement, and that will happily print "this IS null". I've used them, and seen it happen.
How much does this cost? I'm currently a student so I wouldn't have much use for it, but I thought it looked like it would be fun to play with. It'd be nice if your website included info like that in a easy to find location.
Doxygen documentation was neither something that you can review without building it. Documentation is also something really important, but I don't know anyone witch had issue with the fact that they can't review the documentation without building it. Another advantage of having .hpp generated is that it become trivial to have pimpl generated for your library interface.
It seems crazy to me because in my opinion, people implicitly weight how much you should be typing a name with how long it is. The point of reinterpret_cast&lt;HELLO*&gt;(somethingelse) being so unwieldy and clunky is to signal that its a clustertruck Similarly, when i discovered std::reference_wrapper I assumed that it was meant to be used extremely rarely. Its why we use shouty all caps for GROSSLY_UNSAFE_MACRO_HACK_ALERT(), but instead its actually just a workaround for the fact you can't do std::vector&lt;T&amp;&gt; But if you compare std::array vs c style arrays, std::array has the problem that its A: verbose, and B: I can never remember offhand which way round the template arguments go. Even now I'd have to google if its std::array&lt;num, type&gt; or std::array&lt;type, num&gt; int variable[] = {1, 2, 3, 4, 5}; vs std::array&lt;int, 5&gt; variable{1, 2, 3, 4, 5}; This makes something that is better much worse to use. Its a few extra characters and more remembering. Its opt in hassle to get safety, when it should be significantly *more* hassle to get crap safety What we need is: std::array variable{1, 2, 3, 4, 5}; This is why references are such a great tool. Previously everything was pass by pointer, now you have &amp; - significantly more safe, better in a huge number of use cases, instant gold. You swap out one character and it solves all your problems (exaggerating). In modern c++ we'd probably something hideously clunky like void func(std::reference_wrapper&lt;T&gt; t) wait
I agree that many uses of T* can be superceded however a blanket statement that the language primitives are in all cases worse than their library counterparts is misguided. 
There's also the whole `.begin() .end()` thing with the STL (which is hopefully being partially fixed in C++20, though).
Befunge isn't a real serious language and doesn't count. I mean, it's real in the sense it exists, but the entire point of it, and other Esoteric programming languages, is to be weird and usually hard to write in. Befunge isn't a language thats meant to seriously be *used*, it's an extremely poor, extremely contrived, example. Show me ONE real, normal programming language that isn't read english-ey, left to right. 
From my POV, it depends a little on the job. It's more relevant for a senior C++ dev. For a junior dev, you don't want to scare away someone with great potential or problem-solving skills just because they're not a C++ wizard right now. (or dismiss them if they do decide to do the test, and do poorly). Stepping back a little, I've found there's no silver bullet to finding good people. It's just difficult. 
People who complain about this have never tried to port a Java program (or worse, a C# program).
Yeah, ranges look like they'll fix my gripes with how containers work which is nice, having to do std::sort(vec.begin(), vec.end()) is very clunky, but if we're getting std::sort(vec) i can't complain too much
What about generic_ptr ?
Why not do this **in addition to** your current hiring process, i.e. as an alternative, but not a requirement? If you're already struggling to get good people, your goal should be to find candidates using different ways and a variety of tools. You probably want people to apply that will do the online skill assessment, as well as people who are scared away by it or won't bother with it.
In terms of unwinding the C call stack when it may have cleanup work to do? Definitely not "Safe." But I do believe the behavior is still well-defined.
Oh, right. We can't assume that C code is exception safe.
That's right, which is awkward, and in the real world I find it means pointer-type member variables where a reference would be preferable, but where the class needs to be copyable. 
Huh I didn't know the deduction could do that, that's incredibly useful. Thanks! Solves one of my major gripes then
I wouldn't bother with such a job. I'll send a letter and a CV. We can talk on the phone. We can talk in person. I'm not talking to a robot online, and certainly not one that makes me solve silly puzzles. A job potentially lasts for years, even decades. I'll be writing code potentially worth millions. Yet half an hour of interview time is already too much? To me that paints a very bleak picture of what working for that company is going to be like. 
And the link with C++ is ...?
The issue happens before that. A lot of C code looks like this: void foo(void (*callback)(void*)) { void *thing = malloc(128); callback(thing); free(thing); } If `callback` throws, `free` will never be called.
I'm not saying that `inst.foo()` won't blow up at runtime, I'm saying the code `inst.foo()` itself has no issues. If we have a `T&amp;` as a function parameter, as the function implementer we must assume that it refers to a valid `T`. If the standard didn't even make such a guarantee, all bets are off and we'd be living in an anarchy world where `2 + 2` might sometimes come up `5` and we'd have to check that the computer is powered on before we call `std::vector::push_back()`.
Maybe try a more complicated use case that the compiler can't inline detect then. I've see this in the wild.
&gt; So, can a reference be null in C++? Yes it can as C++'s type system is not expressive enough to forbid it. Is it undefined behavior? Yes it is but as I note, being undefined behavior does not mean it can not happen. Yes - thank you! It still does not mean that it makes sense to check a reference for null, but claiming that a reference cannot be null in C++ is simply false with real life compilers.
Something very similar can be said of QPointer
I've absolutely seen `this == 0x0` in a debugger, and I know if I walk up the callstack I'll eventualy find some `foo-&gt;bar()` where `foo` is `nullptr`. My point in the rant isn't to discount peoples debugging experience, just to say that C++ isn't completely hopeless in that _this code_: void foo(MyClass&amp; ref) { ref.method(); } is perfectly valid in all cases. Not to say that `ref.method();` won't end up breaking in your debugger, but that trying to reason about having `&amp;ref == nullptr` _as you write_ the code is a fruitless endeavor. C++ does make it easy to subvert the type system, but that doesn't mean we can't make assumptions _at write-time_ that our callers didn't invoke UB.
Since safe code in Rust/Haskell cannot subvert the typesystem, then the guarantee is provided by those languages in safe portions of code. Unsafe code can be prohibited by compiler settings. Therefore, whole codebases in these 'safe' languages can actually be safe. So it's not the same as in C++. 
Senior dev here. When I see online skill assessment requirements I pass; too many good companies don't use them, making it not worth my time. Plus, I tend to associate that type of testing with entry-level positions.
There is no such guarantee by the standard. The only guarantee is that if a reference is instantiated by a non-null, then it's going to remain non-null for its lifetime. 
Base&amp; base = std::get&lt;A&gt;(v);
That looks like a really interesting idea! I don't know how well it would work as a fully-general feature though. In a world with multiple inheritance, base classes don't necessarily line up (Also I believe object layout is impl-defined). You can write a wrapper function that could work around this though: Base *getBaseObject(std::variant&lt;A, B&gt; &amp;Variant) { return Variant.get_if&lt;A&gt;() ?: Variant.get_if&lt;B&gt;(); } The compiler might even be able to optimize that into a simple cast if the objects happen line up right.
&gt; std::map is very natural Yes, it is very natural, which is *why* the current situation is a shame. A "default" name like `std::map` should be reserved for a type that does that one thing (mapping) exceedingly well without compromising for secondary things (ordered traversal).
Ah, but there's an issue, observer_ptr is a smart pointer in name only. It isn't smart. It doesn't do anything, it owns nothing, it could be null, it could be dangling, it could be anything! It has no semantics, It's only purpose is so people can claim "raw pointers are obsolete!!" Some dastardly programmer could even make it owning! The point of smart pointers is to deal with lifetime and ownership, but the point of observer_ptr is to not deal with that, to be the "smart" pointer equivalent to T*, even though it, imo, doesn't make any sense. how can you have a smart pointer whose entire purpose is not to deal with that?
it's hard to find c++ developers nowadays, even junior ones. In most cases, I'll do the interview myself.
&gt; BTW... the const member methods must use east-const, what now!? namespace Detail { template&lt;class&gt; struct Const; template&lt;class R, class... Args&gt; struct Const&lt;R(Args...)&gt; { using Type = R(Args...) const; }; } template&lt;class T&gt; using Const = typename Detail::Const&lt;T&gt;::Type; struct A { Const&lt;int(int)&gt; y; }; 
Huh? But what if the state is B?
I love this. 
&gt; There is no such guarantee by the standard. This is patently incorrect. A `T&amp;` parameter is guaranteed to refer to a valid object upon entrance to the function.
&gt; the only thing that prevent getting Base class is std::variant's sanity checker Not really. It's in the variant specification that if it holds types `Types...` you can only `std::get&lt;&gt;` for one of these types. The problem is this simple: You made `std::variant&lt;A, B&gt; v`. `std::get&lt;Base&gt;(v)` will fail because this variant has no such type. You can make a wrapper around this to achieve this behaviour. Note: You will need to either implement 4 overloads separately or go with perfect forwarding (+ SFINAE to check if it's a variant type) template&lt;typename T, typename V, typename = std::enable_if_t&lt;is_variant_v&lt;V&gt;&gt;&gt; decltype(auto) get(V&amp;&amp; variant) { using Vs = variant_traits&lt;V&gt;::types; static_assert(/* T is a base of at least 1 of types*/); std::size_t I = /* get current active index */; if (/* variant[I] base is T */) return std::get&lt;I&gt;(std::forward&lt;V&gt;(variant)); else throw std::bad_variant_access(); }
well, that's not variant's use case. For polymorphism, use something like boost pointer container. Variant is for "static" polymorphism.
No, there is no such guarantee anywhere, and I believe the Standard's text does not include such a guarantee. 
Wouldn't `std::visit` do the job? std::visit([](Base&amp; base){ // Do stuff with base }, variant);
The move is to replace HSQLDB that depends on Java with a better and faster engine that is written in C++ : Firebird SQL https://wiki.documentfoundation.org/Development/Base#Java_and_HSQLDB and here are some old tests https://www.ahunt.org/2013/09/lo-embedded-firebirdhsqldb-performance-comparison/ 
Online skill tests offend a fair amount of interview candidates. That is unfortunate. Reasonably skilled developers that don't interview people tend to drastically underestimate how many super terrible candidates there are out there. In my opinion, the purpose of the online skill tests is to filter out the really bad candidates, so that you don't even need to look at their resumes. Once you get to the reasonable candidates, then you do a phone screening and in person interview. Many candidates don't see things that way though, and assume that the really basic questions mean it's a really basic job. Also note that the skill assessment is good when you have a lot of applicants, and you are having trouble wading through them. An online skill test probably won't bring in more candidates.
 Base &amp; base = v.visit([](auto &amp; value) { return value; }); ?
&gt;&gt; It's in the variant specification that if it holds types Types... you can only std::get&lt;&gt; I agree, that's all by specification. Is there reasons why specification does not allow getting Base classes? ----- In your wrapper, you can't statically get stored index if two or more classes will have the same base class. I actually did my own variant in the past which allow you to cast to the Base class. That was just the question of static_assert checks....
It can't be implemented as O(1). It always requires n if's, or switch with n cases. Just because it needs to cast back to the stored type. You can look at particular implementations in gcc and clang. That what you see is compiler optimization magic for this very particular case. 
std::visit is O(n) operation in worst case. std::get&lt;T&gt; is guaranteed O(1).
obviously that depends on the compiler... It's not _required_ to perform that optimization.
Figure of speech. I was talking about an observer in the general context.
std::visit is not std::get performance-wise.
I think for C++ job interviews you don't need to use a skill assessment tool. From my experience it's relatively easy to find out via telephone interview what the rough skill level is - especially for the more senior devs. A few well prepared questions are usually enough - ask about inheritance / polymorphism, modern C++, the different standards, smart pointers, move semantics. If they are good you can dig deeper into templates / template meta programming etc. I only ever sent some C++ implementation tasks to people coming directly from university/ if it's their first job. So basically when I had the feeling they are good programmers with lots of potential, but they don't know (modern) C++ that well. Those tasks were always strictly timed (max 24h) and they were more about to find out how fast they can learn / are really willing to learn. 
&gt; std::visit is O(n) operation in worst case. Says who? &gt; *Complexity:* For `sizeof...(Variants) &lt;= 1`, the invocation of the callable object is implemented in constant time, i.e. it does not depend on `sizeof...(Types)`. §23.7.7 [variant.visit]
&gt; Show me ONE real, normal programming language that isn't read english-ey, left to right. C++? That's [how this discussion started](https://www.reddit.com/r/cpp/comments/80k8hc/a_blog_rant_on_east_const/duwgl18/); someone was annoyed that C++ cv-qualifiers aren't read left to right?
&gt;[...] at O(1) (IOW without using std::visit)? The standard guarantees that `std::visit` for 0 or 1 variants is O(1), so your "*in other words*" is erroneous: You're reformulating a statement into its logical opposite (at least in the case of 0 or 1 variants).
This kind of analysis is only useful when we are considering `n` as a value that is growing unbounded. It's conceivable that you are working on a program where the input size that you are expected to support is large and expected to increase in the future. I've never seen a program where `std::variant` is used that is expected to work over an unbounded number of types in future revisions of the program. --- Besides this, `std::visit` may be `O(1)` as we normally analyze x86 code, depending on exactly how it is implemented. Here are 3 different ways to implement it, giving O(n), O(log n), O(1). Strategy 1: - Chain of `if / else`: (this is used in e.g. Mapbox variant) if (tag == 0) { return visitor(*static_cast&lt;type0*&gt;(storage_)); } else if (tag == 1) { return visitor(*static_cast&lt;type1*&gt;(storage_)); } ... - Binary search: (this is used in e.g. strict_variant, (my implementation)) if (tag &lt; n/2) { if (tag &lt; n/4) { ... } else { ... } } else { ... } - Array of function pointers (this is used in libc++ / mpark variant) using fptr_t = result_t(*)(storage_t *, visitor &amp;); constexpr fptr_t jumptable[] = { +[](storage_t * s, visitor &amp; v) { return v(*static_cast&lt;Types *&gt;(s)); }, ... }; return jumptable[tag](storage_, v); The array of function pointers approach is "intuitively" the fastest -- there is fixed cost that doesn't increase as `n` gets large. In x86 code we normally think of dereferencing an array or calling a function as `O(1)` operations, whether or not that's really reasonable as `n` tends to infinity. In profiling, I found this to be the worst approach because: - Even recent versions of gcc struggle to inline through such function pointers, and if they can't, then the cost of an extra function call swamps any other consideration - The mapbox variant is actually the best, because compilers can translate that to switch case when they optimize, which is actually the ideal solution here. I stuck with my approach for now as a middle ground, but I might change strict variant implementation to use the mapbox variant implementation. I don't think it makes any sense to assume that `visit` is noticeably faster than `std::get`. Visit is the safest way to use the variant and should be the preferred way of using it, because `std::get` can fail.
I'd suggest for more junior positions that companies allow applicants to choose whatever programming language they want to complete these tests.
Just like you can use the inactive member of an union. Still UB, and you still _can't_ to that because the standard said so. It's not about optimisation, is about correctness. Unless the behavior is documented and you can afford to be platform specific. Nonetheless, checking for null this is just like checking is the value of an inactive union member is valid before using it. Once you're in UB, there's no way out, even before the UB actually happen.
Like you said, a pointer is like a phone number. You don't call someone up and deregister them and transfer the phone number to another person. That would be really inconvenient for the next person trying to call them. Makes an interesting analogy. I'm not really going to sit here and argue it. You have your way of doing things and it probably works for you. Nothing wrong with that. 
&gt; sizeof...(Variants) &lt;= 1 Doesn't we have at least 2 types in example?
&gt; Still UB, and you still can't to that because the standard said so. No, if you couldn't do it then it wouldn't compile. The standard only says doing so is UB. I'm not really sure what you're arguing about here. Correctness is irrelevant. You _can_ do it, but the result is UB. What the standard says you cannot do is simply what won't compile.
`std::visit` is specified as: template &lt;class Visitor, class... Variants&gt; constexpr see below visit(Visitor&amp;&amp; vis, Variants&amp;&amp;... vars); So `sizeof...(Variants)` (which would be 1 in the OP) has nothing to do with `sizeof...(Types)` (which would be 2 in the OP).
Well, re-reading it, my comments do sound pretty snarky. Text-based communication is sad.
So how after all this std::visit can be faster then std::get&lt;T&gt;? Where std::get is no-op static_cast&lt;T&gt;
I stand corrected. Thou, as /u/render787 [pointed out] (https://www.reddit.com/r/cpp/comments/815zr5/stdvariant_and_accessing_baseclass_stdgetbaseclass/dv0swl6/) std::visit is still relatively costly operation.
It may be an XY problem here. &gt; This would allow to use (in some places) std::vector&lt; std::variant&lt;...&gt; &gt; instead of std::vector&lt;*Base&gt;. For this you don't need variant at all. Have a look on [Boost.PolyCollection](https://github.com/boostorg/poly_collection) (I would have put a link to documentation here, but boost.org is unresponsive for me right now), specifically base_collection. It's a container for polymorphic values, without extra indirection. The author explained its design in a blog post [here](http://bannalia.blogspot.nl/2014/05/fast-polymorphic-collections.html)
The reason std::visit doesn't support this is because it is simply overloaded on the types it has. It would be ab it more work, but getting this to happen with a custom template function is definitely possible.
`cmake_minimum_required(VERSION 3.10 FATAL_ERROR)` I love it
The issue comes from the rules of union access, which only allows what you what in a certain situation. I believe that libstdc++ implements variant as a recursive union: // base case, only selected for empty types (variant_storage&lt;&gt;) template &lt;typename...&gt; union variant_storage {}; template &lt;typename T, typename... Rest&gt; union variant_storage&lt;T, Rest...&gt; { T value; variant_storage&lt;Rest...&gt; rest; }; This implementation is obviously not required by the standard and another version could use `std::aligned_union` for storage. Still, let's consider a version of your question just using unions: struct Base { /* ... */ }; struct X : Base { /* ... */ }; struct Y : Base { /* ... */ }; union U { char dummy; // allow default constructing U Base b; X x; Y y; }; (for the sake of simplicity, assume that `Base`, `X`, and `Y` are all trivially destructible) The question is in what scenario is this allowed: void foo(Base const&amp;); U u = { '\0' }; u.x = X(); foo(u.b); u.y = Y(); foo(u.b); The standard actually has an answer for this: if `Base`, `X`, and `Y` are all standard layout, then it is well-defined to read the initial common subsequence of the non-active union member. In English, this would require that (more complete version can be found [here](http://en.cppreference.com/w/cpp/concept/StandardLayoutType)): 1. Either `Base` has no data members or only `Base` has data members 2. None of the classes have virtual functions 3. Note of the classes have references as data members 4. Either all data members are `private` or all data members are `public` 5. Each data member of the classes is also standard layout (i.e. follows rules 1-4 and this rule for it's own data members). (you can see [here](http://en.cppreference.com/w/cpp/language/data_members#Standard_layout) for a more through explanation of what it means to read part of the initial common subsequence.) The reason for this rule is that it is the only way to guarantee that `&amp;u.b == static_cast&lt;Base const*&gt;(&amp;u.x)` and `&amp;u.b == static_cast&lt;Base const*&gt;(&amp;u.y)`. Otherwise, depending on the implementation-specific layout of the classes, they could be at different addresses. If that were the case, there's no way to get a pointer to `Base` without knowing if `x` or `y` is the active member. The same problem is true for `variant`, except now you don't even have the benefit of knowing that it's a union. There was talk about forcing `variant&lt;Ts...&gt;` to be standard layout if all of `Ts...` are standard layout (ditto for trivially copyable, trivially moveable, trivially destructible, etc), but that isn't yet the case. Unless there is an incredibly pressing need for O(1) access to a base pointer, I don't think giving up variant (and trying to enforce standard layout) will be worth it.
As I understand from doc - its unordered. If so - it wouldn't suit my particular case.
It depends on what version of `std::get` you rely on `std::get` can signal an error by throwing an exception, or returning `nullptr`. If an exception is thrown, and you have to catch it in the course of doing this operation, that may be hundreds of times slower than all surrounding operations here. If you are using `std::variant` in order to avoid `std::vector&lt;base*&gt;` and avoid cache miss when you go to fetch from the heap, well, throwing an exception is an entirely new dynamic memory allocation. In some OS, like windows, throwing a C++ exception may be tied to "structured exception handling" and may basically imply a system call. So if you are really trying to optimize the hell out of this I would obviously avoid that. (Not to say that using exceptions is wrong or bad, but it should be reserved for exceptional situations, and not something that happens during "normal operation of the program".) If you use the version of `std::get` that will return `nullptr` on failure, then you still have to branch on that `nullptr`, and then do soemthing else. Which is probably, `std::get&lt;B&gt;` instead? I have no idea what you have in mind. It's probably going to boil down to rolling your own `std::visit` if you expect to be able to get the base class no matter what type is actually held in the variant.
I think in case of replacing std::vector&lt;base*&gt; with std::vector&lt;std::variant&lt;ALL_DERIVED_FROM_BASE&gt;&gt; you can guarantee, that there will be no std::bad_variant_access exceptions or nullptrs.
I very much like the idea of this type of skill assessment. This would be especially true when hiring someone for specific skills like C++ programming. In this vein I accepted an offer to take one. It was a hellish exercise. 6 hours - I think 4 or 6 programs to write. I blew it big time. a) I was underestimated the difficulty of the problems. b) The first one - looked like the easiest - I managed to more or less do - took me a couple of hours. It ran to about 250 lines of code. The code and algorithm were non-trivial. c) being generous, assume I got it right. and assume someone (smarter than I am) could complete 4 similar problems in 6 hours. (let's say 8 hours to make it a work day). The would mean 1000 lines of working, tested, correct and difficult code in one work day. That would be about 22,000 lines of such code per month from the programmer who can get a good score on this assessment. That would seem a little unrealistic to me. Now I consider myself and advanced and very competent programmer - but I missed the bar here by a very wide margin. So either I'm self delusional and others are much, much, much more capable and productive than I am, or the design of the "assessment" is delusional about what a realistic assessment would look like. I was disappointed and just moved on. If it's this hard to make an assessment for a narrowly defined skill such as C++ programming, It must be much more difficult for other "softer" skills like system design, mapping users requirements to a program structure, etc. etc. So I still have interest in using "skills assessment" but I see it as a lot harder to implement than would first meet the eye.
Yes, but only if you use `std::visit`. If you use `std::get` you obviously do risk those things.
This is my best try at the moment: https://godbolt.org/g/R8aR8U This differs from the 'get' behavior in a few ways. First, if it matches multiples, this simply gives the 'first', not erroring. Second, it returns by Value, since I could figure out how to make it return a reference. I can poke around it a bit, but perhaps someone better with templates (*cough* /u/STL *cough*) can point out something silly I'm missing.
That isn't an example. That argument is personal opinion, and either way works, and in any case has nothing to do with the language grammar. Your argument was about language grammar, and you gave Befunge as an example where the language grammar makes it impossible to read in anything like english. So give another, but in a real language.
Or std::we\_named\_it\_for\_the\_concept\_even\_though\_it\_will\_always\_be\_a\_hash :p
So it's a wrapper for new. This is a classic example of using a design pattern when you don't need it.
It's not my video, but I think he just uses his phone? You could always ask him directly via YouTube comments...
C++ is used for games, digital audio workstations, microcontrollers, servers, databases, and soooooo on. A game developer is going to have a very different set of skills and his C++ may even look completely different from the DAW or microcontroller code. A game developer and embedded programmer are probably never going to use Boost. The game developer will probably be using some version of C++ that has an elaborate reflection system, which would make the embedded programmer shudder. A game programmer may not even use the majority of the standard library. Despite this, I'd argue a competent programmer in one of these will probably be able to transition to one of the other areas (with a little pain). However, either you're going to miss out on them if you make a robot test that is specialised to your field or you're expecting them to invest the time on their own into switching, which may not happen since a good C++ programmer is almost certainly already employed.
Let's call it "undefined behaviour condition" then. It is by itself not UB yet, but it does set up a condition that a UB is about to go off.
I had to code a tic-tac-toe for my last interview. It's simple enough to do in one hour tops, which is great, and yet gives quite some insight to the code reviewer: is the code messy/structured? Working? Are edge-cases handled? Erroneous inputs handled? ... Next, on the phone interview, we did a "review" of my code, exchanging about design trade-offs and particular decisions. Which again I found valuable (on both sides), as code reviews are a good part of the job anyway so better see how it works early on.
&gt; Not the same thing, as true is extremely unlikely to turn out to be false in practice It's equally as _pointless_ – as far as the compiler is concerned, they're both testing constant expressions.
Awesome! Thanks 
&gt; though i'm not sure there can be a sane "general purpose" default I'd agree, and hence don't think we should ever have a `std::ptr` of any kind. :) That said, `observer_ptr` is a garbage name. My vote goes for `indifferent_ptr` but I doubt that'd get traction. :p
FYI: There's also one in Dresden.
What about [Sol2](https://github.com/ThePhD/sol2)? It seems to be pretty fast overall and to support a lot of features. It's also written in C++14.
!remove
I would have thought the same thing but recently some colleagues gave a simple algorithmic test to 3 candidates. 2 of the candidates with lots of C++ and job experience failed to create an algorithm that was faster than the naive approach even when the instructions basically pointed them in the right direction already and they had multiple days on their own to work on it (it should take about 3 hours). Unfortunately there are lots of "programmers" who can do simple productive work but lack higher level problem solving skills. Maybe their fine for UI work or something but we have complicated problems that need creative solutions. The other thing that was interesting is that all of the candidates had optimizations that focused on reducing instruction cycles instead of increasing cache locality revealing that their optimizations skills are badly out of date.
Its not only a wrapper for new, its a mechanism to create an object based on its typeid value.
 Nobody interviews 50 candidates three times each! Yes you will read 70 applications and then maybe interview 10 to 20 for the first time after that you’ll have a pretty good picture and will probably only interview 2 to 5 people for the second or third time
Ah thanks, forgot to go through my manual check list for groups not on meetup this time...
I meant 3 people sitting in on the phone interview. You're using 1.5 man hours, not half an hour. We _were_ interviewing fewer than that, back when we used an online tool as a filter. With that gone it's a never-ending drudgery of phone interviews. And then a half dozen or so all-day in-person interviews. And by the time that's all done you might have a month or two before another position opens up.
Thank you for continuing to provide this info!
I agree it takes a template argument for the type it creates. Why is this a good use of a factory?
For the function, have it return `const std::variant_alternative_t&lt;GetBaseIndex&lt;Result, Arg, Args...&gt;(), std::variant&lt;Arg, Args...&gt;&gt;&amp;`.
You're going to have to write it out anyway in the end because you can't define a function through a typedef.
Thread should be titled “just use Rust”
You're taking that variadic list of arguments by copy, no? What if one of them is enormous? Why not take by Args&amp;&amp;...?
I don't always test my code... but when I do, the first test is: ``` ASSERT_TRUE(this != nullptr); ``` /s
It could probably be written a little clearer, but to be fair, if you read on just a little farther: MinGW's official website mingw-w64.org provides various builds, but I maintain my own distro because I demand complete control. (It's a long story, but mingw-w64 forked from mingw.org. Although my distro was based on mingw.org for many years, I now consider mingw-w64 to be the one true MinGW.)
Yeah, I don't think this is helpful. There's still a ton of people out there who think the original MinGW is the only one, I think it is important to specifically say "MinGW-w64" to help spread awareness of the fork.
You have 60 minutes. Go!
I'm always tempted to rewrite my code in another language. Rust is a possibility, but it seems its compile times aren't much better than C++, and it doesn't have proper compile-time reflection. D is almost perfect, but I don't want anything to do with a GC or a standard library that's built around a GC. The syntactical ambiguities, the lack of modules, the lack of compile-time reflection, the compile times, and this aggressive style of optimisation (`this` can't be null, refs can't be null, strict-aliasing, signed overflow) makes want to write my own language, which is easier because of LLVM, but I know it would be difficult. I believe compile times can be solved by using memory-mapped modules and a template instantiation cache.
I think you are looking for Qt. It has a very large library that abstracts just about everything you need for portable applications. Basically, you just need to recompile and relink for a new platform without having to change any source code.
I don't understand why you think it's a code smell. Would you also say that `optional&lt;T&gt; const` is a code smell? Because `T* const` is basically the same thing except with indirection (allowing polymorphism, for instance).
Errr why do you have 3 people on a phone interview? 1 person per interview is enough.
Ooh, thats awesome! You crazy library people are coming up with the most useful things :)
That decision is above my pay grade.
Depends a lot on how much time the test takes. Same goes for home-assignments. If it's more than 30 minutes, I probably wouldn't do it (unless you pay me).
Right, thats an oversight on my side, should of course take this by universal reference.
It looks like a good slide deck to me, but definitely for people who already know how to program. Does he use these slides to teach? (I think yes). I really hope it's not for a first year lecture. If so, this would alienate quite a lot of beginners and women.
Of course references can be null int *value = nullptr; CheckMeOut(*value); What you're saying is you want to rely on the fact that they are not null which could be the same thing as saying in a perfect world raw pointers are never null if you just never use nullptr to assign to them either. 
Needs more mansplaining
Sorry, maybe "women" is too generalizing. But the fact is that computer science loses a lot of women because of lectures that assume too much existing knowledge or that people will "just" grasp what "keywords" are and how if/else work etc. Of course, we lose bright people of other gender too, but the fact is that a big group you lose like this are women, and it is a shame and something we should work on improving.
Some of the statements in your whitepaper sound dubious &gt;Luckily, in many cases, &gt;the performance of an application can be increased using relatively cheap offthe-shelf &gt;multi-core hardware (where a processor has several individual CPU &gt;&amp;#147;cores&amp;#148;), and without impacting energy consumption The part about energy consumption is definitely not true. In the part about Intel TBB you write &gt;- Not portable and no GPU support It is available for Linux, Windows and macos and (in parts?) opensource 
We have a dude that does these assessments in about as fast as he can type them. We pay him $300k/year. In the midwest. He works 4-5 hours a day, 5 days a week, with 8 weeks vacation time.
Cool! That seems like exactly the right target audience :-)))
I still doesn't understand why gender has a role in this. I know that CS is historically a field where men are predominant, but I don't think it has nothing to do with teaching. If you teach the same you get the same results, disregarding the gender. I cannot bring proof here, just my guts, however I believe that the fact that women are less interested in CS is one of those catch-22 situations. Less women in key roles brings less women in the field which causes less women in key roles... 
`empty()` has bothered me since I have first seen it as well. Just one gotcha everybody who has learned stl has to go through. But they could still add `is_empty()` as a better option, just like they added `erase(...)` to `std::list` 
No, I am saying that we (men) teach the content in a way that is more appealing to men. It starts with who usually writes the teaching material: Men. Because there is like &gt;90% men in CS. Men write and teach it in a way that they understand or how they learned it in their past (from most likely another man). And then there is the society thing... (unfortunately). Boys are given cars and lego to play with from when they're like 2 years old, shirts with "I'm an astronaut". Girls are mostly given (or expected to play with) dolls and are given shirts with stuff like "I'm a princess". Who is likely to have a better grasp of "engineering" even at a very young age?
&gt; catch-22 situations Yea, it certainly is. But we men can/should/have to play a big role in trying to help change this, even if it's just small things. See my other reply here below to Drainedsoul. So in a way, for example: &gt; If you teach the same you get the same results One of the problem is that the teaching material was (most likely) written by men, in a way that is more likely for men to understand. Many CS teachers have actually never been in the situation that many CS freshers are - they are probably a CS teacher today because they had interest in programming early, many of the concepts were natural to them and they "got it" easily. For many people, this is not the case.
`std::basic_ptr`? or would others believe its a base type?
I'm not sure you're familiar with 'tabs for indentation, spaces for alignment'. It doesn't matter if tabs are different between tools, as long as they are internally consistent within the tool, as all my indentation will be consistent. This is a really useful thing as it allows users to use a 2 or 4 space tab stop depending on their preference rather than having to just concede to one person's preference. I have met very few editors that will 'backspace by N spaces' when I hit backspace if what actually exists is some set of spaces. Even fewer editors will jump by N spaces when I arrow over these spaces, and none which prevent me from typing 1 space into a 'tab' of N spaces. These minor annoyances cause daily friction to me when I am forced to work in a 'spaces in stead of tabs' environment. I think most 'spaces' people either just don't even register this friction, or have more sophisticated editors than me, or just think this is a worthwhile trade-off to have consistency.
Do you have any suggestions for how it can be improved or just "this isn't tailored for X and thus bad"?
I'm speechless. This is really unique and actually fits my domain and the stuff I'm working on very elegantly. I do a lot of data processing for financial trading related applications and we've been looking for a way to express operations over data sets and act on that data using reactive style programming, but so far our solutions haven't been ideal. I feel like the ideas and structure of Cell solves many of our problems and as we use C++ heavily, this would fit right in. Thanks for posting this!
FATAL_ERROR is ignored by cmake_minimum_required in recent versions [1] and can be safely removed, here. [1] https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html
I once had 7 people on a phone interview, but it was a phone interview because I couldn't come in person. My current company now generally does 2 per interview. I believe the idea is so the 2 can discuss the interview later. There's also probably a type of ethics or HR thing where they don't ever want to be in a he said she said situation or something, though why I'm not sure.
What's special about yours? What is yours even called? What do you mean by "sign up"? This is all pretty vague.
const optional&lt;T&gt; tells me whoever wrote this code put more thought into making sure it was the best way of writing what needed to be written. If I see T* const I immediately think they're just slamming their face on the keyboard until it compiles.
I have seen this too. It is just useless. A line of code that adds so little value that there is no point in including it.
It mainly boils down to practice. If you practice these exercises, you'll be good at it. But as you say, this may not be very helpful in everyday coding on the job. If I was gonna practice these coding exercises for 3 hours a day for a month, sure, I'll probably ace many coding interviews afterwards. But is it worth my time? Probably not. So, totally agree with you.
Are there compilers that chose to define consistent behavior for null references or null this pointers?
Most of what I see C++ people arguing is that in a real system it's possible to get the value 0 into memory that the compiler is using to represent a reference. The thing is, so what? I can create a pointer to a random place in the stack or on the heap and then destroy memory in all kind of useless ways, zeros or otherwise. Why this focus on meaningless null values?
The [High Integrity C++ Coding Standard](http://www.codingstandard.com/section/index/) doesn't have strong opinions on code formatting, but I've found the guidelines to be very agreeable.
Noting that `this == nullptr` is still never meaningful.
There's also the fact that forming an lvalue is an ODR-use, and ODR-use mandates a valid object.
&gt; The idea that undefined behavior implies that something can not happen is just an ill founded idea My argument is not that it cannot happen. It is that there is no value in discussing. Can a double hold it's own address? double d; *(double**)&amp;d = &amp;d; Well yes it can.
Yes, most compilers will produce consistent behavior if compiled in debug mode and you have tools like valgrind, address sanitizers, and other related memory debuggers that will produce consistent behavior for such cases. For production/release no chance of this and given C++'s nature/philosophy it's for the best, but for debugging applications to identify potential undefined behavior then yes compilers often produce consistent results.
[Old Man Yells At Intel](https://i.imgur.com/3oTAf6s.png)
`std::reseatable_reference`
`ptr` or `ptr_` is best reserved for a template supporting substitutable read left-to-right syntax for raw pointers. It's how that should have been from that start, instead of C syntax. The proposed `observer_ptr` has no functionality supporting observing. It's just a guaranteed-initialized-pointer wrapper that can't be used where a C pointer is expected, and where *the name is supposed to indicate that it's non-owning*. For those reasons I'd like to call it a **`dumb_ptr`**, as already suggested by OP, but considering that it lacks any extra functionality and doesn't own anything and that someone who doesn't own anything is poor, I think **`poor_poointer`** or maybe shortened to **`poo_poo`** is OK. 
&gt; The name doesn’t quite roll off the *tough* 
(b) it's not hideously hard to have avoided in the first place (cache needs to reserve space based on process ids so process A can't manipulate reserved cache for process B) wew, we've reached peak Reddit 
There a certain set of words including `occurrence`, `wary`, `dependent`, and `tongue` that my typing fingers refuse to spell correctly.
I'd first heard it from Herb Sutter, but I don't know if he got it from somewhere or not.
Interesting tidbit: He never "practiced" them. He just happens to really have the groundwork for algorithms and data structures down pat and is very strong in discrete maths as well. All those assignments are simple if you're good at that, and he is phenomenally good at it. What he does practice is Knuth's TAOCP problems, though. I don't how much that helps in coding exercises, but it sure helps with the theoretical background. 
Well `observer_ptr&lt;T&gt;` (or whatever it ends up being called) would help with that, although I still don't really see what's wrong with const pointers to begin with.
&gt;It's that there is little value in discussing it. There's value in discussing it because when it does happen your program will behave erroneously so it's worthwhile to understand how a null reference can be created in the first place so that you can identify the cause. The most trivial way to create a null reference is to dereference a `nullptr`. Another way of doing it would be if you had a struct containing a reference as a member, and that struct was `memset` to 0. Those are the only two that come to mind. Now yes, I agree doing that is undefined behavior which means that any legitimate use of that would require a great deal of justification regarding the environment, what I'm saying is that undefined behavior doesn't mean something can't happen, on the contrary if you wish to write robust and reliable software, you should really understand all the ways that it can happen so that when you profile and debug your code and you come across a null reference, you have the knowledge needed to track it down.
No, this time your claim isn't true - both for irrelevant pedanting reasons based in refusing to acknowledge anything outside the C++ standard (should be your role, no?) and also for relevant reasons. First, the irrelevant pedanting - `this == nullptr` is not a constant expression, at least not according to C++ standard terminology. Note that in the C++ standard, the term "constant expression" has a formally defined meaning which is distinct from the English language implications of "expression that always yields the same known constant value". A constant expression always yields the same known value, but that isn't sufficient to imply it's a constant expression (or even a constant). For example, if you have an unsigned integer variable `x` and in the absence of undefined behavior, `x - x` always yields the result `0`, but is not a constant expression. The same applies to `this == nullptr`. `this` is not a constant expression, so by the rules of the C++ standard `this == nullptr` isn't a constant expression either. I admit it's remotely possible that I'm wrong as I haven't double-checked, but I can't imagine the standard requiring compilers to solve the halting problem, or defining some arbitrary set of special cases, other than the obvious referentially-transparent by-construction scheme. More relevant to the point, the compilers perspective is not defined purely by the C++ standard, and was never intended to be - that's *why* there are terms like "undefined behavior" and "implementation defined behavior" in the standard. From the C++ language standards perspective, the compiler is *allowed* (not required) to infer that the result of `this == nullptr` is always `false`, and the compiler is equally *allowed* (not required) to emit naive code without inferring that and thereby include the runtime check. Part of the reason for that is no doubt *because* debug builds exist, and have always been intended to exist, even though the C++ standard doesn't define them - because the C++ standard isn't (and never was) intended to define everything. This isn't undefined behavior. Either policy results in the same run-time behavior, consistent with the abstract machine defined by the C++ standard, provided there is no undefined behavior *anywhere else*. In part, the language of undefinedness exists (along with leaving many things unstated) because the C++ standards committee simply doesn't consider everything about the C++ language and how it's implemented and used to be within its remit. "Not within the remit of the C++ standard" doesn't mean "bad". 
dang_ptr Short for dangling or dangerous, of course.
Theres an argument to be made for an `std::ptr` being consistent with a raw pointer, which it would be in this case. It also wouldn't make much sense, IMO, to introduce a `std::ptr` just so we can be "hurr durr never raw pointers". the entire observer_ptr concept makes no sense to me.
I have zero sympathy for organizations saying they have recruiting problems when it comes to technical talent. Assuming you offer good pay, the answer is you are inept and need to pay through the nose for high quality recruiters. Your current staff is incapable of doing hiring properly. Adding on a webbot screening will not help. This industry is filled with successful people who have no social instincts. You get really smart people who can't quickly sort through a pile of resumes and throw the right ones in the trash. Or suss a person out in a fifteen minute call. I can do these things, no problem. Early on in my career I remember being flabbergasted at hires I knew would not work out. It took me a while to realize my elders were just actually that stupid.
Maybe uppercase for _hardcoded_ constants. Like `const int SIZE = 5;` not for variables that happen not to change `const int area = width * height;`
I think you misunderstood. They're working on making your code automatically _be_ in Scotland, in parallel with wherever it is now. It's kind of like automated `git-push`es to github, but without using `git`. Probably because the term [git](https://en.wikipedia.org/wiki/Git_(slang) is more of an English than Scottish term, and Scotts are often ornery towards the English.
The C++ Standard really explicitly states that `extern "C"` has what is called "C linkage" in §10.5.3 and nothing about exceptions anywhere. The reasons why you might want `extern "C"` while allowing exception throwing are somewhat obscure, but the use cases are exception-aware languages that are still foreign. If you want to call Objective C from C++, you can't deal with Objective C mangling, so you can expose a function with C linkage (using, conveniently enough, `extern "C"`) and call it. Anyway, treating `extern "C"` as non-throwing is only the behavior [/EHsc is your exception specification](https://docs.microsoft.com/en-us/cpp/build/reference/eh-exception-handling-model). The behavior is more explicitly stated [here](https://docs.microsoft.com/en-us/cpp/cpp/exception-specifications-throw-cpp) as "A C function is assumed not to throw exceptions under /EHsc, and may throw structured exceptions under /EHs, /EHa, or /EHac." The default is _not_ /EHsc, as it would make MSVC not standards-compliant for no good reason (if that has changed...poor choice). That said, MSVC doesn't have the best track record on that front, but they're really trying to get better.
Get a life
It's not that hard to effectively subvert the type system in Haskell. For example, to use the C FFI facilities to manipulate memory in a C-style way, you don't actually need to tell Haskell you're using the FFI - that aspect of the FFI isn't really a language extension so much as a set of libraries, and used as a building block to define some higher-level data structure libraries even in code that has no intention of calling foreign code. You can certainly use the `Storable` typeclass/interface to write to memory from one type, then read back as another - effectively the same thing as using a `union` to subvert the type system in C. Technically, that doesn't seem to be outside any explicitly safe subset, though obviously it's unlikely to cause problems in practice unless you go out of your way to abuse the FFI, or you're unlucky enough to need to write some low-level C-style data structure in Haskell for yourself. 
Similarly, a lot of the most skilled people I know would just skip past applying for a job like that because they're good enough that they can simply get something else where they don't have to jump through hoops.
Ok. So?..
Your example has been reported by a user as offensive. Please consider how avoiding needless offense helps make C++ a better language.
Depends how much time you're wasting doing phone screens etc.
This is freaking awesome. Is there a table of contents somewhere that I misssed?
The C++ standard doesn't try to define everything about the C++ language - that's why there's language about "undefined behavior" and "implementation defined behavior", and for that matter why the standard is simply silent on a lot of things. Some things are outside of the C++ standards remit. The C++ standard doesn't define what a debug build is. That isn't a constraint on what C++ implementations are intended to do, or on what C++ developers are intended to use or code for. It's simply outside of the remit of the standard. Consistent with that, whether code that can only execute in the presence of undefined behavior is "nonsensical" or not is outside of the remit of the C++ standard. 
Makes C++ a better language? I'd love to see you defend that position.
Thanks
Hmm. That would definitely not meet my definition of consistent behavior. If changing debug and/or optimization settings results in changes in behavior of the program then the compiler does not specify behavior for that code. So, are you saying that no, no compiler that you know of provides consistent behavior in these cases?
This is the heart of your disagreement with the rest of the people commenting on this post. You say that we should require all developers to know all about how undefined behavior on their combination of compiler and platform will behave. Even though many/most people need to write code that works on multiple compilers and/or platforms and it will behave differently on all of them. Everyone else is saying that this is a counter productive attitude. You say that others are being pedantic, but really it is you that is being pedantic. There is no useful case for a null reference or a null this pointer. Stop. There is no specified code that can get you to a point where you have null reference or a null this pointer. Stop. If you are debugging and you have a null this pointer or a null reference the code that produced it is wrong. Full stop. I challenge you to provide a useful case for either of these. Post it in this forum. 
The PDF has a sidebar.
java final is either 'const' for primitive types, or a '*const' for java reference types (Java references are C++ pointers!)
I am doing interviews since the last 14 years and we never used an online assessment tool. If I get a reasonable CV we start either a phone interview or we invite him/her into the office. After an introduction to each other we speak about his/her recent projects and about ours. And there we see if he/her fits into our team. At the end we do a small programming test for 30minutes only. But a failure of the test is not a K.O. criteria. It is just a piece of a puzzle. In the end our way cannot be that bad, because our fluctuation is much lower than the average of our country.
fully agree. also read: https://blog.codinghorror.com/why-cant-programmers-program/ which is true in my experience.
&gt; Sometimes the aversion to breaking changes are more trouble then actually breaking things. I think this is a general problem with the c++ community/industry at Large. I'm a bit afraid that the combined inertia will be the death of c++.
Launching vague hypothesis like "most compilers will probably go with the normal rules for virtual functions" just after having read "the behavior is undefined" in the standard is, like usual, a recipe for disaster in the modern age; an overzealous compiler author will be quick to add an "optimization" where the concrete type of an object is "deduced" because a delete is seen to something that has no virtual destructor, and the whole code path will be retroactively optimized, e.g. devirtualising everything. Of course now this is only an example of what wrong can happen; but this is ok: I'm using this example to illustrate why people should absolutely *not* do that kind of thing, because otherwise they will be bitten by their compiler. However giving the only example of what could go "right" is *not* OK, especially when you know about undefined behavior and you just read that this is explicitly one in the standard. The real thing to do would be that compilers stop adding that kind of retarded "optimizations", BTW, but I've completely lost all hope on this point.
I extracted the page bumbers and titles, parts and the 190 section headings using pdf2txt (python), but it's not clear to me if I can post it under fair use.
Looks nice. I'm happy to see more exploration of source-to-source meta languages. What does it do? I mean, for example, in the lex/yacc analogy, what exactly does cell actually do? Who is it for? What problems does it solve?
&gt; Visa Sponsorship: No Even 2-3 person companies are able to sponsor visas for UK, so what's up with you? Did you laid off the whole HR department?
Nothing is true. Everything. Is. Permitted.
Write linear version and check for optimization. template&lt;class T, class Var, std::size_t I&gt; T get_as(Var&amp;&amp;var, std::index_sequence&lt;I&gt;){ try{ return std::get&lt;I&gt;(std::forward&lt;Var&gt;(var)); } catch(...){} } template&lt;class T, class Var, std::size_t I, std::size_t...Is&gt; T get_as(Var&amp;&amp;var, std::index_sequence&lt;I,Is...&gt;){ if (var.index()==I) { try { return std::get&lt;I&gt;(std::forward&lt;Var&gt;(var)); } catch(...){} else return get_as&lt;T&gt;( std::forward&lt;Var&gt;(var), std::index_sequence&lt;Is...&gt;{} ); } I attempt to signal that std get cannot fail by doing UB if it does. 
There is actual business around internal recommendations. Developers take the job of hr or head hunter. It's much more efficient and the company could pay much less.
In this case there is little value in `variant`. Just use `Base *`.
As a C++ enthusiast (that's how I earn a living) and Haskell wannabe I find the choice of conferences intriguing. ICFP!???? I'll let monsieur Candy do the rest of the talking :-) https://www.askideas.com/media/73/Gentlemen-you-had-my-curiosity%E2%80%A6-but-now-you-have-my-attention.jpg 
&gt;You say that we should require all developers to know all about how undefined behavior on their combination of compiler and platform will behave. No I don't. &gt;There is no useful case for a null reference or a null this pointer. I never say that there is. &gt;There is no specified code that can get you to a point where you have null reference or a null this pointer. Yes there is, which is why the behavior is undefined. If there was no code that could produce a null reference then any attempt to construct one would result in a compiler/syntax error. &gt; If you are debugging and you have a null this pointer or a null reference the code that produced it is wrong. You can't have it both ways. Either a null reference can't happen, or it can happen and you should understand how it can happen so as to correct your code to avoid it. &gt; Stop. Stop. Stop. Stop. Full Stop. I think I'll stop further commenting to your posts as you don't seem to have anything worthwhile to contribute.
This whole issue can be avoided by not using raw pointers for ownership semantics 
I don't remember where, but someone has said that `class` shouldn't exist and `struct` should be used instead. So I would suggest trying to follow that by not using the `class` keyword completely. One may hope that in the future it will be the default style. Same goes for 'class' vs 'typename' but there at least was a reason in the past (to use, not to be in the language).
I agree with the first paragraph, but I can't understand the third. It's like saying people driving cars should stop on each green light to ensure no one is crossing the road in this time. This assumption that no one will cross the road on red light is same as the assumption that no UBs will happen. And people driving without slowing down on green lights is an optimisation based on that assumption. You want to get rid of that?
I kinda disagree with you: - we have `std::array`, despite arrays already existing. - `std::ptr` is just a wrapper around a `T*`. Conceptually-wise, is there any difference? Any non-owning raw pointer can be replaced with this - with maybe small adjustments about template/methods called. - if `std::ptr` is an issue, we can use sth like `view_ptr`
Um, the code sample above is UB bait.
That would be good names for raw pointer wrapping - but here, we are looking for names for a non-owning pointer wrapper.
The day `new` is able to take a string and create a class corresponding to that string is the day where the factory pattern becomes unnecessary. Until then, there's not many ways to create objects dynamically - as in, input a string in a text field and have a corresponding class being created.
I don't believe it's guaranteed that a moved-from `std::vector`'s size is 0: a moved-from object is in a valid but undefined state.
Supportive link: https://stackoverflow.com/a/17735913/576911
Interesting. Thanks for the work and the release with a CC license. If I may, I have a few suggestions. In my classes, I introduce encapsulation, and invariants that are set in the constructors. Actually, I teach that _initializing_ the invariants is the role of the constructors. And that encapsulation is here to help maintain the invariants. Regarding copy assignment operators, there is no need to bother with self-assignment if the operator is exception-safe. Taking care of the self-assignment case just becomes an optimization in the improbable case `x = x` indirectly occurs -- I tend to consider this is a pessimization. Exception-safety is more important to teach along with assignment IMO. Self-move-assignment on standard containers results in undefined behavior. As such, I consider we should do the same with our types: no need to bother, nor to waste time trying to have a collection of strings able to support self-move-assignment. Indeed enforcing the interdiction with an assertion could be a nice idea, but it's one we cannot always apply when instead we define this operator with `= default`. Having a `[require: this != &amp;rhs]` contract, in C++20 hopefully, will be interesting. BTW, `Complex` presents no interest regarding copy, move and so on. These specials functions should have been not specified, or defined with `= default`. Students may in turn define these functions when we know the good practice is to let the compiler do its work. However, `Buffer` is a very good example. Unfortunately, the assignment operator doesn't provide the Basic Exception Guarantee. It's better, and simple, to provide the Strong Exception Guarantee here -&gt; 1. operations that may fail, 2. nothrow operations (among them eventually: commit/release). Regarding copy, I also introduce the distinction between _value classes_ and _entity classes_. The idea is that they are objects we need to be able to copy (and to compare), and objects where it makes no sense. A common pitfall consists in wasting a lot of time to implement copy on classes involved in public inheritance. I'd rather give keys to my students so they are aware there are two big (artificial) families of classes, each with a typical set of recipes to apply (make sure value classes in charge of resources are copyable ; forbid copy &amp; assignment in classes where identity is what matters, typically in classes involved in a public hierarchy). When I introduce public inheritance, I introduce the LSP. Without it, no inheritance could work correctly -- see the classic incorrect examples of SortedList &gt; List, ColoredPoint &gt; Point, Circle &gt; Ellipsis, and so on. It becomes worse when we introduce multiple inheritance.
I tend to think of the moved-from objects as only having to be destructible so wouldn't it suffice to just swap the contents?
If only the language was not originally named "C with Classes"....
unique_ptr 
Looks like the author used this as a case where the naively-expected behavior is usually observed. The circumstances where a conforming *and sensible* implementation doesn't seem pretty far-fetched. copy-on-write comes to mind, but that fell out of favor with multithreading. 
`std::thread`iirc. 
I think it sounds more like "stud" than as "stood". I'm not a native English speaker, though.
In an article of common misconceptions about move semantics, in the opening paragraph the author states a common misconception about move semantics as fact (that there is any guarantee that the moved-from state is the same as the default constructed state, in general).
[Some people might disagree with that.](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c8-use-class-rather-than-struct-if-any-member-is-non-public) &lt;semi-off-topic rant&gt; This is so typical for C++. People can't really agree on which subsets of C++ features should be used. "Modern C++ makes C++ easier to use" might be true but you still have to learn all the legacy stuff and how it interacts with the new stuff if you want to read and extend old code. Resulting in even more overall complexity. &lt;/semi-off-topic rant&gt;
I agree that in C++ there are some typical ways a pointer used by the compiler to represent a reference can become null. This is useful knowledge for understanding program errors. It's not particularly useful for understanding the C++ language. I think the disconnect is which we're talking about. Both are true though so no need to argue.
I agree with you on that point 100%.
We've used hacker rank in the past. The test is very basic and only a couple of hours long, and still many people don't pass. Using the test saved a huge number of dev hours. If half the people don't pass the HackerRank, that can be multiple hours per week you're saving your devs without any real chance of false negatives (the test is *very* easy). As an extra bonus, the test will scare off people who think they're too good to write it. I see several top level comments on this thread, who think this isn't worth their time, or it's "only for juniors". I don't want to hire such a person; you're hiring someone to try to add value to your business. While long term job satisfaction is very important, it's part of life that in the short term, very important but not exciting things come up that have to get done. You want someone who will do those things without complaining, and refusing to do a short HackerRank is definitely a negative indicator for such characteristics. I've interviewed people claiming all skill and experience levels, sadly for whatever reason no matter how amazing someone's resume, how much experience they have, or even how impressive they sound in a 5 minute general phone conversation, they can somehow manage to just be completely terrible. Really good, experienced developers have hunted for candidates themselves and they understand this is true, and won't fault you for taking basic steps such as HackerRank.
Author here. Thanks for the comment. This is a very good point. The intent was not to imply any strong guarantee, but to have a trivial example about move. I modified that paragraph to mention that the zero size is not guranteed. Btw. is there a way to observe from a vector (or other container) that move have occured without relying on the implementation details (e.g. size being zero afterwards)?
&gt; I don't remember where, but someone has said that class shouldn't exist and struct should be used instead May have been me? I've been ranting about this for years.
Maybe, I'm pretty sure it was on CppCon
&gt; my_new_object = (it-&gt;second)(blah); // calls new behind the scene &gt; Sure looks like you know the type here.
I could imagine, for instance, that moving a string that is using small string optimization has no real need to blank out the old string, since it would have to be fully copied anyway. 
I have to wonder why? Does the bang (!) syntax displease you? It follows so many other special operators for all sorts of things. (*, -&gt;, ^, . ) Fixing the Boolean operators to be **not**, **and** and **or** would just make those operators look un-idiomatic, no?
What on earth was their reasoning for calling it lvalue, rvalue, and xvalue? Left Value, Right Value?
In the CPL programming language, it was indeed "left" and "right". C tries to reinvent lvalue as "Locator Value" but that didn't stick.
You are still required to stop on a green light if you spot someone crossing in front of your vehicle, and you are also required to maintain a constant watch for people possibly getting on the road - even in places where they aren't allowed to do so, such as at a red (for them) crossing. The complaint that people have about UB is not that people might get run over when they cross on a red light. The complaint is that the C++ standard allows you to visit such individuals at their house, and shoot them, if you can prove they will run a red light later that day. 
Facebook's folly library did _not_ do that for their `fbstring`'s small buffer, back when `fbstring` was their own implementation. (I believe it's now just a `std::string` under the hood) By not doing it, we didn't notice a bug in our code that was incorrectly calling `std::move` on an `fbstring`, because it wasn't getting cleared so it appeared to be working fine... until someone finally used a string that was bigger than the small buffer. Of course I can't blame `fbstring` - it was our bug obviously, and folly generally tries to avoid doing any extra work. But we ended up modifying it in our codebase, just to detect these types of errors.
Yeah, I wanted to phrase it as "a common misconception in articles about common misconceptions about move semantics" but managed to restrain myself. Or not ;-).
This is bullshit because that implies it is sane to do transformations that are supposedly safe in the absence of "bad" things in the code, whereas it is known by advance that there *are* undefined behavior in non trivial codebases, and they are probably even full of them. You can be in denial if you want, but that is just what it will be, given the comprehensive list is not even known, and that tools exists even less for checking for them (comprehensively, a small subset is of no interest for the discussion about the approach we are talking about) Compiler themselves are not clean. I suspect that there is currently no-nontrivial clean codebase in the world. This approach would be valid if the compiler did actually prove that the transformation is without risk. Given the language, it is basically impossible in the general case, so compilers should limit themselves to *special cases* where they can *actually prove* it (instead of just "proving" it), or do not do that kind of shit at all. The standard does not forbid compilers do actually define what it describes as "undefined behavior". Except for code bases with no consequences (video games) or code bases so clean that the maintainers know they can enable dangerous (in the real world) optimizations (and most of the time, they will be actually be wrong) -- it is insane to silently enable amplification of a whole classes of bugs and security holes to deploy to the world, and enjoy the resulting mayhem.
The assumption that (some) compilers make is that it is "safe" to do any optimization authorized by the absence of UB in source code. This is completely insane, given it is *known* that clean code bases actually virtually do not exist. Some compilers have real clients and use a more cautious approach, BTW.
This one by any chance? https://youtube.com/watch?v=ovxNM865WaU&amp;t=3180
I'm surprised that no one wants to "replace" MACROS with "the magic wand", just image what cpp would be like if instead of having macros as code generators we had static reflection from the beggining.
Isn't this the point of the article?
libc++: https://wandbox.org/permlink/8fw5Hv9ZGvcGMot6 VC++: http://rextester.com/ISUF21911
Actually, your link says that the first vector will be empty: &gt; So for the move constructor, yes, the moved-from vector will always be empty
Oh wow, I should have looked into that more before going on. I never made the connection of what side it's on, but after reading into it now, it makes much more sense. Thanks! 
`std::plain_ptr` because it is just a pointer (like a raw pointer), without added semantics. Or `std::simple_ptr`, `std::basic_ptr`. 
Wow! I had missed `std::apply`. I've got some machinery to clean-up...
I’m curious about the compilation time of the different approaches. Guess that integer sequences might be faster. 
The term "moved-from" is ambiguous. ``` X x1; X x2 = std::move(x1); // x1 is moved from by a move construction X x3; x3 = std::move(x2); // x2 is moved from by a move assignment ``` There are even more ways to put a type into a moved-from state, but the move constructor and the move assignment operator are the usual suspects.
Ooh, you are correct. It's `folly::dynamic` that got changed to using `std::string` instead of `fbstring`. My mistake.
No I think what has happened is that you have lost the argument, so you are making up a bunch of nonsense in order to try to get the last word in, then saying you are not going to reply to anything further because further replies will only dig you further into nonsense.
If I write some code and changing the optimization level makes the code no longer do what it is supposed to then the compiler does not specify what that code does. That code is not reliable and should be fixed to make it reliable across optimization levels. Why don't you try answering the question? Do you know of a compiler that has a documented flag that controls the behavior of "null references" or null this pointers?
I don't really want to try to decode whatever secret messages you're trying to send me via your choice of nearly-equivalent constructs. Will I be expected to be attuned to the Kabbalistic implications of your choice of `while (true)` over `for(;;)` next?
It all could be avoided if only they named it as what it actually does, like std::make_movable.
Yeah, I never go above 2... and honestly even 2 is pushing it... But this example is crying for a ternary.
Should it not be easy for C++ compilers to build in some debug checks if a moved object gets touched by anything else then the destructor?
only the most basic case of index_sequence has been supplemented. It still allows slicing, reordering, etc... std::apply is great because it was a way to common use case not to be part of the standard.
One nice thing about having index_sequence in the standard, as opposed to implementing it yourself with template metaprogramming, is that some compilers actually directly generate the sequence as a special case and that can speed up compilation.
Since C++17, there is no `class` keyword in my codebase. I use struct as typename. struct simply because they are usually less verbose for my use cases (public inheritance) and typename is just more descriptive for what it is.
There is no mention of union, so far as I could tell.
By "debug checks" you mean compiler warnings? I assume that compiler vendors would consider that more of a static-analyzer's job to do... when you consider that the warning would only be checked when the variable is used _later_ (not when it's moved); and it could have been conditionally moved based on other decision logic in your code, and thus mean keeping track of the variable's state and logic paths in the function. 
Yay... a straw man... Inspecting code that has no conventions sounds like no fun to me. If I saw int foo(int *a, int b[], int index) { return a[index] + *b; } I would be annoyed even though it compiles.
I'd bet they are pretty close. `std::apply` uses the same intrinsic under the hood.
That's... not an opportunity I see as valuable. Now, instead of code telling me what happens, I need to know about or otherwise intuit your convention(s)? Add to this the fact that surely everybody has slightly different heuristics for choosing `class` vs `struct`? I will happily pass on this opportunity. I'm skeptical that _any_ convention imparts more readability than even random selection. This is post-hoc rationalizing a language quirk. Nothing more.
Is there a way to customize mapping to C++ types. It's disappointing that records and unions don't map to a C++ type that doesn't have a bunch of run-time overhead. Take a look at std::variant and boost::hana::map.
I certainly welcome suggestions, and thank you for your comments. When I first started developing these slides, they were geared towards students with more limited programming abilities. For this reason, I was often trying to avoid data structures with pointers in examples so as not to possibly confuse students who do not have a good grasp of pointers. As the slides have evolved, however, they have started to target an audience with a much wider range of programming abilities (including more advanced), in which case some of the examples that I am using in certain contexts are too simple. I think that the Complex class that you mentioned is one such example. Historically, when I want to really teach move semantics to students, I just jump to the section on rvalue references (and skip the related material in the classes section). The rvalue reference section has much better examples for move semantics than the classes section. In any case, I have been thinking for some time that I should move some of the material from the rvalue references section into the classes section (e.g., move construction/assignment examples). What you have said makes me think even more that I should consider this possibility. Again, thank you for all of your comments.
F# has language-level zero-overhead units, but they only work for primitive arithmetic types. :-[ There's so much to be said for a language where this is possible to implement as a library...
Your zip looks like cartesian product.
&gt; Btw. is there a way to observe from a vector (or other container) that move has occured Not for any standard type. In general, adding an ability to check moved-from-ness would imply a cost in time or space. Imagine a `unique_ptr`. Under the hood, it's probably just a raw pointer. That raw pointer's values could be an object or it could be `nullptr`. To flag a moved-from state, you'd have to either pick a new "sentinel" value for this pointer (and then add runtime costs in checking this pointer in your `get` member function and so on), or you'd have to add some space to the smart pointer (adding some extra bytes that could store flag bits). That'd be uncool. Now extend this to containers. `vector` could/should just be a few pointers (`first`, `last`, `end`), `map` could just be a root node pointer, etc. The majority of containers just don't have any reasonable place to store extra state without some kind of cost. Since one can't detect moved-from-ness on very common containers like `vector` it then doesn't necessarily make sense to make this detectable on any container. The only use case would be if you had some kind of generic algorithm that would necessarily depend on a `ObservableMovedState` concept *and* which couldn't just be implemented for containers like `vector` or `map`, and that eventuality seems... unlikely.
Another way to put it: it's the ownership that moves, not the object.
That makes sense, but it is not a quote from Bruce Lee, so I might need to downvote anyhow. (not really)
online assessments of this nature are stupid. I once took a C++ assessment and was told I had scored higher than anyone they had ever seen. Which made me laugh because I thought the assessment itself didn't even touch upon anything I'd consider advanced. In fact, one of the answers they marked was wrong was actually right and I ended up filling out paperwork explaining why it was wrong. These tests are not created by experts, they're created by people doing the minimum they can to make a buck. The company is trying to make money, and their employers are trying to make money. I've never seen one of these tests that impressed me, ever. I've never felt like they've done anything other than made someone somewhere feel good about ticking a box. They're basically mental masturbation and a means of making money for specific companies. I would stay away from them.
I don't think the variable names had anything to do with their point...
Agreed. Showcasing `std::apply` is nice, but the title kind of ruins it for me – `apply` in _no_ way replaces `index_sequence`.
N.b. if you do you implement your own `integer_sequence` for some reason, you can use the same intrinsics as the standard library implementation for the same benefit; e.g. Clang and MSVC's `__make_integer_seq` allow you to specify which template to specialize.
If your classes start with public you should use struct.
The thing is: the undefined behavior has become lingua franca of optimization and it is used to essentially steer the optimizers. And there's no other way of doing that that would be similarly clean. E.g. lots of long template expansions often get wiped out because they can use undefined behavior to wipe themselves out of existence. `#pragma` doesn't work for obvious reasons (it's not code), and the community is figuring out what they shouldn't be doing.
I designed it that way for that reason :-)
Yes, you're preaching to the choir.
One thing I don't like when everyone explaining "difference between struct and class", "when to use struct and when to use class", etc., is that they never make clear the subtle yet important the distinction between these concepts: - "struct" as a name of a language feature - "class" as a name of a language feature - `struct` as a language keyword - `class` as a language keyword - class declared with class-key `struct` - class declared with class-key `class` "struct" and "class" are nouns. As names of language feature, they are *synonym*. They are names of *one single language feature*. In this case, talking about "difference between a struct and a class" makes as many sense as talking about "difference between the Batman and the Dark Knight". `struct` and `class` as language keywords are what they are: language keywords. They are not language features by themselves; they are associated with language features. Sometimes, we use the nouns "struct" and "class" to mean classes declared with class-keys `struct` and `class`. This split of usage, comparing to their [original meaning](https://en.wikipedia.org/wiki/Semantics), is [pragmatic](https://en.wikipedia.org/wiki/Pragmatics) for obvious reason. In this case, it makes sense to talk about their difference, but it still causes misconception if we do not make clear they are in fact *one single language feature*. ----------------------- Although this article is worth reading, one thing I want to notice future readers is the potential confusion caused by: - not making clear the distinction, and - shift of meanings of words too subtly The article seems to be using "struct" and "class" as nouns meaning classes declared with class-keys `struct` and `class`, but without emphasizing they are in fact *one single language feature*. Another issue is, when using "struct" and "class" as nouns, they are formatted as code. This grammatical issue may worsen the confusion. Further down the discussion, this article subtly shifts the meaning of the two nouns and introduce new pragmatic meanings: class designed as a bundle, class designed with invariant. ----------------------- This is not a nitpick. The distinction is important for C++ programmer, not just when we reason about program code, but also when we reason about written and verbal discussions. As mentioned in the article, meta class is coming. If we don't make clear struct and class are *one single language feature*, we will unintentionally confuse people into thinking each meta class introduce a new language feature. No, it does not.
We're not talking about the new company janitor. This is an investment in a relationship that will, as I said before, potentially last years, and potentially be worth millions. You can do an initial interview with one interviewer. I'm not going to apply for jobs where I never even see a human being. Don't forget: in an interview I also get to ask questions, get some feel for what working for this company is like. It's not a one-way street. Doing online tricks puts the entire initial investment on me, and there is nothing stopping companies for asking for a ridiculous amount of effort at a time where I might just be one out of hundreds of candidates. Check out the story below where someone was asked to spend six hours(!) solving online puzzles. Excuse me, but that's almost a full working day! If you agree to my hourly rate I'll be happy to solve your puzzles. Oh, and what are the odds that those online puzzles are really math puzzles, without any relationship to the actual work for which I'll be hired? 
It's a pretty bad example IMO, the main use I've seen for tuple apply has been in storing a parameter list from one variadic call for later execution (or punting to another thread), or certain kinds of reflection APIs. You can't use `for_each_tuple` if you have to execute a single function.
Wow TIL. I assumed it was a C'ism. imho calling an rvalue a "temporary" (like a variable in the register of the CPU that hasn't made it out to RAM yet) and calling an lvalue a "reference" is clearer, but no one seems to call them that for some sort of reason.
I'm actually not so sure. I've seen relatively few cases, where any function other than operator= is used on a moved from object. And yes, I can probably construct dozens of valid counterexamples but again - few in production code. I guess, what I'm trying to say: I'd be happy to annotate the few cases, where I deliberately use a moved from object, if my static analyzer in turn warns me of all cases where I use a moved from object accidentally.
&gt; You can't use `for_each_tuple` if you have to execute a single function. I have no idea what this means.
The line between a compiler warnings and static analyzer's job is quite blurry. Many warnings generated by modern compilers have nothing to do with formal semantics and everything to do with detecting potential bugs. Case in point: http://coliru.stacked-crooked.com/a/5ae7794191fec7b1 &gt; and thus mean keeping track of the variable's state and logic paths in the function Compilers already track pretty much everything.
xvalue zna other are required for understanding of move semantics... maybe they were not intended this way, but they are often mentioned in popular introductionary articles.
I've seen `.clear()` used on a moved-from object in production code. It is semantically equivalent to the use of `operator=`. So is any other function that has no-preconditions and sets the object to a known state.
https://stackoverflow.com/q/21358432/576911
Interesting. I think I'm decent at cmake but I've never seen this advice before. Mind sharing a few examples?
Yes, totally agree, I tend to think of `apply` like the splat (`*`) operator in python. This usage of it is rather odd.
Is there a VS 2017 version?
Using it really make the code a bit complex, and I try to avoid it as much as I can. Complexity is the main lead to bugs errors that are very hard to be detected unless you use on of those programs, such as cehckmarx. That's why I prefer practicing a lot.
&gt; &gt; &gt; But that would be more expensive run-time, penalizing everyone else who "follows the rules" and properly declares their class functions as virtual or not. Why should one be at the expense of the other ? We can just have a flag that enables a "safe" mode which adds checks everywhere and aborts on error.
foreign_ptr Clearly not yours. Clearly not safe to delete. Not too long. 
You dropped this \ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¯\\\_(ツ)_/¯`&amp;#32;or&amp;#32;`¯\\\_(ツ)\_/¯` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
C++ is a language of function over fashion. Haskell may instead appeal to your aesthetic preferences.
You're not explaining clearly enough.
idk I wouldn't call the length of function/type names a function vs fashion issue, more an ergonomics issue.
Too far. Too far...
&gt; I think it would need an overloaded constructor taking a T const&amp; for std::forward to work. Forwarding references will bind to const lvalue references, so I think it will still work (assuming `T` is copy-constructable).
How is the name `std::reference_wrapper` a necessary evil? `std::reference` or even just `std::ref` would've worked just fine.
Cool video, I'd like to see more complex examples though and maybe real world usage.
&gt; The way I see it, a dependency manager should be: &gt; Decentralized Have discovery and aggregation features that are or feel centralized, so that end users don’t have to handle URL/URI. Impervious to the loss of nodes, robust and transparently mirrored Based on strong security foundations Orthogonal to build systems Only handling sources, not binaries Easy to use for a variety of use cases. Doesn't [Conan](https://www.conan.io/) already satisfy most if not all of these requirements? It even goes one step further, it handles both sources and binaries. If a binary package built with specified options is available on a remote server, it will download it for you. If not, it will get a recipe and compile it locally. You can then optionally upload it to your server to save time when working on another machine with the same configuration.
Seconding this. Together with CMake it solves pretty much everything. And binary support is important, otherwise you would have been stuck managing third party closed source dependencies manually. And you can always force rebuild from source if you have it available and don't trust the binaries anyway.
&gt; We still don’t even know how our mythical tool would work, but we know that it needs to be authoritative. We can’t afford multiple systems, because then different projects would use different, incompatible systems, and the initial premise of easily including any dependency in a project falls flat. We need exactly one package manager. I disagree. There should be a uniform "package" format and description, certainly. However this does not preclude: - different tools manipulating either, - different hosting services, - ... If anything, I'd rather have multiple tools and services. Competition is healthy.
Classic.
Eh, `reference_wrapper` is pretty self-documenting to me. `std::ref` is already in the STL though as the helper factory function.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/81sk5g/i_need_help_with_visual_studio_2017_its_drives_me/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I may be misreading the CMake documentation but it seems to be suggesting that if the FATAL_ERROR is dropped, then older versions of CMake will only generate a warning instead of an error from the cmake_minimum_required command. If this is the case, I think that an error is preferable. In particular, the page that you cited reads, in part, as follows: &gt;The FATAL_ERROR option is accepted but ignored by CMake 2.6 and higher. It &gt;should be specified so CMake versions 2.4 and lower fail with an error instead of just &gt;a warning. I don't know if I am interpreting the second sentence above correctly, but it seems to be suggesting that FATAL_ERROR is needed to make old versions of CMake fail with an error from the cmake_minimum_required command (instead of only issuing a warning) when using a CMakeLists file that is too new. Again, I may be misinterpreting the above text, and you may well be correct that there is not benefit whatsoever to including the FATAL_ERROR.
There is a mechanism called dependency overriding, so that at A you can force B to depend on C v2. 
From twitter, to continue here: &gt; @pauljbaxter wrote Mostly agree, but I think you will need to support closed source binary dependencies too. Generally though there are a lot more parts than you describe. e.g signing, 'version' specifications like '&gt; 1.2.*', use of revision tags as well, etc, toolchains, build type abstractions. &gt; @Cor3ntin wrote: Binary dependencies is a huge, huge can of worms, imo not worth dealing with. A standard pkgconfig-like format so you can point _any_ build system to the dependency is all I think we need for that. &gt;&gt; @pauljbaxter while I agree its a PITA, separating source dependencies (built to order), binary dependencies (is it compatible with my build requirements) and test/environment dependencies (system packages or IAC) allows each to be treated differently &gt; @cor3ntin toolchains are only a build system concern. But we still need a way to describe a toolchain so we can fail gracefully when a given dependency is not compatible with the target. &gt;@pauljbaxter Not necessarily, particularly for selecting binary dependencies that you may have variants to choose between (arch, abi, std lib) 
No if isn't null for every practical purpose. A practical purpise of a null pointer is doing if(ptr) -- and for that it isn't null. 
It is absolutely overzealous. We have the final keyword now. The diagnostics are not perfect: https://stackoverflow.com/questions/26321216/clang-gcc-dont-warn-about-non-virtual-base-destructors-for-polymorphism-when
&gt; I'm not bashing Conan BTW, I'm very impressed by it. It wasn't me who downvoted you. &gt; In this case the referenced capability is a bit of 'tail wagging the dog' Not really. The root of dependency graph is exactly the only place that has sufficient information to decide how to resolve dependency conflicts like this. &gt; I want B to define what it is tested with. The only way for A to use a newer version should be if B is upgraded and tested to use a new C (openssl) &gt; While conan's approach of overriding the transitive dependencies is appealing, it is also dangerous (though mainly only when a package breaks backward compatibility). True, but like this you can try it and see if anything breaks, while otherwise you would essentially be locked out of upgrade until the dependency decided to do it. 
First of all, people must change their minds about package managers. Now people says "I will wait till one package manager win over others" or "the best package manager is tarball". If you are author of some open source library please adopt ANY package manager, so community will be more familiar with package managers. So far i have heard about: buckaroo, cget, conan, conda, cpm, cppan, hunter, vcpkg.
Btw. it would be nice if someone explain how to use CMake External_Project and how to prepare my library to be easy to use with it :P
-O2 is great, but -Og is :/ https://godbolt.org/g/irB3tW
https://www.reddit.com/r/cpp/comments/7yps20/its_time_to_do_cmake_right
Yeah, it's a bit verbose without inlining. I wonder if forced inline could help.
This is embarrassing, but how do I actually see the console output of this (or any) C++ program on Godbolt?
I just use wandbox if I want a quick online compiler that can show output
&gt; One annoyance with the debug mode is that it changes the size of some standard class templates, so you cannot pass containers between translation units compiled with and without debug mode – this often means that you need to build the whole application with debug mode enabled. Not just that, but all the application's _dependencies_, too.
Note that we do have plans to add execution support *soon*
Yes. Which is a good thing IMNSHO. There are **way** too many ways to fsck things up and the debug runtime is a boon in finding them out. In my work, we build dependencies in 3 flavors: *\_NDEBUG, optimized * \_NDEBUG, -O0 * \_DEBUG The second one is to help analyzing core dumps when they happen (once the optimizer gets its hands on the code, they are harder). The third one is for development, obviously. The edit/build /test(debug) cycle runs on that.
While that's great software development practice it has little to do with the post or my comment. To ensure ABI compatibility for standard library containers between translation units between your application and its dependencies, your application's dependencies must be compiled with `_GLIBCXX_DEBUG` (and the dependencies' dependencies, and so on). Note this is separate from whatever other debug modes you may have in your application. This applies only to the standard library.
are threy any plans to be included in C++20?
I think the OP wants to get Base if the varient is either A or B deriving from Base. 
There is a paper by one of the authors at http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0645r1.html. So, who knows?
In a reasonable language, shouldn't one be able to implement a simple thing with simple code? Is that not self-evident? Can one look at the std::tuple or std::optional implementation and not conclude that the language designers have made terrible mistakes, and recognize that these particular implementations only work because of a chance alignment of ad hoc feature additions?
Portage is completely compiler agnostic. The only thing (that I know of) that would make it difficult to run portage on a windows system is getting an implementation of Bash that portage was happy with. There's always the cygwin bash, or the msys2 bash, or some Midipix based port of bash some day. Portage is also completely build-system agnostic, so it could be made to us MSBuild or whatever similar microsoft-centric build system, or cmake, or a proprietary build system, or name your favorite build system. One could even embed the build instructions directly into the ebuild as a bash script, but probably you wouldn't want to do that, it'd be pretty verbose. It's also package format agnostic. You can convince portage to whip up an MSI just as easily as you can get it to make you a tar.gz. Of course, that capability isn't built into the portage specification itself, but just a consequence of portage being able to give you a filesystem tree of the files from your compiled package. Shouldn't be difficult to make an MSI from that, I hope. Portage can *basically* do it all. But even though it's so flexible, it doesn't mean that it's unreasonably difficult to use. Since portage has great defaults set automatically, for the majority of new packages, it's just a matter of 10-20 lines of configuration to get the package working out of the box. It's great.
What do you want that [Outcome](https://ned14.github.io/outcome/) doesn't do?
Outcome seems promising but I'm still bummed out the monadic API was removed
[Yup](https://www.reddit.com/r/cpp/comments/6me836/outcome_v2_is_feature_complete/dk23lvz/?context=2).
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://www.reddit.com/r/cpp/comments/6me836/outcome_v2_is_feature_complete/dk23lvz/?context=2) - Previous text "Yup" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
This is really cool. I have been wanting to change the structure of a test suite which relies on external binary resources from using a resource directory to compiling the resources into the executable. I was not really sure how to achieve this in a simple and efficient way but it looks like this project meets my exact needs. I look forward to giving it a try when I have time.
The proposal does suggest higher priority for network, ranges, concepts and moduels over graphics. It's on page 9 and 10.
Based on the title, I was hoping that the ISO C++ standard specifications would become "free as in beer".
Not a C++17 feature, but the page showed an ad for the "C++ Kompendium Wiedzy". That's clearly Polish for "C++ Witcher's Compendium", a collection of ancient monster-slaying wisdom by that most famous of Witchers, Bjarne of Stroustrup. Also known to some by his dryad name of Maelbleidd, or (less famously) as the Butcher of Kona, following an unfortunate incident involving an uninitialized variable and a laser pointer. 
&gt; It's actually even easier than that, as structured bindings work out of the box with objects of any type (and arrays) :) They work out of the box with many types, but not *any* type. For example, simply having a protected or private data member will stop "out of the box" bindings to happen. Inheritance and anonymous unions also interfere with "out of the box" bindings. However, specializing the customization points `tuple_size` and `tuple_element` always work.
Oh, didn't know that. Thanks :)
To me the most annoying part is that coroutines are not highest priority. 
About `if constexpr` you wrote: &gt; There are no branches (jumps), multiplications and other instructions that should be present if if wasn't a constexpr. Actually, in this particular case replacing the `if constexpr` with a regular `if` produces the exact same assembly code, as you can see in https://godbolt.org/g/Xbupba. In this case the optimization triggers from the fact that the variable `x` is `constexpr` and the compiler is smart enough to apply the optimization to the both versions of `if` (you would get the same optimization in C++14, by the way). The main difference between `if` and `if constexpr` is that the branch that is not selected is *discarded* so it can contain statements that would actually be ill-formed. This is mostly useful in template. Non-template code de facto gets very little from `if constexpr` beside the fact that the condition is actually checked to be a constant expression.
As far as I know std::expected is like std::optional and does not support monadic error handling, that is, some way of chaining functions.
I remember Howard Hinnant adding a debug mode to libc++ which had the explicit goal of preserving ABI compatibility and allowing linking with libraries for which the debug mode was not accessible. This was years ago; I wonder if the project ever was completed.
There's an https://github.com/Dobiasd/FunctionalPlus library, which should allow that, but personally I haven't gotten my hands on it yet
I'm all for specifying an std.graphics, but based on CAIRO? A C library? And has anyone ever looked at the ugly proposed C header synopsis?
Comments I intended to leave on the blog itself, but wordpress doesn't like me today. --- Explaining what std::move does (and does not do) is great, but it'd be good if the examples were more clear about "you shouldn't generally do this." Also, strictly speaking there is no guarantee that a moved-from vector is going to be empty. In any sensible implementation it will be, but the only standard library type that actually gives a post-move guarantee is unique_ptr - the rest are merely defined to be in a "valid but unspecified state." Calling .size() (which has no preconditions) must be valid, but relying on its behavior isn't necessarily a good idea. We should really be trying to teach everyone to instinctually avoid anything that is moved-from (or specifically, referring to anything after std::move has been called on it). Compiler warnings / static analysis will never be perfect at catching that, we do sorta need to rely on training and code review, and the #1 important part is to discourage use-after-move. abseil.io/tips/77 hits a lot of this.
That’s cool. Remember what it was called?
Coroutines are very high priority, but should also be given time to bake. There's an idea floating around that they can be used for monadic error handling / control flow in addition to the asynchronous use case they were initially proposed for - but doing so efficiently (no allocation / vtable overhead) requires a bit of additional work. Finding the balance between "this does a great thing" and "this does all the great things we can ask of it" (to say nothing of "this won't need changes anytime soon") is hard - much as I'd like to see more valuable things progress out of the standard, it does have to be *right* first.
&gt;&gt; Do you think it is acceptable? Acceptable by who? If it's your own project, do anything you like. Which style is not that important, consistence is the most important. Take myself as an example, in my own project, I use Java alike style, CamelForClass, snakeForVariableAndFunction. But when I work on existing projects with different style, I have to follow them, such_as_this_though_I_dont_like. Consistence is the most important.
&gt; Which style is not that important, consistence is the most important. So true... I was just worried that I would make myself look fool with non-standard convention, but I feel much better now.
I don't know fmt but its website is so bad too me that I couldn't find what to #include.
Can we please not make this about the GUI again. There have been more than enough threads about that topic in the last couple of days/weeks
Just curious: Is it actually important for you to have the exact wording for free or just nice to have?
Or like... "find()" failing because the object wasn't in the container. 
You should include `&lt;fmt/format.h&gt;` as the doc say (http://fmtlib.net/4.1.0/api.html#format-api). In the trunk (master) you can include `&lt;fmt/core.h&gt;` instead which is more lightweight (`fmt/format.h` works too).
The author here. Can't say if it will make to C++20, but I'm going to the standards committee meeting in Jacksonville in about a week to present the second revision of the paper.
It would have never passed the Boost peer review with a monadic API intact. Besides, the way forward is a monadic programming library which works with `ValueOrError` Concept matching types. Something general purpose.
What does monadic error handling look like?
On your own projects, you can use whatever style you want. There are a few things to keep in mind: *the style should enhance clarity. *Being reasonably consistent helps with clarity. *Don't let minor inconsistency cause anxiety. *Part of the above involves identifying when the style rules have started to worry about trivial matters. 
This is a fairly common problem on windows, most developers are familiar with /MD, /MT, /MDd and /MTd and the pain of getting the right combination. But honestly, it’s a godsend and absolutely worth it when things go wrong. 
Haha, TIL clang is not a real compiler... Geez... if you guys hate optimisations so much just turn it off and stop harping about UB to everybody else.
You use the style of the standard library, so snake_case in the case of C and C++. Consistency matters.
&gt;This is a variant of the “Don’t leave room for a language below C++ (except assembler)” rule of thumb from D&amp;E. A consequence of this rule that I dislike is that a few times I have wanted to see what the abstractions in my code compile to. I have one way of doing this (that I know of), examining assembly code. I suppose I could search through the abstraction chain; however, that has frequently led me on a wild goose chase. Unfortunately, my knowledge of assembly is not that great so it would be nice if there were a way to resolve the abstractions and see what happens in C++. 
Indeed, snake_case is the C++ style. Anything else is being deliberately inconsistent. Readability is mostly about what you're used to anyway so the style shouldn't matter. Just use the style the language uses. So CamelCase for Java/C#/Haskell and snake_case for Python/Rust/C/C++
Unlike other languages where people tend to stick to the official style, in C++ there is a tradition of inventing your own. The Google C++ style guide is from a time when it was popular to write Java in C++.
While everything you say is true in this particular instance it is not guaranteed for more complex expressions. I believe using if constexpr forces the evaluation at compile time, whereas a plain if is relying on the optimizer to figure it all out. IMHO If constexpr is so awesome because it will fail to compile in the face of non constant expressions. so in two years when I make a change to the code that turns it into a runtime expression then that if constexpr will fail to compile. This is huge for maintainability. 
You can always turn optimisations off, or use O1 if you feel so strongly about it. Most of us actually want compilers to provide this kind of optimisations. You’re not asking for a safe optimisations switch... you want everyone else to abide to your safety approach. This is the actual bs on your point.
Alrighty then!
One of the problems with teaching C++ is that it is often conflated with a course on general data structures and algorithms. C++, in this context, is only a tool; the goal is to teach linked lists or quicksort. Unfortunately this means that many people believe C++ _requires_ the programmer to write these facilities by himself. But why isn't C++ programming a subject by itself? As the world's language of choice in quite a few fields, and given that so many people agree it is a difficult language, surely just learning C++ should provide sufficient material for a course? That way, one can at least start from the modern end. While it isn't necessarily a job for the standards committee, it would be good if there were 'official' materials online for learning C++, for different levels of audiences, from self-taught beginners to university-taught courses and everything inbetween. Maybe such a thing already exists, but judging from when people ask about learning C++ here in the group there doesn't seem to be a canonical answer to this yet. Also, I'm worried about chapter 6 of the document. It's sad that such a section was deemed necessary. 
&gt; This analogy is flawed. Restricting to C has (in theory) the ability to teach the beginner how the underlying computer works and operates. That can get abstracted away by teaching C++ directly. Teaching someone Beowulf or the Canterbury Tales does not really teach the student how English works. That is usually done by teaching: parts of speech, proper grammar, sentence diagramming (one of the few things in English class I liked as I was really good at it), etc.,... The question is whether your goal is to teach how the machine works or how to properly program in c++. And in any case: While c++ has features that are farther away from the machine, you can demonstrate pretty much anything in c++ that you can in c. What I do understand is the argument to start with a smaller set of language features though- but again, you don't need a c-compiler to write simple code that doesn't use any advanced c++ (although that wouldn't teach people how to write proper c++ of course). 
Try niether https://github.com/LoopPerfect/neither 
The real question is: Would you eat some haggis to have parallelism in your code?
Thanks for your work and dedication!
I like it
C++ has been basically paying my bills =). It's the least I can do to pay back the community.