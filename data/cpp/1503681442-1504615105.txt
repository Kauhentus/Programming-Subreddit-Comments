Sure, I was just using the one variant case as an example; similar things come up in many other contexts. I also think that this is where a performance hit hurts the most; a single variant is the most common case and if it costs more than a switch case then it's definitely not a zero cost abstraction. You can implement multiple variants with switch case + recursion though I don't know how that would compare performance wise to current techniques.
I was aware of such workarounds, but I'm impressed that clang is able to generate such good assembly. At first I thought it was maybe only going to work in the case where the functions did something trivial like return a constant, but when i changed the example to call arbitrary functions: https://godbolt.org/g/t2xmCm it still worked. Maybe a reasonable stance is that this workaround is good enough once compilers generate equally good assembly for it (which can't be that bad if one compiler is already doing it). Edit: I was able to somewhat abstract this out nicely: template &lt;class T, T ... Is, class F&gt; auto compile_switch(T i, std::integer_sequence&lt;T, Is...&gt;, F f) { using return_type = std::common_type_t&lt;decltype(f(std::integral_constant&lt;T, Is&gt;{}))...&gt;; return_type ret; std::initializer_list&lt;int&gt; ({(i == Is ? (ret = h&lt;Is&gt; ()),0 : 0)...}); return ret; } int g3(std::size_t x) { return compile_switch(x, std::make_index_sequence&lt;5&gt;{}, [] (auto i) { return h&lt;i&gt;(); }); } Which produces equally good assembly. There's some non ideal things here like requiring the return type to be default constructible, but still not bad. Once gcc optimizes this, it will be quite a decent technique.
Herb Sutter's deferred_ptr might deserve a mention. https://github.com/hsutter/gcpp https://www.youtube.com/watch?v=JfmTagWcqoE
You cannot call XAML from pure C++ code until C++/WinRT gets proper support, only from C++/CX, WRL (ATL replacement). Although no .NET is required for UWP/XAML, C++/CX still isn't as easy to use with XAML as C# and VB are. For example, you need to manually keep track of the event handler lifetimes and use the concurrency library.
Mixed? It's about a C# app that's using the API provided by Microsoft. The guy is not writing C++ code.
I'm not talking about XAML. He said there is no other option to build GUIs using C++. The Windows API provides a way. Now if it's a nice API or a shitty API is another matter.
But that's an option you can use and many desktop apps use it. Now if it's hard, if it's a shitty API, etc. is another discussion.
I personally prefer template or the type system in general to remain purely functional. In fact I would argue for the removal of the one non-expression/statement that it has (constexpr if) and replacing that by a constexpr pattern match operator (error states Ã  la static_assert are a different matter). The more complex templates get, the more compile time we get - and we definitely already have enough of that. Introducing state like in a switch statement is a prime example of "complicated".
&gt; There's probably no legitimacy in having both, even though there might be use-cases of unique_ptr where its move c'tor is not needed. `scoped_ptr` is the least error-prone and most semantically-direct smart pointer; there's no good reason to deprecate it as it has no real drawbacks (if one needed movability it wouldn't have been an option in the first place).
Only if the caller passes an lvalue instead of an rvalue; the latter will move, not copy.
There was also a [root_ptr](https://github.com/philippeb8/root_ptr) though you don't hear much about it.
That code is the equivalent of loading a gun and shooting at your head. You need to check against null before defining that reference. If *p is never null, why even use a pointer in the first place? 
Yeah, but not everyone wants to create new applications based on a what is becoming a legacy API, alongside MFC and WTL. XAML is the official new way for C++ applications for Windows 10 and later, unless Microsoft changes their mind.
What? Yi Zhang said what was the problem from a .NET developer perspective: &gt;When developing the Windows Store app platform (and then UWP), we realized that having cycles would be a huge adoption blocker for people writing .NET apps using WinRT API, especially with XAML objects. We worked with XAML team and developed a technology together so that XAML can inform the CLR GC with missing reference/edge information between CLR and XAML objects. And with that, GC is able to resolve cycles between CLR objects and XAML objects, with the complete graph information. I think this is in line with what you are seeing - if you are using CLR objects with XAML, you don't need to unsubscribe the events and there is no leak. &gt;Unfortunately, the C++ custom controls doesn't have the technology to inform GC of such missing references. And more interestingly, now we have 3 parties (or more) involved - C++, XAML, CLR, instead of just CLR and XAML. Right now we don't have a good way to support exchanging information between these different environments, which is why you are observing leaks with circular references between CLR and C++ custom control right now. This is a known limitation that we are looking into, and we'll share more information when we are ready. I don't know if the problem still exists though to be honest but I certainly have not seen any information.
Is it becoming a legacy API? Seem to me that is pretty much kicking and screaming for desktop development.
I would like to read about some nice use cases / details about boost::intrusive_ptr and make_shared_from_this functionality.
&gt;I ran to the end of the (very long) thread and saw Yi asking for a repro that wasn't provided. That was for a different problem mentioned in the thread. The comment text I just quoted was about the original problem the creator of that thread was having. &gt;There's a ton in the rest of the thread establishing that there's no managed memory leak, but that there may be a native component somewhere in the stack doing the wrong thing. And you missed the point of the thread. There's no managed memory leak. That's pretty clear. You didn't even get what was the problem Yi Zhang and the other guy was referring to. &gt;What do you want me to say here? There's a .NET bug? Or a WinRT bug? Whatever. I don't know. Eh? I'm just exposing a problem with the .NET projection (in fact and from what I understand from Yi it should be happening with every language that uses a GC. I could be wrong though). &gt;And frankly, I am not all that concerned. OK. &gt;I don't have time to argue with a throwaway account about some huge .NET bug report. That's just a username I selected. It's not a throwaway account. Still even if it was that doesn't invalidate or validate the problem at hand. &gt;Especially a .NET bug report for Windows phone that hasn't had action in almost a year. That doesn't change the fact that there's a problem that Yi acknowledged and we haven't heard any news since then. &gt;Fine--my statement that .NET and WinRT work together "brilliantly" is clearly an overstatement. Unfortunately it is. &gt;You caught me. That was never the point or the goal. I just highlighted a problem in the language projection.
It's an option for sure ... swimming from Europe to America is also an option ... What I wanted to say: why does MS make native desktop development so hard? In my day-2-day job I work with Apple-Guys and they have a great time making fun of the poor Windows-Souls who need to code with this API-Dinosaur.
Yeah, we WTL-Devs scream a lot :)
Pff if you knew anything about Herb its that he likes loudly coloured shirts
LMAO, so true
So in the end, if a caller where to give this function an lvalue it would give the same compiler error as if only House(std::unique_ptr&lt;PileOfWood&gt;&amp;&amp; wood) was declared? Thank you.
From a perspective of modifications and such, the bits of chromium code I've seen seem like a disaster. So many classes with member variables that are non-owning pointers to other classes... just a big web of state.
If the project is cmake based, CLion is great and provides the feature you mentioned. It is my main IDE at work for Linux together with Visual Studio on Windows.
I want to enjoy CppCast but the audio quality is so low between the actual playback rate and the call-in phone quality that I can't stand it. 
&gt;Your goal appears to have been to disqualify my statement about .NET and WinRT by citing a year-old Windows Phone interop issue **reportedly** causing a memory leak. &gt;I've not read the thread carefully. I'm accepting that you've read it more carefully than I ever will. But I've read enough of the thread to file it away as an **inactionable** bug report with more smoke than fire. So Yi Zhang acknowledged a problem, mentioned there is a limitation in the tooling they were looking into and explained that was the reason why the guy was observing memory leaks, *even though it's unactionable?* You are making no sense now. And BTW, I quoted the paragraphs where he said that. There was no need to read the whole thread carefully. &gt;Can we stop arguing about this now? It's petty and pedantic. I just responded to your statement by mentioning a real limitation that I personally don't think it's a petty one in the tooling that a guy from MS .NET team acknowledged an linked to the thread with the specifics. I mentioned probably the only ONE problem with the way .NET and WinRT work together right now and you went kind of crazy talking about how not real it was without even looking to the details and unrelated things like throwaway accounts and what I wanted you to say like if there was some sort of plan from me just to "catch you".
&gt; When you read a piece code though, don't you expect that the owner of a resource (so the unique_ptr) would be more likely to modify it than the other contexts that can access it? No. The only thing to expect (or assume, really) is that when the owner dies, the object at the other end of the pointer dies. But even that isn't guaranteed.
Great, thanks! I'll check it out :-)
Right â the actual error will be that `std::unique_ptr&lt;&gt;::unique_ptr(unique_ptr&lt;&gt; const&amp;)` doesn't exist, only `std::unique_ptr&lt;&gt;::unique_ptr(unique_ptr&lt;&gt;&amp;&amp;)`. :-]
It's basically the same as [MoTTs_' suggestion](https://www.reddit.com/r/cpp/comments/6vx6ir/unique_ptr_shared_ptr_weak_ptr_scoped_ptr_raw/dm492u6/) (at least according to whining that took place on the Boost ML), though presumably a more fleshed-out implementation.
This was [N3146](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3146.html) in C++11.
&gt; Posted on August 24, 2017 &gt; GCC 5.2.1 &gt; clang 3.6.2 Compilers from July 2015 :-&lt;
I'm not sure I agree. The language doesn't change the meaning of the program for attributed entities. That won't change. Reflection would allow the program itself apply meanings to attributes. That is, the interpretation is just a part of the program.
Isn't the optimisation level -Og for cases where you need optimisation and the ability to debug? 
Offtopic, but since it's been brought up... I used to consider myself a WTL-dev, but I haven't had to do any UI work since ~2009 and things are a bit hazy at this point. Lately I have a compelling reason to reacquaint myself; are there any modern WTL resources to reference, or has it been dead these last eight years?
&gt; This came to my attention now that Perl using using the Atom symbol \u269b for atomic assignment Oh dear - I guess we'll need keyboards with a hundred thousand keys or so soon. And the arguments about readability for programming fonts will be drowned out with missing glyph complaints - "All of my Perl code is entirely invisible with this font! Please add the pile-of-poo ASAP.". 
[Boost.Spirit](http://www.boost.org/libs/spirit/).[Karma](http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/karma/tutorials/quick_start.html) is my go-to (though having a Boost dependency is a given for me, unlike many). EDIT: Here are the results of [this benchmark](http://www.boost.org/doc/libs/1_65_0/libs/spirit/workbench/karma/double_performance.cpp) on my ageing Win10 system: MSVC v19.11.25617 x64: sprintf: 0.454s iostreams: 1.294s format: 1.786s karma: 0.097s karma (string): 0.112s karma (rule): 0.129s karma (direct): 0.090s Clang 6.0.0 (trunk, r311150) x64: sprintf: 0.458s iostreams: 1.258s format: 1.758s karma: 0.090s karma (string): 0.096s karma (rule): 0.120s karma (direct): 0.086s
Yes, thought the headset mic would give a better quality in recording...
So from reading that paper, \u23f1 (or anything inside the range \u2190 ... \u245f) is excluded in C++ because it is excluded in the standards for both XML identifiers and Unicode identifiers.
I wouldn't call the implementation all too elegant (though there are better ways of doing it for sure - I just rewrote the bare jump-list container to be far less hacky), but it's got a nice interface for the user :) I'm not sure how the code generation can get all too much better in this situation? Surely a single comparison and jump (at best - depends on the conditions you supply) can't really be beat? From my testing, my new solution forces the compiler to generate a jump table no matter what, with a maximum size that you can specify manually (if exceeded, will fall back to a more traditional look-up - short-circuiting if/else tree). The only compilers optimisations that this composition seems to miss are simple functions being inlined and outlier conditions resulting in a combination of a comparison and jump table
I agree, but if the purpose of the library is string formatting it's a bit weird not to include `&lt;string&gt;`. That said it is possible to factor out the subset of the functionality that doesn't require `std::string` into a separate header that doesn't include `&lt;string&gt;`, but noone seemed to be interested in this so far.
IMO, ownership of an object and who can modify an object are two completely separate contracts. One has extremely little bearing on another. 
Or people will continue to not use perl
I really like to use unique_ptr, but I find that when I write anything that is asynchronous, I'm forced to use shared_ptr so I can get pass a weak_ptr for callbacks.
TIL there's only one right way to learn. And I didn't learn that through Stack Overflow, oops. 
&gt;I'm not sure I agree. The language doesn't change the meaning of the program for attributed entities. That won't change. Yes it will. If you can write code that can see attributes then you can write code which makes attributes meaningful to the semantics of programmes. &gt;Reflection would allow the program itself apply meanings to attributes. That is, the interpretation is just a part of the program. Yes, and that's a bad thing. Nobody wants C++ to turn into Java and C#. Have you seen the horrific over-use of attributes in those languages? It's horrible.
That's stupid. You have to learn everything. You have to learn what 'unique_ptr' means. 
Cool story kid
good Perl is dead Perl
Rule #0: do not write C++ code
I am glad you didn't. That kills cute kittens :-). The problems of a C cast are * "not greppable" (or at least, hard to grep) * which cast is it? `reinterpret` is quite different from `static` or `dynamic`. (From that standpoint, one could argue that it is harder to parse it at a glance - one has to think, not just read).
That's pretty much what concept maps did. Perhaps in the future when simplifying generic programming is desired, we might actually get semantic-based concepts with concept maps, but I wouldn't hold my breath.
Cool write-up. "Linear vs. binary - for small items" though, which is possibly a rare case, comparatively. Chances are, things will be different already for `double`, and even more for strings. Performance is hard. :-(.
Writing code in emojis is cool and all, but please avoid using anything non-ASCII in a code anywhere where it's strictly necessary (basically boils down to comments and strings). It'll make code both easier to read (in most cases) and easier to write.
That was more interesting than I expected.
When we have Microsoft pushing devices like Windows 10S, and all new APIs being UWP only, it shows which direction the wind is blowing. Of course, management can change their mind.
The only really good time I have seen utf-8 used in a programming language, is in a vim plugin I have for Haskell which automatically uses the well known Category Theoretic symbols. But, the nice thing is that it does not actually write those symbols to the source file, and you don't have to type them. You just type as normal, and the plugin updates your view of them, and if you share this source file it will look normal to others. Here is what that actually looks like, if you're curious: http://imgur.com/a/Ztiow
VSCode has an extension for that, too: https://marketplace.visualstudio.com/items?itemName=siegebell.prettify-symbols-mode I use it for F# but I haven't thought of any clever symbol replacements for C++ yet...
Now we all wonder how 2017 compilers stack up. Has MSVC improved release debugging over the years?
There's fewer of other more popular sites that they can visit through the firewall?
Hmm... South Korea is in 7k as well.
I don't think this is on-topic, really.
[cppreference](https://www.alexa.com/siteinfo/cppreference.com) is more popular in China as well.
Where else can I ask this question? Just curious.
I would also like to use a switch for variant visitation, for example: std::variant&lt;int, float, my_type, string&gt; v; switch (v) { case int x: case float x: print(x); break; case my_type t: print(t.member); break; default: break; } Visiting with lambdas is great, but it doesn't offer fall-through and has more boilerplate.
But it helps reading code and learning. The names unique_ptr and shared_ptr can already give you some idea of what it could mean (the words "unique" and "shared" are normal English words). More importantly a beginner can immediately distinguish the two. I know so many beginners that learn about pointers and then for weeks and months they just do more or less trial and error by putting `&amp;` and `*` in front of stuff until it compiles (I'm exaggerating a bit but that's the gist of it). It takes them a huge effort to understand, and some do not and give up. If you have more symbols like `^` or `~` or whatever, it doesn't make the situation better at all.
This was released yesterday and it's pretty exciting! Finally you can use existing CMake projects and directly do development and debugging on a Linux machine (even a remote one). Previously, you'd have to create a new VS project (without CMake and setting up all paths &amp; libraries again manually in VS) to make that work. This was probably the number one feature request :)
None of the Perl 6 operators that use Unicode symbols _require_ unicode, all have ASCII equivalents. Given a bunch of well-known mathematical operators like those for Set theory, it's actually quite a reasonable and modern thing to enable. The [new atomic assignment operator](https://p6weekly.wordpress.com/2017/08/21/2017-34-going-atomic/) is also available as `atomic-assign($var, $value)`.
There are fonts that do this! Fira Code has a bunch of ligatures that kinda merge certain character sequences into one symbol. At first I thought "hey this looks cool, let's try it", but after using it for a while I've found it actually makes the code about easier to read for me, since instead of `!=`, which is two separate symbols, I just have to read a two character-wide `â `, which is just one big symbol. It merges `-&gt;` into `â`, and makes the `::` become closer to each other, to leave more space to the sides of it. I recommend looking it up, most editors should support it out of the box, just install the font and you're good to go.
Have they moved to upstream CMake server support yet? CMake support requires a whopping 0.4GB for some reason, too.
Visual Studio 2017 15.4 Preview aslo include Visual C++ compilers and libraries for ARM64 https://gitlab.kitware.com/cmake/cmake/issues/17213
It would be cool to do the same from a Linux machine to remote windows, using visual studio code / vs studio for Linux, if it existed
&gt; my new solution forces the compiler to generate a jump table no matter what Well, yes, that's problematic if you think the compiler should be able to decide to use an if/else tree for small cases - for gcc this appears to be n = 4. I suppose you could actually perform that transformation in the template by specializing for small n. Inlining is the real issue for me, though; it prevents this being used in places where zero-overhead is expected.
I have to disagree. Depending on your domain, being able to use greek symbols as identifier in code is immensely helpful. Also, many operators should be in Unicode.
yeah, I already bind to if/else if the size of the table is &gt;N (where N is set by the user - default is 128 elements) to save on binary bloat where you have large value spread, so having a small-table optimisation is just as easy. My personal issues are inlining is avoided (though this is only really a problem for micro-functions anyway, and I do believe this can be optimised by the compilers in the future) and it can't optimise large outliers into a combination of a jump table and specific checks for the outliers. I could probably code the latter in myself, but I haven't got around to that yet :) now... how to replicate structure re-ordering via profile guided optimisation...
You speak as if people having problems reading someone else's perl code is a problem. Perl enhances code security by being a write only language. It is a feature.
I think last time I looked at it clang was able to inline table jumps to small functions, so there's hope for gcc in the future.
I don't know why you're getting downvoted, I've had to deal with the same problem. It wasn't greek, but the things the program dealt with only had names in a foreign language, so having the variable names be the same as the names of the things they were representing was immensely helpful.
By the way, does VS still struggle with projects doing `add_subdirectory(depdir)` with depdir being a path out of the source directory? I use this sometime to simplify dependency management** and VS can't work with it without doing the usual cmake generation of vs project. **: no, conan or similar deps managers will not help in these specific cases, I try them all regularly; yes it could be considered a bad practice if we had ways to do better in these specific cases, I'm not saying it's a good way to go for most projects, I just got these special cases sometime.
And if you want to see a trainwreck in motion, look no further than this thread: https://www.reddit.com/r/cpp/comments/6vsoii/some_useful_malloc_implementations/ It seems the people involved really don't understand what I'm trying to tell them...
&gt;well... there is a folder with malloc implementations like it says. There should be a description _in the article_ and _on the github page_. Is that so incredibly hard to understand? Finding an interesting library works like this: someone tells me about an interesting library AND WHY IT IS INTERESTING and then I look at it. Do you really not understand that asking people to dive into thousands of lines of code, just to find out what something is, is just terrible presentation? So just to be clear: I'm not asking for instructions on how to use f'ing Google. I'm _telling you_ that the author needs to step up his game for when it comes to writing articles and/or github descriptions. 
My code uses Â° and Î© a lot (scientific application, lots of temperatures and resistance values). Each time I use them (and including now, in fact), I find another piece of source where they are used, copy them to the clipboard, and paste them to where I need them. Now, I can already tell that someone will helpfully explain that I could define them as constants in one place, and that's true, but it's not the point: typing anything that is not on your keyboard is just a major pain. So, no: operators should not be using unicode. It should remain possible to write C++ using just the ASCII character set. That math uses the extra symbols is irrelevant. A programming language may share some terminology with mathematics, but it is not at all a 1-1 mapping, nor should we try to make it so. 
&gt; That's pretty much what concept maps did. ok interesting, I didn't look into the whole proposal (I was aware 'concepts' mutated into 'concepts lite'). Were the extensions only available when you actually refered to a type by it's concept? &gt; but I wouldn't hold my breath. any hope that 'another language similar to c++' out there already doing it facilitate consensus and getting it done; haskell, rust (and i think swift to some extent?) have features like this
Would be satisfying to rename some functions into ð© ð
A Visual Studio release for Linux would definitely get my attention, and might even make VS relevant for me again.
Let me try again. Semantically, a metaprogram that operates on attributes does not change the meaning of a program because it's a part of the program. The program has only one meaning. The same is true of any metaprogramming technique that you use today to inspect or generate code. I agree that it would make attributes meaningful, but that's not the same thing. There are probably reasonable use cases for generating code corresponding to one flag or another. Today, we might do that using associated types and type traits, which can be somewhat limited and imposes its own syntactic headaches. Or maybe we also use the preprocessor to stamp out code and instantiations. Using attributes may turn out be a reasonable alternative. I'm not going to prejudge a language feature simply because Java and C# abused it.
I think that's more generally about allowing labels in variadic unfolds? Actually, that's just `constexpr` blocks (from the metaclasses proposal) with the `-&gt;` code injection mechanism.
If it ever happens it won't be the same Visual Studio you are familiar with. It would most likely be a modified version of [Visual Studio for Mac](https://www.visualstudio.com/vs/visual-studio-mac/), which doesn't really share any code with the windows version.
Readability is far more important than writeability when it comes to code. &gt; It should remain possible to write C++ using just the ASCII character set. C++ already supports digraphs and alternate forms like and, bitor, etc. So you should be perfectly able to continue to write code in Ascii.
That's a good thing within limits. It does mean that now readers needed to know the equivalences between ASCII names and Unicode symbols, though - something similar in Haskell still irritates me every time with several years experience, and that's presentation only (translating ASCII symbols to pretty symbols for literate code output). For someone who gets regularly reminded of the equivalences, fine. For someone who hasn't seen that before or who only sees it rarely - an extra distraction and possible cause of confusion. I almost always read the source of the literate code in my text editor, same as any other code, so only see the prettified stuff occasionally (though it was only a big problem when I was first learning Haskell and trying to figure out which ASCII symbol to use based on prettified tutorials distributed as PDF and PS files). Anyway, OP seems to be taking that as permission to use unicode everywhere, including in C++ identifiers with no ASCII equivalent which (depending what he writes) other people will need to type too. For people to use their own native language, that's fine IMO, though oddly enough many people who's native languages aren't English insist English identifiers are the way to go. Identifiers should communicate intent, but there's constraints limiting that anyway (especially they should be names, not essays) so that's means at best they're usually mnemonic, and learning a few words of a few languages is no big deal anyway IMO, but the people who are already working in a non-native language seem to disagree. Anyway, back to the point, OP is looking to use arbitrary symbols. Not just that, but trying to push the bounds of which symbols he's allowed to use. I thought my overblown sarcasm made it obvious my comment wasn't to be taken *that* seriously, but there's an issue which I was directing at OP, just using some overblown Perl-hate humor to make the point. 
I guess that explains why regular expressions are so important. 
There is VS Code. It's definitely not Visual Studio, it's more like an editor, and it's far from having all or even a notable subset of the features of VS 2017. But it has come a long way since it first got released and it's pretty nice.
I just had a look, first time I hear about VS for Mac. Unfortunately it doesn't even have any C++ support o/
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6w7wuq/c_noob_question_about_libraries/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Every language with generics since the 90s has this, but the only "widespread" language in C++'s space with generic types that I know of is Rust. 
Would it not be preferable to use C++17's *__has_include()*?
I assumed variadic switch wouldnt allow fallthrough. How would you make the syntax for selective fallthrough work? Would you require break everywhere for most common case, and allow if constexpr to guard break if u want selective breaking?
How would it help it here? Usually you check out most code regardless of the OS. I.e. `"windowsmutex.h"` would still be present when you try to compile it on unix-like OS.
Very good, but 3 things: why using sentinel INT_MAX and not size using pow2 array size is not realistic. using AVX on small arrays makes me doubt this is realistic benchmark since IIRC Agner Fog once reported there is a SSE warmup latency where SSE instructions do not perform good until you have used them for a bit. PS if you liked this check out https://lemire.me/blog/2017/04/10/removing-duplicates-from-lists-quickly/
&gt; Every decision we made Ah here is the core of the cores. Who is "we" Andrew? This thread is full of good people and software experts who are suffering the "decisions we made". We all know there are this "Windows decision makers" we never see or hear. Who decide on "things" like: "UWP only", "push XAML", etc. All this lovely little obstacles, popping up at us like in some game. Making our Windows Devops lives rather harder than they should be ... Scavenging around droplets of info from MSFT teams. They in turn wondering why are we upset about lack of communication emanating from (for example) WinRT/MSVC when they apparently happily chat internally all the time. Sorry Andrew but some of your comments do remind me sometimes on famous "Let them eat cakes..." . After an incredibly long "radio silence" period from WinRT team (yes, some people already thought project is dead and Kenny is doing something else) here is MSVC team member wondering what is the fuss all about: "I hear from Keny more than from my mom" .. Well we do not. And we never now what or when is next major release going to be. Or what is it going to contain actually. And why.
One minor note about article that might matter for microbenchmarks: counting algorithm is not binary search(tm) because return value does not tell you if the value was found or not. I know article uses lower_bound that has the same "problem", but just sayin... BTW now I feel the person who decided that std::binary_search should return bool was not an idiot :D 
**Company**: [Pathcore Inc](https://pathcore.com) **Type**: Full Time **Description**: Pathcore is a Canadian business specializing in digital image management for pathology. We're looking for a C++ software engineer to work on a cross-platform native viewing application and image processing backend. **Location:** Toronto, Canada **Remote:** No **Visa Sponsorship:** Maybe **Technologies:** C++11, C++14, Boost, Qt, CMake, knowledge of Linux a plus, knowledge of C# and Python a plus **Contact:** PM or [visit careers page.](https://pathcore.com/careers/)
The problem with UWP is the UI/UX. It's horrid for desktop applications. Sometimes you need a menu bar, or toolbars. On lower resolution screens the UI elements take up laughable amounts of space. Microsoft needs different control sets for touch and non-touch. One cannot function on both form factors. UWP are beyond ugly. I could never pay for a product using that framework for the UI layer. Maybe Microsoft should have kept Windows Forms support for Visual C++? Such a shame C++Builder costs so much, these days. 
Quoting myself: &gt; That's not to say we didn't make mistakes: in fact, the opposite is true. Quoting you: &gt; They in turn wondering why are we upset about lack of communication Someone commented that C++/WinRT looked dead. I turned around and wrote a half dozen paragraphs about C++/WinRT and the history of the project. Many members of the C++ team are very active on /r/cpp. If you have questions, we will do our best to answer them. And as for "droplets of info", the [VCBlog](https://blogs.msdn.microsoft.com/vcblog/) has 10 separate posts from August alone. Is there something you need to know that you think the VC++ team isn't telling you? Please, just ask us. I'm in close communication with Kenny because he's telling us about MSVC bugs, not because we're building UWP apps on the VC++ team. The communication with Kenny is the exact same thing that happens with developers around the world: they tell us about MSVC bugs, we respond as best we can. It's just that Kenny's project finds a *lot* of bugs. I would suggest that it's a little unfair to compare us to Marie Antoinette. 
If you are looking at straight C++ I would look into [caffe2](https://caffe2.ai/). Its very well documented and there are quickstart tutorials on the site. No RBM support, but otherwise it is feature rich and extensible. The other big deep learning library for C++ is [tensorflow](https://www.tensorflow.org/api_docs/cc/). Tends to be aimed more at large server scale deployments and research. Historically I avoided tensorflow due to a focus on python usability over C++ - however it looks like the C++ API is now a lot cleaner.
TensorFlow is the standard in neural nets it seems. I would start there.
how does one learn this stuff without going to a seminar? what are the resources?
What's the story on ConcRT/PPL/Agents Library? ConcRT got a lot of hype at one time, but the 'native concurrency' blog has been dead for years...
https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list Take a look at this curated book list and pick out something you feel suits your needs, imo.
Please take a look at the sidebar. `-&gt;`
Make a component based architecture for a game engine. Build up different parts of the engine... make a simple game while you're at it. Dig in deep to some parts. Just reading books can be too passive sometimes to really learn effectively.
http://exercism.io/languages/cpp/about
From outside the things look/looked awfully quiet. Which in turn is very confusing for watchers/folllowers of the most important Windows project deciding the Win dev direction for years to come. Basically Reditt threads are not good enough. There is a lot of unanswered strategic questions. All just adding to the unfortunate UWP mess. Mistakes we all make. 
+1 for the right arrow
ping /u/kfunk87
Do you want to practice, or do you want to read up on C++? If it's the first, try Hacker Rank or Project Euler along with a good algorithms book.
I would recommend taking a very close look at some Boost libraries. Pick a few, say, asio or spirit or hana ... anything really. And try to use them. Follow examples, realize your own. Find out why there are designed the way the are. Dive in deep. This should get you in touch with recent C++ development and put a few good skills in your resume. 
Pick up a couple of books from the stackoverflow [list](https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list). If you haven't read them, I highly recommend reading Scott Meyers' books. Try to identify where your skills are lacking - maybe you don't know enough about templates or parallelism or algorithms or whatever - and look for material on youtube or blogs. There are heaps of talks from cppcon on youtube and a lot of them are really great. Look around on github for a project to work on (or start one of your own). Actually writing something is probably the best way to develop your skills (and also identify where they are lacking). Look on sites like [leetcode](https://leetcode.com/) or [hackerrank](https://www.hackerrank.com/) for problems to solve and competitions to enter. 
Off topic but serious question, what do you learn in a game design school ?
Wow! Cool idea this exercism.io !! Gonnu try and see if I'm any good at it.
www.hackerrank.com is amazing!
1. Sentinel INT_MAX is universal, it works properly for every key of type "int", while SIZE would work properly only in this benchmark. 2. Surely, power-of-two is unrealistic. I guess all the described algorithms extend to non-power-of-two quite easily (sentinels are needed through). The only hard case is branchless binary search, but I have explained how to generalize it without much cost. 3. Time is measured over millions of searches, and average is given. I think warmup is very short ("this doubled throughput is obtained only after a warm-up period of several hundred floating point operations" - is this the right quote?), then it should negligibly affect the results.
needs more unicode âð¢â´ ð¯ð¯
You could take a look at project euler, there is a list with math problems, that can mostly be solved by programming it. If you sign up(for free) you even have results for every problem, to check if you did it right. As those are math problems, the programming needed is mostly math stuff, and not much IO, network, ... but whatever else you are doing, the underlying math stuff is mostly needed for everything. Some problems can be solved in multiple ways as well, with varying degrees of optimization.
@1 I guess am I missing something. My idea is that most people have sized arrays, not sentinel terminated arrays(like 0 for char strings) Obviously for sufficient reward(performance) people may consider changing their conventions. @2 I am talking about performance, not correctness... "This requirement may be lifted by processing at most 15 last elements with additional loop(s), but I suppose such a version would work somewhat slower than the version with sentinels." @3 not really - point is that if you use SSE code "in real life" you may end up with intervals of non SSE code use, then you look through arrays a bit, it is slow until SSE warms up, they you do non SSE code again.... basically problem is that if your SSE usage is not common enough you will be affected by this. And you may say if it is not common enough then you should not care about optimizing it, and that is mostly true, but what if it 5% and you are 20% slower than nonSSE code? That is 1% drop in total performance, although you used the "fastest" version. P.S. If it sounds like I am shi**ing over you article: I am not, I have done benchmarking(nothing professional as you but some crap of my own), and I know how painful it is to account for all the problems you may encounter.
I don't think I have ever seen a programming book as universally recommended as Effective C++. I get why too, that book is great. It's not even meant to be a learning book but you still can end up learning quite a bit about how C++ works.
Why is this being downvoted while exercism.io is being upvoted? Anyone?
Bjarnes' C++ book will serve you well in that case 
Just asked a related question a couple days ago on this sub. I haven't checked out all the answers I got, but I can say you shouldn't go with OpenNN. I tried to get it working all summer before giving up.
wont' following work? template&lt;class Platform, class Unused = void&gt; class Mutex; template&lt;class Unused&gt; class Mutex&lt;PlatformWindows, Unused&gt;{ };
Paging /u/STL. I'm not familiar what happened with the whole ConcRT thing or what the preferred alternative is now.
Even a command line compiler for cross-compiling to Windows would be great.
I'm saving this comment as my new "personal guide when I post things on reddit c++" :)
Sidebar* operator-&gt;() { return this-&gt;sidebar; }
&gt; That said it is possible to factor out the subset of the functionality that doesn't require std::string into a separate header That's exactly what I've been doing with formatxx. There's still an include of `&lt;string&gt;` in the main header for `char_traits&lt;&gt;` that I haven't moved yet, but that one is easy to fix soon as I get around to it. I also do plan to add `ostream` support, but again in a separate header. I'd like to further refine the writer interface closer to what ggformat has and reserve the virtual function call for overflow support only.
just print stackoverflow
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Thanks didn't know c++ had a version of tensorflow
What about Theano? It's a pretty established one
Great thanks! One question: do I need to build the project with makefiles or CMake in order to use QtCreator 'intellisense' features? I would love to use it on executables that have debugging symbols but that have been built with QtCreator unsupported build systems
You can use this and AFAIK the code model works : http://doc.qt.io/qtcreator/creator-project-generic.html but overall it works better if you use CMake or qmake since the IDE will have more information available (build flags, defines, etc)
I think the relevant part is from the bottom of page 154 [here](http://www.agner.org/optimize/microarchitecture.pdf): &gt;The processor turns off the upper half of the 256-bit execution engine when it is not used, in order to save power. Instructions with 256-bit vectors have a throughput that is approximately 4.5 times slower than normal during an initial warm-up period of approximately 56,000 clock cycles or 14 Âµs. A sequence of code containing 256-bit vector operations will run at full speed after this warm-up period. The processor returns to the mode of slow 256-bit execution 2.7 million clock cycles, or 675 Âµs, after the last 256-bit instruction (These times were measured on a 4 GHz processor). &gt;It is possible to prepare the processor for executing 256-bit instructions by giving it a dummy 256-bit instruction at least 56,000 clock cycles before a critical sequence of 256-bit instructions. You may insert a 256-bit vector instruction such as, for example,vxorps ymm0,ymm0,ymm0 somewhere before a piece of code that contains time-consuming 256-bit operations. Any instruction with YMM registers will start the warmup process, except vzeroupper and vzeroall. The first 256-bit instruction takes 150 - 250 clock cycles - probably to start a power-up process. So might be interesting to test insert an `asm volatile("vxorps %%ymm0, %%ymm0, %%ymm0\n\t" ::: "memory")` before your benchmark setup and seeing if that has an effect.
You can't have a pure and mutable function :P I am indeed in favor of a pure keyword and I think there was a proposal but it never took off. 
&gt; You can't have a pure and mutable function :P i'm stretching the meaning of 'pure' to be 'pure except for explicitely marked mutable parts' , but I'd still be happy with just pure aswell &gt;I am indeed in favor of a pure keyword and I think there was a proposal but it never took off. ... given the demands of threadsafety, and how much easier pure functions are to deal with ... I'm really surprised we don't have this by now; are there any objections? is it just too hard to agree on a syntax? or what? One thing I note is that 'debug prints' would be an exception from purity, perhaps we'd also need a workaround for that e.g. mutable keyword on certain globals .. explicitely marking them would be ok. I'm ambiguous on Rust but I definitely like it's overall choices on this issue.. 'immutable by default, globals require an unsafe block'. I think a combination of a pure specifier and (some sort of workaround for cases like debug prints) would bring C++ up to par on that.
Current concepts are different: as there is nothing to "implement" for them: they provide a set of syntactic constructs without specifying the exact operation set required for a type; it's just a predicate for a type, much like (expression) SFINAE, but with some added benefits. Rust traits, on the other hand (or Haskell type classes, or abandoned C++0x concepts/concept maps) provide a required set of operations, so it makes sense to override some (or all) of them for a specific type. So, it looks to me that Concepts TS is orthogonal with UFCS, and can't provide any fundamental simplifications about it.
The CBE and TCO examples are from more recent `gcc` and `clang` . The IV elimination example is old indeed, things haven't improved much since then, data is still valid for latest `gcc` and `clang`, unfortunately so I didn't bother regenerating all the diagrams and so forth. :-( Probably should've called that out. 
More interested in cases where you are having to debug instability in a production build in the wild. Debug information quality is in fact not proportionally related to the quality of the generated executable code and wildly varies from compiler to compiler. DWARF is highly expressive and is able to express values even in the presence of many aggressive compiler optimizations. You'll see huge disparities here between `gcc` and `clang` (see last example in the article).
would UFCS have interacted ok with 'concept maps'? Is the incoming concepts feature a subset of concept maps, which could be extended later?
See also [Struss](http://www.project-strus.net/)
I wouldn't recommend learning C++ AND tensorflow together. Learn C++, learn python, learn tensorflow, design a model and train it using python + tensorflow. Load the trained model in c++ if it's necessary. 
If you're goal is to use deep learning and C++ you'll have a hard time research is better in python and faster then you go through the cycle of prototype-&gt;train-&gt;validate once your model is ready you can serialize it and load into on your C++ app I recommend tensorflow or PyTorch for research then you can write your model in tensorflow and load it into your C++ app you can find more here https://medium.com/jim-fleming/loading-a-tensorflow-graph-with-the-c-api-4caaff88463f
&gt; The effect should be to mark all global variables as effectively 'const', then it wouldn't prevent const_cast (even though it would be sometimes UB, but that never stopped anyone). The main problem is that even basic stuff like initializing a string : std::string s = "foo"; would certainly not work because somewhere in std::string's constructor there could be an assignation of variable which would be considered impure. Also you couldn't do math since adding two floats potentially changes the floating point overflow state: http://en.cppreference.com/w/cpp/numeric/fenv/fetestexcept
&gt; then it wouldn't prevent const_cast Ok, it might have to prevent ```const_cast``` to satisfy me :) &gt; The main problem is that even basic stuff like initializing a string : std::string s = "foo"; Under my definition of purity, it's ok to [mutate local variables](http://forum.dlang.org/post/jk2jdg$2o1d$2@digitalmars.com) (for example, a function could work on a mutable accumulator, then return it); from the callers perspective, there are still no externally visible side effects; I suppose for compatibility, the compiler could still calculate if existing functions are pure (by the above definition), and still allow calling those, however that would lead to breaking changes if you later modify them, so maybe that's something to warn about by default
Yes, this is a much better quote. Anyway, the total time of all measured searches was much greater than 14 microseconds, so this effect should still be negligible (compared to bad precision of clock(), for instance). 
You could, possibly, even use `const` as the keyword. Just like a `const` member function means it doesn't change any (non-mutable) member variables, a `const` global function could mean it doesn't change any global variables. Hmmm, but I'd also like to mark member functions as globally const...
Those libraries were developed by a team (Parallel Computing Platform, IIRC) which has since disbanded. (Some of their devs joined the classic VCLibs team that I work on, but they left after a few years for other teams.) ConcRT/PPL/Agents are in maintenance mode right now, and should be avoided in new code. Standard multithreading (including C++17 Parallel Algorithms which we're working on right now) and new mechanisms like the Coroutines TS are the future (and because they are Standard or on the path to Standardization, you can expect a high level of support in the future). From my position in VCLibs, I saw only part of the PCP story. My understanding is that ConcRT was driven by an idea that didn't pan out - that cooperative user-mode scheduling would be the future. Unfortunately it didn't interact well with classic kernel-mode scheduling (mixing ConcRT and Win32 synchronization is risky), and OS support for UMS didn't materialize. I don't know what prompted the strategic shift that led to the disbanding of the team, but the lack of devs who understand the code means that the bits shouldn't be taken as a dependency by anyone. Of course, the STL took a dependency on ConcRT when we added multithreading in 2012. I was still growing as a developer at the time and it seemed like a good idea, but it was a mistake. We replaced one chunk of buggy code with a buggy integration layer to problematic code, and we've spent years disentangling the problem. (In VS 2015+, our STL no longer uses ConcRT for synchronization primitives, except on XP. See [this changelog](https://blogs.msdn.microsoft.com/vcblog/2015/07/14/stl-fixes-in-vs-2015-part-2/) for more info.) I don't think I could have made any other choice (I was far less senior in the 2010-2012 timeframe and couldn't have resisted the pressure to use the PCP team's technology, and I had almost no multithreading experience myself - and there were no other VCLibs devs working on the STL), but I wish I had known the trouble we were getting into. Nowadays things are different. We have all-new management, more VCLibs devs on the STL (with multithreading experience, including myself), we've fixed a whole bunch of multithreading bugs in the STL and ripped out as much of the ConcRT integration as possible (it is fully removed in our next major binary-incompatible version and both the atomics and multithreading headers were totally overhauled by Billy). And I have learned from my mistake - we are being careful on taking dependencies on external code, and will do so only when we're confident that we won't regret it. (Currently, we're implementing Parallel Algorithms ourselves, but planning to pick up external implementations of Three-Eyed Hypot and Special Math.)
I have approved your comment, but you should be aware that you are shadowbanned. You must talk to a reddit admin to get the shadowban lifted (subreddit mods like me cannot modify shadowbans).
&gt; You could, possibly, even use const as the keyword that does make sense to me- globals are to free-functions as struct-fields are to member-functions. &gt; Hmmm, but I'd also like to mark member functions as globally const... exactly; so we still need more. one idea might be marking the class as const, class(const) Foo {} and then mutable stuff needs the mutable keyword ... kind of like how we have 'struct vs class' implying public or private default, or how about listing it like private/public ... ```const:```
Yes, Dyno is only runtime polymorphism.
_ninja edit_: OP, I think you might be interested in reading about effect systems in programming language theory! Go take a look, there's plenty of great research going on to address this exact issue you've brought up =) Your request for purity "except for explicitly marked mutable parts" starts to sound suspiciously similar to pre-C++11 dynamic exception specifications, and that was deemed by the community to be a mistake :P Don't get me wrong, I love purity and immutability Ã  la Haskell, but if I'm reading you correctly this seems like it would require a fundamental change in the type system. Also, the notion of excluding debug prints from the purity specification is a huge flaw IMO. If one of the purported benefits of your pure functions is "doesn't mutate global state except for: X, Y, and Z and is therefore implicitly thread safe w.r.t. all other global state" and there's an exception for debug prints then one of the problems arises. First, if it's part of the type system a debug build is a breaking api change (_not okay_). Second, if it's not part of the type system Ã  la C++17 noexcept then what's the point? Moreover, if I link against your library I simply cannot trust that you won't mutate global state underneath me when I don't expect it (i.e., write to stdout, stderr, or whatever), in which case must I now synchronize my application I/O with calls to your library? (_also not okay_) Or if it behaves like noexcept and you do modify global state, breaking the contract, does the compiler insert a std::terminate call in my application? (_really not okay_) I can't see any way around those options, and the same problem would occur for any systematic exception to the purity guarantee. _second edit_: I just realized that you also have the idea of excluding allocations. Same problem arises because allocating necessarily mutates global state. _third edit_: I think, if such an idea were to ever get off the ground, that purity _must_ imply noexcept.
How would pure functions help with thread safety? You say you want to mark globals as const, but that would only be in the context of the pure function. Other functions, in other threads, could quite easily still modify those variables while the pure function is executing, so it would by no means be thread safe. If thread safety is a goal, then access to variables that are externally modifiable must be prohibited entirely. Which I believe is closer to the generally accepted definition of pure functions anyway. On a related note... Does anybody know why noexcept functions may happily call except(true) functions? Surely the compiler could quite easily detect and forbid that? Given that it would end in tears anyway... UPDATE: to answer my own question, is it to avoid having to mark up every silly getter with noexcept, maybe? If so, that's a good reason. 
The metadata creation happens at compile time and uses a .NET component. There is no .NET dependency at runtime. 
I loved how you wrote its code clean. I still find that way more readable, maybe cause I am a C++ noob! haha PPP14
Right, only "real" pure functions (those that only use their inputs and don't read globals at all) help thread safety. noexcept: noexcept(true) really means "if an exception is about to escape this function, we terminate instead". Sort of "over my dead body!". You want to be able to still call functions that can throw because maybe you know - for the current situation - the function won't throw. ie push_back() is not noexcept, but you know it won't throw if you reserved enough space.
the 'debug print' is kind of a special case... (indeed it might need an 'effects system' to express properly, but stopping short of that imagine debug as a special ,simplified case) ... an effect that you know isn't actually needed by your application in release. To me the implication of 'debug build' is: "not the actual product, but something that behaves the same way , with extra diagnostics and checks"
&gt;&gt; "How would pure functions help with thread safety? " pure functions are inherently threadsafe. The larger the fraction of your program is 'pure', the easier it is to run across multiple cores. I'm not suggesting this as *the only* mechanism*(if so , i'd have gone directly to haskell), just an *additional tool* at your disposal. &gt;&gt;"If thread safety is a goal, then access to variables that are externally modifiable must be prohibited entirely. " ... mark 'main' as pure to acheive this 
Depending on your tick rate, this may lead to dropped inputs. If I manage to press and release a button in one tick, it won't get picked up. Having a const queriable state is still very useful, but you might find a need for a record of each event since the last tick.
Also, 'state' maybe shouldn't understand the input mode. Yeah, coupling to keyboard and mouse is fine for the majority of projects, but having abstract devices that have abstract button names (gamepad0, button11) would work with a customizable keybinding setup better.
I agree with that, but even so, in a debug build you probably don't want to have scrambled I/O because of a race condition on stdout and/or stderr. Likewise, for I/O heavy applications locking access may be prohibitively expensive to the point where a debug build becomes unusable.
You have an if statement when it should be a for statement
[Vote fuzzing](https://www.reddit.com/wiki/faq#wiki_how_is_a_comment.27s_score_determined.3F).
Like the style - clean code, simple file organization. I would suggest putting the "hello world" example from the wiki in README.md. I like that you return results via callback instead of forcing the user to allocate memory (although it could be a higher order function instead of a class). However, it's also true that it would be slightly better from a user point of view to offer an iterator. You could fill a `const std::vector` with results in a one-liner, for example. I have struggled in the past to write such an interface on complicated search data structure. The state you need to keep in the iterator is complex. The generator construct and `yield` from Python would be really helpful here.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Doesn't happen until there's at least 5 votes or so. You can see if it's fuzzing by just refreshing the page and seeing if the score change.
Because this isn't r/cpp_questions, it's probably someone who downvoted for helping someone instead of redirecting them to r/cpp_questions (if someone gets their question answered here, they'll just post here again next time...)
https://www.reddit.com/r/cpp/comments/6qhhdc/generating_iterators_how_c_coroutines_work/dkxq5n1/
&gt;pure functions are inherently threadsafe. No, they're not - not if they may access globals that might be undergoing modication in another thread (your first bullet point). If thread 1 is executing a pure function that iterates over a map, while thread 2 is simultaneously inserting into that same map, you have a problem. I do believe I already mentioned this in my previous message. 
&gt; "not if they may access globals that might be undergoing modication in another thread" so those globals are not 'const' notice I say "globals=const" it does need a way of enforcing that globals are not being modified. eliminating globals altogether would be better perhaps, that a stronger assertion very much in the same spirit as my original request. so extend it to 'pure, and doesn't read any globals'... or extend it to asserting what I state: globals=const short of something like Rusts borrow checker, it might be possible for the compiler to add checks to a debug build (e.g. automatically transforming reads/writes of the global into generated accessor functions) to assert that there is no simultaneous mutation of globals along side use of globals from pure functions, without additional language features (beyond the pure specifier) 
&gt; a pure function would return an error if calling non pure functions No; a function which is pure cannot call a non pure function. It should fail to compile if a non pure function could be called.
That's easy: mingw can do it
If I recall correctly, what you want seems to be very close to how D does purity. D also has immutable values, things which are globally const. There is no counterpart to that in C++. Allowing memory allocation in pure functions is fraught with dangers. What if new throws? On the other hand, not allowing new in pure function severely limits their usability.
&gt; "Allowing memory allocation in pure functions is fraught with dangers. What if new throws?" I should clarify that I personally do not use exceptions. I'm thinking about the C++ subset with exceptions disabled; OOM is UB, and avoided by design (e.g. the program must have ways estimating load and throttling before actually doing operations that allocate)
yes thats what I meant. the compiler would give an error, not return an error at runtime. the *compiler* would return an error. I typed 'return' instead of 'give', sorry. Fill in the gaps.
If you're talking about the mxe distribution, then a big problem is that the 32-bit compiler only supports the sjlj exception implementation, which is slower compared to dw-2.
I think `constexpr` does most of this already, except you cannot use dynamic memory allocations.
As far as I know; [P0078R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0078r0.pdf) was the latest proposal for a `[[pure]]` attribute in 2015. If I remember correctly, there was some interest, but people did not agree on the semantics, and there wasn't a follow-up proposal. You can find some feedback about the proposals and its status [here](https://cplusplus.github.io/EWG/ewg-active.html#75), but it looks like it does not cover the 2015 revised proposal. It might be one of those Â« post-C++17 Â» proposals that got forgotten meanwhile.
There is only "one world". C++11 threads (and Boost threads) are implemented in terms of pthreads as the underlying implementation on Linux. If you get a stack trace of C++11 `std::thread` usage, you'll see `std::thread` calling `pthread_create`, `pthread_join` and the rest. It's nothing more than a convenient and nicer to use (and portable) wrapper layered on top of the lower level primitives. See [std::thread::native_handle](http://en.cppreference.com/w/cpp/thread/thread/native_handle) which will get you the `pthread_t` of a `std::thread`. Then you can use any pthreads functionality you like (but be careful not to muck up the state and confuse the wrappers e.g. by joining a thread--I've not tried it but it's potentially dangerous).
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6whzqu/coexistence_of_pthread_and_stdthread/dm8832s/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; would UFCS have interacted ok with 'concept maps'? It's still orthogonal (sorry about not subpar wording of my previous comment), but it might be not needed, see e.g. the Semigroup example from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2617.pdf &gt; Is the incoming concepts feature a subset of concept maps, which could be extended later? There is nothing like concept maps in Concepts TS. Something in this direction is theoretically possible, I guess, but it would be a big change; and I don't know if there is any work in progress.
Great review, thanks! Is it worth to have a paper copy and save for later, or the electronic will do just fine?
I am looking forward to this book. It's nice to see it's finally done :)
If you want a deep learning library that's specifically designed to be used from C++ check out dlib's tooling: http://blog.dlib.net/2016/06/a-clean-c11-deep-learning-api.html It's actually designed for use from C++. All the other libraries are designed to be used in a language like Python and the "C++ API", if you can even call it that for most of them, is just an afterthought. Or merely someone saying "well, it's written in C++, so I guess you can mess with that C++ code".
Thanks, Stephan â more detail than I had hoped for! Now, who needs to be prodded to make "*ConcRT/PPL/Agents ... should be avoided in new code*" prominent in the VC++ docs? ;-] As an aside, I see you've updated your MinGW distro â thank you for that as well! FYI, in case you haven't seen it yet, Boost 1.65.1 [is on the way](https://lists.boost.org/Archives/boost/2017/08/238365.php) and a handful of the fixes going in are GCC 7-specific.
I just looked at some of the samples. What I saw wasn't encouraging at all. In what universe is [this](https://github.com/PacktPublishing/Cpp17-STL-Cookbook/blob/ce2b8ae0aa4b1c36902ec9c838fa1e152699b590/Chapter03/making_iterators_stl_compatible.cpp#L4-L25) a "STL-compatible iterator"? How on earth is [this](https://github.com/PacktPublishing/Cpp17-STL-Cookbook/blob/master/Chapter03/making_iterators_stl_compatible.cpp#L29-L33) a valid specialization of `std::iterator_traits`? And why on earth would you teach people to specialize `std::iterator_traits` instead of supplying the member typedefs? Then there's [`#include &lt;execution_policy&gt;`](https://github.com/PacktPublishing/Cpp17-STL-Cookbook/blob/ce2b8ae0aa4b1c36902ec9c838fa1e152699b590/Chapter09/auto_parallel.cpp#L6), which isn't a thing. And then it [passes a lambda that captured a random number engine by copy](https://github.com/PacktPublishing/Cpp17-STL-Cookbook/blob/ce2b8ae0aa4b1c36902ec9c838fa1e152699b590/Chapter09/auto_parallel.cpp#L19-L21) to parallel `generate` which will further copy it freely. Let's just say that the result is highly unlikely to be what you want. From another file in the same folder, we have [gratuitous copies with `async`](https://github.com/PacktPublishing/Cpp17-STL-Cookbook/blob/ce2b8ae0aa4b1c36902ec9c838fa1e152699b590/Chapter09/async.cpp#L43-L45), passing a string to three separate functions that do not modify it. Yet another file [uses `chrono_literals` without including `&lt;chrono&gt;`](https://github.com/PacktPublishing/Cpp17-STL-Cookbook/blob/ce2b8ae0aa4b1c36902ec9c838fa1e152699b590/Chapter09/threads.cpp#L5) - and the *using-directive* is completely superfluous anyway when you have `using namespace std;` already. OK, let's try something else. How about `gather`? Alas, we have [this gem](https://github.com/PacktPublishing/Cpp17-STL-Cookbook/blob/ce2b8ae0aa4b1c36902ec9c838fa1e152699b590/Chapter06/gather.cpp#L15-L21), which is completely undefined behavior because at least one of the two comparison predicates it passes to `stable_sort` isn't a strict weak ordering. 
Just a quick note on [reading the content of a stream into a std::string](https://github.com/PacktPublishing/Cpp17-STL-Cookbook/blob/ce2b8ae0aa4b1c36902ec9c838fa1e152699b590/Chapter02/sentence_length.cpp#L46-L47). The author proposes this solution: cin.unsetf(ios::skipws); string content {istream_iterator&lt;char&gt;{cin}, {}}; However, the preferred solution should make use of `istreambuf_iterator` instead: string content { istreambuf_iterator&lt;char&gt;{cin}, {} }; Not only is this self-contained (it does not unset any flag on the stream), but also more efficient. For a full argument refer to Scott Meyers' **Effective STL** *item 29*.
As a person not yet too familiar with some of these things, would you mind explaining what's wrong with the iterator examples and how to do it better/correctly? (i.e. your second paragraph)
You cannot simply state that "during the execution of this function, both this function _and all others in other threads_ will treat every global as const". That's not (at all) how the language works, and any mechanism to implement that would have absolutely massive overhead. In fact I doubt you can implement it at all: you could never guarantee that the other threads are locked at an acceptable point for your pure function to run. For all you know, it might lock them in the middle of a complex, multi-variable update, at a point where the state is inconsistent. So, sorry, but pure functions are not a silver bullet for thread safety. If you want to access globals you'll need to do the locking, and you need to provide a memory barrier as well. Rusts borrow checker works on a completely different basis, and again, simply does not fit the model of C++. If C++ adapted that model, it would mean you get rust semantics on all your global variables simply because you used a pure function - which would mean massive changes to existing software just for being able to use even a single pure function. That's not going to happen. We do, however, have constexpr functions. As far as I can tell those are automatically pure as well, so they seem to be exactly what you want. 
It lacks a few `typedef` such as `pointer`, `reference` and `difference_type`, so any generic algorithm using one of those `typedef` will likely fail to compile.
AFAIK, generic algorithms are supposed to use `std::iterator_traits&lt;&gt;` rather than the typedefs for exactly this reason. A pointer is a random-access iterator, after all, and obviously cannot have nested types. :-] That said, that's a rule for the _consumer_; generally the author should supply typedefs rather than specializing `iterator_traits&lt;&gt;` (as Tim said).
I meant that the linked specialization of `iterator_traits` lacked those `typedef`, which is a rather serious problem
Ah, I see; agreed!
C++17 /u/STL Cookbook :)
&gt;"You cannot simply state that "during the execution of this function, both this function and all others in other threads will treat every global as const"." so it could only be done as a runtime check in a debug build for globals. so, upgrade my suggestion to **'functions that don't read globals'.** for the purposes of this discussion globals are effectively 'volatile'. there's an intermediate case, 'thread local storage' (which are still 'global' from the POV of the thread). Pure functions could still read those. &gt; Rusts borrow checker works on a completely different basis, and again, simply does not fit the model of C++ I disagree. C++ lacks the syntax, but both languages fundamentally have the same 'model'. we could upgrade C++ with a 'transitive const'. you could retrofit lifetimes via template parameters and smart pointers.
In case someone wanted to learn more about T.C.'s last point, have a look [here](https://stackoverflow.com/q/34834125)
&gt; We do, however, have constexpr functions. As far as I can tell those are automatically pure as well, so they seem to be exactly what you want. ok I wasn't aware of what these can and can't do, it's close, but it can only return potential literals. (strangely i'm seeing it taking variables, even though the docs say 'arguments must be literals' too).. perhaps the compiler is inferring in my simple test cases); e.g. it can't return an std::vector. e.g. 'a pure function for concatenating two vectors: returns a new vector containing the concatenation of both inputs' forget throwing OOM as a side effect , I'm assuming the subset of C++ without exception handling (OOM=UB, whole program logic must avoid it) 
C++/CX has been [described](https://en.wikipedia.org/wiki/C%2B%2B/CX) as: brings a set of syntax and library abstractions that project COM's WRL subset-based WinRT programming model... &amp; now that &gt;MSVC team is putting all of our weight behind C++/WinRT , should we be expecting https://docs.microsoft.com/en-us/cpp/cppcx/wrl-integration-c-cx counterpart article on VCBlog? 
Now that this has been up for a few days, I wanted to comment on this a bit more. My objection to the way the current standard is written is that it is arbitrary and makes no sense from a C++ language point of view. To see how arbitrary these symbol limits are, one need only look at the range \u2030-\u204f and realize that half are permitted and half are not. Look at the symbols themselves without referring to the standard and decide which ones should be OK in a C++ identifier and which ones should not be used. Then decide if the ranges, as written, make any sense whatsoever. The standards should be written in a way that makes sense for the language. If we were to amend 5.10, what criteria should be set for the inclusion or exclusion of Unicode characters used in an identifier? IMO punctuation symbols of any sort should not be allowed in an identifier. But we should allow wide latitude in the use of all alphabets and pictographs (including emoji) in identifiers. Take for example the [General Punctuation Range: 2000â206F](http://www.unicode.org/charts/PDF/U2000.pdf) (PDF alert). Should any C++ identifier contain any characters from this set? However, a â± class with member functions of â´, â¸ and â¹ (which is currently not permitted) is much more universally useful than one using Cuniform symbols (permitted).
IMO means ' in my opinion'. BEEP. BOP. I'm a bot! Was this helpful? PM me for feedback.
Is there any documentation for requirements? I'm working on a legacy project where it could be useful, but it's built on an old CentOS box and has a sufficiently insane makefile structure that it's a pain in the ass to get building anywhere else. Also just a suggestion but it could be helpful if you had an intentionally convoluted/spaghettified project included in the demo. In particular I'd like to see if this can help me get a handle on code with lots of global state. It would be immensely useful if I could find all of the statements/state that depend on a given state variable when there is some intermediate global variable(s) involved.
Anyone have c++11/14 version they recommend?
&gt;so it could only be done as a runtime check in a debug build for globals. No, it _cannot_. If you believe it is possible please specify a viable mechanism that does not rely on magic. &gt;for the purposes of this discussion globals are effectively 'volatile'. In order to read a variable... No, scratch that: in order to access any subsystem of your application that is shared with another thread, that subsystem (which could consist of any number of variables, containing any amount of data) must be in a consistent state. Do you agree with that? Reading from the subsystem while another thread is busy changing pointers and stuff will, invariably, end in tears. C++ has no way whatsoever to tell the compiler at which points in time a subsystem is in a consistent state. As the programmer it is _entirely_ your responsibility to enforce that subsystem access is limited to points in time at which the state is consistent. The typical mechanism for this is the mutex. Informing the compiler that something might change unexpectedly, which volatile has upon occasion been mistaken for doing(*), is just not enough. You must not only tell the compiler that something might change; you must in fact tell it when it can safely read from it. And as I said, C++ does not have anything, anything at all, to provide such information to the compiler. And after that you must also make sure the other threads don't proceed to yank the rug out from under you by a subsequent operation as well. In other words, you need a full-blown synchronisation mechanism for your threads, and the only one the language has on offer is protecting them with mutexes, and only ever under explicit programmer control. The compiler lacks the information to reason about them in any way. (*) atomic would be a better choice, but that doesn't change anything. &gt;I disagree. C++ lacks the syntax, but both languages fundamentally have the same 'model'. I haven't looked into Rust much, but as I understand it the borrow checker works by proving that only one thread can have access to a variable at any given time. This is fundamentally different from C++, where a variable can be accessed by any number of threads simultaneously. 
How does it scale? &gt; A document word position, tokenpos_t, is represented by default by an unsigned 16bit integer. This means that the maximum document position supported by default is 65535. That seems way to small to me?
&gt; No, it cannot. If you believe it is possible please specify a viable mechanism that does not rely on magic. in the debug build do something like 'properties' where reads and writes to the variable are actually turned into function calls with some guard. so the debug build will be a lot slower, but actually deals with a locking flag to expose any incorrect access. this would only be an empirical test, there would be the hazard of insufficient coverage of course.
&gt; I haven't looked into Rust much, but as I understand it the borrow checker works by proving that only one thread can have access to a variable at any given time. This is fundamentally different from C++, where a variable can be accessed by any number of threads simultaneously. so this wouldn't relate to a global (because any thread could acquire the globals, but rust marks globals unsafe , which either explicitely marks the places where globals are used, or encourages the user to write the wrappers). maybe we can modify the suggestion to that. 'can't use globals directly, has to call an accessor function'. the other side of rust (freezing etc) applies to variables in scopes which may in turn be passed down the call stack, but with the borrow checked restricting them if you try to do something hazardous.. so you could only pass one mutable reference to threads, or multiple immutable references. so lets just modify the original suggestion until it meets any of these scenarios. ('pure' really means 'no references to globals', or 'only using globals through accessor functions', or 'only using thread-local storage', etc etc etc)
Once C++/WinRT is officially supported the docs and blog should be updated. 
Sorry for the late response, I haven't logged in in a few days :) It sounds like you're compiling with cl.exe using /Zi, and then linking with lld. We'd like to support this, but I admit it hasn't been well tested (clang-cl treats /Zi as /Z7). Would you mind filing a bug? What happens if you replace cl.exe with clang-cl.exe (everything else can stay the same in command line etc)?
Thanks, I'll probably release a new distro for that.
I normally store a pair of flags for pressed or released. That way you can't really miss anything, other than 2+ presses in one tick.
Please realize that my comment is about making the standard meaningful for C++ the language. Most emoji (including the "pile of poo") are valid symbols for C++ identifiers today. The problem is that the current standard is not meaningful at all, including stuff that has no business in an identifier and leaving out much which should be (IMO) allowed. BTW, anyone who has used emoji knows that you don't need an infinitely large keyboard to construct such symbols. There are tools for that. The issue of missing glyphs *is* a concern -- but it is not a new one. I don't have fonts to deal with a large percentage of the Unicode code space that make up the list of currently legal characters in an identifier -- to say nothing of the ones legal in a character string. Edit: a word. Note also that this is coming from someone who prefers to use logical operators "and", "or" and "not" in my code rather than &amp;&amp;||!. Lots of C++ folks prefer the "emoji" variants of those operators today.
Yes but better than nothing at all
To be fair, &lt;execution_policy&gt; [was](http://en.cppreference.com/w/cpp/experimental/parallelism) the name of the execution policy header when it was still a proposal for standardization. Now that it's merged, it's &lt;execution&gt;.
No, get the electronic. There are numerous mistakes, and the electronic is cheaper. The book is mainly worth it only for the concurrency and filesystem stuff, as not a lot of examples using these new things exist yet.
1. constexpr functions can be impure, e.g. [duration::operator++](http://en.cppreference.com/w/cpp/chrono/duration/operator_arith2). 2. pure functions may not meet the requirements of constexpr functions, e.g. the return value of [recursive_directory_iterator::options](http://en.cppreference.com/w/cpp/filesystem/recursive_directory_iterator/options) only depends on its argument, but it can't be called with a constexpr argument, so it can't be a constexpr function. 
&gt; However, a â± class with member functions of â´, â¸ and â¹ (which is currently not permitted) is much more universally useful than one using Cuniform symbols (permitted). Your first example is shown as a black square so does not bode well.
&gt; Your first example is shown as a black square so does not bode well. The interesting question is "does not bode well for whom?"
&gt; OS support for UMS didn't materialize What about [User-Mode Scheduling](https://msdn.microsoft.com/en-us/library/windows/desktop/dd627187\(v=vs.85\).aspx)
Ok, thank you
One requirement is that the project can be built with clang. You can configure the target architecture via cross-compilation (https://clang.llvm.org/docs/CrossCompilation.html). The easiest way for project setup is via a clang Compilation Database. It can be exported from CMake via the CMAKE_EXPORT_COMPILE_COMMANDS flag or from Make by using Bear (https://github.com/rizsotto/Bear). More information in our documentation (https://www.sourcetrail.com/documentation/#CreateAProjectFromCompilationDatabase) We don't have a sample project with global variables, but that's a use-case that Sourcetrail can help you with. You can easily see where global variables are accessed.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6wm2r3/qt_learning_material_recommendations_books_or/dm95bt5/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
The official docs.
&gt; e.g. duration::operator++. What's impure about that?
Presumably it mutates a variable.
Just realized that `aÂ­a` is a valid identifier in C++ and is different from `aâa`, and both are different from `aâa`. 
I occasionally dabble with R, and it allows unicode variable names, so I can name things with the correct symbols for the domain and while it's slightly harder to type, it's extremely readable. (And since I do most of my programming on Linux, I can touch type most of the symbols with the compose key.)
TIL about [git-clang-format](https://github.com/llvm-mirror/clang/blob/master/tools/clang-format/git-clang-format) through the author's failed patch submission.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [llvm-mirror/clang/.../**git-clang-format** (master â 44a7b6b)](https://github.com/llvm-mirror/clang/blob/44a7b6b871e3d8c2b11f686571c9389e96586f7a/tools/clang-format/git-clang-format) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dm97bf9.)^.
Well it's not thread-safe. But yeah it is pure following OP's definition.
haha, love this, Windows users... they get what they deserve :) I see no fun in that.
This *may* be more efficient (but it's not really guaranteed, of course). At least for small files, I prefer code like this instead: std::string file2str(std::istream &amp;is) { std::ostringstream os; os &lt;&lt; is.rdbuf(); return os.str(); } In my testing, for reasonably small files (most you'd want to grab into a string) this ends up faster than essentially anything based on stream- or streambuf-iterators. Its Achilles heel is that it starts to slow down if the file is more than a few megabytes or so. For a larger file like that, you usually want code on this general order: std::string file2str(std::istream &amp;file) { std::string s; file.seekg(0, std::ios::end); s.resize(file.tellg()); file.seekg(0, std::ios::beg); file.read(&amp;s[0], s.length()); return s; } This is a little more complex, and could fail for a sufficiently ugly implementation (specifically, one that did some transformation that expanded the data when reading a text file), but it's *quite* a bit faster as a rule (though it doesn't really fit very well with an "STL"-themed book).
&gt; specifically, one that did some transformation that expanded the data when reading a text file Isn't that to be expected on Windows when reading files with LF line-endings (assuming the fstream isn't opened in binary mode)? EDIT: Derp â I was thinking in reverse, apparently.
In case you plan to do a follow-up episode: I would have added how targets and the `target_*` functions work and emphasized how much CMake changed since the 3.0 release. A lot people still use `include_directories`, `link_libraries` and friends because they read outdated documentation. The Effective CMake talk does a good job, but it's a bit too long. It would be nice to have a shorter C++ Weekly episode to link to. Maybe in the form of an example on how to `find_package` the Guideline Support Library (possibly from vcpkg), creating an imported target and then enable the GSL checkers in clang-tidy using the `CXX_CLANG_TIDY` property.
No. When reading, a CR/LF pair will convert to a single newline character. A carriage return or line-feed by itself will normally be left alone (or a CR might turn into a newline, depending on whose standard library you're dealing with). The only time expansion happens is when you're writing the data out *to* a file (a new-line will turn into a CR/LF pair).
I always thought that the best way to set the various compiler specific flags was through generator expressions, ie: cmake_minimum_required(VERSION 3.9) add_executable(intro main.cpp) target_compile_features(intro PRIVATE cxx_lambda_init_captures) target_compile_options(intro PRIVATE $&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;: /W4 &gt; $&lt;$&lt;NOT:$&lt;CXX_COMPILER_ID:MSVC&gt;&gt;: -Wall -Wextra -Wpedantic &gt; )
I really like that you discuss CMake in your C++ Weekly! However, I am still left confused by one thing ... What is the modern and effective way to set the C++ version? In CMake 3.9 we have - [CMAKE_CXX_KNOWN_FEATURES](https://cmake.org/cmake/help/v3.9/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html#prop_gbl:CMAKE_CXX_KNOWN_FEATURES) which features: target_compile_features: - cxx_std_98: Compiler mode is aware of C++ 98. - cxx_std_11: Compiler mode is aware of C++ 11. - cxx_std_14: Compiler mode is aware of C++ 14. - cxx_std_17: Compiler mode is aware of C++ 17. And we have the mentioned set_property way. But what to choose? Besides that it is also possible to prevent CMake from setting the gnu versions of the standard with: - [CXX_EXTENSIONS](https://cmake.org/cmake/help/v3.4/prop_tgt/CXX_EXTENSIONS.html) I think this is the preferred way over using -Wpedantic to exclude extensions.
this seems pretty convoluted as an introduction. most people would rather see how to easily add include dirs, link dirs, etc. before enabling recent c++ through detection of the lambda capture feature. Also cmake-gui would be much more friendly to show than ccmake from the get go.
I wonder again and again where c++ support in MSVC and winrt as a whole could be today, if MS had decided to go the route of c++/winrt from the beginning and invested the ressources into a better, standardconforming c++ compiler instead of developing yet another c++ dialect with questionable benefit. There were probably good reasons for that and I don't know enough of the internals to say whether it would have been even possible back then, but still -- all that wasted energy... 
VS for Mac is just a repackaged Xamarin Studio, which is a repackaged Monodevelop. It's turtles all the way down.
I've enjoyed each part of your series so far and encourage you to continue. Thank you for your time and effort!
This looks nice - thank you for sharing. Is 3.9 required or is this available in earlier versions of cmake?
No worries, thanks for the answer. I am already compiling with `clang-cl` and `/Z7` when this error occurs. Compiling with `cl.exe` and linking with `lld-link.exe`, FastBuild fails to spawn the linker's process but this seems like a different error. I don't mind filing a bug, but I don't have much information to provide. Is there a way I can have more verbose error messages ?
I've read at least 5 articles on lvalues and rvalues and never understood them. I haven't read this one, but plan on reading it after work. I hope this one is better than the others. Does anyone know of another article or explanation of what they are?
What about Powershell, maybe that can do it? I would be curious. Also if that doesn't work either, you can just use clang-format from WSL.
Here is a much simpler explanation: * lvalues are objects in memory that can be addressed by the code; they have a label. * rvalues are objects in memory that cannot be addressed by the code; they don't have a label. Example: int x = 10; The value 10 does not have a label, it is an rvalue. The variable x has a label ('x'), and therefore it is an lvalue. 
I *think* most of this works after 3.6. Here is a nice presentation on "modern" cmake: https://github.com/boostcon/cppnow_presentations_2017/blob/master/05-19-2017_friday/effective_cmake__daniel_pfeifer__cppnow_05-19-2017.pdf https://www.youtube.com/watch?v=bsXLMQ6WgIk 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [boostcon/cppnow_presentations_2017/.../**effective_cmake__daniel_pfeifer__cppnow_05-19-2017.pdf** (master â c0cef44)](https://github.com/boostcon/cppnow_presentations_2017/blob/c0cef4464de0ba9e0bb96cdb2ec0dc9039703202/05-19-2017_friday/effective_cmake__daniel_pfeifer__cppnow_05-19-2017.pdf) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dma2cin.)^.
I believe you meant to say "10 is an rvalue, and x is an lvalue".
Thank you, fixed it. 
You've got that backwards.... Lvalues are named variables that are not immediately destroyed. `10 = x` doesn't really make sense, but `int y = 10` does. Therefore `y` is a lvalue and `10` is a rvalue.
Fixed it, it was a typo. 
I wonder if you could potentially do this with the metaclasses proposal. Introduce a `const_class` keyword that iterates through each member variable and marks it const, unless the member variable is already labelled mutable.
Doesn't look that trivial but possible: Get-ChildItem d:\devel\project -Include *.cpp,*.h -Recurs -File | Foreach {clang-format $_.fullname}
This reminds me a lot of monads are burritos. I don't think these kinds of "friendly" definitions are helpful. Value categories aren't simple and a lot of this is misleading. For instance... &gt; On the other hand, a rvalue is something that doesn't point anywhere. Except xvalues? Which aren't mentioned. &gt; C++ states that an assignment requires an lvalue as its left operand But rvalues of class type can be the left operand of assignment. Also, I find it odd that you use the compiler to confirm what you state, but then affirm that "he" is correct.
Don't forget about prvalues, glvalues, and xvalues! 
This is a fantastic read for someone like me, it clearly specifies what it is. Up to this point I had a fairly vague understanding, but now I'm set up to look into the nitty gritty of them. I know it's not necessarily the 100% explanation but it's more than enough to help me understand the weirdly named l and rvalues. Thanks!
In the next episode! :)
/u/axilmar has done a good job of the super basic explanation. But I would add one thing: Why do we care? Because rvalues are not long for this life and don't get referenced anywhere else. We can suck out their innards! In particular, if it's a `std::vector`, we can take the memory it points too and not worry about allocating and copying the contents, leaving an empty husk behind. Note that most of the time we don't care what it is.
How many years does it take to get to your level? Could you suggest any eye-opening readings for a beginner++?
That certainly makes auditing code an interesting challenge.
I don't think specifying individual features as opposed to a targeted standard version is actually a good idea, because most likely the features specified will very soon no longer reflect the features that are actually used. Even worse, you can afaik not specify standard library features, which are usually also governed by those flags.
Thank you !! It's encouraging to hear indeed :)
You are correct. Starting with C++17 and moving forward CMake plans on only having having cxx _ std _* meta-features. 
My takeaway from the issues raised in the latter half of the article is that `std::unique_ptr` (and indeed, most smart pointer objects) really shouldn't ever be used with stack-allocated objects. The solutions presented in the article are a clever way to deal with that hassle, but it seems like it introduces way too many ways to screw it up. Especially since `unique_ptr` normally conveys the semantics "I own this object", and the scenario shown explicitly specifies that the `unique_ptr` does not, in fact, own the object it's pointing to (or, more precisely, it's conveying the semantics "this object *might* own the object it points to, but you don't quite know"). Not that there isn't useful utility in that kind of construct: template&lt;typename T&gt; struct observer_deleter { void operator()(T *) const {/*Do Nothing*/} }; template&lt;typename T&gt; using observer_ptr = std::unique_ptr&lt;T, observer_deleter&lt;T&gt;&gt;; //Not copyable, but has a semi-decent interface Really though, what this shows is that the standard is missing is some kind of `scope_guard` object. Either in the form of struct texture_deleter { void operator()(GLuint id) const { glDeleteTextures(1, &amp;id); } }; GLuint id; glGenTextures(1, &amp;id); std_suggestion::wrapper&lt;GLuint, texture_deleter&gt; texture{id}; //Will delete texture when object is destroyed Or: GLuint id; glGenTextures(1, &amp;id); std_suggestion::scope_guard guard{[id] {glDeleteTextures(1, &amp;id);}}; //Will delete texture when scope is left The former being more idiomatic for object encapsulation, the latter being more idiomatic for scope-local operations. Which I realize is veering off topic to a degree, but I do think these kinds of constructs are more valuable than trying to stretch `std::unique_ptr` into doing things like this. 
Oh boy we do. Forward-references and rvalue-references exist for a reason. You mentioned `std::vector`, rvalue-refs solved an optimizing problem about it: move-constructors only copy data members and set the *from object* to be empty. This way it doesn't need to copy all elements from one vector to another, making it way cheaper to move vectors around. Forward-references solve a problem of picking the right overload for a given value.
First of all, lvalue/rvalue is a terrible naming scheme. With that said: there are two axes which you care about; the "able to be moved" axis, and the "exists in memory" axis. The three kinds of values are `prvalue`, `lvalue`, and `xvalue`. `prvalue`s are able to be moved, and they don't exist in memory - you can think of them as a pure mathematical concept of a value. `lvalue`s are the classic `lvalue` - you can't move them, they exist in memory. `xvalue`s are kinda weird, and only exist because C++ originally didn't have move semantics; they exist in memory, but also can be moved. You can turn an `lvalue` into an `xvalue` through `static_cast` (or `std::move`), you can turn an lvalue or an `xvalue` into a `prvalue` through copy and move constructors, and you can turn a `prvalue` into an `xvalue` (for example, to pass to a function that takes a `T&amp;&amp;`) through something known as "temporary objects", which is basically where the compiler allocates space on the stack and constructs that `prvalue` into that area. (watch my cppcon talk for more information :3)
I was actually thinking of writing up a proposal for `std::unique_res(ource)` and `std::shared_res(ource)`. It would be nice to have a generalization of `unique_ptr`to a class of "resources" that don't have to be cast to pointers to work with the current type structure.
Could we get a link to your talk? Sounds interesting. EDIT: Looks like it's still upcoming in CppCon '17 in September :-)
Oh, that's nice. I had this problem a few months ago and couldn't figure out how to do it as a single line. I ended up writing a .ps1 file with a loop: foreach($file in get-childitem -recurse -include *.cpp,*.h,*.hpp) { clang-format -style=file -i $file } With this I must be in the directory I want to format when I run the script.
that might be nice but I think I would prefer something as widespreadly applicable to be inbuilt to the compiler's underlying rules , rather than relying on some sort of meta-programming mechanism (admittedly I haven't checked what this metaclasses proposal is, but it's making me think of something along the lines of [TMP](https://en.wikipedia.org/wiki/Template_metaprogramming) which sounds like it'll hit [compile times](https://stackoverflow.com/questions/318398/why-does-c-compilation-take-so-long))
Honestly this stuff is so crucial to using CMake effectively that if it were left out of the first episode I'd consider that episode to be worthless.
This isn't really true, there's no problem with using a smart pointer with any allocator, any more than there is a problem with containers. The smart pointer or container own the object but not the memory. They own an allocator, but the allocator doesn't own the memory either. I suggest taking a look at allocate_shared from standard library. 
MS VC++ includes an object file named `setargv.obj` that handles the Windows subset of globbing fairly automatically. If we take a program like this: #include &lt;iostream&gt; int main(int argc, char **argv) { for (int i=1; i&lt;argc; i++) std::cout &lt;&lt; argv[i] &lt;&lt; "\n"; } ....and compile it normally, and run with `foo *.cpp *.h`, it'll obviously print out `*.cpp` and `*.h`. If, however, we link with setargv.obj: `cl foo.cpp setargv.obj`, it'll replace its normal command line parser with one that expands wildcards, so when we run it, we get the names of the files we expect. This does *not*, however, support recursive directory searching. If you really need/want that, you will need to write code of your own to support it.
Something like this? [P052r5 Generic Scope Guard and RAII Wrapper for the Standard Library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0052r5.pdf) (which went through many iterations: [N3677](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3677.html) [N3830](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3830.pdf) [N3949](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3949.pdf) [N4189](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4189.pdf))
You may want to contact the authors of [N3949](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3949.pdf) and [N4189](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4189.pdf).
bad bot
Every OS is shit in some way
Windows has been more shitty than others I use in so many ways. You may be correct, but some shit can be more shitty than other shit.
I've been programming in C++ for more than 10 years, answering questions on SO a lot for about 3. For most of that time, I didn't know what an xvalue was. I'm not sure a beginner really needs to understand value categories. You can be pretty productive and write good code without that knowledge. YMMV.
Xvalues are rvalues and may be labeled. Lvalues may be not labeled. Enumerators are prvalues and names.
&gt; you can turn a prvalue into an xvalue (for example, to pass to a function that takes a T&amp;&amp;) through something known as "temporary objects" (since C++17) Through something known as "temporary materialization", and it's not just to bind a reference, but to call a member function or do anything with its result. Until you run a prvalue against an object (whether temporary or named), there is no result.
&gt; int x = 666; // ok &gt; ... &gt; C++ states that an assignment requires an lvalue as its left operand: this is perfectly legal. There is no assignment here, it's irrelevant what C++ says about them. &gt; int* y = &amp;x; // ok &gt; ... &gt; This is another perfectly legal operation: on the left side of the assignment we have an lvalue What assignment??
Yes, but it might be easier to talk through it on a bug report. I suspect it's unable to find a Visual Studio installation (it needs this in order to find system libraries like msvcrt.lib) and fails when trying to merge in the types from msvcrt.pdb. If it found the headers like &lt;windows.h&gt; or &lt;vector&gt; then it must be finding something, but maybe it has to do with the environment that your build system (FastBuild?) is spawning the processes with.
[This video](https://anders.com/blockchain/) came up on r/programming a few month ago and is a very simple and practical introduction.
Argh, this article is completely wrong about what lvalues and rvalues are. I hope anyone didn't read it and think they gained an understanding ... they'll just have to unlearn what they "learned" and start again
yes, I did. But lua is written in C, even if there are nice binding for lua in C++, adding great functionalities, I thought this was too heavy : I needed 2 libraries to do one thing. And also, it was (and it still is) great to learn how to create a programming language (even if this one is really simple if you take a look at how the parsing and tokenizing is done). :)
There doesn't exist any language called C/C++.
Which article is better?
Haha wow! Thanks for that. It's impossible to remember though, so you still need to put that into a script...
thanks, I was tired and didn't feel like wracking my brain (or the standard) for the actual terminology :P
To clarify for readers who may not know: there's a distinction between assignment and initialization. Initialization using `=` is not an assignment even though it looks similar. The examples `int x = 666;` and `int *y = &amp;x;` are declarations with initializers, not uses of the assignment operator.
I've literally only looked at a couple of files so far but two things I'd immediately comment: 1) Your base class BaseDecoder doesn't have a virtual destructor. That's just asking for a memory leak. 2) The first implementation of it (CafDecoder) isn't flagged final ~~and doesn't mark any methods with "override"~~ [edit: no idea what happened to my eyes there] -- if you never intend to inherit from a class it's a wise precaution to flag it final (if nothing else, to make a future you or another future developer to consider whether they actually want to inherit from this class instead of, for instance, mixing in common functionality), ~~and at the level of the compiler it's a good idea to mark methods as overridden, so that you get immediate compiler errors if an inheriting class implements a method that's been changed inthe base class~~. (Along the same lines I'd also remove the virtual declarations in the inheriting class, unless a further class inherits from it.) Also, your inheriting class has this: namespace nqr { struct CAFDecoder : public **nqr::**BaseDecoder You're already in the nqr namespace. I work with MSVC daily and it doesn't mark this as an error, but gcc does. In this instance, at least, I'd really quite like to see more compilers flag this up like gcc does... You also appear to be using shared pointers throughout, although you're also using C++11. Do you have a reason to be avoiding unique pointers? I would always default to a unique pointer until a particular usage case points me at shared or weaks.
Answering others' questions about C++, or rather doing research in order to find the answers, is a good way to really learn the technical details. Getting to know the C++ spec and getting practice reading it is key. It looks like I've spent about 6 years providing answers on SO. That said, I agree that not many programmers really need to know it that well. If you want to get into C++ compiler or tool development, or if you want to be 'that guy' on the team who can answer other team members' questions, then it's pretty useful. Otherwise you can just stick with the standard texts on 'coding standards' and 'effective c++' usage. CC /u/apis
How does it compare or will compare ChaiScript?
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [jeaye/value-category-cheatsheet/.../**value-category-cheatsheet.pdf** (master â fd656df)](https://github.com/jeaye/value-category-cheatsheet/blob/fd656dfe1aa8e85b643e6fd375019a6983ed01f3/value-category-cheatsheet.pdf) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmb02ky.)^.
Good stuff.
*sigh* There is no language called C/C++. Neither is there a language called Java/C#, nor Swift/Objective-C, nor Python/Ruby. But in all those cases the languages have enough overlap in their semantics that it can sometimes be useful to generalise. In this case (I assume -- I haven't actually watched the video), when discussing build systems and handling dependencies, C and C++ work in exactly the same way. Would it really have made any difference if the OP had said "C and/or C++" in the post title?
\&gt;rvalues \&gt;understanding lol ok
C+libraries?
To expand on this (and someone correct me if I'm wrong). EDIT: whelp, turns out I need to read the standards more... The below is wrong, see replies for why. Rvalues were added to the *language* while move semantics were added to the *standard library*. The language itself says nothing about move semantics - it's the standard library which uses the rvalue references feature of the language to implement move semantics. 
The language has formal notions of "move constructors" and "move-assignment operators" entirely separate from the standard library. ;-]
 I've seen it before. What it does, it does well. But it is like a Chinese meal. You're hungry again half an hour after watching. 
But aren't those simply overloaded constructors and move assignment operators?
Yes, but I don't see what that changes... You said "*the language itself says nothing about move semantics*", but it does â it formally defines move constructors and move-assignment operators and distinguishes them from all other constructors/assignment operators; it also mentions moves a few times before the standard library is brought up, e.g. in C++14 [basic.def.odr]/3 it reads in part: &gt; A constructor selected to copy or move an object of class type is odr-used even if the call is actually elided by the implementation.
You are correct. Seems I need to read the standards more. I was going to ask a theoretical question but decided I'll go read the standard more first. :)
&gt; There is no counterpart to that in C++. Uhm, what? A const value in C++ is immutable, and globally const. The problem in C++ is that you can't know if a const reference actually points at a const value, or if you simply have a const alias to a mutable object.
Work at an HFT?
Correct me if I'm wrong, but isn't mp3 out of the licensing woods? I think the patents have expired. 
&gt; And any poor soul who has tried to program UWP in C++ using WRL will surely (and sadly) attest to that. I personally did both and strongly prefer WRL. You can build wrappers around many things there, and while you can't chain method calls easily on a single line, it is _vastly_ easier to debug than C++/CX. Using that also means you don't have to learn the weirdness of some parts C++/CX which you wouldn't know unless you ran into it. And finally, C++/CX has a lot of non-obvious overhead, which I've definitely run into in the past when we weren't careful.
(author here) Correct! Fraunhofer had a press release in April saying they've discontinued licensing due to the patent expiration - https://www.iis.fraunhofer.de/en/ff/amm/prod/audiocodec/audiocodecs/mp3.html Arguably MP3 has been dead for a while, so I likely won't add support unless it came through a pull-request. Opus has offered superior encoding for a while, and there's also a variety of other competitive formats. The main use-case of libnyquist is for an audio engine, and I can't find many examples of games shipping MP3-encoded files recently. 
Totally understandable. I work with audio software so from my viewpoint compatibility with many formats is of interest. 
Thanks for the feedback! I'd like to find time to take another stab at this library, especially to address some of the interface deficiencies you note. It's very "circa-2015 me" code and was shipped pretty quickly to get unblocked on other projects. 
Cool :) I'm planning on looking through in more detail for my own interest. I'd be happy to note anything else major that I see on the way, or if it'd just block you again I'm equally happy to hold my tongue.
Could you elaborate? Saying "it's all wrong" makes it seem like you only read the first paragraph, disagreed one thing, and stopped reading to post this comment. While there are a couple of things in the article that I'm not sure are 100% accurate, I think it's a good page to give to a C++ programmer who doesn't know what an rvalue is. It gives a good intuitive understanding. That can be corrected in detail later.
Try harder with your spam. This is the C++ subreddit.
C and C++ do not work in exactly the same way. That is exactly the misconception that is expresses by C/C++.
Could you point out a difference that is relevant for package/dependencies management ?
Some Lua wrappers makes C++ binding really easy though, but creating a language for learning purposes is still a good idea
I enjoyed other posts on this site in the past, but I am afraid this one is especially bad. Firstly, making smart-pointers to objects allocated on the stack should have a big red caution warning sign "Don't try this at home" on it. You can do it, but there are dragons inside you need to tame. Using it to introduce custom deleters to potential newbies (without mentioning the dragons) is criminal. The dragon here is that since `std::unique_ptr` is moveable you could create a situation when the (moved) pointer outlives the pointee object. In that case the object is destroyed and the pointer is left dangling. Secondly, the trick to use `std::unique_ptr&lt;const Instructions&gt;` in the "Safety belt" section is suggested to solve an unspecified problem ("trust me"). However, it does not solve the real problem (the "dragon" above) and is actually of very little use in practice. The correct way would be to use `const std::unique_ptr&lt;Instructions&gt;` instead. Instances of this type are effectively non-moveable so there's no way (excluding a `const_cast`) the pointer can outlive the pointee. Of course, this would break the example, since it requires a moveable type, but, really, it's the example fault, not the pointer's. Finally, I find particularly annoying the final sentence "other languages, like Java or C#, would do better ". Those languages have a totally different object model, so it's comparing oranges with apples.
I'm not working in audio, but as a suggestion, if you want to make the library accessible to a larger audience, add a CMakeLists. Then you can also remove the hand-created .vs and .xcode project files :-)
Compared to ChaiScript, Hitoban is smaller in term of size of the source code and in term of functionalities. For some people, it is probably harder to read, because it's a lisp-like syntax. I don't think I can do something better than ChaiScript, and it wasn't my goal, but I do think I've fulfilled my ambitions about this project : it is a programming language really small and easy to use (once you know a little about how lisp works). I understand it isn't as powerful as ChaiScript, and I am currently working on some nice features, as something of this kind : `htb::register_function(&amp;my_function, "my_function", &amp;my_htb_environment);` (while ChaiScript is doing `chai.add(chaiscript::fun(&amp;helloWorld), "helloWorld");`). I think it is called an exposure lib or something like that, but I am not sure ^^'
Then this is wrong: &gt; Dyno is pure-library implementation of what's also known as Rust traits, since Rust traits can be used to dispatch at both run-time and compile-time. Maybe you meant Rust's "trait objects"? --- EDIT: - the first example in the readme should probably call `f` with a `Square` and a `Circle` to show that the library actually works (e.g. by adding a `// prints circle` or similar). This is only shown at the very end of the readme. - It would be great if one could use the `Drawable` "thing" (the readme doesn't say what they are called) to constrain generic function arguments at compile-time (e.g. using concepts or `enable_if`). - It would also be great if one could use the `Drawable` "thing" to do static dispatch in generic functions. As in, not only great, but better than concepts, since this allows users to "map" functionality instead of being a purely syntactic thing (which then requires adding customization points, which are a pain to add and use in C++).
Does C++ guarantee ABI compatibility between standard versions? E.g. am I guaranteed that linking a C++03 library that uses `std::string` against a C++17 library that does the same succesfully works? Am I guaranteed that linking C++14 against C++17 actually works? (e.g. due to inline variables?). If this is not guaranteed, then this discussion seems kind of moot to me. Also, currently, depending on which platform you are, you are not guaranteed ABI compatibility at all between compiler releases, which might happen up to 3-4 times per year... IMO if somebody in the std committee ever says "but this would break ABI compatibility between standard releases" the first question to ask would be "which ABI compatibility?", as in, that person should name a single toolchain that guarantees ABI compatibility across standard releases.
&gt; Xvalues are rvalues and may be labeled. Xvalues return rvalue references when evaluated, and so they are labeled. &gt; Lvalues may be not labeled Example? 
Mixing C++ and Python would make your code to complex. Not sure of the right solutions but I guess there are some. If you do choose on doing that make sure you fix any error occur out of complexity as it can damage you code. If help needed, there are programs that might help such as checkmarx or others that help detecting vulnerabilities in the code. Good luck!
Thanks for the advice, I am going to check that :)
We are planning to release Catch 2 final soon\*, so if you are planning to update, this might be a good time to test it and give us a heads up if something broke. For more complete changelog from Catch Classic, look into the [partial release notes] (https://github.com/philsquared/Catch/blob/catch2/docs/release-notes.md) \*Soon originally was around May, so take it with a grain of salt :-)
Pure, can only read globals that are const. 
any chance of releasing catch 2 before the 20th of september? I'm eager to redo the benchmarks of [doctest](https://github.com/onqtam/doctest)/[Catch](https://github.com/philsquared/Catch) before CppCon (might also use a dev build...) For those interested - I'll be presenting at [CppCon 2017](https://cppcon2017.sched.com/event/BgsI/mix-tests-and-production-code-with-doctest-implementing-and-using-the-fastest-modern-c-testing-framework)!
Resuming there is fine. You'll see several examples of that in my tutorials
In that case it would be nice if microsoft stopped making the 32-bit builds the default in new MSVC projects. I really hope that 32-bit/x86 on Windows is dying ASAP and any action from MS that quickens that process (deliberately or not) is welcomed from my perspective ;). Sorry, I know that attitude doesn't help people that "have" to maintain/develop x86 code, but sometimes I can't help myself.
In many, if not most cases, multi-threading should be transparent and you shouldn't be managing threads directly. Think of jobs to be done, and use a thread pool that can automatically execute the jobs and provide you with results - think of `std::async` over `std::thread`. Standard library as well as various frameworks implement this. Investigate parallelization offered by your compiler - it might do some of this automagically :)
in easy terms ? noob here 
Look into `std::async` and `std::thread`. If you're going to access/modify the same data in different threads (which is very likely), look into mutexes (`std::lock_guard`, `std::unique_lock`, etc). There is more of course, but reading up on these subjects should be enough to get you started.
Here's what I addressed from the original post: &gt; My takeaway from the issues raised in the latter half of the article is that std::unique_ptr (and indeed, most smart pointer objects) really shouldn't ever be used with stack-allocated objects. A stack allocator does involve a pointer, not sure why you would think otherwise. I'll suggest to you that you follow my suggestion and read allocate_shared. If there was a allocate_unique, creating a stack allocated objected would look like this: auto x = allocate_unique&lt;Foo&gt;(my_stack_pool.get_allocator()); And that's it.
Until checking is allowed in multiple threads, I can't use this library. But it sure looks very tempting.
Shared memory, heterogenous threading is the hardest kind of parallelism to reason about, be cautious. I wrote a [parallel.h](https://pastebin.com/gvF08b05) for some of my stuff that just uses openMP to give you a parallel for loop. As long as you follow the rule that there's nothing shared between loop iterations, you'll be OK and it'll get you surprisingly far for a lot of problems.
You may also want to look into `std::atomic`, which handles all the fiddly mutex stuff for you when dealing with primitive types (char, int, etc). This can be especially useful if you need to do something simple like increment a counter that is shared between threads.
&gt; In that case it would be nice if microsoft stopped making the 32-bit builds the default in new MSVC projects. 100% agreed; I expressed this recently [here](https://www.reddit.com/r/cpp/comments/6tnt8t/visual_studio_2017_version_153_released/dlobc47/?context=2). IIUC, the more we pester /u/spongo2, the more likely this is to happen. ;-] -- ^^Sorry, ^^Steve ^^:-P
What do you want to multi-thread?
I know you wish to instantly put your fingers on the keyboard, but wait a second. First of all, I recommend you to get familiar with multi-threading concepts and ideas. In my opinion a good book is a good start and it gives you a certain roadmap and a line of discussion. Online you can find lots of books and resources. To "kill two birds with one stone", [this book](https://www.manning.com/books/c-plus-plus-concurrency-in-action-second-edition) is a great introduction to multi-threading in C++ that does not assume any prior knowledge or experience of multithreaded programming (that may be useful, though). I read the 1st edition and it rocks! Another example is this "old but gold" and quite short [online series by Bartosz Milewski about C++11 Concurrency](https://www.youtube.com/watch?v=80ifzK3b8QQ&amp;list=PL1835A90FC78FF8BE). For the sake of your learning path, putting your hands on excercises like "implement a thread pool" or "write a concurrent queue (without claming to be super-fast)" can be instructive. A good book generally includes such challenges in a coherent order. However, as other people commented, in general you should avoid rolling low-level threading on your own but, instead, move to task-based parallelism where possible. Most of the time you won't even need to implement many things because they are already provided by the standard library or by other frameworks/libraries. At the end of this (preparatory) learning path, you can commit yourself to a more realistic project.
The good thing about developing on Linux is the plethora of tools that exist. There is `cscope`, an oldschool lookup tool for definitions and stuff in large C code bases. There is also `ctags` which generates a (basically) non-human readable "database" from your code for editors and such to integrate. There is a magnificent tool called [codequery](https://github.com/ruben2020/codequery) that takes `cscope` and `ctags` and puts in all in a searchable interface. Seriously, use this for browsing unfamiliar codebases. It supports a bunch of languages (see my note on ctags below) and is really fast. Godspeed. note on ctags: There are different implementations of ctags that support different languages and sometimes different output syntax and such. You can get by with the regularly packaged ctags but sometimes you need excuberant-ctags or some of the newer variants. 
Multi-threading can be difficult, you may want to consider reading as much as possible and testing out lots of small fragments before you jump in. 
This is an instance where pedantry is not helpful. This is a package manager, not some code library.
I had a similar need a while ago and I went for implementing a python byte-code interpreter. You use normal CPython to compile the (relatively) complex python syntax to byte-code and then implement the thing that runs the relatively simple byte-code. Have a look: https://github.com/shooshx/zippypy 
Wow ! That's amazing, good job !
In easy terms: don't make it hard. If you're managing threads yourself, e.g. instantiating `std::thread`, or managing synchronization primitives yourself (e.g. `std::mutex`), you're doing too much work, and things are too complex. A thread or a mutex are very low-level primitives. Try to always work at a higher level. `std::async` lets you submit a job (a functor, etc.) for execution - including asynchronous execution on other threads that are managed for you. Leverage the heck out of it. It returns a `std::future` that is used to access the results - with synchronization taken care of for you. But there are even higher-level primitives. For example, if you have a `for` loop that operates on some data elements without dependencies between the elements, it can be parallelized by the compiler - the compiler can generate the code to submit chunks of the loop for execution on a thread pool. By the time the loop finishes running, you're guaranteed that all the under-the-hood threads have finished and the results are ready. If the compiler can't do it for you, you can use map-reduce frameworks to explicitly submit the work in a form that can be parallelized by the framework code - and again, by the time the map-reduce operation is done, the results are gathered up for you. So I think the high-level recommendation is to use the highest-level primitives available, and to think of individual threads as something you only need in select few special circumstances, usually when implementing library or framework code.
Do you want to implement multi-threading, or use multi-threading?
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
there's one nice cheat sheet as a good reference: https://goo.gl/974SEQ
Okay, in line with your first two points (I guess that the different object model for Java leads to a simpler code in this situation. But I get your view.) I've worked your remarks into the post as omitting them would be misleading for beginner developers, as you underlined. Your feedback is valuable, and I must say that I appreciate you took the time to develop it despite the fact you didn't like this post as much as others! So thanks for contributing.
Right, I'd say `=` in `int* y = &amp;x;` has as much to do with assignment as `*` with multiplication.
I like Bjarne's two-dimensional map too, but that's history now: http://en.cppreference.com/w/cpp/language/value_category#C.2B.2B11
&gt; Xvalues return rvalue references when evaluated They can bind to rvalue references (as well as any other rvalue), but they don't "return" them, whatever that means. &gt;&gt; Lvalues may be not labeled &gt;Example? `"abc"`, `*p`, etc. Everything other than the first bullet point in http://en.cppreference.com/w/cpp/language/value_category#lvalue 
No need to wonder anything, I'm a user of many OSes, and Windows is just the worst, simple.
Use it
No, MSVC's expression SFINAE still needs work before it can go near Hana. Fortunately, those two particular things are easy to implement in isolation. I'm on mobile now, but I'll post implementations in a few hours if no one else does in the meantime. I know /u/pfultz2 already has an implementation available for MSVC in his Fit lib, and I seem to remember /u/notayakk posting a few different implementations on SO...
**Company:** [http://pspdfkit.com](http://pspdfkit.com) **Type:** Full time **Description:** We're looking to hire an experienced C++ developer to join our team working on PSPDFKit, the leading PDF framework for iOS and Android. Our framework is used by many companies in countless different settings, which brings unique challenges, especially around API design and writing robust code. **Remote:** Yep! We're fully remote. There's usually one to two company [retreats](https://pspdfkit.com/blog/2017/4-steps-to-a-successful-company-retreat/) in Europe each year to meet up and discuss everything that needs discussed! **Location:** HQ is in Vienna, Austria. **Technologies:** - We mainly use C++14 but are trying to get C++17 going (when all compilers support what we want). - Using a Mac is required, as we do develop a iOS framework in addition to our other product. - We do sparingly use boost. - We have a lot of other languages going on :) Obj-C, Swift, Java, Kotlin. We also cross-compile our C++ code to [WASM](https://pspdfkit.com/blog/2017/webassembly-a-new-hope/) for our web product. **Contact:** [https://pspdfkit.com/jobs/#senior-cplusplus-engineer](https://pspdfkit.com/jobs/#senior-cplusplus-engineer) or if you have more questions, just shoot me a message either here or on Twitter (@pweisk)
`target_compile_features` is the best way in most situations. This will cause the compiler features required by a library to be propagated to other targets who link to it via `target_link_libraries`. Otherwise, you'll need to set the interface properties yourself manually.
See https://software.intel.com/en-us/articles/c17-features-supported-by-intel-c-compiler for a newer version of the table.
Some developers appreciate the commercial support model and some companies require using a commercial compiler for this or other reasons. (And care about Linux, hence MSVC is not relevant.)
Use of Linux is strongly correlated with open-source software development...
PSTL support was introduced in Intel 18 beta, so version 18+.
Not exactly blindly. You can choose the stdlib on Mac. I don't know about other platforms. icpc -help | grep "\-stdlib=" -A3 -stdlib=&lt;keyword&gt; select the C++ library used for linking libstdc++ - links using the GNU libstdc++ library libc++ - links using the libc++ library (DEFAULT) 
Paging /u/GorNishanov
Thank you. I found this one working: http://martinecker.com/martincodes/lambda-expression-overloading/
Abi compatibility
As a beginner am still at a whiny stage of how difficult programming is. I do realize that it wasn't easy for anyone, and just taking it one day at a time, good or bad. 
This is also completely wrong. lvalues and rvalues are categories of expression, not objects. They may *designate* objects, but each category can designate all possible objects. Also, in your example, `10` is not an object , however you say "10 is an rvalue" and "rvalues are objects", a contradiction.
This is the best one I know of: http://en.cppreference.com/w/cpp/language/value_category [This article](http://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c) linked in the references to OP's article is not bad. However, OP seems to have started off with the misconception that lvalues are objects, and in the process of internalizing this article, mangled it in order to not contradict that original misconception.
What about range-v3 [1]? The MSVC 2015 fork[2] is quite outdated. 1: https://github.com/ericniebler/range-v3 2: https://github.com/Microsoft/Range-V3-VS2015
The biggest mistake is that the article continually identifies the terms "lvalue" and "rvalue" with objects, e.g.: &gt;an existing object in a specific memory location, i.e. an lvalue. &gt; an rvalue that needs to be stored somewhere in an lvalue. &gt;create a temporary variable where to store the rvalue *This is completely wrong*. Lvalues and rvalues are expression categories, not objects. You can't "store something in" an expression. Nor can you store an expression in a variable. There are many more cases of these bogus sentences throughout the article, I just picked 3 here. Most casual articles or blog entries on the topic repeat this mistake. The section titled "Lvalue references" is bogus from start to finish. For example here is another false statement: &gt;Can an rvalue be converted to lvalue? Nope It goes on to "explain" that `int&amp; yref = 10;` won't work under the author's understanding of lvalues and rvalues, however the same argument would imply that `const int&amp; yref = 10;` or `int&amp;&amp; yref = 10;` are errors for the same reason when in fact those are valid code. The author goes on to mention `const int&amp; yref = 10;` with some more bogus explanation, that neither points out what was wrong with his previous paragraph, nor is actually correct in any way. 
A coroutine is considered suspended immediately after the call to `await_resume` that returned `false`. Thus, when `await_suspend `is being executed coroutine is considered suspended and it is safe to resume or destroy the coroutine from the current thread or any other thread. A common scenario is to launch async activity from within `await_suspend` and pass a coroutine_handle, that was helpfully provided to await_suspend, as a context to whatever async activity you are launching. When it completes, you are free to resume the coroutine. No extra synchronization is needed. In case of a bool returning await-suspend, you can veto the suspend by returning `false` if you failed to initate async operation (and cannot / do not want to use exceptions to report the failure). However, if you launched an async operation successfully and return `false` from await_suspend, thus, cancelling a suspend, you will end up with double resume, ouch! 
&gt; A common scenario is to launch async activity from within await_suspend Really? [It would result in copying function arguments](https://stackoverflow.com/q/45311488/343443) and quite boilerplatish wrappers. More that that, I've found that it could be useful to launch async activity before co_await: auto f = coro_1(); co_await coro_2(); co_await f; (Also see the `connect` function in [this answer](https://ru.stackoverflow.com/a/703716/177684) for a somewhat practical example.)
As I understand it, metaclasses could be described as a way to allow us to automatically inject behavior and add constrains to a type being defined. It uses a mix of compile time reflection and code generation in order to achieve this. You could, for example, think of `struct` and `class` as metaclasses that add to your type: default operators, default constructors and control the default visibility of members and inherited types.
Same deal as Hana, unfortunately. :-[ Maybe /u/CaseyCarter has new news..? FWIW, Clang 6 trunk has been working _really_ well for me on Windows, even for many very-Windows.h-dependent projects, and even using `lld` instead of `link` for LLVM's LTO... If you're longing for C++1z/C++2a on Windows it's a surprisingly good experience lately â highly recommended.
You should at least benchmark "catch 2 rc3" in your graphs! Would love to see that!
That code lacks perfect forwarding and `overload_linearly`, but if it works for you then less typing for me. ;-D
I have a good mechanism for determining if company I talk to about working there is up to date wrt C++: if they use Herb as example of C++ expert or they send employees to his overpriced courses I know they are not. 
The [Fit](https://github.com/pfultz2/Fit) library works with MSVC 2015, and has both [`match`](http://fit.readthedocs.io/en/latest/include/fit/match.html)(ie `hana::overload`) and [`conditional`](http://fit.readthedocs.io/en/latest/include/fit/conditional.html)(ie `hana::overload_linearly`). Its also fully transparent(which hana is not), so it preserves `constexpr`, sfinae, and `noexcept`. 
okay thank you very much for pointing that difference out to me. :)
A naive replacement of cl.exe with clang-cl.exe (via llvm-4.0.1) caused a lot of boost (latest version) errors, e.g. from boost/mpl. It mostly seemed like boost was unable work with _WIN32 (and maybe even _MSC_VER) defines and a non-cl compiler. I don't know how well clang.exe would work with binary libraries compiled with msvc. Are there llvm 6 nightly binaries?
I use `clang++`, not `clang-cl`. I also [apply some patches](https://www.reddit.com/r/cpp/comments/6v60q7/boost_version_1650/dlzs2rt/) to my Boost sources that include various MSVC fixes, but I've never had a problem with MPL to warrant any changes there. I use the LLVM binaries from here: https://llvm.org/builds/ Not nightly; updates pretty sporadically from what I've seen.
Range-V3-VS2015 is somewhat stale, but does work with VS2017 also. I plan a fresh VS2017 port in the 15.5-ish timeframe that should be upstreamable (i.e., not too intrusive to checkin to github.com/ericniebler/range-v3). 
Apparently this article is quite controversial :P It's a good classical explanation of lvalue and rvalues in C++. The most important piece of that article (and the reason why I personally recommend it) is because the author highlights that temporary variables can be bound to const references. This is huge. It gives you a proper foundation for understanding rvalue references (mutable references to temporaries) and subsequently, you can derive the meaning of xvalue and prvalue from this as well.
Currently, the C++ standard has no official level of support for ABI stability, but it's usually assumed that ABI breaks are bad (because they require people to recompile their software, which may not always be easy or even possible). &gt; If this is not guaranteed, then this discussion seems kind of moot to me. This is a purist's point of view. I personally don't care at all about ABI compatibility because the company I work at has reproducible builds, we build everything from source (not locally of course), and I write software that's used internally only, so we have control over where the binaries end up. But not everyone is in that situation, and for a lot of people an ABI break is a _big deal_. I don't think dismissing this _reality_ in favor of purism is a good thing (in that specific case, at least), but that's just my opinion. 
&gt; since Rust traits can be used to dispatch at both run-time and compile-time. Maybe you meant Rust's "trait objects"? I knew they dispatched both at compile-time and at run-time but I did not know there was a specific name for the runtime mechanism. Thanks, I fixed the README now. &gt; the first example in the readme should probably call f with a Square and a Circle to show that the library actually works Fixed, thanks. &gt; It would be great if one could use the `Drawable` "thing" (the readme doesn't say what they are called) Currently, they are called _dynamic concepts_. The README says: &gt; This defines `Drawable` as representing an interface for anything that has a function called `draw` taking a reference to a const object of any type, and a `std::ostream&amp;`. __Dyno__ calls these interfaces _dynamic concepts_, since they describe sets of requirements to be fulfilled by a type (like C++ concepts). However, unlike C++ concepts, these _dynamic concepts_ are used to generate runtime interfaces, hence the name _dynamic_. [...] &gt; [...] to constrain generic function arguments at compile-time (e.g. using concepts or `enable_if`). `dyno::models&lt;Concept, T&gt;` is an IntegralConstant representing whether the type `T` models the concept `Concept`. Note that modeling a concept in Dyno is different than with C++ Concepts (lite), since there are no syntactic constraints associated to a concept, only the map of functions. So modeling a concept in Dyno is just providing this map of functions. I don't know whether it's useful to use that in conjunction with `enable_if` to constrain your own functions, but you can do it if you want. &gt; It would also be great if one could use the `Drawable` "thing" to do static dispatch in generic functions. Yeah. I could extend the library to allow for that, I think it would be burdensome to use on a regular basis for function templates. On the other hand, it would give you a proxy for definition checking, which Concepts lite can't do. Basically, if you always used `drawable&lt;T&gt;` as a proxy to the actual type in the template, you'd only have to instantiate it with one `T` to make sure your template does not make too many assumptions about all `T`s. That's sweet, but it would come at the cost of usability, compile-times, and error messages. 
Does not look like it :-(. I'm sure the VS folks are working really hard and I'm looking forward to testing Hana on VS! __Edit: Actually, I'm looking at `overload` and `overload_linearly`, and there does not seem to be anything too crazy going on there. I wouldn't be surprised if those two utilities worked. What error(s) are you getting when you try to use it on VS?__
Just to be clear: I was not talking about x86 vs x64 Hosted toolchains, but about the default target architecture for which your code gets compiled. Afaik both, the x86 and x64 version of the MSVC toolchain can produce 32 and 64 binaries and I find it pretty annoying that 32bits are the default. I understand of course that they cannot just drop support for x86 targets, but why on earth is it still the default for *NEW* projects? That being said and as per my previous statement I also find the fact, that the Visual studio IDE and lots of its components are still x86 only programms pretty annoying and just like you I wonder why the x86-hosted toolchain is still the default. Are there any drawbacks when using the x64 version? 
Did it take you three months to think of this meaningless comment?
Hmm... OK, I see why you would say the the article is entirely wrong. Thank you for explaining!
It's hard to do that, because you don't know what to put in the header or not. (Sometimes you want functions or variables to not be accessible outside of the .cpp file.) Hopefully someday the C++ standards group can come up with a better import system to replace this horribly outdated one.
Nice! I toyed with a Schemish interpreter a while back, only got as far as a simple calculator. [VScheme](https://github.com/ClockworkV/VScheme/blob/master/VScheme/main.cpp) Funny how similar these types of programs end up looking. 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [ClockworkV/VScheme/.../**main.cpp** (master â c7b6866)](https://github.com/ClockworkV/VScheme/blob/c7b68665f859ed1fd7a0694b3660a4ca1564cd6b/VScheme/main.cpp) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmd7kq5.)^.
`*[]{}` is an lvalue that refers to a function (not object), and does not have a name.
Why do you want to use RC?
good bot
Never heard of the Opus encoding format before. Seems pretty awesome, superiour to my previous favourite Vorbis in all ways. No drawbacks? 
Funny but also really interesting, because it means you can create a lisp-like language in any language without knowing where you are going, and it will always end up the same :) Just small modifications and you will have the same language implemented in any language you like. Also it is sooooooooo easy to implement, that's why I love Lisp (I got a little bit out of subject ^^')
deleted ^^^^^^^^^^^^^^^^0.4808 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/68083)
deleted ^^^^^^^^^^^^^^^^0.9807 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/22368)
deleted ^^^^^^^^^^^^^^^^0.1944 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/21680)
It's not an lvalue. It cannot be assigned to. Or I am wrong, so please elaborate, 
It's not hard to do that. All function definitions go to the .cpp file, unless the function is an one-liner, and then they go the header file. All variable non-static definitions get mentioned in the header file, otherwise they only exist in the .cpp file. 
No, expressions are not lvalues/rvalues. Only objects are...the word 'values' is not there by chance. 10 is an object in memory alright. That is optimized and does not exist in memory in the final program is not of interest in this discussion. 
&gt; They can bind to rvalue references (as well as any other rvalue), but they don't "return" them, whatever that means. When xvalues are bound to rvalue references, and the xvalues are used, they are evaluated. When they are evaluated, they 'return' something, even if that something is themselves. &gt; "abc", *p, etc. Everything other than the first bullet point in http://en.cppreference.com/w/cpp/language/value_category#lvalue But all these are labeled. 
"It" in this case is a `void(&amp;)()`, which is very much an lvalue. ;-] (`*` is dereferencing the function pointer that the lambda is implicitly convertible to due to being captureless.) You're right that lambda expressions in general are temporaries, thus rvalues by definition. That said, the possibility of 'being assigned to' isn't really relevant, as a type doesn't need an `operator=` to be an lvalue, and const lvalues are a thing...
As a new to c++ I recommend you to work slowly at first. In c++ you've got to stay focused while writing because there are a lot of vulnerabilities. That's my recommendation for you. If you're having problems detecting those kind of vulnerabilities you can try using any program to help you, I've heard of one called Checkmarx so you can try.. Good luck.
&gt; No, expressions are not lvalues/rvalues. Only objects are...the word 'values' is not there by chance. Those are [value-categories](http://en.cppreference.com/w/cpp/language/value_category), which believe it or not, _only_ apply to expressions. &gt; 10 is an object in memory alright. Define "object" â is `10` ODR-used?
Maybe, maybe not. I'd just benchmark a commit to catch2 branch and call it a day. We will probably want to rethink our testing strategy before final release, because two bugs that were supposed to be fixed made it into the dev release (they don't show themselves on piece-meal project, only in single include header). A quick and dirty benchmark says that Catch 2 is faster in test files by ~20% when compiled with Clang. Compiling main is approx 25% slower.
Everything you just said is wrong. See section [basic.lval]/1 of the current Standard: &gt;Expressions are categorized according to the taxonomy in Figure 1 &gt; &gt; [ ...] &gt; &gt; Every expression belongs to exactly one of the fundamental classifications in this taxonomy: lvalue, xvalue, or prvalue. This property of an expression is called its *value category*. It is analogous to how animals are categorized into species. 
All these types of expressions yield objects, and they categorized after the category of the object they yield. I am sorry, but the standard seems wrongly worded here. 
I think the standard is erroneously worded. These expressions get the categories of the objects they yield, and so in reality it is the objects that have categories, not the expressions. &gt; ODR-used? what does ODR mean? 
The standard is authoritative for C++. &gt;All these types of expressions yield objects An lvalue expression may *designate* an object, but it is not correct to say it *is* an object. Also , some values are not objects, e.g. `10`. From the same section of the standard: &gt;An rvalue is an xvalue, a temporary object or subobject thereof, or **a value that is not associated with an object**. See section [intro.object] for the definition of an object. 
So, you are saying that there is case where there is an unnamed pointer, that of an implicitely convertible captureless lamda, that is an lvalue? Can it be assigned or not? please show me some code. &gt; That said, the possibility of 'being assigned to' isn't really relevant, as a type doesn't need an operator= to be an lvalue, and const lvalues are a thing... 'can be assigned' does not mean 'they have an assignment operator' in this context. It means they have a label. 
&gt; These expressions get the categories of the objects they yield Objects doesn't have categories. They have storage duration, but any category of value can refer to any storage duration. You can have an lvalue designating a temporary object, and you can have an rvalue designating a static variable. 
&gt; So, you are saying that there is case where there is an unnamed pointer, that of an implicitely convertible captureless lamda, that is an lvalue? Yes, since the function has static storage duration (as is the case for all captureless lambdas, and as opposed to a temporary), dereferencing a pointer to that function is an lvalue. &gt; Can it be assigned or not? No; function types are not assignable. Again, this is completely orthogonal with its value-category.
Ok, *[]() is an lvalue then. It has a label though! it is not without a label, the label is provided by the compiler. So my definition stands. 
I respectfully disagree. All value expressions shown take their category from the value they yield. The label created is assigned to the object that is the result of the expression, and hence it is objects that finally are labelled or not and are rvalues or lvalues. 
I respectfully disagree, see my other reply. If you don't like me saying 'object', then replace object with 'value'. It may make more sense to you. 
Has Clang/C2 development stalled or something? The latest release is already 2 major versions behind :/
&gt; it is not without a label, the label is provided by the compiler. A label that you can't see is a label? What is a 'label' to you then? You can't just make shit up as you go along... &gt; So my definition stands. What definition?
Your "understanding" is just wrong. Maybe it's worked for you to some extent but how do you explain the fact that an lvalue can designate a temporary object, or an rvalue can designate a static object? The exact same object can be simultaneously designated by both.
&gt; I respectfully disagree With the standard? Okay, you do that â it won't accomplish anything, but it's certainly your prerogative... ;-]
Yes, with the standard. At least I can justify my opinion.
No, my understanding is correct. Temporary objects do not mean they can't have a label, and I don't see how static objects can be rvalues, or how the exact same object can be simultaneously designated as an lvalue and an rvalue...
&gt; A label that you can't see is a label? What is a 'label' to you then? You can't just make shit up as you go along... Of course you can finally see the label. You can printf the pointer, in this case. You cannot see it as an identifier in the code though. &gt; What definition? The one I gave above about lvalues and rvalues. 
`trackers[]`?
Pseudocode :) look here for implementation details https://github.com/tower120/trackable_ptr/blob/master/trackable_ptr2.h
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [tower120/trackable_ptr/.../**trackable_ptr2.h** (master â 1ff9e3f)](https://github.com/tower120/trackable_ptr/blob/1ff9e3f6baebb42152a5bc58b45ec6223e825bc5/trackable_ptr2.h) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmdhqoo.)^.
I'm confused now. Do you mean that a value is an lvalue if the compiler labels it as an lvalue? I don't think that's wrong, but it does not seem useful.
I've implemented the exact same thing some months ago and use it to be able to do memory compaction in my game engine to reduce the amount of fragmentation. It works like a charm, but I haven't benchmarked it to see how it affects performance. I'm not really sure how to handle concurrency without any heap allocation though, if someone has any ideas about how to resolve it, I'd love to hear it. It's here, but the Readme is a bit out of sync from the code (oops): https://github.com/FatihBAKIR/track_ptr
&gt;No drawbacks? Not really. Slightly more CPU intensive to decode than MP3 and LC-AAC (but faster than HE-AACv2 etc), but you get higher quality in return, and the overhead is so low on current devices that it has no impact on battery life. YouTube uses it for a lot of stuff by default now. Opus was basically the Vorbis and Speex people banding together, with funding from Mozilla to work on it full-time, and Skype (Microsoft) and Broadcom joined in with additional technology. It was such a big success that the same is now being tried for video with AV1 (and it's succeeding well so far, with huge buy-in from many vendors and performance &gt;= HEVC/H265). The main drawback is that if you had a big patent portfolio in the audio coding field, it's now pretty much worthless. France Telecom, FhG and Nokia thought that was a drawback ;-)
Looks great, it's something that my game could also use. I'm afraid though that it's incompatible with serialization libraries such as boost and cereal, because of the pointer to a stack-allocated object. Do you have a way to serialize your "track pointers"?
Thanks! Well, you're right that it's incompatible with the existing serialization libraries out of the box. In my game engine these pointers only point to components right now, so I've written a custom serialization function, which stores the entity id of the component and the type of the component, rather than the component itself: https://github.com/malt3d/malt_core/blob/master/include/malt/serialization.hpp#L45 I'm not sure serialization could be generalized completely, as these pointers do not manage the life time of the pointed to object. In my engine, the pointed to objects are serialized separately.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [malt3d/malt_core/.../**serialization.hpp#L45** (master â 6938e37)](https://github.com/malt3d/malt_core/blob/6938e37728a0f734ca502f1ba53a546bd81b4f79/include/malt/serialization.hpp#L45) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmdldpl.)^.
Interesting. However, I don't like the interface, in particular the need for the `Trackable` class to derive from the pointee type. I'd prefer the class to be a factory for trackable pointers, for instance like this: MyClass x; Tracker&lt;MyClass&gt; tracker{x}; // becomes Tracker tracker{x}; with C++17 deduction guides auto ptr = tracker.get_ptr(); // gets a trackable pointer 
&gt; But all these are labeled. you'd have to explain what you mean by "labeled", at first I thought you were talking about "named" (as in, attempting to reverse the (wrong) Meyerism "if it has a name it's an lvalue"), but none of those are named. 
"Cannot be assigned to" is not related to value categories. Consider: struct S {}; const int ci = 0; `ci` is an lvalue, but it cannot be assigned to. `S{}` is an rvalue, but it can be assigned to.
This is an advertisement for a closed beta of a product that has no release date and no price. That being said, I think it is an idea who's time has come. I wish I could try out the 'pro-jucer' from Juce but after around a year of waiting for the windows version of their live C++ solution it was only released for Windows 8.1 and up. 
1) Why it should hurt performance? Or you mean move/destruction? 2) When you do something like this: `struct Widget : public tracked`, did you consider the fact that `tracked` destructors and move constructors will be called AFTER Widget one's? I mean, maybe this is not the big deal in single-threaded environment, but... 3) Why you do std::memcpy / std::memcpy in https://github.com/FatihBAKIR/track_ptr/blob/master/track_ptr.hpp ? 4) If you do not need to prolong object lifetime, I think I know how to handle concurrency :) 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [FatihBAKIR/track_ptr/.../**track_ptr.hpp** (master â ed68cd6)](https://github.com/FatihBAKIR/track_ptr/blob/ed68cd68d8c0b98b7adc5863623c51f96744f92a/track_ptr.hpp) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmdm18u.)^.
I didn't get it. You want interface like shared_ptr / unique_ptr? template&lt;class T&gt; struct Trackable{ T value; T* get(){ return &amp;value; } TrackablePtr&lt;T&gt; make_ptr(){ return TrackablePtr&lt;T&gt;{this}; } }; Trackable&lt;MyClass&gt; myClass; myClass-&gt;x = 1; TrackablePtr&lt;MyClass&gt; ptr_myClass = myClass.make_ptr(); 
No. I simply don't want `Tracker&lt;T&gt;` to derive from `T`. The main reason is that you can't derive from base types like `int` as in your example. `Tracker&lt;T&gt;` would not behave like a `shared_ptr` since it would be neither moveable not copiable, in order to ensure it doesn't outlive the tracked variable.
Hmm... indeed you can't inherit fundamental types... But I think we can have template specialization for fundamental types. Can you show, how exactly you want it to be implemented? I don't understand this part of yours: MyClass x; Tracker&lt;MyClass&gt; tracker{x}; // becomes Tracker tracker{x}; with C++17 deduction guides How `Tracker` should looks like?
Mostly like the `TrackableBase` you implemented, with the main difference that it doesn't produce pointers referring to `this` but referring to the lvalue that is passed in the constructor.
ci can be assigned to: const_cast&lt;int &amp;&gt;(ci) = 5; The above compiles just fine. It can be assigned does not mean the assignment succeeds, but it is accepted by the compiler as an operation. S{} is not an rvalue, it has a label which exists for the brief period the object is alive. 
All the expressions above return a value in memory. Label = memory address. 
Of course. It is useful if you know in which cases the compiler inserts labels. 
Now (I think) I get it :) We need to have myClass_track entity to be alive till myClass alive? Something like this: struct Data{ int x; Tracker&lt;int&gt; x_track{x}; }; Data data; data.i = 100; auto i_ptr = data.x_track.make_ptr(); // Tracker is immobile, what's the point of all this now? //Data2 data = std::move(data); ??
That's not assigning to `ci` now is it. You're assigning to something else. Also `S{}` is absolutely an rvalue.
I lost you. It seems that `MyClass` in my example has confused you. Allow me to rewrite my example without it: int x; x = 100; Tracker&lt;int&gt; tracker{x}; auto ptr = tracker.get_ptr(); There's no need to have a `Data` structure to hold the value and the tracker together. Since the tracker must be created after the value, it's guaranteed that its lifetime ends before the value's.
Ok. Now I want to move x. Let's say put it to std::vector, where it be moved further(during vector internal reallocation). How to get `ptr` to `x`, according to your example?
You can't. You said you wanted a pointer to an object on the stack. If you move the object elsewhere, it's no longer on the stack so it's a completely different problem.
submitted, [X-macro gon' give it to ya'](https://www.youtube.com/watch?v=fGx6K90TmCI), will audio be available? ;) 
Try posting your formatted code at /r/cpp_questions or StackOverflow. 
Look at what happens when the backspace is detected in the else statement. In your example, you print a space and a backspace character. Nothing is done to remove the character or resize the array for the last stored character (or detect if the vector is empty...).
Why do people always do this? [Changelog link](https://github.com/pybind/pybind11/blob/v2.2.0/docs/changelog.rst#v220-august-31-2017)
What about this? int x1 = 1; int x2 = std::move(x1); x2 is still on stack.
Linked to the repo rather than something that actually explains the release! At least it's a little better than linking to a web server with release files :)
A pointer points to an object, not to a value. `std::move` moves values not objects and I do *not* want the pointer to follow the value. If you do, you are making a big mistake, IMHO, since it's a recipe for disaster.
How object differs from value? Moreover ["std::move is used to indicate that an **object** t may be "moved from""](http://en.cppreference.com/w/cpp/utility/move)
I was thinking that people unfamiliar with the library might be a bit annoyed to see just the changelog without an explanation of what pybind11 even is, so the readme file seemed like a better starting point (existing users can easily navigate to the changelog). But I do see how the reverse might be expected given the title. Anyway, here's a link to the [formatted changelog for v2.2](http://pybind11.readthedocs.io/en/master/changelog.html#v2-2-0-august-31-2017) with working reference links.
I'm disappointed to see it currently only supports Visual Studio.
About concurency. Making Trackable/Tracker thread-safe, is relatively obvious. Interesting thing, is how to "lock" pointer from being destroyed/moved while you work with it. What about following: template&lt;class T&gt; struct Trackable : public T{ // or use smaller RWSpinLock https://github.com/tower120/threading/blob/master/src/threading/RWSpinLock.h std::shared_mutex m_lock; Trackable(Trackable&amp;&amp; other){ std::uinque_lock l(m_lock); // do move stuff } ~Trackable(){ std::uinque_lock l(m_lock); // do dstr stuff } void lock(){ m_lock.lock_shared(); } void unlock(){ m_lock.unlock_shared(); } } Trackable&lt;Data&gt; data; TrackablePtr&lt;Data&gt; data_ptr = data; // somewhere from another thread... { std::unique_lock l(data_ptr); // data will not be moved/destructed while under lock } ??? Performance overhead should be as high as using `weak_ptr.lock()`. But you still can store it continuously with vector... Probably the better idea is to use lock on whole container, instead...
&gt; #include &lt;conio.h&gt; Tell your teacher that /u/MotherOfTheShizznit told him to open a C++ book written after 1988.
Really, this is basic C++ knowledge... Basically, object holds values. The CppReference link is incomplete and misleading. The correct sentence would be "std::move is used to indicate that an object may **have its value** moved from." Let's make an example: if you have two variables, say x and y, you have two objects, each object is holding a value. If you write `y = std::move(x)` you are moving the value that was stored in x and putting it into y. The previous value of y is overwritten and x is left with an unspecified value. After the move you still have two objects. The difference is subtle, but it's very important. Do not confuse the container with the content. PS: you can have values not held by objects (the so-called prvalues)...
This discussion leads to nowhere. I got your point about interface and fundamental types inheriting. Thank you for that. 
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6x7lu8/why_does_the_following_program_store_every/dmdx7w6/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I'm on the other hand, really happy this exists. 
Fascinating! How does this compare with Cython (with which I'm more familiar)?
With Edit and Continue (a new feature in Visual C++ 6.0), you can make changes to your source code while the program is being debugged (with some limitations). You can apply code changes while the program is running or halted under the debugger.
&gt; My objection to the way the current standard is written is that it is arbitrary and makes no sense from a C++ language point of view. I don't think that's a good criticism. The current spec was written to broadly allow unassigned characters, so that it wouldn't have to be updated every year to follow Unicode updates. Updating the language spec frequently, or depending on external data that can be updated like a Unicode database is not practical. If they allow code points to be used before those code points are assigned then naturally there's going to be some inconsistency and arbitrariness, because what characters get approved after vs. before they define the ranges is inconsistent and arbitrary. A more reasonable criticism is to ask why they didn't allow even more characters. For example why not just allow everything outside the basic Latin block, and leave it up to the programmer to exercise restraint with regard to characters that shouldn't be used, like some punctuation. &gt; IMO punctuation symbols of any sort should not be allowed in an identifier. But we should allow wide latitude in the use of all alphabets and pictographs (including emoji) in identifiers. Should unassigned character be permitted or not? How frequently should the spec be updated? What about backward and forward compatibility of extended identifiers among versions of C++? What about punctuation that should be allowed, like the underscore character?
okay, fair enough. "has an address" is indeed a common property of almost all glvalues (lvalues and xvalues), in C++ only the bit field glvalues do not share it (or rather, cannot express it in terms of memory model). This is better described as "has identity", see http://www.stroustrup.com/terminology.pdf
I don't know, but something is telling me that if you need this, your software is a gigantic design mess.
Not if there is an static code analyzer that raises the red alert when some dipshit is using unicode outside strings. 
Cython: you write in a not-really-Python-but-sorta-Python language, and then it generates bindings. pybind11: a wrapper over the Python/C API for C++, and you can also write bindings through it. pybind11 is more like Boost.Python than Cython.
Do show me "the mess" :)
I have the same feeling. It look like a dirty workaround for a problem that shouldn't exist.
&gt; The above compiles just fine. It also yields UB, so that doesn't really prove anything.
significantly easier to work with than Boost.Python though: even if you only count installing it and getting it integrated into your codebase. The not having to install a thousand and change headers is also welcome, too.
Ok. First of all, what problem? And second, how it should be solved correctly, without "dirty workaround"?
Any hope for eventual sub-interpreter support? That'd be nice to have for what I'd like to do with python: the message I'm still getting for embedding, though, is that Lua might be a better choice for those use cases than Python. PyBind11 has worked wonderfully at work, though, to export the functionality of my slicing engine (STL-&gt;GCode app) to python. makes it easier for non-programmers to write up their own slicing "pipelines" of a sort.
&gt; Really, this is basic C++ knowledge For some definition of basic
&gt; I do not want the pointer to follow the value. If you do, you are making a big mistake, IMHO, since it's a recipe for disaster. How is this a recipe for disaster? Not sure if I'm missing some context, but this is the intended behaviour of OP's trackable_ptr. He's trying to solve the issue of pointers being invalidated when a container moves values upon reallocation etc. The idea is that you use trackable_ptr when you want the pointer to follow the value.
So, anyone wanting to write C++ in Cyrillic, Chinese or Korean is a dipshit? Physicists wanting Greek symbols in identifiers are dipshits? Go on... The standard says that most Unicode characters are legal in C++ identifiers. One assumes they had a good reason to do that. The standard does not say that "Unicode is only for strings." That was an option which apparently was rejected.
First of all, we're not saying the library is bad. What we are saying is that if you have a piece of software that needs this library, **that** piece of software have a big problem. You shoudn't have to track **stack** allocated memory. If you need it to survive the end of current function it should be heap allocated. If you don't, you shouldn't need to track it. Stack allocated memory is temporary by definition, and it being moved out is an **optimization** that shouldn't be relied on.
The Unicode consortium adds meta-data to the characters. They also categorize all characters which are added -- by range. Either are a reasonable mechanism to constrain usage. For example, things that are considered "syntax" are marked as such. There's a security guideline: http://www.unicode.org/reports/tr39/tr39-15.html But, after studying this only briefly, it seems that the complexity required by a compiler to implement these security constraints are really high. However, the risks are such that compilers should be required to detect and warn when confusable symbols are used in a program.
Well. True - **stack** allocated memory should not be tracked. Do look at [this](http://coliru.stacked-crooked.com/a/c6a2e71ea86f8902). It is rather allocation agnostic, actually.... In that example, technically we track heap/stack allocated MOVABLE object. I must be not named it correctly. I just wanted to emphasize that it is not required to put object in heap, like with `std::vector&lt;TrackablePtr&lt;Data&gt;&gt;`. If you know have idea how to call this thing correctly... Maybe "stable pointer for movable object, without extra heap allocation"?
&gt; The Unicode consortium adds meta-data to the characters. Yes, I mentioned that. You haven't addressed the problems that using it would cause and I'm still convinced it would be a bad idea. 
They could just contribute [this] (http://vrogier.github.io/ocilib/) instead of re-inventing the wheel. 
The relevant sections in the C++ standard are labeled [intro.object] and [basic.lval]... it has to mean something.
&gt; it has to mean something Tbh, not really.
I think the biggest advantage for pybind11 is that it's not just interfacing with C++, it is C++. That makes it well-suited for projects which have tooling built around C++ and libraries which take advantage of everything the language has to offer, up the latest C++ standards. One downside of Cython is that it requires special source-to-source translation (`.pyx -&gt; .c -&gt; .so`) which adds an extra step to the build. Aside from build system complications, this makes debugging a pain because the `.so` file has debug data for the `.c` source, but that's really machine-generated C code so it might as well be assembly. A pybind11 module is created very much like any other C++ shared library and it debugs like one. pybind11 can also take advantage of the compile-time features of C++, e.g. some error checking can be done statically. Templates are used to generate automatic type converters and these can also be user-defined templates which reduces the amount of repetitive stub code compared to Cython.
Your problem is to do with lifetimes, not move vs copy. You are taking the parameter to the coroutine by reference. The object you're passing is a temporary that is destroyed once the coroutine returns for the first time, so when the coroutine is resumed it has a dangling reference. The TS is not very clear that the references are copied, not the referred-to objects, but that's what it is supposed to say (and what the implementations do). See my blog post about this for more details: https://toby-allsopp.github.io/2017/04/22/coroutines-reference-params.html Edit: I'm not sure why it doesn't compile on MSVC - can you link to gcc.godbolt.org with a complete example that demonstrates the compile problem?
The short example I linked with a move-only type is enough to make it fail to compile on MSVC. Just `#include &lt;experimental/generator&gt;` and add the appropriate using statement. MSVC fails to compile any move-only type as a parameter. I suppose my surprise with the chained generators is that the allocated coroutine stack does not move the object and thus owns it.
Sub-interpreters can be used already, but they require a dive down to Python's C API. As for adding an interface for them in pybind11, the main question for such a C++ API is how much it should help and how much it should stay out of the way. The interaction between sub-interpreters, the GIL, threads and extension modules is a bit intricate and it has bunch of caveats even within CPython itself. What's needed is more information about common use cases, or someone with a lot of experience in this specific area. Regarding Lua vs Python: Lua was designed for embedding so it definitely has an advantage there. However, this focus is also its downside -- if it's mainly being embedded into things, it can't really develop the kind of library ecosystem that a standalone language can. The large number of high-quality packages on PyPI are a huge advantage for Python, which IMO far outweigh any initial embedding difficulties. Of course, your mileage will vary depending on how complex the embedded scripts need to be and how many third-party libraries are needed. 
I can understand the difficulties of building a neat abstraction on top of a complex system, without handicapping: most of my work on my Vulkan renderer has been an exercise on this front. I'll probably just have to look more into the lower-level raw interface, then. Thanks, though! In my use case for Python, I probably won't require tons of third-party scripts: mostly just looking at some kind of modding API (eventually), and programming various vehicles in a personal project of mine (like programming a guidance computer, or a drone). I'm just really comfortable with (and a big fan of) Python, and not a huge fan of what I've seen of Lua so far. edit: If you've played space engineers, what I have in mind is similar to what that game does for programmable blocks and mod scripting.
Is that really better than using a structure that does not invalidate iterators with a custom allocator, or something like plf::colony?
I can't see any reason for your move-only type as a parameter to cause a compilation error - I think you've hit a bug in MSVC there.
Unfortunately, Edit and Continue has severe limitations, even in its newest version in VS 2017. It cannot deal with many of the things Live++ supports. I will add a comparison to the FAQ to make that more clear.
I have plans for supporting other compilers, but first have to gauge user interest in order to prioritize my efforts. Which compiler/platform would you like to see supported?
I didn't use `plf::colony` (maybe I should've), but ... consider you want to move object from one container to another. You at least will have to update iterator/pointer to an object in new container. Not a big deal, if you somehow keep track on all used pointers to container elements... With something like `trackable_ptr` you can just use same "pointer", and you don't even have to know that element was moved/stored in contianer/structure/stack allocated/heap allocated/etc... I can not say that it is better, but I think it is more general / automated. Maybe something like C#'s pointers/objects (objects itself may be moved in memory [compacted by GC], but "pointer" to an object will remains valid).
Why not just a 'vector&lt;shared_ptr&lt;T&gt;&gt;`? Iterators are still invalidated but the underlying objects aren't...
This is awesome! I'm still stuck with using boost::python at my day job (we're still using python 2.6 so can't use pybind), but I really hope we can transition to pybind in the future. 
&gt; Allow to have pointer to stack/heap - allocated object, which does not become invalidated, when object moves. Pointer becomes nullptr if object dies. This is basically weak_ptr, with the caveat that it is totally unsafe in any kind of concurrent setting because the object could be destroyed while you're using it. I don't really love shared_ptr (other than for immutable objects), and I like weak_ptr even less. It just makes ownership progressively less clear. Refactoring towards unique ownership is the right solution in the vast majority of cases, even without performance considerations. All in all I can't say this is very attractive. Maybe reconsider why this pointer is even needed in the first place; a class holding a non-owning pointer to another class is usually code smell to start with (considering just passing in that pointer into methods instead of making it a member variable).
There's also [Recode](https://www.indefiant.com) which id software uses. But I've been on their closed beta list for 2+ years now, pinged them, and no response... Got tired of waiting and implemented my own hot swappable DLL a few days ago. Works pretty well, I get &lt;1s iteration times, but there are quite a few limitations...
I think the idea is to maintain the locality of the data.
Oracle is a cancer on the software industry, all this did was remind me of their shady practices and killing SPARC.
lol who told you this is a homework ? man i'm learning c++ for fun.
yeah right that is what i was thinking but, it doesn't care if backspace is entered or not it stores whatever is written from the keyboard into the vector. but why ????? that is my question and this is not homework.
I wrote the code on my own and this is not the ******* homework.
I, and I suspect many like me, have a bit of a trust problem when it comes to Oracle and their business practices, and under no circumstances am I going to include any of their software in anything I do. Just to be safe.
&gt; That is, if there is a member-function in the object with the same name, and taking the same arguments, then it will use that, otherwise, it will perform ADL look-up for a free function with the same name, and use that instead. Function "names" in Dyno are represented as compile-time strings. Unfortunately, because we lack proper reflection for now, it is not possible to programmatically go from a name (represented as a compile-time string) and do what you propose. With reflection, it may be possible to do part of it (although I suspect ADL lookup for a free function may have some pitfalls and may never be implementable the way you suggest, but I'm not sure).
Count me in the never Oracle group. Whenever i can, i try to steer people and companies away from anything to do with Oracle.
Thanks, this is an extremely clear and compelling answer. And you have hit a major issue with Cython on the head. When I was debugging Cython, I used exclusively print statements (which, honestly, has become my go-to debugging tool). The next time I have to write a Python external, I'll send an evening with pybind and see what I come up with.
Ouch! 2.6 is an unsweet spot. To be honest, people should be using Python 3 by now - I moved over a year ago and I felt late - but I can understand not wanting to switch a major version. But Python 2.7 is heavily maintained and has a lot of features from 3.x in it - 2.6 languishes. And as far as I know, there is almost perfect compatibility between 2.6 and 2.7. I'm curious as to why your organization is 2.6? (I'm sure it's not your fault! :-D)
Sorry to be that guy, but why did you implement it without measuring the effect? If I was going to introduce something like this into my own project, I would get some concrete numbers before and after. How can you know it worked like a charm if you didn't measure it!!
Windows 8.1 is over three years old at this stage. Win7 is 8 years old. I don't think it's unreasonable for people writing libraries for bleeding edge features to target an OS released this decade. 
We've done something similar in Wt 4, only without the tracking moves part. We have `observable` objects, which keep track of all of the `observing_ptr`s that point to it, and invalidates those pointers when the `observable` is deleted. By invalidate I mean it sets them to null, but we also distinguish between an `observable_ptr` that pointed to an object that has now been deleted, or an `observable_ptr` that was simply default-constructed or set to null explicitly. It's intended to track objects that are uniquely owned by a `unique_ptr`, but want to refer to somewhere else in the application where you can't guarantee that those non-owning (raw) pointers won't at some point become dangling, e.g. in our signal/slot system. We could use `shared_ptr` and `weak_ptr`, but we don't actually need the thread safety, and `unique_ptr` sets up a more obvious ownership relation. We also made the use of `observing_ptr` optional, so our API uses raw pointers or references as arguments, and returns raw pointers, and it's up to the user whether they want to store it in an `observing_ptr`.
It proves, because the following code: int i = 0; 10 = i; does not compile, because 10 is an rvalue. 
Ok, let it be 'has identity'. 
Yes it does assign to ci. Because the const cast is to the reference of the variable ci. Why S{} is an rvalue? please elaborate. 
There is a very big use case for this pattern. Consider a number of non-polymorphic objects that are owned centrally, but are referenced to throughout your code. Normally you would have to do: vector&lt;unique_ptr&lt;MyClass&gt;&gt; myObjects; // somewhere in the code MyClass* ref; If you care about pointer invalidation, you could substitute unique_ptr with shared_ptr, and the raw pointer with weak_ptr. So this pattern lets you do the same thing, while allocating your objects in a continuous memory block, and being more cache friendly. It also has potentially less overhead than the shared_ptr, while also invalidating pointers.
Since I'm storing the components in a vector, I wasn't able to store a pointer of any kind before, and that's why I've implemented the thing, so there's nothing to compare it with :) I said it works like a charm because it passes all the tests and doesn't crash the engine at the moment.
1. I meant updating the pointers when the object moves. 2. I didn't consider that, but as you said it's irrelevant in a single threaded program and I doubt the order fixes the issue in a multi threaded one (another thread might always read garbage if the whole move isn't atomic) 3. I was lazy and just copied the whole object and set the previous one to 0s as a move. Probably I should remove that.
mr-agdgdgwngo got it right:) The locality is the key.
Welcome to the club :). Initially, I also, need it to track aliveness of my ObservableProperty's https://github.com/tower120/reactive (there it ended with shared_ptr/weak_ptr though), but then I saw that I can track object move without additional overhead, so why not do that? Why you "distinguish between an observable_ptr that pointed to an object that has now been deleted, or an observable_ptr that was simply default-constructed or set to null explicitly." ? I actually don't really get your explanation. Could you point at `observing_ptr`/ `observable` of yours, please?
&gt; This is basically weak_ptr, with the caveat that it is totally unsafe in any kind of concurrent setting because the object could be destroyed while you're using it. Well... true - though maybe it can be improved with this https://www.reddit.com/r/cpp/comments/6x6fui/trackable_ptr_stable_pointer_for_stack_allocated/dmdurtc/?st=j71qwgti&amp;sh=9cac5446 ? &gt; " a class holding a non-owning pointer to another class is usually code smell to start with (considering just passing in that pointer into methods instead of making it a member variable)." Sounds complicated in words, can you show it as code? :)
I think the distinction between a default constructed `observing_ptr` and an `observedDeleted()` `observing_ptr` (one that pointed to an `observable` at some point, but that `observable` has now been deleted) is used in the signal/slot implementation: a slot is no longer connected if the `observing_ptr` is `observedDeleted()`, but if we weren't tracking an `observable` in the first place, then it's still connected. I'd have to ask Koen, who implemented this, to really know why he did it that way, because I personally don't quite know. Our implementation of `observable`/`observing_ptr` in Wt is here: https://github.com/emweb/wt/tree/wt4/src/Wt/Core
why, linux/gcc of course. linux/clang if it's easier.
A little bit offtopic: when you did your signal/slot system, did you consider event system instead? Something like https://github.com/tower120/reactive#event
[removed]
Relevant comments and thoughts on the library belong into [the review thread](https://www.reddit.com/r/cpp_review/comments/6xdkdc/review_of_args/) at r/cpp_review.
I say: âconst autoâ is not so verbose as to justify hiding it behind a macro.
&gt; Yes it does assign to ci. No, it **obviously** doesn't. It assigns to `const_cast&lt;int&amp;&gt;(ci)`, that is an entirely different expression. Value categories apply to expressions, not objects. The expression `ci` is an lvalue. The expression `const_cast&lt;int&amp;&gt;(ci)` is also an lvalue, just a different one. Similarly: int i; int&amp;&amp; r = i; // error int&amp;&amp; r2 = std::move(i); // ok It would be ridiculous to claim that `i` is an rvalue because here, look, I'm assigning an rvalue reference to `std::move(i)` which is just `i` right? Since you insist on not understanding this, I could also use: struct X { void operator=(X const&amp; ) = delete; }; X x; `x` is an lvalue there, `x` is not assignable. The fact that you could tell me that you could just `reinterpret_cast` it to something else that you could assign to doesn't matter. `x` isn't assignable. `x` is an lvalue. You have to stop thinking of these concepts as related, because they're not. &gt; Why `S{}` is an rvalue? please elaborate. Because it's an expression whose evaluation initializes an object. You could also think about it is an expression that doesn't have an identity. Either way, it's a prvalue, which makes it an rvalue. You could always use `decltype((expr))` to determine the value category. If `expr` is an lvalue, you'll get an lvalue reference. If it's an xvalue, you'll get an rvalue reference. It is' a prvalue, you'll get a non-reference.
Try t work it out on paper... let's say I enter the letters "pop" followed by a backspace, followed by an enter. By the time I hit the backspace, the letters pop are already stored in the array. Therefore when I hit the backspace, I must do something to shorten the array myself...
It gets tiring to write it often. 
Tell me about it... . I wish I knew why we hadn't moved to at least 2.7. It's probably just that there hasn't been a driving reason to do so, so it hasn't happened. I know we have been skittish of python 3 for performance reasons (memory use more than speed). 
&gt; It assigns to const_cast&lt;int&amp;&gt;(ci) Nothing can be assigned to an expression. Expressions are not cells in memory to be updated. &gt; that is an entirely different expression It's not, const_cast has a reference to const in its parameter, and returns a reference to the same value which is non-const. Otherwise const_cast wouldn't work. &gt; Value categories apply to expressions, not objects. That's total bullshit. Value categories should only be applied to objects, not expressions. &gt; It would be ridiculous to claim that i is an rvalue because here, look, I'm assigning an rvalue reference to std::move(i) which is just i right? No one said that anything on the right side of an assignment is exclusively an rvalue. &gt; x is an lvalue there, x is not assignable. The fact that you could tell me that you could just reinterpret_cast it to something else that you could assign to doesn't matter. x isn't assignable. x is an lvalue. You have to stop thinking of these concepts as related, because they're not. Totally invalid explanation. Hiding the assignment operator HAS NOTHING TO DO WITH IF THE VALUE HAS A LABEL (I.E. AN ADDRESS IN MEMORY) OR NOT. &gt; You could also think about it is an expression that doesn't have an identity But it has an identity. In order for the object to be initialized, IT SHALL HAVE AN ADDRESS IN MEMORY. EVEN IF IT IS TEMPORARY. OTHERWISE 'THIS' WOULDN'T EXIST. Therefore, it is an lvalue. 
I would say that the terms event and signal, and event handler and slot could be used interchangeably. I think you're maybe referring to asynchronous versus synchronous handling of events? In that case, our signal/slot system is indeed synchronous. Signals and slots are handled within the scope of a single `WApplication` (which corresponds to one user's session), and there's only one thread serving a single `WApplication` at a time. I think the simple answer would be that Wt was inspired by Qt, and actually designed to be familiar to people who know Qt, so Wt has a signal/slot system. Unlike Qt, though, Wt uses pure C++ and does not rely on preprocessors like Qt's Meta-Object Compiler (moc). Switching to an asynchronous system now would be quite a major change, since Wt has used a synchronous signal/slot system since its inception in 2006. Outside of that, doing everything in a `WApplication` in a single thread with synchronous signals/slots for the most part keeps our code quite simple. If a user of Wt wants to do something asynchronously, then they are free to use whatever means or framework they deem fit, as long as only one thread touches a WApplication's widget tree at any time. I don't think that hurts performance much, since the tasks that you really need to perform asynchronously are generally in the backend. I personally don't know what considerations Koen made exactly, and I can't currently ask him about it since he's out of town. I only joined the team 3.5 years ago.
Is there a reason that you use the std::unique_ptr constructor directly rather than std::make_unique? My understanding is that this function is more than just useful, but actually is safer to use because if the new operator fails it can result in leaked memory, and make_unique prevents this. I don't remember the details of exactly how this issue occurs, but I think Scott Meyers addressed this in Effective Modern C++.
&gt; That's total bullshit. Value categories should only be applied to objects, not expressions. Dude. Stop. Just read the standard: http://eel.is/c++draft/basic.lval, everything you said here is incorrect. 
&gt; Therefore, it is an lvalue. The argument you're making doesn't follow, and writing it caps doesn't make it any more valid. It doesn't have an identity. Moreover, I gave you a way to check value categories as defined by the standard: use [`decltype((expr))`](http://eel.is/c++draft/dcl.type.simple#4) (expr, because value categories apply to expressions): S s; decltype((s)) // S&amp;, because lvalue decltype((std::move(s)) // S&amp;&amp;, because xvalue decltype((S{})) // S, because prvalue 
Sorry, I make my stand: what the standard says is incorrect. I don't care how the people that wrote the standard reached those absurd conclusions, I totally disagree with them. From the link you posted: &gt; Historically, lvalues and rvalues were so-called because they could appear on the left- and right-hand side of an assignment (although this is no longer generally true No shit, Sherlock! rvalues are values without a memory address, lvalues are values with memory address. It's as simple as that. Expressions can't be lvalues or rvalues, it's an illogical concept, because things are only separated into values with a memory address and values without a memory address!!!!!! expressions don't have memory addresses. And the distinction between rvalues/lvalues is because some values are only stored in registers and they don't have memory addresses. That's about it really. 
&gt; The argument you're making doesn't follow, Yes it does. S{} has to have a memory address, for 'this' to work, and therefore it cannot be an rvalue. &gt; writing it caps doesn't make it any more valid I'll write ANYTHING I WANT IN CAPS, IF YOU DON'T LIKE IT DON'T READ IT. It's my right to do so. &gt; It doesn't have an identity. Yes it does. The 'this' pointer. &gt; Moreover, I gave you a way to check value categories as defined by the standard Please repeat after me: Expressions can't be anything. Expressions only compute things. The things they compute either have or don't have memory addresses. The distinction between xvalue/prvalue/rvalue/etc on expressions is totally without merit and not useful in any way whatsoever. 
why not `let` ? let x = blah();
Is there a reason why you use boost functionality where equivalent Std functionality is available?
Not really, I simply kept using boost since I already had lots of code using boost::funcion/bind/signal But I'm all for changing it to std only. I'll give it a go later. Thanks.
Interesting. It seems to work fine in gcc, but not in clang. That's a pretty cool site, by the way.
It does happen with Clang[1]. [1] https://godbolt.org/g/8JeE7X
ERRATA: Well, Do is indeed initialized, I should have been more careful! Well, Do is not initialized, so it may have any random value. Just happens to be the address of EraseAll in this case, that's "bad luck" ;)
That's what I meant. gcc doesn't have the problem. Clang does.
This happens because the compiler assumes you didn't trigger undefined behavior by calling `NeverCalled` outside of that translation unit. Because `Do` is static, you can't access it outside this TU (removing `static` makes the compiler assume only that `Do` is valid, jumping into what it points to), so the only function that is modifying this pointer is `NeverCalled`, which can be called from outside.
Oh, I see. Well, it's not really a problem, it is expected compilers will optimize code that triggers undefined behavior.
Important tip! Clang/LLVM requires the v140 toolset. If you don't have VS2015 installed, you can add it in the VS installer. (note it's 4.36 GB) You can than integrate it in VS using the script: (run as Admin) ...\LLVM\tools\msbuild\install.bat (running the installer again might work too) Than "LLVM-vs2014" will show up as an option for the "Platform Toolset", in the project properties.
`Do` is initialized because its in static memory. But it's initialized to `nullptr`. clang makes the assumption that a program will not run into undefined behavior. From there it reasons that since `Do` contains a value that will cause undefined behavior, SOMEHOW `NeverCalled` must have been invoked so that invoking `Do` will not lead to undefined behavior. And since we know that invoking `Do` will always call the same function, we can inline it. EDIT: Pay special attention to what is marked as `static` and what isn't. If you don't mark `Do` as `static`, clang will generate the code you expected. If you declare `NeverCalled` `static`, clang will generate a `ud2` instruction.
Makes sense. So the only way for this code not to crash is to have `NeverCalled` called outside of this translation unit, so the optimizer is assuming this is the case. Changing `NeverCalled` to be static is certainly stopping this optimization from happening and main is calling an undefined opcode (to make sure it crashes there).
Accidentally calling system("rm -rf /") would qualify as being a problem in my book, but I see your point ;)
Why not ? I though of Scala's var before let, that's all =)
The problem is that the program invokes undefined behaviour. If you do that, all bets are off. Calling `rm -rf /` is as valid as anything else because the behaviour is undefined. I love this example. :)
Yes, I realized that when I read thlst's comment actually.
one rich asshole called larry e
Please Noooooooooooooo. - That name is bound to collide with some 3rd party variable name - Please use UPPERCASE names - While the name hints at its inteded use, it hides too much information for someone not familiar with the code. Admittedly that might not be a problem once someone has seen a few lines using it. Not that I wouldn't love to have a short form for const auto (c++ code in general is much too verbose), but afaik that would need to be a context dependent keyword in the language - known to everyone and without the danger of name collisions. If typing const auto is too tedious I'd recommend defining a shortcut in the editor. 
It could also feed your dog or clean your dishes if you are lucky. Or burn your house down if you are not. After all, open source software comes without any implied or explicit warranty :\^)
So it is actually true that things could blow up in case of undefined behavior. :|
But you could choose to use a compiler that will try to rescue you instead of one that actively seeks to hurt you. There is this misconception on computer science that any deviation from a standard must be punished; if you did this in other fields your project would not last long because the overall goal is to be useful and make stuff less problem-prone. No one would buy power outlets that explode as soon as the standard is not entirely respected to the letter.
If youâre actually concerned with keystrokes then get an editor with autocomplete or a good text-expanding system extension. Donât waste your time making your code hard to read and maintain. Typing is the easiest part of programming. There are other things you should spend your time on.
Well, yes. It's not that hard to understand... Since calling through an uninitialized function pointer is undefined behaviour, it can do anything, including calling `EraseAll()`. Since `Do` is `static`, it cannot be modified outside of this compilation unit and therefore the compiler can deduce that the only time it is written to is `Do = EraseAll;` on line 12. Therefore, calling through the `Do` function pointer only has _one_ defined result; calling `EraseAll()`. Since `EraseAll()` is static, the compiler can also deduce that the only time it is called is via the dereference of `Do` on line 16 and can therefore additionally inline it into `main()` and eliminate `Do` altogether.
&gt; But you could choose to use a compiler that will try to rescue you instead of one that actively seeks to hurt you. There is this misconception on computer science that any deviation from a standard must be punished; The code transformations here were not implemented in order to actively hurt programmers who write code with UB. They were intended to help code that has well defined behavior. The fact that code with undefined behavior suffers is merely an unintended, but unavoidable, side effect. There have been proposals for 'safe' compilers that do provide padded walls, child-proof caps and so on. It turns out to be pretty challenging.
Can you give an example where pybind11 is nicer? I looked at Boost.Python ages ago, but it was pretty nice...
&gt; The TS is not very clear that the references are copied, not the referred-to objects, but that's what it is supposed to say (and what the implementations do). The TS says (N4680 [dcl.fct.def.coroutine]/11): &gt; When a coroutine is invoked, a copy is created for each coroutine parameter. Each such copy is an object with automatic storage duration that is direct-initialized from an lvalue referring to the corresponding parameter if the parameter is an lvalue reference, and from an xvalue referring to it otherwise. A reference to a parameter in the function-body of the coroutine is replaced by a reference to its copy. ... Which I think very clearly indicates that fresh objects are created in the coroutine frame and initialized from the actual parameters. I *do* agree that this may not be how the implementations work - certainly not MSVC - but I don't think the current wording is ambiguous as it was in earlier proposal drafts.
What's the advantage of this compared to the old way? Seems equivalent, no? EDIT: sorry now I see it's per-target. But what if you want to set a flag across all targets, as is quite common?
&gt;Since calling through an uninitialized function pointer is undefined behaviour It's not uninitialized. It's initialized with `nullptr`.
Very nice, although I would like to see CMake support. Would you accept a pull request if I were to implement that?
Not to take away from this, but I really wish there were more talks/articles that were "How to design a project from 0-10 lines, 10-100 lines, 100-1000 lines, 1000-10000 lines" etc. While smart pointers/lvalues + rvalues/performance stuffs cool, my real issue is that there's very little information on how to structure large pieces of code, and even less about why you should structure it like that or the real world problems that crop up when trying to cram an application into an architectural design This is the kind of stuff that's the actual problem with programming for me - but often talks seem to focus on stuff that is nice but not the core issue I've got the hang of about 50k lines of code now due to repeated failure and experimentation and can design projects that aren't a colossal mess in that ballpark, but the second one of these projects eventually strays into the 100k plus mark I'm aware that my knowledge is significantly less useful, as every order of magnitude is a totally different ballgame
&gt; So the only way for this code not to crash This is actually the only way for the code not to _invoke undefined behavior_. One possible outcome of undefined behavior is that the system crashes - this would happen for a classical "convert every line of C into asm without advanced optimizations" compiler. The whole point of undefined behavior is so that the compiler can say "I assume that this isn't going to happen, so I'll just do whatever I would have done if it didn't happen". Here is clang's reasoning: 1. Either someone sets `Do` or it remains null. 2. The only thing that can set `Do` is `NeverCalled`, which will set it to `EraseAll`. 3. If `Do` remains null then `main` will perform undefined behavior. Since I can do anything I want in this case, for simplicity's sake I'll do the same thing that happens when there's no undefined behavior, viz. call `EraseAll`. 4. `main` always calls `EraseAll` no matter what, so let's inline it. Raymond Chen has an interesting take on this: [Undefined behavior can result in time travel](https://blogs.msdn.microsoft.com/oldnewthing/20140627-00/?p=633/).
I managed to use std::function and std::bind, but there's no equivalent to boost::barrier, so unfortunately it still uses boost::barrier.
Well, not explicitly initialised.... Calling a null function pointer is just as much UB as an uninitialised one anyway.
It is not uncommon in engineering to have to make trade-offs. In many other languages the language tries to protect ill formed programs at the expense of well formed programs. C++ is a language that rewards well formed programs at the expense of ill formed programs. If you desire protection and are willing to pay the performance cost for it, there is no shortage of languages out there to satisfy you. C++ is simply not one of those languages and complaining about is unproductive.
&gt; This happens because the compiler assumes you didn't trigger undefined behavior by calling `NeverCalled` outside of that translation unit. I read this like four times before I understood what you meant. This happens because the compiler assumes you called `NeverCalled` outside of that translation unit, since otherwise you would be triggering undefined behavior.
The compiler isn't actually saying "I see undefined behavior here, I'm going to run `rm -rf /` because I hate users". The example is contrived, that function could've been doing anything, the author just chose to have it run that command
Yes, it's ridiculously unpredictable. All logic is out the window.
&gt; If you desire protection and are willing to pay the performance cost for it, there is no shortage of languages True. But I reject the notion that safety and performance are necessarily mutually exclusive. It seems Rust made some great progress in that direction ... at the cost of ergonomics. So, I guess it's pick two out of safety, performance and ergonomics.
The program has only undefined behaviour because there is no other translation unit which invokes `NeverCalled` before `main`. It would be possible to do so using another static object's constructor from another translation unit. So, detecting this undefined behaviour isn't even possible for the compiler unless you count global program analysis (which kind of goes against the idea of separate compilation). But the compiler *is* allowed to assume that `NeverCalled` is called before `Do` is used because `NeverCalled` is the only place that initializes `Do` properly and `Do` has to be properly initialized to be callable. The compiler basically did [constant folding](https://en.wikipedia.org/wiki/Constant_folding) for `Do` in this case.
Hi, try `-fno-omit-frame-pointer` gcc argument so the compiler won't optimize frame pointer register as well resulting in stack unwinding problems for profilers and debuggers
older versions of GCC launched nethack when they encountered UB : https://feross.org/gcc-ownage/
The C++ community is divided into two groups: those who think this optimization is awesome, and those who think it is terrible and dangerous.
Did you submit any of these as PR's? 
No, that's the misconception that's expressed by C==C++
What is the unified comparison operator? My Google foo seems to have failed me. 
&gt; Well... true - though maybe it can be improved with this Sure, though as you said the overhead for the non-owner is now very high. In fact, it's probably much higher than weak_ptr; weak_ptr::lock, name not-withstanding, can return after a single CAS + trivial pointer arithmetic. So this reduces the incentives to use it in the first place. &gt; Sounds complicated in words, can you show it as code? :) I'm not saying anything revolutionary: class Foo { public: Foo(const Bar&amp; x) : m_x(&amp;x) {} void baz(double y) { m_x-&gt;qux(m_blub, y); } private: Bar const * m_x; int m_blub = 0; }; Is, all other things being equal, worse design than: class Foo { public: Foo() = default; void baz(double y, const Bar&amp; x) { x.qux(m_blub, y); } private: int m_blub = 0; }; There may be other considerations like performance or polymorphism (being forced to adhere to an existing interface), but in general this should be avoided. If you have a non-owning pointer, then clearly there is somewhere else an owner who also references the object. If you aren't the only one who can modify the object, then you can't enforce any invariant that involves that object. If you can't enforce invariants that include it, it probably doesn't need to be a member of your class.
That seems to be a rather insane approach to compile software :/ Is clang less crazy in that regard? Edit: oh that was clang, sorry; due to the website name I thought this was gcc.
&gt; The whole point of undefined behavior is so that the compiler can say "I assume that this isn't going to happen, so I'll just do whatever I would have done if it didn't happen". That's what some crazy compiler authors want to make you believe but they are full of shit. Historically, undefined behavior were there mostly because different CPU had different behaviors, and also because platforms did not crashed the same way (there is no notion of crash in the standard, so it falls back to UB) or even some did not "crashed" reliably but became crazy (which might be the best approximation of the postmodern interpretation of UB). The end result is that we can't program an efficient and simple ROL or ROR anymore even if all behavior variation of all major cpu made it possible, if mapping shifts to instruction sets. Also, instead of segfaults, we are potentially back in the MS-DOS days where a misbehaving program could render the computer crazy (because now crazyness is amplified by the compiler, limiting a little the interest of crazyness being prevented by the CPU protected mode). In a nutshell if you attempt to do an operation that has not been possible on any obscure CPU on any obscure platform, you risk the compiler declaring your program being insane and doing all kind of things to punish you. And that is even if you only ever target e.g. Linux x64. What a shame.
Which, BTW is a complete utter bullshit assumption for anything remotely related to safety. If you work in such a domain, please push for a switch to a language with saner compiler authors.
The problem is that the compiler does bullshit assumption to "optimize" your code, instead of doing safe things. If "optimization" consist of erasing the hard drive, there IS a fucking problem in the approach.
http://wg21.link/p0515
Yet they are dangerous, and thus should not be employed for engineering work. Safe compilers are not that challenging. Rust goes ever further and proposes a safe language, and other languages existed before (not trying to cover as much risks as Rust, but still far better than C or C++).
This should be directed to StackOverflow; it's off-topic here.
&gt; C++ is a language that rewards well formed programs at the expense of ill formed programs. Which is a completely retarded approach, because any big enough C++ program is going to have an UB somewhere, and the compiler potentially amplifying its effects way beyond reason is a recipe for disasters.
Rust tries to cover multithreading cases. For stuff as simple as what is presented here, safe languages exist since a very very very long time. Basically only C or C++ are major languages (in usage) that are that retarded, actually.
&gt; Historically, undefined behavior were there mostly because different CPU had different behaviors, and also because platforms did not crashed the same way [...] Historically, compilers were shit at optimizing your code. Assuming undefined behavior wont happen is not a new concept. It should be about as old as signed integer arithmetic. Having the tools to reason about code in complex ways is new.
And that's why the compiler authors doing that kind of shit are complete morons. Calling a nullptr is UB meanings that the standard does not impose a restriction, to cover stupid architectures. We are (mostly) using sane ones, so compilers are trying to kill us just because of a technicality that should NOT have been interpreted as "hm, lets fuck the memory safety features of modern plateforms, because we might be gain 1% in synthetic benchmark using unproven -- and most of the time false -- assumptions ! All glory to MS-DOS for having induced the wording of UB instead of crash in the specification" This is even more moronic because the spec obviously allows for the specification of UB, and what should be done for all compilers on sane modern plateform should be to stupidly try to dereference at address 0 (or a low address for e.g. nullptr-&gt;field) 
Yet those tools make insane assumptions and emit code without informing humans of the dangerosity of their reasoning. Dear compiler: if you "proove" that my code contains a particular function call in another module because of the wording of the spec, and because MS-DOS existed in the past; then first: please emit the source code of such module for me, as you have obviously proven its content; second: allow your next emitted UB to erase yourself from the surface of the earth because you are fucking dangerous. This is, after all, permitted by the standard. 
That's pretty cool. Thanks for the link.
I've argued in the past that the wording implies that new objects are initialized from the references (as references are not objects). However, if that is the case then the attached note about the lifetime of objects referred to by parameters is nonsensical, which is enough to make the intent pretty ambiguous, even if the wording is not.
**Company:** Microsoft **Type:** Full time **Description:** Are you passionate about building brand new components and services to solve challenging distributed systems problems? The High Availability Storage team is the one for you! We are looking for a talented, self-motivated software engineer with high growth potential and a passion for learning. As a member of our team, your work will have broad impact across multiple products including very large private cloud datacenters and Microsoft Azure. You will work on challenging problems in the areas of distributed systems, scale, performance optimization, and help us contribute to Microsoftâs next generation hybrid cloud storage platform. Breadth of technology, depth, user mode, kernel mode, front end, services, you name it. Nothing is off limits here. We encourage you to reach out to our recruiter @Heather_MSFT (https://twitter.com/Heather_MSFT) on Twitter to learn more about specifics of our team. If you have any questions, please do not hesitate to reach out and engage directly with our team. Microsoft is an equal opportunity employer. All qualified applicants will receive consideration for employment without regard to age, ancestry, color, family or medical care leave, gender identity or expression, genetic information, marital status, medical condition, national origin, physical or mental disability, political affiliation, protected veteran status, race, religion, sex (including pregnancy), sexual orientation, or any other characteristic protected by applicable laws, regulations and ordinances. If you need assistance and/or a reasonable accommodation due to a disability during the application or the recruiting process, please send a request to askstaff@microsoft.com. **Location:**United States, Redmond (WA) **Technologies:** Basic: At least 3 years of experience developing software in C++ and/or C#; Preferred: Solid problem solving &amp; design skills. BS/BA degree or higher in computer science or equivalent. **Remote:** No **Visa Sponsorship:** No **Contact:** [careers page](https://careers.microsoft.com/jobdetails.aspx?ss=&amp;pg=0&amp;so=&amp;rw=1&amp;jid=307988&amp;jlang=en&amp;pp=ss)
How could that possibly be an acceptable outcome? There is only one valid code path, and that is that main jumps to nullptr. This will then crash the application. Concluding from there that this is undefined behaviour, and just doing something that violates the behaviour of the language as specified in the standard, is completely unacceptable. It is simply not the compiler's role to 'correct' your program like this behind your back. It is time that the notion of undefined behaviour is brought under control: as Bibifrog writes, it is there to allow for differences in CPU architecture. It is categorically not there to allow any kind of BS to happen. If you write to a nullptr, you may crash the application (modern OSes), the entire system (Amiga), or nothing may happen at all (8-bit). But that's pretty much the range of possible behaviour. UB does not mean the compiler can take the opportunity to activate Skynet and terminate society. We should actively resist the notion that UB allows for _any_ kind of behaviour; that it is an acceptable excuse for the optimizer to go wild. If an integer overflows, it may wrap around or trap; it should not render a mandelbrot to your printer. If an invalid pointer gets dereferenced, it may corrupt memory or crash the application, but it should not hack into your neighbour's wifi and download a ton of tentacle porn. If an uninitialized variable is read from, it should return the value that was already in memory; it should not forward all correspondence with your mistress to your wife, get all your credit cards blocked, and have your house auctioned off. Nasal demons are not a thing, and the notion that they ever were has proven toxic to our profession. We desperately require the ability to reason about our programs, based on the behaviours specified in the standard, and it seems that unless we reign in the range of possible behaviours allowed by the concept of UB, we are about to lose that. 
&gt; doing something that violates the behaviour of the language as specified in the standard Your program contains undefined behavior, the standard no longer specifies behavior for such a program, try to keep up.
`int add(int a, int b) { return a + b; }` This function invokes UB. Do you want every signed arithmetic to emit warning/error? There are a lot of cases like this. You might think that something you do is obviously well define (like some ror/rol arithmetic) but it's probably only true for the specific arch you use while C and C++ are designed to be portable. So if some thing can't be defined in such a way, that it'll perform equally well an ALL potential architectures of interest, it's just left undefined. You can just use intrinsics if you want to rely on some specific-arch behaviour. That way you'll at least get some sort of error when you try to compile your program to a different system.
Feel free to compile your code with `-O0` if you don't want the compiler to perform optimizations.
How could you possibly miss my point that I find this aspect of the standard to be unacceptable? 
How did you manage to miss my point that I find this aspect of the standard to be unacceptable? 
There is precisely zero basis for assuming that NeverCalled is going to be called anywhere. If the compiler wishes to make that assumption, it should _prove it_, and not _infer it_ "because otherwise the program won't make sense". 
Well, if you want any dereferencing of a nullptr to end up really reading from address 0, just declare the pointer volatile. Or you could also use the sanitizer that those moronic compiler writers provide for you ;) Admittedly, I would also prefer null pointer dereferencing to be inplementation defined and not undefined behavior.
So go use one of those, why shit on these two?
I wouldn't say insane. That's a side effect of undefined behavior. If you trigger it, you can't reason about your program.
Sorry, english is not my first language.
Sure there is. If NeverCalled is never called, the program is undefined and outside the range of inputs the compiler consider. Every legal C++ program that this input could form a part of, NeverCalled is called first. The compiler has proven it.
But are any of those other languages good? My experience so far is 'no'
lol how can i forget that ð it should be like this : ... }else{ cout &lt;&lt; " " &lt;&lt; '\b'; Name.erase( Name.begin() + (--index) ); } ... ð
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6xjphr/what_are_the_windows_compilers_that_support_pop/dmghy5y/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Actually part of what I had in mind were things like the proposals for 'friendly' dialects of C, which have thus far failed to get anywhere.
&gt; crashed crash
I would buy your book of do and do nots of compilers if your do nots remain as creative as these.
&gt; Which is a completely retarded approach, because any big enough C++ program is going to have an UB somewhere, and the compiler potentially amplifying its effects way beyond reason is a recipe for disasters. Then take another approach and write your own compiler, that errors on any undefined behaviour. That said, you'll be lucky if you can even compile most basic programs.
&gt; There is only one valid code path, and that is that main jumps to nullptr. This will then crash the application. No, there is no "main jumps to nullptr". It's "main jumps to an uninitialized function pointer". Ruh roh! What if that function pointer happened to be holding junk data matching the value that `NeverCalled` sets it to anyways? Wouldn't the outcome then be entirely reasonable, and consistent with the naive, no-nasal-demons point of view? Don't blame the optimizer for all of this. Uninitialized values will get you even with `-O0`. So save some of your fire for the other parts of the language :)
Isn't static data always zero-initialized?
&gt; it is there to allow for differences in CPU architecture No, that's not the only reason. It is also there to *allow compiler optimizations*. For example, strict aliasing.
Nope, you're wrong about the assumption that "this" is only available in lvalues. rvalues have the same memory behavior as lvalues, it's just that you can't refer to the memory address of rvalues without having a rvalue reference. struct S { S() { std::cout &lt;&lt; this &lt;&lt; "\n"; } int a{ 0 }; }; void foo(S&amp;&amp; s) { } void main() { foo(S {}); // compiles =&gt; S {} is an rvalue, "this" just works fine S s; foo(s); // doesn't compile because s is not an rvalue } 
I once modified clang to make it allow `using val = const auto;`. It was fun.
&gt; Historically, compilers were shit at optimizing your code. That's irrelevant, and not the reason why the C standard talks about UB. Despite the downvotes /u/Bibifrog is getting, they are right about the origin of UB. &gt; Assuming undefined behavior wont happen is not a new concept. It may not be new, and the standard may allow it, but that doesn't automatically make a good choice. &gt; It should be about as old as signed integer arithmetic. Integer overflow is actually an excellent example of this: it's UB in C99, because different hardware behave differently when it happens, and the standard actually has an example on why, because of this, an implementation may not arbitrarily rearrange operations during a sequence of sums. A complying implementation may only do so if the underlying platform guarantees that the underlying hardware overflow behavior _does not change the result_. This is very different from assuming it doesn't happen, and it actually recalls the basis both for UB and what the compilers should strive for. That's a very different principle from âassume UB doesn't happenâ. &gt; Having the tools to reason about code in complex ways is new. And buggy. And the C language really isn't designed for that. Using the assumption that UB doesn't happen as basis, instead of acting on it as âleave the code exactly as isâ isn't necessarily the wisest choice.
As /u/Hedede points out below, this is a global variable with static storage duration and no explicit initialisation, so is therefore zero initialised. http://en.cppreference.com/w/cpp/language/initialization#Non-local_variables Calling / dereferencing a null function pointer is still UB, but I do agree with the point that even if the general case is impossible to catch, some specific cases like this could result in a (possibly optional) compiler error. 
If it weren't undefined behavior, the compiler would have to generate code to handle it, which wouldn't be great either.
Then use Rust and stop unproductively swearing. C++ is used in mission critical software, your statements don't hold.
Undefined behavior isn't even a property of the language. Static analyses, even though they are very advanced by now, are still limited to static analyses. Bibifrog is after runtime checks, pretty much what Rust does when compile-time checks can't cover some situations. But compilers have very good runtime analyzers nowadays, specially Clang with their sanitizers. If you use C++, you are naturally expected to learn those tools and make sure your software behaves as expected.
I wish more practical talks would be submitted to conferences, or just someone starting a blog on this. On the other hand, if your talk isn't cutting edge, its going to be often shut down by the program committee.
I wonder if Herb will again fake that user study participants said what he wanted to hear.
There's other thread pools like [progschj/ThreadPool](https://github.com/progschj/ThreadPool) that use `std` functionality only and no `barrier`, are you sure it's needed?
I think you want to use let not val. Other than that I agree with you that const auto is an abomination, C++11 shoud have gone for const/var instead of const auto/auto but geniuses from ISO are incompetent clowns when it comes to introducing new keywords(because you know some shitty companies do not want to spend money on code maintenance entire ecosystem needs to suffer). 
Your title says "val" not "var". Also, var =&gt; const seems strange.
Can I borrow that attention instead? I was lead here by looking for an error I've previously reported and had marked as resolved but am still seeing in the latest 15.3 build (15.3.3). https://developercommunity.visualstudio.com/content/problem/89836/odd-static-assert-behaviour.html template&lt;typename T&gt; inline constexpr bool IsMessageWellFormed() { // #TODO fix these broken static_asserts in latest Visual Studio (15.3) static_assert(std::is_same_v&lt;decltype(T::packetType), const EPacketType&gt; || std::is_same_v&lt;decltype(T::packetType), const RakNet::MessageID&gt;, "Message missing const packetType member"); static_assert(!std::is_member_object_pointer_v&lt;decltype(&amp;T::packetType)&gt;, "packetType must be static"); return true; } Gives `error C2187: syntax error: 'const' was unexpected here` on the first static_assert. I realize that maybe with me using the `/permissive-` switch and any further work to be standards-comformant, I may have just slipped into a hole with some code that was previously allowed but non-conforming. Is that the case here? If I change that first static_asser to just static_assert(std::is_same_v&lt;decltype(T::packetType), EPacketType&gt;, "Message missing const packetType member"); I get `error C2187: syntax error: 'identifier' was unexpected here`. `EPacketType` is defined earlier in the file, thusly; enum EPacketType : unsigned char { NOT_SET = ID_USER_PACKET_ENUM, // first value must start at ID_USER_PACKET_ENUM SERVER_BROADCAST_DISCONNECTION, SERVER_INITIAL_SYNC, SERVER_TEST_MSG, CLIENT_SYNC_ACK, SERVER_PHYSICS_UPDATE }; Curious to hear your thoughts!
No, we do not want a warning. But do you really want the compiler to reason that since this is UB, it is therefore free to assume the function will never be called at all, and just eliminate it altogether? 
The compiler should generate the code it is told to generate. The static function pointer should initialize to nullptr, _because that is what the standard says_. There is no code to change it, so such code should not be generated. And when it is called, the compiler should do the exact same thing it does whenever it calls a function pointer: jump to whatever value is pointed at. You can mod me to minus infinity for all I care, but that's the only legal outcome. 
Looking forward to learn more about this. 
&gt; The static function pointer should initialize to nullptr, because that is what the standard says. That would be the case if the program was correct, with defined-, implementation-defined, or unspecified behavior. It contains undefined behavior, which the standard also says makes the program erroneous. Therefore, the standard imposes no requirements on what the behavior should be. That's basic terminology.
In this case it's not a function call that may cause UB but integer addition. So compiler just assumes that overflow never happens and everyone is happy. But the same reasoning makes compiler eliminate all kinds of naive overflow checks like `a + 1 &lt; a` and similar. There is no real way around it. And in most cases compiler can't statically reason whether this particular case of UB is unexpected by the user or not. Or if even happens (since usually there is no way to detect it until runtime). But you can use tooling like UBsan to make sure your program doesn't rely on UB in unexpected ways.
Sean Parent's talk may give you some extra ideas. https://www.youtube.com/watch?v=QIHy8pXbneI
The compiler authors have it right here. Undefined is for stuff that makes so real sense. For platform differences the standard defines a number of things as implementation defined.
People seem to often miss that proofs depend on axioms. The compiler takes the validity of the program as an axiom at the optimizer phase, as any errors are reasonable to catch are allay cought by the front end.
Pybind is much less verbose. It looks like object.bind("fun1", [] {}) .bind("fun2", [] (int x, int y) { return x+y; }); 
That argument does not fly. If the integer addition is UB it may be eliminated. That means the function will be empty, so it too may be eliminated. It's the exact same reasoning, applied in the exact same braindead way. 
This optimization consists of assuming that the programmer initialized variables. Attempting to erase all files is simply running the code the programmer wrote.
What? That's not the reasoning the compiler uses for integer overflow. Maybe you'd like to read these two links: 1. https://blog.regehr.org/archives/213 2. http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html Optimizing undefined behavior isn't guided by illogical reasoning.
&gt; If the integer addition is UB it may be eliminated No. Integer overflow is UB. So compiler assumes that NO overflow happens (i.e. no UB happens) and generates code as if `a + b` never overflows. This is expected by most programmers, but on the other hand it leads to compiler to optimize/eliminate checks such as `a + 1 &lt; a` (Where a is of signed type), since `a + 1` is always bigger than `a` if there is no overflow.
Yes, I got that. My point, if anyone cares, is that the standard really need changing. The current reading, that of nasal demons, is a gross misrepresentation of what UB was intended to be in the first place, but that supremely pedantic reading wasn't a big deal because compilers by and large understood that if you wrote `a + b` it should emit an `add` instruction, even if it could prove the result would overflow. And similarly, that if you wrote `Function bla=nullptr; bla();`, it should emit a `jmp 0` instruction, even if it knew this would crash the program. UB, as originally intended, only meant that it is not the compilers' responsibility if the program crashes at this point. It only says the compiler does not need to go out of its way to stop the upcoming accident from happening. "The compiler can act as if the UB wasn't there" only meant "the compiler does not need to take special care in situations like this, but can generate code as if the function pointer has a legal value." If anything, this means that the compiler should not analyze the value of the function pointer to begin with; it should simply accept whatever value is present and load it into the program counter. Unfortunately, this critical understanding of what UB was supposed to be is lost on the current generation of compiler writers, who grew up believing in nasal demons, and who set out writing compilers that aggressively rearrange code if there is a whiff of UB in it. The result is that we are losing our ability to reason about our code, and this is a very bad thing. It means that any addition (or one of a hundred other things) is about to become a death trap; if the compiler can prove, or even just infer, that it will result in UB, it might and will do _whatever it likes_, and more and more that is proving to be something completely unexpected. We need to stop this, and the way to do it is by changing the definition of UB in the standard. 
Because in your case there's no right answer, application architecture ends up becoming highly specialized for the application over time. The bigger and more complex it grows, the more abstractions get built to support it. It's helpful to know about all the various design patterns so you can know when to employ it, but don't expect it to be a clean process. It's going to get messy. 
I agree, but we seem to have collectively given up before we've started I can give a whole bunch of tips on how to design code up to ~50k lines of code that will help someone who has no idea what they're doing. It won't solve all your problems, but it would help 99% of C++ talks for example are focusing on improving the specific implementation of a class, or algorithm, which is nice but there's so little for nice architecture design. There are definitely things that would help and things that wouldn't
What do you propose the change to be like?
&gt; Admittedly, I would also prefer null pointer dereferencing to be implementation defined and not undefined behavior. That'd be bad for optimizations.
Rust has UB too. Rust has unsafe stuff too. In the end it comes down to "rewarding well-formed programs at the expense of ill-formed programs". And which exact programs you think are "most important" is an endless and unresolvable debate. You might not agree with the design of C and C++, but to say that it is "retarded" is an inflammatory and untenable position.
Thank you, I overlooked this.
&gt; Bibifrog is after runtime checks, pretty much what Rust does when compile-time checks can't cover some situations. [dependent typing](https://en.wikipedia.org/wiki/Dependent_type) can help with this.
I can recommend you so much to try pybind11. The debugging is awesome as well. You can compile your python module with debug information, then start your python script that uses the module, set a breakpoint in VS, attach the VS debugger to the running python instance (CTRL+ALT+P), and it'll break inside the C++ code in VS. I'm currently using PyCharm for the python-side so there is the minimal hassle of switching back-and-forth between 2 IDEs and re-attaching the VS debugger (it's a negligible hassle though!), but apparently Microsoft is already working on integrating python and C++ projects together so this will become a seamless experience (maybe it's even already possible in the latest VS 2017 Preview, I haven't tried lately).
I [wrote this as a joke](https://www.reddit.com/r/cpp/comments/69jlm7/const_by_default/dh779vz/) once... and it is still an awful idea.
I don't really have much to say about the C++ code, but this is what Rust does for integer over- / underflows: - In debug mode, the program will always crash on an under / overflow, unless not it is marked as the following: - wrapping_add - standard overflow: `65536 + 1 = 0` - saturating_add - clamped overflow: `65536 + 1 = 65536` - overflowing_add - overflow with extra boolean return if overflow: `65536 + 1 = (0, true)` - checked_add - same as overflowing_add, but returns Option&lt;T&gt;: `65536 + 1 = None` (would be `std::optional` in C++) - there is a fourth type, which I call "padding_add" - which would return a bigger type than the initial one in case of an overflow. So `65536 + 1 = 65537_u32` (u32 (32bit unsigned int) being the next biggest type). It is not part of the standard library, since it doesn't integrate well with the type system, I think. Same goes for multiplications, divisions and subtractions. It's a tradeoff between safety and more typing. Rusts overflowing is "specified to wrap as twoâs complement. ([source](https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md))". Meaning, it defaults to wrapping_add and it is not undefined behaviour. I don't want to influence this discussion, just some thoughts on what could be done better.
Sure, you can use Clang's sanitizers to wrap those (there are others like address sanitizers, undefined behavior sanitizers etc). At least Clang and GCC both have -fwrap too (I don't know about MSVC). Lastly, Clang provides [builtin functions](https://clang.llvm.org/docs/LanguageExtensions.html#checked-arithmetic-builtins) for wrapping as well.
Man, you always bash ISO. Why donât you join the committee and make a difference if youâre clearly so upset.
Do you even `if err != nil`?
UPDATE: actually it would be quite simple. We change the definition of UB as follows: "a compiler is not required to prove the existence of UB, but if it does, it is required to issue a mandatory diagnostic." This eliminates the most toxic part of the problem: that it changes code generation without even telling you about it. 
gcc on Windows for a beginner?
All of them, none of them, it doesn't matter. You can always go back and add them as you need.
They could, but it sounds like they're ready to just sit down and learn some core C++
Visual C++ should be the only one you need.
I would recommend installing `Desktop development with C++` under the `Windows` workload tab, `Game development with C++` under `Mobile &amp; Gaming` tab, and `Linux development with C++` under `Other Toolsets` tab. This installation will pretty much cover everything you will need (and more). If you want to use the command line to build your programs, search for the `x64 Native Tools Command Prompt for VS 2017 (vs2017)`. If you let the installer pick default locations and create start menu shortcuts, you can find it in: `C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Visual Studio 2017\Visual Studio Tools\VC` You can check [this link](https://msdn.microsoft.com/en-us/library/ms235639.aspx) for a more detailed approach on how to compile and run your program. The instructions are for VS 2015, but should still apply. If you're going to use Visual Studio itself to compile and run, [this](https://docs.microsoft.com/en-us/cpp/windows/creating-a-console-application) should help you get started. Good luck and remember, Google, [MS-Docs](https://docs.microsoft.com/en-us/cpp/) and [MSDN](https://msdn.microsoft.com) are your friends.
The question was *"what workloads I should install for Visual Studio Community 2017"*, and your answer is *"research what a compiler is and download gcc"*. I'd suggest that if you want to overrule the question like that, you need to have a pretty strong justification.
Gaming workload for someone who is about to write his first c++ program? why? Same goes for Linux workload - you know that this just means you can establish an ssh connection to a Linux machine and compile your stuff there?
The only thing you need is "Desktop Development with c++", and you can keep optional components that are selected by default. There are some other components that can be useful later, but you can always change your installation later, so stick to the defaults for now. Edit:. Oh, and when you create your first project, just use "Empty Project"
Sorry, I can't remember what each workload provides so I listed those that are installed on my machine. They give me access to pretty much anything a beginner will need and I could not say, with confidence, that only installing one will suffice. If OP's internet is slow and/or OP is low on storage space, my suggestions might be overkill.
You never know what a new programmer will venture into. u/lanedraex provided exactly the type of advice I would have been looking for when I first started learning C++. It's very detailed and very helpful, in my opinion. 
Thanks
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
What optimizations? The kind shown here? If it was really the Intent of the author that a specific function known at compile time gets called, he could just do the assignment during static initialization and make the whole thing const (-expr). Yes, I know it might also prevent one or two useful optimizations (right now I can't think of one) but I would still prefer it, because I'm not working for a company like Google or Facebook where 1% Performance win accross the board will save millions of dollars. On the other hand, if bugs get hidden or blown up in terms of severity due to optimizations like that can become pretty problematic. As Bibifrog said, you just can't assume that a non-trivial c++ program has no instances of undefined behavior somewhere regardless of how many tests you write or how many tools you throw at it.
Is that actually a workload? I don't think there is even a component that is just called "Visual C++".
Is that actually a workload? I don't think that is even a component that is just called "Visual C++".
Is that actually a workload? I don't think that is even a component that is just called "Visual C++".
Is that actually a workload? I don't think that is even a component that is just called "Visual C++".
Usually, you want give a beginner as few options as possible. VS is imho anyway not a very beginner friendly IDE and installing more workloads just means more options / choices the user has to make and more things that can go wrong during installation. You can always install additional workloads later if the need arises.
I used to explore each of the many options. It helped me learn. 
Learn C++ or learn VS? And was that the first thing you did when starting to learn programming? Or after you wrote your first few simple porgrams? Nothing against exploring options but you shouldn't present all of them to a beginner from the start (The fery fact that the OP asked this questions shows that too many options overwhelm a beginner). Again, one can always install additional packages LATER if one gets curious, but stick to the minumum at the beginning. Neither the Linux Workload, nor the Gaming workload contribute anything to a normal c++ commandline project.
I was thinking of the install screen I saw yesterday. Different version of VS perhaps. I guess I'm not too clear what workloads are if that's not one :/
As the original Post has been deleted, I cna't be sure but I thought this was about installing the community edition of VS2017: https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio The problem is that my installer isn't english, so I might be wrong, but the closest thing I could find would probably translate to "Visual Studio C++ core features"
Actually, both. When I first started learning C++, Visual Studio wasn't something I had access to. I learned to compile and build my programs from scratch using GCC for DOS. The options I was given were from the [DJGPP Zip Picker](http://www.delorie.com/djgpp/zip-picker.html). At first I downloaded everything not knowing what I would and wouldn't need. Eventually, I did some searching to figure out each option. I ended up learning Allegro for graphics and I learned that I wasn't interested in using the Unix Curses Emulator. When I started learning Visual Studio later, I ended up installing much more than I needed. I installed all languages even though I really only needed C++ related stuff. I had no idea what MFC was at the time but I installed it and learned what it was, though I decided not to learn the framework itself. Maybe you're right and focusing a new programmer on just what they need is helpful but for me it gave me plenty to explore. It could be that it helped me simply because I'm the curious sort anyway. Let's face it though, any tutorial that covers Visual Studio C++ will also tell them to start with a Win32 Console application and will walk them through the settings to get a basic console app started anyway. 
&gt; Man, you always bash ISO. Why donât you join the committee and make a difference if youâre clearly so upset. I also dislike US congress, I should just run for congress and STFU in the meantime, right. ;) 
&gt; Typing is the easiest part of programming. Shorter code is easier to read also. 
So you're not using the Visual Studio IDE (+debugger etc.), correct?
My dream feature for these scripting libraries would be some sort of debugging support. I assume this is a very hard thing to do since none of the libraries I know do this.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6xsesg/any_help_with_my_program/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I donât care. You need to get elected for that. But there are ways attending an ISO meeting without jumping through too many hoops.
Oh! Yes, desktop development with C++ which in turn selects that
I think it completes C++ evolution -- we finally got to the point when incorrect code can actually format your hard drive. :D
If invalid pointer dereferencing becomes defined behavior, it will stop operating systems from working, will harden optimization's work (now every pointer dereferencing has checks, and proving that a pointer is valid becomes harder, so a there will be a bunch of runtime checks), and will break a lot of code. Personally, I like it the way it is nowadays: you have opt-in tools, like contracts, sanitizers, compiler support to write safer code, and still have your program as fast as if you didn't write those checks (release mode).
When calculating the profit, you need to use the rounded number of cartons (i.e. 1296)
/r/cpp_questions is the sub you are looking for
&gt; Calling a nullptr is UB meanings that the standard does not impose a restriction, to cover stupid architectures. You're thinking of implementation-defined/unspecified behavior. Undefined behavior is for erroneous programs/data.
Yup
Hmmm, I know we are here to help answer questions, but when it's for a grading in education I don't think it is right at all... You are being measured on your own ability and study, not mine or others on the internet. If you have questions you should ask the person who set you the study/exam question, otherwise I consider this cheating.
I didn't say invalid pointer dereferencing in general. I said dereferencing a nullptr. And maybe you don't know, what implementation defined behavior means, but it would require no additional checks or break any OS code: First of all, turning UB into IB is never a breaking change, because whatever is now IB could previously have been a possible realization if UB. And vice versa, if the compiler already gave any guarantees about what happens in a specific case of UB then it can just keep that semantic. Also, look at the most likely forms of IB for that specific case: Windows and Linux already terminate a program when it actually tries to access memory at address zero (which is directly supported in HW thanks to virtual memory management / memory protection) and that is exactly the behavior desired by most people complaining about optimizations such as shown herer. The only difference when turning this from UB into IB would be that the compiler may no longer assume that dereferencing a nullptr never hapens and can e.g. no longer mark code as unreachable where it can prove that it would lead to dereferencing a nullptr. Meaning, if you actually have an error in your program you now have the guarantee that it will terminate instead of running amok under some exotic circumstances. On kernel programs or e.g. on a microcontroller, the IB could just be that the programs reads whatever data is stored at address zero and reinterprets it as the appropriate type. Again, no additional checks required. Finally, the problem with all currently available opt-in methods is that their runtime costs are much higher than what I just sugested. Using ubsan for example indeed requires a lot of additional checks so all those techniques are only feasible during testing, not in the released program. Now how many programs do you know that actually have full test coverage? (ignoring the fact that even 100% code coverage will not necessarily surface all instances of nullptr dereferencing that may arise during runtime).
It's not really cheating when it's 90% complete and besides , I plan to learn from whoever is willing to help me. Cheating isn't going to help me in the long term. 
Hmm, well given 4900 milk the number of cartons is rounded to 1296. I still don't understand why mind tap is asking for decimals. It's using the rounded number of cartons but it's not able to output any decimal answers. 
This is the ouput. Mindtap is reading it as 55% complete. I'm missing one or two outputs. [here](https://imgur.com/a/UkO6K)
[Note that the OP probably forgot to enable LTO](https://www.reddit.com/r/programming/comments/6xtya8/comparing_c_and_c_usage_and_performance_with_a/dmig7ro/).
LTO?
[removed]
link-time optimization
I don't get it, what exactly should I take from the article?
Link Time Optimisation
GCC comes with libstdc++ not, as the article variously refers to "stdlibc++" or "stlibc++".
[removed]
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6xtpm9/im_having_trouble_getting_the_last_result_can/dmimkhv/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I did not forget. I purposefully only tested with default settings. There are too many things in flight already, adding lto would only have confused things. The measurements linked show that LTO makes the executables smaller but not by an order of magnitude. Relative size differences remain roughly the same. You should use LTO in the real world but for this experiment the findings remain the same.
&gt; Hmmm, I know we are here to help answer questions, We're not. We have a separate subreddit for questions: /r/cpp_questions! :)
That's the worst idea I've heard in a long time. That's kind of like overloading some operator like * or &lt; for strings to call printf with the operands as first and second argument. Sounds clever on the paper, saves a few keystrokes (DAE autocomplete?) and makes your codebase 100% unintelligible to everyone on this planet, including you a few weeks from now when you inevitably forget your "clever" tricks. **Never, ever write code you would call "clever" or a "trick".** Write simple, dumb code.
Please don't ever release that abomination to the public.
If writing makes you tired 1. Autocomplete 2. Programming might not be the right hobby for you 3. Autocomplete
I think the extensive use of globals in the locator classes can seen as a weakness in architecture. As far as I can tell most of this stuff can be owned by a game instance or something along these lines. Given the nature of the game and the primitives it consists of, you could start write unit test to clarify the architecture of the game. Perhaps you would find that you can do away a bunch of classes...
&gt; ... with a real world project. &gt; use LTO in the real world but for this experiment Choose one.
Did you strip the executables ? when I do it after compiling, the C++ one looses much more size, relatively, than the C one.
char* is suppose to alias all... why would there be a problem?
Don't you think it would make sense to get every program to run as fast as possible?
Yes. The unstripped size is 2 MB or so.
Casting a pointer to some type T to a pointer to a char type does not violate strict aliasing. Casting a pointer to a char type to a pointer to an unrelated type (~~as in the OP's code~~ edit: as the OP's use case would require) DOES break strict aliasing.
... uh ? when I do `meson build` (in release, g++ 7) I get a 160kb executable. when I strip (with `strip`) this executable it goes down to 125 kb.
hmph. In my case, `Msg` has always been a `POD` and constructing the object and then doing a memcpy does not actually lead to memory copying at `-O3`. Both the compilers (gcc and clang) were able to remove the memcpy call from the final code. I am interested in the answer to this question though.
Still getting used to it, but I have a favorite use case that I rarely see mentioned: declaring result types for library function calls. I much prefer having the result variable track the function type to memorizing details that may be automated; what matters is what values the result is compared against. The first rule of programming is that there are no rules.
So, let me see if I understand. Objects cannot be "reinterpret_casted into existence", they only exist according to the standard when they are newed or otherwise constructed properly. And if you try to go around that and access an object of some type where none exists, you break strict aliasing. Here, to get around this, you are actually going to new an object there, using placement new, but the initialization will be trivial, so it will have in its fields already the correct data. There will now be a valid object at this location according to the standard, and you didn't pay any runtime cost, assuming the object is POD and all that. I think it might cause lots of compiler warnings about "maybe used uninitialized data". Since that's basically what is happening from the compiler's point of view. It might also be annoying with cppcheck or similar static analysis tools. To my knowledge this would not cause undefined behavior though. Edit: Actually I'm not so sure now. In the C++14 standard, [5.3.4] new, item 17: A *new-expression* that creates an object of type T initializes that object as follows: â If the *new-initializer* is omitted, the object is default-initialized (8.5); if no initialization is performed, the object has indeterminate value. â Otherwise, the new-initializer is interpreted according to the initialization rules of 8.5 for direct- initialization. It doesn't say anything in this section like, when using placement new, uninitialized members have the value that was already in the memory. So, from the point of view of standard / optimizer, all that data might be uninitialized afaik. Anyone know a better reference in the standard to resolve this??
I would not call code that passes around const char pointers and casts them unnecessary to std::string and uses printf c++
Let's assume that `Msg` has a trivial default constructor that performs no initialization on its data members, otherwise this code would be obviously broken. Even then, this is worse. Previously the compiler can only invoke the strict aliasing rule if it knew that `data` does not actually point to a `Msg`, but now you have guaranteed undefined behavior for accessing an uninitialized object. The `Msg` object created by the placement new expression has indeterminate value, not "whatever that was in the storage previously" (see [dcl.init]/12). In fact, at least [one major implementation]( https://gcc.gnu.org/gcc-6/porting_to.html#flifetime-dse) is known to use this kind of analysis for optimization. 
Release mode does not have -g. You should use debugoptimized. Different versions of GCC and stdlib also yield different sized executables.
&gt; memory leaks 0 0 &gt;1000 Reason enough for me to use the C++ version. Also your C++ version doesn't really look like good C++ to me, it looks like a very bad C conversion. Also fix your includes :-) : #include &lt;string.h&gt; // =&gt; &lt;string&gt; #include &lt;stdlib.h&gt; // =&gt; &lt;cstdlib&gt; // (many more) 
Seems like a good case for std::string_view
C++ is faster than C.
boost::barrier is extremely simple and you could write your own version easily just using std::mutex, std::lock_guard, and std::condition_variable. Just take a look at the source, its only about 20 lines or so.
I alternate between VS and VSCode. VS can debug lld's output just fine.
So you compile your code (a CMake project presumably?) on Windows with VSCode and clang++.exe, and then debug the code from within VS?
I use Boost.Build, not CMake; not sure which text editor I'm using is pertinent... ;-] EDIT: To be clear, debugging from VSCode works fine, too.
GLib is a huge library, which can vastly reduce performance and increase memory use. I've done a server project in plain C and C+GLib. Not surprisingly, the GLib version is slower and takes more memory. GObject is a *dynamic* object system, after all. I'd say this comparison is comparing GLib and libstdc++, rather than C and C++. Or you can conclude libc is so weak that we need to introduce GLib to make C practical.
There was a [very long discussion about this](https://groups.google.com/a/isocpp.org/d/msg/std-discussion/rt2ivJnc4hg/Lr541AYgCQAJ) on std-discussions a while back. What you have is not valid code, and really: callback(reinterpret_cast&lt;Msg const*&gt;(data)); basically *needs* to do the expected thing, even if it's currently UB since there's no actual `Msg` object there. I don't know if something's going to change in this regard in the future, there was some talk about having a new cast that begins lifetime? 
Not to mention that it throws string literals (!) instead of exceptions and declares most of the variables at the start of the function C90 style. And that was just from the first cpp file I opened up.
How long did it take to do the conversion?
There was a similar question on stackoverflow: https://stackoverflow.com/questions/41016334/cast-array-of-bytes-to-pod. One problem is that you have no guarantee that operator new doesn't modify the memory. You can copy the data forth and back however, which then gets optimized away.
Well, one of the Committee members said something along these lines ones: &gt; "Once you've hit undefined behavior in your program, anything can happen. Your computer can melt. Your cat can get pregnant." QED 
My sarcasm detector is confused right now.
yes, that was the party line, but it never actually happened before now. I think we could throw in the towel and go party for the next 40 years or so. C++ is complete! :D
Yeah, the file I looked at should have used std::string_view in at least a few places.
Except it's not. OP just doesn't know what he's doing.
Which open source library? what a terrible title.
I think the post's title belies some of the post's points. One part I found interesting was the notion of using C++ as a temporary holding pit when transitioning a C codebase to an even more modern language (D and Rust are mentioned, but not limited to those) due to cleaner diffs in VCS commits during the piecemeal conversion being easier than directly going from C to the target language. &gt; Following this train of thought to its final station yields slightly paradoxical results. If you have a legacy C code base that you want to convert to D or Rust or whatever, it might make sense to convert it to C++ first. This allows you to do the hard de-C-ification in smaller steps. The result is modern C++ with RAII and value types that is a lot simpler to convert to the final target language. As long as the design is 1-to-1 with the target language I guess that's generally true, but at some point if you are going to use differentiating features from the new language that don't have as much of a C++ counterpart, like D's ranges and slices for example, then there might be better ways. For example, using D again which partially backwards compatible with C, perhaps generating a DLL exposing the piecemeal developed functions would work in a similarly clean way at the cost of abstracting the split through cross-language linking. That would allow the refactored functionality not to be inline but to be separate in the D code from the transition code back in the C codebase where the refactor would be represented by deleting lines, replacing them with invocations to those new functions exposed by the DLL from the D code. I don't know. lol
Yep. That is a bug in MSVC. If you replace T&amp;&amp; with plain T, you will get the desired move behavior. I was not able to repro the segfault on clang. Can you provide a repro/file a bug (https://bugs.llvm.org/), I can take a look.
That's a good catch. The point of using placement new in that code was to make certain an object existed to avoid the aliasing issue but I didn't realise placement new had UB on the underlying bytes and therefore caused a different set of UB. It seems very wrong though that the only way to work around this issue is to use memcpy in performance critical code and hope that every compiler will optimise it away. What if the compiler optimising behaviour changes, or for some reason it can't optimise this behaviour for certain calls? It seems extremely fragile. 
Launching async activity from await_suspend can get you zero-overhead adapter compared to plain callback model. Launching first and returning future like object adds an overhead associated with the future. With some creative coroutine adapters to synthesize a future-like object you can whittle down overhead quite a lot (eliminate heap allocations for the future shared object, for example), but, still would not be able to remove synchronization required when completing an operation and subscribing continuation, plus, if I/O completes before subscription happened, you may need to repost completion on a threadpool to avoid jitter.
&gt; every expression is exactly one of an lvalue, an xvalue, or a prvalue thats not what the venn diagram is saying... edit: its a good article though
It seems to me that lvalue and prvalue in the Venn diagram only mean the red/green area (terrible colour choice btw) and _not_ the overlap - so that statement is true. Glvalue and rvalue represent the entire circles including the overlap.
Possibly confusing Ven diagram aside, the article is quite amazing, I am keeping this to give as reference. Personally I had no idea about the concept of prvalue and the guarantee that no mctor will be called in cases like the usage of '='. The one thing I'm still unsure of after reading this is whether an optimization in a case like: T t1{}; T t2 = std::move(t1); Where t1 can just be "aliased" to t1 instead of actually calling the move, means that t1 "becomes" a prvalue when move is called, or if during the move t1 is guaranteed to always be an xvalue (even if the move ctor itself can be optimized away by the compiler). Though I guess from a programmer's perspective this wouldn't really matter.
Could you check the KDevelop command-line output? What version of KDevelop is it?
Very good article, thanks for sharing. I had no problems reading the Venn diagrams, but maybe it's because I already knew the subject and my math background. However, I agree that the choice of colors is far from colorblind-friendly. The note about the "most vexing parse" (i.e. `T var();` being a function declaration) is unnecessarily distracting. I would rewrite the example using `{}` instead of `()` and leave the subtleties for another article. The final paragraph contains a sentence that doesn't parse in English ("there are expressions are C++ are divided"), probably the remnants of a cut&amp;paste edit. 
I just came up with [a picture](https://i.stack.imgur.com/QgGEL.jpg) which helps you remember that xvalues are the result of calling `std::move`.
Code generators and build systems are both close to my heart so let me (hopefully constructively) criticize this a bit. &gt; [...] annotated with preprocessor identifiers [...] &gt; [...] python script [...] So the more accurate title would have been *Simple C++ Reflection with Preprocessor, External Tool, and CMake*. Currently (until we have reflection as part of the language) there are two main approaches to adding reflection(-like) functionality in C++: using preprocessor macros and using source code generation. The main drawbacks of the preprocessor approach are having to annotate your classes/members manually (which is both tedious and error-prone) and ugly code. The main drawbacks of the source code generation approach are the need for an external tool (which might not be portable, like Python scripts) and poor support for source code generation by existing build systems (see below for details). The proposed setup, by combining both approaches gets all the drawbacks. &gt; each source file in the reflected projects has an attached custom CMake command so when it gets modified that command gets ran What happens if another, `#included`'ed header gets changed? While in a very simple implementation like this it may not be an issue, in anything more real-world, like an ORM, it definitely will. For example, an included header may have a `typedef` that you use to declare data members in your class. If you change that `typedef`, then the SQL type and thus the table definition for your class will change as well.
Because that's not what you actually said. Instead you argued that the compiled code violates the standard: &gt; just doing something that violates the behaviour of the language as specified in the standard, is completely unacceptable But the standard specifies no behavior for this code, so it's impossible to violate it. &gt; If an invalid pointer gets dereferenced, it may corrupt memory or crash the application, but it should not hack into your neighbour's wifi and download a ton of tentacle porn. Good luck with that. Corrupting memory is exactly what allows for hacking your neighbor's wifi, etc. I mean, this is how exploits work. Given the way C and C++ are designed, it would be hard to rule out everything that attackers use to take over programs (invalid pointers, buffer overflows, use-after-free, etc.), all of which are instances of "undefined behavior". That said, I'm sympathetic to your call for an improved standard with more defined behavior. As you said, &gt; We desperately require the ability to reason about our programs
&gt; Unfortunately, this critical understanding of what UB was supposed to be is lost on the current generation of compiler writers I think it's unfair to blame compiler writers for implementing exactly what the standard says. If the authors of the standard had specific intentions for UB, they should have said so instead of going straight to "this code is literally meaningless, anything can happen". &gt; It means that any addition (or one of a hundred other things) is about to become a death trap What do you mean, "is about to"? Addition always has been a death trap, and C++ is chock-full of other, similar traps. There's a very narrow and subtly defined range of code with defined behavior, and if you stray outside just a bit, all bets are off: "_**undefined behavior** - behavior for which this International Standard imposes no requirements_" Unfortunately, this critical understanding of what C++ actually is is lost on the current generation of application/library writers, who grew up believing in "`+` is just an `add` instruction", etc. &gt; We need to stop this, and the way to do it is by changing the definition of UB in the standard. Agreed.
&gt; it never actually happened before now Exploiting programs (leading to arbitrary code execution) is an instance of undefined behavior (usually buffer overflows, user-after-free, etc.). It has been happening for a long time.
R u crtn? 
It will always be an xvalue. prvalues can only be values, not references.
60k - very few indeed...
&gt; Nope, you're wrong about the assumption that "this" is only available in lvalues I didn't say that. I said that everything that doesn't have a 'this' should be an rvalue, the rest should be lvalues. 
i LOVE cherno!!
I used to watch his channel in the game development by c++ and openGL. For some reason, his video quality becomes worse and worse and more like the code debugging streaming or so. The last time I did check his channel was two months ago and his channel had stopped to upload for a while. I thought this one is totally dead already. But I was wrong. He just take the negative comments before and improves his video quality.
`string.h` is `cstring`, not `string` ;)
&gt;With a regular union you can only use POD types Not true! Since C++11, unions can contain pretty much anything, but must have a user-defined constructor (although I'm not sure that helps much - it's not like the union can contain anything to indicate which member was initialized)
&gt; A good rule of thumb: if you see #include &lt;iostream.h&gt;, run. Beginners won't know that the .h is significant.
the venn diagram shows that there are lvalues, there are prvalues, and there are xvalues which are both lvalues and prvalues. The follow up sentence 'every expression is exactly one of an lvalue, an xvalue, or a prvalue' contradicts that. So it seems a venn diagram is the wrong diagram for this job. edit: to clarify, to represent the statement 'every expression is exactly one of an lvalue, an xvalue, or a prvalue' he should have three totally disconnected circles
"any shouldnât use any dynamically allocated memory, but itâs not guaranteed by the spec." That is quite misleading. Implementations are encouraged to avoid dynamic allocations for small objects. In most implementations this means objects that are pointer sized or smaller and are nothrow move constructible. So dynamic allocation occurs quite easily when using any
Uuh, okay, thanks! :-) I assumed it should be `&lt;string&gt;` since it was supposed to be a **C++** (re-)implementation ;-)
Why is it significant? Beginner here.
There are no prvalue expressions in your example; `t1` is an lvalue, because it names an object with identity, and `move(t1)` is an xvalue, because `move` is a function that returns an rvalue-reference. So the second line is a move-construction from `t1`, not a default-construction via prvalue â that would require something like `T t2 = T{};`.
iostream.h is a very old header for i/o streams in C++. The implementation exists since before the introduction of namespaces into the language, and should probably be considered unsafe to use.
Good general reference blog in that I can get the links easily here. I was hoping for more of a how to set up a POSIX environment using Boost, Juce, MSYS2, or something so that I can work on all different platforms. Then how to use the various build tools like make or something. 
No, that is not how venn diagrams work. Lvalues and PRvalues are things _inside_ the venn diagram, _not the circles themselves_. The circles are clearly labelled as GLvalue and Rvalue. Xvalue is both a GLvalue and an Rvalue, a PR value is only an Rvalue (and not a GLvalue), and an Lvalue is only a GLvalue (not an Rvalue). It could be clearer as to which are the labels and which are the items (using the same font and colour is not helpful) but the diagram is actually correct.
&gt;Because that's not what you actually said. Instead you argued that the compiled code violates the standard It does. The static pointer should be initialized to nullptr. That's what's in the standard. It's not happening. That makes it a violation. As for code that is not called, not in fact being called, I'm not aware of that being in the standard, so maybe you are right on that count. It would make for a remarkable language feature though. &gt;Good luck with that. Corrupting memory is exactly what allows for hacking your neighbor's wifi, etc. I mean, this is how exploits work. Yes, but it isn't the _compiler_ that should be introducing the exploits or the weirdness! The UB should happen at runtime, not at compile time. UB was always a way of saying "at this point anything could happen, because we just don't know what will happen if you make a wild jump into the unknown. Maybe the application will crash. Maybe you will accidentally hit the OS function for formatting harddisks. Who knows? The compiler has no way to predict what will happen if you make the jump, so... good luck." The situation here is completely different: the compiler has proven through analysis that UB exists, so it has already cleared the first, very significant, hurdle: it _knows_ something is wrong! (this is one of the fundamental issues about UB: it was originally assumed to be undetectable at compile time to begin with). At this point it could choose to issue a diagnostic. That's not actually required by the standard, but I don't believe it is forbidden either. The reason the standard doesn't require it, is because analysis of this situation was generally believed impossible in the first place - but hey, we did just analyze it, didn't we? So why not simply issue an error and stop compilation? So, as a first step towards fixing UB, I'd propose this: "if the compiler manages to prove the existence of UB, it should issue a mandatory diagnostic." 
I'm quoting the article.
I wouldn't be surprised if it is, given the amount of work being put into C++ compilers vs C compilers.
Now I'm even more confused.
&gt;What do you mean, "is about to"? Don't pretend compilers always behaved like this. I've been programming since 1985, and C++ since roughly 1998. If you had an overflow, you would get a two's complement overflow on virtually every architecture on the face of the planet. The notion that if the compiler can prove the existence of UB, it can change the generated code to be something other than an add, really is new. And you know what? I'm not even bothered by the compiler actually doing this. What I'm really bothered by is that it happens without a diagnostic. There is a huge difference between "oopsie, the code that is normally always fine will not work out for you in this case" (UB in the original sense, where the compiler simply did its default thing, unaware something bad would happen), and "hah! I see your UB and I will take this as an excuse to do something unexpected!" (UB in the new sense, where the compiler knows full well something bad will happen and uses it as an excuse to emit different code, but not a diagnostic). 
edit: I see what you mean - were the 'glvalue' and 'rvalue' in there 7 hours ago? if so, many apologies!
Presuambly he still needs the definitions from `string.h`, so `cstring` is right. The rule for C++ is that any C library of the form `xxx.h` is also available in `namespace std` using the header `cxxx`. So for example, `stdint.h` introduces `::int32_t` and `cstdint` introduces `::std::int32_t` (along with many others) Often, one header will introduce both the scoped and global versions, but that's technically not portable.
It probably means that the material is using Turbo C++ or another similar compiler of the same vintage (early 90s) which existed before the language had been standardized. The header was renamed to `&lt;iostream&gt;` as part of that standardization. Any examples written for those ancient tools will not work with modern, standards-complaint tools. Believe it or not there are still places in the world where Turbo C++ is taught in 2017. It's completely reprehensible.
Get CLion, configure it to autocomplete `ca` to `const auto`.
Currently the parser doesn't parse the type - only the names of the fields. To get the type one might generate code that uses ```decltype(field_name)``` to get the actual type and thus reparsing wouldn't be necessary when a typedef declared far far away in a separate header changes - nothing will break. Also given how common CMake is nowadays and that most projects have some scripting along with their build systems I'd assume that Python/JavaScript/Ruby/etc. is available in the environment (and the parser can be written in any language) - so for users who want as few dependencies as possible - utilizing what they are already using seems like the simplest solution. Also I might concider using this approach even if C++ got native support for reflection for the following reasons: - compile times: with my approach parsing and codegen are done for a source (or header) file only when it is changed - and not when a different file included by our current file is changed. Also compilers are getting increasingly more complicated - no wonder C++ code compiles so much slower than C code... Compile time reflection will have some cost. - unlimited control 
Go read the article?
&gt;This function invokes UB. Err, no, it doesn't! It might invoke UB at runtime _for specific arguments_. It is the overflow that is UB, not the addition. 
Where in the article are you quoting from?
&gt; Don't pretend compilers always behaved like this. I've been programming since 1985, and C++ since roughly 1998. If you had an overflow, you would get a two's complement overflow on virtually every architecture on the face of the planet. 1. I don't think that was actually 100% true in the presence of constant folding and other optimizations. However, we're not talking about what a particular compiler does on a particular architecture. As far as the language itself (as defined by the standard) is concerned, signed integer overflow has always had undefined behavior. 2. More importantly, I remember writing a simple loop that overflowed a signed integer. It behaved differently when compiled with optimization (IIRC it terminated with `-O0` and ran forever with `-O2`). That was at least 10, maybe 15 years ago. What I'm saying is that this change (if it is one) is in the past, not the (near) future (as "is about to" would imply).
We have a very specific case here: we have an invalid pointer dereference, but we already proved its existence at compile time. This specific case we can trivially define a behaviour for: forbid code generation. If the compiler can prove that UB will occur at runtime, why generate code at all? Note that this is not the same as demanding that all invalid pointer dereferences be found. But _if_ one is found at compile time, why is there no diagnostic?
Posting 4 later
They were there by the time I replied to your original comment... 7 hours ago :)
Cool, thanks for elaborating on that!
void_t perfectly describes what it does - it's an alias for the type 'void', that just happens to swallow up any template parameters you pass to it. It's _used_ for the detection idiom's implementation of validation/detection, but this is honestly something of its time - there are better, simpler ways to achieve expression validation (see hana::is_valid).
&gt; run time 0.01s 0.005s 0.004s
std::variadic\_version\_of\_[boost::enable_if_has_type&lt;&gt;::type](https://github.com/boostorg/core/blob/815625904311e29fe3fb83f0ef3f012a4a94572f/include/boost/core/enable_if.hpp#L26-L30)\_that\_always\_returns\_void
There's now also std::experimental::is_detected http://en.cppreference.com/w/cpp/experimental/is_detected
I see your point but I totally disagree, things should be named for what they do, not how they are implemented... (so IDK why the fact it is an alias for void matters). But you may be right since only usage of void_t I know of is detection idiom, so maybe void_t is more generic in usage than that. BTW hana::is_valid looks nice, but unfortunately due to language decltypes hurts readability a lot... I wonder if using C++17's deducing constructors this could be hacked around... But that is out of my level... 
that's exactly what I was referring to - but experimental::is_detected is pretty crappy honestly. There are better ways of doing it (see below).
embarrasing
but what it does is alias 'void'?
Yeah. That's what I meant. I elaborated it in the further comments.
here's a quick example that demonstrates how is_detected and is_detected_v could be implemented without all the partial specialisation complexity (example code stolen from cppreference). https://godbolt.org/g/x9bQEn is_detected_or and is_detected_exact can be implemented similarly.
Ok, to use another example: std::move does not move anything, it is a cast, but rvr_cast would be harder to understand for people... 
I don't agree with that - there's plenty of threads, talks and topics regarding what std::move actually does specifically because it's not self-explanatory. rvr_cast would have been a lot easier to understand.
&gt; If the compiler can prove that UB will occur at runtime, why generate code at all? Because the compiler can't know that `NeverCalled` is not called from elsewhere. Situations like uninitialized variables are relatively easy to prove, and compilers do forbid compilation. There's no valid path for this code: int main() { int a; return a; } Clang gives: $ clang++ -std=c++1z -Wall -Wextra -Werror a.cpp a.cpp:5:10: error: variable 'a' is uninitialized when used here [-Werror,-Wuninitialized] return a; ^ a.cpp:4:8: note: initialize the variable 'a' to silence this warning int a; ^ = 0 1 error generated. However, there **is** one possible, valid path for the code presented in this thread, which is `NeverCalled` being called from outside. And Clang optimizes the code for that path.
I agree that we do not agree. :) And although I think I am right, it is possible that you and I both assume all developers think like we do while the split may be more like 10% developers think like me, 90% like you so that is why I think std::move "is better for everybody!!!! OBVIOUSLY!!!" Anyway thank you for examples and discussion.
Well that is actually quite interesting, I did not know about this. It reminds me once I was thinking about something related to C++ &lt; &gt;, =, != and how you can create some operators from others, and couple of weeks later I realize it was done long long time ago... (std::rel_ops)
Because C++ didn't have namespaces back then iirc
It's been talked here before, and I will bring it back: the optimization happened in the optimize stage. There's no easy way to report it back to the frontend once you've gone through other optimizations (you lose information about original code). Diagnosing something like what LLVM does is simply impossible currently.
Wow! That's a big library. Any suggestions on where to start? For context, I'm a long time Pythonista who's going back to school for CS I'm taking the intro comp sci course for c++, but I've already picked up enough c++ syntax for the class. I'm interested in what is unique about c++ and maybe even interested in making wrappers for python. My ideal career path is statistical analysis without having to use R.
The argument falls short in cases when std::move leads to copying instead of moving - https://stackoverflow.com/questions/27810535/why-does-calling-stdmove-on-a-const-object-call-the-copy-constructor-when-pass
Right, and which of those numbers is the lowest? (Protip: It's the C one) Even if the C++ one did run faster it's pretty silly to extrapolate that out to the statement 'C++ is faster than C'. Here is an actual quote from the article: &gt; **Converting an existing C program into C++ can yield programs that are as fast**, have fewer dependencies and consume less memory. 
This: template&lt;class T&gt; T* laundry_pod( void* here ){ static_assert( std::is_pod&lt;T&gt;{} ); char op_away[sizeof(T)]; memcpy(op_away, here, sizeof(T)); T* r =::new(here) T; memcpy( here, op_away, sizeof(T)); return r; } standards compliant and optimizes to noop at runtime. A hostile compiler can turn a+b into a for loop solving fermat's last theorem. Assuming compiler hostility is not a good plan. Maybe something like the above needs to be added to the standard for the truly paranoid. But saying we should do undefined behaviour because we fear future compilers will suck at optimizing seems like shooting off your face to spite your pimple.
Problem is templates, maybe. I guess. My first instinct is to just static_assert(assuming type system can do that) on passing const to std::move, but maybe ISO ppl decided that for templates they do want to use fallback on copy. Again this is not my expertise, I really dont know why they did it, I just assume that sometimes in some template code something can get deduced to be const T or const T&amp; and they did not want to stop that code from compiling... 
&gt; At this point it could choose to issue a diagnostic. Eh, it can't. Read this specific [blogpost](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html) for why it can't. TL;DR: &gt; If the frontend has challenges producing good warnings, perhaps we can generate them from the optimizer instead! The biggest problem with producing a useful warning here is one of data tracking. A compiler optimizer includes dozens of optimization passes that each change the code as it comes through to canonicalize it or (hopefully) make it run faster. &gt; &gt; For warnings, this means that in order to relay back the issue to the users code, the warning would have to reconstruct exactly how the compiler got the intermediate code it is working on. We'd need the ability to say something like: &gt; &gt; &gt; warning: after 3 levels of inlining (potentially across files with Link Time Optimization), some common subexpression elimination, after hoisting this thing out of a loop and proving that these 13 pointers don't alias, we found a case where you're doing something undefined. This could either be because there is a bug in your code, or because you have macros and inlining and the invalid code is dynamically unreachable but we can't prove that it is dead. &gt; &gt; &gt; Unfortunately, we simply don't have the internal tracking infrastructure to produce this, and even if we did, the compiler doesn't have a user interface good enough to express this to the programmer. 
you can't 'move' a const object because it's const - you'd invalidate the const-ness if you were to move from it. std::move is essentially static_cast&lt;T&amp;&amp;&gt;, there's really no magic happening here.
C++ is great for when you need to do some higher-abstraction heavy lifting but need access to the lower-level details for performance. For math-heavy systems, you'll either need to learn how to use the vector instruction / macro thingies, or use some library like Eigen that takes care of all that madness for you under the hood. Probably the biggest difference to modern higher-level languages you'll run into is that in C++ you can instantiate classes and whatnot directly on the stack / inside collections instead of dynamically allocating them and accessing them via references / pointers. This can lead to huge speed benefits when used correctly.
What I wanted to say is not that they allow moving from const objects, but that they fallback to copy instead of giving hard compile error. And my assumption for why ISO did it like that is that they probably did not want to limit template code(in cases when deduction gives that type of something is const something) . Obviously you should ask STL or Hinnant if you care. I do not care enough to bother them for this kind of trivia.
it doesn't fail to compile - it uses the copy constructor instead. The source above fails because the copy-constructor is deleted.
Saw the title and thought "better than acherno's?" I guess I have different ideas about what counts as a small number of subscribers. 
Bo Qian's channel (https://www.youtube.com/user/BoQianTheProgrammer) also has some great C++ videos. 29k subscribers.
And I didn't know about std::rel_ops. Thanks for sharing it.
Redid the colo[u]r choice. Better?
There is also [`magic_get`](https://github.com/apolukhin/magic_get) which does some very limited reflection, but without macros or extenal tooling and non-intrusively. Upd: apparently you are already familiar with magic_get, and even filed [an issue](https://github.com/apolukhin/magic_get/issues/10). 
Exactly. Question is why: "but that they fallback to copy instead of giving hard compile error" My instinct is that std::move should just static_assert when you when you call it with const. And I am speculating why they fallback on copy. My guess was that they did not want to disable a lot of template code where things get deduced to be const. 
&gt; it looks like a very bad C conversion That's probably because that is exactly what it is. :) I could have spent ages polishing and fixing and styleifying the code but for the purposes of these measurements it would have been pointless. It also does not use string_view or the like because I had an older compiler that did not support it and so on. If someone wants to make it super duper up to date and then do the measurements again, go for it, the source is there.
I didn't mention it in the post because it's reflective capabilities are too limited, and it's mentioned in the posts (linked at the top) by jackie, but its an interesting project nonetheless!
This is a lot like the "Charlie X" episode of Star Trek (TOS) where the kid with the mental powers lets a starship be destroyed because, instead of reporting a broken part, he just eliminated it altogether. Nobody was particularly happy with that. I appreciate the problem is hard. I'm sure, however, that eventually it can be solved: either by moving the diagnostic stage forward to the front-end, or by having some kind of reporting mechanism in the optimizer. I've also been told that I should not mistake specific implementations for the language standard; surely that applies here as well. 
Not that easily, it is really about losing entropy because it would require a lot of computational resources to keep track of every optimization path, what the code was before it and after, just to report a bunch of transformations in an specific order led to UB from one source line. That's impractical, and I presume we won't see this solved any time soon.
&gt; Since the parameter type isn't exactly T&amp;&amp; it isn't a forwarding reference See [CWG 1700](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1700). `type_t&lt;T&gt;&amp;&amp;` *is* `T&amp;&amp;`, so this is still a forwarding reference. gcc has always considered it as one, and clang trunk now does too.
Much!
It's been fixed now, much clearer :)
I think it's okay, I would've prefered void_type to fit with true_type and false_type
I really think what you're looking for is `&lt;boost/hana/type.hpp&gt;` and `&lt;boost/hana/traits.hpp&gt;`. You don't have to use the rest of Hana, which has algorithms for heterogeneous sequences, but those two headers solve exactly your problem (and no more). The only difference is that Hana uses free functions and you use methods for the type traits. Also, as a fun historical fact, I started Hana after making exactly the realization you made, which is that we can represent types as objects, and type traits become methods (or free functions, whatever). Then I realized I needed utilities to manipulate those types, which led to developing algorithms on tuples.
Roger
My opinion is that the detection idiom itself is sub-optimal given what we can do with modern C++. I'm disappointed we're exposing low-level details like `std::void_t` in the standard library, because doing so is encouraging folks to write their own SFINAE tricks based on it. IMO, better alternatives are [`hana::is_valid`](http://boostorg.github.io/hana/index.html#tutorial-introspection-is_valid), which has been mentioned already, or the utility introduced in [this paper](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0726r0.html#requires-expressions). _Edit: And yes, `void_t` is not a very descriptive name regardless._
You can also overload for lvalue refs, I asked basically the same question a while back https://stackoverflow.com/a/24232488
Great post! I'm glad they added the guaranteed copy/move elision to 17, it makes working with non-moveable types (like stuff in &lt;atomic&gt; for example) a bit nicer. Also interesting read is Stroustrup's [notes](http://www.stroustrup.com/terminology.pdf) on how they arrived at these categories and terminology.
Not the answer I was hoping for, but an informative one nonetheless. Oh well.
out of curiosity - what are your plans for taking advantage of C++17 for language fold expressions, using-declaration expansion and auto non-type template parameters? I've been putting together something that's starting to look more and more like hana (completely by coincidence - I've actually never actually used hana, just seen your talks!) but with functions designed for the manipulation of heterogeneous non-type packs - reliant entirely on 'auto'. Curious to know if you're already on the case? :)
 template&lt;class T, std::enable_if_t&lt;!std::is_lvalue_reference&lt;T&gt;::value,int&gt; = 0&gt; using non_reference_t = T; template&lt;class T&gt; void f(non_reference_t&lt;T&gt;&amp;&amp; t);
&gt; what are your plans for taking advantage of C++17 for language fold expressions, using-declaration expansion and auto non-type template parameters These are all nice improvements, but I don't think they (alone) change the realm of what's possible significantly enough to warrant dropping support for C++14. However, at some point, I'll make a major version bump in Hana and I'll probably make it an occasion to go to whatever standard is current. I'll be able to use constexpr lambdas and `if constexpr` to massively simplify large chunks of Hana, which is the biggest benefit IMO. Regarding auto template parameters, I've thought about having something like template &lt;auto Value&gt; struct constant { }; be some sort of generalized `integral_constant`. Then you could store that in a tuple and you can manipulate them using algorithms like any other sequence in Hana. There's no concrete work going on, though.
Will do, thank you.
oh definitely not - my library is very much a bit of hobbyist work, so using every single feature the language offers me is just so I can familiarise myself with them. I'm even using your C++2a explicit template lambdas here and there. That's similar to what I'm doing right now - I've been toying with the idea of template &lt;auto... Vs&gt; struct value_list {}; also - to make it easier to make use of the values directly, without having to pick them out of an integral constant type or have them convert via operator T(). It's all still a work in progress though.
I would not have expected that to work, but apparently it does. That is actually really cool.
&gt; external tooling (such as libClang - see siplasplas and CPP-Reflection): External tooling is listed as a negative, but this CMake-based solution is exactly that: an external tool. &gt; annotating fields in a custom way is not straightforward What's not straightforward about this? Attributes should be sufficient if you were using a libclang-based tool. If this works for you, that's great, but it just seems a little unorthodox. I wouldn't expect a project generator tool to also handle generation of class metadata. If I were building a game engine from scratch, I would probably just go with a libclang-based tool. I might even consider using an IDL and custom parser that generates headers if it's geared primarily towards serialization of actor/entity data. With an IDL, you at least have full control of the data layout and don't need to worry about having a tool that can parse C++.
I checked him out for the first time in like a like a year yesterday. I clicked on his latest video and it looked pretty cringy tbh
That C automatically inheirets? I mean who even uses a C-only compiler these days? Clang,MS,gcc are all C++ compilers that support C as well, but are primarily C++ compilers...
&gt; - The first alternative must always be default constructible &gt; - [...] &gt; - If the first alternative type is not default constructible, then the variant must use `std::monostate` as the first alternative This is complete nonsense. 
I am wondering why you felt the need to post this here.
I found the article needs more examples. Other than 'c++ 17 doesn't require a definition for an unused move constructor', the rest of the article did not add anything but confusion. Need more clarity as to what an expression related value type is with more practical examples of when and why these things matter.
Because defects in the software is being ignored despite being reported.
A `const T&amp;&amp;` isn't a forwarding reference. You can then use a helper function and expression SFINAE, which you may find preferable. See https://stackoverflow.com/a/45515048
They don't support submodules *out of the box*. You can still write your port to take care of obtaining the submodules, unless I'm mistaken 
I've found that expression SFINAE covers almost all the cases that I would use the detection idiom, and that the code is more readable / easier to verify. Techniques like those from Hana or `if constexpr` cover basically all the other cases. However, I still use the detection idiom because Visual C++ still doesn't properly support expression SFINAE and thus Hana; I find it the most readable alternative to the missing features
I think /u/roschuma posted a plenty fine explanation of what's going on in your bug.
&gt;But it helps reading code and learning. The names unique_ptr and shared_ptr can already give you some idea of what it could mean (the words "unique" and "shared" are normal English words). More importantly a beginner can immediately distinguish the two. Beginners are frankly unimportant. C++ is a language that requires deep learning and understanding. You need a lot of experience to be adequate at writing C++. Making the language worse under the **false** assumption that it will help beginners is a stupid idea. &gt;I know so many beginners that learn about pointers and then for weeks and months they just do more or less trial and error by putting &amp; and * in front of stuff until it compiles (I'm exaggerating a bit but that's the gist of it). You aren't exaggerating at all. That's got nothing to do with using a symbol. It's just their lack of understanding of pointers. And symbols as term operators have nothing to do with symbols as type operators.
When you import something from the C++ standard library, most if not all of the time the import does not end with a `.h` If you see a `.h` you are most likely importing a local file **or** a file from the C standard library. The C standard library can be a *pain* sometimes =_=
&gt;Let me try again. Semantically, a metaprogram that operates on attributes does not change the meaning of a program because it's a part of the program. The program has only one meaning. The same is true of any metaprogramming technique that you use today to inspect or generate code. Not relevant. The presence or absence of an attribute should not alter the semantics of a programme. That is the requirement, and that's an important requirement. &gt;I'm not going to prejudge a language feature simply because Java and C# abused it. Java and C# didn't abuse it. They have it. The developers that use Java and C# simply used it. The thing is, *any use of the feature is an abuse*. We have metaprogramming tools in C++ already.
Sorry but I'm not going to install `boost` or use any of the hideously over-complicated boost TMP libraries like Hana just to do some simple SFINAE.
I don't understand your point.
Yeah, it's cool to read this stuff. Naming is really hard, and I don't envy the people the job of coming up with these names. In retrospect, what I find most confusing about the names is the complete lack of symmetry. lvalue and rvalue are at different levels of taxonomy, glvalue and prvalue are the two-letter ones and are also at different levels of taxonomy. If I could go back in time, I would've suggested either: * rename glvalue to lvalue and lvalue to plvalue. This gives you symmetry in lvalue/rvalue and plvalue/prvalue, but breaks the lvalue and rvalue are disjoint rule. * rename rvalue to grvalue and prvalue to rvalue. This gives you symmetry in glvalue/grvalue and lvalue/rvalue, but breaks the everything is either an lvalue or rvalue rule. As-is, we have have sort of but not really related names. But really the names don't ultimately matter anyway - as long as we have the concepts right, and I think with the large improvements in C++11 and C++17, we do. At least, until the next improvement!
 struct is_valid_t { template &lt;typename F&gt; constexpr auto operator()(F&amp;&amp;) const; template &lt;typename F, typename ...Args&gt; constexpr auto operator()(F&amp;&amp;, Args&amp;&amp;...) const; }; constexpr is_valid_t is_valid{}; namespace type_detail { template &lt;typename F, typename ...Args, typename = decltype( std::declval&lt;F&amp;&amp;&gt;()(std::declval&lt;Args&amp;&amp;&gt;()...) )&gt; constexpr auto is_valid_impl(int) { return hana::true_c; } template &lt;typename F, typename ...Args&gt; constexpr auto is_valid_impl(...) { return hana::false_c; } template &lt;typename F&gt; struct is_valid_fun { template &lt;typename ...Args&gt; constexpr auto operator()(Args&amp;&amp; ...) const { return is_valid_impl&lt;F, Args&amp;&amp;...&gt;(int{}); } }; } template &lt;typename F&gt; constexpr auto is_valid_t::operator()(F&amp;&amp;) const { return type_detail::is_valid_fun&lt;F&amp;&amp;&gt;{}; } template &lt;typename F, typename ...Args&gt; constexpr auto is_valid_t::operator()(F&amp;&amp;, Args&amp;&amp; ...) const { return type_detail::is_valid_impl&lt;F&amp;&amp;, Args&amp;&amp;...&gt;(int{}); } _**Hideously**_ over-complicated! ^/s
Depends on how strong of a programmer you are, I suppose. C++ can be fairly challenging, but also the things people tend to use C++ for are usually a bit more complicated too. But if you know your stuff I don't think it should matter if you have a degree or not. I think focusing on problem domains rather than specific languages is probably the way to go though. You want to use the right tool for the job and not a a specific tool for the sake of using that tool.
!removehelp
I'm a college drop out, so I'd say yes.
That wouldn't make line up with other elements of the standard library, since `std::true_type` is a struct with a member type `std::true_type::type` (and a static member value). `void_t` is an alias for an elementary type, just like the other `_t` typedefs are at least on some occations. `std::enable_if_t`, `std::underlying_type_t`, etc. `_type` types are structs with member types.
C++ is more used to special purposes these days. You will almost certainly **not** find it used in web dev unless you're working on some seriously funky shit. C++ is often used for performance reasons, and if you're developing lower level code (drivers, database system, kernel modules, trading software, etc). Because of that, the people who work on those systems tend to have a much stronger requirement to know proper computer science, because they're the people actually implementing the lowest levels of the software. So, C++ and a not having a degree is probably a bad mix unless you're a very experienced and skilled developer. If you want to get into web dev, start with Python, C#, Java, Ruby or Javascript. They are all much more relevant to web development, and much more general purpose.
It seems auto-mod is on vacation today.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
As dodheim puts it nicely, the actual code for `is_valid`in Hana is very simple, and can even be simplified to [the following](https://wandbox.org/permlink/bD7uYWy3DRRbw3pU): template &lt;typename F, typename ...Args, typename = decltype( std::declval&lt;F&amp;&amp;&gt;()(std::declval&lt;Args&amp;&amp;&gt;()...) )&gt; constexpr std::true_type is_valid_impl(int); template &lt;typename F, typename ...Args&gt; constexpr std::false_type is_valid_impl(...); template &lt;typename F&gt; constexpr auto is_valid(F&amp;&amp;) { return [](auto&amp;&amp; ...args) { return decltype(is_valid_impl&lt;F&amp;&amp;, decltype(args)&amp;&amp;...&gt;(int{})){}; }; } I'm not advocating for the use of `hana::is_valid` specifically, but for the technique it uses. Also, I'm sorry for you that you're feeling that way about Boost, since you're missing out on several great libraries. 
The potential audience is quite small though. C++ isn't the most popular language lately and I would say the amount of learners are diminishing in favor of the web technologies, scripting languages that are decently fast for most purposes (like python), and garbage collected bytecode languages (C# and Java).
&gt; I didn't say invalid pointer dereferencing in general. I said dereferencing a nullptr. The compiler doesn't know the difference, because there is none.
I think hana is cool, and probably useful for people who are better lib devs than me but I think you may understimate the usefulness of detection idiom for "newbies" (like you say in your talks). I just use it a extremely verbose way to check if something compiles. And it is in std:: so I do not need to use HANA dependency(we can discuss if my fear of adding libraries to a project is justified some other day). Also although % of devs speaking void_t is miniscule it is still much more than % of devs speaking requires library version. @paper - wow, concepts are really trainwreck ;) This is half joking since again IDK enough for my opinion to be valuable, but TBH for 10y I am pissed that C++ did not go the Haskell way(IDK Haskell, but I know when you write something compiler deduces type classes/concepts (if you uses multiplication it figures out it is a number, etc)) And now it appears that agile constexpr destroys waterfail concepts... If only somebody proposed even more powerful constexpr if 5+ years ago and if only somebody did not write "even more powerful constexpr considered" paper because it was competition to his pet project... Obviously concepts will be pushed through because political reasons... but that paper is really nice. https://www.reddit.com/r/cpp/comments/6sdjkr/c_standards_committee_papers_201707_posttoronto/dlc8fkf/ P.S. u/andralex you were right about concepts after all... I should have never doubted you. :) I will click on all sociomantic ads as penance ;) 
Thanks!
Ta!
Unfortunately, there doesn't seem to be a lot of modern C++ in his videos, and while he's aware of it, he's just discarding C++11/14 features for later videos, which may not happen. I consider them to be fundamental and important now, absolutely needed to be talked about. For example, he talks about enum classes, while mentioning enum classes briefly, saying that the video about them will be done some day. But why not start with them, as they're the superior alternative to old enums? Why not teach beginners good things at the start? In his object construction videos, there's not a word of uniform initialization, which can make lives of beginners much easier. And there are lots of other examples of such things which can be pointed out. The tutorials would have been good for C++03, but remembering that we already have C++11 for 6 years and this being "the best of C++ tutorials" makes me sad. 
I've not once seen evidence that these kinds of optimizations (UB as opposed to unspecified) would have any meaningful effect in real world application performance.
Can you look also at my compile-time reflection [ideal-couscous](https://github.com/maxis11/ideal-couscous). It's uses macroses, but provides greater reflective capabilities than magic_get
You're conflating C standard meaning of "undefined behaviour" ("rm -rf is a valid option") and "unspecified behaviour" (the compiler doesn't have to document what it does, but can't assume such behaviour doesn't happen). Unspecified would mean that referencing null does something, but makes no guarantees about the result (random value, program crash etc).
The compiler doesn't have to know the difference. It can - and should - generate the code as if the pointer pointed somewhere. What it shouldn't do is to reason that such dereferencing never happens.
I believe [this tutorial series is much better](https://www.youtube.com/watch?v=nFM0SuPSxnc&amp;list=PLfthkO_8dYCqARBKnZQm6Ck614Td9Vmz7), albeit in German only. At the beginning, it explains simple concepts as well, but then moves quickly to more modern C++ and give lots of hints about how to use the STL.
Can you explain how the second and third lines of code work?
a single = is assignment dual == is comparison The first if will assign x = 1 and then evaluate it as true.
&gt;Wouldn't that ruin the point of using if? Yes, it's a good example of a typical mistake. Also: https://en.wikipedia.org/wiki/Yoda_conditions
No, the if assigns x=1 which evaluates to true. It is a common mistake and most compilers have a flag to warn about this.
The if line should give a warning. If not,crank up warning level or change the compiler. The line is also bad code because it does too much,first it does the assignment and then the comparison.
Have you pitched `hana::is_valid` to the committee? Would it be welcomed so that lower-level stuff like `void_t` might be deprecated?
Not at all - I use this all the time, in this idiom. if (auto fp = getFilePointer()) { // Do something. } else { // Report an issue. } The big advantage to that pattern is that the `fp` variable's scope is extremely limited, so you can't accidentally use it somewhere that it is empty.
https://www.youtube.com/watch?v=XBC0vDO4yCk 
A second possible mistake is the following: if (something) do_something(); else do_something_else(); do_another_thing(); do_another_thing gets executed even if something evaluates to true, sonce do_another_thing does not belong to the else clause. The else clause only needs one statement, if you want multiple statements, use brackets. cout &lt;&lt; "****"; isn't indentated correctly.
Yoda conditions back in the 80s I used to use. Hard to read they are, annoying to coworkers it was, but avoided problems at the time I did. Now compilers can catch an assignment in an `if` statement every time and warn you. I haven't written a Yoda condition in a decade or more. Turn up your compiler warnings as high as they can go. You'll be thankful that you did.
Let the -Wall flow through you.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6y6lx9/shouldnt_the_output_be_not_equal/dml3ama/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Which may generate warnings by compilers. Of course, this gets a nod in C++17: if (auto fp = getFilePointer(); fp != nullptr) { // ... }
Clearly, in the same vein as RAII and SFINAE, this should be shortened to std::vvobeihtt, implementing the famous VVOBEIHTT idiom.
Many new languages are hosted in LLVM. Could that be another reason why LLVM contributors keep increasing? 
First 5 and 8 - because thats a post increment, so it's returns the value of A and then adds one to it Second 11 and 9 - because the B-2 in the previous statement doesn't take affect on the variable B, it just returns 8 and disregards it after printing it. Also because it's a prefix increments it takes affect on B before printing it.