&gt; And what happens when you link two libraries both of whom specialized std::hash&lt;std::tuple&lt;Ts...&gt;&gt; differently? the same thing that happens when you link two libraries both of whom have a function named `debug` ? &gt; Second, it could break extensions. When we have an incomplete type for a standard template like hash, compilers are free to add their own additional specializations without breaking the standard and all standard-compliant code will still cross-platform compile. that's not what I am arguing about. Of course you will get errors if you do dumb things, but these errors are entirely predictable while the current standard mandates UB. &gt; You can have your own hasher which I then have to add as an additional template argument to every use. How do you explain to beginners that : std::unordered_set&lt;std::tuple&lt;foo, int&gt;&gt; is ok, but not std::unordered_set&lt;std::tuple&lt;int, int&gt;&gt; ? even worse, what do you do if you want to have a library which provides some generic code : template&lt;typename T&gt; void my_api(const T&amp; t) { // let's use a hash map to speed up some operations thread_local std::unordered_map&lt;T, int&gt; map; } if I am an user of this API and my T only uses std types, there's nothing I can do - except fork it, if I have the rights to it! &gt; Or, fancier, have notstd::unordered_map be std::unordered_map with default hashing on primitive types and the like, and replace the hasher with the smart hasher on other types. how is it even possible to consider that this is an acceptable solution is beyond me. This entirely breaks the consistency of a codebase.
It would consistently used notstd::unordered_map. And an internal hash map requires the arguments be hashable. A smart hasher can pick up on hash extension points found via ADL and on std specializations. Noone should use an unordered map in generic code without exposing hash customization. Every customization argument you made boils down to "but I want to do it in std". Which seems to be a very weak argument. I think existing means of specializing templates in std should be depricated. Stay out. Use a different method to add customization points. 
If we are going to use the specific task argument then you can easily argue that most VS users out there are not even going to use C++. No, we need to be realistic about this. You need to put some **useful** features for each "segment" of the market (C++, C#, VB.NET, JS, etc.) in the commercial edition to get a decent sum of money. You just can't charge only for the obscure features.Now that's not new. Intellij IDEA has to do the same thing by not supporting for example deployment to application servers and that's something that's basically a must for enterprise development that is basically what Java is all about.
It is a great talk, which has definitely again inspired modifications to the way I will mentor future junior engineers. Kate's talks are always very good at providing guidance that is need to help with just this difficult subject. I think her talk on teaching the library and how to do it by going at it using STL types from the beginning and the Core guideline one have entirely shaped how I approach basic C++ mentoring at work. This talk was the most software design oriented one I had seen so far and again has given me ideas although it is more difficult to follow. Simplicity as she says takes time and much like with optimization you are not often given enough time to achieve it.
I think it's an interesting idea.
Guess a lot of developers know this already, but in case you've never seen any of Kate's talk before: this is way more than just "how to write c++ code". This should be a general philosophy that all Senior developers teach Juniors. It's to large degree universal. This talk is nothing new or not much new if you've been in the industry for long enough to have good habits. But these habits came from lots of wasted hours, lack of sleep, tears of frustration and helplessness. And she delivers all these lessons in a nice package.
My team lead asked me to work on refactoring the code with modern features. I understand how to read documentation and implement after playing around. I implemented and refactored, passed all the unit tests, and that was it. I going think there's a time requirement for using new found knowledge in your work.
Now, someone just needs to benchmark \[this\]([https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/](https://probablydance.com/2018/05/28/a-new-fast-hash-table-in-response-to-googles-new-fast-hash-table/)) against the official Google implementation of Swiss Tables.
In previous tests, and on other platforms, qsort() and a quicksort template were much closer in performance. But, some platforms don't appear to compile their standard libraries with the optimizer turned on :-) .
is that better than intellij ? just curious ?
It's specific to C and C++. As with all the jet brains IDEs it uses intellij at its core, but is customized for C and C++. I actually use it for rust because the rust plugin can do visual debugging, which it can't do in intellij.
There's just no way it would be perfect right away, if it was that easy it'd have been around for much longer.
Yeah, I think he's saying you should unit test in C++. He takes a long time to say that. Seems like most projects in any language will find any excuse not to test. Or maybe not even make excuses and just not test. I usually do my tests with cppunit and have been working on integrating those with cmake. Between the two of them, it's a halfway decent test system. cppunit's a lot better with a custom test listener that you can use to report on all the tests at the end of the test run, though. I suppose I should write one as an open source project one of these days...
VSCode and C/C++ extension and CMake is what I need on macOS, Xcode makes me think about "iOS app" :) &amp;#x200B; Hopefully VSCode has an extension/tool to detect memory leak soon.
&gt; But, some platforms don't appear to compile their standard libraries with the optimizer turned on :-) . With MSVC you can actually fix that! The actual libraries can be compiled as you need them with the level of debugging you need it to be! The path on windows to the qsort file is... C:\Program Files (x86)\Windows Kits\10\Source\10.0.17134.0\ucrt\stdlib\qsort.cpp And if you notice, you'll see the extension is .cpp! That's right, the entire C standard library for Windows is *Written in c++*. And even further, the qsort file *ALWAYS HAS OPTIMIZATIONS ON!* It's just that it also is (partially) timsort, so with less than 8 elements it actually uses (I think, I can't seem to find it) just a regular old naive sorting method, probably insertion sort.
I guess there was much bike shedding about this.
Too late for that unfortunately...
I still prefer Xcode's debugger. By far the best debugger interface in my opinion.
They can, that's called speculative devirtualization.
my manager did. it is important to be told this. specially new guys without experience they can feel pretty desperate during the first weeks when they are totally lost. 
 \*\*Company:\*\* [Document Modelling](https://www.documentmodelling.com) for our flagship product: [Prose](https://tryprose.com) \*\*Type:\*\* Full-time \*\*Description:\*\* We're looking for a talented C++/Qt developer to work for our exciting startup developing a next generation product! Our ideal dev is able to think independently, is highly technical, has an intimate knowledge of C++, and has extensive experience developing user interfaces using Qt. Our ideal dev also comes with a good sense of humour, excellent communication skills, and a healthy dose of enthusiasm. Your skills will be put to work creating a next generation product that is poised to transform an industry. The work we are doing is highly technical, and is increasingly using more and more forefront technology (WASM, ML etc). We have dev staff in the UK, Germany, &amp; Australia - We are truly a distributed development team. Our main product, Prose (tryprose.com), is essentially an IDE for drafting contracts. We pride ourselves on developing technology that is cutting edge and has the potential to impact not only the legal industry but any field which requires highly structural documents. Word Processing software is great, but what's next? Prose. \*\*Location:\*\* Office is in Canberra, Australia, but we also have devs in Munich and Cambridge. Ideally we'd like someone in one of those locations but working remotely would be possible for the right candidate. \*\*Remote:\*\* Yes \*\*Visa Sponsorship:\*\* No \*\*Technologies:\*\* C++17, Windows, Qt \*\*Contact:\*\* Email Simon at simon.gemmell@documentmodelling.com
The document spells it out pretty clearly. You mark up your code with the appropriate C++ attributes and it all just works. The only magic types the project knows about are those coded in for back-compat reasons with stdlibs that haven't been marked up; new code would be expected to use the attributes.
Thanks!
Me, no. I'm not in management. But when I started my manager told me more or less that, although with more detail about expectations as you ramp up. That said, it's a really big company and both expectations and transparency probably vary by team.
Based on what I’ve tried out so far...not much aside from the new dark theme. I will admit, when I did use Xcode for C++, I only did so for small school assignments instead of larger projects like I am doing now. I’ve also learned a lot more since then as I’ve become familiar with other building tools, CLI tools and other editors and IDEs.
On ska::flat_hash_map, have a look at [this micro-benchmark](https://attractivechaos.wordpress.com/2018/01/13/revisiting-hash-table-performance/). It is not that impressive. When I have time, I will add absl::flat_hash_map to the figure.
One thing which is nice about the Abseil tables in particular is absl::Hash. It will create arbitrary hash functions for you which have strong mixing properties. A bad hash function will ruin the performance of any hash table and SwissTable makes it hard to do that.
zero context...
From the wording in the title and on the slide, I have this bad feeling that it's his retirement from C++. I hope that's 100% wrong.
He's not retiring, it was about thanking his mentors.
Thank the lord. I can wait forever for that day to come.
Check the [documentation](https://github.com/abseil/abseil-cpp/blob/48cd2c3f351ff188bc85684b84a91b6e6d17d896/absl/container/flat_hash_map.h#L63); references are only invalidated on a rehash.
Brevity *and* context. I like it.
For those interested, I quickly ran some benchmarks compared to my [`tsl::robin_map`](https://github.com/Tessil/robin-map) and [`tsl::hopscotch_map`](https://github.com/Tessil/hopscotch-map) based on the following [benchmark](https://tessil.github.io/2016/08/29/benchmark-hopscotch-map.html). You can for now see the raw results on [pastebin](https://pastebin.com/ujPcGAad), I'll check to run more tests to add the results to the main benchmark page later. The implementation is quite impressive, mainly for read misses due to the technique used, but is quite sensible to the chosen hash. I have to check if I can improve a bit my hopscotch hashing implementation. Since I saw the video of the CppCon talk, I wanted to try to use some part of the hash in the neighbourhood info of the hopscotch bucket instead of just 0/1. 
Oke, i probably didn't explain myself very well. The pattern i am using is a lazy cache where keys are computed if they do not exist yet in the hash table. We always return a reference to the entry from the hash table, but that results in the problem above, because in case of inserts a rehash could occur.
Hi, thanks for the feedback. Yes, thread\_local is another way to go and I was thinking about using it but instead went with this solution. I could extend the article with a version using thread\_local though. And true, it does not help you with the gdb but with threadsanitizer it's very nice as the ids match.
Yes, then you can't use flat hash map directly. I'd suggest pairing a memory pool (or stack allocator if you don't need to delete individual objects) and a flat hash map of pointers.
As far as I recall the function std::this\_thread::get\_id returns the same value as the pthread\_self function. This thread id is different than the thread/process id (gettid or syscall(SYS\_gettid)) shown by system utils such as (h)top in Linux. Personally I prefer to see the latter in the logs because I can more easily troubleshoot issues on production machines. In addition I usually give a name to every application thread (pthread\_setname\_np - for networking, for disk work, etc) which also helps me pinning problems in particular functionality/sub-system. As for the idea for 'caching/prettifying' the current thread id, it seems to me that it can be made more simple/efficient using something along the lines (excuse the printf usage :)): [https://wandbox.org/permlink/dGNb7JO4aXLb1ErB](https://wandbox.org/permlink/dGNb7JO4aXLb1ErB) [https://godbolt.org/z/cs9usE](https://godbolt.org/z/cs9usE) However, such implementation may not produce the same ids like the thread sanitizer.
Yep
I get tired, a compiler does not. Compiler implementers are doing an amazing job, why complaining when they're trying to make my life easier (and safer)?
https://stackoverflow.com/a/23899379/347508 
Well I agree with you. But one thing you haven't mentioned - MS not only gets money from people/companies who buy the commercial editions because they want the upgraded feature set. I would actually guess that this is the minority. People/companies upgrade because they *have to* upgrade when they get (or already are) bigger and exceed the terms and conditions of the Community Edition (not sure from the top of the head what they are but IIRC it was related to turnover &amp; people size).
It's pretty silly. `auto` should be used to make our code easier to read, but here...
Why not use TLS and use an actual, human readable, descriptive name plus number for the thread? constexpr has come a long way.
Wouldn't `Concept auto my_var = some_expression();` be the correct syntax?
If that compromise makes it into the standard, yes. There's no decided syntax for concept locals yet.
With that style,`auto` means “create a local variable”. With this style it's really easy to spot all variables declarations. As a bonus, they can't be uninitialized.
Well there's the `auto x = float{42.};` version if you want
Python is garbage! Give me {} OR GIVE ME DEATH!
&gt; If one doesn't know that 42. is a double ... At some point you have to assume the reader of the code has a certain level of knowledge. For me, basic knowledge of literals is important. If someone knows the difference between float and double, and the distinction is important, they should probably know 1.0 vs 1.0f.
&gt; At some point you have to assume the reader of the code has a certain level of knowledge. For me, basic knowledge of literals is important. And if they do they're not going to write `float x = 42.`, hence there is no problem in the first place.
I also dont get why he dont uses "float x = 42.f"
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9jm6mc/best_place_to_learn/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
It's braces initialization or really modern C++ from your C viewpoint :). This post is worth your reading [https://arne-mertz.de/2015/07/new-c-features-uniform-initialization-and-initializer\_list/](https://arne-mertz.de/2015/07/new-c-features-uniform-initialization-and-initializer_list/)
Thank you very much for the link. That makes perfect sense, and the fact it gets rid of the compiler thinking this is a function call MyClass c(); is great. Was totally unaware of that change.
It is known as uniform initialization syntax, and was introduced in C++11. It allows for some previously impossible things, like initializing a map. But it is also available for non-objects, so you can use it for everything, and it is less ambiguous than parens initialization, which could look like a function call or a declaration in some cases. Random blog entry about it: https://mbevin.wordpress.com/2012/11/16/uniform-initialization/
I don't understand how come the first solution provides the same IDs (indices) as those from clang sanitizers. It's call order-dependant. Maybe I'm missing something. 
Windows 10 supports a more reasonable way to do that: https://docs.microsoft.com/it-it/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setthreaddescription.
Well all C code is valid C++ code so if you know which features are not available then you can try. But be aware, that there are A LOT of features in C++ that aren't in C. You need a different mindset if you want to program in C and I don't know if you can get that without regularly programming in the language itself.
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9jmw4b/c_to_c/e6smv5j/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Was asking myself the very same question. IMO, it doesn’t.
 #define private public don't ever do this
Also just to throw in, I absolutely hate to see the closures and job loss that you described and I hope you land on your feet with a great company.
Absolutely don't do this. Formally speaking, this is undefined behavior. Refer to 17.6.4.3.1 &gt; A translation unit shall not #define or #undef names lexically identical to keywords, to the identifiers listed in Table 3, or to the attribute-tokens described in 7.6. Since `private' is a keyword, this means that your program invokes undefined behavior. A conforming compile may: 1. Emit a compile error 2. Not emit a compile error and crash on runtime 3. Not emit a compile error and replace the program with `system("rm -rf /");` 4. Not emit a compile error and replace the program with an ASCII animation of Rick Astley. 
I like using `auto` to signify "I don't care about the exact type". For example I use it for types meant to express abstract ideas (eg iterators) or when I care only about the behavior (eg iterate through container and print out the elements). In this mindset `float x = 42.0f;` is the consistent way to declare a `float`, not `auto x = 42.0f;` or `auto x = float{42.0};'.
Original speaker here. Sorry in hindsight I wish I would have been a little clearer about details such as that. Feel free to ask me questions if you're curious. 
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
It's _mostly_ OK for unit tests.
&gt; With that style,`auto` means “create a local variable”. That was the original meaning of that keyword, actually: create a variable with automatic storage duration.
You do have access to "a" filesystem on the consoles - typically with a readonly game path, a writable temp/cache, and possibly others - but every path you have access to is game-specific. You're completely sandboxed. You have no access whatsoever to the console's OS filesystem, but that doesn't mean you don't have _any_ filesystem. I would expect the XBoxOne to have std::filesystem soon if not already just because Windows does and it shares a lot of the C++ library (it's largely built on top of Windows API calls, which are what has a different implementation, rather than the C or C++ standard headers). PS4 I have no idea, but if it uses a public STL implementation (I don't know off the top of my head) I'd expect it to get it too.
IMO the fact that std::hash isn't provided for pair/tuple is a bug in the standard library, not an invitation for specializing it. Putting any user code in the std namespace is asking for trouble.
&gt; IIUC, if templates and constraints became “hard” by default, then most current template functions and classes that just use typename would break, The only thing that would need to become "hard" is code using concepts.
The ideas are very nice. But while the class() syntax helps the parse for metaclasses I will say that the \_\_generate \_\_fragment stuff is ugly and much like the "Concept auto" and "import export &lt;module" the syntax choices being made by C++ committee at the moment is very surprising in their lack of simplicity. I would suggest asking Kate Gregory if these things will be fun to teach or to read. I understand stuff is getting hard to squeeze in but still there has to be better stylistic choices available.
thanks as always ! 
Happened to me a couple of times, unfortunetally. It's never this simple of course. Having references as data members can easily result in a dangling pointer if you misjudge the lifetime, or change the code to pass a temporary object to the constructor.
But having a reference as a data member is not what those demos show and such a dangling reference usually much harder to detect. My point is: Detection of dangling references is a QoI problem that only becomes really useful, if it handles the complex cases, but the examples shown by most tool demos are so trivial, that I'm not convinced they help me with real problems. 
But having a reference as a data member is not what those demos show and such a dangling reference usually much harder to detect. My point is: Detection of dangling references is a QoI problem that only becomes really useful, if it handles the complex cases, but the examples shown by most tool demos are so trivial, that I'm not convinced they help me with real problems. 
The underscores are there to designate placeholders for syntax to be haggled over later. FWIW, I'm a professor and teach C++ to 60-90 students per semester. Why not ask me about teachability? Teaching is literally my full time job.
I disagree but I have no data on the matter. I will only say that if that was the case then they would just make every feature available in the Community edition. Given that both MS and JetBrains are not doing that then I have to conclude that their analytics say there is a decent number of customers that are paying for the feature set.
I learned about this for the first time a long time ago (2010!) from [litb](https://stackoverflow.com/users/34509/johannes-schaub-litb). I do find his solution more succinct: http://bloglitb.blogspot.com/2010/07/access-to-private-members-thats-easy.html The short of it, in case the link ever goes dead, and a [godbolt link](https://godbolt.org/z/YSkmlM): #include &lt;iostream&gt; // Tools template&lt;typename Tag&gt; struct result { /* export it ... */ typedef typename Tag::type type; static type ptr; }; template&lt;typename Tag&gt; typename result&lt;Tag&gt;::type result&lt;Tag&gt;::ptr; template&lt;typename Tag, typename Tag::type p&gt; struct rob : result&lt;Tag&gt; { /* fill it ... */ struct filler { filler() { result&lt;Tag&gt;::ptr = p; } }; static filler filler_obj; }; template&lt;typename Tag, typename Tag::type p&gt; typename rob&lt;Tag, p&gt;::filler rob&lt;Tag, p&gt;::filler_obj; // Victim struct A { private: void f() { std::cout &lt;&lt; "proof!" &lt;&lt; std::endl; } }; // Thief struct Af { typedef void(A::*type)(); }; template class rob&lt;Af, &amp;A::f&gt;; // Proof int main() { A a; (a.*result&lt;Af&gt;::ptr)(); } 
&gt; The implementation is quite impressive, even more for read misses due to the technique used, but is a bit sensible if a basic hash function is chosen. I remember Matt explicitly saying that they'd rather improve the broken hash function than attempt to account for broken hashes in the map implementation; so it seems deliberate.
I decided to remove support for typedef from the **C++ Middleware Writer** after listening to part of this.
It's not actually call order dependant, the IDs of the threads go exactly in the same order in the thread sanitizer as they do with the first solution. I updated the article with an example of this and I have used the exact same thing with multiple threads and it has been working great. 
I... I think I just witnessed the death of Rust.
What do you mean? The feature is removed from the standard now and with`/std:c++17` MSVC behaves exactly as specified by ISO in all other cases.
So how do you feel about the teachability of the proposed syntax for metaclasses?
What is done?
This is brilliant satire (I hope)
It is. 
I tried to google "defun defun 3" but I got nothin
[You're welcome.](https://youtu.be/6Dg73E_fv9E)
Now, note that (named behavior) cateogry makes so much code simpler the result can be an explosion of complexity. templates, proper classes/structs, vtables and polymorphism, dtors/ctors (RAII), ADL, and functions themselves -- these are all things that fall under **named behavior**. All of these permit writing code that whose behavior is insanely more complex in far less end-user code than what you could do before. The complexity of behavior explodes, while the complexity of the written code collapses. And programmers are limited by the complexity of the code they write more than the complexity of the code's behavior. The strongest attack from C programmers on C++ programmers is exactly that explosion of complexity that the features of C++ *permit* without having to write out the *complex code*. In assembler, complex behavior requires complex code. In C, less complex behavior requires complex code -- it has structs and functions, which I'd argue are combinatorial powerful. So things you can do with the two of it is some insane things that would be over-complex to write practically in assembler. And C++ goes further. Some of this leads to **bad code**. There are horrible class heiarchies that nobody would have written in C. There is bad template code that are just as bad or worse. Dtors/ctors that break things exist. ADL messes things up sometimes. So the criticism of C++ from the perspective of C is **valid**. But the benefit isn't zero. Proper use of inheritance, classes, methods, templates, ADL, RAII and the like makes code insanely easier to reason about, while including complex behavior that doesn't have to be replicated in a billion spots to get the behavior you want. metaclasses, modules, static reflection, type functions, concepts -- all of these will cause both new kinds of **bad code** and, we hope, a trancendental increase in expressivity. I think that those are so powerful, that entire existing features of C++ will become depricated, possibly including *every single current use of the `virtual` keyword*. C++11 was a sea change compared to C++98. C++23 if we have all of "metaclasses, modules, static reflection, type functions, concepts" may be as big a step from C++11 as 11 was from 98. It could take a decade to digest what you can do with those 5 things. 
making me a mod might save you some effort ;)
That sounds plausible.
&gt; I think that those are so powerful, that entire existing features of C++ will become depricated, possibly including every single current use of the `virtual` keyword. With compile time code generation, replacing hierarchy of classes by composition of classes (with `std::variant` and the visitor pattern) will become totally possible. Currently we can already do it, but the amount of boilerplate is still a bit too high.
 for( unsigned int ii=10;ii&gt;=0;--ii ) { //Stuff inside loop. } &amp;#x200B;
As a C++ developer, I think that Rust should be seen as a positive competition, just like the apparition of clang boosted the development of gcc. It may eventually die, but it would have given a new point of view during his lifetime.
You must have misread the code. The first stage of the pipeline is constructed last since it needs a reference to the next stage, thus it is the first stage that gets stopped and destroyed first.
Ah, indeed you are right. Thanks for the explanation. 
More than that. `virtual` implies a certain implementation of a certain object model chosen in the 1990s. Each compiler implements it in certain ways. It has compromises and assumptions and costs. It assumes someone will need a virtual inheritance somewhere, that classes have certain layout requirements, etc. It doesn't permit per-instance vtable modification or ownership. It makes the classes it is part of not-trivially-copyable. It requires the vtable be part of each instance and not separate in a flyweight system. It doesn't permit higher typed classes. It doesn't support inline vtables. It doesn't support sparse vtables. It doesn't support double or higher dispatch. Those are all *choices* made, in the 90s, that determine what a C++ heiarchy with virtual methods and/or inheritance means. Metaclasses by itself lets you roll out your own object model at near zero cost to the end user. So `com_class foo: interface_A, interface_B { /* ... */ }` suddenly produces a com-compatible object named `foo`. Or MFC/ATL style message maps or more complex ones. Or C# style broadcast and hooks. Or QObject style signals and slots. Or lua style metaclass chaining. Or python style method adornments. Heck, how about easy to write bounded or polymorphic value types with our without enforced SBO. Or metaclasses which generate both a set of compile time concepts and type erasure wrappers for easy duck-typing; what if `std::function` becomes: template&lt;class Sig&gt; ducktype moveonly_function { Sig operator(); function( function &amp;&amp; ); function&amp; operator=( function &amp;&amp; ); bool operator&lt;=&gt;( function const&amp; ) const; function(); explicit operator bool(); }; and everything was generated for you. Meanwhile: duckinstance foo:duck&lt;moveonly_function&lt;void()&gt;&gt; { }; would just check that `foo` qualifies as an instance of the ducktype `moveonly_function&lt;void()&gt;` and generates easy to read error messages if it isn't. Similarly, template&lt; IsADuck&lt; moveonly_function&lt;void()&gt; &gt; F &gt; void foo( F f ) `IsADuck&lt; ducktype &gt;` is a concept that says "types which are ducktype compatible with the ducktype `moveonly_function&lt;void()&gt;`", without actually doing the ducktype type erasing. Anyhow, I'm excited. 
Why is an advancement of one language always considered a death sentence for another? These languages can happily coexist each having their own niche.
Sure, but why would you use a reference in the first place? If you want to store a reference to a lookup result ok, but in 90% of the examples I see, using a reference is plain stupid.
Yea, agree we both don't have the data. Btw the Community terms are as follows, approximately: For OSS always ok. for company work: Allowed for up to 5 users, if you are *not* an "Enterprise", which is defined as having more than 250 PCs or users, or having more than US$ 1 Mio annual revenue.
I kinda fear the metaclass meta programming abominations we will witness. 
&gt;Am I correct that the property sample has the disadvantage that it generates a new metaclass for each instance of a property? No, it's creating a new class for each property. I like Herb's idea better than yours, as his is more powerful than yours (if I understand yours correctly). I don't want to create a new metaclass for each different property. Also why the base class? Seems unnecessary IMO. &gt;the code inside the getter/setter is simple and follows a certain pattern. Can you give an example? I have no idea what you're referring to. Also: &gt;The need to write it out directly is just bad practice and sort of boilerplate in itself. But having a full blown (meta) class hierarchy for each property is not bloat?
Exciting stuff! Any idea how long it will be until we can use in this production? The `class(property&lt;int&gt;)` thing is a little disappointing. When we write a class, we can instantiate it without having to tell the compiler this name is a class. When we write a function, we can directly invoke it without telling the compiler we are going to invoke a function. So why does a metaclass need an extra `class()` around it so the compiler knows it is a metaclass? 
&gt; noexcept If a noexcept function throws you did flag it wrong. There is no way for the comiler to prove that noexcept functions really do not throw
why ? there are plenty of languages with equivalent features (e.g. java / c# / python reflection) and the only thing metaclasses have created are widely used frameworks such as Django, Spring, ASP.Net or Unity3D
Uh, that's [warning C4297](https://docs.microsoft.com/en-gb/cpp/error-messages/compiler-warnings/compiler-warning-level-1-c4297?view=vs-2017). (In gcc it's -Wterminate and in clang it's -Wexceptions).
ok wow I stand very corrected. I am pretty sure I don't see this at work but can't test till Monday
Is your problem actually with MSVC, or is it with the standard? Is there a specific example that you feel MSVC should warn about and doesn't where other compilers do?
Are comments suddenly not a thing in C++? Seems like the easiest solution. while(true) { // Loop forever // Code that does stuff }
It’s zero overhead!
[https://github.com/google/hashtable-benchmarks](https://github.com/google/hashtable-benchmarks) will happily accept pulls for any maps folks who want to contribute. I would very much like to improve the overall state of the world around tables and benchmarks (they are hard). We already have Facebook's F14 in there and I will be merging in absl::flat\_hash\_map soon (now that it is released).
Yea it comes short of the halting problem. Saying that a function won't throw is a pretty bold statement.
[Atmel AVR](https://en.wikipedia.org/wiki/AVR_microcontrollers)
Just a guess but one of the reasons might be that if compiler were to check noexcept-ness, it must discard any function that dynamically allocates memory (because it might throw), or in some cases it might need to do flow analysis (because noexcept-ness might depend on the template parameters), in that case standard either needs to force implementers to do full analysis or make it implementation-defined. Former puts stress on the implementers and the latter might result in inconsistent behaviour.
Its okay. I don't know what I would consider ideal. 
All the reflection and metaprogramming stuff is going to the committee. You can't do metaclasses without it. 
Sortable auto isn't bad. It's not what I prefer, but its not the worst we can come up with. We can always do worse :) I would love if we only talked about sets of values. Export import solves a real problem. There's really no better way to write that. And yes... the frgament and placeholder stuff will go away. I just dont know what to replace it with. 
How do you want to handle libraries where the compiler only has the declaration of a function but does not known anything about the implementation? And just out of interest: Which language do you think does error handling right? I have the feeling that no matter how you do it there is something wrong/lacking. I'm not to happy with C++ exceptions, but the error handling in C , C#, Java or Rust is in my opinion not better.
Well there's http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf and the static reflection proposal. 
&gt;why ? there are plenty of languages with equivalent features (e.g. java / c# / python reflection) and the only thing metaclasses have created are widely used frameworks such as Django, Spring, ASP.Net or Unity3D. I can't speak for Java and Python but it's false that C# provides equivalent features. Reflection (and in C# case runtime reflection) is only one part of what metaclasses provide and what power it will give to developers.
What do you mean by "x-x area"?
Indeed, and let’s not forget that “safety” is not the only thing that Rust brings to the table. I’ve tried Rust and I don’t really like the strict borrow checker - I think proposals such as this one are better. However, there are few things where I think Rust is ahead of C++, and that is mainly it’s nice ADTs and pattern matching.
Coordinates on the screen like a 2inch by 2inch square somewhere and only in that square 
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9jsdua/is_it_possible_with_c_alone_to_check_xx_area_for/e6ty8pz/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; Standard behavior was there all along, even before C++11. But it was available only by using undocumented compiler switch /d1Esrt This is news to me, and very few references to this anywhere. I'm curious what other switches there are / have been. 
I thought this was about cars at first.
Suspended. What was this?
Note how you use const liberally in your code. It's not required to help you solve real problems, but it will certainly reduce cognitive load, speed up code reviews and make you more confident that your code is doing what it is supposed to be doing. There's no point wasting your precious mental energy making sure a variable isn't being modified or isn't being read while dangling when you can have the compiler do this for you.
Hey Andrew! FYI, you can use [user flair](https://www.reddit.com/r/cpp/comments/4tm8k9/user_flair_is_now_available/) to mention your university/Committee/etc. affiliation so readers will always notice it.
1. just isn't possible. What if you make a call to an external library, and it throws? How could the compiler possibly know that? 
Looks like the page is down on Medium at the moment. Will check again later, but thanks for updating it to explain. 
Unsigned underflow is defined to roll over. Signed integer under and overflows are UB. 
didn't knew that! :thumbsup:
Because these blog posts are basically one of the libs devs going "oh yeah, we should make that blog post". Note that generally bumping the revision number doesn't contain compiler or standard library changes; we always bump at least the minor version when that happens. (Unless we have a recall-class bug in the standard library but that hasn't yet happened and given the amount of testing it gets is unlikely to ever happen)
&gt; There's no point wasting your precious mental energy making sure a variable isn't being modified or isn't being read while dangling when you can have the compiler do this for you. How is that related to my question? And I would be very happy, i'f I could really on the compiler could catch all dangling references, bur the examples I'be seen so far are just not convincing (yet). Maybe the checkers at least detect a dangling string_view by now.
The most convincing argument that I heard is that it cleanly allows to apply multiple metaclasses to a class. 
Most cool, thank you. :)
This just looks like somebody who didn't know how the variable vs function namespaces worked?
codeblocks with the plugins package
The only cost of RTTI is bigger binary size, and the info needs to be stored anyway (even if you don't use RTTI) because at any point the program in some random compilation unit could go "surprise, i use typeid on some random virtual object", so I don't see how this particular cost could be removed.
Do you teach debugging? I once took a C++ class to fulfill a credit requirement and the fact that I knew how to use a debugger was a HUGE advantage over the other students.
!removehelp
I thought that embedded C++ was gaining some traction. Was is it replaced with?
Because they have exactly the same niche! Both C++ and Rust want to be the language just above assembly, aim at zero cost abstraction, maximum performance possible, abstraction (unlike C), … By having C and C++03 bacward compatibility, and a much bigger use, if C++ suddenly catch up with all the adventages of rust, their is no point at writting anything in Rust. I thingthat Rust is non-bacward-compatible C++ some people wanted. With the absence of backward compatibily, Rust was able to pick much safer and intuitive default, it has nice properties that make it much safer by default, … But ultimately, it has exactly the same goal as C++. And unlike clang vs gcc, you can't use both in parallel, since they are not compatible. Anyway, like I said in another comment, I sincerly thing that Rust is a really healthy competition to C++. And if Rust ever die, predated by C++, it would mean that C++ would have progressed a lot .
Perhaps you should use the contact info in that code of conduct instead of posting about it on reddit.
Ok, I understand the need for flexibility. Is there also a need for the syntax for the most common case to be so unpleasant? How about if we add a... classdef? classdef class(property) property; Or maybe `using` would already be enough: using property = class(property); 
Oy gevalt!
I bet nothing will happen at all, this is obviously an "inclusive violation", not a bad one. All this CoC hysteria is a bad joke.
I'm not sure what to make of this. It's not even about the sexualized language *per se*; the official tweet itself seems to imply that this whole "lightning talks" session was quite, erm, unprofessional in some ways. At a bare minimum, people should have been warned about the character of this event - after all, one key reason why conferences have binding CoC's is that what may be taken as "good-natured fun" by some might be problematic to others.
"fuck" with no context isn't sexual (that's up to your interpretation) and I don't see how it would fall under "excessive swearing". "cum" actually has only one conventional meaning, but I'd have a hard time arguing it really brings sex into anything when it's the only thing on the shirt. I can't speak for how that works with other people.
Your comment has been automatically removed because it appears to contain disrespectful profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9juy8t/speaker_at_cppcon_violating_the_cppcon_coc/e6uf7m3/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
This is further evidence that CoCs are tools of the state to undermine free software. The rules are applied selectively against those that need to be removed (according to state and corporate interests) and those removed are replaced with people subservient to state and corporate interests.
We don't need those things. Why not just allow `property&lt;int&gt; smt {};` directly? 
What do you mean? Embedded C++ is not replaced?
This is not the right place to report a CoC violation.
She/he is very good at attacking other speakers: https://twitter.com/slurpsmadrips/status/1044801802502205440 Would publicly denouncing another talk, posting on twitter "Yeah the entire thing was fucking terrible" or "This fucking joker [...]", not be a violation of CoC too? Or is it justified to use such personal attacks and derogatory language because the speaker was racist, mysogenic? If it was that bad, should it be handled publicly by denouncing and attacking the speaker? Or is it perhaps just a very different stance of opinion? Then it would be more appropriate to say something like "Didn't like that talk because of X" or "I found that a bad talk". Where's the line, who gets to decide? Should that be fought out in public with swear words, very likely ruining the speaker's reputation, or even career?
Please report the same via conduct@cppcon.org
Please go back to quarantined Nazi subs where you belong.
Well I wasn't there, and this is just my opinion and my thoughts based on what I can see on the internet. I don't really want to report anyone for a CoC violation, I think (I'd have nothing to gain personally by that). I would hope though that the CppCon committee that "rules" about these issues would take into account thoughts along the lines of what I've posted. (Also I'd rather stay anonymous, and I'm not sure how to do that via email.)
It looks very nice and professional. Unfortunately I have no idea what's going on. Can you explain some common use cases for CookMem? Is it for special case scenarios? Or is it solving some awful problem I didn't even know I had? PS: https://coconut2015.github.io/cookmem/tutorials.html &gt; Oftentimes, we want to allocations to be done within a big chunk of memory I don't think that sentence works.
This is genius. If the content of your loop is quite small and you're worried you'll reach the end of the loop you can just replace the unsigned int by unsigned long!
Hah, my account got suspended because of automatic spam filter. Now it's up and running again.
If you see me then see this. These CoCs are being used as a tool to undermine free and open source software. They are used to attack and remove "undesirables" and replace them with people who are willing to advance the goals of the state and corporate rulers. Social activists are being played as pawns to attack free and open source software.
Create a throwaway account.
Are there facilities for custom deallocation? Or do you only adress working with arrays of things?
I also wish all pointers go with STL convention to, \`make\_qobject\` looks "smart" :)
I assume its taught in an earlier course. I sometimes use a debugger in class to show what's really going on.
Back working. Medium automatic spam filter had my account suspended for some time.
So it's an arena / pool / region allocator? How does it compare to other arena allocators?
&gt; Is it for special case scenarios? If you're allocating a lot of small bits of RAM during a particular short-lived execution context (maybe as part of a database transaction or serving a single web query) you can allocate them all inside a single chunk of RAM. At the end of that execution context you free the whole chunk. The allocation is cheaper, and the deallocation is much cheaper. And you don't have to keep track of and free every bit of allocated space as you go, you can trust that it'll all be freed when you're done.
You can tell most compilers to not generate any runtime type information. I never tried it, but I'd hope to get a link time error if you try expect that you get a link time error, if you try to link object files with and without rtti.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Embedded c++ is an absolute abomination and I don't think it ever gained significant market share. 
Nevermind then
&gt; But there is no indication whatsoever that CppCon is not doing that. We'll see. Unfortunately, the path of least resistance is not for even-handed enforcement of the CoC, but simply for "doing something" (whatever that is) when people complain in a highly motivated/vocal way. We've seen such things happen repeatedly elsewhere, and this is indeed not a good thing for of F/OSS or the industry more generally.
Nope. This is C++, generally the answer to doing anything weird is "undefined behaviour". Although, in this case, it's not even C++, as far C++ standard is concerned you cannot disable RTTI. $ cat a.h class A { public: virtual ~A(); }; $ cat b.h #include "a.h" class B : public A { public: virtual ~B(); }; $ cat a.cc #include &lt;iostream&gt; #include "b.h" A::~A() {} int main() { B b; A* a = &amp;b; std::cout &lt;&lt; typeid(*a).name() &lt;&lt; '\n'; } $ cat b.cc #include "b.h" B::~B() {} $ c++ -c -fno-rtti b.cc $ c++ -c -frtti a.cc $ c++ a.o b.o $ ./a.out fish: “./a.out” terminated by signal SIGSEGV (Address boundary error) 
I know I'm being pedantic, but the term is "wrap" not "roll over". Also, no matter if your `int` overflows at `INT_MAX` or `INT_MIN`, your `int` overflows. Undeflow is when a floating point has decimal part so small it gets truncated to 0. Also, also since unsigned integers have a defined wrapping behaviour, it is said that they do not overflow.
But if you compile both files with `-fno-rtti` you would get a compile time error saying "you can't use `typeid` and without rtti".
MetaClasses looks cool in what they allow to achieve. However I still feel that it is weird that they are not a special case of using "type functions" (functions that are manipulating and/or generating types, you can get a taste in this paper: [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0844r0.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0844r0.html) ). To clarify: the syntax in R4 imply that the function can only be used to generate one type and that's it, which also imply (at least for now) that it can only be used as a metaclass. If it was an usual function as in it takes a type as argument (or several, and maybe some other things), then the usefulness would be larger than metaclasses (pseudo code from the first example): template&lt;Mutex M, Auto T, Auto X&gt; // Mutex and Auto are concepts, X probably could be more constrained constexpr X guarded(T source) { Auto guarded_source = guarded_with&lt;M&gt;(source); for...(auto o : source_with_mutex.member_variables()) { // or whatever way to get members guarded_source = guarded_member(guarded_source, o.type(), o.name()); } compiler.require(guarded_source... ); return guarded_source; // This is particular is missing in the example Assuming something like this is available, then using it is not restrained to class definition or member declaration (like in the talk): using X = property(guarded(MyStruct)); X a; X b; Which is why metaclasses feels like a special case to me. I hope both reflection/metaprogramming and metaclass proposals will tend in this direction.
I mean, yes, that was a response to parent comment: "if you try to link object files with and without rtti"
I wasn't answering your question. I was responding _directly_ to your comment that says detection of dangling references is only useful if it handles the complex cases. I contend that this isn't true by pointing out that regardless of the complexity of the case, you'll reap the benefits of it of relying a bit on the compiler for these issues.
More: [https://youtu.be/-Airq1IlfTk](https://youtu.be/-Airq1IlfTk) [https://youtu.be/HD3-lF72EIo](https://youtu.be/HD3-lF72EIo)
My ints roll over and heel, too. 
I'm torn between upvoting this for the sheer inventive, or downvoting this for the sheer inventive. 
I'm talking about [embedded c++](https://en.m.wikipedia.org/wiki/Embedded_C%2B%2B) doesn't sound as if you are using it
C++ is improving the first two with every release without sacrificing speed. I think compilers need to do a better job linting 'old' ways and teachers need to focus on the 'new' ways
Not necessarily compilers, but I do think it would be great to have a lint tool of some kind that finds “old style” C++ code and recommends current best practices instead. Or even better, can create a patch you can apply. 
Though I think the people in this comment chain are making solid points I think most anti-C++ is just rationalizing laziness. Younger people have a hard time with patience and often steer towards shiny Java or Python.
Even better, automatically rewrite syntactically-obvious cases. 
That lightning talk was groan inducing, not only because of the '5 gals' statement, but also because of a 'block lives matter' comment, referring to indentation. Since many lightning talks are lighthearted and humorous (look forward to James McNellis's!), I think that particular speaker just got it a bit wrong what humor means. But I didn't see proven(!) ill intent. In the best case, the '5 gals' comment is describing an unfortunate status quo, and in the worst case it was misguided. While a reaction to this admittedly awful talk on Twitter is appropriate, I also think Isabella chose the wrong language. It's a much more personal attack of the lightning talk speaker, and therefore (ironically) probably closer to a CoC violation. Is it understandable? Sure. Still doesn't make it appropriate. That said, some of the further reactions scare me: [https://twitter.com/metalcanine/status/1044806147579031553](https://twitter.com/metalcanine/status/1044806147579031553), [https://twitter.com/visagermusic/status/1044807603287724032](https://twitter.com/visagermusic/status/1044807603287724032). Is this what we have come to as a liberal, understanding, polite and tolerant society? These things don't only go one way, and this aggressive offence culture is scary.
Um, isn’t this `clang-format`?
Why not just make a new language and put all the trendy crap there? I'm in the camp of "people are destroying C++" because it's far too complex now, and sometimes the hardest and best thing is to know when to stop. It still has [deficiencies that aren't being addressed](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0934r0.pdf) because shiny new features for the neophytes are higher priority. I have a friend who is an ardent supporter of C++, but even he conceded to me in 2 recent dialogs that "a significant amount of time is spent avoiding copies" and "C++ is a field full of rakes."
Is it?!
You mean clang-tidy?
No thanks. We make a conscious choice to use the "old style".
Probably, I was too lazy to double check.
If java and python are shiny, I am a fucking supernova...
[clang-tidy](https://clang.llvm.org/extra/clang-tidy/) is fairly close to what you describe (specifically the `modernize-*` family of checks). I don't think it has the ability to output patches, but that seems like a fairly trivial operation with version control: From a clean source tree run `clang-tidy`, then run whatever command generates a patch file of changes in your version control software. Still, it might be interesting to suggest patch output as a built-in feature. (Disclaimer: I'm never personally gotten around to using `clang-tidy` in earnest; it's one of those things I keep meaning to get around to.)
He explains what "zero-overhead" (not zero-cost) means around 9:40. I claim that both exceptions and RTTI are "zero-overhead" by Herb meaning of the term. I do not believe that most of the people who claim they can't do their stuff with exceptions because of the perf. penalty, actually measured the penalty on their use case. (RTTI is different, as Herb says, once there's static reflection.) It is simply false that the code using exceptions is somehow equally simple as the code not using them. STL doesn't work without exceptions. str1+str2 doesn't work without them (a special case of "operator overloading doesn't work without exceptions"). From that standpoint, "zero-overhead" can't even be put into the picture. One can use recent C++ libraries that make working with error-return **much** more palatable - but still can't make it as simple as code using exceptions - so that's the trade-off one is making.
... and being (probably) already accustomed to frustration, having to poke / thrash around. Very good frame of mind. 
Oh, from outside CppCon, I didn't realize that this was yet another lightning talk. I'm still puzzled as to whether the fact that "lightning talks are often lighthearted and humorous" was something that would be made clear to the attendees before the event. Either way, it's understandable that some folks might want to have some fun and decompress, but professionalism is important, and especially the courting of controversy (regardless of one's social/political orientation) seems to go against the spirit of maintaining an inclusive and harassment-free environment. I'm seeing problems on multiple sides here.
I see, yeah no it's definitely not the same thing. Thank you!
realtalk i never undstood why anyone uses for(;;) when you can use while(true) or at least while(1)
&gt; Doing infinite loops in C and C++ with a for loop has always been awkward. It's not awkward, it's undefined behavior.
C, and more generally, backwards compatibility. It's one of the greatest C++ strengths. It's what keeps C++'s momentum - people don't need to learn a new language to have low level access to hardware. That's why we have had so many languages designed from scratch (someone mentioned D) that were supposed to be "C++ killers", yet it hasn't happened.
Well, it comes down to the right tool for the job. If you don't need speed and you have no background in C++, but you were taught Python in school, why would you go to C++? That's not lazy in my book.
Zero-overhead means I don't pay for a feature if I don't use it. With RTTI enabled, however, the compiler generates type info even if I don't use RTTI (typeid) in my code. That's - by definition - not zero-overhead. The cost of exceptions (that rely on RTTI) is often negligible and, I agree, sometimes people make assumptions about the cost of a feature without profiling it thoroughly. Still, a low or negligible cost doesn't change the fact that there *is* overhead associated with both exceptions and RTTI. My personal rule of thumb is to use exceptions unless I have specific reasons not to(performance, executable size)
OP, A human moderator (u/blelbach) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9jyuo1/macos_mojave_update_issues/e6v3b8g/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Summary: Lua, ruby (and home-brew) and Python have stoped working. wchar.h is missing. Clang thinks its version is 1000. All my 32 bit applications refuse to open. It uses significantly more ram. SFML is crashing on basic things like opening a window. But hey, the background is cool.
Nice! I'll Google that.
That basically lets me know all i needed. Thanks.
Pick any 10?
Well, to me it's pretty much everything that would be referred to as Modern C++ is in my opinion for the johnny-come-latelys. Yes that makes me old, yes that puts me in the minority. I think the standard library was a horrifying mistake, in large part because it provides an excuse for complexity creep in the core language spec. We also sure as hell didn't need to encourage template metaprogramming, which is really complicated and a source of nasty bugs. Modern C++ is now too complicated and unwieldy to be a candidate for reliable systems programming, which is why new projects are adopting Rust and using strict language subsets of C++ that completely eschew C++11 and the standard library when working on high-reliability code (see Google's Magenta/Fuschia for an example).
&gt; C++ is improving the first two with every release without sacrificing speed. I agree on expressiveness, but simplicity really? I don't find C++17 simpler; the rules are getting ever more arcane with every release! Let's take the example of `= default`. Surely the rule is simple, right? If you are writing `C() {}`, then replace it with `C() = default;` instead. Right? [Not quite. Only do so if the constructor is `public`](https://stackoverflow.com/questions/37618213/when-is-a-private-constructor-not-a-private-constructor): &gt; C++14 8.4.2/5 [dcl.fct.def.default]: &gt; ... A function is user-provided if it is user-declared and not explicitly defaulted or deleted on its first declaration. ... Which means that using `C() = default;` on a private constructor let the user write `C object{};` (using aggregate initialization). And of course the user is going to write `C object{};`, because they've learned that writing `C object();` led to the Vexing Parse (`object` is then of type `C(*)()`) and that Uniform Initialization was to be used for initializing objects. Unless, of course, for classes with a constructor taking `std::initializer` as the sole parameter, since it's then preferred. --- So, to sum things up, Default Constructors, Uniform Initialization, `std::initializer`. 3 newish features, and a huge big stinking mess of weird interactions. No, C++ is definitely not getting simpler. It's piling special case upon special case.
I've been learning C++ for only half a year, but I can see where this sentiment against it comes from. I don't dislike the language and I know I have _a lot_ to learn yet, but there are certain things that seem to be needlessly difficult, especially when coming from languages like JS, Python, Clojure or Go. I know these languages have their own quirks and problems, but I'm gonna compare my little experience with C++ to them anyway. * Package management. I really miss being able to write a list of packages (and versions) I want to use and download them with `pip` or `npm`. Often when I want to use some library, it's not clear from docs what's needed to do to include it in my program. Many times it seems to me it's impossible to use some libraries unless you are expert at the language and its tooling. Last week I had problems with `&lt;optional&gt;` included in MacOS (`clang` with `-std=c++17`; it seems to be some old implementation) and I had to manually include `optional.h` found somewhere in LLVM repo. Not exactly beginner friendly. * A lot of ways to do one thing. This is especially problematic now that I'm learning the language after 33 years of existence. Sometimes I search for information regarding some feature or problem and I find multiple ways to implement it. I understand this is normal for language that went through a lot of transformations throughout the years and keeps the backwards compatibility. There could be however ways to _easily_ tell people to avoid some old features or anti-patterns. I ended up using `clang-tidy` with C++ Core Guidelines, which helped a lot, but once again it took a lot of time to set it up and I'm still not entirely sure if I use it correctly. * Documentation even for the simplest functions seems to have needlessly complicated examples. This is often the case also for library documentation, books and various articles. It seems to me that everyone is obsessed by showing how clever they are instead of providing actually helpful content. * Many compiler errors and cryptic and don't really help me to find given problem in my code. When I was learning `std::vector` I tried to create a vector of references. `clang` exited with around 400 lines of error messages. None of them descriptive enough (again, for a beginner) to show me what's wrong. This is quite frustrating, because I end up doing a lot of guess work. * I've found it hard to compile code. There's so many various flags and options. CMake helps a bit with setup, but it's another piece of complexity to a language that's already hard enough. I miss being able to write `go run` and have everything take care of itself. All in all, maybe there's a problem with the language itself, but I don't see it through tons of problems with tooling and UX. There's so much of needless friction. I spend hours of studying resources to include simple libraries and then hours decyphering compiler's error messages for the simplest problems. I do all of this during evenings in my free time and it's often extremely frustrating to fight with tooling instead of actually programming. I don't know where's the problem with these things and how to fix them. Is it just hard to have simple tools in this ecosystem? Is it a legacy problem? In the end I just see that newer compiled languages like Go or Rust don't have many of these problems and it leaves sour taste in my mouth.
Yeah, no one who's read Scott Meyer's *Effective Modern C++* would confuse its trajectory for simplification.
A lot of what you write seems to stem from tooling. Give conan.io a go and see if that changes your experience. 
... it's clang-tidy, one of the 'extras': https://clang.llvm.org/extra/clang-tidy A problem is, that it needs the: compile_commands.json database, which requires either that you build with CMake (and turn on CMAKE_EXPORT_COMPILE_COMMANDS - https://cmake.org/cmake/help/v3.5/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html), or, use the Bear tool and regular Make: https://github.com/MaskRay/ccls/wiki/compile_commands.json That database records /exactly/ how each file is built, so clang tooling can do things with confidence. 
If you’re using MSVC, check out Clang Power Tools, it’s pretty great!
**Why are they called "Swiss Tables?"**
Not sure what you mean here. You mean the tests using arrays of pointers? That's just for testing.
Thanks, I will
I don't see why clang-tidy should make patches. Let vcs do what vcs does best.
Substitution failure isn't an error, dontcha know?
"Kids these days" C'mon now. The people who can be served by Java or whatever else languages go to those languages. The most ardent critics who could not use Java often go to C, or use the barest minimum C++ features, or go to Rust. If you're trying to evangelize or rationalize the usage of C++, calling people lazy and naive is not a good strat.
&gt; package management Conan probably does what you want and is getting more popular year-on-year.
&gt; In C++ all threads of execution must terminate, otherwise, the behavior is undefined. That is simply not true. I assume you are referring to http://eel.is/c++draft/intro.progress#1, which lists a few other things a thread can do other than terminate. Infinite loops are fine as long as they do something.
The word you are looking for is proselytize, not evangelize, and I'm not trying to do it. I'm just observing. I don't care what you use.
Ah that is the word I wanted, thank you. Even if you're just observing, I think my point about people seeking what C++ offers in other languages still stands. I wouldn't exactly characterize Rust as being a language for impatient people.
Gotcha, I'll play around with it. Thanks so much.
Sure. There are a lot of talented people that write excellent code in modern C++ no doubt about it, but the majority of people that play with C++ are not that kind. STL or standard library is very powerful but it's very easy to misuse and produce slow code (sometimes is confusing too). Another thing is that in order to take advantage of all the modern things in C++ you have to use exceptions (that's the right way) and personally I avoid them for my own reasons therefore we are limited to what is proven. If modern C++ matures at some point we will embrace. Finally what I like most about C++ is that it allows the author to judge what is right and wrong about his project; forcing people to use a particular style or practice is nobody's job. 
I remember doing it because while(true) generated warnings about constant conditions, and using double parens was more annoying to type. I kinda like that its weirdness draws attention to the fact that it's an infinite loop. Hopefully that means reviewers are more likely to look for exit conditions in the loop body :P
&gt; I'm curious what other switches there are / have been. The "undocumented" MSVC switches I know of are `/d1reportSingleClassLayout_____` (replacing the underscores with a class name of yours) and `/d1reportAllClassLayout`: struct Base1 { int x; }; struct Base2 { double y; }; struct Middle : virtual Base1, Base2 { int m; }; struct Derived : Middle, Base2 { double d; }; run with `/d1reportSingleClassLayoutDerived` produces: class Derived size(44): +--- 0 | +--- (base class Middle) 0 | | +--- (base class Base2) 0 | | | y | | +--- 8 | | {vbptr} 16 | | m | | &lt;alignment member&gt; (size=4) | | &lt;alignment member&gt; (size=4) | +--- 24 | +--- (base class Base2) 24 | | y | +--- 32 | d +--- +--- (virtual base Base1) 40 | x +--- Derived::$vbtable@: 0 | -8 1 | 32 (Derivedd(Middle+8)Base1) vbi: class offset o.vbptr o.vbte fVtorDisp Base1 40 8 4 0 https://godbolt.org/z/0_FYso I don't think I've ever actually *used* this though.
Well, except when there's no other overload available...
I think 2011 C++ was both late and immature when it arrived. Ideally string\_view would have been part of 2011 C++. Abseil takes a step toward that, but I don't want to have absl::string\_view for older compilers and std::string\_view for newer compilers. There's also the two different include files to keep track of. I don't like the ifdefs. If a new C based on 2011 C++ takes hold, it can adopt string\_view.
I suggest you read the paper that introduces the "Concept auto" syntax, so you can better understand the motivation for it and why alternatives haven't gotten consensus. I believe the latest one is [P1141R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1141r0.html).
I was thinking this is for real and just a really, really incredibly low-quality post! Haha! Ok if I'd seen the name I think I would've recognized it and then guessed it was satire :-)
I don't know if you have, yet, but I think a good and updated C++ book is the best way to make sure you learn the best practices and nitty gritty details of the modern C++ world. [This resource is great](https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) for choosing. C++ Primer is a good start, and then moving over to Meyer's book on Effective Modern C++ should get you going in the right direction. Also watch some of Herb Sutter's CppCon talks. Sean Parent has some good ones too. I really like CMake, but agian, there is a lot of different styles and outdated info online. [This book is amazing](https://crascit.com/professional-cmake/) if you want to learn the "proper" use of CMake, and utilize it's latest features. And there are some nice talks from CppNow that I can't remember the title of. But CMake is daunting at first, but once you start using it I find that it is quite good.
People seem to think that using C++ as 'C with classes' is a bad thing, but it isn't at all really. I think people new to the language feel pressure to use all the fewtures of the language, but that's an awful idea. Keep it simple, if you find yourself using the dark art of template fuckery then you're likely to be going down the wrong path unless you're rewriting the STL. Some of the videos from cppcon, etc profess new best practices, but again, they're not.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9k1kiu/good_modern_book_to_learn_c_and_data_structures/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt;I just see that newer compiled languages like Go or Rust don't have many of these problems People are steadily fixing the problems in Java and it seems to me harder and harder to justify C++ unless you're doing embedded on something with very little memory. They're adding much better control over memory layout (value types), SIMD instructions, much better facilities for wrapping native libraries, and ways to pre-compile code so you don't necessarily pay for "jit warmup". Go looks like a flash in the pan joke to me, personally. I don't know what to say about Rust yet. I just see that Java keeps steadily fixing its problems and obviating the need for C++ on many platforms.
Not sure about recent compilers, AFAIR, that will cause some compilers warning about dead loop.
Cargo. Definitely Cargo.
Younger people steer towards Java???
&gt; I think the standard library was a horrifying mistake I mean, what would you use instead?
`for(;;) { int const volatile x = 1; }`
&gt;Many compiler errors and cryptic and don't really help me to find given problem in my code. When I was learning std::vector I tried to create a vector of references. clang exited with around 400 lines of error messages. None of them descriptive enough (again, for a beginner) to show me what's wrong. This is quite frustrating, because I end up doing a lot of guess work. After seeing these cryptic template errors the first time, I actually put the C++ book back on the shelf and continued with C. That was a few years ago and the situation still isn't optimal. I agree with your other points as well.
&gt; I would really appreciate if my compiler told me instead of producing a program that does what I didn't intend In the original draft, if a function with the `noexcept(true)` specifer actually did attempt to throw an exception, then the behaviour of that program was undefined. The optimizer guys were eventually persuaded to accept that calling `std::terminate` in that situation was an acceptable performance compromise ... &gt; but they could warn in trivial cases I don't know about MSVC but [gcc will emit a warning](https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=gcc/cp/cp-gimplify.c;hb=212b6e316d456a33ae6dfb708a14167f8d7711ff#l1422) whenever the optimizer replaces a call to `throw` with a call to `std::terminate`at compile time. I assume that clang works similarly.
Java is still one of the most common languages used in teaching. (Yeah, I know... citation needed, feel free to google). It's because many business software jobs are done in Java. Also Java was very big for backend stuff, but that's not my area of interest so I don't know if that's still the case.
I would stop bothering with C++ and learn Rust immediately if that were a more demanded skill. Sadly, the industry I'm interested in (Embedded) uses predominantly C (I don't have a huge problem with that) and increasingly C++. I have seen zero Rust jobs in my area. Bit of a chicken-and-egg problem and of course inertia.
&gt;Even C has a very small standard library with string manipulation and a few tidy things like qsort() C does have some really stupid things like C99 complex numbers (complex.h) though. No idea why something like that was added. Stuff like that doesn't belong in the standard library of a systems language in my opinion.. that's more suitable for a dedicated math library or implementing on your own. 
I agree with you. That is pretty arguably a lapse of judgment. I am wondering if the availability of arch-specific intrinsics encouraged them to push adoption on the compilers... But it does seem out of place. 
You always have absl::string_view, and it's always available in absl/strings/string_view.h regardless of language level. It's just sometimes an alias for std::string_view. You shouldn't need any offers.
Well if he doesn't do any cpp no wonder he doesn't know about boost
I'd argue that GoLang is a pretty popular alternative rather than D.
That seems weird, seeing as for example KDE was mostly developed by German developers, and it's one of the largest and most successful C++ projects.
Fair enough. Go did gain some traction, but as far as I know, it can't compete in memory constrained scenarios.
While you're at it, you can also check out the brand new LLVM Compiler Toolchain plugin, it allows you to use Clang/LLVM, in a non-conflicting with MSVC way, including lld-link from the VS2017 IDE. You literally flip a switch.
Your post is very interesting, though I don't have enough background to fully understand some of your comments. Could you perhaps explain more by what you mean about the following: * "Moves could have been bitwise copies with compile-time invalidation" While I think I understand what you mean by bitwise copies, I'm not sure I understand what you mean by compile-time invalidation. And I would also be interested to understand more the negative consequences in your mind of the choices that were made for the current move semantics. * " Concepts could have specified required interfaces, instead they are slated to only specify *part* of the required interface..." I have a basic understanding of concepts, but am wondering if you could elaborate on the point you made regarding "specified required interfaces" vs "specify part of the required interface". Presumably some of the folks on the committee are aware of your point, but for reasons, the concept spec is as it is today, so I'm wondering what made the committee decide to create the spec that they've created versus something more like what you are thinking of? Aside from those things that you mentioned in your post, I am wondering what other technical aspects of current C++ language really bother you. &amp;#x200B;
I believe he is making a generalisation based on anecdotal evidence. By your description he doesn’t seems to be working on the embedded world, which is pretty much C/C++ and exists in any country. In terms of C++, take a look into MeetingCpp to see what they talk ans it’s pretty much the same. btw: Germany is huge in open source
ok yes undefined behavior would be way worse. also idk if GCC actually warns by default I just compiled something the other day with GCC and it had no issue with throw in a noexcept
I worked at a company that does embedded engineering. Like everybody there knew stuff like boost. (quote: "Boost? You mean the quasi standard."). Also they used all sort of libs (after quality checking those of course). I guess it rather depends on the person. I've met people doing their masters degree in computer science and never even heard of stuff like Git.
Well you're basically trying to compile two different languages together. Maybe object files should contain language ABI information but this could break old projects.
We have an office in Germany, and we use plenty of open source software. Our (German) customers haven't complained either, in fact they want us to step up our support for Linux. One thing I did notice in a few places was a desire of control over the software (whether for legal reasons, reliability, support, or other). These are all places where a software bug is potentially going to result in embarrassing worldwide news articles, hundreds of millions of euros of damage, and/or lost lives, so I can understand a certain reticence to bring in unknown, untested, 3rd-party code where you can't even sue someone if it breaks. However, I suspect that is more related to the type of industry than to Germany perse. No, the biggest difference in German C++ is the keywords: Vorlage &lt;Modellname M&gt; Klasse K { Ganzzahl g; Fließkommazahl f; M m; }; Other than that there is hardly any difference, as far as I can tell. Well, that and the fact that they make you use QWERTZ keyboards, so my typing speed gets reduced to hunt and peck typing... 
Aren't you trying to achieve ABI guarantees here where C++ doesn't offer any in the first place ? This is not about rtti, this is about lack of standardized C++ ABI
I cannot confirm this. I've been working both in the scientific computing and bio-medical (FDA approved products) field in Germany. MISRA was a no-go and C++11 at least the default. C++14 and C++17 were already introduced. &amp;#x200B; I really depends on what field you are working in. And from that statement above, I don't want to work in the automotive industry ever.
Are you for real? You use translated keywords? 
When c++17 removed `register` it already broke a good part of my code which includes C libraires which had it in their headers. I don't see how removing more would help. Any sufficiently laege codebase uses at least every part of the language once.
If you don't break from it it's undefined behaviour
The only difference as far as I can tell is that the bigger companies like to have much more control over their Software and are thus much more conservative. This makes in house development's more likely. Apart from that lot's of the German C++ jobs are related to the automotive sector, so anything that relates to that domain might be overrepresented in Germany. 
There are many things one would make different - some of these people have actually implemented languages of their own. A few things I'd do (Although I know that some of them would cause lengthty discussions, and some of them are not feasible) On my side, I would remove the automatic conversions of integer types. I love that there's a phasing out of the preprocessor - I feel less inclined with the recent standards to go for a smart macro substitution. I haven't used one intentionally since C++11 appeared. I do accept though that there's reasonable use cases for the processor, but I'd do as much as possible with constexpr, up to the point that even the platform specific definitions could be tested in a constexpr. So yes, I feel like I'd remove the preprocessor. I would also remove the #include, and go with something like modules from the start. I would probably keep around #pragma for *pragma*tic reasons, as it would be a good way to actually specify useful things (like this class needs the SDL or SFML library). I'd use the dot to separate namespaces, I'd use the dot instead of -&gt; everywhere. I'd make every class member function const noexcept by default, and every passed reference const by default. I'd remove pointer arithmetics outside of specially marked corners (some unsafe call), and I'd use a single notation for references and pointers. I think that reference vs. pointers is one of the toughest things to choose from, But this one I didn't think in depth. I have to think about it more.
I may overlook something obvious, but since register isn't a keyword anymore, wouldn't it be trivial to fix with a macro?
C with templates. 
It's still a keyword. It's just unused.
Oh. Well, then I don't see an obvious solution.
&gt;Part of the problem is the separate compilation model. Can we change that? Maybe there are much better models out there. Why wouldn't the compiler work like this? - There is only one file type, which is like a Pascal module. There are no headers. - The compiler maintains a database, listing the functions, classes, globals, etc. from each module. - Upon compilation, in stage 1 the compiler checks for updated modules, and updates its entries in the database. - In stage 2 the compiler compiles updated modules, using the information from the database. This model does away with headers, forward declarations, and include order, as well as the need to repeat every function name twice, and it guarantees there is only one definition for each thing so it is automatically consistent with itself. It vastly cuts down on compile time, on account of not reparsing millions of lines of header code in each translation unit. Consuming a library is as easy as importing its database. One file, done. Of course the database file is itself standardized (I would suggest something based on SQLite), so it works across compilers. This is what I expect from C++ modules. Not sure if it is going to be this good, but please give us this. 
If it's only about removal of stuff, I would go with std::vector&lt;bool&gt; and maybe more controversial std::variant (and make sum types a language feature).
Unsigned integer types. At least, in relation to container sizes.
Swift has the point of view that the safe way should be the default and that all less safe behavior should have to be opted in. e.g. * There are no `const` member functions. They are the opposite, in order to modify a member variable you have to state that the function is `mutable`. * The variable declaration is `let` or `var`. The general rule of thumb is to start with `let` and change it to `var` if necessary. This is as opposed to `int const` which requires a second word. * Functions can not throw unless you declare that they do via `func name(args) throws -&gt; ReturnType`. * switch cases don't have fallthrough. * switch cases must be exhaustive over all the cases of an enum OR provide a `default`. * Function arguments are copy-on-write copies or (basically) `shared_ptr`s. You have to explicitly declare an argument is modifiable. etc. Safe by default is the definitive superior choice that C++ unfortunately can never switch to.
&gt; And of course the user is going to write C object{};, because they've learned that writing C object(); led to the Vexing Parse (object is then of type C(*)()) and that Uniform Initialization was to be used for initializing objects. That's actually not quite the vexing parse. That's just a function pointer declaration. `C object;` is how you would declare a default-constructed instance of type C. Regardless, if you have another user-defined constructor (defaulting the default constructor is redundant otherwise), private data in your class, define the private constructor (`C(){}`), or you mark the private defaulted constructor as `explicit` the compiler will prevent aggregate-initialization in this context. I'm with you that this is confusing, but I don't think it's quite as sharp of an edge as it seems at first glance. `std::initializer_list` is indeed an ugly beast, but hopefully not one you face often outside of container initialization (where it is very helpful.) Once you can memorize the difference between `std::vector&lt;int&gt; a(1,2);` and `std::vector&lt;int&gt; b{1,2};` you should be good. Anyway, I do agree with the greater point that C++ is getting less simple as they add more features, as breaking backwards compatibility isn't an option.
auto
yes! i don't see why `v.size()-1` has to be a snake pit. 
Perhaps it would be an idea to separate C from C++. Have the compiler support both languages, but not in the same file. E.g. using new and malloc in the same file is a compile error. That way you can remove old C style things from C++. 
Good points that I agree with, but that goes a bit beyond just stripping things out.
Arrays implicitly decaying to pointers. Still have the explicit decay using &amp;arr[0] but avoid the implicit decay. To be fair we basically get that using std::array, but it feels like that should be the default and not the thing you learn about later.
What's wrong with variant?
Well, working in a German company designing and building industrial QS machines I can tell you there definitely is a difference doing C++ development here: we provide a German UI in addition to the English base UI! Besides that, ripping out all of the open source libraries would mean immediate shutdown of the company. We rely heavily on open source like Boost and tons of other libs - but with some scrutiny: all of those libs live in our in-house repositories and are typically heavily modified to compile without any warnings at the highest compiler warning level of MSVC (i.e. `/W4 /WX`, largely eqivalent to gcc's/clang's `-Werror -Wall -Wextra -Wpedantic -Wconversion -Wsign-conversion`). Otherwise I am totally free to use C++14 or C++17 in my code or even in-house libraries as long as it doesn't affect other projects in active development. I don't know how this is different from development elsewhere.
&gt; An iteration statement whose controlling expression is not a constant expression,156) that performs no input/output operations, does not access volatile objects, and performs no synchronization or atomic operations in its body, controlling expression, or (in the case of a for statement) its expression-3, may be assumed by the implementation to terminate.157)
On your second point: It's called concept definition checking and was originally part of C++0x concepts. Bjarne mentioned it in his CppCon keynote this year.
That's probably something for when we have modules.
Well, our certainly could be done, but I'd like top point ot that due to the copy-paste semantics of #include, the compiler doesn't (logically) see different files but just one giant translation unit. What is of course already possible is to have a separate .c-file that is compiled with a c compiler and write a c++ compatible header file - only exposing macros can be difficult. 
It's really cumbersome to use compared to similar features in other languages (most obviously Rust's Enum https://doc.rust-lang.org/rust-by-example/custom_types/enum.html).
That's a good point - I always do as you suggest (e.g. &amp;arr\[0\]). Can you talk a little about cases where you've been bitten by the implicit decay? Or about what real-world problems it has caused you or others you know?
&gt;very easy to misuse and produce slow code Like? &gt;you have to use exceptions Not true. LLVM for example doesn't use exceptions, but that hasn't stopped them from adopting modern C++ features. 
I like the default initialization mechanism you mention. Seems like it covers the common case as well as cases for the performance purist. I know I've seen discussions about 0 being implicitly convertible to nullptr being a bad thing, but can you elaborate on your thinking as to why this is a bad thing? What problems has it caused you or others you know? Can you talk more about destructive move semantics with compile-time-checking? What exactly do you mean there? And what problems the current move semantics causes that would be solved with destructive move semantics?
Just for clarity, I'm definitely open to hearing about things that could be changed. With that in mind, do you have additional ideas or thoughts that you could add to u/lanziao's list?
Thanks for the list and the pointer to stuff that you like about Swift. I agree with many/all of these. Definitely some good stuff there. Are there things you like about what C++ does that are not in Swift or where Swift gets things wrong in your opinion?
I've read or perused a few papers that talk about a native variant/sum type and seem to agree with their thinking. Have you read those papers? I'm definitely interested in hearing about things beyond just removal, so if you had thoughts on this front, I'd be interested in hearing them.
I've seen this comment at various times by lots of different people, so I don't think you're alone there. But in the spirit of having a consolidated list of knowledge, can you give a few paragraph explanation for your opinion on the removal of unsigned types?
I see lots of complaints about things that are a little bit bad, but what about the things that are really bad: trigraphs and leading 0 octal integer representation (This one is partially removed already and deeply evil). 
I've been thinking of this fairly recently, and had come up with a few ideas. Of the three biggest changes I want, one is non-breaking, so I'll just say "LiteralType non-type template parameters" and leave it at that ([it does appear to be coming in C++20, thankfully](https://en.cppreference.com/w/cpp/language/template_parameters#Non-type_template_parameter)) The first breaking change I'd make is to get rid of the current set of integral types (`short`, `int`, `long`, etc.) and replace it with a system similar to `&lt;cstdint&gt;`. However, I'd break the integers into two groups. The first group acts kind of like the `int_fastX_t` types, where the storage size of the type is not guaranteed, and overflow is considered undefined behavior (to allow for optimizations). The second group acts like `uintX_t`, having a guaranteed storage size and defined overflow. Both groups would have both signed and unsigned types. The size could even be a template parameter, and have the language use Big-Integer code when needed to support non-native sizes. The second change is something I came up with from my limited time using Swift. I would get rid of `NULL` and `nullptr` as they exist today. If you have a pointer, it must be initialized to point to an actual location (or it's undefined behavior if you don't). If you want to store a "null" type, you would use the type `std::optional&lt;T *&gt;`, indicating that the value can be null. This would significantly reduce ambiguity (especially for C-like interfaces), as the caller knows if null is an allowable type. I would replace `nullptr` with something (say, `nil`) of some type (say `std::nil_t`) that is implicitly convertible to `std::optional&lt;T *&gt;` for any type `T` (the same way that `nullptr` of type `std::nullptr_t`, which is implicitly convertible to `T *`). `std::optional` could even use partial template specialization and the value `reinterpret_cast&lt;T *&gt;(0)` to keep the type ABI-compatible with original pointers.
Every compiler I've used in the last few years can already do this
Interesting idea? In your estimation, how much of the problems that people complain about are due to the support of C style stuff in C++ and how much is due to just screwing up new features and how much is due to trying to force-fit some features in C++ into a C-style syntax that perhaps could be done a much better way?
Between this and some compiler settings, yes. This idea has been a feature of GCC/MSVC for years. 
I've heard people complain about allocators before. What are your complaints about them? Is it the way they are currently implemented? Or is it the idea of having allocators at all? Or some other thing?
auto certainly is used MANY places these days. Is there a particular aspect of auto that you don't like? Or is it the idea that the keyword is used for so many things? Or something else?
Fix "uniform" initialisation.
It's possible for `v.size() &lt; v.size()-1`
At least I can understand people. C++ is a language where you can spend ages of your time in solving problems that are only related to the language itself. This can be very frustrating if you have to deliver an solution for a real problem in time. When learning c++, and also later for a very long time, you constantly run into problems that leave you just puzzled. E.g. look at GotW #100/101 about Compilation Firewalls. Having to apply a pattern rated with difficulty level of 8/10 that still results in tons of obscure code, for something that should not be existent at all is no very encouraging when you try to find reasons to like the language you are learning.
Sounds very similar to US companies, at least. The "bringing in open source libraries and heavily modifying them" sounds like a bad idea though, unless you have some effective way to merge in changes from the upstream.
I haven't been bitten by it since my university days, but it was an giving me what the author calls "C++ apathy" while learning. Basically I felt that this was a big language wart that was inherited from the ancient days of the last century. If you have been using C++ for more than a semester you probably won't get bitten by it (unless you do a lot of template meta programming I guess. I'm not smart enough to understand the problems there) but for a beginner it is one more thing to worry about and learn.
In my opinion, removing the exception specifiers in C++ was a mistake. Exception specifiers to me seem like an essential element of documenting API behaviour. The problem (imo) with throw specifiers is that it isn't enforced at compile time, not that the idea was flawed. Checked exceptions in java make the use of exceptions far less error prone than C++ and for that reason most successful projects I've seen largely abandon exceptions in favour of return values. A better answer to this I think would have been to follow a java checked exception light approach. If a function provides an exception specifier then the caller must also specify the exception or handle it. Else, if a function doesn't specify an exception then the caller cannot either unless it provides a catch all. The noexcept and throw() approach to me seems like an acknowledgement that exception specifiers in their current form don't work well and an abandonment of them in order to facilitate performance improvements that are often not realised. &amp;#x200B; &amp;#x200B;
I'd like the standard to specify the floating point implementation. Almost everything uses ieee754, but the fact that it could be something else means we cant get compile-time floating point numbers. I'd like better solutions to heterogenous data structures. if i have a bunch of types with identical interfaces, and I want to add instances of any to an associative data structure, its incredibly tedious to have to do so via std::variant or std::any or whatever else. I'd like more explicit ways of stating whether something should be evaluated at compile time. Constexpr is nice but it's not a guarantee.
Would you be able to give a small example which illustrates how it is cumbersome it is to use variant in C++ vs the Rust Enum feature that you mention?
&gt;You can't... be serious... Uhm, no, I'm not ;-) 
- The header/TU build model is bad - Copy should require function call or operator by default unless you add an attribute saying otherwise. - Move should be destructive by default (controllable by special members or attributes). Use the new lifetime profile to check you don't use moved-from objects. - Implicit conversions sh have dedicated syntax (rather than being a single argument constructor) - Constructors should have names - Moves should be destructive by default - Initialization should only use braces, no parens - Undefined/uninitialized default initialization should not be a thing (have an explicit uninitialized syntax if you want garbage data, otherwise zero it) - std::variant is a band aid, should have language-level solution for discriminated unions and switching on them. I suspect you can get discriinated unions with metaclasses, but switching on them is what sucks the most, so unless we get full-on AST macros, we need a solution for this. Std::visit and the "overloaded" type aren't tenable. - The new lite exceptions (and 14ned's proposal for checked exceptions in C) should be the only kind of exceptions - Initializer list is too strange, should probably be a protocol/Concept like in C# - Operator-&gt; should not exist, dots everywhere plz - References are non_null pointers at best, and a strange philosophical problem at worst. Just have non-null pointers, pointers, smart pointers. - Drop ADL, rely solely on Concepts for what ADL was previously used for. - Allow overloading by Concept (e.g. like explicit interface implementation in C#). - What if SFINAE wasn't a thing? What if we just had D style static-if? - Relax TBAA rules significantly - Make reinterpret_cast imply object existence - Preprocessor should be dropped in favor of AST macros - Remove vector&lt;bool&gt; specialization - Rename std::array to std::fixed_array, rename std::vector to std::array - Designated initializers shouldn't care about order written. Just implicitly reorder them, and require that compilers warn about uninitialized dependencies (e.g. passing fields of member to another member's constructor when the first won't be initialized yet). - iostreams should not use operator overloading, string formatting should all be fmtlib - Drop RTTI as it exists in favor of the new static reflection, but also have a default implementation of full or partial (compiler flag + attribute controlled) runtime representation of type data with rich info and method name tables - Specify build system in-source, using build directives with room for implementation-defined configuration - I wouldn't remove const, but I'd want to think about how to make it stronger. I don't think it being entangled with threadsafety is a good thing. 
Certainly the current preprocessor seems like a universally disliked feature. What do you think about Herb Sutter's metaclass proposal(s). It seems they've sort of settled on a token stream insertion approach when generating code, which in and of itself is reminiscent of macros. I'm guessing you have (or would have) a positive reaction to metaclasses. If this assumption is true and if my observation that the token-stream insertion used in metaclasses is sort of the same as macros, it seems like your dislike of macros hasn't so much to do with their injection of tokens into the parse, but something else. Care to elaborate? In regards to undefined behavior, what are the biggest gotcha's you've seen with undefined behavior? Do you have a top-3 list of these? Or perhaps a top-10 list?
Thanks for the elaboration. Being a devil's advocate for a second, for a modulo number system like unsigned ints, it is expected that N &lt; N-1 can happen, or more generally, N &lt; N - D can also happen. What is the fundamental problem with this? How has this bitten you in the past in code?
Do you know if clang++ or g++ does this? If so, what is the command-line flags that I should use to try it out?
I absolutely agree with that. I have yet to see any code with trigraphs in it and it's been a long time since I've seen octal representation being used for anything.
So the main problem for current false positives is the fact that the analysis uses a local approach for being fast and applies heuristics at function boundaries to prevent the need to scan the whole program top to bottom? This sounds like a perfect match for upcoming modules, that will translate the program bottom to top. The module system should be able to provide the missing meta information for functions.
No, not me, I'm not German. I just work there sometimes. And actually - no, they don't either ;-) 
I think a lot of people complain about this. Do you have any thoughts on what you would do to fix it? I'm guessing you'd get rid of initializer lists as one step? Other thoughts?
Remove everything from C which have been superseded by C++: arrays, typedef,... Also const everything by default. 
This is an awesome list!!! I will try to follow up with you tomorrow when I have more time. Thanks!
Metaclasses don't provide reflection, they use it.
Wow, I'd never thought of this or even heard of this before. But I can imagine this could be a problem in detailed numerics work. Have you run into specific issues where this ended up being a big problem for you? If so, would you care to talk a little bit more about the context?
What’s wrong with std::vector&lt;bool&gt; ?
Technically, `arr` and `&amp;arr[0]` are not the same. One points to the array and the other to the first element of the array. The difference starts to matter when you have multi dimensional arrays.
C++17 got rid of trigraphs.
How so? I was disappointed -Wlifetime uses heuristics instead of a real analysis without false positives.
What would you expect the return type of `std::vector&lt;bool&gt;::operator[]` (non-const) to be? Because the correct answer is **not** `bool &amp;`.
Eliminate square bracket (c-style arrays), eliminate C-style strings ("Hello World" would be a string not a const char *), and have main just take a std::array of strings for command line parameters. Probably something with pointers as well. 
it makes code which *looks* like it's correct, fail in a common case. Consider this: ``` // iterate over every element except the last one for (size_t i = 0; i &lt; (v.size()-1); ++i) { /*...*/ } ``` One must check whether the vector is empty; with a signed integer type this wouldn't be a problem. While this is easy to spot in isolated examples, similar code has passed code reviews way too many times.
oh my. That’s pretty gnarly.
I have. For example, I've released our Boost 1.68 at the very same day as vanilla Boost 1.68 came out. I'm not happy having to modify libraries to meet some quality standards, but not every library maintainer is keen on taking pull requests regarding squashing compiler warnings.
Good example! Do you know whether any compilers statically check for potential unsigned underflow, such as the example you've show, as a warning? If so, can you point out the compiler and warning flag? If not, do you think it is a reasonable check that could be added or are there too many potentially false positives for such a check? By false positive, I mean that presumably, there will be some subset of programmers who have written the above snippet who actually know that v.size() is always &gt; 0 in the context and so for them a warning would be unwanted noise.
`#define register ` maybe? I seem to recall doing that in the past to get rid of a compiler warning.
Remove all support for treating `char*` as a string from the standard library.
&gt; LiteralType non-type template parameters Why? Literally all this does is making template code harder to write.
Do you have a more extensive list of things that have been superseded by C++?
Interesting! Why do you think that square bracket operator is a problem? One thing that C-style strings are used for is specifying the contents of a small chunk of memory in a convenient way. Do you have any thoughts as to whether another feature would be suitable for this use-case? &amp;#x200B;
Make everything default to const. Unify function syntax and lambda syntax. Rewrite template syntax with readability of advanced template meta programming in mind. Fold macros into template syntax.
&gt; I'd use the dot to separate namespaces, I'd use the dot instead of -&gt; everywhere. How would smart pointers work in that case?
I'd love for something like this to be an opt-in feature, where you can use an explicit standard type by using "float/double754" but using "float" would default to the compiler vendors default choice.
Lots of people using sizeof after passing a dacyed array to a function
&gt; Literally all this does is making template code harder to write ... It'd for example make `std::array` nearly impossible to use. I'm not sure I see how that's the case. All it would do is expand what can currently be done. I also don't see how it could make "nearly impossible to use", as it would still work exactly the same. `std::array&lt;int, 10&gt;` would work the same way as it always has. All it changes is what non-type parameters are allowed. Currently, the only non-type parameters allowed are basically integral types and pointers/references (enums and `std::nullptr_t` are also allowed). This means that you can have a template like `some_type&lt;1&gt;` or `int x; some_other_type&lt;&amp;x&gt;`, but not much else. This change adds more types that can be used. Now you can use types like `std::pair`, `std::tuple`, and maybe even `std::string_view`. I already gave up on a project because I knew it would be impractical without LiteralType template parameters, so I might go back and give that another shot if/when the feature is finally added.
How about: for(auto i = begin(foo); distance(i, end(foo)) &gt; 2; ++i) { /*...*/ } It's not pretty at all and is certainly not something one would write without thinking, but it avoids this problem.
`register` was deprecated in C++11 before being removed in C++17, so you had 6 years to prepare.
i don't get bitten so much by it. the errors are also usually very obvious during the first run. but doing unsigned arithmetic often means having to be _very_ careful with arithmetic. i guess it's easy to make up an infinite number of examples where unsigned ints require you to be extra careful: // iterate the elements from 0..n-1, the wrong way: for(size_t i = 0; i &lt; vec.size()-1; i++){ float diff = (vec[i+1] - vec[i])/dt; ... } // one of the right ways: for(size_t i = 1; i &lt; vec.size(); i++){ float diff = (vec[i] - vec[i-1])/dt; ... } // similarly, strip 3 chars of the wrong way: auto sub = str.substr(0, max(0, str.size()-3)); // and one of the right ways: auto sub = str.substr(0, max(str.size(),3)-3); // is vec_in at least 2 elements longer than vec_out? wrong way: if(vec_in.size()-2 &gt;= vec_out.size ) ... // right way if(vec_in.size() &gt;= vec_out.size() + 2) ... &gt; for a modulo number system it is expected that N &lt; N-1 can happen just to be clear: both, the signed and unsigned ints are a "modulo number system" (finite field). _unsigned_ is the keyword here. what i'm saying is that having them signed would allow a lot more flexibility in writing out simple data processing algorithms and require a lot less care. 
explicit one-parameter constructors by default.
Basically what templates accomplish is compile time code generation, but the instructions for this generation are written in a very convoluted syntax that was never intended for the complex patterns it now supports. It's a mess of v braces, lists of types, and typedefs. It could be accomplishing very simple things but it is neigh unreadable for a novice, so I've seen many firms avoid it all together. My wish is that there were a way to write compile time code that generates types. This could be accomplished by a form of compile time reflection. The only real uses I've seen for macros where they are irreplaceable in modern C++ are in the areas of code generation. If we're already dumping a fully fledged compile time reflection / generation system into the language I'd say cover what now macros alone can do and get rid of em. As for functions and lambdas, make a "void function () {}" stament assignable to a function object, integrate capture syntax into function definitions, and then fix everything you broke along the way to make it happen.
&gt; In the ideal world, with the existence of all the various flavors of operator new, do you think that it is still required to have malloc and friends? C compatibility, so yes. Right now valid C code is full of UB if compiled as C++ because "malloc does not create an object". &gt; Understanding that it is really hard, I'm curious as to whether you had any thoughts about how you might constrain implicit conversion or what are the various problems you've run into in your thought-experiments doing this? Oh boy... I tried to organize my thoughts and write it comprehensively, but couldn't. Take two, I guess: - You don't want implicit narrowing or implicit differing sign comparison. The latter is especially sneaky, because it works most of the time and rules regarding those are just strange. - From there, let's say you want to just leave implicit conversion going from smaller integral types to larger. - What about literals? Right now `5` is `int`, but `5.` is `double`. This might be fine... - Do we want implicit conversion of `int` to `float`/`double`? Probably. - What about the other way around? Should `float` implicitly convert to `int`? You're losing some data, but you're losing the same kind of data with integer division. - At first thought custom types should not be implicitly convertible, but that makes `std::optional&lt;T&gt;` terrible to use. - What about a `class MySpecialSnowflakeInt { int foo; };`? usually you wouldn't mind implicit conversion from `int`, but there's a posibility you created `class FileDescriptor { int fd; };` with the sole purpose of avoiding implicit conversion. &amp;nbsp; Bottom line: I'm not smart enough to say where the line should be drawn.
It is undefined behavoior to #define a keyword. But this is the solution I initially thought of, because I thought that it wasn't a keyword anymore.
Good idea. The C11 standard also have optional stuff, so it quite feasible to do.
&gt;It is undefined behavior to #define a keyword. I did not know that. It makes sense, but I didn’t know that was part of the standard. That being said, if the compiler your using handles it in a specific (and reliable) way, you could always just do it. I’m doing that in a project of mine (relying on the fact that allocating with `operator new[] ()` and freeing with `operator delete ()` works just fine on all compilers I tested, despite that being technically undefined behavior) (and no, I’m not talking about the keyword `delete`, but the memory operator that doesn’t do any destructor calls)
"Allocators are to allocation what vectors are to vexation"
What do you mean, compile-time fp numbers?
There are platforms where this would make the subscript operator very expensive. 
&gt; Remove everything from C which have been superseded by C++: arrays, how do you think std::array is implemented ?
&gt; Implicit conversions sh have dedicated syntax That kind of defeats the purpose of implicit conversion. &gt; Undefined/uninitialized default initialization should not be a thing (have an explicit uninitialized syntax if you want garbage data, otherwise zero it) Except that I recently have seen a bug in /r/cpp_questions, about which compiler complained because `int`s are not initialized by default. Zero initializing the local `int`s made compiler silent, but the bug was still there. &gt; Operator-&gt; should not exist, dots everywhere plz I think it is useful as it adds a certain degree of clarity, if you ask me. There's `(*foo).bar`, but that is unreadable. &gt; Preprocessor should be dropped in favor of AST macros AST macros? What about metaclasses? &gt; Rename std::array to std::fixed_array, rename std::vector to std::array I think the current names are clearer. &gt; Designated initializers shouldn't care about order written. Just implicitly reorder them, and require that compilers warn about uninitialized dependencies (e.g. passing fields of member to another member's constructor when the first won't be initialized yet). The problem is that initialization of one member variable could depend on the value of another member variable, hence the order matters. :/ &gt; Specify build system in-source, using build directives with room for implementation-defined configuration Can you elaborate? I have no clue what you're talking about. &gt; Expression blocks should be a thing, immediately invoked lambdas are just a crutch for not having this. Why do you think that immediately invoked lambdas are a crutch? &gt; Locally scoped functions (not lambdas, more like static methods on a local class) should be a thing. I've seen this in python and it always looked unreadable to me. Probably the lack of braces. &gt; Have explicit enum exhaustiveness checking in switch statements, and make adding a default case not bypass it (sometimes invalid values sneak in despite best intentions). Sometimes there's a hardware bug in your custom designed PCB, so you end up with a random value not covered by your enum values. \*sigh\* &gt; Implicit conversion between int, bool, and pointers. I don't think I'd hate writing "if (x!= nullptr)" everywhere instead of "if (!x)" Sometimes I like this. Other times I've shot myself in the foot.
Rust. 
&gt; Rename std::array to std::fixed_array, rename std::vector to std::array &gt; I think the current names are clearer. No, they are not. For anyone who had an hour with graphics programming or maths or knows physics, vector is a totally different thing.
1. Remove implicit type conversions. 2. Safety first, then performance, instead of performance first, safety second; that means no more C while doing C++, except when explicitely declared. 3. By default, all pointers would be shared; raw pointers to be used by explicit declaration only. 4. Everything would be an object, all types would be classes; for example, int[10] would be array&lt;int, 10&gt;. 5. Strings would be value objects. 6. Template specialization on floats/doubles and strings would be allowed. 7. Literals would have special types. 8. All types would have operator =, comparison operators, copy constructors etc automatically, except when they have raw pointers in them. 9. Basic integer types would be byte, short, int, long and their unsigned versions, i.e. 8/16/32/64 bits integers on every platform. 10. Remove implicit struct padding; make it an error if struct layout is not compatible with current cpu. 11. Char would be different type from byte. 12. Remove break from case statements; make case statements accept multiple expressions as criteria. 13. Use [] for template parameters instead of &lt;&gt;; use () for array access. 14. Arrays could be multidimensional. 15. Array access would by default check index against bounds; special bounded types would allow array access without bounds checking. 16. No more global namespace. 17. No more header files. 18. No more struct keyword; each class would be a struct. 19. Use the keyword abstract instead of '= 0' for virtual abstract methods. 20. Virtual methods would be impossible if the base class did not have a virtual destructor. 21. Operators new/delete would accept the allocated type as a template parameter. 22. Variables would be typed with the line and file that they are declared at. 23. By default, access to global variables or to variables of surrounding context would be const. 24. Functions would be allowed to return multiple values. 25. Functions would be allowed to be called with named arguments. 26. Referencing a template function/class without template arguments would be allowed (there would be no need to turn template functions/classes into concrete classes with templated operators and declare instances of them). 27. Instead of the static ketword, the oveblic, private and exported would be available for symbols at top level. 28. Shared libraries would get first class treatment and a common heap. 29. Fibers/coroutines would get first class treatment. 30. Actual message passing would get first class treatment (i.e. not only we would have virtual functions but also message functions). 31. Side effects would be mandated to be visible in the order expressions are declared...i.e. no more ambiguity as to which side effect should be visible first. 32. No more undefined behaviors. 33. All types would have a literal form. 34. The syntax keyword-parenthesized expressions-block would be overridable. 35. Variables would be allowed to be declared in an expression list. 36. Operator dot would be overridable. 37. No more the compiler would have a standard library; instead, it would have a standard library manager and library site, where the standard library would be available by default. 38. Move operation would be destructive; no std::move would be needed. The list is by no means exhaustive, it is just a list of things on top of my head; also, I did not add a lot of very cool features the language doesn't have but could easily get.
const operator[] for std::map 
I'd remove the class keyword and stick to struct. (and along with that, I'd allow the private/public/protected keywords to be used with structs).
Amen about Octal.
LLVMs module system works for C, C++, Objective-C, and Objective-C++. Not sure about Microsoft's proposal tho.
But are `std::array` and `std::fixed_array` really unambiguous? Why not `std::dynamic_array` and `std::fixed_array`?
libC++ supports filesystem, tho I think it's still in the experimental branch.
So I'm curious, why was `std::vector` named vector then, who named it like that, and maybe for what reason(s)?
Removing all the C only constructs especially C arrays and strings. Is there a compiler option to disable them?
That's why that part ended with question marks. I have no idea what AST macros are.
to prepare for what ? the problem is not in my code, and I cannot go to each linux distribution and ask them to change the C libraries they ship so that they work with my C++ code
yes, but how does its internal storage work ? [here's a hint](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/array#L50)
Void types.
How does signed improve _any_ of those problems...? You still have to check for negative indexes.
Like /u/lrflew said, the return type is *not* `bool` or `bool&amp;`. You can't do the folowing: std::vector&lt;bool&gt; foo{true,true,true}; bool* bool_pointer = &amp;foo[1]; // bool&amp; bool_ref = &amp;bool[1]; doesn't work either.
Developer from Germany and I don't think you can make such a generalisation. All that hugely depends on industry or even actual project. And it's not unexpected that in the embedded domain they're not aware of Boost. Are they even using C++ or is it mostly C?
Just leave it as /r/c_language
That's more conceptual than technical. Technically &amp;arr[0] is just (arr+0). 
The opinion of Scott Meyers, who has certainly spent lots of time thinking about the interactions of the accumulating features of C++: [Breaking all the eggs in C++](https://scottmeyers.blogspot.com/2015/11/breaking-all-eggs-in-c.html) 
have you ever tried lisp? or d macros? it's magical! (ik lisp macros are not compile time but it's the same idea)
this means that std::array&lt;int, 5&gt; which is basically struct array { int _impl[5]; }; would become struct array { array&lt;int, 5&gt; _impl; }; you can easily see why this does not work
I'm curious, why the signed sizes?
My thoughts. - Have initializer lists as a proper type (that is, that you can move elements from, and that actually stores them. Would be similar to std::array.). - keep the {} syntax or make it {{ }} if necessary - remove uniform initialization syntax -- allow only Type name{} to default initialize.
This code compiles, but has unexpected behaviour: #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;bool&gt; bv{false}; // 'auto' should make a copy, but doesn't because bv[0] gives a proxy type auto b = bv[0]; b = true; std::cout &lt;&lt; std::boolalpha &lt;&lt; bv[0] &lt;&lt; '\n'; } 
They point to the same address, but can differ in type, so your compiler will be very cross and tell you "hey, if you want this to work, you'll need to pass -fpermissive".
I've tried approaching lisp, but the syntax is so strange and foreign that, combined with terminology I don't know very well, I could never go through even the basics. I guess I'll take a look at D macros. Thanks for pointing me in a general direction.
Why not? In the span of 6 years one could easily make bug reports or pull requests for the distributions he supports.
`[:|||||:]`
Good point. I guess that really comes from `vector&lt;bool&gt;` having been introduced into the language much earlier than `auto`.
&gt; 16 bit processor with 64k address space Didn't think about that. So... I guess we need to be stuck with unsigned `size_t`.
I am not aware of such an option. Would be very interesting to have a -Wcarray that warns you when declaring a c style constant length array non-dynamically. On the other hand int* x = new int[n] would have to remain of course.
I really enjoyed this talk. I like how Kate addresses important aspects of software engineering, which in my opinion make the difference between ok or good code and really excellent code. 
I have hopes that in the future I can see all of this implemented into a new language based on C++ and be able to honestly say that C++ is not my favourite language.
The more I look at it the more I think "this is why C programmers hate C++". If you do this, better have a good explanation *why* and "unsigned size_t" shouldn't be the only answer. Also, that's an off by one error. I'm actually skipping last two elements, which just speaks of the "cleverness". &amp;nbsp; &gt; To debug something you need to be smarter than you were when you wrote it. If you're as smart as you can be when you write code, how will you ever debug it? \- I don't know whom I have just paraphrased.
&gt; Concepts could have specified required interfaces, instead they are slated to only specify part of the required interface, so it's likely requirements will accidentally slip in and diagnostics will continue to span pages upon pages in our terminals. They tried that; it was called checked concepts. The idea was that the template code would be checked to ensure it only used what the concept provided. They even implemented it. It was insanely slow to compile and they couldn't figure out how to make it faster, and they kept on falling off-track getting it into the standard. So they shed checked concepts (at least for now) and pushed at getting concepts in. I do not think there is anything about the current proposal that blocks adding checks to templates. Maybe when we can export templates via modules (and not have to reparse and compile and check it in every source file that refers to them) checking will be cheap enough. 
&gt; ik lisp macros are not compile time There's `eval-when :compile-toplevel` and `define-compiler-macro` in Common Lisp.
Get rid of implicit generation of copy constructor and assignment operator. 
You can already use private/... with struct a though. Why would you remove class?
There is a proposal for this: Regular Void.
&gt; Copy should require function call or operator by default unless you add an attribute saying otherwise Why?
No you don't get it. My point is that the std::array would become a language level class and not a library class; and then the implementation details is at compiler responsibility maybe like an intrinsic but I don't care. As an example in C#: int[] myIntArray = new int[5] { 1, 2, 3, 4, 5 }; int len = myIntArray.Length; // = 5 here `myIntArrays` type is `System.Array` which comes with all methods tied to Array class **as member functions and not free function**. But as said I my original post, UFCS would probably overcome this.
Note: what you found about private = default is, I believe, a known defect about aggregates, that has simply been overlooked but IIRC will be fixed in C++20. Unfortunate, but yes, given the complexity of the language, those things are probably bound to happen. I would not call that chaotic, though. It's a spec bug. It's like a software bug that would sometimes happen even in a well maintained project. Not a manifestation of chaos. 
To clarify a bit, `std::vector&lt;bool&gt;` is an awesome structure and is useful. It was just a mistake to call it `std::vector&lt;bool&gt;`.
yes altho doing it at runtime is so cool
&gt;Container sizes should be signed Totally agree. I watched a few videos on the usage of unsigned types. All my colleagues are like "what if the value can't have negative values, like mass or something else"... and I'm like: So what? Do you really think that is OK to say `--i;` when `i` has value `0` and get still a positive value? How will you check that for problems in the code? You can't. &gt;Implicit conversion between int, bool, and pointers. I don't think I'd hate writing "if (x!= nullptr)" everywhere instead of "if (!x)" This would be nice. &amp;#x200B;
IIRC someone who was involved or around when they were working on implementing C explained that the pointer notation that C got was an experiment. And that time has taught that that particular experiment was a failure.
The "pointless" flush might be just what you want, but certainly. &gt; What some guidelines require is using pointers instead of references. I worked under such guidelines for five years. I internalized it, but then when I left, I went back to using references whenever I could... 
if you have side effects inside the loop it is not
Remove structs as a keyword and use only classes and remove implicit private on classes :) (or do the same to struct) Maybe be nothing about dropping something but replace the extern "C" with a defined export, so not every compiler does his own thing :P and if its not overloaded or in a class use extern "C" Syntax to export it &amp;#x200B;
Inheritance
Then somebody decides to replace vector with a list and get quadratically-running algorithm instead of compile error :p
Optional stuff is silly. Either put it in or let it out. The whole point of a feature being standard is that you can expect it to be there.
So how would you consume C libraries? Including OS headers?
I don't see any particular problems with that. Could you specify what problems specifically would be a problem?
How is `int _impl[5]` implemented today?
I don't know exactly, but it annoys me that there's often two ways to do things. One C and one C++ way, but it's always heavily frowned upon to use the C way. Itd be much clearer to only have 1 way to do it and deprecate the older one.
&gt; Noone should use an unordered map in generic code without exposing hash customization. so how is this supposed to work with something like boost.graph where a single algorithm can operate on a dozen structures ? have three lines of template parameter declarations ? And why should something that is an implementation detail and could change from a release to another be part of a public API ? this is against all sane design.
Exactly float754 would always be standard compliant at the cost of performance, while if you just want the systems best float value you'd use float
Can you? I haven't tried it, I just assumed you couldn't. As for your second question, because "structure" defines what it actually does far better than "class". Shit, even "object" would be more descriptive than "class".
I'd begin with *requiring* warnings on things we now have better options for. E.g. if you do not write `override` but you are overriding something, you get a warning. If you don't write `[[fallthrough]]` but you are falling through, warning. If you use an old-style cast, warning. This subtly pushes code to use newer and safer styles without immediately breaking everything. I'd add a way to inform the compiler you can take new keywords (`[[standard=c++20]]`), so this endless dance of introducing new meanings for `static` can end. I'd change the way the language is built to completely eliminate header files, as per my earlier comment [here](https://www.reddit.com/r/cpp/comments/9jwdpf/journeys_towards_c_antipathy/e6wcl0w). I would eliminate UB where reasonably possible. For example, `char c = 0xFF; toupper (c);` really doesn't need to be UB. 
1. Default const, qualifier for mutable 2. Get rid of references, but add a real std::non_null&lt;T&gt; (ala gsl). 3. vector&lt;bool&gt; needs to be an actual vector&lt;bool&gt;, use a different name for packed bits. 4. Better threading primitives 5. static_if for templates to replace some ugly SFINAE 
&gt; Operator-&gt; should not exist, dots everywhere plz Would be really annoying for smart pointers; you'd have to say`(*p).x` or `p.get().x` every time you want to access their pointees.
It's a non-obvious performance hit that is hard to track down exactly where it's happening.
Making a constructor with initializer list the better match was a bad call, reducing the usability by a percentage close to 100. E.g. `string{ 5, 'x' }` which just gives you a 2-character string, or ditto `vector`. That means that the old round parentheses syntax *must* be used here and there and then is significant, so for me, after a period trying out the intended "use curly braces always for initialization" I concluded it just wasn't practical to use curly braces except where it's actually needed.
(Yes, Meeting C++ 2017 was quite a while ago, but this was just published and it is a very thorough trip report)
I would make variables `const` by default, with e.g. keyword `mutable` or `var` to make them mutable. And add an `optional`-like type that allows a parameter to be logically `const` except for one operation, namely extracting the value as an rvalue reference. And add a mechanism for writing a `const` plus non-`const` member function pair as one general declaration. The first point would break C compatibility. So it would be a very different language... 
That's exactly what I meant, thanks.
And when the maintainers reject your patch because they are coding C and everything is fine in C?
&gt;There are no const member functions. They are the opposite, in order to modify a member variable you have to state that the function is mutable. I agree with this in principle, but man would I hate that porting effort. &gt;Functions can not throw unless you declare that they do via func name(args) throws -&gt; ReturnType. This seems like a good idea in principle, but in practice exceptions are so ubiquitous even in the standard library that it would be a real headache trying to implement anything beyond Hello World. Add a function call inside of your in-house library and suddenly 18 layers of software have to be re-declared with execeptions. &gt;switch cases don't have fallthrough. switch cases must be exhaustive over all the cases of an enum OR provide a default. The first would prevent a pitfall for novice programmers, but greatly weaken the power of switch blocks. The second would also greatly reduce the utility of switch blocks. Switch in most normal uses is a substitute for a long if/else if/else chain that is only switching on a single variable. I sometimes use it when it would be more terse than writing the if/elses, and requiring all cases to be covered would just mean I use it even less than I do now.
Switch case fall through can be very useful though.
 “Within C++, *there* is a much smaller and cleaner *language* struggling to *get out*” [http://www.stroustrup.com/CVu263interview.pdf](http://www.stroustrup.com/CVu263interview.pdf) &amp;#x200B; Lots of the complexity of C++ is for the libraries. Ordinary users don't need to know everything to use the Standard Library. New users can be taught a much simpler subset of C++ and not worry about what goes on in the libraries. &amp;#x200B; Also if you want to code in a new language then there is still the problem of converting the legacy code. It would be easier to convert older C++ into newer, simpler, modern C++.
"fun" fact: you probably can't use that "extra" bit worth of information in the size_t anyway because you can only use half of SIZE_MAX (which is PTRDIFF_MAX) for a single object on many platforms.
That's not an artifact of C heritage. That was a design decision by Bjarne. He believes having multiple ways of doing things is better, allowing professionals the freedom to choose different implementations for their design purposes. I am really glad for it.
Remove implicit type conversions. They lead to so much buggy and unexpected behaviour.
So you don't have those endless signed / unsigned mismatch warnings that come from typing 'int' instead of 'unsigned' for your index variable, in for-loops. 
&gt; because bools in std::vector&lt;bool&gt; are packed They *might* be packed.
Even worse!
"Hey let's make a `vector&lt;bool&gt;` that fucks up the `vector` API so that we can pack `bool`s instead of creating a dedicated data structure for it. Gotta have a poster child for template specialization!" "Why make the bit-packing required when we can make it optional instead, thus defeating the entire point of this specialization?" "APPROVED"
What would you have it for on lookup failure?
That sounds about right. I'm usually not the one to call out committee for poor choices, because every choice is some kind of compromise, but `std::vector&lt;bool&gt;` is just evil.
&gt; Locally scoped functions (not lambdas, more like static methods on a local class) should be a thing. So, exactly like non-capturing lambdas?
You lose the side of the array when you pass it to a function.
I think the only reason for separate new/delete and new[]/delete[] was because of the decay. The compiler cannot distinguish between arrays and single elements so that job is passed onto user.
Some people even like to relay on the strange behavior of mixing signed and unsigned things without realizing that much of what they are doing is undefined behavior which means the optimizer is free to rearrange their code in ways that give totally different results.
If you subtract two sizes you get a signed result. If you're going to use arithmetic then unsigned numbers become annoying real fast. 
They just want more syntax. I agree it dosn't matter and it's not worth cluttering the language with more things to type a few less characters but it's a valid perspective. I'd rather more painful things got fixed instead.
&gt; so for me, after a period trying out the intended "use curly braces always for initialization" I concluded it just wasn't practical to use curly braces except where it's actually needed. This was exactly my team's conclusion as well. In theory, it's "uniform". In reality, it does such *weird shit* for someone who's expecting it to match like a constructor call that we also abandoned it. Current style permits it only for types with public members and without any explicit constructors... so the same structs and arrays we've always used it for.
&gt; Exactly float754 would always be standard compliant at the cost of performance Unless the hardware implements the standard.
Meta request: I want compilers to have a flag like `--backwards-incompatible-opt-in=1..10,12,14..17`, with these numbers corresponding to a list of breaking features decided by the standards committee, which are constantly added to. Many good options in the other comments. Better yet, some kind of namespace-alike feature to turn these on, so it is easier to mix old and new code. The whole problem with improving C++ is backwards compatibility, so lets solve that first. I can't switch to Rust because I work on gigantic C++ code bases that will never be rewritten. But gradually improving these code bases with opt-in changes is totally viable. 
One could argue that the op's question is silly. I can't remember who said that the worst mistake about Unix is the naming of creat. I understand. 
`~thread()` should not `terminate` if the thread is joinable. This madness makes the bare std::thread unusable in the presence of exceptions (in other words - always).
There is absolutely no difference between a class declared using the keyword `class` and a class declared with the keyword `struct`, **except** the default access specifier i.e. the accessibility of members and bases whose access wasn't specified explicitly. Nothing in the language prevents you from using access specifiers in a class declared using keyword `struct`. Now, naming class to object would make it completely incomprehensible to people who expect conventional object oriented nomenclature.
I tried googling it, but I can only offer you links to furniture stores. I was worried that I was the only one not familiar with the term.
I agree with much of your list, but there are a few that I don't think make sense: * Constructors should have names Why? Is there a benefit to writing T::__construct() over T::T() ? or similar? * Operator-&gt; should not exist, dots everywhere plz How do you propose accessing members of a smart pointer or iterator itself and not members of what they refer to? (ex: std::shared_ptr&lt;T&gt;; ptr.get() vs ptr-&gt;something(), the get() is a member of shared_ptr, not of T). * Drop ADL, rely solely on Concepts for what ADL was previously used for. How do concepts address what ADL does at all? * What if SFINAE wasn't a thing? What if we just had D style static-if? C++17 introduces the first efforts to have this, and yes, its goal is to deprecate almost all uses of SFINAE * Make reinterpret_cast imply object existence What does that mean? Are you saying that reinterpret_cast&lt;T *&gt;(nullptr) should throw an exception or something? * I wouldn't remove const, but I'd want to think about how to make it stronger. I don't think it being entangled with threadsafety is a good thing. I don't see how const has anything to do with thread safety... The only relationship they have as far as I know is that a const object can be read by as many threads as you like, but only written by one at a time. Which is logically sound (matches reader-writer lock semantics for a reason). * Locally scoped functions (not lambdas, more like static methods on a local class) should be a thing The difference between a locally scoped function and a locally scoped lambda is what exactly? Can you elaborate on this?
You could use pragma poison for your entire codebase
You’re breaking the ODR...at least conceptually. 
I would go further and say that this could simply be the syntax for lambdas. There could be an optional trailing capture declaration like in PHP: ``` auto foo(int x) use(list, of, captures) { ... }; ```
Sure, why not seems reasonable as long as there are 1 or 2 standards that accept both ways so stuff doesn't break immediatly. To avoid confusion i typically use separators: `0'377`
A for loop runs until the second clause evaluates to false. `istream::operator&gt;&gt;` returns a reference to the stream, so it's the [stream's `operator bool`](http://www.cplusplus.com/reference/ios/ios/operator_bool/) that determines when the loop ends.
Yeah, I have no problem with supporting octal, it is mostly just the way it happens by mistake, and it used to happen to input the user typed in as well.. 0c would be much more explicit. I'd also like to see them support binary with 0b. 
Yes, that's my point. If I flip on `-standard-math` or whatever, and I'm targeting an architecture (or extension) that complies with the standard, it should emit hardware instructions. And if I'm targeting an arch that doesn't have standard floating point, I get software emulation. You could even detect at runtime and thunk in the right implementation. This is pretty much the same as soft vs. hard float support on ARM.
RAII. Templates.
Ah, great. I'm still behind the times with my outdated C++11 knowledge. 
That's an interesting idea. I actually like the assignment. It makes it clear that lambdas are first class.
Destructors, Move semantics, templates
If I had to name 3 it would be Destructors (RAII), type safety and generic programming. Especially generic programming. You could remove the `virtual` keyword form the language, I wouldn't be so lost. Just give me overloading and template, I can create polymorphic wrapper for easy to use polymorphism. RAII is a must. No question asked, RAII everything. Also, lambdas.
No. Bjarne has been behind several additions to C++ that gave a second, third or even 4th way to accomplish tasks. There are great reasons to have multiple options so that implementers can optimize for different purposes. 
Lambdas were something that, coming from Python, were totally natural for me. Type safety and its benefits took some getting used to when I moved from Python to C, but now that I'm on the other side, I see it as a huge advantage in a language. Dynamic typing now seems more weird to me than static typing.
RAII is the kind of acronym I was hoping to find when I posted this! Thanks for giving me some Sunday morning reading :)
When programming in Lisp you should use something like [Smartparens](https://github.com/Fuco1/smartparens) strict mode. Otherwise it's like programming C++ in Microsoft Word :) (list 1 2 3) ; create a list containing 1 2 3 &gt; (1 2 3) '(1 2 3) ; shortcut to create a list (what you write is what you get) &gt; (1 2 3) `(1 2 ,(+ 1 2)) ; ` is like ' but allows to compute values with a comma prefix &gt; (1 2 3) (defmacro sum-list (lst) `(+ ,@lst)) ; destructs list, returns (+ list-values) -&gt; AST transformation (sum-list (1 2 3)) ; expression is transformed into (+ 1 2 3), then executed &gt; 6
Is also like to add to that lambdas abstracting to iterators (and soon ranges) Type safe sum-types In general, modern C++ uses the type system a hell of a lot more. Making the compiler do the work for us. Brings forward many issues that can be caught at compile time rather than run time. Value semantics. Sure C and C++ are both value semantic languages, but we end up writing a lot of reference semantic code (with pointers). Modern C++ has really put the effort to shift things back, and it's possible to write a lot more things with value semantics. 
You mean as `std::string_view`? I don't want to wait hours waiting for an application to launch just to heap allocate static data.
Depends on compiler, but I think in gcc something like "-x c++ or -x c" and in MSVC there is a dropdown per file that lets you choose something like "compile as C" - sometimes compilers decide based on file extension too, though this seems quite hit and miss and seems to change version to version. 
Actually, it has been `Klaße` and `für`-loops ever since C++ began supporting unicode identifiers. 
I'm not saying we shouldn't have the ability to have statically allocated strings anymore, I'm saying the "char array with 0 terminator" shouldn't be treated as a string type by the standard library anymore. Something like `string_view` could be used for this purpose, yes.
Ah ok it's clearer now, thanks.
Move semantics blew my mind when I learned about it. I had never really stopped to even consider that a language could make a distinction between how it treats permanent expressions and temporary ones. Templates are still blowing my mind. I've used them before, but only in the most very basic use case like, "this object is a list that holds elements of type T". I still don't think I fully appreciate exactly why people use templates, and honestly most instances of template specialization I see in code confuse the turds out of me.
Sorry, but what are the advantages of default const?
Why?
&gt; Are there things you like about what C++ does that are not in Swift or where Swift gets things wrong in your opinion? For it's domain, not really. Swift was designed by the guys who made llvm/clang. They've done a great job of creating a high level applications language. I don't use it really, but off the top of my head I can't think of a single change that a high level applications language should have that C++ does and Swift doesn't. As a systems engineer, Swift is too high level for my taste. All classes are reference counted. This is a HUGE amount of overhead. Every single Array you create is backed by reference counted buffers. Ditto with Strings. 
Exactly. So the simpler way to deal with it would be to have one compiler. Then what the compiler does can be improved on if it doesn't make sense, but at least the behaviour is not undefined.
Oh, you want fun C++ acronyms? I'll suggest SFINAE.
Ha, what about importing and consuming macro-heavy libraries? Basically, anything written in C, including interface to the OS?
Undefined behaviour came into existence because when the language was standardised there were already too many compilers with too many variations in behaviour under certain conditions. The concept of undefined behaviour was a loophole. The problem though is that the concept of undefined behaviour prevents the programmer from reasoning about the code. What if we just had one compiler for C++? Well then you don't have undefined behaviour. You just have how it behaves, which is either good or bad or unexpected. The point is though that at the very minimum, it can be reasoned about because there is a single point of reference.
/I/ do - I must. I'd rather do that than cast everywhere. Some time back at least, Google's coding standard was to always use 'int' everywhere - I don't know what they do about indexes into containers. But I was just explaining what the grand-parent(?)'s objection probably was, and, agreeing that it had some nice effects. 
I never understood the rationale behind the single return statement rule. It may have it's origin in C's ancient single entry single exit behavior. But it just makes the code difficult to read and to maintain.
And then if a specific compiler (for some reason) implemented the array class poorly we would be doomed?
&gt; Why? Is there a benefit to writing T::__construct() over T::T() ? or similar? An example I had yesterday: I wanted to write constructors for a BVH node that would accept different parameters depending on whether it was a leaf or an interior node. If you just distinguish by parameters, the only way of inferring their purposes is to look at the comments (assuming you even have any) or just to work it out from the parameters their asking for. Instead, I used two factory methods: InitLeaf and InitInterior, which are pretty unambiguous about their functions.
If you want to write a program that tracks every single star in the Milky Way...
&gt; The problem is that std::string is bad It's not bad. It does what it does pretty well. The most important thing is that it handles memory allocation and deallocation implicitly, versus const char *s, which were an absolute mess to deal with. It does lack some basic functionality, which can be added to in the future.
Why not use tagged dispatch or wrap your parameters in a type? Just as efficient and arguably even more readable.
So what would you call the “things” that won’t grow (like, I need a collection of 50 objects)?
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
It's not the compiler, it's the hardware. For example x86, for register ? (placeholder ? can be substituted with A, B, C or D), there are ?L, ?H to access the two lowest bytes of the register, ?X for accessing the lowest 15 bits as a single entity, E?X for lowest 32bits and finally R?X for the full 64bits. Therefore, on x86 you can, without any overhead, access any part of your 64bit register. But on ARM, you don't have that kind of luxury, so using variables that need 8bits actually requires a lot of bit shifting of 32bit registers. &amp;nbsp; How about signed overflow? It's easy to say just make it wrap around, but that would destroy performance on anything that isn't using two's complement. &amp;nbsp; NULL pointer deference? But my MCU has `0` as a valid address, are you telling me that I won't be able to access that register?
;) use a language with BigNums, like Python.
That feels like a workaround for the fact that you can't rename constructors though
A standard library constructed around the idea of using iterators to bridge the gap between data structures and algorithms. The C string library defines a data type where you can chop the head off, and the tail is still a string (that is, you can increment a pointer to characters within a string, and it is still a pointer to characters within a string. (Lisp has a similar idea: you can take the cdr of a list and the result is still a list.)) C has a rich library of functions that work on the standard data type: string, but you can't use those functions with anything else, and you can't operate on a portion of a string with them, except the tail of a string. C++ extends this in two ways: its library uses a pair of iterators so you can easily work with any part of a container data structure, not just the tail, and its **templates** allow datatypes to be parameters to functions. That way, you can use the algorithms of the standard library with many different pieces of a container data structure, and not restrict the algorithms just to containers of types the library author knew about. Others have followed on from the design philosophy of the standard library: the Boost Graph Library for example, gives you tested algorithms that operate on graph structures, but since it works in terms of iterators, it doesn't care how you implement the storage of the graph. Iterators themselves are types, so you can write functions that take a pair of iterators and return a pair of transformed iterators. In this way you can write pipelines that do sophisticated transformation of data just by composing calls to standard library algorithms that take iterators from the previous call to a standard library algorithm. Sean Parent's lecture [Better Code: Data Structures](https://www.youtube.com/watch?v=sWgDk-o-6ZE) is an hour well worth your time. He covers these points and much more. He has an eloquence I can't match.
A standard library constructed around the idea of using iterators to bridge the gap between data structures and algorithms. The C string library defines a data type where you can chop the head off, and the tail is still a string (that is, you can increment a pointer to characters within a string, and it is still a pointer to characters within a string. (Lisp has a similar idea: you can take the cdr of a list and the result is still a list.)) C has a rich library of functions that work on the standard data type: string, but you can't use those functions with anything else, and you can't operate on a portion of a string with them, except the tail of a string. C++ extends this in two ways: its library uses a pair of iterators so you can easily work with any part of a container data structure, not just the tail, and its **templates** allow datatypes to be parameters to functions. That way, you can use the algorithms of the standard library with many different pieces of a container data structure, and not restrict the algorithms just to containers of types the library author knew about. Others have followed on from the design philosophy of the standard library: the Boost Graph Library for example, gives you tested algorithms that operate on graph structures, but since it works in terms of iterators, it doesn't care how you implement the storage of the graph. Iterators themselves are types, so you can write functions that take a pair of iterators and return a pair of transformed iterators. In this way you can write pipelines that do sophisticated transformation of data just by composing calls to standard library algorithms that take iterators from the previous call to a standard library algorithm. Sean Parent's lecture [Better Code: Data Structures](https://www.youtube.com/watch?v=sWgDk-o-6ZE) is an hour well worth your time. He covers these points and much more. He has an eloquence I can't match.
&gt;trigraphs Since they aren't used are they a problem? I realize that probably someone uses them, but I have not seen them or seen conversation about them outside of a "trigraphs exist, trigraphs bad" type thing.
Wait... if `(+ 1 2 3)` evaluates to `6`, does `(- 1 2 3)` evaluate to `-6`? `-5`? What about `(- 1 2 (+ 10 20 30))`? Does that become `(- 1 2 60)`? How on earth can that be `39`? &amp;nbsp; And I thought I understood this simple example.
You may not be lost, but your programs would start leaking memory all over!
Well, if you leak a lock... ;)
Some things that haven't been mentioned yet: namespaces and references. Namespaces just make organizing code easier. Instead of everything living in the same global namespace, you can actually try to logically partition your functions into their own namespaces. References, as in the difference between: void fn( const Type &amp;obj ) vs void fn( const Type * obj ) It's a small thing (and admittedly I'm torn about the trade-off of losing the &amp;arg at the callsite), but at least you can try and show intent that something can never be null...
If you're just learning about RAII, then the key thing to know is that it is misnamed. "Resource Release at Destruction" would be a better term (and "RRAD" looks cooler, too), but, alas, we're pretty much stuck with the original name.
Not for headers, AFAIK, just the files that are actually being directly compiled.
The problem for both of these is that they can be unintentionally used, especially by people newer to C. Some syntax errors can also get extremely confusing warnings if the compiler for some reason thinks it is seeing a trigraph, but obviously the octal one is far more likely to trigger problems. Trigraph examples here: https://msdn.microsoft.com/en-us/library/bt0y4awe.aspx?f=255&amp;MSPPError=-2147217396
Well a header is just a piece of code that gets included into a source file.. so of course that would be up to you how you include them. It is true you cannot specify one scope as "C" and another scope as "C++" within the same file, so there is a limit to the flexibility. You can use #ifdefs though....
I've worked a bit on a template heavy library that is an alternative to Boost.Python. It uses SFINAE heavily and while it looks intimidating at first, with a lot of effort, even SfINAE can be readable. [Take a look.](https://github.com/pybind/pybind11/)
Make Explicit type conversion (functional notation) with a parenthesized single expression behave as if static_cast. Currently, it's same with C-style cast with all its glory and hideousness.
As a bonus, language guarantees that the resource will be freed even in the face of exceptions and, yes, RAII is a very natural thing.
See also the paper, P0707 (http://wg21.link/p0707), and search for "defun." Lisp defun (and Scheme define) lets you define a function... but in Lisp and Scheme you can even redefine built-in functions and macros, including defun/define itself which is what "defun defun" / "define define" does. Here's a sample related StackExchange question: https://emacs.stackexchange.com/questions/375/symbols-value-as-a-variable-is-void-defun-when-reloading-emacs . I'm not interested in doing anything like that in C++, and there's nothing like that in my proposal, you can't change any definitions (including of this class after it is defined), you can't reach out and affect anyone else's type or code, the only thing you can do is participate in generating the one-time-and-then-immutable definition of this class you're writing right now which is nice and localized and bounded... and still very powerful. 
Oh, I completely agree that backward compatibility matters for existing code bases; but then you don't have *much* choice, short of a rewrite. I was thinking more in term of new project, where the choice of language is only driven by expertise and technical requirements.
Lambdas, `constexpr` along with `if constexpr`, move semantics, enum classes at the language level. STL algorithms from `&lt;algorithm&gt;`, smart pointers, and sure, the already available container types at the library level. Side note: The original creator of STL, Alexanter Stepanov, said that you should be using `std::vector` unless you have a *very* good reason not to.
The more you work with templates, the more likely SFINAE will come up. The easiest way to use it is with `std::enable_if`, which lets you enable or disable the existence of a function based on a boolean condition. This is a very useful tool for creating correct, robust interfaces for templated classes.
&gt; `(- 1 2 3)` means `1 - 2 - 3` That's what I first though, only my mind decided that equals `-5`. &gt; In Lisp functions start with the operate, e.g. the + function, all other values are function arguments. That's as far as my prior knowledge of lisp goes. Then the part about `if` was just obvious. Thanks for the help, I wasn't aware that you can do `(+ 1 2 3)` not just `(+ 1 (+ 2 3))`. &amp;nbsp; I still think the syntax is ugly.
The initial commentator's suggestion sounds fine to me.
Let's get to it :) ###Moves Let's take the following class: template &lt;typename T&gt; class Ref { public: private: T* ref; }; This is a similar class to `std::reference_wrapper`: it's never null, but can be pointed to another object. How do you implement the move constructor and move assignment operator for this class? Leaving `ref` null? That's unfortunate, as it contradicts the first invariant :( If you have bitwise move, instead, then the compiler can just `memcpy` the instance (no user-code called, guaranteed `noexcept`: see `std::is_relocatable` for C++20) and the compiler will guarantee that the copied instance is never accessed any longer (and the destructor is never called), so that its state no longer matters. ###Concepts Let's take the following algorithm: void duckit(Sortable&amp; container) { container.quack(); } The only requirement is that `container` be `Sortable`; yet we call `quack` on it and the compiler gives no error on the definition of `duckit`. At the instantiation point, either `container` has a `quack` method and everything's fine, or it doesn't and you get the usual wall of errors "instantiated by ... at ..." for each and every instantiation in each and every .cpp file compiled in parallel. On the other hand, had the use of concepts triggered a stricter check (all capabilities used must be specified by the concept), then you could have had a nice error at the point where `duckit` is defined telling you: `quack` is not a member of `Sortable`, did you mean `wack`? The latter is SO much more user friendly :/ --- &gt; Aside from those things that you mentioned in your post, I am wondering what other technical aspects of current C++ language really bother you. I'll pass on that; way too many and I'm lacking sleep ;) I'll just say that I would prefer the committee to overhaul the language (more stringent clean-ups) and have a more principled approach to evolving (big orthogonal features, rather than a flurry of small time warts that may fix one papercut but leaves its neighbors unsolved).
Can we do better in C++20? Like `kstring&lt;"fizzbuzz"&gt;` or similar? 
&gt; Note: what you found about private = default is, I believe, a known defect about aggregates, that has simply been overlooked but IIRC will be fixed in C++20. That would be really nice! &gt; Unfortunate, but yes, given the complexity of the language, those things are probably bound to happen. That's actually half my complaint, though. Rather than tacking on more and more new features, I wish some time was spent into unifying existing features and cleaning up their interactions to *reduce* the number of rules and the size of the standard. It's understandable that humans will not get it right the first time; but it's rather annoying to have to live with our past mistakes forever. I wish the benefit of hindsight was used to fix the mistakes from the past. I do understand backward compatibility matters, of course, however per-unit compilation mode could solve most syntax issues (at least), allowing mixing multiple standard versions seamlessly. And from then on, you could more aggressively deprecate features in new standard versions, converging toward a cleaner C++, rather than slowly aggregating warts as we go.
That doesn't address OP's problem, though, which is using code from a C header in a C++17 file. Aside from trying a hack like `#define register`, there is no easy solution for OP; he would either have to keep using C++14 which allows the `register` keyword, write a C wrapper to mediate between his code and the C library (which could be very time-consuming if his existing code makes heavy use of the C library), or convince the maintainers of the C library to not use `register` in the header/interface (which they might even have good reasons for doing).
I think the following is meant by this, but I'm far from an expert. Unlike integer arithmetic, floating point arithmetic is sometimes not as natural, because of finite accuracy. So there are probably multiple ways to define things such as multiplication. So it may happen that the same floating point calculation (addition/multiplication) has a different result at run time compared to compile time, as the standard does not dictate the implementation. 
Copied from the subtitles for the talk's Q&amp;A session: &gt; The answer is the primary developers, Elcus and Roman, are in the Zurich office. Closed hashing, abbreviated "ch", is also the top level domain for Switzerland. And Swiss efficiency just has a good spot in the zeitgeist. But, in the end, we decided to name it something more descriptive.
I'd remove old-style exceptions and RTTI, or at least make them opt-in.
`volatile` Instead there should be functions such as `volatile_read8(char* address)`.
&gt;If you're just learning about RAII, then an important thing to know is that it is misnamed. "Resource Release at Destruction" would be a better term (and "RRAD" looks cooler, too), but, alas, we're pretty much stuck with the original name. I think CADRe is the correct one: Constructors Acquire, Destructors Release.
Do not pass parameters with ampersand and star: use references instead. Const reference if the parameter is strictly input. Use smart pointers if you absolutely have to use pointers. &amp;#x200B;
Respectfully disagree. I would say that RAII doesn't have anything to do with constructors. Yes, typically we will acquire in a constructor, since the object has to get ownership somehow, and a constructor is a convenient place to do it. But we don't have to do that. Say I do the following. ofstream out; out.open("file.txt"); ... I never need to call `out.close`, since `std::ofstream` is an RAII class. But I did not acquire in the constructor.
How do you propose implementing std::array with using a c style array under the hood?
My list * Templates: * In both the garden variety and the SFINAE senses * Namespaces I was going to name destructors and dynamic polymorphism, but then I realized that would be part of C w/ classes. I think a lot of the other things that people have said fall into the class of syntactic sugar (which is great, but not key). E.g., move semantics I think are just a simpler way of doing Foo b; Foo c; b.move_from( c ); &amp;#x200B;
Sure, but my point is that it's implemented by the compiler. `array&lt;int, 5&gt;` could be too. 
It's interesting to me how the three compilers' outputs are very unlike each other. clang just embeds and prints the precomputed output. gcc converts the output into instruction data and doesn't include the precomputed output. MSVC is... something else.
The problem uniform initialisation was designed to solve was being able to initialize an inline instance of constructor-less types: struct S { int x; int y; }; f(S{1,2}); // vs old style S s = {1,2}; f(s); This is important. It's weird that in C++'03 only classes and primitive types can do this, but not structs.
Klaße is not a word. We do use während-loops though.
Yeah, strong agree with /u/Nicksaurus. Tag dispatching is gross. You wouldn't write `T::__construct`, you'd write `T::with_jazz_hands(get_jazz_hands())`.
The only real advantage is to not have to make your own virtual tables, but in modern computers allocating lots of smaller objects on the heap, dereferencing their pointers, then dereferencing their pointer in the table is extremely slow and usually a poor choice.
How would this be indicated in the code that it's a constructor and not a regular function call?
* RAII * The standard library (`std::string`, `std::vector`, `&lt;algorithm&gt;` &amp; `&lt;numeric&gt;`) * Templates * "Safe" pointers (mainly `unique_ptr`, `shared_ptr` is useful too but don't overuse it) * Lambdas
Even worse is that this is also a pointer: void foo(int argument[5]) The "5" is entirely ignored.
I think you don't need to become "proficient" with templates to use C++, even in a professional setting. Use them, yes, totally. Write a few short ones, too. Deal with all corner cases in a very complex template? No thanks. That's the job of library writers. Just because a feature is there, it doesn't mean you **always** have to use it in your programs.
That does look good. More consistent syntax would be nice (what if functions looked like lambdas?) but what I was thinking about is I'd like debug builds to not construct the lambda objects. Are they actually defined in the standard to be equivalent to functions? I remember seeing some MSVC disas that pushed them onto the stack, so this is what motivated that point.
There's one question where something like `buf[0] = '+'` should be used to determine if the `printf` will print `7`, but the if statement checks the value of `buf[1]` too. Without seeing how `buf` is declared there's no telling if accessing `buf[1]` is valid, undefined or just unspecified.
&gt; &gt; Implicit conversions sh have dedicated syntax &gt; That kind of defeats the purpose of implicit conversion. I believe he means dedicated syntax for *defining* implicit conversions, not for using them. &gt; The problem is that initialization of one member variable could depend on the value of another member variable, hence the order matters. :/ Wouldn't the suggested compiler warnings generally catch that?
&gt;where there is really no equivalent, C not being object oriented &amp;#x200B; OOP is basically a design pattern in C. You can emulate it via structs, new/init/delete functions, inheritance via base pointers and polymorphism using virtual tables. Often it's not optimal but it's possible. gcc has a compiler extension (cleanup attribute) with which you can specify that a function (a `free` basically) should be executed if the variable goes out of scope. Thus, it enables you to use RAII in C, although in a less convenient way. cleanup is used in some C projects, but it's non-standard. &amp;#x200B;
`signed`/`unsigned` should be detached from wrapping/non-wrapping. Relying on wrapping as a feature is rare, so let's make it opt-in. How about `wrapping` as a keyword. `wrapping uint32_t x = 593249238432; // Well formed, but x has wrapped.` We also introduce non-wrapping uints: now they throw an exception if an attempt is made to decrement them below zero. This should be hardware accelerated. [Regrettably few of the major architectures implement integer overflow traps, but since we're rewriting C++ I don't see the difficulty in adding some features to x86 and ARMv8 too.] The compiler can warn the author at compile time if this will be as slow as a tortoise on the intended architecture, and she can decide if the overhead is worth it for her purposes. While we're at it, drop `long long`, `long`, `int`, *et c.*, in favour of `int32_t` *et c.*. If you really don't care about the size of your variable but you do need it to match the native word size, we will re-purpose `uint_fastXX_t` for such purposes.
things out of top of my head in no particular order: * RAII * templates * constexpr * meta-class programming (soon) * exceptions * auto * aliases (templated typedefs) * decltype * STL * smart pointers (shared_ptr, unique_ptr) * ownership transfer (move, forward) * lambdas * std::async (concurrency, yes it's doable in C but it's pain)
I am beginning to wonder why this matters. Do you just want to get rid of `int a[5]` altogether? &amp;#x200B; What does this accomplish other than perhaps create yet one more layer of indirection?
Of all the things one has to learn about C++ understanding what std::vector is, has to be one of the easiest concepts to grasp. Why anybody would suggest changes here is beyond me.
You're probably right, since pretty much all C and C++ compilers ignore `register` anyways.
I think something could be worked out with variable argument templates such that `std::array&lt;int, x,y&gt;` becomes equivalent to `std::array&lt;std::array&lt;int,x&gt;,y&gt;`.
There are proposals for `char8_t` for Unicode char, with those you don't need char anymore.
Swift so far has the best chance of replacing C++ long term. I really see it as one of the better new languages out there. 
Why is it a failure?
What does "force 0 in the final binary" mean? Do we have to allocate space for the variable, discrete from the space used to represent any other variable, for the duration of its accessibility? I think this is a far stricter constraint than it appears.
Sure, but that's more of a workaround. Would be great for \`char\` to denote something character-related =).
&gt; That kind of defeats the purpose of implicit conversion. I meant dedicated as in overload explicitly separate from constructors. I'm thinking it should be [more like C#](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/implicit). &gt;Except that I recently have seen a bug in /r/cpp_questions, about which compiler complained because ints are not initialized by default. Zero initializing the local ints made compiler silent, but the bug was still there. I like having the compiler catch things, but don't we already basically have this possible bug with any class type that has a default constructor? I think warnings in this case would be useful, and I'd probably advocate for a standard that explicitly initialized everything even though the default behavior when you ignore those warnings became less prickly. &gt; I think it is useful as it adds a certain degree of clarity, if you ask me. There's (*foo).bar, but that is unreadable. I think this clarity is really diluted because of references. Something that I think would add clarity is to reserve `operator-&gt;` as the un-overloadable access operator. &gt; AST macros? What about metaclasses? Metaclasses don't really cover the full spectrum of thigns that proper AST macros do. I can imagine an argument being made that this is a good thing, but I suspect it would be like any other opportunity you have in C++ to make a mess. We'll collectively decide on the kinds of things we should definitely not do and then make checkers for those things. &gt; The problem is that initialization of one member variable could depend on the value of another member variable, hence the order matters. :/ That's exactly what I mentioned in my second sentence there. Have the compiler warn about it. Otherwise, it completely defeats much of the purpose of having the designated initializer syntax. &gt; Can you elaborate? I have no clue what you're talking about. I mean to say that we'd specify which source files to compile, and where headers and libraries live, in some kind of build.cp file, and to accomodate people with complex needs, they could write constexpr functions to generate lists of files to include in the build. The "room for implementation-defined configuration" is talking about leaving room to deal with UWP, Android/iOS/MacOS, and RPM/deb/whatever packaging needs. &gt; Why do you think that immediately invoked lambdas are a crutch? They accomplish the same thing as expression blocks, and if you look at the disas in debug builds (and frequently in release builds) it often has to do the whole calling convention dance instead of just assigning the final computed result to the target variable.
&gt; The first would prevent a pitfall for novice programmers, but greatly weaken the power of switch blocks. There is now fallthrough syntax and compiler warnings about this.
Copy-on-write strings introduce a terrible overhead if there is a need to support multithreading. That's why they were dropped in C++11. 
[Curiously Recurring Templates](https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern)
It means that if the variable is still there (i.e. allocated in the stack or using a register), then the compiler will emit assembly to initialize to 0, but still performs the rest of the analysis as if the value was unknown, i.e. emitting warnings for reads of the uninitialized variable.
&gt; Being new to the language, I'm not sure that I even know what is the right question to ask to disambiguate the meaning of this idiom. All the nuances that come with the abstractions C++ provides. This leads to a different paradigm when writing C++ code. There are usually easier/better/different ways to accomplish the same things in C++ that you would do in C that are generally accepted and understood. Same thing applies when you move to a higher level language. You could write python code just like you'd write C or C++ code (for the most part) but you'd be doing yourself and others a disservice by not learning new paradigms based off of the flexibility python offers. Working in C++ for so long, it wasn't really common to pass functions around as callbacks, whereas in python, lua or any language that had easy support for lambdas it was a very common idiom to use and see. To me, that's the real difference in learning other languages. Not just the syntax, learning syntax usually takes me a few days of constant use and a reference page. Learning the new idioms/paradigms/architectures of accomplishing the same goals in the new &lt;insert language&gt; way, is what takes some time. 
It didn't *look* evil. It was a clever use of specialization, back when specialization was new and shiny. It just had unfortunate side effects.
There is no one true way, but there are a myriad of ways. You could use ADL based customization points. You could pass in a meta-traits template, sort of like allocator rebind. You could pass in a generic hasher that must work with all types. Requiring a *global* hasher be used in all those dozen cases is akin to using global variables for your function state. It means you cannot have two boost graphs the same types and with different hashers, or in fact a different hasher in any of the containers/type pairs used in boost graph anywhere else in your program. There doesn't have to be one true way to hash something. You can have tradeoffs between collision rates and computation costs, for example; one that I've done is written a string hasher than only samples 11 characters on long strings. Good enough when you expect your data to look one way, but dangerous in other situations. 
To address your other points: &gt; How do you propose accessing members of a smart pointer or iterator itself and not members of what they refer to? (ex: std::shared_ptr&lt;T&gt;; ptr.get() vs ptr-&gt;something(), the get() is a member of shared_ptr, not of T). I think that `operator-&gt;` should be reserved for this purpose since it's less common when using a smart pointer, and seeing a `-&gt;` would then be an indicator that you're likely dealing with a smart pointer. &gt; How do concepts address what ADL does at all? Isn't ADL just a way to prioritize overload resolution to prefer the namespace a type is defined in? We can use Concepts to prioritize this relationship instead. I'm sure there are cases it couldn't cover, but I rarely rely on ADL so if you can think of some specific examples I'd be interested to know. &gt; C++17 introduces the first efforts to have this, and yes, its goal is to deprecate almost all uses of SFINAE And I'm very happy to see this :) I want to use `if constexpr` outside of function bodies too, but I'll take what I can get for now. &gt; What does that mean? Are you saying that reinterpret_cast&lt;T *&gt;(nullptr) should throw an exception or something? No, I mean amend the current rules that say this is almos always undefined behavior. I want to do type punning without memcpy/bitcast. Right now it's really hard to navigate these rules (for evidence, see [this CppCon talk](https://www.reddit.com/r/cpp/comments/77nael/cppcon_2017_scott_schurr_type_punning_in_c17/)). &gt; I don't see how const has anything to do with thread safety... The only relationship they have as far as I know is that a const object can be read by as many threads as you like, but only written by one at a time. Which is logically sound (matches reader-writer lock semantics for a reason). I agree, I also don't see how const has anything to do with threadsafety. But people (and not randos, I mean people like Herb) have been suggesting we use const as a strong marker for threadsafety. Apologies if I'm misinterpreting this stuff, but that's how it seems. I also don't think `const` is even very good at that, because the mutability guarantee only goes in one direction. It's pretty weak. &gt; The difference between a locally scoped function and a locally scoped lambda is what exactly? Can you elaborate on this? Mainly that it doesn't construct an object on the stack even in debug builds, and it could participate in overload resolution with regular functions. Non-capturing lambdas are definitely very close to, but are not quite local functions.
Assume you have code like the following: int f() { int a; return a; } Such code makes no sense, and you really want the compiler warning you about it (and any modern compiler does so). It is not always trivial to diagnose this for compilers or to notice the problem for humans (consider writes to the variable that depend on conditions, which may be inside loops, etc.). If you initialize always your variables to 0, you won't get the warning (and you will get wrong code). The advantage of initializing, however, is that at least the problem will always behave the same way. The idea I posted above is simply taking both of the best worlds: having a way to tell the compiler that the value is uninitialized for analysis purposes, but still end up writing a 0 anyway in the binary for determinism.
I thought about dynamic_array, but like ropodcast said it *is* long, and there was already a `std::dynarray` proposal which sounds useful but is different from both `std::vector` and `std::array`.
We use a CoW string everywhere at work, and I'm not convinced it's a universally better approach. I'm pretty sure we're wasting a shit ton of memory and cycles churning on strings unnecessarily, but it's hard to know where to begin removing them for the biggest impact. Aside from not being to do SSO, your visibility on how many unique strings are in memory is muddied. I'd rather have types like Mark Elendt described in his talk where you have explicit string storage owners and string references.
As an embedded guy, templates are amazing. Template + constexpr + auto alone are huge benefits to using C++ over C, nevermind the encapsulation and optimizer benefits of using classes and namespaces. Genetically programmed C++ runs at least as fast as hand written C with modern optimizers, and takes half as long to program, and is safer. I wish I’d discovered it all sooner because I just started C++ in earnest like a month ago
Because that's not the same - a struct can be partially initialised. And with designated initialisers, it gets even more funky.
How do you feel about on-off templates functions you put in a cpp to avoid duplicating code? I did this recently to allow some code to work with multiple unrelated string types that all partially conformed to std::string's API.
The biggest reason is that if you don't have other virtual methods in your class, then making the destructor virtual adds a `vptr` entry on every instantiated object making them (at least) one pointer bigger (8 bytes on 64 bit platforms).
Does it matter? The caller only needs to know that it returns a new object, which can be made clear from good naming practices
The original hardcore vision was based around class invariants. For example, the invariant of a file class might be that it would have a valid file handle. That would mean opening the file in the constructor (and throwing if the open failed). The benefit of the strong class invariant is that you don't need to repeat checks for an invalid file handle in all the other file methods. It brings what was dynamic state into the static type system. Notionally similar to have references cannot be nullptr so you avoid nullptr checks when dealing with them. If you don't follow this vision, then it just becomes a more convenient way of writing try/finally, which is far less profound.
Well yea, i think it matters (I think). Without consistent naming, duck typing is pretty much broken. Constructors don't "return an object" at all they build one where the memory was already allocated. For example, how would this work for stack allocations? Require that they use assignment syntax?
Thankfully, most use cases of SFINAE are obsoleted now by constexpr if —which is another big differentiator from C With Classes.
&gt; Constructors don't "return an object" at all they build one where the memory was already allocated. Copy elision also does this, so ¯\\_(ツ)_/¯ I think your assignment syntax suggestion sounds good. The duck typing thing could maybe be fixed if we pass the name of the constructor in? It does make something like `make_unique` verbose, true: std::unique_ptr&lt;T&gt; pt = std::make_unique(T::from_jazz_hands, get_jazz_hands()); I guess at the very least the default constructor would require a consistent name so that `push_back` just worked.
Sum types have a pretty strong overlap with variant though, while the overlap is less strong for structs. Why keep variant when real sum types exist?
So, if we are thinking about assignment syntax... then we are basically back at factory methods... class T { public: T *from_jazz_hands(T::jazz_hands &amp;jh) { ... }; }; auto ptr = T::from_jazz_hands(get_jazz_hands()); Or if you don't like pointers, just copy and use move semantics. class T { public: T from_jazz_hands(T::jazz_hands &amp;jh) { ... }; }; auto obj = T::from_jazz_hands(get_jazz_hands()); Isn't that giving us pretty much what you are asking for?
As messy as it can get, it sure is fun :)
 &gt; The difference between a locally scoped function and a locally scoped lambda is what exactly? Can you elaborate on this? Locally scoped functions could presumably be recursive without relying on any weird capture tricks. I have no idea if that’s what he was getting at or not, though. 
Actually... yeah I suppose you can do basically everything I'm thinking of with just move semantics and factory functions
Well, let's say we had named constructors, something like this: struct T { __construct name1(int a); // both are constructors with same parameters __construct name2(int b); // but have different meanings! }; cool, how do we use this in a template which needs to make one of these things? template &lt;class T&gt; void foo(int x) { // what do we put here instead of T var(x); or auto var = T(x) ?! // ... // use var } 
&gt; I meant dedicated as in overload explicitly separate from constructors. I'm thinking it should be more like C#. Taking C# syntax would be confusing thanks to already existing conversion operators, but I see your point. &gt; Default initializing There's also the case of tightly constrained hard real-time systems that wouldn't like executing the extra instruction or two needed for default int initialization. &gt; I think this clarity is really diluted because of references. Something that I think would add clarity is to reserve `operator-&gt;` as the un-overloadable access operator. I can see your point. I don't like that references have value type like syntax either. &gt; AST macros/metaclasses This sounds like something Herb Sutter would refer to as "giving the programmer too much power". I don't know enough about AST macros to say anything more. &gt; That's exactly what I mentioned in my second sentence there. Have the compiler warn about it. Otherwise, it completely defeats much of the purpose of having the designated initializer syntax. There is `-Wreorder` if you enable `-pedantic`, but that's not exactly what you're talking about. &gt; lambdas Lambdas are constexpr by default. I haven't checked, but is the situation better if you declare the variable `constexpr` too?
&gt; MSVC is... something else. Isn't MSVC's solution the only "correct" one? A program that has no output should have no content.
It's extremely similar, yes, and I do this often now that we have guaranteed copy elision. However, named constructors could also support member initializers so you wouldn't have to do the private constructor dance. If the language just had this, I'm sure we could also think up more useful features, libraries, and idioms that work with the fact that every constructor has a name.
Why are these talks uploaded by the NWCPP channel and not the official CppCon channel? And they don't include the speaker name in the video title, that's mildly annoying.
I see your point. ...I don't know the solution to that situation though. Maybe some sort of syntax to pass in a function *call* (e.g. a function with its parameters set already. Does that exist in any form?) rather than just a list of parameters. I don't really like that constructors in C++ are duck typed anyway though. It seems like an odd place to have ambiguous syntax when most of the rest of the language doesn't.
The committee has recognized that this was a mistake in the initial standardization for quite some time. Unfortunately, it's a mistake that can't safely be fixed, only warned about.
How is polymorphism C w/classes? What is the “modern” alternative?
Example: auto foo = [a, b, c]() { bar(a, b, c); }; // so now foo(); // is the same as saying bar(a, b, c); 
You can "have a single file that has the source code of the entire library/package and could just be dropped into a project" right now. it's called a tarball (or a zip archive if you prefer). It's the "regardless of compiler, compiler flags, layout of dependent classes" part that is difficult, and it's not going to change one single bit with the advent of packages.
My guess is that this talk was given by a member of their group and the CppCon channel will upload it when they're ready. Based on past years, they try to get a few "big" talks out quickly and then upload a ton of talks back-to-back later on when the processing is done.
The swap case is what I was mainly thinking of when I wrote this point. Could we not just have a `Swappable` concept? Same thing applies to `begin()`/`end()`. For the stoul example, that's the sort of thing I never do except by accident. Is this gaining you anything aside from sparing you from typing `std::`?
&gt; Do you just want to get rid of int a[5] altogether? Since this is a thread about throwing away backward compatibility, yeah. std:;array is better in just about every way, except maybe terseness when declaring it. 
I have seen code with comment in several languages, even two languages in a same file, but never seen translated/localized keywords like these :)
It's lacking too many features that C++ has, e. g. overloading or integer templates.
The survey was quickly updated based on a couple comments received. If you have already taken the survey, there is no reason to take it again! Thank you.
The question based around #ifdefs could be compiled with a command-line definition of those config options, as that's a very common thing to do. I'd say it's worth adding a note that there are none of those. One question is about a `mask` array. The definition of `mask` leaves all elements uninitialized, so it's UB to read them later and the below code very much depends on the values you think the array has in order to answer the question.
Whoa, TIL this syntax!
&gt; We are crafting the language to be exactly as we desire, so let's add them! :D Ah, yes, I forgot that we magically made unicorn initialization work as well. &gt; This is a thing I wish we didn't rely on, it'd be better to just know that it does what we want by construction. Compilers don't read minds. At least not yet. Also what the programmer meant and what he wrote are sometimes different things.
Thank you.
Resource release at destruction looks like struct RadPtr { RadPtr(void* p) : ptr(p) { } ~RadPtr() { delete(ptr); } private: void* ptr; } That is something you really don't want to do. In this case, "resource acquisition" refers to ownership. The object acquires the resource and handles all the cases (copy, move, assignment, release). But OAII (ownership acquisition is initialization) sounds awful.
Immutable data are free from entire classes of bugs: race conditions, TOCTOU, logic errors, ABA . . . When there is mutable data, it's a big yellow caution flag to treat this data very carefully.
I remember reading about some performance issues, like having to copy the entire data around as it “changes” (ie produces new objects based on that one), and that thrashing memory very quickly... not something useful in an application where lots of objects hangs very quickly (like a game world).
Yeah plus it defeats the purpose of a code guideline. Restricting the developer in his algorithmic design is just plain stupid. Guidelines should operate on a syntax and semantics level not logic.
Probably the same thing that vector::operator [] does when index is out of bounds.
The problem with COW on a default in the standard library (which it used to be; gcc &lt; 5 string was COW) is that while for many applications it may provide better performance overall, it's much less deterministic and makes reasoning locally more difficult. With the current string, you mostly know when you are copying or not (the only exception is situations where there's a branch on whether new_size &gt; capacity, but that can easily be checked in advance). With COW you never know when any non-const method will suddenly trigger a big allocation. Another thing is that really once you go COW, it seems to me like you may as well go to ropes, or more generally, something more sophisticated than string which is very limited by needing a contiguous buffer. 
With respect, what’s that got to do with whether const is default or mutable is default? If game data *needs* to be mutable for performance reasons, no problem. Default-const just means you’d have to mark it. For most code this would be less verbose.
Reading this summary I definitely come out in favor of trivially relocatable. I think the key point is that it basically has to be memcpy or bust, otherwise you aren't getting the killer performance boost. Providing a customization point for an object doesn't help with this because the whole point is to avoid having to call some (potentially non-inlined) function for each object being moved, instead just a parallelized memcpy. And realistically almost every object that is movable, is trivially relocatable (really, unless it has internal references). So sacrificing performance (and language simplicity) on the 99% case in order to get something a bit better than move (but worse than memcpy) on the 1% case, sucks. I think trivially relocatable is fantastic and really hope it gets standardized quickly.
Does anyone know if this will be on the CppCon channel as well or is it a NWCPP exclusive?
conan
C++ encourages writing vocabulary types in language optional. expected. future. vector. Once they are added you can then compose them. You can write code that reads like Python, runs like C, and is as pure as Haskel. It is nice. Wrapping something in a class is nice. When you wrap a noun, verb or adjective in a class, and have a category of nouns, verbs of adjectivrs, suddenly you can write sentences. To this end, we have ideas like regular and semi-regular types; these are types with value semantics that play nice with the std library containers. They are a category of nouns. If you make your noun-like thimgs be semi regular as a habit, you can now talk about collections of them. That kind of category of classes lets you create insanely more intricate structure without insane amounts of complexity driving you insane.
I would, instead, want correct comparisons, i.e.: unsigned int a = ...; signed int b = ...; // and if (a &gt; b) would generate: if (a &gt; 0x7FFFFFFF) return true; if (b &lt; 0) return true; return a &gt; b; Of course, can be generalized using std::numeric_limits etc... Yes, there is a performance penalty there, but if you don't want it, don't mix types.
I don't understand why the factory methods wouldn't be the preferred solution anyway.
Constructors just feel more... right? It's a bit of a vague preference, but it feels like if I'm making an instance of a class I should be using the language tool designed for it
If you destruct something that isn't at the top of the heap, then you get a void. Embedded systems don't typically have any sort of memory management to handle that. If you continue to allocate and then deallocate memory, you'll eventually crash the heap into the stack and your software will crash.
C++ is not rust.
To me constructor vs factory method is a lot like paying jiffy lube vs changing your own oil. You're paying someone so you don't have to deal with the details. Maybe the factory method is a very thin layer over the raw constructor, but it also ensures you can adjust how the class is being created in 1 place (assuming you're consistent in the use of factory methods). To be honest, I use that approach in just about every language I work in . Even in C# I don't like to use new directly unless I'm creating a builtin System type (such as dictionary, array, etc). It just makes more sense to me.
So you want "compiler magic" to he added to implement what we already can do in library code? Seems a bit unjustified given that c arrays aren't that harmful... Isn't it simpler to just not teach them until people understand advanced topics?
If everywhere you go the comments aren't trustworthy, then maybe the problem isn't everyone else. 
I didn't say anything about the heap. I said destructors.
&gt; meta-class programming (soon) &gt; Where do you get "soon" from?
-pedantic but fair. I guess the point I was trying to make is that when you allocate memory on the heap, don't let go of it (as you normally would with RAII when things go out of scope). Other things like locks, semaphores, mutexes, etc that should be released are still fair game.
Is nwcpp competing with the cppcon channel for posting the talks? Any reason they're not all posted on the cppcon channel?
its the same as last year - don't remember why...
&gt; Frankly, you talk like you have very little experience with large, real world code bases. That's funny.. I was thinking the same thing. 
Have a ~~macro~~`constexpr` global that says whether float is ieee754 or not. Actually all feature testing should use `constexpr`, macros are not required.
I'd love `tuple` to be a core feature.
Pretty sure your first points are on most compilers de facto, so it's not so bad, even though I would love to see it become standard.
I wish you could` if constexpr` the function definition itself.
&gt;So you want "compiler magic" to he added to implement what we already can do in library code? We're talking about what we would do if backwards compatibility wasn't a concern, right? Being able to do things like make actual iterators (rather than hacking around them) and knowing how big an array is are both really good thing to have on even your lowest level array type. I don't believe there is any memory or run-time cost to std::array over a c-style array. &gt;c arrays aren't that harmful... IIRC, C arrays are probably responsible for more security problems than any other language feature on earth. &gt;Isn't it simpler to just not teach them until people understand advanced topics? If you're talking about the real world now, and not the hypothetical world the OP posited, yeah, I'm absolutely on board with this.
My god. The basics of most languages are little longer than your comment :-(
&gt; Many compiler errors and cryptic and don't really help me to find given problem in my code. When I was learning std::vector I tried to create a vector of references. clang exited with around 400 lines of error messages. None of them descriptive enough (again, for a beginner) to show me what's wrong. This is quite frustrating, because I end up doing a lot of guess work. That's a point where the STL implementation wasn't written well enough. With SFINAE, you can prevent template matching from finding the regular `vector` template at all, which will give you right away a single line error (`vector&lt;int&amp;&gt; not found`). With concepts getting in, it will be even easier, since you can have something like `vector&lt;NotAReference T&gt;`, and if you try to instantiate it with a reference, it will fail to match but the syntax is way better. I'd argue it's also the standard fault, because pre C++11 it was forbidden to even try with a reference because &gt; T must meet the requirements of CopyAssignable and CopyConstructible. But they relaxed the requirements. Fair enough because of move-only types, but that removed the assignable requirement for instantiation. Maybe a wording change would help?
This question is still wrong. buf[1] could have any value.
My favourite coding adventure is when my code shrinks and gets better for it. My least favourite coding adventure is when I have to explain to fairly experienced coders how my code works; this last is only good when their eyes light up and they plan on using what I showed them (tuples) but not when their eyes darken and they plan on removing the complex nightmare that I just wrote. Templates often fall into this last. It is a terrible thing if you removed two readable functions and replaced them with one unreadable one. 
I meant with the commented-out "output" lines uncommented. Sorry, should have been more clear.
There's another great talk that happened this year called something like "The Salami method for cross-platform development" at CppCon. It was an architectural approach to support being truly cross platform C++ across other programming languages and platforms (desktop, mobile, web, embedded, etc). I don't know when they'll have all the talks put up, but the author's blog is here: [http://videocortex.io/2017/opencv-web-app/](http://videocortex.io/2017/opencv-web-app/) where they demo'd it. &amp;#x200B; I'm not the author, just someone that is really interested in cross-platform C++ development.
What's wrong with it?
Eh, the [original Lisp paper](http://www-formal.stanford.edu/jmc/recursive.pdf) was 34 pages. I feel ya tho.
Is this the plan for subsequent years as well?
Ah... Weird. The recording setup for these seems to be a bit worse. It's recording off a mic in the room instead of tapped to the speakers mic. And the camera location/focus/capture of slides seems like it's lacking polish.
Among other things, because my employer doesn't want to share their source code with their customers. The customer gets a pre-compiled binary and set of DLLs without debug symbols or source code. Either the customer manages to deal with the ABI I provide them, or they don't. That's their issue. So any packaging system that involves mandatory source code distribution is automatically disqualified for delivering my code to customers. Then, you also have to consider that every project has a different set of compiler options that it needs / works best with. The reason packaging is such a *massively* complex problem is not simply a matter of sending source code around. Its how to build the code. Its compiler compatibility, its platform specific considerations, its dependency management, its a whole bunch of stuff. There is no need for a one solution to rule them all solution to this problem. For me, Gentoo's portage system solves the problem perfectly. But that still requires a lot of grunt work. The reason a bunch of other languages can do package management is because those languages ***do less*** than c++. Their package management tools also suck really really badly. Node.js left justify package sound familiar to you? Java jar files have also been a massive pain in my ass over the years. I'd rather the standards committee stay far away from this subject until the c++ community comes up with one, or more, *really good* flexible, extensible, rock-solid solutions... And then they don't have to do anything anyway, cause the problem is solved already, no need for a standard.
If we're going to promote const everywhere we probably want to change the semantics of move to allow moving from const and forbid use after move.
This would be nice, but you have to drop (efficient) compatibility with Linux for that, since IIRC there's no way to open a file with a string_view; it has to be null terminated.
That's where removing implict casts would be nice, and retaining the type of arithmetic operations. If you subtract two unsigned numbers you should get an unsigned number back. The current way is annoying and error-prone. Go gets this right, IMO.
Are you implying it should join() during unwinding? Because that sounds like trouble to me. What if the thread is a worker loop that will keep running until some flag bit is set to "done"? You'll cause the stack unwinding to stop indefinitely and your exception will remain in flight, uncaught.
We'll be there for a while.
&gt; By default, all pointers would be shared; raw pointers to be used by explicit declaration only Why shared? I rarely want shared ownership for anything, and raw pointers in the presence of careful static analysis like the lifetime profile are not as risky. In fact, I think I would be more likely to introduce a memory leak through some shared ownership cycle than I would be to dereference a dangling pointer.
There's: std::string a = "num: " + 0; which compiles with zero warnings under `-Wall -Wextra -pedantic` in gcc and clang and is undefined behaviour. 0 -&gt; nullptr -&gt; cstring constructor for string but undefined behaviour.
"Because we, as your IT department, aren't going to order an US-layout-keyboard and do to our company IT policies you are not allowed to configure any other keyboard layout."
The efficient implementation for operator[] in vector doesn't do bound checking, but for map it's not the same - you already have to check for existence to find it in the first place. I don't think it would make sense for this case to be UB. I could be persuaded to have it behave like at() but I think that the behaviour is different enough from the non const version that perhaps it's better how it currently is. Alternatively the current behaviour could be switched out for a version which doesn't implicitly add new elements, but that has downsides of its own.
I'm not sure we can kill macros just yet. token pasting and stringification have some decent uses that haven't been replaced. For example, if I have an enum, leveraging macros to implement a function to convert the enum to a string is far less likely to contain a typo than manually typing out the cases.
object is a bad name. A class is a type. An object is a value.
Documentation
How does that solve the ABI problem? The only advantage such a distribution has is that it is easier to enumerate all the source files in your build script - nothing more.
Many large tech conferences change locations regularly. It's good to go to a fresh environment - it can help increase attendance. We considered many venues; the new location was the best option given our constraints. It's not that we decided to move away from Seattle. We just didn't limit our search to Seattle.
Only if copying is really expensive (e.g. containers) otherwise, pass by value can actually improve performance, because it makes the optimizer's life easier. I for one am very happy, that I can cout around my types by default just like ints (i'f you want to prevent copies, just make the special functions private or delete them). But then, the parts of my code that are performance critical are usually very localized, so identifying the odd case, where am unnecessary copy is problematic for my performance or latency is relatively easy. From what I've heard I'd probably think differently if I would work in the game industry. 
A lot of code does constitutional commission based on detected features via the preprocessor. Constexpr values aren't available at that stage.
And that is an improvement how?
Premise was that backwards compatibility isn't a concern, and I was only talking about the standard library. Linux (and other OS) specific functions like `open` etc would obviously be excluded to that (well, doubly so considering they're really C APIs that just happen to be usable from C++ rather than C++ APIs). I'd also like to see [GSL string_span](http://codexpert.ro/blog/2016/03/21/guidelines-support-library-review-string_span/) make it into the standard.
I hope we'll get a `constexpr` equivalent to `#ifdef`. It's definitely possible.
`while("the world exists") { /*...*/ }`
[*cough*](https://www.nxp.com/products/processors-and-microcontrollers/additional-processors-and-mcus/8-16-bit-mcus/8-bit-s08-mcus:HCS08)
If this is as part of maintaining it, then I guess the type, function and variable names usually give the most informative and accurate information about what is going on. In practice if there are comments, I will read those and ignore the code until I have drilled down to where I need to put my fix. Then read the code to make sure the comments are correct. Most people don't write enough comments for this approach to work, but it usually works when it's my own code that I wrote long enough ago to have forgotten. Assertions can also be useful. If used well they can capture class invariants, pre-conditions, loop invariants, and other assumptions that the author is either assuming to be true or thinks they have made to be true. A good assertion will reflect the crux of their thinking. If it is to evaluate them as programmer, or as a code review, then obviously names, comments, and assertions are things to look for. Also consistency of style, and especially of indentation.
What's the point? Accessing variables and pointers directly instead of using syntax like `[]` is confusing. news at 11.
Not sure. If you want to conditionally include a header, you need something that operates on the preprocessor stage. Also, if something is syntactically invalid in a particular dialect / c++ version it doesn't make sense to handle that in- language. Imho, if you develop a constexpr feature with all the capabilities of a macro, you very likely will end up with just another syntax but the same problems.
I also use factory methods in C# and C++, so I understand what you're getting at, but there's an optimization angle to consider: named constructors could initialize memvers directly instead of initializing and then assigning. Furthermore, the factory method approach requires you delegate to a private constructor, and now that private constructor that you made just for the factory method is part of overload resolution. It's just messier than if we had proper named constructors. ( cc /u/Nicksaurus )
they do less....less what? less memory management? less fighting with platform details, build flags? Is is that 'bad' that in order to compile a java project which has 1 or 100 or 1 million lines of code I have to write 10 (ten) lines of build setup (maven)? That includes handling for all dependencies too. The right way, if of course to spend a lot of time fighting with build, packaging and all that. Because 'that' is the job, and not the product itself. Right? ps: huge c++ fan here. But the (dis)comfort in using the language is what drives away people to languages 'less'. Simplicity is a huge feature. And is lacking here. 
Code shouldn't be unnecessarily clever, but I think reading speed should be slowed down. Yes, the adage goes that code is read more often than written. I would, however, add that code is not read more often than it is read. Code only gets read when a) it is being written, and b) when something goes wrong. &amp;#x200B; If code is being read for the second reason, then I would say speed reading code is going to cause more errors.
Any chance CppCon will some day go outside US or even North America?
that's absolutely not true, a factory method does nothing more than build an object, there is no requirement for private constructors, and if performance is really a concern you can either call the constructor directly or design the factor method to use perfect forwarding.
Has the guy defending binary packages ever seen vcpkg? All the things he mentions (download, compile, resolve dependencies) are solved by that. Of course build times still do matter.
Yeah! USA-based C++ developer looking for an excuse to visit Sydney, here!
Untrue, proposed `std::error` can be specialised just as much as an exception type for any custom or bespoke type. The polymorphism is in the *value*, not the type.. I just supplied a proof in code to WG21 last week. You can see it for yourself at https://wandbox.org/permlink/dwDF69iNiRprceP2
It is proposed that *static* exception specifiers be added to both C and C++. See http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2289.pdf. These are 100% compile time enforced, and thus are actually useful, unlike dynamic exception specifiers.
You're not required to even bother writing any constructors or factory methods at all. I'm talking about common usage. Everything you wrote after "if performance is really a concern" is what I was talking about in my second paragraph.
I already live in the world where everything is distributed as a source. This world is called [Gentoo Linux](https://www.gentoo.org/). There are several others that do the same. You can try one of them for a while, maybe it will give you a new perspective to this. One consideration out of many is that not all of the universe is written in C++, and not everybody conforms to the idea of C++ modules. 
at first, i usually read example usage or unit test cases, then i read its documentation, and review main parts of codes!
Type based exception throws can be implemented using a `std::error` based mechanism with 100% source compatibility. The breakage is with binary compatibility with C++ compiled by older compilers. Herb mentions this in his paper, I propose a specific mechanism in WG14 N2289.
THAT is a shitty reply and I'm done with you.
I think it's great. The one thing that's a bit of a shame is that now two of the premier conferences, C++Now and CppCon, are both in the Denver area. Of course the two conferences serve very different purposes, but there's a lot of people going to both, or sometimes to the one and sometimes to the other - so where previously you'd go to two different locations, which was awesome, you'll now go to the Denver region twice. Ok - Denver is still very different to Aspen, so I guess that's ok too. And Denver is sort-of easy to get to for international people too, which is not too bad.
Hey OP, can you add a link with the other parts of this article? Also, I wonder if there is a forward include to std::string (or something I could do to make them forward declared). Thanks.
Do you guys stream the talks live? Or non-attending public can only access them in YouTube afterwards?
if you look at the [implementation](https://github.com/KnightOS/libc/blob/master/src/gpl/ldexpf.c). it boils downs extracting the exponent and adding the power. I looked at the [assembly](https://godbolt.org/z/ezdYkv) it calls ldexpf and nothing more. It loads the float in a vector register and exponent in edi and calls ldexpf. I also tried -march=native. It resulted in the same.
Which particular hardware instruction did you expect it to use?
Since you knew it, maybe you know a way to get the type automatically ?
Hey! You can find other articles from my profile: [https://medium.com/@drodil](https://medium.com/@drodil) No there is no forward declaration for std::string and one should not forward declare any std members anyways (see response to my post for more information) &amp;#x200B; Direct links to other parts here: [https://hackernoon.com/shared-static-variable-for-all-template-class-instances-eaed385f332b](https://hackernoon.com/shared-static-variable-for-all-template-class-instances-eaed385f332b) [https://hackernoon.com/shared-enum-operators-71562163f6eb](https://hackernoon.com/shared-enum-operators-71562163f6eb) [https://hackernoon.com/c-telltales-pt-1-human-readable-thread-id-92caa554a35f](https://hackernoon.com/c-telltales-pt-1-human-readable-thread-id-92caa554a35f)
while("this loop was written by u/reddib and you should blame him if it causes problems")
&gt; If you have a class that uses any of the stream classes from standard C++, you should use the `&lt;iosfwd&gt;` header in the class declaration and only include the necessary headers in the implementation. That's assuming separate compilation, that reducing build time is a major concern, and that one doesn't use the standard library via a precompiled header. 
It is useful to avoid leaks in C or C++ that manages resources manually and has to do cleanup at the end of the function. It hasn't been a remotely useful role since C++11 though.
I would say 'correct' is just assumed in this context. Any practice in coding, or any field really, is worthless if it's not done correctly. Consistency? Worthless if it's consistently returning faults and exceptions. In this context, of 'correct' bring assumed with this question, documentation is king. I'm going through some C and H right now, reverse engineering it, and let tell you, it is some of the best documented *anything* I have ever seen. The programmer wrote a paragraph of comments, explain what, how, and why, for every single function of code. It's glorious, and the only reason this reverse engineering project is going anywhere nearly as smooth as it is. Without these comments, we would have essentially just accepted this product as a black box we can do nothing about, and simply have to carefully work around so as not to break it. 
I was falling back in love with C++ and then I read Scott Meyers' book. The quest for zero cost abstraction is a myth. I think I would rather juggle chainsaws than deal with the fine print.
Is it possible to solve backwards compatibility using something like this? #pragma c++17 { //means the following code is c++20 //in this block we only use the latest syntax } or #cppversion c++17 { //means the following code is c++20 //in this block we only use the latest syntax } 
binary with 0b is supported since C++14
Indention.
I would also add const correctness.
Typically if there is some native operations they are wrapped in the built-ins. And then library function is implemented via those built-ins
This whole array-decay-to-pointer business
[Pacific++](https://pacificplusplus.com/) is in Sydney next month. But it's a smaller convention, only two days.
Implicit generation of this special functions is not a problem in itself. It starts to be a problem when it (implicitly) violates rule of 5: If user defined destructor is provided currently compiler still generates copy constructor and assignment operator but it should not (because if you need non default destructor, default copy constructor and copy assignment operator rarely make sense). This behaviour is already deprecated. So it can be removed in future versions of standard.
I haven't heard about QWERTZ keyboard too, before writing this comment I actually thought you had typed wrong keyboard name :). Is there a Euro symbol instead of $ too? how long do you get used to that keyboard?
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
How do you/your team maintain open source libs and keep them up to date with original repos? I guess you're not just using `Boost`, so it might take significant effort.
That's awesome. September's busy for us, but I could probably make it to Denver for a day, maybe two, whereas I wouldn't be able to make the trip out to Seattle.
He mostly use C (and Windows).
[//Code generated by the C++ Middleware Writer version 1.14.](https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/zz.middleBack.hh) I think it's creative and helpful, but not everyone sees it that way.
I watched this yesterday. I would have liked to get a gcc perspective, but hearing from other compiler devs was interesting. The panel wanted to know if they should focus on faster compile times or run times.
Alright, fair enough. The languages in question give me less options, options that I am accustomed to, and demand to be able to, exercise, by doing more in ways that I dislike. To compile my CPP projects at my day job, it takes 10 lines of build config file, no matter how many lines of code that involves, including handling for all dependencies. I don't spend hardly any time fighting with build options or packaging, until I need to. But when I need to, I need to, and that's all there is too it. So I get my cake, and I get to eat it, by using C++. There is a learning curve, because complexity is not simple. Arguing that people are driven away from using a sophisticated power tool because the power tool won't remove half it's features is silly.
"Reading" for what purpose?
how could I substitute another &lt;array&gt; implementation if there is no &lt;array&gt; but only compiler builtins ? 
that's why we need language-level variants.
Did you compile it with or without debug informations? And can you post you test code?
Sorry it's been a day since I wrote that, I forgot that I specified it could be a built in. Replace built in with implementation defined and you still get the ability to swap out implementations but we can get rid of native c style arrays.
&gt; SBRM (scoped based resource management) appears to be another one, but I kind of dislike that one as well. for me it is the clearest definition
Ok so since you mentioned 3rd party frameworks, and many of them have custom deallocators, how would I incorporate that?
 I've once looked for an hour why &gt; for (size_t i = v.size(); i &gt;= 0; i--) &gt; { &gt; /*...*/ &gt; } Resulted in an infinite loop. I was a novice at the time, but still ...
Yes. May be I am wrong I prefer to have some excellent and in-demand features implemented directly at language level, not in STL. I just feel that this is more effective approach.
I generally consider dynamic polymorphism part of inheritance, which in turn I consider part of "classes".
It's a nice enough location. And I sure hope this change works out for the best. But I have reservations about the choice. As the only advantage over Bellevue I see is that it's a slightly bigger venue, accompanied by a variety of disadvantages. I'm so glad I'm not involved in such decisions, as I can imagine it was a hard choice to make.
You can find the work that Titus mentions as [\`std::compile\` is here](https://rawgit.com/bfgroup/std_cpp/master/doc/std_compile_D1178R0.html). Note that it's a WIP and the first revision will be frozen for the WG21 mailing deadline next week. As I'm making edits to respond to current feedback from the SG15 reflector and from conversations at CppCon.
Uniform Initialization is necessary to solve the Vexing Parse and Most Vexing Parse, so I'd rather "demote" `std::initializer_list`. Writing `std::vector v{{1, 2, 3}};` when you want to pass an `initializer_list` is easy enough, after all.
At this point, I'd rather have free-functions: `release(p)` is perfectly fine :)
Spot the performance issue: bool contains(std::unordered_map&lt;std::string, int&gt; const&amp; map, char const* key) { return map.count(key) &gt; 0; }
I am not suggesting at all that you do so, but just wanted to point out that in some other fields (I work in medical physics, so this is the point of view I am coming from), the conferences move around each year to make sure that every once in a while, the conference is nearer to other parts of the community. Again, not saying you should do that, but pointing out it's not unheard of.
Got you covered: `using size_t = int64_t;`
The problem here is implicit conversion - not copy. 
Typically it takes no more than forking the lib in question locally and keep the modifications on a branch which will be rebased to HEAD when necessary. The essential parts (i.e. just the sources without all of the build cruft) will then be transferred into our subversion repo ready for consumption. In most cases this preparation takes no more than just a couple of minutes, and many libraries don't have new releases that often. The consumption part is fully automatic afterwards.
One downside of this is diversity of locations. My two favorite C++ conferences in the US are CppCon and C++Now. C++Now is held in Aspen, Colorado. With CppCon now in Denver, the 2 major C++ conferences are being held relatively close together.
This is the top-level comment for **meta** discussion. Reply here if you have questions or concerns about this post.
As it's now October, the [Q4 2018 thread](https://www.reddit.com/r/cpp/comments/9kig88/whos_hiring_c_devs_q4_2018/) is now live; you should post there.
My question might be stupid, but why is this important? 
main(){[](){}();}
Also, the actual problem is the design of std::map, which got at least somewhat better with transparent comparators.
A bigger binary size can be prohibitive in e.g. embedded systems. Developers in the demo scene would probably also stay away from it. A bigger binary size can also lead to worse performance due to less effective instruction cache utilization. 
I didn't think this sort of use was prevalent on STL and C++ was prevalent in embedded. I had considered the instruction cache misses, but there is no evidence from OP that this is an issue in that regard. 
&gt; Locally scoped functions (not lambdas, more like static methods on a local class) should be a thing. What is the difference to a lambda that doesn't capture anything?
&gt; Drop ADL, rely solely on Concepts for what ADL was previously used for. What has one to do with the other?
&gt; Designated initializers shouldn't care about order written. Just implicitly reorder them, and require that compilers warn about uninitialized dependencies (e.g. passing fields of member to another member's constructor when the first won't be initialized yet). Are you really talking about c++2a designated innitializers or are you referring to something else? If so, what?
Well, 'failure' may be too strong, but: there has to be better notations for pointers, pointers to functions, etc. It's just not good (in C) that everyone more or less has to use typedefs to get a sane, readable way to use things like arrays of ptrs to functions etc. 
Pretty cool! I'll leave to try it out in my projects.
 $ du -csh ~/build-score-Sanitized-Debug 21G /home/jcelerier/build-score-Sanitized-Debug this is the size of one build configuration of the software I'm working on. It requires multiple gigabytes of RAM to build &amp; link in debug mode due to all the debug info bloat generated by `visit` and other language-level constructs - you wouldn't believe how much bloat boost.asio adds in debug mode, even though it entirely gets inlined in release mode. The release binary is ~20 megabytes and has kick-ass top-notch performance - but 99% of the time I and the other devs build in debug mode because it's where bugs are catched.
That won't fit in a tweet...
That's also outside the scope of what OP is presenting. And, I don't disagree that the bloat in debug symbols can be a problem. It wasn't presented that way, however.
On the other hand, one of the great things about C++ is that it gives library writers so much power. It seems like you should be able to write a library variant that is just as efficient as a language variant (thought a library variant may be more awkward than a language variant). If you cannot, we need to explore more in depth why. A language variant can definitely be made more smooth to use. However, it should not be significantly more efficient.
Ability to overload, and not being semantically an object.
Could you show an example with adl and with concepts? I have to admit that I haven't looked into the details of concepts, but to me they seem to be orthogonal to adl.
Yep, this is talking about the new designated initializer syntax. It makes no sense to me to require you always write them in declaration order.
`this` changed to be a reference rather than a pointer.
Oof. The random logic ones. That's a lot of brutally in such a short entry.
I'm away from the keyboard so I can't right now, but I don't think it can be fully covered without something else on my wishlist, which is being able to overload on concepts. Instead of having to add an argument's namespace to the overload resolution search, the thought is it could dispatch to the concept overloaded free or member function.
That actually happens on 64-bit platforms, so no big deal.
I was wondering how this compares to [libsimdpp](https://github.com/p12tic/libsimdpp) and what it offers over it. The one I linked is header only which made it nice and easy to drop into my project as well. Is something restricting this?
Saying "rad" is also a lot nicer than RAII.
CppCon is run by a US based 501(c)(6). It would be very hard for us to do business outside of the US. Also, there are many people within the US who cannot travel outside of the country due to visa restrictions. Of course, there are many who cannot get visas into the US as well. Neither way is perfect. Also, there is less of a need these days. There are already many excellent C++ conferences outside of the US. [Meeting C++](https://meetingcpp.com) is the large scale European C++ conference.
A 5 part series on equivalence relations seems a little long winded. I mean, if you want to read so much to understand equivalence relations, you should rather read Halmos' Naive Set Theory.
Nope. I've never needed such code, and when I'd need it I'd write down the type manually.
delete ( new Cpp() );
I feel the concern you described except with ADL rules. IMO, if you want to use an unqualified free function name, add a using directive for it.
If you want code to easily detect extended instruction sets that are supported by your processor, Microsoft has some excellent sample code: https://docs.microsoft.com/en-us/cpp/intrinsics/cpuid-cpuidex?view=vs-2017 It uses the `__cpuid` intrinsic function to load information from your CPU. If you click the link and scroll down, there is an example C++ class (InstructionSet) that loads the relevant information and exposes the availability of each extended instruction set.
I also compared boost visitor (but not abseil). I've heard it uses a recursive if approach. In my experience gcc will almost never turn this into a jump table (newer clangs will though, in simple cases though). Surprisingly though it can't even optimize out an empty visitor. See the link: https://gcc.godbolt.org/z/Kt8ZNf. IME, it seems like a sad fact of C++ that nothing really compares to switch case for optimization, but there's also just no elegant implementation for most things with switch case, you end up resorting to macros/codegen. Hopefully compilers will improve here soon (since I hear the committee will not improve switch case) but until then I'll do what I have to do (use macros and switch case).
I've seriously considered the utility of such an `any_of` (and `all_of`). I believe it would be perfectly readable at the call site and be made to avoid copies for one-off uses like in the example. The problems start when you want to keep one around to use later. That's when you need the copies, but lack of careful usage can lead to some bad results for generic code. For example, `1 &lt; any_of(0, 2)`, but `any_of(0, 2) &lt; 1`. Similarly, `1 &lt; all_of(0, 2)` is false and `all_of(0, 2) &lt; 1` is false, but they are not equivalent. Given this, I'd be all for simple uses like `if (any_of(x, y, z) &gt; 0)`, but nothing that would require me to work out whether some generic algorithm could technically fail to work properly because of the lack of ordering guarantees these provide.
Delete this
Well I don't want conditional header includes, I want conditional module includes in that case. It's much easier to make syntax for it when modules are actually a first class citizen unlike headers. You should be able to only output valid C++ code with constexpr, not code fragments but unless you have a weird version, you should be able to replace most macro uses.
Switch case in C++ is very limited in various ways. Most relevant here is that you can't really use it generically since there's no variadic switch case, and it's also quite painful to figure out how you'd set it up on multiple variants (i.e. destructuring; which visit also has to handle). As a result, switch case doesn't end up being a good solution to fully implement visit (for arbitrary numbers of types and variants). So you end up with say function table pointer approach which works well in terms of generic programming but poorly in terms of optimization. Currently what I'm trying to do is to add switch case to library implementations for the "common case" (one variant, &lt; N types for N = 10 or 20). But obviously this is all starting to look pretty ugly. We can keep working around and keep trying to improve compilers but I think it's hard to argue with language level pattern matching (which may or may not immediately imply a language level variant, I'm not sure). It provides a simple and clear construct that immediately gives the compiler maximum information. There's a reason beyond just greater age (and thus more accumulated man hours into optimization) that switch case produces such great assembly. Compiler analysis resources are always limited and even if compilers figure out how to e.g. turn variadic if-else into a jump table in a simple case, they may not do it in a more complex case. With switch case or pattern matching you really make it easy for the compiler.
Why, am I breaking any rules?
It's not thread-specific. One can write a destructor with a loop that will keep running until some flag bit is set as well. Exceptions aren't easy. Threads aren't easy. Worker loops aren't easy. We should be careful anyway and make sure that everything works during unwinding. But now we need to care not only about our code's behaviour, but also about std::thread behaviour. I'm not implying it *should* join. It could though. Or it could detach. Or, better, specify the default action as a ctor parameter. Anything would have been better than the current approach. &amp;#x200B; Also, an obligatory manual join (or detach) forces the "single return statement" style, which is frowned upon by... [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rnr-single-return)! Quoting [Andrei](https://youtu.be/WjTrfoiB0MQ?t=841) \- "Well, aha! If they're 'not good for you', why do you have me write them?"
Pretty awesome. We still use the fizzbuzz interview question where I work. I didn't get the {{ }} initialization of the arrays though (in the Compiler Explorer link). Why use two curly braces?
Excellent points. I actually think we are on similar pages if not the same page. My point is that the inability/difficulty to implement an efficient variant is a symptom. In this case, it seems it is due (among other things) to the limitations of switch case in c++. This underlying cause should be remedied (possibly by the addition of language level pattern match). What would be less than ideal is fixing the case solely for variant by making variant a language implementation.
Yes, but it's more that this is total nonsense
Thanks, fixed the typo.
&gt; $ du -csh ~/build-score-Sanitized-Debug &gt; 21G total &gt; &gt; The release binary is ~20 megabytes This is insanity 
Is your talk that you're referencing "What C++ developers should know about globals (and the linker)"?
No one posted the C constant deducer from Linux?
I mean, the link will. Or a TinyUrl. It is just spam/advertising, though. Not like the new Triple KrustyBurger available for a limited time at select KrustyBurgers near you!
No, that's last year. This year my talk was called helping the compiler help you, not posted yet but hopefully soon.
I can understand people thinking it's important but in the case of std::variant one has to wonder isn't the bigger problem that using it at all is atrocious. It's the poster child of C++ gone off the rails.
Just had to teach a coworker about digraphs and trigraphs in some code he wrote. So I take this back. 
Other service providers don't like there being free service providers. 
Why do people hate giving MCVEs? Is it allergies? 
Is it? And in particular, this part? OP doesn't address that at all. So, back to my question. If you have real world embedded issues, a discussion of those would be illucidating.
What would that even mean?
So instead of telling me to delete this and telling me this is total nonsense, maybe you could act a little more mature and explain what rules I’m breaking, how this is nonsense, or at the very least explain how I could improve this so-called “nonsense”.
If you need to implement a new construct, simply implement it.
I recently bought a mechanical keyboard that has an embedded microcontroller. All of its software is written in C++. People make a lot of extensions for it but if you try and use too many of them you run out of memory. Code bloat makes these problems occur sooner.
I never get the idea of running stuff like that in a vm, every time you may want to open it you start up a vm, its a hassle and it just seems to complicate the issue rather then solve it.
Not at all related to OP's post. If you want to post about that, please do.
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9kmlod/can_someone_tell_me_if_my_understanding_is_correct/e708ja6/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Ok professor.
**Company:** [Binance](http://binance.com) **Type:** Full-time **Description:** We are looking for highly skilled Senior Developers (5+ years development experience as a minimum) to work on our backend for our world class trading platform. We are continuing the development of our platform using Rust and C++, with legacy systems in Java. We are continuing to build up our next generation crypto-currency exchange and are looking for eager, hard-working problem solvers that can continue to evolve our 24-7, highly scale-able, exchange system as new features and performance improvements are constantly being added. **Location:** Tokyo, Japan. Relocation support provided **Remote:** No **Visa Sponsorship:** Yes (Degree or 10 years minimum exp) **Technologies:** C++ (11,14,17) and/or Rust **Contact:** Apply directly https://jobs.lever.co/binance/2c03bc65-3c1a-43d8-ab2c-bbf5899c9d4a Or Email Cayden at [Cayden@binance.com.com] 
You do realize your post is you asking people to use their time to work on a random unknown project right?
Yep, it is a landmine that most people avoid, but there it is :)
Yes I am fully aware of that, however in my post I stated that I was open to all project ideas. So, a person may have an idea to work on and that idea may be chosen to work on. I’m not planning a huge project, more of a drop-in/casual thing. I am not asking anyone to send their whole week on this, all I’m asking for a little bit of your time. And besides, the point of this isn’t to make GTA V, it’s to meet new people and get better at collaborating.
That is ridiculous. I think its high time we stop ignoring debug builds. Atleast it should not be this insane.
While this discussion is going on again, question: With a language-level variant, how do we do the kind of introspection we can do now? For example, imagine you have a variant representing some possible function return types and you have some following operation that makes it possible for the value to be consumed as well: template&lt;typename... Rets&gt; auto process(const std::variant&lt;Rets...&gt;&amp; result) -&gt; std::variant&lt;Rets..., std::monostate&gt;; For the sake of the example, assume `Rets` doesn't contain duplicate types or `std::monostate`. When people want a language-level variant, what plans do they have for this kind of introspection and manipulation of the possible types?
It replaces the very common pattern of auto old_value = value; value = new_value; return old_value; And it does forward properly if you move the second parameter into std::exchange. The name isn't great, but I also can't think of a better one. 
I'm not up to speed on c++17 or the macro magic with \_\_PRETTY\_FUNCTION\_\_ does someone care to untangle that and explain it?
But the name is what would make it clearer.. instead it makes it more confusing.
 #define while if
I apologize but I don't exactly follow. I don't suggest breaking negative indices in subscript operator. I only suggest that the standard library used a signed type for sizes of containers, so I could do reasonable arithmetics on those. If someone is on a 16bit arch and they use negative indices to indicate an error they are just as good as they are today. sizeof can keep evaluating as uintptr_t. Casts of those are visible at compile time. Or am I missing something? Thanks in advance.
&gt; The name isn't great Then is it really a great replacement for the common pattern that everyone already knows, understands, and can quickly parse? 
The generic code would dispatch via concept overload.
Just few months ago there was a game developer investigating using std::variant with 40 types in his project. He gave up because of code bloat. That was the motivation of looking into all this, before I migrate to 17. Seeing the results, I wonder, what does one get for that added code, if one is not working with generic, variadic code? For the end-user it is only a bit less typing, a bit better maintenance, and a tiny bit better semantics. These are all nice, but why should I have to pay such price? Actually, why should I pay *any* price, considering no extra work is done in terms of application logic? 
Use clang-format.
The problem is that the `Vc` types like `float_v` need to know, at compile-time, the vector width of the target, so that they can choose their size. For example, depending on whether the hardware supports SSE, AVX, or AVX-512, the `float_v` type will store 4, 8, or 16 floats, which affects the size of `float_v` objects.
please stop posting each of these as an individual post. They are small enough that they can all be posted as one thing. 
because if you lose the part on the right, it still compiles, even though you forgot to initialize it.
float x = 42.0f; oopsies into float x; = 42.0f but still compiles. Make it auto, and it doesn't compile anymore.
Starting up a saved VM is literally one click. A VM configuration file can be passed between users for easy setup of the same environment. If it goes horribly wrong somehow, you've only ruined your VM. It honestly does have a lot of advantages. Especially in this case where the user wants to continue using Linux but wants to use VS. it's a simple solution.
Many embedded systems developers have a rule to not allocate anything on the heap.
Why would I lose my initialization? And even if I do, the compiler would show me
How many lightweight and flexible C++ logging libraries do we need?
- usage of C pointer function and `void *` is terrible, please use `std::function`, - please prefix your macros, - I would suggest a `operator&lt;&lt;` interface rather than printf style especially because printf is unsafe. You may also use variadic templates instead.
Yet another text-logging lib. Are there any good "semantic logging" libraries for C++?
on-line C++ code generator &gt; The actual C++ Compiler.
i prefer: constexpr bool ever=true; for(ever) { }
I find std::optional&lt;std::reference\_wrapper&lt;T&gt;&gt; just so overly verbose and using std::reference\_wrapper is also annyoing as you always have to type .get() to access the underlying reference (since overload operator dot can't be overloaded). &amp;#x200B; I came to the conclusion that with C++17 it's not worth the hassle and one should simply use T\* instead of std::optional&lt;std::reference\_wrapper&lt;T&gt;&gt;.
Or even instead of `std::optional&lt;T&amp;&gt;` if it were allowed. 
Here's a non-golfed version with explanation: https://godbolt.org/z/TNB6b1
Ok, maybe I could post a series once in a while instead every article as its own. Anyways I will be posting multiple times a week.
Because of such reason i find modern c++ super unfriendly to work with. All such features should be build-in in the language, not provided as standard library with hundreds of namespaces and weird names.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9kpiv3/how_long_would_it_take_for_a_noob_to_be_able_to/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; (*) A reference can, technically, be null: T* pointer = nullptr; T&amp; reference = *pointer; No, it *technically* can not. The only way to try to do it, like you just did, is by dereferencing a null pointer, which causes undefined behavior. The standard explicitly addresses this in section 8.3.2: &gt; A reference shall be initialized to refer to a valid object or function. [Note: in particular, a null reference cannot exist in a well-defined program, because the only way to create such a reference would be to bind it to the “object” obtained by dereferencing a null pointer, which causes undefined behavior. As described in 9.6, a reference cannot be bound directly to a bit-field. ] 
Hmm, I think `std::optional&lt;T&amp;&gt;` would be fine. I already use `boost::optional&lt;T&amp;&gt;` a lot, and it's two characters shorter. :) It comes down to expressiveness; `T*`, though it is technically exactly equivalent to `optional&lt;T&amp;&gt;`, is often used for a value that should never be null or for an owned value.
Your footnote on a reference being unset is wrong. That is undefined behavior, thus explicitly NOT C++. You would be more correct saying that it can be done syntacticly, but that it has no semantic meaning. In 30+ years of C++ programming, I've never seen the need for nullable or reseatable references. To extend your analogy, it's like saying you want to grab your luggage and you don't care whether there is something there or not. Or which actual piece you are connected to. 
No, that's the point - the it would still compile just fine. Did you even read the article?
Rebinding semantics on optional&lt;T&amp;&gt; assignment? Great Scott! Over my dead body!
Couldn't they call it std::opt and std::ref_wrapper...
I often introduce private inheritance as a way to import stuff, while not enabling syntaxic substitutability. I don't care about visibilities. I only care about the objective: - either to import and just import (private inheritance) - or to provide LSP compatible children (public inheritance) I've never found a meaningful scenario where protected inheritance really makes a difference.
&gt; std::function but std::function is anything but lightweight
&gt;std::court &lt;&lt; std::endl; Hm, I don't think this is a type. At least I saw a dark humor joke there =)
If C is separated from C++ it means that all those C headers won't be able to be included in a C++ file
After 17+ years of C++, I cannot use a few lines of build config to do anything - in a real world, non trivial project. It's just not that easy. So, good for you. I like hiding complexity. I like abstractions, even though I need and use the power 'behind the scenes'. I prefer the perceived simplicity of string or shared_ptr (whose complexity I totally ignore) in detriment for the 'sophistication' of the code that is handling char* or raw pointers. As someone put it: I like code that reads like python, runs like C and is pure like haskell. I love C++, but I think it is slowly fading away. It becomes more and more complex and that's not what the mainstream uses.
So... An optional&lt;T&amp;&gt; would, in your world, never be able to transition from empty to non-empty, or from non-empty to empty?
 optional x = ...; x = optional{foo}; No arguing over the semantic that way :)
But... That would be rebinding?
Isn't what metaclasses aim to be?
This link is garbage on mobile. Also if someone isn't going to use a real word for a description I'm not going to bother reading it. Also how is this not solved with a u8 typedef?
Yep. Agreed. Perhaps I need to change the way I write raw data manipulating code, but in a few instances I tried simply replacing **unsigned char**s with **byte** and it (the casts mainly) made the code so much uglier.
True. The current copy paste behavior of include prevents that. Therefore this checks needs to be performed before include is copy pasted. Maybe a pre-preprocessor? Or an alternative for include is needed, such as modules.
Hi, author here. Could you elaborate the "sucks on mobile"? I've heard before the template isn't good on mobile but "it works on my machine" (Androids, mostly). Works defined as 90% of screen real estate is text, ignoring WP's ads. Concrete tips to improve mobile compatibility will be welcome. &amp;#x200B;
So what are we supposed to represent images ([0, 255])? `std::byte`, `std::uint8_t`, `unsigned char`?
That sounds pretty horrible, but I'm afraid I can't reproduce it in any of my mobile devices. I do see an ugly ad before the content but I can't really do anything about that. That's the price for the free tier in wordpress. Thanks for reporting it though! &amp;#x200B;
`std::byte` is for binary data that isn't an integer or bitfield anything else. Just a blob of binary data. If you want a 1 byte unsigned integer type, then `unsigned char` is indeed the "correct" type. 
`std::uint8_t`. That's the type that's guaranteed to be 0-255. `unsigned char` isn't a specific size so isn't what you need. `std::byte` is only really intended to be used to mess around with object memory (for things like memcopy et al). It's not for mathematical use.
Cool, thank you!
I haven't watched this yet, but the new category of side Channel attacks inside CPUs including Spectre is hard for even professionals to get it reasonable understanding of. I hope Chandler does a good job explaining it in such a way that the mid-level to expert in another topic type of person can understand it. He barely speaks directly to novices, but that's awesome because he's doing something specific and complex. I'm going to watch this and report back my opinions.
&gt; No, it technically can not. Technically means "Strictly speaking", so *strictly speaking* it's possible to have a null reference, you just have to intentionally fuck it up. 
Fibonacci sequence can start with any two natural numbers. The ratio is the limit of the sequence will be reached anyway.
well worth a watch, summarizes side-channel attacks fairly well, gives hints on mitigations from casual developer perspective.
The way I see it, we have had optional references (T\*) since forever, but we didn't have optional values (T) and `std::optional` plays exactly that role: it even models the pointer interface for consistency. So there is absolutely not reason to circle back and replace the already functioning T\*.
I would argue that uint8_t is a much better unsigned integer type than unsigned char.
Well the error in the given code isn't the `byte{42}` line, but the `b &amp; 0b11` line. It instead has to be written: return b &amp; byte(0b11);
True. But readability nowadays is a problem(when using template meta-programmed library ). Today we have short discussion about it. std::guard\_lock&lt;std::mutex&gt; l(lock\_); // C++11 std::guard\_lock l(lock\_);// C++17 This is language level change. Not only more readable(less noisy) but support is also easier. &amp;#x200B; &amp;#x200B; &amp;#x200B;
Unless you're on one of those wonky systems with 256bit chars 
This is one topic, where I'd preferred good diagrams over example code, but otherwise he did a pretty good job. I have to say, the whole thing just became even more frightening than it already was.
Part 1 is about equivalence relations, Part 2 is about ordering relations, part 3 is about writing comparisons for your type, part 4 is about the spaceship operator and part 5 is about ordering algorithms.
The fundamental problem is that there is (afaik) no way to distinguish a literal int from an int variable so std::byte can't e.g. overload binary bit wise operators to accept integer litterals. I hope for a literal suffix for byte.
I just finished watching this while I was working. He did try to present this topic in a way that a mid-level C or C++ developer should be able to understand. They were plentiful code samples, and he ran them on stage and there were no major technical issues. I felt he did a good job explaining all but the second code sample. I learned a great deal about how Spectre in the family issues works and how there are a number of issues that weren't related, but the news media did mire in with them. I would recommend this for anyone with some systems level programming experience who wants to learn about the Spectre security bug.
While I agree good visual samples are nice, I'm not sure how you draw a diagram of this. He's talking about code that never ought to be executed being executed not exactly a topic that what inspired Rembrandt or Monet.
You can also create a byte user-defined literal, e.g. `_b`, and use it like this: return b &amp; 11_b; // to be equivalent of b&amp;byte{0b11}
I mean I wanted to get the code for me to get the sequence where the 2nd number should more than 1 from the first number. &amp;#x200B; Eg. \- 3,4,7,11,18 \- 2,3,5,8,13 \- 1,2,3,5,8
&gt; After 17+ years of C++, I cannot use a few lines of build config to do anything - not in a real world, non trivial project. I'm just saddened by this. Not because of your example specifically, but because this is common in the C++ community. The C++ language itself being complicated doesn't result in poor tooling. Poor tools are their own fault. The build system that my day-job has is certainly not perfect by any stretch of the imagination, but it really is as simple as 3 lines of configuration to build a project with all the default settings. Any deviation from those defaults is typically one or two lines of extra code, but can be more if it's more complicate. We're able to change the settings for each individual c++ file being compiled if we really wanted to (but we don't want to, and I'm not aware of any project at my job doing this, so it's rather cumbersome to be able to do so and takes a lot of extra build config/code.) Basically all I have to do is write &gt; "Type of build (exe, dll, so on)" "name of build" for the absolute simplest, all defaults, build that has no dependencies beyond the standard library. I can optionally "publish" the build so that it ends up being picked up by things outside its codebase. I can compile only specific cpp files. I can change the list of dependencies. I can change the compiler and linker flags, and I can do all of those things conditional on what my platform target is (e.g. linux, windows, x86, x86_64, so on). By comparison, tools like cmake are garbage. What I can do in literally 1 line, takes 10+ in cmake. What I can do in just a hundred lines can be up to thousands and thousands in cmake. And this is for a codebase with many hundreds of libraries, and millions of lines of code stretching back to the mid 90s. &gt; It's just not that easy. So, good for you. :(. It could be. I very much doubt that a standardized system as published by the ISO C++ standards committee is where the answer is though. &gt; I like hiding complexity. I like abstractions, even though I need and use the power 'behind the scenes'. I prefer the perceived simplicity of string or shared_ptr (whose complexity I totally ignore) in detriment for the 'sophistication' of the code that is handling char* or raw pointers. Yep, I like high level abstractions as well. In large part because I have an excellent understanding of how they're implemented and the consequences of using them where I use them. Sometimes the out of the box tool is a perfect fit. Other times it needs a new set of template arguments. Rarely, but it happens, you need to write something very customized to fit your need, the standard widget doesn't cut it even with tweaks. &gt; As someone put it: I like code that reads like python, runs like C and is pure like haskell. In my opinion, python is unparsable to the human eye. That whole semantically meaningful whitespace concept is brain pulverizing to me. Maybe I'm broken in that regard. But I do understand what you're trying to communicate. I'd point out that C++ frequently beats C in various benchmark applications, even when being prevented from using idiomatic C++ code in favor of slower solutions (There was a post here in /r/cpp about this some 4 months ago or so. Just before the original language benchmark website was scheduled to shut down. Though I believe it migrated somewhere else instead of closing it's doors?). &gt; I love C++, but I think it is slowly fading away. It becomes more and more complex and that's not what the mainstream uses. From my perspective, I think C++ is gaining more complexity under the hood, but becoming significantly less complex on the surface, and for the majority of C++ programmers who have no need to dig deeper than the first couple of surface layers (That'd be the vast majority of C++ programmers, I wager) C++11 and newer are considerably easier to learn and understand for that surface layer. I started my career in C. Honestly, never again. I'll contribute to a project that uses C, but only if I'm trying to use it and can't find something better. And even then it's like bashing my face against a wall. The language is just barely capable of expressing meaningful concepts concisely. &gt; ell me that you need xvalues in every day use. Tell me that you know all the initialization rules. The resolution overload, all the template quirks... I have a decent working knowledge of xvalues, and deal with template code that handles various value types regularly. Probably not everyone needs to deal with this. Some of us do. I agree with you that the initialization rules have recently gotten out of hand. That doesn't imply that the c++ language should be neutered. Simply that we have a problem to solve, both at the process/commitee level, and the language level. I do deal with resolution overload and template quirks all the time. I manage to crash Visual Studio 2015 (Oh how I wish I could upgrade to VS2017) regularly with some of my template code. &gt; And I will say: you are lying, it's mostly accidental complexity. And there's lots of it in c++. (Some of it because of the backward compatibility cruft). That's not really nice to say I'm lying. You can accuse me of being wrong, being misinformed, or having come to the wrong conclusion. But lying is the notion that I'm deliberately stating something I believe to be a falsehood. I'm sure that's not what you were trying to say, and I have no animosity, so no apology needed. I don't enjoy the level of backwards compatibility that we, as a language community, pursue. I dearly wish we had a better way to support deprecating things. Like language-level feature flags to allow the compiler to operate in backwards compatibility mode or something. For example, as you pointed out, the initialization syntax stuff is mirred in complexity and leaves a lot of "Do what the programmer expects" problems in the wake of the uniform initialization syntax stuff. &gt; Yes! It's powerful. But it's killing it(self). //I hope I'm wrong. I don't disagree that we recently got a little carried away with new syntax options. E.g. I find the syntax for Concepts to be annoying, and think Bjarne's preferred syntax to be dangerous for people unfamiliar with a particular codebase. I'd rather see more (relatively little) things like the spaceship operator than big changes like Concepts, and I'd rather see things like metaclasses (E.g. I quite enjoyed the $ syntax the paper from last year demonstrated, even though that's apparently not going to be used anymore), than co_routines. And I think I share your opinion that the language is moving more quickly than we can identify and solve the problems for newly added features. We're adding a bunch of add-ons to the language instead of improving the core mechanics. Like, for co-routines. What the bloody hell is "co_await" ? Thats a viscerally disgusting keyword. But most of what we're discussing here doesn't really apply to build systems, does it? :-) Build system ease of use does not imply a lack of options or complexity under the hood. I'd be all for a standardized build system if I expected it to be, in any way, both simple and also powerful. But we all know that that's not going to come out of the C++ standards committee. So lets not bother, and let them focus their wonderful efforts on the core language, while the community can offer the full range of possible solutions?
1 byte yes, but 1 byte is not guaranteed to be 8 bits, just at least 8 bits. See https://isocpp.org/wiki/faq/intrinsic-types
"Size" here refers to the bit width, not to the size in bytes. Of course `char` is always 1 byte wide, but that byte is not always 8 bits.
I was at this talk. It was great and I learned a lot, but there were a lot of threads I couldn't follow. When it was over, I was chatting with the guy sitting next to me. He said basically the same thing (he couldn't follow everything). Turns out he was Howard Hinnant (the author of move semantics, unique\_ptr, and a bunch of other stuff). So I don't feel so bad.
Indeed. 1 byte is 9 bits on Unisys 2200 series machines.
I didn't know it until five seconds ago but all I've ever wanted is to be introduced by a live band before I give a talk.
std::optional/variant/any use the `std::in_place_t` type tag to prevent their constructors from overloading those generated by the compiler. consider using that in your own classes if you really do require perfect forwarding
&gt; Turns out he was Howard Hinnant Lucky you!
Ah ok - no worries. &amp;#x200B; Although I have to say: in a pre-c++17 world without \`std::string\_view\` I think that particular implicit conversion was quite important.
It's an alias for and prints like a char, which is unintuitive.
I guess pointer can be used as optional reference, because it doesn't do anything more than this. You can do delete operation on it which you don't want in optional references, though. And dereferencing nullptr is UB, which is questionable, but I think compilers have flags for checked exceptions (transition unit-level, unfortunately). And no default constructor when on stack.
Dereferencing `std::optional` is also UB.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9kshfc/emergency_code_problem/e71hr08/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Anybody else noticed Dvorak keyboard layout? Is programming with it better / faster than with traditional QWERTY layout?
It sounds like you have adware on your phone. Android?
I’m assuming he has some kind of adware or something. On my phone, I just got a single inline box ad before the content that wasn’t even slightly intrusive. If every website were like yours, I would never use an adblocker
T^ is too concise for the c++ standards committee, we have T&amp; for a reference, T&amp;&amp; for move semantics, so clearly the next logical step is T&amp;&amp;&amp; for a move-able reference
&gt; static_if for templates to replace some ugly SFINAE How would that be different than `if constexpr`?
I had a bit of trouble following how the illegal access was translated into a specific cache access time, but [this video](https://www.youtube.com/watch?v=IPhvL3A-e6E) from Matt Godbolt fills in the gaps. Chandler's talk was an excellent dive into how they're fixing it, but I found Matt's explanation of the actual issue more detailed.
That's a nice idea. Might be a good workaround. I'll try it out the next time I have to fight bytes. Thanks!
&gt;If every website were like yours, I would never use an adblocker Thanks! To be fair to every other website, I'm not monetizing anything. That makes it easier to choose the least intrusive setup I can get for free.
Matt Godbolt has [a great video](https://www.youtube.com/watch?v=IPhvL3A-e6E) that goes over the underlying issue more clearly. Basically, a byte is speculatively loaded from a "off-limit" region of memory. It is then used to compute an address in a cache line that's not currently in the cache. The computation of this address depends on the illegal value in such a way that different values would target different cache lines. This cacheline is then fetched by another speculated load instruction. At some point after this happens, the speculative branch is aborted, and the instructions are undone -- but that cache line still exists in L1. Then, back in the process space, a set of possible cachelines are loaded, and the time it takes to load each is measured. The one with the fastest time was already in the cache, and this information can be used to derive what the value of the illegal byte was. In pseudocode: https://imgur.com/a/3Sm6xS1
By "exactly equivalent" I just meant that the type "has the same set of possible values" rather than "always acts the same."
&gt;The one with the fastest time was already in the cache, and this information can be used to derive what the value of the illegal byte was. How? That's amazing. Even after looking at the pseudo code, it's not at all obvious to me how timing information can be used to derive \_what\_ is in a cache line. I can see how it can be used to determine \_that\_ something was in a cache line. An short access time relative to a higher access time implies cache locality. How the iterator in the pseudo code is directly correlated with the cached value seems to require more explanation.
I don't
It is uniform between arrays and array-like types and pods and pod-like types. There is s difference between uniform and universal. 
&gt; Use std::uint8_t. That's the type that's guaranteed to be 0-255. It's guaranteed to be 0-255, but it's not guaranteed to exist. `unsigned char` is guaranteed to be `sizeof(1)` and at least 8 bits. As such, any platform where `std::uint8_t` is defined will by necessity have an `unsigned char` of exactly 8 bits. If you might be working on esoteric systems, then `unsigned char` will be at least 8 bits, and if you prefer to use the `std::uint*` types then you can use `std::uint_fast8_t` which is guaranteed to exist and be at least 8 bits. In practice `unsigned char` is perfectly fine and will work as expected on all platforms.
Can you put if constexpr() in front of a function declaration? template&lt;class T&gt; if ( std::is_pod_t(T) ) { void Function(T&amp; t) { .... } }
C++ is useful for systems programming. Let's keep it that way please? All you will succeed in doing by trying to enforce such philosophies is alienating large parts of the user base.
And you can do pointer arithmetic on T*, which you shouldn't be able to with an optional reference.
Ah, [that kind](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3613.pdf) of static if. Not sure the benefit it provides (since the inclusion of `if constexpr`) worth the potential abuse.
I spent a the intro going "take it by value and move" and the rest confused at why you'd bother with the templates. He says this isn't taught, but obviously I picked it up somewhere. Perhaps because I watch out for interesting CppCon talks?
&gt; Well, proposals exploring potential solutions sounds like extending lifetime extension rules, or making them accessible to user defined types? In which case, I fully agree that lifetime tracking is a much better solution. More like making the rules that already apply to temporary lifetime extension via `const&amp;` available to user types, so we don't have magic to teach/explain about how `const&amp;` can do things nothing else can. &gt; Also, to be clear: I've yet to hear it said that banning of optional&lt;T&amp;&gt; has anything to do directly, per se, with dangling. I recall it showing up in committee notes as the precise reason it was disallowed, in fact. &gt; The supposed alternative to a nullable reference is a pointer, which has dangling problems at least as bad. Pointers are not semantically the same thing as `optional&lt;T&amp;&gt;` would be. A pointer is a location in memory, either a valid object, or null, _or_ some address that is not a valid object; a one-past-the-end address, or the address of a destructed object, or the address of allocated-but-uninitialized memory, and so on. None of those are undefined behavior, to be clear; those are all things that can legally be in a pointer in a perfectly defined program operating as expected, because a pointer makes very few promises. Instead, a pointer makes a simple demand: if it is dereferenced, it must be pointing to a valid object, and it's _your_ problem to make sure before dereferencing. Easy enough if the pointer is null, but not so easy if the pointer is in one of those other states. Your _convention_ may be that your pointer is either pointing to a valid object or to null, but that isn't in any way guaranteed or even proscribed by the language (the language very explicitly makes all those cases above perfectly legal). Put more simply, a pointer encompasses many possible states: null, a valid object, a one-past-the-end address, or uninitialized memory, and there is no means to differentiate between all of those states. A pointer is an object with 4+ possible states but can only clearly distinguish one of them by itself (null; all the other states are not-null). Contrast to an optional. An `optional&lt;T&gt;` is precisely either a T or it is empty. It has exactly two states. Both of those states can be determined by querying the optional itself. The very clear semantic meaning of an `optional&lt;T&amp;&gt;` then is that it is either a reference or it is empty. Exactly two states in any well-defined program. The contract is also narrowed for references. I can do arithmetic on a pointer. I cannot do arithmetic to (the address of) a reference. Which matters to tools. How is your tool or static analysis supposed to know if `*++ptr` is legal or not? Nothing in that expression nor is the type of `ptr` indicates whether the pointer is a "maybe-null non-owning reference" of if it's a pointer into a contiguous range. In order to avoid a slew of false-positive errors, tools must err on the side of believing pointers _might_ be pointing to some contiguous range (outside of the cases where they can prove otherwise). There's also the generic programming angle. Arbitrarily banning `optional&lt;T&amp;&gt;` is about as bad as poisoning `vector&lt;bool&gt;` from a generic code perspective. Code that might need to return an optional value that might be a reference now needs some kind of metaprogramming trick to map `T&amp;` to `T*` while mapping `T` to `optional&lt;T&gt;`, and then of course dealing with all the fun of `nullopt` vs `nullptr` and so on. Obviously, the kicker to all the above is the phrase "well-defined program," which runs into problems because dangling references are so damn easy to accidentally create despite them _always_ being in the realm of undefined behavior (unlike dangling pointers, which are perfectly legal and quite valid in all kinds of cases, _so long as you don't dereference them_). Rust solves this with its lifetime annotations. Swift or Kotlin or so on solve this with garbage collection. C# solves it with a combination of garbage collection and (in 7) a complex set of rules about stack-only types and spans. C++ solves this _sometimes_ with temporary lifetime extension (for `const&amp;`) and doesn't solve it at all otherwise, which is a problem for many use cases besides just `optional&lt;T&amp;&gt;`. Which is, aside from just being a problem, an inconsistent foot-gun and needlessly so.
It happened to me too. Looks like the ads on your website has scripts enabled that can redirect you to another website. 
&gt;He says this isn't taught, but obviously I picked it up somewhere. It's a split opinion on whether to do that according to various "thought-leaders". Herb Sutter says to not do the pass by value then move and instead prefer const reference, or overloading with r-value reference. Chandler Carruth says to do the pass by value then move. I'm in the pass by value/move camp as I find that in practice that approach generates optimal code. Compilers elide the extraneous moves and you get other optimizations from the compiler not having to worry about potential aliasing when working with references. Herb Sutter's advice tends to be too purist and academic for my liking but it does have an advantage which is that if your function throws an exception, the pass by value/move approach will not be able to provide the strong exception guarantee, whereas Herb's suggestion can provide it. Given that my codebase disallows the use of exceptions, and as a general matter I find exceptions create more headaches than they solve, it's not a concern for me.
I cannot percieve how this impacts C++'s ability to do systems work. The additional type safety is a *plus*.
I wanted C++ to have built-in tuples, not stdlib tuples. Then you could just do auto [present, val] = some_function(); [bool, value_type] some_function () { return [false]; }
But we already have that exact abuse, we just use SFINAE and templates to express them, which is ugly.
I'm really on the fence. On the one hand decent C++17 calling an ancient C API is painfully slow to write bc the type system keeps saying "are you sure" so you have to cast a ton and jump through hoops non stop. On the other hand if you play too fast and loose with the casts it's so easy to fuck up. Since the problem is the APIs rather than the language, I think the real solution is to make systems APIs nicer and more C++ oriented (e.g. imagine if the OS just have you a shared ptr instead of telling you to repeatedly ask for a void*)
The OS couldn't take a shared_ptr trivially due to side-effects. The API should be templated, though. Concepts make it easier. template &lt;typename T&gt; uint32_t system_api (const T &amp; __restrict arg);
you can pretty much already do this auto foo() {return {1,2};} //... auto [x,y] =foo();
not seeing the trivial issue with returning a shared ptr 
I just preferred using brackets. That, and my syntax specification allowed for automatic derivation of tuple members. `if` would automatically compare against the first boolean if found, other types looked for best fit.
The kernel cannot create the object. Your program would have to register callbacks to handle it, and that is unsafe as it is providing user-code to be executed in ring0. The Kernel's runtime isnt necessarily the same as yours. It could pass you a kernel_shared_ptr or something defined by a uniform kernel abi, but not a normal stdlib one.
I'm sure the standards committee would look seriously at any proposals that makes it easier to use std::byte easier. Sometimes it is better to offer up solutions rather than writing a blog complaining about how a C++ feature works.
Please don't spam the subreddit. Posting your own content multiple times a week is likely to be spam.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9kwi56/need_some_help_with_this_problem/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; unsigned char isn't a specific size so isn't what you need. Seriously, is there a platform where unsigned char is not an 8-bit unsigned integer type?
It sounds really interesting. Can you explain a bit why I would use this rather than Qt3D?
The literal preserves the length information: https://en.cppreference.com/w/cpp/string/basic_string/operator%22%22s
I wonder if the code is reminiscient of Lugaru?
On a similar note, there's also OpenSceneGraph which is easily integrated into a Qt UI (e.g. using osgQt). We use it at work. Would really like to know more about this!
Qt3D is LGPL as far as I remember, so should not be a big issue in most cases.
&gt;C++ is a compiler based programming language. You cannot execute a C++ program without compiling it. &gt;a compiler based programming language. Doesn't that just mean it's a compiled language? 
Yet it is a huge issue. In my company this license is on the blacklist (meaning you need very good motivation and a talk with the lawyers to use any software with this license).
Well in that case you are probably not using Qt anyways (which is either LGPL or commercial), so why would you care about the library in this post?
&gt; kernel could not create the object they already make some strings and ask the process ok call system free (or equivalent). of course another option is to make an os written userland library &gt; need callbacks why? just return it to the user. also there are many system calls that have callbacks at least in Windows and those are run in user land. also are you sure that ring-x always corresponds to permission? May be true but i didn't know that &gt; kernel may have different run time 1. this is already OS specific so out may not be the most elegant option in all the various ways you could make an os 2. the kernel can allocate in the user space &gt; terrifying.... scope completely depends where the memory is. both options may be valid. in some ways "new" returns a shared ptr to a page that is "owned" by the OS and deleted in a syscall. pointers to com/handles are similar. don't have any examples purely in user land at the moment but maybe that indicates if the OS have the resource probably it needs to clean it up
**Company:** [Bloomberg LP](https://www.bloomberg.com/careers/technology/engineering) **Type:** Full time **Description:** Bloomberg technology drives the world's financial markets, and we're looking for passionate and energetic problem solvers to join us. We have full-time software engineering openings across a variety of teams and geographic regions. Since this is the C++ subreddit, I expect most people looking here will be interested in that area. If you are a strong software engineer with a background that is not so much in C++, but you want to learn and work more with the language, we'd love to hear from you. We value your experience and problem solving abilities - we have C++ training classes once you get here. **Location:** NYC, SF, London, Frankfurt **Remote:** No **Visa Sponsorship:** Yes **Technologies:** It's a large company, so pretty much anything and everything is used somewhere. We are primarily a C++ firm, and use all sorts of languages/technologies depending on the project. C++-wise, most new code is compiling as C++14 (though we of course have older projects around). Most of our backend is running on Linux and other UNIX flavours. **Contact:** A selection of roles are linked below, but there are plenty more to be found [through our website](https://careers.bloomberg.com/job/search?fd=Engineering), or email us your resume @ [Jen - jcarberry7@bloomberg.net](mailto://jcarberry7@bloomberg.net) for NYC/SF, or [Kelly - kdonald1@bloomberg.net](mailto://kdonald1@bloomberg.net) for London/Frankfurt (put "Reddit" in the subject line), and we will do our best to help you find a job here that matches your skillset and interests. :) NYC: * [Senior Software Engineer - Developer Experience](https://careers.bloomberg.com/job/detail/65482) * [Senior C++ Engineer - Communications Applications](https://careers.bloomberg.com/job/detail/71053) * [Senior Software Engineer - Equity](https://careers.bloomberg.com/job/detail/62930) London: * [Engineering Team Leader - Ticker Plant](https://careers.bloomberg.com/job/detail/70988) * [Senior Infrastructure Engineer - C++](https://careers.bloomberg.com/job/detail/66067) * [Senior Software Engineer - Market Data/Feeds](https://careers.bloomberg.com/job/detail/68081) * [Senior Software Engineer - Custom Indices](https://careers.bloomberg.com/job/detail/70978) Frankfurt: * [Senior Software Engineer - Frankfurt](https://careers.bloomberg.com/job/detail/68219) If you're fresh out of school, please apply [here for London (closing soon!)](https://careers.bloomberg.com/job/detail/70669) or [here for NYC](https://careers.bloomberg.com/job/detail/68821). ----- I'm not in the recruitment team myself, so I may not be able to answer all questions, and can't handle applications, but I am a Team Leader in the Software Infrastructure department in London, and came through the graduate training program myself (admittedly it's changed a lot since then...), so I'm very happy to talk to people about what we do and how we work. Especially as my group is hiring in [London](https://careers.bloomberg.com/job/detail/66067)) and [Frankfurt]((https://careers.bloomberg.com/job/detail/68219))!
Please note that I don't have any real experience with Qt3D. &amp;#x200B; Q3DObserver is designed to draw 3D figures on a widget with the least amount of C++ code as possible (no Qml). To recreate this Q3DObserver example with Qt3D, a lot more code would be needed: `// Create widget and add 3D figures:` `Q3DObserver observer;` `observer.addPoint(QVector3D(0, 0, 0), QColor(Qt::red));` `observer.addLine(QVector3D(-1, -1, -1), QVector3D(1, 1, 1), QColor(Qt::green));` `observer.addTriangle(QVector3D(0, 1, 0), QVector3D(1, 0, 0), QVector3D(-1, 0, 0), QColor(Qt::blue));` `observer.addText(QVector3D(0, 0.5, 0), QColor(Qt::white), "3D text");` `// Show widget:` `observer.resize(1280, 720);` `observer.show();` Q3DObserver's only dependence is Qt5Widgets and its license allows to be linked as a static library, so if you want to show some shapes on a 3D space with an orbit camera without writing a lot of Qml code or adding another shared library as dependency, Q3DObserver can be useful. For more complex use cases, Qt3D is the better option.
As Qt3D, OpenSceneGraph seems much more feature complete than Q3DObserver, but it is also more complex and has a more restrictive license (wxWidgets vs Zlib).
Seriously, stop suggesting dev-c++ as the beginner's dev environment on windows. Visual studio community edition is free and the best environment on windows. Plus the article is full of mistakes. Like c++ is not an object-oriented language, it's multi-paradigm.
Or use Cling for a c++ REPL. :)
Yes - but they are mostly weird. Platforms with 9-bit bytes and 16-bit "bytes" both exist.
how would knowledge of those things relate to security and hardware constructs?
Why not watch it first? What is the point of even posting this?
&gt;It's guaranteed to be 0-255, but it's not guaranteed to exist. I believe they are guaranteed to exist if the platform supports it. The fact that it doesn't exist on esoteric platforms with non-8-bit "byte" is actually a good thing for the stated use case of a 0-255 number - if you used `unsigned char` then your code is likely to compile but not behave correctly, but if you use `uint8_t` it will fail to compile and bring the problem to your attention so you can fix it properly.
How many of these talks do we need? At some point they should just pull up youtube and show one of the previous talks.
Anyone know if this video presents anything not in one of the previous 10 videos about this same thing?
I don't quite understand why it took them so long in the first place. 
Though it usually does not hurt, I think consistency is only a means to an end; what you really want here is readability, conciseness and comprehensibility. Formatting consistency should be a non-issue with newer formatting tools like clang-format anyways, and consistency in other areas is much harder to even define.
This was kind of joke. 
Kuka, german based biggest robot company in the world is totally different. \* Allowed any C++(with some native restrictions) \* There are no stupid guidelines in Kuka \* There no &amp;std::endl for clarity or static\_cast&lt;void&gt;(printf...) in Kuka \* There are no strange lint tool in Kuka &amp;#x200B;
I'm a Team Leader for an application and middleware team in London. I joined the company in January 2018 so my perspective might be complementary to Chris'. Feel free to send me a message if there are any questions I can answer.
Well, I didn't need to see the code compiled and executed to believe him that it works. Not saying live demos don't have a lot of advantages, but for explaining complex problems they are not always the best medium and in this particular case you can't even see the actual mechanism (cache / pipeline state) in code. I'm pretty sure that if I hadn't known the basics before (and seem some similar code examples, ) I would have had to rewind/ pause the video to really understand what is going on thanks to the multiple levels of indirection.
TL;DR This tutorial is incompetently written. Don't waste your time.
I get so angry when people refer to weird machines that have **existed** at some point and are now relegated to museums (like the PDPs and UNIVACs with 9-bit bytes) or the occasional TI DSP, or the stubbed Windows CE. For all practical purposes, for any of the mainstream platforms today, unsigned char is all you need for your *byte* programming.
&gt; Applying the actual definition of undefined behavior to this article, all it means is that null references are possible, but the behavior of using a null reference is not defined by the standard. I would expect assuming references cannot be null is a form of UB based optimization that is done frequently in compilers. &gt; You're saying that because X is undefined behavior, that X can not happen. That is incredibly error prone logic! I don’t think the original poster ever said that. The point is that once you’ve got undefined behavior, the solution is to prevent the undefined behavior from occuring. Nothing you do *after* undefined behavior matters, for example even if you checked for a null reference, the compiler likely (and validly) could optimize out your check.
Mostly they are irrelevant because you won't be running cross-platform code on them - but `uint8_t` is still a much better type name to use when you need a variable that's _specifically_ 8 bits, than `unsigned char` which is both much longer to type and much less clear: "char" - really? It has absolutely nothing to do with characters apart from the C spec defining it as being the same size as one, and you certainly don't want a character - what you want is an 8-bit unsigned integer - i.e. "u(nsigned)int(eger)8(bits)" - uint8. What's worse is char being guaranteed as size 1 broke any hope of "char" being redefined as a larger type for actual unicode character work, which resulted in the horrible hack that is `wchar_t`.
Tautologically, there’s no such thing in c++ as a “null” reference. It’s quite literally **undefined** behavior.
Why wouldn't you use Qt in a company when it has a commercial license?
Didn't take him for a rock-guru, thought it [being a guru] was limited to C++ :-). But yes after all that moving, reflecting, conceptualizing and thinking about how to make C++ simpler by making it even bigger, one might have a need for some relaxation of constraints. Why those musical intros have to be in the yt-videos, though, is beyond me, it's just weird. But hey, at least we're thinking outside the box, so maybe we should just cheer.
No; There is an explicit requirement in the design of the standard library that you can create vocabulary types, that are indistinguishable from built-in types. This is why you have `std::complex&lt;int&gt;` and not `std::Complex&lt;int&gt;` (for example). A type called `Byte` would not match any convention used by the standard library and it would be _inconsistent with everything_.
This looks very interesting. I could maybe use it for a project. Do you think something like modelling a **very basic** house (simples shapes to model walls, doors, windows...) is possible with your library? This would only be for a prototype, not a complete app so it doesn't need to be fancy (textures, shadows are optional). Also can it be used alongside Qt3D? For example to use the more advanced fonctions of Qt3D
&gt; CppCon is run by a US based 501(c)(6). It would be very hard for us to do business outside of the US. SIGGRAPH is US/north american, and they go to Canada every few years (their cycle is more or less LA, Vancouver, Anaheim, and next year D.C.). They're part of ACM, which is a 501(c)(3) ("not-for-profit membership corporation"). It's a really awesome model - alternating between 3, 4 or 5 large locations, one of them being in Canada. Fully supporting the Canada idea here! :-)
Yeah, that's a great point! I too am unsure if it is madness or genius :D I know for example that my parsing breaks with nested templates that end with `&gt;&gt;`, same problem as before c++11 I guess where templates had to be written as `&gt; &gt;`. To fix this you basically have to implement full out c++ tokenising inside the enum declarations which might be a bit overkill...
I think you're right, that one is meltdown, not spectre. I have trouble telling them apart at this point, there seems to be quite a bit of overlap between them.
&gt; You're saying that because X is undefined behavior, that X can not happen. That is incredibly error prone logic! No, he said that if your program contains UB (and your compiler does not specify such behaviour as it implementation defined behaviour) it is not valid C++ program. If it is not C++ program it is not reasanable to spectulate about behaviour of executable compiled from it by your C++ compiler. And there is nothing you can do about it. For example, you may believe that references *can* be null and start to check it all over the place, but compiler could (and most likely will) ignore it. Example on goldolt: https://godbolt.org/z/SgzIch If your program contains for example signed overflow you can't check it post factum. You can only prevent it. Why? Because "... if any such execution contains an undeﬁned operation, this International Standard places no requirement on the implementation executing that program with that input (not even with regard to operations preceding the ﬁrst undeﬁned operation)" &gt; all it means is that null references are possible All it means that if you have null reference then it is already too late. You should not even think about null references. You should think about dereferencing null pointers and preventing it.
It's "Undefined" but they literally tell you how it would be done, it's tautologically impossible, however it's technically possible.
There were no comments, no upvotes visible. I wanted try to avoid having this buried, it was from Chandler so I figured it would be good.
&gt;Do you think something like modelling a **very basic** house (simple shapes to model walls, doors, windows...) is possible with your library? Yes! In fact I made a similar library in the past to show 3D houses in a CAD-like application. You can add the roof and wall faces to the widget and it manages the lighting and the camera for you. Diffuse lightning is implemented, but textures are not supported. For me, the major limitation of Q3DObserver is that it doesn't provide object selection. If it is not needed for your prototype, please try the library. &gt;Also can it be used alongside Qt3D? You should be able to show a Q3DObserver widget and a Qt3D one in the same window.
Simple C++17 constexpr recursive implementation: https://godbolt.org/z/jgDfEa 
e.g. when you have a use case where you can't load a python runtime
Then there would be tons of compaints that “the C++ committee is again making the language more complicated by introducing another arcane syntax”.
On the other hand, it's easier to convince people once a blog post becomes popular.
When we originally designed our benchmarks we started by trying to simulate real life work loads. We ended up coming to the conclusion that real life memory pressure is nearly impossible to simulate. It tends to neither be "hot" or "cold" but a very strange mixture. The micro benchmarks are thus focused calipers on particular operations and configurations. When we want to get macro numbers we run large scale performance things like websearch's internal systems level benchmarks. Roughly speaking, we use systems level benchmarks to do final validation of changes, but we use micro benchmarks to iterate and optimize small things. &amp;#x200B; I am not familiar with "execution traces" but surmise it is something like "capture all operations that happen to a table and then replay them outside the context of the rest of the app". My first guess is that not having the other work loads of the app with change the memory behavior so heavily that they will not be as useful as one might hope.
\*\*Company:\*\* [Laboratory of Plasma Physics](https://www.lpp.polytechnique.fr) \*\*Type:\*\* full time \*\*Description:\*\* The Laboratory of Plasma Physics a public research lab strongly involved in the development of high performance computing (HPC) codes for simulating plasma dynamics observed in laboratory experiments and astrophysical environments. We are currently developing a code (named "PHARE") that aims at solving plasma kinetic dynamics on multiple refined grids on tens of thousands of core. We want this code to be open-source, flexible enough to be used by a broad international scientific community. We are a small team and look for a passionate C++ developer, who has experience in developing HPC applications. You will join a small team, who love C++ and numerical simulation, and will participate to all aspects of the project, from the design of the code architecture, to the implementation of components and their tests, etc. and participate to the team's publications. \*\*Location:\*\* Laboratory of Plasma Physics, Ecole Polytechnique, Palaiseau, France. The is a very international environment. \*\*Remote:\*\* We like when things are done and done well, no matter where they were done. Often it's better to sit together, talk and draw on the white board... but we respect everyone's freedom to work from home from time to time and choose its own work hours. \*\*Visa Sponsorship:\*\* No need in France. \*\*Technologies:\*\* We work on unix (mac, linux). We use C++17. The code depends on the C++ AMR library [SAMRAI](https://github.com/LLNL/SAMRAI), and the I/O library [HDF5](https://support.hdfgroup.org/HDF5/). There's a coupling with python via [pybind11](https://github.com/pybind/pybind11) on its way, thus we also need python (3). We use [TeamCity](https://www.jetbrains.com/teamcity/) for continuous integration, CMake to build the project, [Google Test](https://github.com/google/googletest) for tests. \*\*Contact:\*\* contact us at [nicolas.aunai@lpp.polytechnique.fr](mailto:nicolas.aunai@lpp.polytechnique.fr) 
The commercial license is pretty expensive. A ton of people use it professionally under the LGPL.
std::byte is not guaranteed to be 8 bits in size. If the platform byte size is 16 bits, it is 16 bits in size. And since it does not represent a numerical value, it does not have a range anyway. &amp;#x200B;
While the backend has the same performance, any kind of data processing on python is a few orders of magnitude slower than is c++. One of my main issues with doing anything in python is that it is just so slow. I've had a few cases where python has been the bottleneck so c++ api is more than welcome
But now the issue is that you're mapping of data strictly on 8-bit boundaries in memory, which may not be an optimal mapping for some architectures. `std::byte`, `char` and its variants make no such restrictions.
I don't have any experience with that proposal, but in theory it doesn't bother me to take ease or efficiency of compiler implementation into account with a change to C++. To me, not caring about ease of implementation could lead to features never arriving on compilers or at least taking much longer (perhaps it's worth the wait, but at least we should consider that metric). Likewise not caring about efficiency of implementation could lead to much longer or perhaps more brittle or error-prone compilation. Both of those negatives are affecting the human side of the translation process and are not just hidden implementation details. I take your point that as programmers we should hope to not have to care too greatly about implementation of compilers, though.
I am not the author, btw. Just sharing what I believed would make for interesting conversation in the comments regarding their perspectives on the matter.
You need to use Qt anyway, and Qt3D comes with it. So it’s a non-issue. 
I hadn't considered that. Seems you have more confidence in my ability to write standardization proposals than I do. That's awesome! On the other hand: ranting does take a lot less time, and I'm pretty short on time these days. Some day, maybe.
Sean Parent also advocates for this if I'm not mistaken.
I was thinking primarily of people who were active in C++ development in, say, the late 1980's through the mid 1990's or so. The earliest I recall STL being involved in C++ development was rather later than that (something like the early- to mid-2000's or so). He's certainly welcome to correct me if I'm wrong though (and he moderates here, so there's a decent chance he'll see this). 
Not bad, but does not seem any better than [Qt's overview](https://doc.qt.io/qt-5/model-view-programming.html)
Not using stdlib, I see 😀😀😀.
Thanks, that's interesting and makes a lot of sense. The context that I failed to add to my original question is the history of memory allocator benchmarks, which eventually realized that "a random sequence of randomly-sized allocations and frees" did not match actual workloads. I was wondering if anything similar had happened to hash table microbenchmarks, but it sounds like it's trickier than that.
Thanks, that's interesting and it makes a lot of sense. The context for my question was that memory allocator benchmarks eventually realized that "a random sequence of random-sized allocations" did not match most program's memory allocator workloads well enough to be meaningful tests. I was wondering if some equivalent might also be true for hash tables, but it makes sense that it'd be more subtle than that.
My point is more whether the term “null reference” is a useful term. I’d argue it’s like “the value pointed to by nullptr”, in that you can maybe express it syntactically, but it’s better to think of it as non-sensical. (So more of a question of best mental model)
This is an article about a quote in the paper and some ranting about a footnote about the quote and how that supposedly all invalidates the entire premise of the paper without even a shred of actual analysis, understanding, or discussion about the actual content of the proposal itself (the justifications for which are all of two paragraphs further in). It pretty much seems like the author got one paragraph in and then decided to angrily write about that paragraph.
I don’t see why we can’t compromise with `T&amp;^&amp;`...
*technically* **only**. 😁😁😁😁
Often the UB would only be diagnosable through more rigorous control flow analysis, which is out of scope of the compiler. There are tools that will attempt it though, for example Clang’s UndefinedBehaviorSanitizer.
Hi there! Thanks for your comment. The purpose of the series is to only cover the basics for each topic - enough to understand the concepts and where to find more information if needed. This week's post is based on several different sources, including the one your're linking to, in addition to my own experience. All those sources are linked to within the post. Arguably, Qt's Model/View introduction is a bit "meaty" so thought this post would be a better overview. I also tried to focus more on the actual concepts than covering all the different classes that Qt provides. Perhaps you disagree? Cheers, Alex
\*\*Company:\*\* [QuasarDB](https://www.quasardb.net) \*\*Type:\*\* Full Time \*\*Description:\*\* QuasarDB is a high-performance, distributed, time series database. QuasarDB has been designed to handle the most extreme time series use cases in financial applications. We are looking for a talented C++ software engineer to join our core team and help us expand the capabilities and performances of the database. More information [https://quasardb.net/careers/](https://quasardb.net/careers/) \*\*Location:\*\* Downtown Paris, France. Language used: English (International team). You may need to know French should you wish to order *pain au chocolat* at the bakery. \*\*Remote:\*\* Employees can work remotely at will but are expected to show up at the office at least once per week. \*\*Visa Sponsorship:\*\* Please only apply if you already are allowed to work in France. \*\*Technologies:\*\* C++17/TBB/Boost/STL \*\*Contact:\*\* [jobs@quasardb.net](mailto:jobs@quasardb.net)
Two-phase init. Blergh.
That is not a small consideration. Specially if you eant to make an optimized pipeline for your entire model.
This is awesome! If you slightly modify their C++ example, you get &amp;#x200B; #include &lt;torch/torch.h&gt; auto model = torch::nn::Linear(5, 1); auto optimizer = torch::optim::SGD(model-&gt;parameters(), /*lr=*/0.1); auto prediction = model-&gt;forward(torch::randn({3, 5})); auto loss = torch::mse_loss(prediction, torch::ones({3, 1})); loss.backward(); optimizer.step(); &amp;#x200B; which is almost identical to the python implementation &amp;#x200B; import torch model = torch.nn.Linear(5, 1) optimizer = torch.optim.SGD(model.parameters(), lr=0.1) prediction = model.forward(torch.randn(3, 5)) loss = torch.nn.functional.mse_loss(prediction, torch.ones(3, 1)) loss.backward() optimizer.step() &amp;#x200B; There are some libraries which have a nice Python interface and a horrible C++ interface. This C++ frontend shows that this need not be the case - you can have the C++ interface be as nice as the python interface.
In my experience, numpy gives pretty good performance since python calls into c++ for most libraries, but it still has a lot of overhead. This might be useful for deployed models like the tensorflow mobile thing
&gt; There were no comments I don't see how that's relevant to anything. &gt; no upvotes visible. same. &gt; I wanted try to avoid having this buried, Posts don't live/die based on you commenting on you maybe watching something at some point in the future. 
Posts here live/die based on you posting that you think they might be interesting.. especially a high-visibility talk from one of the best speakers in the community.
If those are you goals, I think you've hit them well.
Cool story bro.
I would also add naming consistency if the program isn’t sample code. Use of classes with no polymorphic features.
Technically that call in and of itself is not undefined behavior, but the moment you perform any operation on that pointer, including just copying its value, you've engendered undefined behavior, for example this is undefined behavior: auto x = std::malloc(sizeof(int)); *x = 5; // This line always engenders undefined behavior. The issue is that objects are created according to the rules specified in S 4.5.1 [intro.object] which states that the **only** way to create an object is by: 1. By a declaration (such as a variable declaration). 2. A new expression. 3. When implicitly changing the active member of a union. 4. When a temporary object is creating subject according to S 7.4 and S 15.2 That's it... nothing else create an object in C++ and specifically `std::malloc(n)` does not create an object of type `T`, it has no way of knowing that... rather it creates an indeterminate object with a size of `n`. Once you cast it to a pointer of type `T` the pointer represents a so called invalid pointer value (S 6.9.2). Invalid pointer values are permissible in C++, but any operation on an invalid pointer value, including copying it, assigning to it, dereferencing it, any operations at all, is undefined behavior. This is widely known issue among the C++ committee but object creation is such a delicate issue and getting any detail wrong could have huge consequences that little effort has gone into finding ways to fix this problem. One attempt to resolve the issue can be found in proposal [P0593](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0593r2.html). For the most part though, we just accept it like we do many aspects of C++ that result in undefined behavior. And this is kind of the point I'm making... undefined behavior in C++ is so rampant and unavoidable that to say it technically never happens is just fooling yourself. If you wish to be a productive C++ developer, don't convince yourself that undefined behavior doesn't happen in C++ or is not allowed in C++, rather accept that it is very much a part of C++ development and familiarize yourself with how your compiler/platform treats it. Questions to ask are things like whether your platform optimizes that behavior... does it cause any kind of runtime diagnostic to be issued (clang and GCC can diagose many forms of undefined behavior), does it provide well defined semantics for it (via compiler flags such as -fno-aliasing). This is how you familiarize and reason about C++ to write practical and effective software, not by pretending it doesn't exist or it's not actually C++ and C++ is some kind of idealistic and pure language... once you actually read the standard and familiarize yourself with the defect reports (http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html) you realize C++ is anything but a pure language.
I found the lifetime checking really interesting. Is there an implementation out in the field (e.g. a VS extension or in clang-tidy), which could be tried? 
Great tutorial! It is a nice overview of how it all fits together. I'm kind of sad that you won't go into how to implement models and proxies. It's the real strength of the system. Anyway, since this thread might attract Qt guys I'll add a bit of my experience. Warning: it's basically a rant. Proxies are a genius idea to transform the data you display without the need to expose the model from one class onwards. Awesome. It gives me a lot of headroom to improve the model without touching the UI. Now, proxies become more or less useless the moment you see that QSortFilterProxyModel runs on the main thread. If you are sorting 50000 rows with 2 columns, it will block the whole UI. That's just the way it was designed. I would really like to see a design for a concurrent SortFilterProxyModel, that will do all sorting/filtering operations in a different thread. This will possibly make the sorting slower, but at least it won't block the UI. I can display a "Loading" moving gif while that's going on, no problem. Any ideas are welcome!
Well, it is even in the classic [Scott Meyer's book "Effective Modern C++"](http://scottmeyers.blogspot.com/2014/03/book-report-new-title-new-toc-new.html), so I also was surprised then the presenter said it is not taught.
&gt; virtual tables Inheritance != runtime polymorphism