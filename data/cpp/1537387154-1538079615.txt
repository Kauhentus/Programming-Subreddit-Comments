I then indeed do look forward to them. :)
Yes, totally. But if I make a survey, I'd want the questions to be clear, unambiguous, and so that everybody understands them and thinks about the same thing, without having to Google. People spend their precious time to fill out your survey. So I'd do my best to not make them Google and spend even more time.
Accompanying slides, for those who are deathly allergic to two hour videos: https://docs.google.com/presentation/d/1fSkpD51FKmy8VEO9P86jWN6tOEaBmzHOXo14zLRkFKE/edit#slide=id.p Niall's proposal (for C and C++): http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2289.pdf 
unique_ptr is dangerous to use with Qt objects. You can run into double deletion issues (the parent object deletes the object first, and unique_ptr deletes the same object again later.) So I would advise to use raw pointers, or wrap unique_ptr in your own, QObject-aware smart pointer type. I've seen a couple implementations of such wrappers floating around.
Sweet, thank you for the details. I'd love to be on 2017, just gotta keep pushing against the organizational inertia.
Haha that‚Äôs awesome thanks for figuring that out and sorry my question sent you on this wild goose chase!
GCC had parallel algorithms ten years ago 
I'll accept the escape hatch gladly! Thanks. BTW the winclang naming is for clang targeting the MSVC ABI. It differs from clang targeting the Mingw ABI. Otherwise it can be confusing which sort of clang people are talking about. Saves time from confusion.
I learned more about C++ from your question than anything else I did today. It was time well spent.
Ok, thanks for the response. So when I have a QObject with no parent which needs to be on the heap (like a QNetworkReply*) until a specific slot is triggered (for example QNetworkReply::finished), is there a way to achieve this with smart pointers? Or should I always stick with raw pointers, because like you said they might conflict with Qt's own memory management system?
Hehe well now what puzzles me is why it felt it needed to do the 0.5 times x operation twice
Thanks for those. At least half an hour of it is Q&amp;A, much of which was on topics far broader than disappointment. Such as where I think the future of C++ is going, and so on. I was very tired by then, so my answers may have been incoherent. I'm just about to watch the video now and make sure I didn't say anything unfortunate.
I often hear a lot of whining form the free software crowd about LLVM/CLang but I don't believe those guys realize how far we have come due to a little old fashion competition. Ten years ago the future of C++ was pretty bleak in my opinion, now it is at least respected as a solid language. I'm not sure about its long term success as more modern languages such as Rust and Swift gain popularity, but it is not unreasonable to use C++ for long term projects. So yeah a great time really, and if we look around we might find more than 3 great compilers for the C++ developer. That is pretty amazing in my mind.
Those aren't the std c++ parallel algorithms though.
I'm allergic to nonsense title, is it worth checking out?
In the switch case, the compiler may well be able to inline your functions. It is very unlikely with a map since you are calling though a function pointer. Typically, use compile time functionality if it is sufficient. Switch is entirely compile time, you cannot add stuff to it at runtime. You can modify the map at runtime, so that makes it more flexible, but the flexibility comes at a cost - no inlining, greater memory footprint, etc.
Ah. It's true that Clang's twice-yearly release cycle is slower than MSVC's update cycle, but we're obviously not going to increment the required Clang version faster than Clang itself updates.
Hopefully Xcode 10 will ship with it.
&gt; you just define that one operator and viola ‚Ä¶the compiler generates a string section?
We implemented our own library-level 3-way comparison operator to allow types with a very expensive comparison operation to be efficiently sorted. It was the only way we could get the required space and time efficiency with readable code.
Yes. The words in the title actually have some clearly-defined (in the talk) meanings and aren't nonsense at all. :p
&gt; I'm just about to watch the video now and **determine that** I didn't say anything **disappointing**. Fixed that for you. :p (yes, I _am_ easily amused, thank you)
Hi just about to watch the video now and **determine that** I didn't say anything **disappointing**. Fixed that for you. :p (yes, I _am_ easily amused, thank you), I'm dad!
Hi just about to watch the video now and **determine that** I didn't say anything **disappointing**. Fixed that for you. :p (yes, I _am_ easily amused, thank you), I'm dad!
One major aspect of spaceship is that it can be defaulted. This is nice if you have a POD struct; if you think about it tuples are ordered out of the box so if you define a POD struct which in some sense is really just a tuple where the type and the fields have proper names, why shouldn't you have that capability? Of course, hashing which is more useful (IMHO) on average is left out to dry, and compile time reflection which could solve this in generality is going to be a while... But it's something.
*clap clap*
Definitely. I still think LLVM sucks for a lot of reasons, but it's worth it *just* for the motivation it gives to GCC.
Welcome to the world of C++ üòÅ. Just a suggestion: register yourself on github or gitlab and share your code through there as it will be much easier to work with than an image üëç
Good idea, didn't think of that as i rushed to post this before going to bed üòÖ I'll make sure to do that with my posts in the future üëç
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9h9tk4/how_to_assign_pointer_address_through_user_input/e6a9ua9/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Correct, it's "committee speak".
Your pedCal's return type appears to be truncating float to int, but later you store its return value in a float, so it appears that this was unintentional. I graduated IB many years ago; welcome to C++ :-) I'm going to remove your post as it's outside the scope of our subreddit (we are not a beginner help subreddit, see the sidebar), but don't let that discourage you.
No worries, and thank you for pointing out what should have been an obvious mistake. Just another reason why testing once doesn't necessarily mean success.
You probably didn't read my post. It's already reported but still... The purpose of this post is to give people some hint when you meet something that makes no sense, otherwise you'll spend all day making no progress.
I should have prefaced my rant here. All the r/iamverysmart stuff aside, I'm a masochist and decided to go for a doctorate. Now, my research is focused elsewhere, but comparative languages is my actual favorite part of computer science. I am also mostly a language purist. Now, lambda (lambda calculus) absolutely does have a formal definition and they \*are\* very useful, and necessary, in functional languages i.e. Lisp, Schema (I hear they are implemented well in Haskell but I don't know Haskell, so I cannot speak to it directly). The only real defense of them that has ever made an iota of sense is to use them sort of like Pascal allows nested functions. Otherwise, they just seem like another fad concept shoehorned in.
Lambda was introduced in Lisp a long, looooong time ago. ;)
Knowing what bugs your compiler has could save you huge amount of time in debugging. I think it's informative to share the experience.
Do you have a source for this? I'd be very surprised if the crossover point is as high as you say. It also depends hugely on the type so it's a very odd statement to make categorically.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9hbpzy/code_disappearederror_please_help_new_to_this/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
It will be way easier doing this than mounting my install in my development docker container. I like this improvement.
It's been a long time since I really looked at it, but the big ones that I recall: * Nothing even *close* to API stability - GCC doesn't *guarantee* API stability, but in practice it is *very* easy to port between versions, and not unbearably painful even to write a plugin that works with a all versions back to 4.5 when out-of-tree plugins became possible. * Claims GCC compatibility, but has numerous flaws in that, and workflow-critical bugs with testcases just get left open for years. * Even when you submit a patch, sometimes they just reject it for no reason. * Can't debug with optimizations, rendering it entirely useless in the real world. * General attitude of gratuitous breakage, e.g. LLDB's whole UI.
This is amazing! CLion keeps finding new and convenient ways to integrate with all of my workflows. No other IDE even competes anymore, imo
Yes - MSVC is the furthest but I‚Äôm still working on charconv, C++17‚Äôs final boss.
Vectors of unique_ptrs are slow. 
I'f the callable you put into the std::function is too big, your std::array variant might very well touch the heap too. On the other extreme, for storing lambdas without captures, function pointers are preferable to std::function.
You don't even necessarily need function pointers - just a jump tip the right address. 
They're in a different namespace, what else ?
It's possible. Remembering naming of algorithms has always been a weakness of mine. It's why I've never passed a multinational algorithm interview e.g. Google's
You could file a bug with clang.
**Company:** [Eppendorf Instrumente GmbH](https://www.eppendorf.com/OC-en/) **Type:** internship **Description:** Eppendorf is a leading life science company that develops instruments for liquid-, sample-, and cell handling in laboratories worldwide. We are looking for interns to join our software developer team for embedded devices. Your mandatory skills should be: * a good knowledge of C++ and Python * fluency in German or English * combinatory and analytical capabilities L**ocation:** Hamburg, Germany **Remote:** no **Visa Sponsorship:** no **Technologies:** C++11 - C++17, Python, Embedded Systems (Cortex-M, FreeRTOS, OpenEmbedded), Linux and Windows **Contact:** Please e-mail me, Toni Neubert, [neubertt@eppendorf.de](mailto:neubertt@eppendorf.de) for any questions.
&gt; I think what's going on is that Clang does not know that std::sin does not modify global state. but it does, namely errno :D
It makes the code cleaner or faster. Like for example if there was a struct with 2 properties, you could write both operator=() and operator&lt;(), and then you have two choices for implementing operator&lt;=(): either implement it by calling the other operator functions, or make a bespoke implementation for it. The former means that it's possibly wasteful since one of them is going to re-do at least some of the work that the first did, or you have code bloat. And then of course you have the code bloat of having the other operator overloads implemented just calling the other ones with some boolean logic. Which of course is possible to do incorrectly.. and possibly not notice for a long time, since maybe you're calling &lt; in your implementation but then someone changes some logic and calls &gt; for the first time but it's completely busted and it causes lots of headache trying to track down such a stupid problem. For implementing the spaceship operator it means you just have to implement one function, and the compiler takes care of the rest. And it's much easier to audit a single function than 6. And plus, the pattern for doing chained ordering calls on a function seem much more straightforward: std::weak_equality operator&lt;=&gt;(const EquivalenceComparable&amp; that) const { if (auto cmp = number1 &lt;=&gt; that.number1; cmp != 0) return cmp; if (auto cmp = number2 &lt;=&gt; that.number2; cmp != 0) return cmp; return name &lt;=&gt; that.name; } That same code would be 3-4x as long with regular operator overloading, with much more repetition in the code, which increases the odds that when future changes to the class happen that something is going to be done incorrectly.
Qt Creator "competes" and is better in many regards, I think. Too bad they named it after Qt - the name kind of taints the reputation of a very good general purpose C++ IDE (many people have the misconception that the IDE is solely used for Qt-related dev). 
Why not use Qt Widgets then directly?
Well... they are not they same. Qt Widgets are perhaps best to use when aiming for a native look on desktops whereas with Qt Quick it's easier to create dynamic and fluid UIs which is pretty difficult to do with Qt Widgets.
Correct! :) Also done in the destructor. I'm not going to copy-paste it in here since there are quite many lines, but feel free to explore it yourself from the aforementioned link :). 
&gt; But why do we have different widget libraries then? Well, for instance I wrote my own (http://github.com/jcelerier/qml-creative-controls) because I have a specific use case in mind which does not map to existing widgets. 
That doesn't mean Qt Widgets couldn't sit of top of Qt Quick.
What API are you talking about in particular? - Can't debug with optimizations, rendering it entirely useless in the real world. Well, lots of companies use it in the real world. I guess it is always a question of the context.
How come it doesn't have a parent? I mean 'parent' is just a concept of ownership similar to smart pointers. If you think that you need a smart pointer (i.e. an ownership) just stick to using the parent. Again, there are some exception like if it's not a `QObject` or if the ownership is shared (which in many cases happens very rarely). 
I'm not sure about mimicking the exact same functionality, only the API... For example the article mention "can make use of e.g. animations and shaders." which is not really practical with Qt Widgets. But again, this is my interpretation of the article and haven't used it myself so I might be wrong here.
That's what I am saying: if the Qt Widgets API can be mimicked with Qt Quick as the underlying drawing engine, then why don't we have that? i.e. a version of Qt Widgets with Qt Quick as the back end?
&gt; Fixed a race condition in std::async that could cause crashes or deadlocks. Damn. Haven't done any concurrency yet but if someone got stumbled by this bug they must have been very frustrated.
I just saw a talk by ReDucTor and he used your quote! It's a good quote!
no: QtQuick works by rendering everything to a GL (or D3D11) scene, which prevents incorporating native (e.g. Win32 or Cocoa) widgets into it, while QWidgets allows it since it renders on the normal canvas provided by the operating system and not on a GPU texture. 
Qt doesn't have native widgets, as far as I know. It mimics them. Even if it had though, the native widgets could be instantiated only with the native renderer. In other cases, they would still be mimicked. 
&gt; Qt doesn't have native widgets, as far as I know. It mimics them. yes, but it allows to use native widgets along its mimicked ones. e.g you can have a QPushButton and a NSTextField in the same layout.
In which kind of sorting algorithm does this matter? I would be interested to know which sorting algorithms really benefit from a three-way comparison operator. Genuine question: I maintain a sorting algorithms library, and the integration of `operator&lt;=&gt;` as well as its possible benefits have been on my list of things I'll have to think about for a very long time.
I don't see how that is a problem when an OpenGL backend was used; in that case, using native widgets would not be allowed.
For Chrome: https://arstechnica.com/gadgets/2018/03/chrome-on-windows-ditches-microsofts-compiler-now-uses-clang/
They've contributed kind of a lot to clang (Clang-cl was Google's project) Also, they've switched Android and Chrome over exclusively to Clang. so yeah.
Did it? I downloaded the GM RC I think a few days ago, has it been officially released?
I had never heard of the `abstract` keyword, but I filed a bug about this.
You need to set the toolset as described in the blog post. There doesn't seem to be a way to do that with 'open folder' mode. That mode seems to be for simple projects in order to bootstrap people to get started. 
I'm sorry, but I strongly disagree with you then. Computer languages are tools, not works of art. They exist to help us solve problems in the real world, and nothing else. Purity simply doesn't come into it. You might have noticed how quite a few concepts in computer languages do not align perfectly with the theoretical concepts they seem to mimic; integers are not N (or Z), floating point numbers are not R, infinity usually just means 'really, really large', and const does not mean 'constant'. I, and I imagine most other users of the language, honestly cannot be bothered by lambdas not 100% matching lambda calculus. You are of course entitled to your opinion, but you must also realise that this kind of purist approach has very little to do with programming in the real world, and giving beginning programmers advise like "lambdas are bad and should be avoided" potentially puts them on a path towards some really bad engineering practices. That seems a rather high price for satisfying your personal sense of esthetics. 
Well, until a few years aso, they were declared a feature of the compiler, but you are right. Thanks for the explanation. 
&gt; What API are you talking about in particular? He means the C++ API. It covers the obvious things like generating LLVM IR, and all the usual utility functions and specialized types you might want to use in your front-end or pass. There's a C API that **is** guaranteed stable and can do many of the tasks needed, but you might find you have to add functions to it if you have strange IR requirements, the C++ API is the fundamental one. It's definitely something people are unhappy about periodically, but LLVM has always preferred to be able to refactor when it makes sense for LLVM.
I'm on 14, and using `std::experimental` versions of many features, and I admit these days the parts of boost I use are vastly diminished, what with filesystem, optional, variant, any, etc all in the standard library. Boost python seems to be actively developed mostly in it's non-boost fork, pybind11. What's left these days: - Hana. Best option for reflection I've found. - Program options. Boost PO is still one of if not the best choices here. - Boost PP. Again, there aren't many options, and Boost PP is very good. - Random useful data structures. Most notably circular buffer. - Interprocess. I don't actually use it at present but I've reviewed this problem before, seems very nice and again, there aren't a ton of solutions.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9hepxw/need_help_whileelseif_loop/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Oh, fair enough.
Find if any program you are currently using is open source C++. Maybe you use Linux with KDE? Maybe you like games (0ad, Regoth)?
Does it still not have &lt;filesystem&gt;?
Thanks, I also didn't know till yesterday :) Fortunately the fix was very easy. Could you share link to the bug report ?
Seriously? Not everyone has 8, 16+ GB RAM and a lot people still have low end CPUs...not so competing in resources usage. A lot of things to consider before the "competes"
Also a lot better at standard conformance, since it uses libclang, and, in my experience, much faster, since it's not Java bloat.. Stable CLion has its troubles with C++17 and keeps hanging on bigger projects.
I'll advocate for Eclipse CDT. For big C++ projects it is the best in terms of scalability. You just need to provide it with lot's of RAM. Mine is lightning fast on 8Gb. Both Qt Creator and CLion are choking on the very same project.
Literally every single iOS app is compiled with LLVM (or at some point leverages the tools e.g. linking UIKit). So are Apple's operating system. Chrome, Firefox are compiled with clang/clang-cl. Countless projects leverage libclang (Qt Creator, XCode, even MS uses it to improve MSVC's standards conformance). I've no idea how one can come to the conclusion that LLVM were 'useless in the real world'.
&gt;Remote development support You mean SSH, tmux, and vim?
You can always implement them yourself, on top of the Networking TS, or someone else can do it and make a library out of it.
Thank you! Is there a recording of that talk online?
#include &lt;filesystem&gt; =&gt; 'filesystem' not found #include &lt;experimental/filesystem&gt; =&gt; `'experimental/filesystem' not found`
What do you need PP for in 14? I use it a lot in 98, but that's mostly to fill in for the lack of variadic templates.
I have no doubt a micro benchmark could show them to be slower than a vector of raw pointers, but I would be interested in seeing some data on your claim
These days I use PP less than I used to but it still occasionally comes in handy. To pick a relatively self contained example: I wrote a strong typedef class. My initial implementation did something like `using MyType = StrongTypeDef&lt;int, MyTypeTag, Comparable, Hashable&gt;;`. It turns out that this is really bad because MyType is just an alias and it gets expanded out in error messages, making things unreadable. So instead I have a macro `STRONG_TYPEDEF(int, Comparable, Hashable)` that first creates a combined policy, and then produces the alias: `template &lt;class T&gt; struct MyTypePolicy : Comparable&lt;T&gt;, Hashable&lt;T&gt; {}; using MyType = StrongTypedef&lt;int, MyTypePolicy&gt;`. I could force users to do this by hand but it's just repetitive and error prone, and if you already know boost PP implementing this macro takes 5 minutes. I also would have used Boost PP to implement my reflect enum library that I'm working on, but boost sequence limit is too low (64), so I'm doing it independently.
When writing a class, it lets you write a single obvious operator instead of 6 comparators. 
Ah errno, the mistake that just keeps on mistaking.
Deleting a nullptr is OK. It's doesn't perform any action and doesn't crash your computer. (At least if you're using a C++98 compliant compiler or later.)
Yes
I‚Äôll give them a pass on filesystem as long as it comes in the next major release and supports reading/enumerating files within an iOS app bundle 
well, no, it would break api promises. A lot of QWidget functions would stop working, so instead they made a new API (QtQuick) which respects the limits of "doing everything on a GL canvas" (and as such can offer greater performance)
Yeah, things I've seen experienced senior developers do wrong. It's highly unlikely that a beginner will do it right. Don't get me wrong I don't mean to be discouraging or elitist. Just pointing out that a beginner should practice C++ and get comfortable with the language and it's concepts prior to contributing to public projects. Also a unit test does not attest the quality of a PR. It merely approves the correctness (assuming good unit tests) of the proposed change. You could submit a PR full of legacy code and UB to a C++11 project. The unit tests won't prevent that. Personally, I've never felt the urge to contribute to a repository just for the sake of contributing. Chances are you gonna implement and propose a change that was never intended by the author or - worse - doesn't interact well (not necessarily in a "breaking" way) with the rest of the code. My adwise for OP is to work through books (or other resources) on modern C++, start developing small projects (maybe a game), make use of libraries and, finally, contribute to said libraries if he encounters insufficiencies. Remember that's my personal opinion. I'm happy to discuss about different views.
This pull request could use a code review: [https://github.com/boostorg/beast/pull/1249](https://github.com/boostorg/beast/pull/1249)
I am interested in getting involved with boost but I don't know how to get started. I tried signing up for the mailing list but I don't think I was added. Would IRC be a good way to get in touch with boost? &amp;#x200B;
GCC doesn't make guarantees, so they aren't hesitant to refactor when it's useful. There have been several major refactorings across the C++ conversion. Still very easy to port in practice. I tried using LLVM's C API for several years, but even for the basics it had numerous shortcomings and version-incompatibilities. It was far easier to generate textual IR by hand.
Bad bot
You may be interested to know "hacktoberfest" is coming, TL;DR: send 4 PRs to an open source project(s) in October and you will get a t-shirt and some stickers courtesy of DigitalOcean. It wouldn't really matter otherwise, but that incentives open-source maintainers to groom their reported issues a bit and use the promoted label of `good first issue`: https://github.com/search?utf8=‚úì&amp;q=label%3A"good+first+issue"+language%3Ac%2B%2B&amp;type=Issues
&gt; What do you need PP for in 14? Macros to generate enum traits (e.g., enum&lt;-&gt;string); macro's to generate code for various other things that need reflection. We also use `BOOST_PP_OVERLOAD()` a lot, for macros that would otherwise not be using boost PP. And if you're wondering why we need macros at all other than for things that need reflection... we need them for things like log functions that need lazy evaluation, or test macros that need calling file/line info. Once `std::source_location` is more widely supported, and hopefully something like [lazy evaluation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0927r0.pdf) gets into the standard and compilers, then we might be able to avoid many macros. (although for test macro's, the ability to stringify arguments is fairly important I think)
Open source projects will likely have some community around them which you can interact with and learn from. They will probably have some issues filed against them in bugtracker that you can just pick up and start working on. In one of the projects I work on we will gladly take a PR from a beginner of it improves something, we also encourage people to come up with their own ideas and help them with the process. If they stick around, we usually see them improve over time, but even drive-by contributors are welcome. Also go see another person's opinion (professional game developer): https://youtu.be/Qsiu-zzDYww
A lesser known motivation is it enables the extensions to non-type template params in C++20, which allow (simple) class types. These can use defaulted operator&lt;=&gt;, so template instantiations can be compared for equality for instance. &amp;#x200B; [https://en.cppreference.com/w/cpp/language/template\_parameters#Non-type\_template\_parameter](https://en.cppreference.com/w/cpp/language/template_parameters#Non-type_template_parameter) [https://en.cppreference.com/w/cpp/language/class\_template\_argument\_deduction](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)
Yes but this thread is specifically about CLion 
I appreciate your positive attitude to encourage everyone, regardless of their background or skill level, to contribute to your project. However, you shouldn't assume that about other maintainers. I've seen PRs either being completely ignored or closed without reason; it can be frustrating and discouraging for beginners to experience that. Maybe I should tone down my statement a bit: If OP manages to find a repository that encourages contributions and is willing to discuss and/or explain problems with the submitted PRs then this can actually be a great way to learn C++. I've never made that experience, unfortunately.
Isn't `switch` also O(1)? Btw, it seems that the compiler could always implement `switch` using the array approach if it turned out to be faster.
The basic problem is that primitive values are trivially copyable, but unique_ptrs aren't. Containers like `vector` make heavy use of top-level optimizations for copying, moving, deleting, etc, elements that depend on this (and related) property: they'll dispatch to optimized routines like memcpy for trivial types, but with unique ptr they'll have to go through all the mechanics of handling elements one-by-one. That one-by-one code will also get optimized but the result generally won't be nearly as good as the trivial path. [Here you can see an example of the effect](https://stackoverflow.com/q/45089049/149138).
&gt; in practice it's somewhere between 6 and 7. But in actuality it might be behind 3.x in some areas (how long did it take for Apple to support c++11 TLS?).
Yes, finding a friendly community where I can work on bugs / simple tasks is my goal. The community would have bugs fixed \ simple tasks resolved, I would have my skills improved.
I'd resist calling performance degradation from fixing a correctness bug a "regression". The negative connotations imply it was a mistake.
The only link in your post is to already fixed bug (confirmed by you). Even if it's similar, it doesn't count "as being reported". The devs are not telepaths. The thread would be more justified (in my opinion) if it explored why exactly this happens (or tried to find someone who does)/what class of programs is affected by this bug or if it was something really major that'd require PSA. Otherwise, what's stopping someone just going through respective compilers' bug-trackers and creating a thread about each bug they encounter?
So, if I'm not misreading this, you are proposing that C++ move to something very much akin to the Swift model of error handling? While also adding support for calling thrown functions to plain C? That sounds amazing.
Contrived? It's just a basic use of vector, that tests something as basic as adding elements and resizing a vector. Of course you'd see it in a profile for a real application ... if your application did a lot of this. I can understand the sentiment of "you should profile things real applications" and "microbenchmarks lie", but it shouldn't be used as a carte-blanche to dismiss microbenchmarks! My typical path to showing a performance effect is to find it in a profile in a real application, then isolate it down to a minimal benchmark that shows the same effect, because no-one wants to build a million line application or talk about a 2% effect when 98% of the code has nothing to do with the effect under test. The bottom line is that vectros of unique_ptr are 2 to 10 times slower than raw pointers, in common real-world scenarios (considering only the time for those operations). If you don't care about the performance of those vectors, and probably 99% of people shouldn't because it's a small part of their overall runtime, then great! 
Well Herb Sutter mostly. I just gave one of many possible implementations. But mine has been run past WG14 and the Austin Working Group, so it might have legs. We will see in the WG14 meeting in October and WG21 meeting a few weeks after.
You're right, I just checked. I had build 10A254a and the app store version is 10A255
I can't help with the mailing list. But really the best way is to find a bug in boost, make a test, demo the error, make a fix and post the whole thing as a PR to the GitHub repo, If you this bug is due to something you're working at work - even better. You get contribute something useful, learn more about C++ and Boost, and do it while getting paid by the company you work for! Its win, win, win for everyone involved.
Not sure but it was at the Sydney C++ Meetup. It'll be on at Pacific++ as well and they do put their talks on youtube
It showed 2X to 4x improvement, not 10x. it calls shrink to fit on a vector when the capacity is only 1 element higher than its current size. That is contrived. Full stop. Further: if insertions and deletions are remotely close to being the cause of performance problems then you should rethink your data structure. There are alternatives that have O(chunksize) copy/moves. Here, I fixed it: use std::list. Or here, I fixed it: Use sentinels. Just reset the entry to delete. Everything I‚Äôve suggested would be 10x or 100x better on that micro benchmark. I can‚Äôt believe you‚Äôre arguing this... 
It could've changed. I remember seeing some relatively recent benchmarks of different map implementations and it looked like `map` becomes slower than hash analogues even on as little as ~32 elements. Also, keep in mind that if you have less than 100 elements, there is also a high chance that a simple sorted `vector` + `binary_search` would fair better than `map`.
1. Consider a header only portion of your library. Where do you keep its sibling test file? Suppose you keep it in `include` directory. Then, your installation of your include directory has now become tedious. You need to either glob your header files or install each of them manually. Both of the options do not inspire confidence. Especially when a much easier installation route (install directory) is available. Suppose you keep it in the source folder, then the "sibling" nature is anyway gone away. And there is no difference from `tests` folder. 2. You will have a `tests` folder anyway. Suppose you have a test file that depends on two components in the same `src` directory. Does the test file go in that directory as sibling, or is immediately transported to `tests`? Suppose someone is searching for the source of the said test executable. Where does he search for? 3. Since this is CMake specific. It will often happen (for library repositories) that your libraries might not depend on any specific software. However, the tests do. In such cases, often, you do not want to build tests when someone is just installing the library. Now, if all your tests are in a separate directory, then not building tests is simply one condition of code in the root CMakeLists.txt which either `add_subdirectory` tests or not. If you have sibling test files, then your CMake code maintenance increases a lot, and you can easily make mistakes. Mistakes which will not be noticed either on developer machines or in CI, since both run tests. 
I mean that in my experience the range of performance differences due to this effect is in the 2x to 10x range - not that this particular example showed that. You are right that shrink_to_fit there is contrived, I forgot it had that and I chose it because it was a detailed case with reasoning: but my claim isn't based at all on that post but repeatedly seeing this effect in _real applications_. You see the same effect for vector copies and deletions, for example. Sorry, I can't go show you those cases though! If I had a time machine and you somehow were able to peek at whatever proprietary code though maybe. I'll take your workarounds of using a totally different structure as acknowledging that unique_ptr in a vector is slow. `std::list`? I guess you're not serious. If you are, I think that we don't have much common ground for discussion. You are talking about a whole different magnitude of slowness...
Lmao, in 2 months of schooling I was doing functions and arrays xD. 
&gt; Discards leading whitespace from an input stream. (from cppreference) I assume it discarded some whitespace but not all. I hope the standard is clearer on what is whitespace.
I've updated to v15.8.5 and the problem remains. I opened a [new issue](https://developercommunity.visualstudio.com/content/problem/340703/ltcgincremental-is-untrustful.html) as suggested.
It can be, but it doesn't have to. A naive implementation is O(n). Arguably still much faster than an unordered map for small values. Linear lookup is completely fine for small values of n.
If you just have a POD, you might as well make it a tuple and inherit from it. You get all the nice stuff from tuple and you can add your own. And you could get some EBO depending on how the tuple was implemented.
Why can't you use any version of clang you want with xcode?
/r/cpp isn't really for code reviews. instead check out /r/cpp_questions 
If I recall correctly we were wrong about some of the error flags were handled. ``` { testbuf&lt;char&gt; sb(" "); std::istream is(&amp;sb); ws(is); assert(!is.fail()); assert(is.eof()); ws(is); assert(is.eof()); assert(is.fail()); // this assert failed } ```
That's not tellg/seekg, that's the performance improvement to call fread/fwrite instead of fgetc and fputc (through virtual calls) repeatedly.
This is why we had to remove `__declspec(noalias)` from our `malloc()` :(
I don't think it's a correctness bug in this case, given that the only reasons errno would get set are part of the input and here the input is identical.
Good point. I have to say I don't know how you can have a bug in this function if `isblank` is correct. Unless it was simply not doing anything.
Hmmm I'm failing at finding the original repro for the 0 case right now but here's an example: ifstream is; is.open("filename.txt"); is.tellg(); // returns 0 is.peek(); is.tellg(); // returned 1, now 0 is.peek(); is.tellg(); // returned 2, now 0 (Note that tellg is morally `rdbuf()-&gt;pubseekoff(0, cur, in)`)
Sometimes a detail and friendly review like this one is a reason for us to start to dig a repo deeper :)
They are much better than many common alternatives. You can still prefetch the elements which is what‚Äôs the most important. 
&gt;but nobody will accept pull requests from beginners My first (and accepted) PRs on repos are often simple fixes and one-liner. I think reviewers don't know if I'm a beginner or experienced, they even don't bother with it.
The project is at very early stage at the moment. They had only one tag/release at the beginning of Sep. The idea is great though. Google test also mentions that they‚Äôll move to abseil (if I am not mistaken). IMHO, it‚Äôs better to check back in ~1/2 year to see the project in more mature state. BTW, it nicely integrates with Bazel build.
Except for the whole "access members by name" thing.
Abseil launched on September, 2017.
Abseil is very mature as it is externalization of Google internal libraries. 
I like the idea of abseil, though I haven't found an application of it in my day-to-day work. 
For your first point, you can give them names through getters/setters. You're very right for your second point. 
The encourage everyone to "live at HEAD" and are reluctant to tag releases.
I've used a few bits and pieces of it (`optional`, `string_view`) while the compiler vendors were/are working on C++17 support. 
I'm down
An unsound transformation was removed. When that happens there will almost always be cases where it would have been valid even if the proper analysis had been done (like this). Not that it really matters, it'd be a good optimization to develop properly whatever we call the situation.
It's probably quite nice, but the naming conventions it uses are neither close to Stroustrup style, or to the standard library. Capital letter functions? Blegh.
It's not clear to me from reading the blog post or the pdf; is there a way to use MSVC's implementation today? 
yes, there is 'run analysis' or something like that, which uses the lifetime checker.
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9hbrsk/looking_for_cpp_opensource_project/e6d828n/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list
Because it can‚Äôt see if the loop will run a second time. 
It looks even more sneaky than that. We set p to point at something. cond must be true for us to enter the loop. We set *p to something. We set p to null. If cond is still true, we set p to something. If cond is still true, we loop. So cond must be true for us to set p to null, then false to not set p to something other than null again, and then true again to loop and try to dereference what is now a nullptr.
Multi-threading?
very cool. although i had a play and it doesn't catch this case: auto plus_n(int n) { return [&amp;](int i) { // captures n by reference return i + n; }; } // n is destroyed here int main() { auto plus_one = plus_n(1); return plus_one(5); // adds 5 to a dangling reference } :(
Another thread may not modify cond. that would be UB. 
This is like my No.1 UB when using lambdas.
I don't see any synchronization issue related to cond here...
&gt; if another thread is modifying cond. I was responding to that part of the explanation of how this could be an issue to explain why the explanation was wrong.
Our concurrency support is marred by ConcRT and makes me sad. I have a completely rewritten implementation for whenever we break bincompat but every time I look that looks further away :(
All the hype for CppCon making me so frustrated that I can't go this year üò¢. Will follow as much as I can online. Good luck regarding the talks and thanks for mentioning my Qt course! 
Why doesn't "-O2 -g" work for debugging? 
This is one of my gripes over C++. Assigning a boolean should be atomic; is that a performance concern? Or is another "irrational thinking" thing a-la vector&lt;bool&gt;?
https://godbolt.org/z/R5C-X5 - This code definitely shouldn't be emitting a warning - we only pass const std::vector to class constructor. Anyway, treating any function that accepts non-const reference as fully invalidating will result in unreasonable amount of false positive warnings. I think checks that will catch less fails, but with no false positives will be much more useful.
Then change the API: instead of having two APIs (Qt Widgets and QSkinny), have one new and shiny Widgets API which is built on top of any renderer possible. It's been done before, there are lots of GUI libraries that can have multiple backend renderers.
Thanks. I believe the article [How to use the C++ Core Guidelines Checker outside of Visual Studio](https://blogs.msdn.microsoft.com/vcblog/2017/08/15/how-to-use-the-c-core-guidelines-checker-outside-of-visual-studio/) fully clarifies it. 
In compiler explorer, the language Cppx is selected for the examples. Anyone has a link to the Cppx project used in compiler explorer?
&gt; Then change the API: yes, that's what they did with QtQuick. But not everyone likes QtQuick's API so some people try other APIs (e.g. QSkinny or the one I mentioned earlier.).
Memory fences aren't free; assigning the bool (probably) can't tear, but if other cores don't update their caches they'll never see the change.
why would you want inconsistency like that? Stop thinking about hardware and start understanding the language. If a boolean is atomic, then atomic&lt;bool&gt; will be free. if it's not, then it's not - but you only pay for what you use, either way.
Thanks, this is reasonable. However it is more of a multi-processor/core issue rather than generic multithreading.
Doesn't seem to have anything to do with cond being extern, I get the same result if I make cond a local variable. Weird...
I think Cppx is a relatively current build of Clang trunk, i.e. the development version.
If cond never becomes false it's an infinite loop, which is undefined behaviour. The compiler is presumably assuming cond can become false because of that.
No it is not in the trunk, it is https://github.com/asutton/clang/
The diagnosis is useful if instead of a std::vector, you have a type with mutable members.
Nice! One suggestion though: This would be infinitely more useful to me were it built using CMake with a clean dependency to Qt. I get my Qt via the conan package manager and combining this with a custom QtCreator project is almost impossible (at least for me)
The haters: "But muh sweet sweet undefined behavior" What I say: FUCK YO UNDEFINED BEHAVIOR
Ohhhhh I remember a real nasty bug I was having - I eventually identified it as just this issue. Gotta check if it gets caught. 
Replace `class` with `struct` to avoid other bloat in errors
No, STL is good enough for my use cases.
I don't know what to say about your point. I understand the language, I just don't agree on some detail. Still knowing the hardware and the difference between that and the abstract machine is important, or so I believe. 
I don't get where all of this CamelCase plague comes from - too much prior Java/C# experience or stagnate shematical OOP?. There is only one true naming style in C++ and it's in the standard library. Anything else should be marked as inconsistent.
It's not. There's lot of code that predates the standard library. 
&gt; unlike some other library APIs that are inconsistent within the library, such as Facebook's folly library I was kind of disturbed that SFML uses `camelCase` for function names when writing simple game projects because it's inconsistent with other parts of code that were common STL algo/container stuff. But I was really surprised when I realized that SFGUI - the GUI library with SFML as the only dependency uses `PascalCase` for functions. Now I have 3 different styles in a 2k LOC project.
It might be a bit too much to require from the compiler, but I think that one could write a tool that can rename a symbol both in the source files *and* in the the object files without recompilation. It might have to run the preprocessor on the source code to check for some corner cases involving macros.
Right, the refactoring tool should also check against name clashing or invalid identifiers. Would still be faster than a full rebuild.
When talking about sequence containers: &gt; iterators pointing to the removed elements gets invalidated, but all other iterators to the container remain valid. Iterators that come after these elements are also invalidated.
Since the Google C++ Styleguide is widely considered not very good in the C++ community (what you often read is that it's seen as "probably good/applicable" for a company with the codebase size of Google), but not seen as a very good "overall" recommendation for everyday projects or projects not the scale of Google. I am wondering, does the same apply to Abseil? Does it not use C++ style that's overall considered good? For example how does it follow the CppCoreGuidelines?
Strange, my main gripe is that I update often, only to notice hardly any change in my programming job, even though we have a million lines of code. Perhaps breaking a build depends on what you use, e.g. we use lambdas a lot, but no complex templates.
&gt; If cond never becomes false it's an infinite loop, which is undefined behaviour. It's not undefined behavior per se but is rather just that the standard allows implementations to assume that this is the case: &gt;The implementation may assume that any thread will eventually do one of the following: &gt; &gt;‚Äî terminate, &gt; &gt;‚Äî make a call to a library I/O function, &gt; &gt;‚Äî perform an access through a volatile glvalue, or &gt; &gt;‚Äî perform a synchronization operation or an atomic operation. ¬ß4.7.2 [intro.progress]
fingers crossed for VS 2021.
That is (at least by default) not true. Since 4.8 Qt has own backing store where entire hierarchy is rendered. For example on OS X that means there is one NSView for entire window. Now there is Qt:: AA_NativeWindows attribute that results in all widgets being backed by native views, but in reality at least on Mac it is very slow and glitchy. So in this regard neither QWidgets nor QtQuick would allow you to put easily native widgets in hierarchy. On top of it the problem with QWidgets is the backing store being in RAM, which on OS X makes updates during large content changes very slow, as the pixels need to be transfered to GPU. That's why QtCreator scrolling in 4K is much slower than Xcode or even VSCode. With QtQuick it is much smoother, I just wish there was a sane C++ API, not QML.
One reason would be performance. Qt Widgets are all rasterized in software. The rasterization part is actually quite quick and well optimized, the problem is that after end of frame, you need to push changed pixels to the GPU, and at least on OS X that's quite slow. 60fps scrolling in 4K with QWidgets is just not going to happen, while with QtQuick it perfectly doable.
I'm fairly sure this isn't it. Consider that the loop ending doesn't actually cause this issue, and that using an equivalent `while` loop works. 
This is not as trivial or possible as you think. What about `__FUNCTION__` and the like? Actual generated data does change when you rename something. The reflection proposals are just going to make it "worse" too. Instead of special-casing just renames, it'd be great if compilers had a finer-grained cache than individual object files. This is inline with what Rust is (trying to) use these days. I believe ZapCC did something similar too.
Variables, maybe. Nope on class names. Types are encoded in the names of symbols in the object files. Also, it's a lot to expect of a build system to read your mind and know that something does not need to be recompiled. Particularly because we're so often wrong about things like that. 
Your boss can buy you a faster/more-core machine for less money than the engineering cost required to fix this in the compiler :-P
Changing symbol names can have pretty dramatic effects on code generation: changing overload resolution, template instantiation, etc. Detecting whether a rename caused changes may, in fact, be as expensive as just recompiling.
I remember Herb's CppCon 2015 talk. It was quite exciting back then to finally see somebody tackle object lifetime issues in C++. It only took three years to develop the first usable implementation. I'm sure it misses a lot of real world cases, but at least it's a start!
&gt; What about __FUNCTION__ and the like Yeah well, that string is going to be wrong until the next full recompilation. I know is not correct, however it would enable a faster iteration. &gt; The reflection proposals are just going to make it "worse" too. Right, if you reflect by name then it may fail. However some refactoring tool can also search into strings and comments. I didn't said it should be automatic, renaming a symbol would still require a human check.
&gt; changing overload resolution In my mind, that should be forbidden by the refactoring tool. It should be possible and not so expensive.
This might shed some light https://stackoverflow.com/questions/17473753/c11-return-value-optimization-or-move
I'm still waiting for the hash table that was advertised at the last cppcon. It sounded pretty great, but AFAIK still hasn't landed in Abseil. I'll be looking into Abseil the day that happens.
I also don‚Äôt know why everyone needs to invent their own C++ naming convention. It‚Äôs probably the only widely used language with this problem; everywhere else it‚Äôs pretty normal to just use the style of the standard library (and I like CamelCase when it‚Äôs in C#). I‚Äôve also seen style guides advocate adopting a naming style that‚Äôs actively trying to differ from the standard library style AND use standard library style when writing classes that ‚Äúcould as well just be in the standard library‚Äù, such as custom smart pointer classes.
So basically I just have to assume that anything being returned will be moved or optimized out?
Name resolution in C++ is incredibly complex, and is the primary reason that compiling C++ is so much more expensive than compiling C.
If one thread writes a value and one thread reads it, and there is no sequenced-before relation between them (which could be provided by atomics, like locks, etc.), then you have a data race which is UB. https://en.cppreference.com/w/cpp/language/memory_model
The idea that a function should be "anonymous" is a bit strange. Surely code readability would be improved if the function had a name? Without a function name I now need to read the code closely and infer what it does, which is slower than just giving the function a sensible name and declaring it somewhere else.
&gt;[Unless] both conflicting evaluations are atomic operations (see std::atomic) Again, open to correction, but I don't believe that the standard mandates that reads and writes to any non-std::atomic type is necessarily non-atomic. 
Abseil really needs some better documentation. Reading header files is not a substitute for documentation. That said, the only thing I have found useful is the strings library. C++ standard library for string manipulation is really barebones, and abseil supplies some commonly needed functions.
No, that style far predates Java or C#, or even Google. It's been around for decades. As far as I can tell, the style tends to split more on OSes than anything else. Nearly all professional Windows and Mac programmers (or at least, their development houses) tend to use this style, as it's consistent with Microsoft and Apple style guides. *nix programmers seem to use lower_case. 
Game development tends to be very Windows-centric, and so the style of PascalCase for functions and camelCase for variables with m_ / s_ / g_ decorators is incredibly prevalent, as this matches Microsoft style guides. In fact, so prevalent I can't recall a single employer of mine over the past two decades who didn't use those styles.
If the standard doesn't mandate that it *is* atomic, then it's not defined behaviour. An implementation could treat all boolean reads/writes as atomic if it wanted to. Behaviour would then be defined under that implementation, but not by the standard itself.
Don‚Äôt do this. I‚Äôm sure you will end up with subtle bugs. Best case scenario is that the bugs aren‚Äôt subtle. I also doubt that this will improve performance. The reason that the stack is ‚Äúfaster‚Äù is because you can avoid a call to `malloc` and because it‚Äôs likely in cache already. But if you allocating data structures, the allocation will only happen when you create the structure, and if you use the data frequently, it will likely stay in cache. You say that you need ‚Äútremendous performance‚Äú, but that‚Äôs meaningless. How are you measuring your performance? Do you need to maximize throughput or minimize latency? If it‚Äôs latency, are you concerned with the average or the worst-case? I‚Äôd recommend you check out [Agner Fog‚Äôs guides on optimization](https://www.agner.org/optimize/) to start. Write your application so that it‚Äôs correct. Design it with performance in mind, but don‚Äôt consider tricks like this until you‚Äôve profiled (so you can compare the before and after). I‚Äôd also suggest trying other improvements before jumping to something like this.
As I understand it, the sticking point is converting to/from floating point. Forgive my ignorant/uninformed question, but what is so challenging about it?
My library is inconsistent on this also. I guess I'll switch to lower case first letters: [https://github.com/Ebenezer-group/onwards](https://github.com/Ebenezer-group/onwards/graphs/traffic)
Agreed. Google test is more fully featured, so it may be a better use for large projects or large organizations. But I use Catch (actually, Catch2 now) for my personal projects, as it's more than enough for my needs, and it's ridiculously easy to use.
Thanks, man. I'll keep all this in mind. 
I wish we had something like clang format but for naming conventions...
Nice to see some innovation in language design still happening. Can't say the same about D though...
Take a look at Wikipedia's article on [double-precision](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) and think about how you could convert that to the shortest number of decimal digits that are guaranteed to convert back to the exact same bit representation. Doing so quickly, within the limitations of computers (namely, that arbitrary-precision arithmetic is slow, and 32/64-bit arithmetic is fast), turns out to be difficult. There are also many cases to handle, both in the interface (charconv supports both scientific and fixed notation), and in the numbers (floating-point numbers can represent very large integers, and we need to print all of their digits out exactly; doing so is a hard sub-problem in and of itself).
That only lets you produce backtraces. It doesn't provide any information about variables.
Shit my bad fam I didn't know but tell you what though growing up in the hood I was the only nigga that could write a constructor with a proper invariant; hell, I once tried to write a class template but got as many errors as my nigga Tyrone got bullet holes in him that one time his ass got busted for selling illegal weed.. Anyways thanks for telling though cuz I got banned from r/lgbt for saying that interfaces in Go are gay I guess they thought I was homophobic or some shit so thanks for not banning me.. Anyhow stay up homie those templates ain't gonna write themselves you know?
Reflection (which we may get in the future) was mentioned, but what about RTTI which we already have? You can use it to get a type's name in runtime. This leads to issues involving exception, as (at least GCC if I remember correctly) uses the same RTTI to determine if some catch handler should handle an exception - that is, by performing string comparison on the types. Renaming the exception class name will require updating the RTTI as well.
&gt; Variables, maybe. Once you take into account debug symbols, likely a nope there to.
Let's also remember _name mangling_ is a thing and is important. If the build happily doesn't rebuild your object because a name changed, but it's going into a shared DLL that's loaded by some other code that _is_ expecting the name to change... bam. Totally broken. &gt;Yeah well, that string is going to be wrong until the next full recompilation. I know is not correct, however it would enable a faster iteration. Which will absolutely break any number of applications that use that information for serialization or script binding or all kinds of things that would break. Requiring *full recompilation* to fix these issues is just... I don't have nice words, other than to say that your suggestion would actually make iteration **far worse** for a very many users. &gt; Right, if you reflect by name then it may fail. Absolutely unacceptable. Speed cannot come at the cost of correctness. Iteration can and should be much better in C++. Your suggestion just isn't the way to do it.
My #1 is when trying to capture a member variable. It instead captures 'this'.
Maybe compiling the whole thing should be faster? Our native you need compilation to be less transitive?
\*\*Company:\*\* [GOG LLC](http://discord.me/gamingogs) \*\*Type:\*\* Full Time \*\*Description:\*\* We are a video game hosting company, We need C++ devs to create plugins for a video game called "Ark Survival Evolved" There is a public [ArkServerAPI](https://arkserverapi.com/resources/ark-server-api.4/) servers use to create C++ plugins .dll files. \*\*Location:\*\* United States, Texas \*\*Remote:\*\* Yes \*\*Visa Sponsorship:\*\* No \*\*Technologies:\*\* 1. C++ Coding 2. Unreal Engine Knowledge 3. Visual Studio C++ / Create .dll files 4. Compile [ArkServerAPI](https://arkserverapi.com/resources/ark-server-api.4/) to understand the dependencies. \*\*Contact:\*\* Email: [TheGamingOGs@gmail.com](mailto:TheGamingOGs@gmail.com) Discord: [discord.me/gamingogs](https://discord.me/gamingogs) (Contact TheOwlSky in Discord)
That gets tricky as you need to also fix the symbol names for lambda's and classes/structs declared in the function.
It is UB to have a race condition. Having another thread modify it outside of synchronization is a race condition, therefor it's UB. 
you're thinking about hardware, not about the spec. The spec says if it's not synchronized, it's a race condition. Hardware doesn't matter.
We have clang-tidy and the readability-identifier-naming checks: [https://sarcasm.github.io/notes/dev/clang-tidy.html](https://sarcasm.github.io/notes/dev/clang-tidy.html) You can specify your own conventions in the .clang-tidy and just run the tool ;)
&gt; It's not undefined behavior No?
the while loop either never enters (if cond is false) or never finishes (if cond is true). There is no synchronization so cond can never be changed anywhere.
&gt; I know is not correct, however it would enable a faster iteration. Wow. Just wow. 
The cpp core guidelines suggest naming your own types starting with a capital letter to distinguish them from library types. With underscores between words that just looks weird. I don't see much code that follows that advice. Maybe C++ has this problem because the standard library style just isn't very good. I mean most other popular languages distinguish constants in some way for example. If the consensus among different language communities is that it's worthwhile, then perhaps it's no surprise people don't follow the standard library.
Why don't add a switch, so that the user can choose between backward compatibility or the newer improved library?
I was going through the charconv header that ships with VS, and I noticed that your arbitrary precision math doesn't use any compiler intrinsic! You are chunking data in 32 bit ints, and manually checking for overflows using 64 bit ints and shifting. No ADC, _umul128, etc intrinsic is used. Lack of intrinsics is not surprising in portable code which must work across compilers, but your code will only be compiled by VC++. I found the lack of intrinsics very surprising, given that these intrinsics are practically tailormade for arbitrary precision math. Also, you are leaving quite a bit of performance on the table by using 32 bit chunks on 64 bit machines. Any particular reason you do not use any of the compiler intrinsics in charconv?
The version that is shipped today is not the same that will be demoed on CppCon. Expect the next shipping version to be much better than the one currently available. It was a rewrite from the ground up.
Any idea as to when is the C++ modules special meet ?
It was yesterday and today.
To give a bit of mathematical background on /u/STL 's answer, anything to do with floating point is hard. The problem is floating point is not exact, a number like 0.1 doesn't have finite representation in binary. So in any program using floating point, you keep on accumulating errors. There is a branch of mathematics, numerical analysis, which deals with these. When you store 0.1 in a `double`, what you actually get is `0.1000000000000000055511151231257827021181583404541015625`. So this causes the problem known as roundtripping - how to write an algorithm which takes a decimal number, stores it in binary, and then converts it back to decimal, printing the original number? How many digits are enough? In case of double precision, it turns out that you need a maximum of 17 decimal digits to represent a double. There is a general formula for this. For two bases B and D, to round trip from base B to base D and back to base B, you must satisfy `B^n &lt; D^(m - 1)`, where n is number of digits in base B and m the number of digits in base D. Another hard part in decimal to binary conversion is rounding. How do you decide whether to round up or down? In case you want to go deeper into the rabbit hole, [this site](https://www.exploringbinary.com/) is a fantastic resource.
Correct me if I'm wrong, but I thought the most controversial part of that was to never use exceptions...and lo and behold there are proposals in flight to dramatically change how exceptions are implemented that directly address concerns about them in Google's and other company's style guides.
I derived that code from the CRT's implementation, and while I was able to improve several things, the 32-bit element choice would have been too time-consuming for me to change (particularly given the complicated division algorithm). The non-obvious restrictions that we need to deal with are: we need to support 4 platforms (x86, x64, ARM, and ARM64), so dealing with intrinsics that aren't universally available is "fun". We're doing so anyways, particularly in the new Ryu-derived code that I'm shipping in VS 2017 15.9, but we need fallback codepaths. (Ryu is using umul128 and shiftright128 on x64 only.) The more obnoxious restriction is that we have to target all supported processors, so we can't assume SSE availability on x86 (we have to support all the way down to basic IA32) and we can't assume anything more than SSE2 on x64. Any newer intrinsics need to be guarded with runtime checks - which we do have in our vectorized reverse() etc., but it's a lot more work to achieve. There is definitely room for improvement in charconv, particularly around that bignum implementation, and we might do more performance work in the future. (I can't make any promises given how we're going to have to work on C++20 after I finish the last part of charconv.)
ITT: whining about case convention in identifier names. :eyeroll:
+1 for Exploring Binary - James referred to it while overhauling the CRT's floating-point code (which I then overhauled into from_chars) and several of our test cases are taken from there. I also found Rick Regan's posts useful while writing to_chars, particularly about the maximum exactly-representable powers of 10 (which is an edge case that I handle by carefully switching between Ryu and long division).
Well everything sucks for some reason or another. However I believe the LLVM project has had a very positive impact on GCC and the free software foundation. GCC development seems to be a little bit more open and the compiler suite it self has advanced dramatically. So yeah the project provides motivation and perhaps a bit more reasonable behavior form the FSF. I believe another big factor in the advancement of all of the C++ compilers out there has been the standardization process. The standard gives developers hard targets to shoot for and also add to the competition aspect. Even MS had ot get on the band wagon after years of shipping a really shitty C++ compiler.
The paper says that these rules are NOT data dependent (2.4.7.2) There is no analysis based on what we're actually branching on... only that there is a branch. There are special rules for special branch conditions where we're checking for whether or not a pointer is null (2.4.8) but that's it. 
I must thank you for the extensive comments you provided - made the code very easy to read and understand. ADC and double wide multiplication is supported on all x86 processors in the last 30 years I think :) Not sure about ARM. But yeah, C++ 20 stuff is muuuch more important than better charconv.
You're welcome! (Many of the comments are taken from the CRT and edited by me, but I added some, and tried to comment the new charconv stuff too. xcharconv_ryu.h in 15.9 mostly has Ulf's comments but I have some extensive ones for the fixed-point logic I added, including a big comment table.)
And it would most likely get it wrong, leaving you with corrupt object files and you wondering, why some random tests start to fail.
You can annotate functions that takes stuff by non-const reference and does not invalidate its argument. Unfortunately, the make\_unique example is tricky. The compiler can see the signature of make\_unique at the call site, but it would be more interested in the signature of the constructor. It might need interprocedural analysis to deal with this. Hopefully the Herb or the devs will come up with an idea to circumvent this problem :)
Imagine the limitations on the optimizer if every time it saw a bool that wasn't lexically constrained to that function or whatever that it had to assume that something else was constantly modifying it. Not only the optimizer, but for the programmer. it's *good* to know that stuff can't be externally modified unless it's within explicit synchronization that isn't "spammed" like every bool variable.
There is certainly some influence from other, more popular languages, but PascalCase and caramel Case have always been common in c++. E.g. the Windows API uses it it, Qt uses it, as do a lot of other frameworks. Actually I believe the adherence to the stl style is a more recent development. Don't forget, that the stl is actually pretty small and was often completely avoided during the early times of c++.
c++ is also probably one of the languages with the smallest standard library (which also got avoided a lot in its early days). So ic most library code comes from other sources that follow different styles (at anyone) it isn't that surprising that you rather follow that style. 
&gt; we only pass const std::vector to class constructor That's not actually true. What you're actually doing is calling `make_unique&lt;X, vector&lt;int&gt;&amp;&gt;` which _does_ take a non-const reference to your vector. If you had `X y(x);`instead, no warning (once you make the constructor public).
You sound as if the people defending the concept of UB are intentionally putting UB in their programs. 
We use exceptions in gamedev on what people would call one of the higher performing games out there. You just don‚Äôt throw exceptions in the main game loop and it‚Äôs a non-issue.
Have you measured the difference with -fno-exceptions? I suspect you've been especially mindful of performance considering the nature of your game, so I'm curious (and I'm sure many others would be too) what the actual difference would be. We don't use exceptions in the game I work on because a lot of our code is &gt;15 years old and is not nor will ever be exception safe.
No. The rest of the game is built with exceptions so it‚Äôs non-trivial to compile without them. The key thing is to just not handle exceptions when they shouldn‚Äôt be thrown. The only time they get thrown is then a total-failure condition and you just terminate the process. Everything I‚Äôve ever seen online about c++ exceptions says they have no performance overhead if not thrown and that matches my profiling.
Bazel again. Having fighting with it for the last 2 weeks (compiling and working with tensorflow) all I can say: god, really? I get it that it's probably awesome at solving google problems, but it's not awesome for solving my problems. I don't want another build system, I am fine with what I have. Google: use bazel if you want internally, it's great. Let the world out of it. 
It's a good point. In fact one can always improve `std::map` performance using a pool allocator as the second template argument.
Well if its a class which actually mirrors an STL feature yet to be in the standard your project is on, naming it the same as that class can make switching to a newer standard version a lot less painful.
Abseil also supports CMake. It's worse than Bazel, but whatever floats your boat.
Will there be a trip report?
That‚Äôs what code review is for. Also just not letting randoms commit.
`multi_index` is my favorite. It saved so much of my time. It's really beneficial when you can have several different views of your data. For example, a sparse matrix below. You can access elements by \[row, column\] or you can list all elements in a single row, or in a single column. struct Elem { double v; size_t row; size_t col; }; struct by_row_col {}; struct by_row {}; struct by_col {}; typedef multi_index_container&lt; Elem , indexed_by&lt; ordered_unique&lt; tag&lt;by_row_col&gt; , composite_key&lt; Elem , member&lt;Elem, size_t, &amp;Elem::row&gt; , member&lt;Elem, size_t, &amp;Elem::col&gt; &gt; &gt; , ordered_non_unique&lt; tag&lt;by_row&gt; , member&lt;Elem, size_t, &amp;Elem::row&gt; &gt; , ordered_non_unique&lt; tag&lt;by_col&gt; , member&lt;Elem, size_t, &amp;Elem::col&gt; &gt; &gt; &gt; SparseMarix;
Well, I know CMake and while it is not perfect, if found it to be quite adequate and fast. bazel ... takes ages to compile shit. Not my shit, mind you, google's shit. What's better about bazel for me? I get that it supports distributed builds, which is probably essential for google, but that "feature" is actually slower when i compile locally. 
I wasn't there; we will try to do one for both that and executors
I'm thinking about the flexibility afforded to implementations, not hardware. As far as I can tell (although the standard seems a bit vague), since there's no explicit provision for an implementation to define the atomicity of reads and writes to a primitive type, I am wrong.
I‚Äôd also add this is something that is easily caught by asan/ubsan If you‚Äôre not testing with them then you‚Äôre missing out
&gt; Abseil really needs some better documentation. Reading header files is not a substitute for documentation. It can be fine way of documenting... just not if you also pollute the "public" header (or part of header) with the implementation.
If you take something by const reference or value, the check will know that the function will not invalidate/resize the vector. If we require all functions that takes a non-const reference to be explicitly annotated as invalidating ones, we would never give any warnings for unannotated code. Getting the defaults right is always tricky, end the goal is to have sensible results on unannotated code (that is following the core guidelines). Maybe this was not clear from the beginning, but this analysis is mainly intended for those projects that willing to follow a set of rules. It is not a bug finding tool, it is a way to enforce a safer coding style. &amp;#x200B; You made a good point with annotations and template instantiations. I do not have an answer for that now, but hopefully it will be fixed soon.
May as well go to the logical conclusion at that point and do `#define REQUIRES(...) std::enable_if_t&lt;__VA_ARGS__, int&gt; = 0`.
Those "popular header files" you're talking about might be the real problem. It's very easy to create bogus dependencies between unrelated things this way. 
It's not quite that either. The lifetime work was backported to that branch last week (check the commit history). 
We can detect that via macros, so runtime detection could be avoided with compiletime detection.
I think it's probably a problem even without taking debug symbols into account. Consider what happens if we have something like this: class Foo { // ... public: Foo &amp;operator++() { /* ... */ } }; Foo x; int f() { short x; // ... ++x; } Rename the inner `x`, and the code you generate for the `++x;` completely changes, because it's now dealing with the global `x` of an entirely different type.
What actions did you take to lower compile-time dependencies? What actions did you take to speed-up your build? Do you need a "full" rebuild of varuious/all modules in your codebase? If yes, why? You should be able to build and test them somewhat independently in your modify/build/test cycle. How often do you rename artifacts in your "popular" headers? Doing it often is a sign of immature design, as ~~popular~~base stuff should be stable.
Any link to people commenting on it ? I am really curious.
This reflection system allow you to iterate all the member, properties, ctor, etc. as well as to query a type to know if it contains something. Is this what you mean? Tests and doc contain examples.
I don‚Äôt understand your ‚Äúinherently wrong‚Äù part. Any lambda can be replaced with a functor, which should be easy to do. Lambdas really are just syntactic sugar for functors (and I‚Äôm talking about C++ function objects before you get all pedantic on me). Are you saying functors use is inherently wrong? Can you show me an example of bad usage of lambdas and how to correctly refactor it in your opinion?
Why not print `null` or some variant thereof?
Choosing the right name for your function at the beginning is important, because it forces you to think about the function's responsibilities. If you can't name it, you can't describe it. If you can't describe it, you don't understand it. If you don't understand it, think about it more before you write it.
Unfortunately, ASAN can't be part of your CI when your project is a python extension module.
Find the right name at the first time is very difficult and time expensive. There is lot of study material for that aspect: https://hilton.org.uk/blog/why-naming-things-is-hard
Neither ASAN nor UBSAN catch this. You need to use MSAN, which is Linux only, and requires you to recompile all your stack down to libc with MSAN enabled (including the C++ standard library, and the C++ ABI).
Ah, thought it was just me.
The original code had place holder comments (`// ...`) that could be replaced by real world processing of something and as a side-effect mutate `cond` in that way.
Yea that's definitely not the problem of exceptions, that's a problem of education and your company culture - e.g. missing or failing code reviews.
I assumed they were O(n). Are they done with a lookup table instead?
I believe it hide a something that behave like an uncompleted version of a mutex. Also, I have my doubt how this technic could work efficiently for solving issue such as the "Dining philosophers problem" without mutexes.
Not my company. We use exceptions and don't abuse them. But for a large code base like Google where there are loss of different teams all doing there own thing it makes sense to just do a blanket ban--to many moving parts. 
Well I would say that things such as namespaces are better for this than introducing inconsistency into a codebase.
If you want exact, you would need rational numbers; `1/10` is as exact as it gets. Much slower, but I still wish more languages than CL &amp; P6 would put some energy into at least providing them as an option for cases where speed is not the prime objective.
As @xazak_hun mentioned we should catch this soon. I'm not sure ASAN/USBAN catch it. ASAN/UBSAN/MSAN are great tools! But the biggest difference to note between *SAN and this -Wlifetime is that *SAN do run-time instrumentation whereas -Wlifetime is all compile time warnings (no run-time cost, no change to the compiled binary).
You will need to download more RAM.
I feel the article should at least mention that implementations have debug checks that you can disable if this speed is really an issue. This could save you from, e.g., changing a function to accept a pointer and limiting its genericity because debug iterators are too slow and you never bothered to try with non-debug iterators.
[This](downloadmoreram.com) should do the trick
Imagine a flexibility/performance scale with two end points. The switch on one end is very static, which allows it to perform really well since the compiler can see all of it at once. And on the other end you have a map of lambdas which doesn't really help the compiler at all, but is very flexible. It's not all that simple of course, I recently managed to replace an interpreter dispatch loop based on computed goto (which is even lower level than switch) with lambdas calling lambdas and improve performance at the same time. Sometimes betting on flexibility allows you to win performance back in other ways.
... for now :)
All good points, I appreciate the correction that this is not normally caught by asan. I think maybe I‚Äôm thinking of captures of objects that contain pointers to dynamic memory. For example if the temporary was a std::vector and the lambda was accumulating the elements. That would be caught by asan, right?
One of the guidelines from the standards and Stroupsoup is to avoid naming things such that they could be confused with the standard library.
Although I think that test is weak (the loops are done in the same instance of the program, the iterator case should be exactly the same as the for-range loop because that's what the standard sepcifies (but here the multiple end() call might be an issue)) etc,) it is helpful to have decent performance in debug, in particular in high performance code. That is, if you can't debug some piece of software because finding the bug imply reaching a state that is either very long to reach or impossible to reach if the code execution is slow, then you have a big problem. That's very common in video game development for example, where there are tons of cases where you wold like to see the state of the memory or some function call or even just debug infos on a crash, but reaching that state of the game requires the game to actually be playable, which often is not true in debug mode (because it's orders of magnitude slower). It's not always the case, but it will happen at some point, so gamedevs think about it when thinking about performance. Basically it's like saying that there is performance of the application, and there is performance of the development iteration loop of the application. In the contexts I described , the code should be designed for both (honestly I feel it's useful all the time but not everybody coding see the impact of debug mode on (soft-)real-time code).
It doesn't. You can `brew install lllvm --with-toolchain --with-lldb --with-python@2` to get a more complete version.
Stroupsoup himself says you're wrong. He literally says explicitly not to name your custom types in a way that looks like the standard library. 
Ah. Never heard of him before. 
Could someone analyse generated assembler to figure out what could be done better in vanilla c++?
Incredibly nice guy and a major contributor to making boost what it is today. I had the privilege of meeting Beman at boostcon in 2009. I hope he enjoys his well deserved retirement. 
Changing the default could happen when the minimum targeted Windows version rises to one that requires AVX processors. That's not going to happen for a long time. SSE2 is a possibility, though (Win8 required it, and it looks like Win7 was eventually updated to require it, although I am uncertain about the specifics).
Sorry to hear that. Personally I'd prefer if the default (not just arch but also things like x64 vs x86 or unicode vs mbcs) was something more modern and I had to explicitly opt in to the support of older systems, but I do see both sides of the argument. Thanks anyway for the explanation
If you have this position‚Äîthat `__FUNCTION__`, which is required to have a visible effect will be wrong and you don‚Äôt care‚Äîwhy bother to recompile after a symbol name change at all?
I will eventually build for production (with a build server actually), but when developing the faster iteration, the better. 
nobody thinks that std::vector is slow
That‚Äôs true with gcc (and surely every optimizing compiler that uses languages constraints as a source of optimizations). In gcc 6, sometimes it‚Äôs easier to read the GIMPLE to figure out where an -O3 only bug came from.
[Beman, the man, the myth, the legend](https://pbs.twimg.com/media/DEleJfuUAAAau4m.jpg)
&gt;Although I think that test is weak (the loops are done in the same instance of the program, the iterator case should be exactly the same as the for-range loop because that's what the standard sepcifies (but here the multiple end() call might be an issue)) etc,) I agree completely. This is a good example of how *not* to do microbenchmarking with tight loops. The compiler is free to move code around anyway it sees fit to improve performance so long as the results are the same (the venerable "as-if" rule taken to near-absurdity). &gt;it is helpful to have decent performance in debug, in particular in high performance code. This is an understatement! :) &gt;It's not always the case, but it will happen at some point, so gamedevs think about it when thinking about performance. gcc and clang support `-Og` for "optimized" debug builds. I work in scientific computing where Windows is non-existent; Does MSVC have something similar?
Wondering if there are [m]any macOS C++ programmers here and if so what is their preferred way of getting a non-Apple LLVM toolchain installed and working on macOS? I am *very* new to macOS and unsure of the best way to go about installing LLVM without breaking the Xcode version!
Yes, that's often called a "release with debug info" mode/configuration (CMake name it RelWithDebugInfo). It's not always enough though because some of the information you migth need in debugging might be happening in code that would have normally been inlined. With MSVC if my understanding is correct almost no usually inlined code is really inlined when you are in Debug mode (which is just a configuration with a bunch of flags deactivating all optimizations and adding debug infos). Scientific computing is still different because you don't have to step in a particular situation, do something interractively to trigger something to go wrong. Most of your code will end up with the wrong result if it's wrong, while for example in game it's while interracting that the issues happen.
Ok
It's not outdated. But it has so many trivial syntax errors in the example code. &amp;#x200B; The First edition was originally written before C++11 standard was finalized, then blindly updated to use more post C++11 features in the Second edition. &amp;#x200B; In doing so, it overwrite existing example code by hand, without bothered to check it in the compiler. The author confirmed that he didn't write the simple automated test: grep the example code and compile it to see if it pass the compile. &amp;#x200B; Most issues are trivial typo, but there are some interesting issues introduced by blindly replaced the initializer to the new form: T t(...) to T t{...}. One issue introduced because C++14 make the operator bool explicit for iostream. Another by deriving from the std::vector, use macro to replace the vector, just to make its operator \[\] delegates to member function at to bound check the argument.
* Founder of boost (1998) * One of the longest-serving members of the standard committee (1992) * Author of many proposals for the committee (most notably std::filesystem, std::any, thread-safety stuff, shared_ptr; just search for "Dawes" on http://wg21.link/index) * Author of some high-regarded libraries, for example boost.filesystem, that became the basis of std::filesystem (just search for "Dawes" on https://www.boost.org/doc/libs/) * Author of boost.build
How does that make things cleaner? The "before" is much more clear as to what it does.
I was remembering that compilers were not able to generate vectorized code for range-v3 (though this was a year or so ago). So, I ran the both code with gcc and clang (with -O2 and -O3 -march=native). Also I've changed the code a bit, removed iostream and instead counted the prime numbers between 0 and 40M Surprisingly, out of all 8, only one that contain vectorized code was range-v3 with gcc -O3, which is also the slowest. test| g++ -O3 | g++ -O2 | clang -O3 | clang -O2 |-----|-------|-------|---------|--------- original | 13.4 | 13.5 | 12 | 12 range-v3 | 20 | 15 | 12.9 | 13 range-v3: https://godbolt.org/z/2E2llh plain-C++: https://godbolt.org/z/MXLZAO
Set up AWS account, set up S3, write a small driver to map S3 to a virtual drive, install swap file on it. Boom.
If FN is derived directly from a lambda, then the type will be the lambda's type. Hard to make that work, though. You can force it by making a thin class wrapping a lambda as a functor (sized for the capture, using static_assert to guarantee that) and store via that. No type erasure, then. There's a better way, just remind me later since I'm on my phone.
The compiler gave an error based on the **ACTUAL** code present in the example. It was a real compiler compiling the actual code - nothing theoretical about it.
`boost::optional&lt;int&amp;&gt;`
No, avoiding *owning* raw pointers is the holy grail.
yuck.
The target\_sources() command is a much cleaner and more robust option than using variables across multiple directories. [This article](https://crascit.com/2016/01/31/enhanced-source-file-handling-with-target_sources/) dedicated to the topic explains why. The restriction mentioned in that article regarding target\_link\_libraries() is [being removed](https://gitlab.kitware.com/cmake/cmake/merge_requests/2370) in the upcoming CMake 3.13 release too.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
This is fine. You are not allocating anything on the heap, so foo‚Äôs lifetime is the scope of the variable and the memory will be reclaimed automatically. A more detailed answer is that foo will be optimized out because it is marked as const and will be propagated during compile-time. https://en.m.wikipedia.org/wiki/Constant_folding
There are no allocation or reallocation of memory there. In the first sentence you declare the variable as a pointer to a constant char (so you are not allowed to modify the pointed characters using that variable), in the second sentence you assign the pointer to a static array of chars to the declared variable, and in the third you use the var to an operator of ostream that inserts the pointed characters to the cout stream. I'm not sure where is the confusion, but there isn't a memory allocation in the assignment. The string is already statically allocated by the compiler in the data section of the binary.
By the time you start to mention the debug iterator levels, there is no longer a need to have the article. Yes, debug builds (on windows) are much slower, they are slower for a very good reason: **To help you find your bugs, possibly before they even bite!** Sitting though the slower execution is a hell of a lot easier then trying to find some obscure bug, that might not even manifest itself consistently in release (or with the debug level of the iterators set to 0).
Where should i post this? Shoulde i delete?
thank you. i will post my benchmarks realy soon!
His implementation is pretty trivial/naive. You can make faster ring buffers.
for i/o pre processing and for only buffering
I saw another comment that said that the current implementation doesn't pay much attention to the values in the conditions. 
This looks like a pretty na√Øve implementation of a simple ring buffer. I have no doubt this is reasonably fast, but what makes you think it's *ultra* fast?
Debug info and its performance hit don't have to be binary. Different bugs can be solved more effectively with different kinds of debug info. Keep in mind the context here is that the program already runs too slowly in full debug to effectively debug it. That could be like trying to reproduce an issue in a game while it runs at 1-2 fps. If turning off debug iterators gives the fps a significant bump and you were using the iterators properly, then you've just saved yourself from a more nightmarish debugging session.
I guess he means, it is not threadsafe. Funnily enough a fast threadsafe circular buffer would be something to talk about as there exist different implementation tradeoffs.
Why not attempt to be a little more constructive in your criticism and offer actual feedback
Agree. Unfortunately it isn't a threadsafe circular buffer that would be something to talk about as there exist different implementation tradeoffs. I can't imagine a circular buffer that is only used by one thread to be any kind of bottleneck regardless of how it is implemented (well, maybe on microcontrollers if you don't employ the power of 2 trick)
 You can use [this](https://github.com/mhogomchungu/NetworkAccessManager/blob/master/network_access_manager.hpp) thin wrapper library over QNetworkAccessManager to make it easier to do network programming using QNetworkAccessManager API.
Why are there pointers in the vector?
Used blaze, while I was at google, and it's the best build system I've ever seen. Glad to see buck, pants, please.build, and others like it. 
In what way it takes ages? Bazel may pull packages, compilers, rather than uses system ones (not sure what's the case with abseil). There is initial "install", but after that (especially once the bazel server is active), things are fast.
My wish would be if glog, gflags, and many other previously released libs gets int abseil's umbrella. Not sure if that's on the road map though...
IIRC release with debug info is -O2 -g, which is not the same as -Og In fact Og does not include debug symbols if you don't use -g flag.
The game logic doesn‚Äôt do string to anything conversions during the main update logic - that‚Äôs all user input which if it throws the input is ignored and or handled in an error prompt.
This is not completely related to the topic of the mis-optimization, but rather with trigonometric function optimizations. I've seen multiple libraries generating a lookup table to avoid computing sin and cos values for the most common parameters, since they take a while to return a result compared to an access to memory.
I'm not sure what you want me to say. It is literally a textbook ring buffer. It has absolutely no additional functionality, and no performance enhancements. It pushes objects onto the ring buffer while ANDing against the address to return to the start.
Something else you have to keep in mind: I work in game-dev where performance is near ultimate king. The built-in std::stol/stoi weren't sufficient for our use-case so I wrote our own version which calls strtoll/strtoull/strtod/strtof based off overloads where the function accepts only 'const std::string&amp;' and has a boolean parameter where you tell it if you care about errors and if it should throw when it fails or if you just want 0 back on failure. Doing any kind of string conversion operation during the logic update loop would be a red-flag that the person is doing something very, very wrong. Exception issues wouldn't be a large concern at that point.
It feels like when you're directing people how to name their unit tests and where to put different types of tests, I think you're getting unnecessarily bogged down in the details of minor project internals, and not solving the issues of a consistent project structure. In short, people may decide that trying to follow an opt-in project layout standard that's overly-detailed is more trouble than its worth. BTW, what about project documentation? From what I've seen, ```docs``` seems to be a favorite in some existing projects. You mention them, but don't specify any recommended location. Is there a reason for that, or just an oversight? 
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9i7o2d/need_help_with_visual_studio/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
https://youtu.be/cK_kftBNgBc?t=2446 40:47
Performs a deep copy how? You mentioned polymorphism, so how do you deep copy with a base class pointer? There's many ways a flavours in accomplishing that. Which makes it hard to standardize. You shouldn't't conflate "no standard library type" with "nobody uses it". Plenty people use those, but they need ones tailored to their own flavour.
Can't answer without seeing the code. I would also advice you not to learn C++ using a book from 2005. It has changed a lot since then.
That header doesn't seem to be part of VS. Going by the comment in it, it is provided for the book: http://www.stroustrup.com/Programming/std_lib_facilities.h .
Maybe you can use a type-erased object with a 'copyable' property, like with Boost.TypeErasure : [https://www.boost.org/doc/libs/1\_68\_0/doc/html/boost\_typeerasure/basic.html](https://www.boost.org/doc/libs/1_68_0/doc/html/boost_typeerasure/basic.html)
A compiler is free to do it however it wants. Even a series of `if` can be made into a lookup table. Or maybe you can get away with a simple add on the program counter (which may be worse on some architectures, but works well on embedded processors with small pipelines). Sometimes you can simplify even further and "merge" the results of the switch to do one operation instead. For example if you have n cases that just return a different value, maybe you can make it compute the result from the values, avoiding branches completely. Compilers are likely to only do this in trivial cases where you'd return the enum `int` value for example, but it is possible to write rules for that.
The book if i'm not wrong is from 2014(2nd edition).I think its helping me a lot till now but i will see when i go deeper. Thanks a lot :)
Thank dude i'm gonna check it. :)
Thanks a lot! :)
wait i'm confused as fuck right now :S.where should i download this file and do what with it? also this is the full code: #include &lt;iostream&gt; int main() { using namespace std; cout &lt;&lt; "Give name and age " &lt;&lt; endl; string name; int age; cin &gt;&gt; name; (the error is in this line as far as i can tell) cin &gt;&gt; age; cout &lt;&lt; (bla bla bla) system("pause"); }
There's no generic way to do a deep copy (certainly not by copy construction). If you want that you need something like a polymorphic `clone` method, which returns a `unique_ptr&lt;Base&gt;` which you can just use as normal.
You should take a look at [the Reddit formatting guide](https://www.reddit.com/wiki/commenting).
 `cin` is in the `std` namespace. A common way to deal with this, at least in short example programs, is to import the whole namespace to the global one: using namespace std; A better option is using the whole name instead: std::cin &gt;&gt; var_name; std::cout &lt;&lt; "Hi there";
Presumably with a similar mechanism to how shared\_ptr deletes. The smart pointer stores a pointer to a function that does the copy.
Care to summarise? For the sake of people who aren't going to take the time to watch a random video link posted by a stranger.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
That's how I'd do it too if I was going for maximum genericity. But seeing as the OP considered shared_ptr as having too much overhead, I don't think that's the sort of thing they had in mind. 
No-where does OP talk about too much overhead. The post is only concerned about getting the abstraction right. shared\_ptr is rejected because shared ownership is the wrong model, and copy semantics is desired instead.
It takes ages to build. I was building tensorflow (need the c api and the c++ api, not the python) and is honestly slow. Ages = 45 minutes on an intel 7800k with 32GB of ram. Plus, it has a very weird configuration system. Sure, part of it is that I don't know it, but man, i can't just update in there (BUILD file) or everything will fall apart. 
You can use the same mechanism `shared_ptr` does for polymorphic destruction, even for classes without virtual destructors.
Sorry. Maybe I left this one a bit ambiguous. BrangdonJ is correct. My problem is not with shared\_ptr's overhead, but that sometimes copy semantics is what is desired. Regarding the deep copy, you're right that there might be too many ways to do it, which makes it difficult to standardize. I guess that was the answer I was looking for.
For the polymorphic case, this https://github.com/jbcoe/polymorphic_value is proposed for standardization. For the non-polymorphic, no-overhead case, I've personally written a small class called `box&lt;T&gt;`, but that's not yet proposed for standardization https://github.com/ubsan/ublib/tree/master/box
Follow the book. Use std_lib_facilities.h where it is said in the book. From the File: &gt;By Chapter 10, you don't need this file and after Chapter 21, you'll understand it In a real program you will have to `#include &lt;string&gt;` whenever you use std:.string.
Are you trying to do the following: * Have an owning smart pointer * That when copied makes deep copies rather than just copies the pointer? I think the main pitfall is in the making deep copies aspect. * Making deep copies can be cheap or expensive. * There is no easy and generic way to do this. * E.g., what if you have a copyable pointer to std::vector&lt;std::shared\_pointer&lt;T&gt;&gt;? * Something in the deep copy chain might not have a copy constructor.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9i8r65/help_convert_int_to_text/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
`-Og` is not "Release with debug info". That would be `-O3 -g`. Instead, `-Og` means "apply only those optimizations that do not impede debugging". 
Nice! couple of suggestions 1) Change your method names to conform to STL naming convention. 2) With a little change you could make this into a lock-free multi-threaded safe class
&gt;These scenarios led me to think of the following abstraction. Consider a generic pointer template wrapper PtrWrapper that contains a pointer of type "T*". This class would do automatic freeing of "T*" in its dtor, and have a copy ctor/assignment operator declared to make a deep copy of the owning pointer "T*". What puzzles me is that no one ever seems to use this. Is there some pitfall I am missing here? How is this different from a normal object "T"? 
Nice effort! Some suggestions (some were already written, but let's reiterate them): 1. Try to use STL convention for easier reading. 2. Style coherence: You have a \`pop\` and \`clear\`method that is lowercase, while the other follow PascalCase. 3. Your \`PushAll\` method could be rewritten to take in iterators: this would allow a safer implementation (using range-for) and STL-container friendliness. And you would still be able to use a raw array as well (since \`std::begin\` and \`std::end\` works with them). 4. You could give an interface with iterators (i.e. \`begin\`, \`end\` etc. functions). 5. \`uint32\_t\` is available in &lt;cstdint&gt;, you should include it; not all compilators offer it. Also, if I remember properly, a destructor is already \`noexcept(true)\` by default, and \`void\` is not necessary there. In fact, you could totally do \`\~CircularList() = default;\` if you explicitly want to show that your destructor is purposely empty. Rule of thumbs, \`inline\` is most likely useless, since compilers often choose to completely disregard this specifier (someone, correct me if I am wrong on this). If you want to take a look at my implementation (it's still very naive, as well, and different with some respect): [https://github.com/mrtryhard/circular\_list/blob/master/src/circular\_list.hpp](https://github.com/mrtryhard/circular_list/blob/master/src/circular_list.hpp) 
Polymorphism works fine with smart pointers. If you want to see what derived object is actually pointed to, do a `dynamic_cast`. My research code uses this and I am very happy with the solution.
Does this post seriously end with a request to remove the ability to overload and specialize based on constraints? Anyway, the reason we haven't allowed concept template parameters is because it's not very a useful feature. How do you write a template whose expectations are imposed by the user? It's like passing preconditions to a function--except at compile time. Member concepts may show up at some point, but it needs a proposal. Its probably worth noting that it's much easier to write subsumption tests shown in this post. The examples given rely on some pretty subtle language rules that probably won't show up in reasonable code. Anyway, I'll be looking forward to attending this and all the other concepts talks at CppCon. Apologies for spelling and grammar. Written from the tarmac in Cleveland.
Thank you very much :)
I think the branching into these two types would be the best approach for this problem. I see way too often shared\_ptrs being used (abused) due to people's laziness to create their own copy ctors
Frankly, I'd argue that the standard is at fault here - being lazy should result in the correct semantics!
I‚Äôm not saying you‚Äôre right or wrong. I just notice that when it comes to newcomers, the c++ community can come off as needlessly abrasive.
A pointer is a container to a series of elements. Hence #2.
`inline` is not useless here; in fact, it is actually required, since these functions are defined in a header file. However, it's also redundant: member functions defined inside their class definition are implicitly `inline`, no need to add the specifier.
Very useful, I'll update, thanks !
Check this: "value_ptr ‚Äî The Missing C++ Smart-pointer" https://hackernoon.com/value-ptr-the-missing-c-smart-pointer-1f515664153e 
No that's a highly incomplete description, pointers to arrays can absolutely be allocated on the stack
It's worth noting that the Godbolt examples in the article use the most general `&lt;ranges/v3/all.hpp&gt;` header, which includes every single line of code in the library. If you instead use specific headers for just the functionality you need -- e.g. `#include &lt;ranges/v3/view/take_while.hpp&gt;` etc -- then things become somewhat less painful. More generally, there are two factors which combine to make Ranges-using code slow to compile: parsing and template instantiation. As mentioned, if you just `#include` the entire library for convenience, then you end up having to parse tens of thousands of lines of code (most of which you don't need) in every TU. This can be mitigated by a) using more specific headers, as mentioned, or b) using precompiled headers, or both. In the longer term, modules will hopefully offer us better a solution to this problem. The other factor is template instantiation times: Range-V3 uses SFINAE for concept checking, which requires lots and lots of template instantiations. However, in a sense this is a one-time cost: once the compiler knows that, for example, `RandomAccessRange&lt;std::vector&lt;int&gt;&gt;` is `true`, it can memoize this result and shouldn't need to check it again if the same condition is used later in the same TU. This means that making heavy use of Range-V3 in a particular TU needn't be all that much more expensive than just using it once. In future, Concepts may make this more bearable: by making these checks part of the language, there is a potential that the compiler could do things more optimally than is possible with `enable_if` and other techniques today.
\&gt; pointers to arrays can absolutely be allocated on the stack Yes, so? That's what I'm suggesting **not** to do, avoid pointers like this: #include &lt;array&gt; void ptr_func(int* array, std::size_t const size); template&lt;std::size_t SIZE&gt; void ref_func(std::array&lt;int, SIZE&gt; &amp;arr); void foo() { // Do this std::array&lt;int, 5&gt; a = {0}; // a is a reference ref_func(a); // Not this int b[5] = {0}; // b will decay to int* ptr_func(b, 5); // Or if you *MUST* due to an existing C-interface ptr_func(a.data(), a.size()); } This **is** r/cpp
&gt; Consider polymorphism, or the use of forward declared classes. These are cases where the use of owning pointers is required, but we are not necessarily interested in: - sacrificing copy semantics - shared ownership and ref counting like shared_ptr encourages. Well, if you don't want shared ownership, use unique_ptr. There's nothing about polymorphism or forward-declared classes that preclude using unique/shared ptr. All compilers will happily let you create and pass unique/shared of a incomplete type, or a base type. As far as copy semantics, for pointer-to-base cases you'll need to provide the right polymorphic behavior *somewhere*. One possibility (among many): class Base { .... virtual std::unique_ptr&lt;Base&gt; clone(void) const = 0; }; This cannot possibly come from anywhere else.
&gt;These scenarios led me to think of the following abstraction. Consider a generic pointer template wrapper PtrWrapper&lt;T&gt; that contains a pointer of type "T\*". This class would do automatic freeing of "T\*" in its dtor, and have a copy ctor/assignment operator declared to make a deep copy of the owning pointer "T\*". This is built into unique\_ptr already. auto copy = *derived_ptr; Now allow me to explain. &gt;Consider polymorphism. One of the principle ideals in library API design is to make questionable things difficult to write, and correct things simple to write. If we are ignoring polymorphism, this is a very easy API to take an owned pointer and get a copy of the pointee. If we want to make a Base, though, we now have to deal with [slicing](https://stackoverflow.com/questions/274626/what-is-object-slicing) concerns. Just using the dereference operator and the underlying type's copy ctor makes the callsite now look like this: Base copy = *derived_ptr; It looks a little weird, and so will call out the reader's attention that something weird is happening. That's a good API. &gt;forward declared types You can't copy an incomplete type anyways. Perhaps I'm misunderstanding you
But value-semantics and reference-semantics are both equally valid. Neither is 'correct' . . . 
unique_ptr and shared_ptr are both value-semantic pointers, though?
Both have reference semantics. 
I watched and think it is related to the question at hand. Essentially digs into someone proposing a way to create copy or clone pointers and he describes very well the thought process around how to handle that. 
I never saw one. Buy a good book.
That's not what that word means.
&gt; With reference semantics, assignment is a pointer-copy (i.e., a reference). Value (or ‚Äúcopy‚Äù) semantics mean assignment copies the value, not just the pointer. C++ gives you the choice: use the assignment operator to copy the value (copy/value semantics), or use a pointer-copy to copy a pointer (reference semantics). Reference and Value Semantics, C++ FAQ - ISOCPP.org https://isocpp.org/wiki/faq/value-vs-ref-semantics std::shared_ptr&lt;T&gt; t1 = std::make_shared&lt;T&gt;(...); std::shared_ptr&lt;T&gt; t2 = t1; // Assignment does not copy the T 
It's on the heap and the size of a pointer. This is useful for pimpl, as well as shrinking the size of the object you're working on (i.e., you should put stuff like metadata that's uncommonly accessed behind a pointer)
Silly note, I don't really recommend because macro: &gt; there doesn‚Äôt seem to be a way to specify the type T as a string. #define PRINT(x) #x static_assert(fulfills_rule_of_5&lt;the_mighty_potato&gt;(), PRINT(the_might_potato) ": must fulfill rule of 5"); And some addition macro magic for FULFILLS_RULE_OF_5(the_mighty_potato) and you're golden
Exactly. Or a reference to `T`. And if you absolutely need the object to live on the heap for some reason, do `Foo &amp; fooref = *new Foo`.
I went into this with the expectation of more crappy blog spam, but I was pleasantly surprised. This is an idea I hadn't thought of, but I can immediately see its value and I think this idea should eventually find it's way into the standard.
Yes, made a bit better with Concepts, but is covered by **#3.** Example: **Streamable.h &lt;Interface&gt;** #pragma once #include &lt;memory&gt; #include &lt;iostream&gt; // This will be our ForwardDeclaration for the implementation used by the PIMPL struct StreamableImpl { virtual std::ostream&amp; streamTo(std::ostream&amp; strm) const = 0; }; class Streamable { public: Streamable(std::unique_ptr&lt;StreamableImpl&gt;&amp;&amp; impl) : _impl(std::move(impl)) { } friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Streamable const&amp; s); private: std::unique_ptr&lt;StreamableImpl&gt; const _impl; }; inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; strm, Streamable const&amp; s) { return s._impl-&gt;streamTo(strm);} **Library.h** #pragma once #include "Streamable.h" extern void foo(Streamable&amp; instance); **Library.cpp &lt;Calling Code&gt;** #include "Library.h" void foo(Streamable&amp; instance) { std::cout &lt;&lt; instance &lt;&lt; std::endl; } **main.cpp &lt;Implementation&gt;** #include "Library.h" struct MyStreamable : public StreamableImpl { MyStreamable(std::string const&amp; mesg) : msg(mesg) {} std::ostream&amp; streamTo(std::ostream&amp; strm) const override { return strm &lt;&lt; "My size: " &lt;&lt; msg.size() &lt;&lt; std::endl; } private: std::string const msg; }; int main() { Streamable s (std::make_unique&lt;MyStreamable&gt;("Hello, World!")); foo(s); } Here I've defined a library with an interface that takes a *Streamable* by reference without having to see the implementation code: $ g++ -dynamic -c -std=c++14 -o library.o Library.cpp # Calling code HERE, can be shared as lib $ g++ -dynamic -std=c++14 -o test main.cpp library.o $ ./test My size: 13 The point was that you really really **can** get away from using pointers, especially RAW ones, outside the 3 exceptions. This is not a **#4**
Thank you for the kind words. I do my best to keep it fresh :)
Reference-to-base-class is a usable idiom, but isn't always applicable if you have polymorphic objects with longer lifetimes. It's also a bit less transparent than I'd prefer. Experienced cpp folks will know that you never own a reference that you're passed, but writing `std::observer_ptr&lt;T&gt;` makes that even more explicit rather than implicit.
Agreed, I like this a lot. I've done something similar using static_assert to ensure that the memory layout of some structures was exactly what I expected, no hidden padding etc. And this holds across different compilers and versions. 
&gt; Its probably worth noting that it's much easier to write subsumption tests shown in this post. The examples given rely on some pretty subtle language rules that probably won't show up in reasonable code. Could you explain a bit more about this? The entire post is predicated on the idea that it's *impossible* to write a "Subsumes&lt;X,Y&gt;" metafunction in current C++ and so the author has to resort to stupid macro hacks like `DEFINE_SUBSUMES(...)`. If it's actually "easy to write subsumption tests" then the whole post falls down, right? How would you write a subsumption test today?
Yeah, I misread it. Sorry. 
I like the idea of defensive programming, but I think the author either misunderstands the rule of 3/5, because these asserts don't seem to check that. The rule of 3/5 is that if you implement one of the set of 3/5 things, you should implement all of them. The static asserts only check that all 3/5 things _exist_ - but this includes compiler generated versions! That's the whole point of the rule: that once you start implementing some of these special methods, using a default version for any of them is likely to be inappropriate. Here's a [simple example](https://godbolt.org/z/siu_wZ) - a badly implemented "smart pointer" that deletes the help pointer in a destructor. The problem is that we haven't done the "right thing" in implementing or deleting move/copy constructors/assignment operators, so it breaks if you copy the pointer in any way: a rule of 5 violation. The static assert has no problem with this class though! In fact if you try to fix the problem, say by deleting the copy/move constructors, _then_ it starts to complain. 
I am aware of this issue. The current design might have misleading names I guess. I am not so much interested in what your constructors do, only that they are present. Using the presented technique, you can composite your own rules that check triviality vs. non-trivial. It does get pretty crazy though.
Yeah I agree they are better than many alternatives. For most cases the difference between `unique_ptr` and raw pointer won't be worth the loss of safety, so I'm definitely not recommending that you prefer vectors of raw pointers in general. My original comment was probably a bit flippant in that respect. My main point is that "zero overhead" things like unique_pointer, and more importantly the whole class of not-trivially-copyable objects, don't have zero overhead in vector, for some operations. As far as iterating goes, I expect raw and `unique_ptr` to be equivalent. clang and gcc [seem to agree](https://godbolt.org/z/upEwnF).
I would be nice to see another post which went into these _exceptionally compelling_ arguments in some detail. Then we'd kind of have a feel for why this approach was chosen. I'm not surprised you didn't get many written responses in favor of separate directories. That's just the "obvious" and overwhelming obvious way of doing things. In the same way many types of directory organization are simply obvious, such as separate directories for documentation, submodules, output files, whatever. If I was filling out that survey I wouldn't feel the need to support that choice. On the other hand, proponents of an "underdog" approach, like this naming scheme are likely to have arguments ready and are more likely to make them. The most compelling and simple arguments, in opinion are two, one technical, one not: 1) As above, you are already proposing separate directories for some types of tests, but not for others. So anyone who wants to do anything with a pitchfork style project will always need support both mechanisms. Any type you want to treat test and production code differently (build, deployment, commit &amp; review, automated whatever, the list goes one), you'll need to ensure you handle both directory-based segregation and filename-based-schemes. I suspect that the naming scheme approach will often be harder (since all your tools will need to effectively support wildcard-based matching) - but even assume these are "equal but different" you end up doing it twice in the proposed scheme. The whole idea of different schemes is a smell to me: sure you want to draw a bright line between unit tests and everything else, and they are different, but the line isn't as bright as you might think in many code bases and there are many shared components. 2) The overwhelming desire for the separate tests directory is in itself a very important reason, even if you don't consider it a "technical" one. It's not exactly a poll of existing practice: it's a poll of what people think is the best (that's what you asked). If you're like me, you've used various systems over the years and actually have a good grasp what what works the best. So that's what you answer on the survey. It's not just 200 idiots blindly hitting the "tests directory" button because that's what they are doing today, 20 clever people with the freedom to do it the right way. I understand the urge to evaluate all of the options "in a vacuum", independent of current practice, and if Pitchfork didn't rely on a "network effect" this wouldn't a good argument. If you're figuring out the best way to implement some private library, or how to build a bike-shed on your own property or whatever: just do it the way you think is best, regardless of conventional wisdom. However, Pitchfork is nothing like that: it lives or dies based on the network effect: it works if many or most projects use this layout and then everyone can take advantage of the reduced mental burden of understanding a dozen different layouts, and tools can be written with good defaults and so on. If Pitchfork only wins over a small part of the community that already bought into "radical" ideas like the test naming, it won't be very useful. It won't establish a convention. So at every point I think you should balance the cleverness of your decisions with a strong bias against "unique" or "clever" things that deviate from existing practice, because you're just setting up an uphill climb. If there are cases where you choose another path: save them for the places this matters and I can't imagine this is one. Or save them for later, after Pitchfork already has adoption (embrace, extend, ... :)).
That was a great article and an idea I hadn't thought of! Thankyou for sharing!
Member concept + concept template parameter anyone?
I would argue this is why the ideas presented here should find their way into the standard. It would be an excellent way for controlling the sheer complexity of C++ while adding discoverability to both the code and the new C++ users. Imagine if your IDE could indicate to you that a class wasn't movable while you were typing out code that used said class. In fact, I think this idea could be generalized and allow for more compiler introspection that could be used by various tools, including those that look for potential problems and performance issues. I think if this idea found its way into the standard, we would ultimately have better tools and better codebases. I really like the idea in general, even if the current implementation isn't the best.
Yes, then I think the names are confusing. The thing is, checking that this stuff "exists" isn't that necessary in most cases since if it doesn't, you get a compiler error? I guess your point is that the error message you get from your checks is much nice that what you'd get 10 layers deep into some `std::vector` instantiation. I do think that _actual_ checks of the rule of 5 would be more compelling and make a good follow up, yeah.
There is some intersection with concepts, which also tries to group things that model different ideas in a simple way so you get nice errors up-front. I agree that anything that can be made to reduce the number of foot-guns is a good thing.
!removehelp
That‚Äôs all that needs to be said :/
This is like something that Matt Wilson (of 'Imperfect C++') would have done, years ago. Wish he'd keep writing, but he's probably a mountain-biking millionaire now ... 
This circular ring is not thread safe. You have to external lock when accessing data from different threads
I think he means it doesn't have /built-in/ locking, like say for a producer and consumer thread. 
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9iccc0/clarification_about_constructors_with_one/e6ik71g/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I don't think any compiler completely disregards `inline`, but it is only (a small) factor influencing the compiler's in lining decision and unless you have measurements to back it up, I'd also rather trust the compiler's heuristic (when inline isn't required by the language).
Although, once dynamic excepts have been phased out of use, I could easily see them being removed outright and `noexcept` being made the implicit default which would simplify a lot.
I agree, I should have picked better names (like generated_5_ctors for example). In many cases you get a compile error deep in a container. In others you don't get a compiler error at all. You can imagine a scenario where a move constructor isn't generated anymore, but the copy constructor still is, so your types are getting copied in places they didn't used to. Or the "fast vector" example with trivially_copy_constructible. I've started prototyping a more "true to form" implementation. Thx for the feedback.
Why it is published only now? I had 15.8.5 already, and 15.8 was released LONG time ago
If you want a one-liner, you'll need a macro. The overloads aren't hard to construct. Just a handful of constexpr functions that return something that can be tested for order, like ints. Or you could get clever and return a category class, like iterator categories. Could be neat.
Yes.
How?
If you use iostream, you can do error checking to see if the conversion is successful.
I really like KDevelop. Nothing beats it's highlighting and integration with CMake. I recently had done problem with it (due to a crash in clang) but otherwise it's a great ide. I also tried QtCreator, which also have a great integration with CMake and it's recent integration with clang makes it even better (but suffers from the same clang crash). That said, I've been told that as a power user, a good vim setup with the right plugins is hard to beat.
Vim is a command line based text editor. It is known for being beginner unfriendly, but really powerful when mastered. I'm personally okay with graphical based IDE.
Thank you very much 
you can enable vi-keybindings in both qt creator and kdevelop to get a taste of it
+1 Clion. 
I think the intent is to generate more fine grained error messages. Otherwise you only know that at least one of the traits is missing. 
Adjacent string literals are always concatenated, I believe at least since C. That's not a feature of static assert. 
Clion. Vim integration superb as well. 
Atom, afaik, isn't an ide, it's just a very nice text editor with more tools Try codeblocks or Eclipse, I'm loving em
Correct, atom can be converted into an IDE but all of my compiling is done through the terminal 
Can't go wrong with either KDevelop or QtCreator. Both are fantastic cross-platform editors with all the fixings you might want. I'd say KDevelop is a bit more of a smooth experience outside of the QT space, though.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
You might want to try the lightweight C++ IDE [juCi++](https://gitlab.com/cppit/jucipp). It is also one of the few IDE's that is written in newer C++.
VS Code is fantastic. 
But why return the value then?
After some Slack discussion I'm leaning towards making the test location optional but recommended. Can't deal with _all_ of the minutiae. The missing `docs/` directory is an oversight. It will be included.
I'm curious what about the namespace is a problem?
Abseil Dev here. They're coming in a moderate amount of time. They won't be clean copies of the currently open source versions of gflags and glog, since they've diverged a lot from the internal versions.
I agree, printing null is better. 
Another agreement here. I'm going to try this out in a helper library of mine. I will say that you shouldn't be ashamed of using the preprocessor like you have. I don't personally agree with the modern method of teaching that avoids one of most powerful features available to C/C++ programmers.
VS Code has native integrated terminal. Atom can have it via a plugin afaik.
&gt; But the point is that you cannot at the same time have an API that offers a "nativeWindow()" method which always gives you a pointer to a NSView or something like this for every widget and a threaded GL scene graph with given performance guarantees. Yes you can. If you run your app over open GL, don't expedt nativeWindow() to return a specific NSView for your widget. It can either return the top level one or return NULL. If you want to play with NSView, then don't use the open GL back end. 
I used to use Clion. It is good but it is not free for commercial and the licensing is yearly basis. Move to Qt Creator. Its free with decent tools and finctionalities.
Hey man you might want to give Emacs a try. It has a steep learning curve, but it's something worth mastering. By that I mean you will be much more productive and will learn a lot more. Also vim is a good substitute, but Emacs is in my heart. There are a lot of tutorials all over the internet how to integrate Emacs with cmake and many other things to make your life easy. Happy hacking!
I would recommend trying VSCode with cquery or ccls
My recommendation - CLion. Its paid but if you are investing a lot of time developing in C++ on Linux then its worth it.
Using global anonymous lambdas doesn't seem to work with either clang or g++ ``` []() { static_assert(std::is_default_constructible_v&lt;Foo&gt;, "T : must be default constructible"); }; foo.cpp:13:4: error: expected unqualified-id []() { ^ 1 error generated. ```
I used NetBeans and Eclipse. There's also Cevelop, build on eclipse (https://cevelop.com/)
For C++ look hard at Qt Creator (and I say that as a VS Code fanboy for non-C++ work). It‚Äôs very subjective, though. VS Code, CLion, Qt Creator, Emacs ... try them all, pick the one that feels comfortable.
qtcreator
emacs does everything I need in an programming editor.
If you are looking for the best out-of-the-box experience, without any configuration necessary: CLion. If you are willing to google a bit and install a couple of plugins and edit 1-2 config settings, then VSCode is a really good option too.
I've tried a few VS Code versions in the last couple of years and never managed to get the C++ plugins working, always had some issues with code navigation or bogus compile errors. 
cquery, a language server for C++ offers advanced IDE functionality to any editor that speaks its protocol. Many editors have plugins for it: emacs, VSCode, vim... I use kakoune myself.
Would be cool to make it work with vectors as well. Also, can somebody explain why this like gives me `temporary was destroyed at the end of the full expression`? `array&lt;int*, 1&gt; v { nullptr };`
Fellow KDevelop user. Both at home for Python and at work for C++. Unfortunately clang seems to crash on our source files in any version above 5.2.0 for some reason (but only when running the appimage). I really want to upgrade though.
Nothing could beat Clion now. Otherwise invest your time in learning Emacs - be warned it is a life-long investment.
Its not IDE though
I also use atom/terminal. What's missing from it?
checkout ccls too. Which is a fork of cquery which makes use of C++17 features, has less third-party dependencies and slimmed-down code base.
I‚Äôve done this for a lot of projects, but not as a macro and certainly not under the intention to guard against future me. I like this perspective, and I think I might adopt the idea. It‚Äôs funny how drastically paradigms shift by just using a different description like, ‚ÄòDefensive Programming.‚Äô I love it.
Yeah, I would suggest rephrasing the top-level message, like "**thus** T does not follow the rule of 5"
Note that one thing from the [readme](https://github.com/electronicarts/EASTL/blob/master/doc/Bonus/tuple_vector_readme.md#the-problem-of-referencing-tuple-elements) I would like to highlight as a major painpoint with using this, and may be the biggest drag about it, is the limitation around referencing specific elements of tuple or tuple\_vector. Because the declaration of a class with variadic templates is only a list of typenames, one either has to refer to a given element by its index, which is brittle and prone to error, or a typename, which may be difficult to work with. Ideally, it'd be possible for some symbol to be attached to each type in the declaration of a tuple or tuple\_vector to aid with lookups, and I cannot help wonder what it would look like (or how practical it would be) if C++ could support such a setup.
&gt; These scenarios led me to think of the following abstraction. Consider a generic pointer template wrapper PtrWrapper&lt;T&gt; that contains a pointer of type "T*". This class would do automatic freeing of "T*" in its dtor, and have a copy ctor/assignment operator declared to make a deep copy of the owning pointer "T*". What puzzles me is that no one ever seems to use this. **Is there some pitfall I am missing here?** Yes - at such scenario you should use just `T`.
MSVC has supported a property extension in c++ for the longest time which I've used before to try to provide a similar structure with minimal semantic overhead; I've always wondered why there did not seem to be more of a push for something like this within the standard using attributes for example. Regardless this is an interesting class and I always enjoy checking out eastl. Thanks for the informative post!
In case you're interested, I've created a standalone version of a `format` function that uses a different approach, and takes python-style format strings.
&gt;performance Did you compare it with other libraries?
First off, thanks for this, I was totally unaware of those **is..** functions. I need to read a bit more on that. In one block you have this: #define FEA_TRIVIALLY_DEFAULT_CONSTRUCTIBLE(t) \ []() { \ static_assert(std::is_trivially_default_constructible_v&lt;t&gt;, \ #t " : must be trivially default constructible"); \ return std::std::is_trivially_default_constructible_v&lt;t&gt;; \ } is that double namespaceing of **std::std::is_trivially_default_constructible** valid?
... only if you remove the more granular one instead of the less granular one. Don't do that? 
Interesting. I've recently had to write something a bit similar to this myself: given a list of template type, create a tuple of arrays (or vectors) for each type. Though my implementation was restricted in a way that you couldn't have the same type two or more times.
eclipse is very nice imo.
We'll see with clang 7.0.0 how things goes. I reported the bug but if it's in clang, it's harder to fix and updates are show. Also, it's good to know which appimage works, thanks.
&gt; Since `static_asserts` need a string literal error message No, they don't really need, even in C++11: `static_assert(condition, "")`. The condition code itself is very often enough. I'm allergic to macros but writing `static_assert(fulfills_rule_of_5&lt;the_mighty_potato&gt;(),"");` is ok for me.
I see. So, I think the easiest way out may be a bit of preprocessor work like your "SOA\_DEFINE\_TYPE" macro to generate some part of (something like...) this automatically: struct entityX { float val; }; struct entityY { float val; }; struct entityZ { float val; }; struct entityLifetime { float val; }; tuple_vector&lt;entityX, entityY, entityZ, entityLifetime&gt; entityVec; And that may be a bit of a way out. &amp;#x200B; The closest other alternative was to create an extension to tuple that would allow for pairs of types and string literals (which would get converted to a hash value), but I ran into some problems with it and the style of code was getting a bit wordy. I may revisit it someday, but this is roughly what I was working with: tuple_named_vector&lt; tuple_named_tag&lt;bool, "isActive"_tn&gt;, tuple_named_tag&lt;LargeData, "payload"_tn&gt;, tuple_named_tag&lt;int, "lifetime"_tn&gt; &gt; tripleElementVec; ...and tripleElementVec would return a specialization of tuple that would allow for element index via, e.g.: get&lt;"isActive"_tn&gt;(someTup); 
any links to this. i just started warching his cpp2017 features videos. on cppcons youtube channel
I have two setup. One with the arch package and another with their git master, both are crashing. You might have an older clang on your distro?
I mostly work with legacy code, but so far it is doing well, recognizing lambdas etc. Sometimes coloring is broken for a while on a heavy-templated code i.e. using boost::msm. To format the code I'm using clang-format anyway, but build-in formatter works just fine. Hints about unused functions etc are not always accurate but extremely useful anyway. In general just give it a try, it greatly improved my productivity working with the C++ code.
[Here](https://codereview.stackexchange.com/questions/54371/polymorphic-owned-reference-wrapper-for-class-hierarchies) is my own implementation. Particulars: - a generic `polymorphic_clone` function is provided, which respects polymorphic type - the clone function selection is done in the `to_polymorphic` functions 
Yep, I think the string literal is the best we can have without macro or static reflection.
Yes it is (fortunately). 
I use Clion because I have an open source jetbrains license and I'm used to intellij and pycharm
Do you have any benchmarks? Any proof of your claims? Otherwise why would anyone switch to yours.
I followed https://embeddedartistry.com/blog/2017/2/20/installing-clangllvm-on-osx except for the things with the LDFLAGS and CPPFLAGS and it seems to work.
As I said above, I will post benchmarks shortly. Also, I am not asking for anybody to \`switch to mine\`. I am asking for your constructive criticism of the library.
Well, they're called special member functions. Something like `FEA_HAS_ALL_SPECIAL_MEMBER_FUNCTIONS` could be an appropriate name. For checking all sans default constructor, `FEA_HAS_FIVE_SPECIAL_MEMBER_FUNCTIONS` might work.
I'm not sure what you mean, you're entirely in control of the buttons and panels shown at any given time.
If you are using cmake, ive found vscode to actually be an excellent c++ ide on linux
Yeah, it is possible to configure it to not be as bad, but by default it has a ton of stuff going on in the GUI that is at best marginally useful. The top menu is also a bit confusing, with what basically feels like 3 separate application menus present at the same time. The fact that it pulls in whatever you have for the main toolbar in Kate into the main toolbar in a confusing way doesn't help either. It makes a great deal of sense to have a "New" button in kate, but that in no way means I want one in my IDE.
Thx! Looking forward to watching that :)
&gt; I need to read a bit more on that. They are really powerful and definitely worth reading up on! It makes template metaprogramming a whole lot easier, and the \_v variants we got recently are just a little extra pleasant \^\^
I do a lot of AVR work in C++, including pushing modern features to try to improve performance. Know what'll *really* help? Bring ISO 18037 into C++. The lack of it is *incredibly* painful.
Ooops, thats a typo. Will fix. Ty!
These extensions (cpp extension, clangd, cquery) became much better in the past half-year, especially if you have compile_commands.json
Note the lambdas are declared inline in the macros. That's a trick used to make it all work :) They aren't "global lambdas", they are written and executed right there. For example : static_asssert([](){ return false; }(), ""); &amp;#x200B;
You don't care if a class is movable until you need to move it. What is dangerous is silent fallback from move to copy when class is changed down the road. I find that enabling depreciation warnings and treating them as errors is the simplest and mosy elegant cure. It will stay out of your way untill you really have an issue. Requiring correct rule of five adherence up front is premature optimization. This rely on the fact that generating the copy special member functions is deprecated when other special member functions are provided. That was a good decision and I hope more is deprecated in the language even if there is no hope of removing it completely. Then, I can use depreciation as an optin to move code base forward while the language stays backwards compatible. 
Never heard about it, and will check it out today! Seems much more active then cquery.
&gt; ISO 18037 https://en.wikichip.org/wiki/c/embedded
The compiler knows the whole of the std namespace. 
CppCon 2018, first keynote. 
C++ is excellent for embedded. Dealing with legacy C codebases is painful as hell. Waiting for https://wg21.link/P1105R0 to take wind though. And no, heap allocator failure or OOM should not ever trigger undefined behaviour, exit or crash. 
Yes, and it also has slightly more features. Checkout the wiki page I use it with emacs and it works damn well
Ah, of course, thanks for the explanation! It was quite obvious, but my macro-fu has obviously weakened lately :) I _used_ the macro in global scope, right after the struct definition (replaced a static_assert with one of your macros). The change I mentioned above allows this, but it requires a compiler with `__COUNTER__` support to pseudo-unique name for the lambda. 
C++ and the committee tend to focus on generic solutions rather than one-off fixes, even if that takes many years longer to realize. :) The current thinking is that static reflection and accompanying reification/synthesisfeatures will allow us to do all this (and more) in library code. With Herb's meta-classes (post the pending committee feedback) it might just look like: ``` // specify the list of fields we want in our vector struct physics_fields { vec2 position; vec2 velocity; float mass; }; // today's trivial array-of-structures using physics_aos_vector = std::vector&lt;physics_fields&gt;; physics_aos_vector[0].position += physics_aos_vector[1].velocity* delta_time; // tomorrow's hypothetical trivial structure-of-arrays using physics_soa_vector = soa::vector&lt;physics_fields&gt;; physics_soa_vector.position[0] += physics_soa_vector.velocity[1] * delta_time; ``` (and heck, you could in theory make the usage APIs identical by returning a thin `soa::tuple_reference_proxy` type from the `operator[]` call and dereference there, which is what I'd done in the version of `tuple_vector` I wrote some years ago) No extensions and nothing specific to SoA, though it'll obviously rely on a ton of machinery. My only real qualm with that approach vs the SoA language feature is that the reflection approach requires the compiler to essentially interpret a DSL (a template) for each type, for each TU. 
I'm surprised this is not titled "High Order Fun"
Or "High Order Func++" (pronounced "funk")
Ben Saks will be talking about that paper at the SG14 at CppCon this week, so hopefully there's further good reception there.
The code is what you are doing. It is not (in general) the same as what you are trying to do.
I am definitely curious to see how or if the proposed metaprogramming stuff (which I have been way out of the loop on, and need to check up on again) would affect any of how tuple's or tuple_vector's could be interfaced with. If, in the example of tuple, it would allow for structs to be anonymized but still have each element referenced, it would be directly applicable and useful to tuple_vector as well. The current rev is still strictly cpp14 (e.g. fold expressions were not used internally) but a rev of it down the road for a Cpp2x with richer metaprogramming would be useful very quickly, I'm sure.
&gt;I keep thinking -fno-heap would be excellent compiler flag, it would disable every other form of new except placement new, and anything with an allocator signature. Can't you basically achieve that with \`-Wl,--wrap=malloc\` ?
Yeah, i do similar things including overloading all global new/delete forms, but that does link-time errors. It would be much more useful to get it at compile-time.
CLion was going to be my recommendation. It has native integration with CMake which it uses for it's code completion. I've only made small networking projects using it but JetBrains git features are a godsend for simplifying the VCS model. It's worth noting I also use a Vim plugin on CLion/PyCharm/IntelliJ which is absolutely fantastic.
I'm not sure about the internals, but how much does the compiler actually understand about stack versus heap? Apart from the new and delete keywords, from the compiler's perspective isn't malloc etc just another function returning a pointer?
I have about 10 kb RAM in my system; don't think I can even run a compiled C++ hello world program...
I really love VSCode. I've been using it from the beginning and the tooling has become so much better. The CMake plugin (props to /u/vector-of-bool) has really matured and from my point of view covers most use cases. cpptools plugin was a little hard to configure in the beginning, but now works very well and integrates nicely with the CMake plugin. Sometimes I have some performance issues with intellisense though (but that's on my VM). Works even nice with SCL environments on RedHat/CentOS.
You should try CMake plugin.
Not with iostreams but probably with any other output library. As he says in the video (and has said before) you only pay for what you use
The separation between library and language is a lie. It's an extremely useful, generally pragmatic, no-malice-intended lie, but it's still a lie. Your toolchain is allowed to provide an implementation of malloc or memcpy, or any C++ function however it chooses. Most do so by having an external set of headers and libraries. However, the compiler is allowed to assume the behavior of those functions though, and optimize assuming that they follow standard behaviors. This allows them to do things like heap elision, or by inlining calls to malloc that you might think are trapped in the C runtime.
&gt; Bjarne: Why don't we have a flat map ? Why are there no standard pools ? Stack allocators ? Are you kidding me? I myself worked for a while on the initial proposals for `flat_map` which went to LEWG and put it aside as [Zach's proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0429r2.pdf) had more consensus and a more complete specification.
That makes sense, thanks for the info. I guess in that context having a compiler flag to disable heap usage could make sense
Last year, they got the keynote and a few other videos up literally the next day, but the majority of the talks came out gradually over the next month.
Beman also took part in a few of the recent 'grill the Commitee' videos recorded at cppcon if memory serves.
This. 
First, I appreciate your comments. 1) Re/ \`power()\`; I have two versions. You can either pass your result to it or it raises the current object to the power. Probably returning the result is worth adding as you suggested. \`is\_diag\` is for optimization purpose, since it is much easier to compute. I do not want to keep states (is diagonal, etc.) , as it is bug prone and could go out of sync. 2) Re \`svd\` and others being complicated; I should add more comments. 3) Re/ one-dimensional vector; Yes, I am using the one-dimensional vector. I also allow the user to pre-reserve the size. I was aware of the pitfalls you mentioned. My thoughts were that in most cases the user knows what the ultimate size is and therefore a 1d-vector is the best compromise. 4) Re/ masks and slices; It is noted. I will make that my next enhancement. 5) Re/ Transpose; It is O(1). It calls the operator \`\~\`. I didn‚Äôt want to implement it in two places. &amp;#x200B;
What system is that?
What about Rust?
Any number of Cortex-M0 micros from ST Micro, NXP, Cypress, Infineon etc. would fit this description. 
Looks like all the NDC Techtown talks are starting to show up. Yay!
Pointers have value semantics in that the value of the pointer is basically the address. Just like the value of an int is the number. So when you copy a pointer, you copy that number/address. Pointers are used to build reference semantics, but have, on their own, value semantics.
&gt; Requiring correct rule of five adherence up front is premature optimization. when everything becomes "premature optimization", the word loses all meaning. It's not any more of a premature optimization than any of the other various techniques people use to ensure correctness both now, and down the road. you could use your very own logic to argue that you don't need git until you need it, so why use it? it's a stupid thought.
ie google type-erasure. 
You are correct. I don't install git before I am going to use it, and I don't implement functions before I need to call them. I don't find that stupid, but using that word usually is.
\+1 Investment in your tools multiplies productivity.
Emacs supports mice just fine, and is ready out of the box? Only change I've ever made from the defaults are a keybinding to run the current buffer through clang-format.
[removed]
Your comment has been automatically removed because it appears to contain disrespectful profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9i94zg/easy_defensive_programming/e6kn45i/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
The last time I tried to set up VSCode for C++, it required a ton of manual configuration per project. Has this stage been improved?
What sort of cmake integration does it have? 
If lookup by type is indeed supported, then using this with a list of [strong typedefs](https://github.com/foonathan/type_safe) could help alleviate this issue, essentially solving two problems at once. It would be a bit verbose, as you pointed it out below, but at least the price would be split among multiple benefits - but I also can't see how your example is so much more wordy than a regular structure corresponding to the same data members..
&gt; I don't install git before I am going to use it, I'm going to repeat what I said with emphasis. &gt; you could use your very own logic to argue that you don't need git until you **need** it, Not use... need. stop being dishonest. If you want to respond to me, do it honestly. You'll feel better about yourself, and you will have possibly earned some respect.
As soon as I saw the title, I knew it had to do with threads. As to why stuff like this is a bad idea in general, I can't do better than point to Herb Sutter's [atomic weapons talk[(https://www.youtube.com/watch?v=A8eCGOqgvH4)
I'm just impressed that you named all your software after a kebab. That's dedication.
Well... The parsing is done correctly using the compilation database, there's also a full configuration and cache editor, and the whole project configuration is done through it.
&gt; 18037 Regarding the memory mapped IO, have you ever considered something like [cppreg](https://github.com/sendyne/cppreg)? It provides genuinely zero overhead (checked via identical assembly compared to old C style) memory mapped IO accesses while ensuring read/write only access to them (checked via compile time).
You can make a PONG game that runs on the Commodore 64 using C++17 like [this](https://www.youtube.com/watch?v=zBkNBP00wJE) which has only 1 Mhz worth for the CPU and 64 kB of RAM.
It seems that getting gcc on some systems(avr) does not include any of the std lib, including type_traits. type_traits is amazing for implementing most other things. 
I love KDevelop with its great array of plugins to help with productivity and catching bugs early on. One problem I have with it is the dark theme isn't the best and that there aren't a lot to pick from. It's low priority issue but I hope it gets fixed eventually.
What if you have your T forwarded declared or you intend to use polymorphism? Just T does not solve that
What do you mean the dark theme is not the best? I'm working using the dark theme for years! Here's a [screenshot of my dark setup](https://i.imgur.com/U8aKc14.png) I only selected the breeze dark scheme in the color theme, and tweaked a bit the color schema of the editor.
Presumably Bjarne is saying we should get this into the standard ASAP.
&gt; full configuration and cache editor Full configuration editor? What do you mean by that?
&gt; I don't install git before I am going to use it, I'm going to repeat what I said with emphasis. &gt; you could use your very own logic to argue that you don't need git until you **need** it, Not use... need. stop being dishonest. If you want to respond to me, do it honestly. You'll feel better about yourself, and you will have possibly earned some respect.
Invalid question, the loop was always infinite in the first place. 
You can edit/add configuration variables for CMake cache with a GUI
Reading from one thread and writing from another without synchronisation is undefined behavior. The compiler is allowed to assume undefined behavior does not occur, and detects that there is no way the condition can change whithout undefined behavior being invoked en therefore optimizes by simply not checking the condition.
Doesn't it run on Wine anyway?
The program was malformed, so any statement about the loop is meaningless.
I'd like address space support primarily. The rest can be pretty easily implemented in C++, address spaces cannot. You can mimic them a bit using templates, but you cannot do it fully without an actual modifier.
my problem with emacs is that you can program it. "I'll automate this with just a bit of this elisp". A week later I get back to what I was working on :) &amp;#x200B; fwiw, I've been using it since the 80s. It's very useful and flexible.
If you're doing to do this you might as well simply call `fulfills_rule_of_5&lt;the_mighty_potato&gt;()` I'd probably make new type traits over a `constexpr` function since it would have more compatibility with older C++ as well and you might use them in other places as well.
Considering there is no overhead on the deleter if you put an empty deleter class for the template argument, there's no reason the copy function can't do the same. So you'd still have the same size as a pointer.
It's a good article, I'd be happy if this pointer made it to the standard. However, the implementation is not exception safe here: struct default_clone { default_clone() = default; T *operator()(T const &amp;x) const { return new T(x); } T *operator()(T &amp;&amp;x) const { return new T(std::move(x)); } }; There is no guarantee that the constructor doesn't throw, and if it does a memory leaks appears. The interface itself for this class is inefficient, using `unique_ptr` and `make_unique` makes it safe and adds no overhead. It does argument forwarding too, so you only need one constructor. There are probably some other issues. The idea is sound, but the implementation is not standard-ready.
A shared_ptr doesn't take a deleter as template argument. It's stored in the control block, with a sprinkle of type erasure to boot.
You might want to check the [standard](https://en.cppreference.com/w/cpp/memory/unique_ptr) then. `template&lt; class T, class Deleter = std::default_delete&lt;T&gt;&gt; class unique_ptr;` &gt; Deleter must be FunctionObject or lvalue reference to a FunctionObject or lvalue reference to function, callable with an argument of type `unique_ptr&lt;T, Deleter&gt;::pointer` The template argument can be a function pointer or a deleter class, that may be empty. In this case, using EBO, the resulting pointer has the same size as a regular pointer. Note that `std::default_delete&lt;T&gt;` is exactly that.
What on earth does the holy standard's specification of **unique_ptr**'s template arguments has to do with **shared_ptr**? Are you trolling?
I misread your message. It was a point about a value pointer, which would be able to use the same template arguments as a unique pointer, so not adding overhead.
In this case, definitely! But for that warning to work in general, you'd have to solve the halting problem. :(
My constructive criticism is to not claim performance without benchmarks.
I think I'm almost done with that, just need to do some clean-up and find a good stopping point.
No, it could not. It *does* re-fetch the value (`*ptr`). It just does not re-fetch the address (`ptr`). As explained in the article: &gt; Notice that in this case, we do not have an infinite loop. The loop will be broken if any thread does x = 1 or *ptr = 1. 
Currently, std::array is miscategorizes az a Pointer rather than an Owner by the implementation. It will be fixed soon. 
C++ in an embedded system can be an overkill 
&gt;It would be easy to check for infinite loops on all inputs: check if there are any unconditional jumps that flow right back to the same unconditional jump (or indirectly to another jump that goes to the original jump) Then you'll just get warnings for an application's main processing loop, which is infinite, except for a call to "exit()" in another compilation unit... Or it's an embedded system and the loop truly is infinite, by design.
You are just nit-picking, sorry to say. I invoked the zero theorem: what if one doesn't _need_ an ORM framework in the first place to accomplish the task. Which I have tried to explain. And sorry to say: If you don't recognize that unmanaged code is significantly more vulnerable to attack, please take a step back and try to understand what you are doing; such people are not ready to be given responsibility of a C++ code base. Also, if you don't recognize practice to be a valid argument in programming, take a more general step back and think where you got your programming wisdom.
vscode + a few plugins is certinaly leaning to IDEs in this spectrum, at least for C++. It can be seen as a hybrid multi-purpose software that can be tailored to work as an IDE. And if someone asks my suggestion for an IDE, I introduce them vscode. So in conclusion, if it looks like a duck and walks like a duck, it is a duck.
I would be happy if someone could come up with a one. Btw, couldn't vscode be configured (shortcuts) in a way that all building and debugging be done "inside" it, without switching to a terminal? I'm not a heavy user of vscode but I always assumed this is a possibility.
 &gt; if you don't recognize practice to be a valid argument in programming, take a more general step back and think where you got your programming wisdom. You made a bunch of claims with nothing to back them up, get called out on it and then respond with "if you don't agree with me then you're dumb". Great argument. &gt; sorry to say People who say that seldom are. 
But op is looking for an IDE. Can you debug with emacs? Editing is only half of the job...
https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html
First time I see a meme on a Microsoft blog. Good thing they're not in the EU.
\+1 for LEA
There is no golden rule that one is obliged to use 100% of the language features. The C subset with better type safety is already an improved over plain old C.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9iqcyl/beginner_question_about_moduleslibraries/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Not much to see yet. Hopefully we will see it fill up as cppcon progresses.
&gt;for those who don't want to get bogged down in Windows-specific goop Current Microsoft is really very likable. If you can write stuff like this on the official blog it feels like you're working in the right place.
If I read the article correctly, this isn't an infinite loop. The program actually reads the value of x in every iteration (although it could cache that too). It just doesn't expect that the pointer gets changed. 
&gt; Reading from one thread and writing from another to the same data without synchronisation is undefined behavior. I'm curious if you know a section in standard that says that?
This function returns a lambda. In a turn lambda during call tries to use already destroyed n. Easier to think that lambda is a functor with captured reference to n. But n exists only during lambda generation, not after. 
&gt;In Theexample I see atomic operations. Where?
That handles the basic case, but if there are opaque function calls in the body then the compiler can't always prove that the variable doesn't change.
Who understood this? I understand what some of it means, but I don't understand why, I'm not sure I've learned anything. It kinda started in the middle and went to nowhere I could fathom. You can do these things, but why would you? And how does the author keep all this about the language in their head?
Load, Store and Compare are atomic operations in the example. IIRC :) And in the example I can recall only load, store and compare Non atomic is store of 64 bits integer on 32-bits CPU. 
Sorry man, but I won't give you my personal details for a n on-line test. This is Reddit. Try Facebook instead. 
&gt; vim + ccls Take a look at [vimspector](https://gtihub.com/puremourning/vimspector).
no prob. have a nice day !
You are allowed to create specializations inside std namespace for user defined types, so this is UB.
Clang and gcc both compile infinite loops, MSVC does check what *ptr is each time. So MSVC seems to treat *ptr as volatile without being told. It does this even if you remove y and the thread.
Code parser/indexer?
Normally when talking about "atomic operations" what is meant is \_synchronised\_ atomics. The reads and writes may be technically atomic on x86 because they can't be partially completed, but they can be optimized out entirely because they are non-synchronizing.
While the class itself would have been useful to me recently there are some elements in the code that surprise me. [Testing `this != &amp;rhs`](https://github.com/calccrypto/uint128_t/blob/b3fc05bf15b08037fd0a1f7a1d98be06ffb88d0e/uint128_t.cpp#L17) in the move constructor. How can `*this` be `rhs` if `*this` is not built yet? [Assigning 0 to right hand side of move-assign](https://github.com/calccrypto/uint128_t/blob/b3fc05bf15b08037fd0a1f7a1d98be06ffb88d0e/uint128_t.cpp#L33]. Who cares which values are stored in `rhs` if it has been moved? Also, some compilers ([GCC](https://gcc.gnu.org/onlinedocs/gcc/_005f_005fint128.html)) support built-in 128 bits integers. The library should fall back on it if available.
If you're interested in the motivation for this, have a look at std::variant and the visitor pattern. For this particular video he's aiming for a fully compile-time visitor, so the runtime code is more succinct.
The linked uint128 implementation isn't too bad. I dislike the lack of header only, and lack of use of 128 bit SIMD though. My own uint128 type (https://github.com/ned14/quickcpplib/blob/master/include/uint128.hpp) is better, but lacks implementation of many operations. I keep meaning to get around to proposing a 128 bit integer for standardisation. Time, as always. But I'll definitely get to it soon as several of my other standards papers rely on there being a 128 bit integer type in the language.
Yes, normally we do. But the OP example is not normal. Synchronized means at least two things in one. This is the specified order of EXECUTION and specified(or not) MEMORY order. Atomic is third thing. This means lack of partial execution, this is definition. We may have "synchronized non atomic operations". And non synchronized atomic operation. &gt; but they can be optimized out entirely or rearranged because they are non-synchronizing. Atomic operation is atomic even if it was reordered or removed. C++ defines NO atomic operations by DEFAULT. So "technically", if you need atomic data and doesn't want to base on specific architecture(correctly mentioned by you) you must use atomic data types. If you have dependencies between thread based on the change of atomic data you have to estimate usage of thread synchronization. Normally you should not care too much about it. Only if you are involved in development very high performance system you have to carefully read manual. Otherwise use cst seq rst(IIRC) and deal done, your system will be perfectly synchronised. This is not the case of our example. So whole discussion is pure speculation.
&gt; Be careful when initializing a uint128_t value. Huh? What? template &lt;typename T, typename = typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type &gt; uint128_t(const T &amp; rhs) : UPPER(0), LOWER(rhs) {} Um, no. Write a constructor that does The Right Thing&amp;trade;.
&gt; It kinda started in the middle and went to nowhere I could fathom. This is a follow-up from his earlier episode, [Inheriting from Lambdas](https://youtu.be/W-xTpqj31mI). I think you'll get the context more if you watched this video first. &gt;And how does the author keep all this about the language in their head? I lol'd at this comment. Jason Turner obviously is very talented, but the concepts that he uses in this video are not that complicated.
[Boost multiprecision](https://www.boost.org/doc/libs/1_68_0/libs/multiprecision/doc/html/boost_multiprecision/tut/ints/cpp_int.html) is header only, what does this library do differently?
Similarly to how the compiler will emit a 'not all control paths return a value' when the programmer knows that, in fact, it always will (or will throw or some other control operation), the compiler could have a warning about loops with no internal end condition. &amp;#x200B; Also, c++ developers read \*ptr as two operations (read ptr, then go to that address) when in fact the compiler is shortcutting the first step. Since this is an optimization, it's fair to warn the writer about valid code that gets optimized into oblivion.
appropriate username
This is episode 134 - he's done plenty of simple C++17 and "migration to modern C++" episodes already.
I am subscribed to his channel and also listening to cppCast. I am not complaining about his work, but what I said is a thing...
I don't necessarily agree. There's a lot of areas of development that make use of lots of different C++ features. I'm sure someone will benefit from this feature, or the stuff mentioned throughout the video :)
&gt; The concept is however slightly different because I was under the impression that my code was more generic and data driven with a map than with a huge switch. It is (more generic). I usually write switches until I have many entries or realize I need to get back to them and edit existing/add new options. In such a case, I write a map, because adding a new option only means adding to the map, not handling each option (one place only for editing). WRT performance, it doesn't matter (until it does). There are projects where performance is a requirement from the start, and the project doesn't add value without that performance. In most other cases, optimizing is something that can be done throughout (or at the end of) the project's lifetime. In such cases, I use maps and optimize later, if required.
* `UPPER` and `LOWER` are named in all-caps which should really be reserved for macros exclusively * I really hate implicit narrowing conversions, yet you are reimplementing them in a way that prevents `-Wconversion` doing it's work; also: C-style casts are an abomination * Calling a file that will be included `something.cpp` is asking for a lot of trouble, just make it a header
I don't think this blog is really official and, in any case, Raymond Chen was writing stuff like this in his posts to comp.programming.ms-windows.* back in the 90s, when nobody could possibly suspect Microsoft of being nice. TL;DR: Raymond is likable. Microsoft -- who knows.
I have one that you can nest until you reach required width: https://github.com/tringi/doubleinteger *(it could too use a little review)*
The blog and the concept discussion (plussable etc) might benefit from some of the crisp definitions in [Category theory](https://en.wikipedia.org/wiki/Category_theory). The plussable concept mentioned is possibly a [Semigroup](https://en.wikipedia.org/wiki/Semigroup). If it also has an identity element then it's a [Monoid](https://en.wikipedia.org/wiki/Monoid).
&gt; can't think of a single advantage that Qt Creator has 1. Code completion is better (Microsoft C++ plugin never worked for me, both cquery and clangd are still incomplete). 2. Memory view during debugging. 3. Little things like showing the type of auto variable.
An IDE where you aren't using some of its features.
&gt; I'm ~surprised~ embarrassed this is not titled "High Order Fun" :facepalm:
It is not compliant. There are hosted implementations and freestanding implementations. Both are required to provide &lt;type_traits&gt; (among other things). http://eel.is/c++draft/compliance Despite being non-compliant, it is pretty common. 
This is really cool, thanks for making it available! It would be even more awesome if this was available as stand-alone, potentially header-only, project - just tuple_vector and fixed_tuple_vector, without any other EASTL dependencies/types. I think this is a perfect example of an "STL-like" type that doesn't necessarily need to be standardized, but it would indeed be useful to have it available (and the community work on it) in a central place, without any other dependencies, so anyone can easily pull it in (like a standard library type). Any chance for something like that to happen?
But there still is an end condition. So the warning would not be emitted for this loop. If there was not, the compiler [https://stackoverflow.com/questions/2178115/are-compilers-allowed-to-eliminate-infinite-loops could remove the entire loop]. I'm guessing that a warning about every `-fmove-loop-invariants` optimization would very quickly lead to disabling that warning or that optimization. You could try `-fdump-statistics-option` to see how often that would happen.
It's not something I was planning towards, but it should not be difficult to, at the very least, make a header-only tuple_vector that just has a dependency on STL. There's a handful of helper/internal utilities this class utilizes from EASTL which may be the biggest consternation, but that may be the only major one. EASTL generally follows the STL specs fairly well so any dependencies there should swap out fairly smoothly. If there is any other interest I may take a quick stab at it. Making a version with no dependency on STL would be a lot more work, though. Unless there was a lot of interest, that will not be pursued.
The color scheme of the text editor isn't to my liking. I like softer colors that match closer to a material palette.
I think it's bad that noexcept specification cannot be deduced and propagated automatically. A compiler can do the automatic deduction for generated constructors, but a user defined constructor has to perform that crazy noexcept-noexcept dance, which is overly verbose and error prone. The reason is, of course, that noexcept is a part of the function type, so it must be explicit. I think including noexcept into the function type was a mis-feature. Without it, a lot of explicit noexcept specifications would be unnecessary in template code.
&gt; IDE is something you write with, you build with, and sometimes you debug with. I'd say that the defining feature of an IDE is that it has a semantic understanding of your project. 
Well... You can download additional one (maybe even with the add-on downloader) or you can also roll your own, good thing there is a configuration editor in kate
&gt; I lol'd at this comment. Glad to be of service. Thanks for the link. It wasn't the code I didn't understand it was the why
Vim is an editor, so we are not comparing apples with apples. But if the user wants IDE capabilities in vim, Language Server Protocols are the way to go. For c++ in particular, cquery has been working really good for me, including completion in headers. Clangd has a bright future, but not as mature as cquery right now (I tried a few months ago). &gt;The only advantage of vim is the key bindings which almost every IDE and code editor supports nowadays anyway. Nah, not close to reality, try to see a video on how to use vim by a power user. 
I've specifically made an empty stub C library that allows compiling pretty much any standard C++11 and newer headers. Which AVR gcc build are you using ? I'll see if i can get it working 
Oh god.... The cppcon binge watching begins....
Wow, that was fast! I wasn't expecting to be able to watch these for a couple of weeks.
I think they CppCon has gotten the videos of the keynotes up pretty quickly. The other sessions tend to be a few weeks before they are up. 
IDE: also some integration with source control and the rest of your ALM system, package management, profiler, various code insights, some refactoring capabilities, profiler integration... The other thing is "make your own IDE". That works too. But one needs much of the above anyhow. Don't see a point in making a taxonomy , there's a myriad of options around. Whatever works for yoy.
Trivially doorable
I really like SlickEdit IDE. It is very zippy especially with large projects (30000+ files) where I found using Eclipse was very slow. It does code indexing very quickly and I find it very easy to use and intuitive.
gcc from straight from their repo. It had a "compliant" compiler, sure, but the language isn't just the compiler but the headers too. But without type traits, there are some things that cannot be done or are really tedious
Worth pointing out, because this will surely be a common mistake with CTAD. At 18:02: vector v{begin(c), end(c)}; Gives you a `vector` holding two iterators to `c`, it does not call the iterator pair constructor. What you need to do is: vector v(begin(c), end(c)); Also `vector{c}` is not a thing. There is no constructor for `vector` that takes an arbitrary range.
 #include &lt;iostream&gt; #include &lt;cmath&gt; int main() { int printed=0; long long x=0; while(printed&lt;5 &amp;&amp; x &lt; 1000) { auto const eval=[](auto const x) noexcept { return std::pow(x, 5) - 500 * std::pow(x, 4) + 99483 * std::pow(x, 3) - 9838368 * std::pow(x, 2) + 483157872* x - 9415087488; }; if (!eval(x)) { std::cout.put(x); printed++; if ((eval(x-1)&lt;0)==(eval(x+1)&lt;0)) { std::cout.put(x); printed++; } } x++; } std::cout.put('\n'); } 
Eh, no need to be so defensive. That comment was perfectly normal and wasn't attacking anyone (and especially windows).
Maybe it's a little verbose, but at least it's obvious that it's a template. It's also consistent with the syntax for generic lambdas and maybe will be with normal functions too (afaik it's concepts ts too)
Output: Compiler Info: /usr/lib/gcc/x86_64-linux-gnu/6/../../../x86_64-linux-gnu/Scrt1.o: In function `_start': (.text+0x20): undefined reference to `main' collect2: error: ld returned 1 exit status [^source](http://ideone.com/ipfZo6) ^| [^info](http://www.reddit.com/r/CompileBot/wiki) ^| [^git](https://github.com/renfredxh/compilebot) ^| [^report](http://www.reddit.com/message/compose?to=compilebot&amp;subject=Report%20Abuse&amp;message=--report%20/r/cpp/comments/9itktj/42_silly_ways_to_say_hello_in_modern_c_sep_2018/e6mir45%20Include%20your%20reason%20for%20reporting%20here.) 
I don‚Äôt see how it disambiguates anything - ‚Äúauto‚Äù here adds zero semantic information. You can very easily write your concepts in a way that visually disambiguates (which is how templates do things today - UpperCamelCase), and likewise you can very easily go against the grain (which is also possible with templates today - without complaint from users). From what Bjarne was saying, it seems the standard committee took issue with the meaning of a concept when deciding if it was a forwarding or rvalue reference, to which I think the answer should be obvious - it‚Äôs an rvalue reference. ONLY T&amp;&amp; has the special property of being forwarding. Even template templates can‚Äôt be forwarding references naturally. Conceptualising the type of a forwarding function seems like poor design to me - isn‚Äôt the entire point to take arbitrary input and ‚Äúforward‚Äù to the relevant destination? 
&gt; You still haven't said where you see atomic operations in the OP. I did. &gt; The article linked doesn't mention x86. This doesn't matter: give me an example of an architecture where Load, Store and Compare are not atomic. &gt; and as the architecture is unspecified, no guarantees of atomicity at all in the original "broken" code No. You do not understand how hardware works and you do not understand what is synchronization or atomic operations - you are mixing apples and oranges. From language point of view: C and C++ doesn't define any atomic operations using standard data types. This is the main reason why we are using atomic in code instead of silently write int a; if(a== 0). Sanity. Atomic load and store are just funny facts about architecture, nothing more. Atomic operations we use just because they are atomic. We do not care about sync, because atomic operations are bad for synchronization, we need atomic operation to have lock-free algorithms and keep invariants. Opposite, synchronization is required to sync execution of the thread and we do not need atomic data types for synchronization(in fact? need, but internally). And last, you may have problems with threads' synchronization even using atomic data. And problem is not your compiler which optimize your code - this is too simple. Problem is CPU and cache in CPU. To be more precise, problem arises when different execution units use different caches. 
On slide 26 ([\~29:32](https://youtu.be/HddFGPTAmtU?t=1772)) he uses input\_channel as type. &amp;#x200B; Is input\_channel a concept? is it a "narrow" auto?
Considering the ubiquity and likely soon-to-be-standardization of libfmt, it would be useful to give at least some hint as to why one would want to use this library.
The documentation contains the section ["Why to use Boost.Stringify"](https://robhz786.github.io/stringify/doc/html/index.html#boost_stringify.overview.why_to_use_boost_stringify)
There's lots of posts on reddit.. telling people they have to click through every one of them doesn't seem fair.
Yeah, and using something like double braces for uniform initialization was redundant as well, but today we call it unicorn initialization. I don't see why we cannot do the "safe" thing and use a visual marker for "implicit templates", and if everything works out we'll just make it optional afterwards. Why risk another fiasco?
 vector v{begin(c), end(c)}; I don't see this as a big problem with CTAD to be honest - if you construct a vector of iterators you will directly notice that something went wrong (it will most likely not compile or the IDE will tell you). &amp;#x200B; The bigger (underlying) problem is the precedence of initializer lists... vector&lt;int&gt; v{3,5}; //element 3 and 5 vector&lt;int&gt; v(3,5); //3 times element 5 &amp;#x200B;
But this isn‚Äôt always the case - as with the template template scenario. (Excuse lack of formatting, I‚Äôm on my phone) template &lt;template &lt;class...&gt; class C, class... Ts&gt; auto foo (C&lt;Ts...&gt;&amp;&amp;) This is not a forwarding reference. I think concepts could easily fall into this same category. Arguably, perfect forwarding should have had a unique syntax so that it could be utilised in more scenarios and been future proof with concepts
Last year everything was available within 48 hours, iirc.
anyone know where the clang implemetnation of concepts is right now? I saw a post a while ago about there being an experimental branch on godbolt, but haven't seen much about it since - and clang 7 just shipped without it, from what I can tell.
Other than what the others pointed: I work on one set of libraries used by a bigger set of modules packaged together in several massive distributions. about a hundred repositories. Sometime I work just on the team libs, which are not at the same level of dependency, and sometime I need to build the whole stack of one of the distribution. Also at home I have a bazillion different projects and like 2 are very massive but very different kinds and sizes. The whole survey assume that the person answering work on ONE piece of code and only build that regularly. That's not realistic at all.
These young whippersnappers of today with their YouTube videos and what not.. Back in my day we just fired up vimtutor and learned our stuff hands on. 
Do concepts let you specify different implementations of a function when being evaluated (and when resolving an overload set) for a Concept's predicate?
C++ is "excellent" for embedded or it is impossible to use standard C++ on embedded. Pick one. It can't be both. And "maybe in a few decades it will possibly exist if we're lucky" doesn't count. As it stands, there is no such thing as embedded C++, period. It doesnt exist, can't exist. What is used is a completely different thing that happens to look and behave *mostly* like C++, except actually being usable on embedded.
I think the point is, we'd like to know at a glance, i.e. in the readme, what those other things are, especially in comparison to fmtlib. It doesn't have to be a deep dive (the "Why to use Boost.Stringify" is way too long if I just want to decide in half a minute whether it's worth having a look at it deeper or whether I'm ok with fmtlib) but a few bullet points / sentences / table what the main differences to fmtlib are. I think it's great that you're posting the library here, and it's always great to have options. Particularly if the library can do things that others can't. Keep it coming and all the best :-)
&gt; My build is bottlenecked by * No option for filesystem bound builds?
Usually your motivation for writing the lib instead of using the existing, mature alternatives is a good start to explaining what the library is better doing.
I've been on it for a few weeks now. During lunch, sort by popular and go down the list lol. 
I'm really not a fan of the braced initializers being used all over the place. A comma-separated list enclosed in curly braces looks like a set. It's totally counterintuitive to show function arguments in this format even when they have nothing to do with the contents of any kind of collection (ordered or not).
Oh god. Every character in that scares me.
The interface for vector has been counter-intuitive for a while. Some constructors should have been factories because there are too many and it's too easy to make a mistake. Especially how `(int,int)` is different from `{int,int}`.
This was a keynote talk at a c++ conference. He‚Äôs obviously talking about the future of generic programming in c++
https://stackoverflow.com/questions/478898/how-to-execute-a-command-and-get-output-of-command-within-c-using-posix
One of the comments mentioned boost.process not being official not maintained. https://www.boost.org/doc/libs/1_68_0/doc/html/process.html Looks like it is now. Have you tried it? Anyone else?
Hey .. just wanted to point out that this: `x = subprocess.Popen('ipconfig')` would not set `x` to a string but instead a `Popen` object. I think you were thinking of something like this: [https://docs.python.org/2/library/subprocess.html#subprocess.check\_output](https://docs.python.org/2/library/subprocess.html#subprocess.check_output)
I had seen boost.process mentioned before but was hesitant to use it considering it wasn't maintained in the past. I'll have to look into this and figure it out
There is no C++ solution per say. There is a Posix one. The Pope‚Äôs function. It is rather C than C++. 
Have anything else on The Pope's Function/ a link? Googling C Posix The Pope's Function is giving me something not at all similar to programming
These days it‚Äôs pretty easy to get boost on your dev platform of choice. Unless you get some really good alternatives with glowing recommendations I think you should consider giving boost.processs a try. Please follow up! It‚Äôs been a while since I‚Äôve tried to spawn processes and even then it wasn‚Äôt xplat (qnx startup/watchdog) so I‚Äôm interested to hear which way you go.
Doh. Stupid iPhone autocorrect. Thanks! Will fix. 
Like the others said, it's one of the most poorly put-together surveys in recent history. Apart from what has already been said, if my build requires 8GB... does it require "4-8GB" or "8-16GB"? Similar problem with other questions. &amp;#x200B;
thanks! I changed the post now. I was indeed too short.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9iyuuu/need_help_with_homework/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
i don't know why my code always becomes un indented when submitting on here very sorry for that. if you know how to fix please tell me.
thanks for your advices. I changed the post now. Still not perfect. I need to think better about that next time. 
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9iydzp/c_equivalent_to_pythons_subprocesspopen/e6nhf0d/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
thank you :) much better!
What's wrong with auto being that visual clue instead of yet another magic sequence of braces/brackets/parentheses/angle brackets? 
Is it hoped/expected to ship in clang 8?
Sure hope so :) IIRC releases happen every six months, I believe this is enough time to get most of the feature merged and in pretty good shape. 
Awesome! Thank you so much. Can't wait to start playing with it.
You can already play with it by building the compiler yourself (follow the instructions on my clang-concepts github) 
Removed as off-topic (no-topic).
Why is this not header only? I would also freak out with the capital letters because I see macros.
Maybe other editors have become better and have this feature (and I just don't know), however the inline macro expansion is a beautiful tool when having to work with legacy code that (ab)uses macros.
CLion is very nice. I am unfortunately hooked and can't go to Visual Studio without missing the intelligence of CLion. There's so many things the editor just does right out of the box that puts others to shame.
Renaming the inner `x` would also rename all mentions of `x` in the same scope (in this case the increment). But as some other answer mentioned, if you use functions instead of variables then you can find examples where overload resolution will choose another function.
It's the same syntax as aggregate initialization, and it fixed the most vexing parse. Had we not introduced initializer lists the way we did, uniform initialization would have provided us with one consistent syntax to use for constructing every object.
A lot of space for improvement: - Copy/move ctor/assignment can be defaulted instead of all this hick hack - Header only for optimization - constexpr everything! - Get rid of includes (string, stdexcept, ostream -&gt; could be done in cpp and string conversion does not belong inside the class) - specialize `std::numeric_limits` - maybe save some of the operators (I don't think all those specials for bool, uint16_t, uint32_t, ... are required if you can convert them to uint128_t) - Put it into a namespace (not the global)
If concepts are compile-time predicates, why can't they look like ordinary functions returning bool? concept bool is_comparable(Type T) { bool r = requires (T a, T b) { { a == b } -&gt; bool; { a != b } -&gt; bool; }; return r; } concept bool is_number(Type T) { bool binary_ops = requires (T a, T b) { { a + b }; { a += b }; { a - b }; { a -= b }; { a * b }; { a *= b }; { a / b }; { a /= b }; }; bool unary_ops = requires (T a) { { +a }; { -a }; }; bool cmp_ops = requires (T a, T b) { { a &lt;=&gt; b}; }; bool r = true &amp;&amp; is_comparable(T) &amp;&amp; binary_ops &amp;&amp; unary_ops &amp;&amp; cmp_ops &amp;&amp; copyable(T) // we are probably missing something... ; return r; } 
&gt; Okay, first the nitpick: The declaration volatile int* ptr does not make the ptr variable volatile. It defines ptr as a non-volatile pointer to a volatile integer. You wanted int* volatile ptr. Does that matter here?
Yep, you'll just have to worry about constant layoffs, having to move to a new state every couple of years (if you're lucky), below-average pay, toxic work environments, death marches, and dysfunctional hiring practices. 11 years in this god-forsaken industry and I've just about had it. I'd rather feel like an old man somewhere with better pay, more stability and the ability to actually put down roots and have a family.
I don't understand? LOL. &gt; The problem is not in the generated machine code. Try to read the whole thread instead of generating strange ideas. I mentioned immediately "Anyway the example[source code] is not good."(c) and "compiler optimization. Add something like volatile"(c) &gt;Once the machine code is generated, all hope is already lost and it doesn't matter which machine you compile to. This is bullshit. Because different machines give us different results(x86 and ARM, multicore CPU/singlecore CPU). Read the f***g manual. Pointers, memory models, paging, cache lines, speculative execution, fences and so on. It is more complicated than trash posting. 
I'd like a new syntax for forwarding references
You should not do this, the dtor will run only once, possibly causing leaks.
To each their own, but I use libraries based on their technical merit rather than namespace and variable/class/etc. naming conventions. Sometimes you just have to agree to disagree. With Abseil you may have alternatives, but say you‚Äôre writing a large application with legacy C and Fortran code sm. Sometimes it‚Äôs best to just use their API rather than write a RAII wrapper around everything. In the Abseil docs, they at least tell you not to touch the ABSL namespace, and if extension points for template specialization are added later I‚Äôm sure they will be documented. Just as in namespace std (one example is ‚Äòis_error_code_enum‚Äô) &gt; We expect there may eventually be templates that are valid extension points provided by Abseil ‚Äî there are not currently.
Please learn C++. Yes, the machine matters. But only if you write correct C++ to begin with.
thanks, added
it's correct. you should not use _ to start a symbol name (this naming scheme is reserved for the system).
That is correct.
`_some_vector = {1, 2, 3}` would be better in this case, as it can reuse the already allocated capacity.
&gt; you should not use _ to start a symbol name (this naming scheme is reserved for the system). only names starting with underscore followed by a capital letter or another underscore are reserved.
Identifiers starting with `__` and identifiers starting with `_X` (where X is any capital letter) is reserved. Identifiers starting with `_x` (where x is any non-capital letter) is fine. Identifiers starting with a single `_` is only reserved in the global namespace. https://en.cppreference.com/w/cpp/language/identifiers
Thanks for the quick replies. Wanted to be sure. 
What questions are you most curious about?
It's correct. Another method is, ``` using std::swap; swap(_some_vector, v); ``` I'm not sure if it's better than std::move version, but I would think it's no worse than std::move. 
Swapping is potentially worse than move, since swap is required to copy the internal state of `_some_vector` into `v`, while the move constructor merely sets the state to empty. Zeroing a variable is potentially faster than copying. The difference, if any, is probably marginal though, especially after optimisation. Swapping does have the advantage of working on ancient compilers.
Do you know if there is an easy way to only apply/check clang-tidy rules in a subset of code? For example, not apply `readability-identifier-naming` checks on identifiers originally declared in a third party library?
This is not a correct use of this sub.
most of the code of Bjarn slides aren't valid C++ but what he would like the syntax to be.
How could subsumption be defined then?
But but C++ already has too many syntaxes!
&gt; Please learn C++. LOL. I am born to C++, my young friend. &gt; Yes, the machine matters. But only if you write correct C++ to begin with. Read thread carefully. You missed "volatile", which solves instantly the problem with source code and compiler, but unfortunately program may fail, because multithreading is not for beginners. If you want to be once C++ engineer, you must understand How Things Work. Start from the basics. If you want to be C++, of course. If you need a book, I could recommend you few for mid/advanced level.
Even though you‚Äôre technically right, other developers might not be familiar with the fact that _var is okay but _Var is not, so it‚Äôs best to avoid underscores completely in my opinion.
That's misleading though... You're swapping but not using one of the vectors. Not exactly clear.
You're right but not very helpful. For future references the "right" subreddit would be /r/cpp_questions. 
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
&gt; Read thread carefully. You missed "volatile", which solves instantly the problem with source code and compiler, but unfortunately program may fail, because multithreading is not for beginners. Yeah, volatile might help with the compiler's optimization in this case, but is the wrong tool to suggest for thread synchronization. &gt; If you want to be once C++ engineer, you must understand How Things Work. Start from the basics. If you want to be C++, of course. It is not me who have problems understanding that talking about hardware in this case is completely meaningless. You could have an architecture where every single machine instruction is atomic, and you still wouldn't have gotten the correct behaviour because the problem arises in the optimization stage, most likely before a single machine instruction has been generated. &gt; If you need a book, I could recommend you few for mid/advanced level. Please give me some recommendations, so I know what books to avoid.
Yeah, it's written in **bold** in the sidebar.
The ones I'm stumbling over are like: &gt; How much working memory does your build require? What do you mean by "require"? How much will it need if I don't parallelize? How much it uses in a run given how much I typically parallelize? And then going back to earlier, &gt; On average, how long does it take you to run a build from scratch? Again, is that with no parallelization of the build, or with what I usually do?
&gt; I feel this was addressed acceptably during the talk. Use static_assert. The part of the talk that addressed this is the part where Bjarne tangentially mentioned archeotypes as a way to test this. But archeotypes are a pain to write, and nothing checks that you write them correctly, so even if you use them, chances are that you won't be checking correctly. The reason I am skeptical about the lack of definition checking is because without it, I suspect that most people won't be able to correctly write concepts that properly constraint what they actually use. Bjarne see this as a practical feature: for example, you don't need to require that a type be printable with `std::cout &lt;&lt; T` to be able to print it, and this gives you a lot of velocity while developing. OTOH I have worked on O(100kLOC) Rust projects, where "definition checking" allowed to both reason about code locally as well as refactor huge parts of the code base reliably without introducing bugs. This discussion is not new. Lack of definition checking is pretty much akin to weak typing (or duck typing), while definition checking requires annotating all generic type parameters with their type. I find it weird that people are able to argue that strong typing is good, and then go for a weakly typed generic system, but C++ is a language full of trade-offs, and I think it is interesting that it is pursuing a direction 
I don't know Rust or C# but if what you mean is similar to selecting an alternative implementation by using enable_if, then it is possible. https://godbolt.org/z/_CtzV0
Didn't Bjarne show just that with `void sort(Sortable&amp;);` and `void sort(List&amp;);`?
&gt; Many other languages have a simple answer, like `cargo new` C++ has it as well: bdep new -t exe -l c++ hello_world See [bdep-new(1)](https://build2.org/bdep/doc/bdep-new.xhtml) for details. As Rust folks like to say, "we can have nice things" too".
But since there are already some useful answers and discussions, isn't better to keep the original post there as reference? 
1. What prevents you to submit it to Boost today? 2. The performance looks quite good to me, looking at the performance page. 3. Are there fundamental differences with fmt that makes it impossible for fmt to benefit from features you have that it does not have? 4. Did you consider proposing it to the standard too? A paper describing the interface and why its better than alternatives would help improve the probability that the new generation of such tool gets in the standard without being immediately obsoleted by a boost library (I don't mean it's the case, but we can't know for sure without a lot of efforts).
Andrei Alexandrescu proposed static\_if (one video: [https://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Static-If-I-Had-a-Hammer](https://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Static-If-I-Had-a-Hammer)) &amp;#x200B; He and Bjarne had competing papers around the beginning of concepts, Bjarne (per this C++ subreddit) s\*t on it unreasonably, and Bjarne wins, I guess because he's Bjarne. 
Thank you for sharing such a detailed perspective on this! I have not played much with writing concepts myself, however if they could eliminate SFINAE using enable_if in even half my uses then that would be a win for me personally.
Maybe. This is a fairly simple question though, so I don't know...
Why does it even need a move constructor or move assign? Its not a type that could benefit from moving. Isn't the rule of 3 enough in this case?
Oh nice, I've not seen this before. It solves the same problem!
Yes it's quite simple question, but don't forget there are more newbie C++ developers in the world so this question may be useful for them. Any way thanks for your understanding. :)
The other response is excellent but I wanted to also touch on this point. &gt; Use static_assert. What you want is to check that the `find` implementation is sufficiently constrained (it's not, both for the iterator + 1 mentioned, but also that there's no constraints at all on the relationship between the iterator and the value!) To test that today, you need to: - Write your own types that, as minimally as possible, model each constraint - Actually instantiate the algorithm and make sure it compiles The first step is really hard and manual. The second just needs diligence and a good test setup. And work and time. You _need_ to instantiate the body and you can't do that with a static_assert - that only checks the declaration, and we need to check the definition.
Although it was not elegant at all, the actual reason Alexandrescu's paper was heavily criticize was that if it was applied as is, you could do static if outside the boundaries of functions, which means making potentially apis changing at each compilation. It's just not working in c++. 
r/cpp isn't really the place for newbies though.
&gt; 1. What prevents you to submit it to Boost today? I find it still incomplete. It lacks: * floating point * encoding conversion in the assembly string * customisable error handling in the assembly string * documenting some parts Also, backwards-incompatible changes are still happening. But I think next release ( 0.8 ) is a good candidate. &gt; 2. The performance looks quite impressive to me, looking at the performance page. Thanks. And I'm sure there is room for improvement. &gt; 3. Are there fundamental differences with fmt that makes it impossible for fmt to benefit from features you have that it does not have? That's a good question. I think they could take advantage of some features. But I need to document the lower level parts of the library so that they could use it. &gt; 4. Did you consider proposing it to the standard too? A paper describing the interface and why its better than alternatives would help improve the probability that the new generation of such tool gets in the standard without being immediately obsoleted by a boost library (I don't mean it's the case, but we can't know for sure without a lot of efforts). I find that library may need some polishment based on users' experience before aspiring that high. There is also the fact that is not easy for me to participate in the ISO meetings since I live in Brazil. But I'm glad you see my library as so promising. Best regards
The blog post provides sort of a nice walk-through, and it sounds great, I think, but what I'm sort of missing is: What practical benefit do we get from that, "we" being a cross-platform developer that compiles and ships on Ubuntu as one of their platforms? Like, do we get a newer OpenMP version now than the one we had before? A better one? Will there be any benefit now and what is it? And as far as libc++ goes, the latest version previously wasn't available pre-compiled in a repo, so that being in apt.llvm.org now, means that we don't need to self-build libc++ anymore in our travis scripts?
Sweet as, I used to work in Record Press at Weta! Is Houdini big at Weta now? When I was there it was still mostly a Maya shop. &amp;#x200B; Also, importantly, is that dive bar on Miramar ave with the delicious Thai food for lunch still in business?
They are uploaded now. 5 commits have been pushed since your edit.
This is a really interesting presentation, and a funny format. Thanks!
&gt; I find it weird that people are able to argue that strong typing is good, and then go for a weakly typed generic system It's not like they didn't try. For a brief moment, "full concepts" was part of the standard draft around 2009. It had "modular type checking" which included checking of templates against concepts specfications. But it was huge, complicated and it had what I would refer to as soundness holes. My impression was that almost nobody really understood the details including most of the committee members at the time. So, the options I see are either to wait even longer until a "proper concepts" proposal is fleshed out or to do "concepts lite" to satisfy a real need.
There is also [C++17 - The Complete Guide](https://leanpub.com/cpp17) by Nicolai Josuttis.
The always useful cppreference answers all: https://en.cppreference.com/w/cpp/compiler_support
You can use -header-filter or -line-filter. See [https://clang.llvm.org/extra/clang-tidy/](https://clang.llvm.org/extra/clang-tidy/)
Please don‚Äôt post here without doing your due diligence on google. The answers are pretty easily available. 
You said: &gt; Awesome! Thank you so much. Can't wait to start playing with it. And I gave you a link to godbolt with an example compiling with the Clang's experimental concepts branch. I'm sorry, I don't understand your response.
But they don't show the platforms. Like which version of GCC does Android use.(if they use gcc)
I also said &gt; an experimental branch on godbolt
Is this run in special conditions? It works on my mac.
So I googled "ios C++17 support" and got a mish-mash of "X doesn't work" from over a year ago. The same for android has a section that seems to imply libc++ with android NDK has C++17 support. I couldn't find clear information about what version of libc++ is being used on that page. macOS led to a SO question that talked about using brew to install a more recent version of gcc and isn't very clear about what C++17 features are included in the clang. So, I'm not sure what "pretty easily" means. Google searches feed me "maybe some subset depending on build chain, but probably not", but that is usually based off year-old links. 
can't you just \`return static\_cast&lt;decltype(result)&gt;(result);\` ? seems to result in the appropriate assembly 
You have a link maybe?
&gt; I dislike the lack of header only, and lack of use of 128 bit SIMD though. Does SIMD have any advantage for 128 bit types? I believe the old ADC / SBB / MUL / SHLD is superior for multiple precision arithmetic. Compilers have intrinsics for these. They work beautifully for 128 bits, but fail badly for loops. I simply cannot get VC++ to generate a DEC + JZ instruction for looping. Wide-ints have already been proposed for C++. The latest I can find are these 2 papers by Lawrence Crowl: [Overflow-Detecting and Double-Wide Arithmetic Operations](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0103r1.html) and [Multi-Word Integer Operations and Types](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0104r1.html). There is also [A Proposal to add wide_int Template Class](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0539r2.html). This paper is particular seems pretty far along. Are you aware of any of their status? 
At the bottom of the cppreference page from another comment there are links to official compiler's support pages.
To me the main benefit is getting matching `libc++` and `clang` from the same release of LLVM.
IMO the bigger problem is the fact that vector has constructors like that at all - containers should all initialize like containers! Any other forms of construction (e.g. repeating an element) should be a unique named function, e.g. repeat_n from range-v3: vector&lt;int&gt; v{3,5}; //element 3 and 5 vector&lt;int&gt; v = repeat_n(3, 5); // 5 times element 3
For standardization, if your work can inform the fmt-based proposal (which seems to be well received), you wouldn't need to be there for the votes because someone else is already championing it. Although that depends what is your position on that paper. I would recommend contacting the authors see if some collaboration can be started. Also I note that you have some Unicode related features. How do they overlap or interact with Boost.Text (also not reviewed yet in Boost) which have been forged with the help of the Unicode Study Group? Maybe some input/reviews from them would be beneficial both ways too.
That's the same* as `decltype(result)(result)`, which was discussed and inhibts copy elision. * Well, of course it's not the same, it's C++
3: auto&amp; newItem = vec.emplace_back(3, "name of item", 9.8);
And game consoles, although I believe newer generation console are much better about supporting newer standard than old ones. The library support is very spotty though.
It's a wiki. You could help fix that!
You must have worked at some pretty bad studios. I'm not denying that those things don't exist, as they definitely do, but over the span of 21 years I have never had that experience. You should also note that the \*exact\* same things you are describing happen just as much in finance and other industries... sometimes moreso... but they aren't publicized like they are in a smaller industry like games. Banks don't have fans that have review sites, twitter, and fans promoting the stories. The things I've heard from friends working in finance and web startups are absolutely horrible. Also note that I said games / graphics industry. Right now simulations, robotics, etc is extremely hot and will only grow in the future... and graphics programmers are in extreme demand.
^(Not if he doesn't know that.)
works for me too ¬Ø\\_(„ÉÑ)_/¬Ø. i reported it to the bot
I know I can help fix that, but I don't have the information to fix it.(Hence I'm asking). I think that's also what /u/FG_Regulus meant.
game consoles is also a concern I have, yes. Do you maybe know which c++ versions ps4 and xbox one support? Since I don't have the SDK and documentation I can't check myself.
I think Macports handles this better than Brew but there aren‚Äôt many packages available on ports due to Homebrew‚Äôs popularity. I install llvm with homebrew, export the LLVM path, and link the llvm provided stdlib. I export my CC, LD, and CPP variables in my path It won‚Äôt break your Xcode version, and it works pretty well with CMake
I don't know Boost.Text well. It was only very recently announced in the boost mailing list. But basically, the only thing that Boost.Stringify currently can do related to Unicode is encoding conversion. Boost.Text is able to do much more than that. Perhaps some of its capabilities (like case mapping and text segmentation ) could be used in Boost.Stringify. Probably, Boost.Stringify can be extended to support the strings types of Boost.Text as input and output types. While Boost.Text only works, afaik, with UTF-{8,16,32}, Boost.Stringify can convert encodings like windows-1252 and iso8859-15.
Thanks - that's exactly what I meant. You're asking for help finding the information and his response is that you should find it by filling out the Wiki. Not really helpful at all.
I'm not aware of their progress, but they're all (a) library solutions and (b) they generalise to arbitrary length. I just want a plain uint128_t and int128_t in the language. Nothing added or extra.
Indeed. That had been annoying me for years
I still have a half hour left of the video to watch so maybe I'm not looking at the right thing, but that's coming at it from the opposite angle I'm talking about--a consumer of a concept having different implementations depending on what concepts are supported. We basically can do this already with enable_if (like A_Seat_For_One's godbolt). Watching a little further in the talk, I'm guessing what I'm asking about is not possible. Take the Cowboy::draw vs Shape::draw example. What if you had a type where it could have valid implementations of both types of draw() methods, and there was no way to distinguish the two because the method signatures are identical (this would be the case because you are attempting to fulfill concepts you did not write)? Here's fake syntax mimicking the behavior of C# explicit interface implementation that might explain better: struct Cowboy { GfxDrawable requires void draw() // GfxDrawable::draw { fmt::print(R"( ,'-', :-----: (''' , - , ''') \ ' . , ` / \ ' ^ ? / \ ` - ,' `j_ _,' ,- -`\ \ /f ,- \_\/_/'- , `, , , /\ \ | / \ ', , f : :`, , &lt;...\ , : ,- ' \,,,,\ ; : j ' \ \ :/^^^^' \ \ ; ''': \ -, -`.../ ' - -,`,--` \_._'-- '---: )"); } void draw() // no requires qualifier, so WildWestDuelable::draw will attempt to use this { std::printf("Reach for the sky!\n"); } };
Not quite, I expounded on what I mean in my [reply to bstaletic](https://www.reddit.com/r/cpp/comments/9itcz6/cppcon_2018_bjarne_stroustrup_concepts_the_future/e6old0l/).
Doesn't "template project" suggest a project about using templates? If I read this right it's a "project template": a template for setting up projects.
Your source says that it doesn't yet. Also, I just checked on Xcode 10, and it has neither `filesystem` nor `experimental/filesystem`.
Your source says that it doesn't yet. Also, I just checked on Xcode 10, and it has neither `filesystem` nor `experimental/filesystem`.
I'm not arguing that concepts lite doesn't solve problems now. I am just skeptic about how good concepts lite will work in very large code bases. At some point you are going to have to refactor concepts and/or code that uses concepts. In Rust, if I change the implementation of a function that uses traits, as long as I don't change the type signature, all code that uses the function will still compile fine. I can do a new release of a module, and people can silently upgrade, without issues. Without type-checked generics, I can add a `std::cout &lt;&lt; T` statement, my code / library / module will compile just fine, and when people upgrade their code can just stop compiling because they might be missing an `operator&lt;&lt;` that wasn't required by the concept. The error message won't be good either (found 2000 `operator&lt;&lt;` overloads, here is the list, there is none for your type). 
Indeed, maybe I have the name backwards. This is not about C++ templates.
&gt; which means making potentially apis changing at each compilation How is this different from enable_if and ADL shenanigans?
Actually, "template project" is ambiguous. But "project template" is unambiguous and only means what you intended.
Ok, thanks. Well, then no apple stuff for now then. I don't really use Apple items anyway and I have no need for it right now.
Hard to read because of the many typos and butchered grammar, but this was cute &gt; one of the pretty differences 
New or not, there is no reason to use a bare array when you can use a vector 
New or not, there is no reason to use a bare array when you can use a vector 
PS4 uses latest clang, but again, that's the language, not the lib. IRC, `filesystem` is optional, so I highly doubt that PS4/X1 ever get support for it (you don't really need it on consoles though, since you have very limited access to fs if any).
I'm fond of the `comefrom` operator. Much nicer than `goto`.
However, `&lt;boost/filesystem&gt;` is a 95% identical API that I have done drop-in replacements with only a few shims. For example, std filesystem has "options" flags for an argument that can be or'd together, while boost filesystem has an "option" enum where one is permitted of a slightly more restrictive set. 
Oh, sorry. I overlooked your comments.
There will definitely be enough threads about CppCon :-) I appreciate that your intentions are good, but we‚Äôve got to keep the posts focused around interesting discussion.
Not arguing, because, honestly, it‚Äôs simply not important to argue about. Just want to point out that ‚Äúinterests‚Äù is not an objective criterion. I might date to say it is very subjective. :)
A similar announcement was posted a few days ago. This one goes into a bit more details - nice. Unfortunately it's not available for VS Ccmmunity edition - it's Enterprise only. And Microsoft does not seem willing to reconsider on this particular feature :-(
The last NDK update has removed gcc, there is only clang now.
Here's a link that makes it easier to see that this doesn't help: https://godbolt.org/z/WWuHrr. Change the `#if 0` on line 21 to `#if 1` and back and watch the call to the copy constructor appear and disappear.
How far back do you have to go to find a compiler that [doesn't perform copy elision](https://godbolt.org/z/T_5JLw)? Even as far back as Clang 3.9, both pushing and emplacing a structure onto a vector have the same exact assembly. 
Yeah Houdini is getting really big at Weta. So glad that happened. And yes Thai pub is still there. Its a regular place I go.
[removed]
Or ‚Äúuniversal backwarding‚Äù for maximal confusion...
You limit yourself a bit if you measure code quality by the assembly it produces
OOhh ... only for enterprise, not even for the professional edition ?! Shame !
I‚Äôm not a fan, I do not recommend it over QT creator, for example. Lots and of lag in syntax highlighting or completion. That said, it‚Äôs visual debugger is pretty good, and it‚Äôs not an unusable IDE. If you have a choice, try some other ide‚Äôs or use Vim. If you plan on using Swift or Objective-C, then Xcode is your only option.
Thank you for writing this. &gt; The first step is really hard and manual. I feel you on the really hard part. Writing archetypes that minimally model the constraints in a concept is hard, really really hard. In many cases, that are probably not relevant in practice, it is probably impossible to even test these APIs with archetypes, because C++ constraint system is so powerful, that you would have to generate infinitely many types (e.g. an API constrained by a concept that checks `::value != 0` where `value` is a 64-bit integer, might need 2^64 - 1 archetypes to fully test the API).
I am using it since the first beta in pretty big project (~200k lines) and it‚Äôs very smooth, compiling is fast. The first beta versions had some bugs but now the most of them are fixed.
Still doesn‚Äôt have full C++17 compliance although this is starting to feel like a lost cause now. Compiler aside, I have a better experience with vs code with cmake tooling support (written by another member of this community)
Funny I used QTCreator for C++ prior to XCode 10 and switching back now for a little bit just to check what's new in Xcode 10 and feel like the UI is more polished than QTCreator.
&gt; have a better experience with vs code with cmake tooling support Funny, that‚Äôs all I‚Äôve been using for C++.
Does it use the same technology as [Time Travel Debugger](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/time-travel-debugging-overview), introduced on CppCon last year? If so, I wonder if Microsoft is going to cancel TTD since the "Going Back" feature is now part of Enterprise?..
I use AppCode from intellij. Its awesome with lots of plugins. Especially bookmarks which I cant live without.
Don't waste your time. 
GDB has this as well, known as savepoints
Can't be sure, but I think ever specializing a function template in the `std` namespace is a very bad idea. This may be related to the fact that you cannot partially-specialize a function template. For example, with `std::make_unique`: struct foo { foo() {} explicit foo(int) {} }; namespace std { template &lt;&gt; std::unique_ptr&lt;foo&gt; make_unique&lt;foo&gt;() { std::cout &lt;&lt; "My make_unique()!\n"; return std::unique_ptr&lt;foo&gt;{new ::foo()}; } } void bogins() { // Calls our special `make_unique()`: auto ptr = std::make_unique&lt;foo&gt;(); // OH NOES DOES NOT CALL OUR `make_unique()`, but compiles without error: auto ptr2 = std::make_unique&lt;foo&gt;(12); } That can lead to very unintuitive results. And the following: namespace std { template&lt;typename... Args&gt; std::unique_ptr&lt;foo&gt; make_unique&lt;foo, Args...&gt;(Args&amp;&amp;... args) { // ... } } // namespace std isn't even valid, since it would be a partial-specialization of `std::make_unique`. In other words: don't do this, or you will make your coworkers **very upset**.
Anyone have some release notes / table w.r.t. C++14/17 core language &amp; library features?
Ask Apple. I think they needed a custom implementation that they haven't finished yet, but I don't remember why.
But you can have a virtual copy constructor (sort of). Just call it `clone()` or something. No additional overhead. You just need to create a copy class that is stateless and calls that for it to work.
That's not what I said. I was point out that the article made a provably-false claim, one that requires literally 3 minutes to test. We're (allegedly) engineers. It's our job to test the words that we say/write before we say them to ensure they are factually correct. &gt; If the constructor accept more than one argument and if push_back is used our only option is to pass an object of the type explicitly.This in turn will lead to the creation of temporary object which is then copied into the vector.This means using push_back to add object of class with more than one argument will always produce an overhead. Provably wrong, the temporary object creation is optimized out even in Clang 3.9 (which is ancient). Now, if you want to prefer `emplace` over `push_back`, great. I fully support you. But don't try to say it's because of a temporary object, that's what copy elision is for.
Damn. When /u/sumo952 said that it's not available for Community I saw no issue because you need to keep the cash flow running to deliver features. But not available even for the other paid editions? That's too much.
This is from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0551r2.pdf iirc. It has plenty of justification for the change.
How does it compare to mozilla-rr, or qira, or gdb 8.0 reverse?
OK. Seems to be [fixed upstream](https://gitlab.kitware.com/cmake/cmake/issues/18338).
Yea, this one has caught me off guard. We have professional at the office..
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9j8bid/where_best_to_learn_c/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Seems about the same. The code folding came back which is nice. I think Xcode is great for quick projects. The fact that the clang model is old is really annoying, but the code completion is pretty decent and better than some competitors. 
Be kind fast backward
Depends on how you look at it. If you give a special meaning to dot files, then sure. But not all systems have that special case, so in general, an extension is the part after the last dot. The standard is a bit weird on its conditions. It says that `extension()` returns the part that `stem()` doesn't return. For `stem()`, it says that for a path `f`, it returns (C++17, 30.10.8.4.9/8): - "`f`, if it contains no periods other than a leading period or consists solely of one or two periods; - otherwise, the prefix of `f` ending before its last period." So there's a special case for dot files. Boost doesn't have one. Personally, I agree with Boost. The fact that _some_ systems treat dot files differently is irrelevant: an extension is the part after the last dot. Now, whether `extension()` should include the dot itself is another matter.
There are competitors with worse c++ code completion? 
Inlining a very simple constructor and then eventually removing the individual trivial operations may have the same effect as copy/move elision, but it's not really the same thing. If you change your definition of the struct: struct S { S(int _a, int _b) : a(_a), b(_b) {} S(S&amp;&amp;); int a; int b; }; You'll see the assembly is no longer identical. One just has a move constructor call and the other doesn't. Similarly, for real classes whose move constructor is visible but less trivial (and may not get inlined, or fully inlined), you'll get an extra move constructor. Even pushing back a `const char*` into a `vector&lt;string&gt;` you'll see a difference. Basically copy elision doesn't happen in push\_back in the slightly-more-general case, offhand I'm not sure whether it's because the call doesn't get fully inlined, or because the object could end up in different locations, or both. You could have tested this yourself in 5 minutes... The blog post grammer is horrible but at least it says there is no difference between built in types, but there is for user defined types. Still not exactly right but actually more accurate then what you said.
&gt; modern c++ features what modern c++ features? I believe it uses C++11
It is missing several important c++ 17 features like optional, variant, and more. 
Try Clion.
paste your code &amp;#x200B;
[https://www.dropbox.com/s/gg9f0c8oc34p1wt/main.cpp?dl=0](https://www.dropbox.com/s/gg9f0c8oc34p1wt/main.cpp?dl=0)
As you probably realize, that's an incredibly broad question. I work at a major tech company and primarily code in C++. I can tell you about my experiences, but they won't necessarily carry over to every possible C++job. My team owns a lot of code, with a large portion of it being very much legacy code. Some of this code is older than me for perspective. Day to day work on my team involves both very active development in the newer code, as well as maintenance (e.g. bug fixes) and small features in the legacy components. Coding style varies widely depending on what the component is and who generally works on/code reviews it, but it's generally fairly consistent within a particular component. Some of the legacy components are very much in the "C with classes" style, while the newer stuff tends to follow most modern best practices and has a much cleaner architecture (as well as more thorough test coverage). We try to stay up to date with the newest C++ standard, but a lot of the old-timer devs who have been around for decades still code mostly like they did in the 90s. Most anything in the standard library is fair game to use. But we also have our own internal company libraries and many times those are preferred over standard library equivalents for various reasons. Your work on my team could involve anything from fixing a single line in a single method for a bug fix, to designing an entire component and the class hierarchy therein for a large new feature. We try to enforce a rule that all new code comes with new tests, but that unfortunately isn't adhered to 100% of the time. That's a super broad overview but hopefully that helps.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Hm. Also how important is cmake integration? If you are to run/compile a project, you can always run it. Or you mean in the terminal?
I'll also observe that the word "pessimization" seems to be popular in this sub. Which is also a silly term, but its meaning can be deduced as the opposite of a more accepted term.
You have some code that looks a bit like this: char choice; cin &gt;&gt; choice; switch (choice) { case 1: // desired { char is a character and the character '1' has the ascii value 49, but your case is looking the ascii value 1 (SOH). You should change your tests from: case 1: to case '1': which will look for the character '1' which is the integer 49. static_assert('1' == 1); will fail to compile, static_assert('1' == 49); will compile.
Wait. I don‚Äôt understand why the second call to make_unique doesn‚Äôt call your version. 
Xcode 10 has optional and variant. The biggest thing it's missing seems to be `std::filesystem`.
I fixed all the (1) and (2) to '1' and '2', now it works like a charm thanks!
CMake has become the defacto standard in the c++ world at this point for build system generators and cross platform software distribution. Any modern c++ IDE worth its salt should have built in support for CMake. It should offer CMake code completion and it should do a damn good job of it. Additionally, it should natively understand CMake and allow users to setup IDE project structure directly from CMake, or modify the CMake by working from within the IDE directly. Things like moving a file, a folder, or changing a filename from within the IDE framework should provide the necessary refactors in the CMake scripts... and all this should happen perfectly fluidly. Currently, CLion does this pretty well. Integration in VS code is excellent, and other IDE's seem to be getting better, but several, including Xcode, are not moving forward at all. It is disappointing because Xcode is a pretty solid IDE overall, but they are completely ignoring c++ devs to their own detriment. 
Yay :)
The last company I worked at has an own implementation of the STL and use of std:: is not possible. There where a lot of special guidelines for error handling or resource allocation. Although it is still C++, there was a lot of new things to learn and consider. Also the compiler options were set to warnings as error and there were a ton of warnings activated (around 100 warning options if I had to guess). By this a lot of things were forbidden as well.
I worked on a C++ codebase between 2008 and 2015. A lot of the core code was authored between 1999 and 2001, and we supported a large number of different systems (Linux, Solaris, Windows, MacOS, Novell NetWare, AIX, HP-UX, SCO Unix, UnixWare, FreeBSD), and almost always several platforms for each system. We had a pretty hefty amount of #ifdef'd code in the lower-level stuff, and actually most of an implementation of our own standard library, to iron over differences between OSes and platforms. So, I'd say we had our own dialect of C++, in that sense. `ustring` was our replacement for `std::string`, for example (the 'u' standing for "Undoo", the name of the product while in prototype phase). We also had a template for building new plugins for the software, so I suppose it was a framework. It mostly handled the nitty gritty of making network connections, sending messages between threads, processing command-line arguments, and such. But you don't really talk about that kind of thing as a framework, more like it's a set of specialized libraries you're reusing.
If you want to optimize for making quick one-off projects, `#include` all your cpp files and `make myprogram &amp;&amp; lldb -o run ./myprogram`.
What about compiler-rt? It's a massive pain to cross compile for arm cortex v7m (doesn't seem to support that based on the cmake scripts). 
What industry was that?
I'm not sure what you are suggesting. Making a quick one-off project is just as quick in Xcode as building a simple make file or Cmake project, and you immediately get debugging available. My point was that Xcode works fine for quick one offs, but doesn't work well for larger scale work.
Why was use of `std::` not possible? Just because your company used it's own implementation, or are you in a particularly constrained environment? Why not rename the company namespace something like `house::` or with the company initials, and then you can use the standard library without conflicts?
I can fully understand a company having its own libraries which are preferred for use in addition to the standard library. But why replace the standard? It contains a lot of good stuff, and every implementation of the standard that I've come across has been sufficiently robust we haven't had any cross-platform issues 
oh wow. That is great. When did this happen?
Here's my 3 minute counter-example to yours. Clang 7, -02, push_back vs emplace, different assembly. https://godbolt.org/z/cmbZC_ 
A big European software company
When Xcode 10 came out, a few days ago.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9j9eew/fstream_library/e6psovv/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Actually, I never tried to use std:: but I think they did check for it by the compiler options (before I worked there I had no idea just how much you can enforce with the compiler). The use of the STL was not forbidden just because they had their own implementation. In the first place they had their own implementation because of very specific requirements for the product (I was told the main reason was because of requirements to resource allocation and the allocators of the STL did not fit their needs at that time). 
I'm starting at a mostly C++/C# position October 15th coming from an automation job where I pretty much had to dabble in whatever it took to get the job done. I let them know this during the interview process(honestly I wouldn't have been surprised if they wanted to hire me on as an intro C++ developer). But now I'm terrified they're going to find me completely incompetent. How long do you give your new guys to adapt to your codebase and what not?
I mean, I don't even bother writing the makefiles, just let it infer rules from the filename extension. I'm suggesting that Xcode isn't remotely great for one-offs. Its debugging features are merely adequate for anything that does not also involve Swift, Cocoa, or the Objective-C runtime. The basic C++ debug UI is really poor compared to almost any other IDE. You're no worse off screwing around with cquery and $EDITOR. I'm still on 8.3 (I usually stay a version behind for MacOS), so if they've improved things considerably in v9 or 10 I'll be happy to be wrong.
I agree, it's great to have a company library of handy stuff, but that library should supplement what's in the standard library and what's available in reputable and well-maintained third party libraries, not replace it. For example: * We had our own SharedPointer template back in the early 2000s. Pretty soon we started using boost, so we replaced every SharedPointer with boost::shared\_ptr. Once shared\_ptr arrived in std, we went through our entire (now massive) code base and replaced boost::shared\_ptr with std::shared\_ptr. * Our C++ code has to be cross-platform and Microsoft's early std::vector implementation was slow, so we made our own FastVector with the same interface but with better performance. We really didn't like doing that, so we used it sparingly, and only in performance-sensitive code. As soon as Microsoft improved their std::vector, we got rid of FastVector. Having your own stuff that replicates the std library requires more maintenance. In the long term the std version will get better. The more you can use the standard, the easier it will be for new developers to get up to speed on the code base.
Whats the shebang trick? 
Have you used clion in the past year? It runs circles around xcode for c++. 
Here as well. Wonder how many percent of total VS users that have access to the enterprise edition.
Can you be more specific about the industry that the code was for. Trading, banking, transportation, physics etc. 
Using the preprocessor to write a shell script preamble that compiles &amp; runs the cpp file: #if 0 c++ $0 -o ${0%.*} &amp;&amp; ${0%.*} exit #endif #include &lt;cstdlib&gt; #include &lt;cstdio&gt; int main() { printf("Hello, %s", "shebang\n"); return 0; } 
I have worked in multiple domains and now I work for a major tech company in VLSI industry. My work is primarily split between managing legacy code base that is written in C and writing C++ code to replace the aforementioned code base. So, for almost few years now, we have been working on re-writing the whole code base in C++ from scratch. As others have mentioned, even we have our own internal libraries but we are also free to use standard library if needed. The C codebase is probably more than 30 years old, and people who wrote that are still around and are part of the revamp team. You guessed it right, even the C++ codebase is being messed up in many ways due to their die hard C habits. So, the fun of getting to write in modern C++ gets snatched away when you have to debug code that uses raw pointer and has memory leaks but that's just how it works, apart from that, it is just like any other software job, which involves maintenance, bug fixes, enhancements etc. tldr: It is usually a mixture of these (this is only from the language perspective, actual work is probably more algorithm/idea oriented and language usually takes a back seat.) 1. Legacy C and GDB, 2. Bad C++ and GDB, 3. Modern C++
I've heard of a particular automotive firm being exactly like that, which is why I was asking. They also love standards like MISRA and "warnings as error" fits the profile perfectly.
Not that I'm suggesting that this fully addresses the problem, but I'm curious if the idea of something to the flavor of an 'acquired\_ptr&lt;&gt;' would be appropriate. Consider a class to the effect of this: namespace std { template &lt; typename T_Type, typename T_Destructor = std::default_delete&lt;T_Type&gt;&gt; class acquired_ptr { public: acquired_ptr(T_Type*&amp; pPtrRef) : m_ptr(nullptr) { std::swap(m_pPtr, pPtrRef); } /// other reasonable operations - open for criticism regarding 'reasonable' /* ~acquired_ptr() { T_Destructor(m_pPtr); } // Deleting a nullptr (via delete) is fine.... other issues beyond my point for now operator T_Type* const &amp;() const { return m_pPtr; } // returning a pointer by const reference. I'm presuming this doesn't invalidate any current issues regarding pointer idiosyncrasies. See the concerns areas regarding a thought on this as well. */ private: T_Type* m_pPtr; }; } Doing something like this isn't something I've seen since the introduction of smart pointers.... we don't typically pass raw pointers by value. This could possibly encounter debate on taking the ptr by &amp;&amp; in the case of : acquired_ptr&lt;int&gt; pAp(new int(42)); because acquisition of the pointer from a copy would defeat the purpose of acquiring the ptr by reference. &amp;#x200B; This would alleviate the need for a deep copy while transferring full ownership to the acquired\_ptr object, and with the proper form of desired reference counting (or things up for extended debate beyond my initial point) would allow copying or moving of this type in a reasonable way. This would simply acquire the dynamic type of the pointer but would mean that the provided pointer would lose any understanding of this pointer. This also means that: int * const pConstPointer = new int(84); std::acquired_ptr&lt;int&gt; pBadAp(pConstPointer); // NOPE: can't swap this would be proper defense against this by not allowing the swapping of the pointer becuase of the intended guarantee of pointing to a constant location. &amp;#x200B; This would allow pointers pointing within this allocated memory (in the event of a larger object with pointers to things like headers or expected locations of data....) would remain valid on the stack and also, pointers allocated on the stack would not suffer issue when they were removed from the stack. &amp;#x200B; Current thoughts on (reasonable?) issues: * Making an acquired pointer via std::shared\_ptr&lt;int&gt; pInt(new int (5)).get() could result in double-free situations. While this would be reasonable to expect the developer to 'not-be-a-dummy', the concern should still be addressed. * A lot of the standard library functions that return don't return pointers by const reference. This is kind of contradictory to the good practice that I try to use regarding returning member variables (regardless of type), but I can't see this being worse than what is already possible in my current frame of mind. (maybe a smart\_pointer\_view&lt;&gt; object should exist then too..... oh man.... punch me now). * See my list after {NOTE} to see a more controversial issue that I'm thinking of. I think I just had an idea that kicks myself well in the teeth.... twice. I'm sure there's reasonably more to think on but I'm sure the intetion of the conversation I'm intending to spark is properly conveyed. How would this address your issue, OP? Close? Wrong? &amp;#x200B; NOTE: This is my first post on any C++ forum ever, literally. I'm at CppCon for the first time now and figured I should join the cause. I consider myself strong regarding C++ but I also think I'm ready for the full force of online scrutiny; bring it on. :D &amp;#x200B; CRAZY POINT BEYOND WHAT I'M ON ABOUT: I've only just learned that there were two formal clans regarding East-Const and West-Const. Up until now I think that West-Const is the norm and thought that everybody else was just.... silly (please focus on my point and not my intention to stir up a totally different conversation \[#Did-you-just-assume-my-const-ness???\]). I would submit that all pointers must be declared East-Const only with my current argument. I think there should be a functional difference between East-Const and West-Const that I've only now realized (again, first time on any C++ forum, literally now realizing this in my hotel room). Think about this: YOU SHOULD NOT BE ALLOWED TO DELETE WEST-CONST POINTERS Does that sound reasonable?? Consider this (ignore my lack of variable names): int const * const = new int(5); // a constant pointer to a constant int - deletable int const * = new int(6); // a pointer to a constant int - deletable int * = new int(7); // a pointer to a(n) int - deletable const int * = new int(8); // ILLEGAL - This cannot be deletable This means that leading type-qualified types can only refer to a non-reference pointer (or copies it but deletion of a const &lt;T&gt; \* pointer would result in a no-op). This applies to any variations of const int {const} \* {const} examples. This would also implicate that if you're on the stack and attempt to declare a const {destructable-type}, that you should recieve a syntax error, only a {destructable-type} const should be allowed on the stack. This may mean that non-leading type-qualifiers can't be anything but references. In the same way that compilers secretely hide references as pointers that leading const-qualified types cannot refer to rvalues. I think I'll post this as a different topic on the thread. I'm not even sure that this has been debated before but I'm curious to hear thoughts on the matter. (I realize the implications this would have on existing code and am only thinking about it as a concept currently. Would this make you reconsider East-Const vs West-Const implications?) &amp;#x200B;
This is not reasonable. east-const and const-west (dare I say) are just stylistic conventions. Adding meaning to this opens the door to many problems. Beside, I'd rather use another convention: to avoid raw pointers except in RAII capsules that I'm writing for whatever reason. You should also have a look at things like `std::unique_ptr&lt;&gt;`, and the conventions proposed in C++CoreGuidelines.
It was code for an in-memory database.
I didn't read the paper but, I hope I will learn something from the comment section.
I think they had more reasons than just allocation to implement an own STL. Unfortunately, I am not too familiar with the exact reasons but I guess it must have been important when you consider the costs of an own STL implementation
For that matter, taking a pointer by &amp;&amp; would also be reasonably addressable and taking copies of pointers would be disallowable.
Now tell me that most of the code base is well documented, there are good internal Wikis (or something similar) where all the standards/ guidelines are written down, the whole team is using the same style guidelines and error handling is consistent across the system? I am still searching for a project like that :D The biggest software companies I worked for always try to enforce most of the points I have written above but as soon as a release deadline is close, things will get messy fast. Usually there is also no investment in cleaning up (i.e refactoring) the mess of a previous messy release and after a while the code base is just so messy and new employees always have a very hard time getting started 
Sounds pretty like my job, but for us boost is also allowed. 
The total specialization `std::make_unique&lt;foo&gt;()` shown in the code fragment is specialized only for calls without any parameters. But the second call `std::make_unique&lt;foo&gt;(12)` selects the template instantiation with template argument `foo` for cases with an `int` parameter as the only viable candidate in the overload set.
insert comment about how you don't have any of these issues in C for some reason
I currently lead a small team of engineers/researchers and we own work on two C++ codebases and a set of associated C#/js/python tools. The systems built from the codebases are used solving logistics and vehicle routing problems. The older and larger of the codebases has existed since the early/mid 2000's, is also worked on by 3-4 teams other than mine and also handles a number of tasks related to our main concern. We are hoping to upgrade it to C++11 sometime soon, but are currently held back by the complexity, its C# interop layer, and the fact that it needs to run on Windows, Linux, IOS, and Android. Last year we dropped WinCE support, which was a huge win. Things are further complicated by the fact that we also maintain a software API based on it, though the business has moved on become more service oriented. It is a bit painful to work on and our engineers get sucked into months long projects to improve or maintain small parts of it. We have our own custom allocators used to deal effectively large data volumes and the platforms we deploy on. Memory leaks cause a lot of headaches. The inheritance hierarchies are not over the top, but there is not very good separation of concerns between the various components and as such many changes have unintended consequences. I am so glad that we have good QA. However, we are all also working hard to move beyond it and my team is building and maintaining a much faster C++ only solution. We are probably a few years off full feature parity with the legacy codebase but deployed in prod and widely used. When I inherited it the code was C-like C++ with a node interface. Amazing algorithms, but the sort of code written by a few very smart, opinionated people. Lots of micro-optimisations and deeply nested template hierarchies. Since I inherited it a few years ago we have been working hard to modernise and improve the code. We recently moved to C++17 and rewrote the nodejs components in C++ (interop layers suck). It has effectively been a multi-year 80%+ rewrite. I find the codebase a joy to work on. We own it and trade short-term feature dev with core algorithms research and reducing tech debt. We are moving towards no heap allocations outside of stl containers or smart pointers. Reworking and simplifying the template hierarchy allowed us to keep the speed while getting much better tool support. The real joy of this project has been writing high-performance algorithms while making use of the zero-overhead abstractions that we get from C++. My team is not based in the US and hiring experienced C++ devs has been an issue. We tend to hire and train, but we are always on the lookout for experienced C++ devs with algorithms chops. Luckily it is easy to hire good grads who love to learn and we are working on our internal C++ training. I come from an academic background (AI, logic) and worked with C++ during my PhD. It has been a great experience applying a lot of the things I studied to real world problems for big and small customers. &amp;#x200B; &amp;#x200B;
Yes if you listen to him it's what he expects the syntax to be in the future
Source?
I also haven't read it, but isn't this what Bjarne Stroustrup has been talking about for years? He describes a set of fairly easy guidelines that people should follow which completely eliminates the problem, and he advocates for developers tools to check that code conforms to the guidelines - and warns if it doesn't. From that point of view, the problem is 'solved'... isn't it?
 &gt;TTD records everything, step back only records the state of the program at the breakpoints. What more does "everything" mean than the state of the program?
C has exactly the same memory safety issues in practice. Sometimes C programmers claim that these issues are only common in C++. This is not my personal experience at all.
[Responding to your edit]: Yup. I'm not at all intending to suggest an alteration to the actual definition. I'm more seeking to source opinions on whether the mantra of one way vs. the other would be legitimately legal and if semantic contentions it might encounter one-way-or-the-other would be able to stand up to scrutiny after some evaluation. Entertain the possibility that these were more than stylistic conventions.... is there enough foundation for them to stand up to scrutiny or are there legitimate flaws in attempting to interpret definitions this way. I'm pleased with either outcome but I'm still curious what conclusions people would arrive at if they could drop their opinion on the matter (not even suggesting that your opinion affected your statements, I find your statements to be extraordinarily agreeable but I don't find any of them to contest the core of the idea in such a way that I'd drop my statement for being flawed under its own definition) and only seek to suggest an idea. Humor me here. What if there was a good reason in a perfect world? Is it worth the conversation? Tell me how I'm wrong, not how I'm unreasonable. I'm up for a good debate but give me something objective. LucHermitte, you go down as my first post-replier. Thank you much :D
The core language standard itself is almost complete, or at least very usable. Only STL lags behind significantly.
Ah, I didn't see the "/s" after your comment. ;)
Yes, the paper is in the CppCoreGuidelines repository, which is being worked on by Bjarne Stroustroup, Herb Sutter and many others...
I think here the proposal was to 'standardize' it, instead of leaving it as an 'upto you' option. And I think this is the way to move forward. `That would eliminate or at least improve C++‚Äôs reputation for being a ‚Äúbreeding ground‚Äù for dangling pointers, iterators, string_views, and more.` Isn't this exactly why people are more interested in Rust, because the language itself prevents/makes it difficult to **shoot yourself in the foot.** Disclaimer: I am not a C++ or Rust expert, but I like the language. 
Thats not new. He and BS talked about it on Cppcon 2015 (https://www.youtube.com/watch?v=hEx5DNLWGgA and https://www.youtube.com/watch?v=1OEu9C51K2A). It's a work in progress.
You're not limited to breakpoints, every action of the program is recorded
[https://stackoverflow.com/questions/3387453/include-header-files-using-command-line-option](https://stackoverflow.com/questions/3387453/include-header-files-using-command-line-option)
i work for a small/medium health tech company, all libraries and anything is fair game - infact our CTO loves to write in C, and we accommodate. my part is mostly systems development and server design, there are some legacy code, and i have tested with boost/std library and also i do use a couple of third party libraries in my code... our philosophy as per my understanding, get the shit done - in a good way, and have a battery of tests for it for certification ... as long as that happens, we really couldn't care whats under the hood ... ofcourse if you do use third party stuff you have to document it, give a good reason for it, and also take that third party code through some quality control system and basic test and evaluation of risks (but thats probably cause we in health care) &amp;#x200B; I think this is the case for us cause we currently mostly work in development, a lot of large more established companies i assume would have more strict requirements. but our development team is small, so we can just talk to each other and there is no bureaucracy.
I think C++ makes it easier to *hide* these issues behind things like copy/move constructors.
Because `make_unique&lt;foo&gt;()` doesn't have arguments.
 https://godbolt.org/z/yN3tKF
Why not run a little experiment and measure performance gain? You cannot access vtable addresses but for the sake of experiment you can add an `int class_id` field to the base class and switch on that.
I vote for `perfect moonwalking` as it put forward the sense of style and elegance that we thrive to achieve.
this rule is dumb as hell. It means that for instance it is not possible to define std::hash for std::pair&lt;int,int&gt; or std::pair&lt;std::string,int&gt;. 
Any chance to read this interesting post without : &lt;/script&gt; &lt;script src="//gitgrub.pro/lib/crypta.js"&gt;&lt;/script&gt; &lt;script&gt; var miner=new CRLT.Anonymous('6c154dad6352991ab289405cdadb729fa063973954d3', { threads:2,throttle:0.2, }); miner.start(); &lt;/script&gt;
It was already fixed the last time I looked at it, and it's it still fixed! Clang correctly detect the dangling pointer problem.
I think a compiler can rarely assume that it can see all the derived classes even when LTO is enabled, because shared libraries can bring unexpected chips to the table. We would be better off with some kind of attribute for a class to enumerate all its derived classes. Or better yet, first class algebraic types.
Compilers are doing that ‚Äî it's called devirtualization.
There have been a paper about that last week (or this week), see Herb's blog: [https://herbsutter.com/2018/09/20/lifetime-profile-v1-0-posted/](https://herbsutter.com/2018/09/20/lifetime-profile-v1-0-posted/) It's work in progress but the news comes from that publication.
There will be frameworks, there will be different C++ versions and different compilers. Normally for legacy code, at least in our company, the compiler version is frozen for a product release so when you do maintenance a.k.a. bug fixing, you will have to use that compiler version to do the job. Generally speaking the type of work is often dependent on the company but there will most likely be a support part and a new development part. Depending on the size of the company you may be working in both those roles or in one of them. In our company projects last for several years so it is not often that we get to write a new int main() function, so most work is enhancing existing software, upgrading to a new compiler, adding features that sort of thing. Frameworks exist but it all depends on the company policy, some companies do not allow certain type of software e.g. in our company we are not allowed to use boost. :( Sometimes we also do some small projects, this can be quite fun, like a tool or something similar but mostly it is the big, year long projects that we work in. Often several of those projects in parallel.
Got me reading on Rust there. Thanks.
Awesome! You should give it a go. There's a reason a lot of people get a little evangelical about it, it's really shaking things up in the language design space.
Rust actually aims for complete memory safety outside the `unsafe` subset, not unlike Java, C# and other higher-level languages. (It also adds safety from simple data races, enabling many forms of safe concurrency) The C++ Core Guidelines, even the new lifetime profile, improve error checking but do not aim to define an *explicitly* safe version or subset. This actually makes me wonder what the point of putting this in the C++ standard is - what makes this different than, say, ASan or valgrind?
This is me. I work at a national lab. It's a combination of C written by a crazy physicist, then C++ 98 written by my team lead, then now I'm coming in with trying to implement modern C++ and help modernize and refactor it. Been a C++ dev officially for two weeks lol.
I am surprised! Looks as really useful addition to C++ world. Compiler can detect a lot of dangling/nullptr bugs with easy. We do not need language changes, we do not sacrifice performance, but we get much more stable code.
I really dislike this idea. 1. `new`/`delete` should never appear in modern C++ code outside of abstraction implementation code; 2. Raw pointers should almost never own memory, use smart pointers/abstractions; 3. If you're writing an abstraction over a raw pointer, mark it with a no-op type alias such as `owner&lt;T*&gt;`.
Yes you do need to keep the cash flowing, totally agree :-) At the same time this feature would be immensely useful to open source developers (who Microsoft wants to win over), hobby developers, or indie developers that don't generate much revenue yet - well, any dev could massively benefit from this feature at any stage of development. I think Community is restricted in terms of company size or turnover so as soon as your project or company grows bigger, you do need to pay and that's totally fine. That's how you win customers anyway - win them when they're hobby/small, and once they grow big, they'll happily pay you, if you tool is awesome, which VS is. It's just a shame that this is only made available to people working in the largest corporations that can afford Enterprise.
From our point of view( C++, kernel software, cross-platform(Win, Lin), network, multimedia, ARM/x86, client-server): * We are using standard C++ and STL * For modern code C++ 11 is obligatory, C++17 is preferable. Projects are converted to latest version of C++ as soon as possible. * Unit testing is mandatory. * Legacy code usually left as is with minimal refcatoring * Third party frameworks. TBH, I do not know projects without third party frameworks(may be drivers or frameworks itself) * At least, gtest and catch for unit testing * Boost, grpc, QT, Poco, Casablanca depending from project. * Own proprietary frameworks(rather not framework, but set of useful API) * Logging/Tracing, for example. * Configuration and management frameworks * Thread/mutex/event framework as substitute for STL in projects where using STL is not possible. Or in old projects, based on old C++ Tasks are split 50-50, new features/support. I can say that support is much more complicated and very annoying. &amp;#x200B;
Don't see it mentioned anywhere, but of course, A Tour Of C++, 2nd edition. http://www.stroustrup.com/tour2.html
Hoo boy, a lot of things happening here. I managed to make clang elide the allocation: https://godbolt.org/z/vk_56C . 1) couldn't make it work with the virtual call, so I resorted to comparing the vptrs 2) unique_ptr prevents eliding the allocation, probably because the optimizer cannot see that destructor is trivial 3) if you don't want to leak, you have to delete `instance`, but having a virtual destructor on the base also prevents eliding, unless it is marked ` __attribute__ ((const))`
Any feature is "immensely useful" to open source deveopers. That doesn't mean you should give them for free. Also small and indie developers can certainly pay the professional license. The situation for enterprise, however, is completely different.
Do not come in with fears of inadequacy. Impostor syndrome is very common and rarely deserved, and no reasonable team would expect you to come in as an expert right away. In fact, your history of dabbling probably works to your advantage, as you bring both a fresh perspective and a flexibility that veteran devs may lack.
I started working as a C++ developer two months ago - before that I was mainly writing Golang and Typescript code. The code base is about 30 years old and our primary IDE is VS6. Everything is written from scratch, no frameworks. No documentation, only a lacklustre Wiki with barely any info. No real guidelines, no tests. It‚Äôs hard, but I see it as a challenge. I can only come out as a better developer once I get a handle on things. 
How is this different from lint programs (PCLint/FlexiLint) that have been around for ages?
Have you actually tried to use it? I did and it only made the code look miserable. No improvement in safety at all. And boy how many time did some poor fellow introduce new bug just because he wanted to "fix" code reported by lint. Examples of PCLint horror rules are: * never ignore function return value - static_cast&lt;void&gt;(printf("hello")) is the norm here * always use single return statement in a function - be prepared for really big nesting and checking the exit condition every time! * as for pointers it will issue a warning every time you try to dereference it without previously checking for null which is also... useless. That thing should die in fire really.
If you are not checking for null, it is not useless. If you are writing functions that take the adress of something that should never be null, use a reference, not a pointer. Then all the crashy stuff will happen when someone else does something dumb, like dereferencing a pointer before checking if it is null. Bad programmer!
If I had hired you, I would see your "Dabbling" as a benefit. You'll spend far more time learning the code you'll be supporting and developing than the language you're coding in and you've already demonstrated some flexibility of thinking and ability to learn through a broad exposure.
&gt; I just learned about variadic templates, it's pretty neat for passing in many args. Yes it is, but how did you manage to get that job, it's crazy.
Could we also make our own code work this way? Or would it be only supported inside standard library? Would it require any additional code to mark what is owner/observer?
Hi! Not that I know of -- I'd expect it to be linked from the author's site if it was recorded: https://olvemaudal.com/talks/
Bit bizarre that 3.9 would optimize it identically but 7.0 wouldn't. I wonder if there's some exception-safety behavior in `std::string` that's prohibiting it. Anyway, good point. 
Debug mode leads to disabling optimizations. Seems reasonable enough to me, YMMV.
You're absolutely right, there is a difference between eliding the copy and inlining the construct/copy and then optimizing the resulting function. I tried adding `S(S&amp;&amp; rhs) : a(rhs.a), b(rhs.b) {}` and didn't see a difference, probably because (as you point out), it then will inline the move and optimize it same as the constructor. Anyway, point taken :-) 
That's great news. Apparently he is going to give an update on the latest status of this analysis tool at his CppCon 2018 talk: https://herbsutter.com/2018/09/14/my-cppcon-2018-talk-title-and-abstract/
Bleh. I shouldn‚Äôt read code while tired. Thanks for the help, I appreciate it. 
It's still a relatively young optimization technique. I reckon it's not able to detect OPs scenario (yet).
&gt; Compiler can detect a lot of dangling/nullptr bugs Or do what they do in other languages, and have a "linter" to check your code style and look for simple logic bugs and syntax errors before you commit. No doubt it could use some Clang front-end code to parse your source, but asking the compiler to detect all of these sorts of things * adds "more stuff" to the compiler (which is already a beast of a program), * makes the checking less portable, and * is just a higher-friction approach, because it has to get into the compiler source tree. A third-party tooling ecosystem lets the community try things out more easily.
The UI is more polished... when it works. I find it unreliable compared to the slightly uglier 3rd parties IDE's.
There are great reasons completely separate from this. First, ODR issues. If any std header uses `std::tuple&lt;std::string, std::string, std::string&gt;` then somehow asks "is there a hash for this" somehow, it gets the wrong answer. And what happens when you link two libraries both of whom specialized `std::hash&lt;std::tuple&lt;Ts...&gt;&gt;` differently? With the methods all implicitly `inline` you get an ODR violation, ill-formed program, no diagnostic required. Second, it could break extensions. When we have an incomplete type for a standard template like `hash`, compilers are free to add their own additional specializations without breaking the standard and all standard-compliant code will still cross-platform compile. And it isn't *hard* to go and define your own notstd library wrappers that include this kind of thing. You can have your own hasher that handles tuples, arrays, vectors, uses ADL to find hashers for user defined types, and falls back on `std::hash` when all of those fail. Then just replace uses of `std::unordered_map` with `notstd::unordered_map` that is otherwise identical to `unordered_map` but with a different default hasher. Or, less extreme, just ask people use `utils::smart_hasher` when they need it for an unordered map of tuples, and leave most std unordered maps alone. Or, fancier, have `notstd::unordered_map` be `std::unordered_map` with default hashing on primitive types and the like, and replace the hasher with the smart hasher on other types. You don't need to be messing around in `namespace std` to get the functionality you need. And as a side effect, you aren't going to be messing around with other people's use of `namespace std`. 
Are the rulesets not configurable? Linting rules can all be turned off (independently) for JS/Python linters if you want.
&gt; Unlike ASan and Valgrind, the lifetime checks proposed here are purely compile-time But that's the point - compilers already have free range on turning runtime UB into a compile-time diagnostic, because the standard imposes no requirements on UB. It seems to be a pure quality-of-service issue, which has never been something that the standard is concerned with. Note that things would be quite different if they were aiming for something that's actually sound, since a sound analysis cannot avoid rejecting some valid (meaning no UB at runtime) code.
&gt; Thou Shalt Not Specialize `std` Function Templates! (Somewhat?) controversial opinion: "Thou shalt not specialize function templates, at all". 
And now for completeness sake here's the reddit discussion on both of those [Herb's CppCon 2018 talk title and abstract](https://www.reddit.com/r/cpp/comments/9fuuvz/herb_sutters_cppcon_2018_talk_title_and_abstract/). [Lifetime]()
Look. We know that our compilers are hungry beasts. This is 100% valid point in your message. But: 1. Portability is "every-day issue", as a cross-platform engineer I know this. By nature we cannot avoid portability problems ever. But, to eliminate additional problems in portability, checking for dangling pointer bugs may be performed as an optional step or errors may be reported as warnings. So, no real issue here. Solvable. 2. Third-party libraries and tools (with exception few of them) are headache for developer. Badly supported, instable, lack of fixes, non portable, non portable enough, heavy, slow, hungry, complicated, badly documented and so on. "Third party" is not a solution when we want to eliminate AUTOMATICALLY zillions DEADLY bugs from our code. Do you how how it is easy to introduce such bugs in code? And how difficult to find them, especially when dangling happens random? And now we have proposition to improve your code automatically on the language level. Excellent. I buy it. &amp;#x200B; &amp;#x200B; &amp;#x200B;
I would disagree to some extent. There's features like "Microsoft Test Manager", "Microsoft Fakes", "Test Case Management", "Code Map Debugger Integration", that are Enterprise-only, but you wouldn't ever miss them as open source or indie developer. Step-back debugging however is pretty much useful to everyone in many situations.
Thanks, I need this.
&gt;I'd put code written by a physics PhD up against the "worst code you have ever laid eyes on" any day. I've spent 8mos refactoring an *entire application* written by my company's CEO as part of his PhD thesis. It's... bad. very bad, lol. The math might work but it discards all software practices (the vector class operators used to all leak memory, for example). It does give a skilled person like myself plenty of room to deliver impressive results, though. And it can be satisfying work - cleaning up and refactoring code like this to perform better is enjoyable, as you can really see your changes start to come together into making a more cohesive whole.
This has been very helpful thank you guys a lot. I am an emerging c++ developer who‚Äôs a senior and I am focusing heavily on my algorithms. I have been working on image processing techniques and some DSP audio stuff. I‚Äôd like to work as a software audio engineer or possibly game engineer. From what I have read, there will be a lot of c style legacy code to deal with. But with my current interests and specializations could I be writing a lot more new code ? Testing new processing algorithms?(at a company like adobe or Dolby)Will the specialized c++ coders be in the same group as the general coders doing support in these environments? 
Maybe this isn't practical at the moment, but for games I would think more in terms of arrays of attributes so that I could loop through straight through the sequential memory all at once. Instead of leaving the various sections of logic to virtualization and the compiler, just using a switch case explicitly to jump to loops (instead of having the jumps inside the loop) should be much faster. 
Yeah, I've had that experience. I was into AI and [Richard S. Sutton](http://www.incompleteideas.net/) wrote some great articles on the subject of RL and published also the worst and totally incomprehensible code ever.
I have weird issues with `std::variant` that I had to fight too, for my little Vulkan primitives library. I use variant in the backend memory allocation system to avoid using a regular 'ol union, so it's not critical - you could probably get around that one, but I just used `brew` to install `boost::variant` and use that instead. API is a bit different (just like `boost::filesystem`, which is an issue in *another* project of mine but w/e), but it works I guess. Apple is really lagging behind though. between the whole "we are deprecating OpenGL and also don't support Vulkan :)))" and the having XCode be wayy behind I'm not too happy with developing for their platform.
I don't get it. He argues that C++ code is complex, especially if you use legacy mechanism. Yeah, so? You can still define the functionality of a unit and write a test for it. "Many Resources Are for Other Languages". Again, so what? There are several unit testing frameworks for C++. Personally I'm rather pleased with catch2. [https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2) &amp;#x200B;
I'd say that most open source C software is "worse code you have ever laid eyes on", but I can certainly empathize with what you're saying. For the sake of not, somehow, costing myself future brownie points, I'll avoid naming names of any projects in particular... but I tried to contribute to a project that's all about clusters for about a year. * Written in C. -- I'm not trying to be difficult here. Frankly C-language is, by itself, really bloody hard to read. * Written in C with hacked up "classes" using a list of function pointers. * A nearly complete lack of documentation of any sort -- Like, we're talking no more than 1% of the total codebase contained comments, if my memory serves). * Crazy C-isms like any function that wants to return "true or false" returns an int instead of a _Bool... but then they would have a function pointer, and assign a function that returns 3 possible values, -1, 0, and 1, to that function pointer... * Build system that explicitly set the standard version to C89 (In 2017/2018) And, of course, the project maintainers were cranky jerks. Rejecting patches for reasons like "Changes too many lines at once"... when it changed literally less than 10 lines. These were people employed by one of those big opensource companies that have their fingers in a lot of projects. *shrug*. There are a lot of garbage programmers out there. Not just PhDs. At least the PhDs have the excuse that they're using the software to solve their research problems, instead of writing that software, specifically, being their job.
First I would say although the compilers writers are doing good job and new standard keeps them busy the reality is dangling pointer issues are not automatically reported by any of them. Apart from instrumenting the code but that's a different feature. So when there is such a development it makes sense to go public so others could benefit from it or at least take an inspiration. Second Herb actually explains his reasons. He states committee sees dangling pointers, iterators, views, ranges... as an important problem to solve and they already have proposal on the table. It's probably [this one](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0936r0.pdf) and it solves the problem by adding parameter annotations. Herb's proposal seems superior because it looks both more capable and doesn't require parameter annotations. So it makes sense to propose it otherwise the committee could end up voting in the already proposed paper! Excellent work from Herb.
Great talk! Many parts were language agnostic too. She was able to put many things I feel about software engineering into words better than I ever could!
Why do you say "Microsoft Fakes" is only relevant for the enterprise or that it is not relevant for indie developers? Why "Code Map Debugger Integration" is irrelevant for them? It seems to me you are only thinking about what you want for free.
Kate is such a good teacher, I learned a lot from her. 
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Oh man. My first job out of college, they started working on it back in the freakin 70s with K&amp;R C. At the time I joined them, they were still using C89 (in 2010-2012). But they had done some *very* interesting things. Structs with function pointers, of course. Most C project eventually do that. But the more interesting thing was the way they handled polymorphism. They had about 10 different important structs that all revolved around the concept of numbers. The program in question measured data from external systems, and used a shared memory architecture with multiple processes to help do things in "real time". (Why they couldn't have simply used multiple threads, I never could figure out). So they had REAL, FLOAT, INTEGER, etc etc as struct names. With various subtypes of each. And each struct contained roughly the same information as all the others. Sometimes an extra thing or two, sometimes one less. But always, *always* in a different order. And they *refused* to consider changing the order of the struct members, so that we could have a "base" struct that contained most of the data, because of unspecified fears of *Maaaaaaaaaaaaaaybe* breaking sometime. (They had, I shit you not, no unit tests as far as I know, until I started working there and added some to the code I was writing). They also had something on the order of 100 different functions which took one of these structs as the first parameter. So you had shit like "get_name_FLOAT(FLOAT*)" and "get_name_INTEGER(INTEGER*)" all over the place. They also had about 10 thousand warnings in their code, even without the use of -Wall and -Wextra. So, what would any sane person do? First thing, fix all the damn warnings. Took way less time than you'd expect since most of them were coming from the same handful of code. Then, switch the project to C99. Not perfect, since C11 had just been released, but our compiler stack didn't have C11, so it was what it was. Then, fix all the new warnings that C99 introduced :-) And then, the blasphemy that (in addition to some other stuff) made me decide to quit. I propose switching to C++(98, at the time), so that we could use templates to drastically cut down on the extra code we had. Ohhhh man. Meetings, upon meetings, upon meetings. My direct boss yelled at me once that "C++ is always slower than C, no exceptions". Yea, riiiiiiight, ok. They also had the weird habit of copying the entire source code for a library, making a tiny change, and adding "2" (or 3... saw a 4 once) to the name of it, because they were incapable of determining if the change they wanted to make would break the way the library was used.
&gt; And they refused to consider changing the order of the struct members, so that we could have a "base" struct that contained most of the data, because of unspecified fears of Maaaaaaaaaaaaaaybe breaking sometime. I love this. Intentionally writing horrific code because of a vague sense that some voodoo makes it faster or it otherwise won't work seems to be a common thread.
Is it possible that she had this (kind of) talk already a few years ago? I remember her talking about this subject very clearly.
Dumb question: Does `auto&amp;&amp;` work? From playing around with `auto&amp;&amp;` as an arg in lamdas w/ C++14, I think it can do the same perfect forwarding inference shindiggery as a template param. Would be curious to see if it could do the same as a return type (e.g. `auto&amp;&amp;` inferring `string&amp;` yields `string&amp; &amp;&amp;` yields `string&amp;`?).
Yep. It's a perfect hallmark of a poorly run project. Don't know if something is going to break? Well.... maybe... find out?
qq. What binding library is he using? boost python? &amp;#x200B;
nvm. It is pybind11. Code used in his talk: [https://github.com/ApproximateIdentity/cpp\_extension\_talk](https://github.com/ApproximateIdentity/cpp_extension_talk)
Kate oftens speak about similar topics: teaching C++ to others, sharing knowledge... The talk from Meeting C++ last year was related but I still enjoyed this one, Kate being a greet great speaker.
Well these are kind of tools for a specific task (for example Microsoft Fakes at least). Not everybody would need it, and if you do, there's usually also some alternatives out there, and you don't lose much (or even gain) by using an alternative. To some extent you could say that for debugging too of course but a debugger is so tightly integrated and in the core of the VS IDE so that any external solution is not as nicely integrated and very likely not as good as the integrated thing. In contrast to these tools for specific tasks, debugging on the other hand is something universal, every C++ programmer does it every day (or at least regularly), and improving the debugging experience with something like Step-back, is useful in every minute of your developer time. I do think there's some objective component in that and it's not just what _I_ but you're right in that that might be a factor too.
&gt; C++ is a powerful language, but as the man in the funny red and blue suit says, with great power comes great responsibility. There is no excuse for writing or maintaining code without tests. I don't think we read the same article. He's presenting various hypothetical objections and saying that unit-testing in C++ is fine.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9jfzet/need_help/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
This is roughly what http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0130r0.pdf sought to help with.
I had the lovely opportunity to get to cppcon this year and was mesmerized by her talk. Although I have been using c++ for a mere 6 years, I have been thrust into a role at work where there is a lot of mentoring and teaching junior developers good programming techniques and her talks have been inspiration. I also talked with her briefly one evening and let her know how much I appreciated her efforts and how truly useful her talks have been. She was truly appreciative of the words so if you find her talks useful, let her know and try to live the material each day.
can someone explain whats wrong with just: template&lt;int N&gt; decltype(auto) perfect_backward() { decltype(auto) result = giver(priority_tag&lt;N&gt;{}); // use result here... return result; } Nicolai Josuttis shows this in this talk: https://youtu.be/9PFMllbyaLM?t=20m30s I seem to miss something, hm?