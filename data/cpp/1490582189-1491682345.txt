I think it's kind of surprising how hurt and threatened the C++ community is with Rust. Some of the comments are downright angry. I went to CppCon this last year and was a bit shocked that Rust wasn't mentioned even as a point of comparison. It's a language that targets a very similar demographic... is getting a ton of press.. and you know.. maybe there is a good reason for that? Maybe there is something to learn? These kind of articles are nice b/c they illustrate to me what's so exciting across the fence. (I've never used Rust, so for me it's been a bit of a mystery) The comments reminds me of how C++ can be such an insular bubble that put it's fingers in it's ears when it hears criticism
Understood. I'm willing to work on a proposal.
Adding methods to primitive types like that is both interesting and horrifying. It's like Java made love to C++ and we got Rust O_o
Indeed. It's like a forced meme at this point
I'm getting real tired of Rust programmers infesting C++ communities to go "here's 12 reasons why I think rust is better" like... who asked... It's like some jehovah witness door-to-door thing going on.
That you don't like the syntax doesn't change the fact that the semantics are identical. If you want to spend more time typing, and forcing other people to read boilerplate, that's certainly your prerogative. ;-]
That's not entirely true. There's a reason to use reinterpret_cast over c-style ptr casts. Just as there's a reason to explicitly state that you are forwarding over a c-style cast.
In every C# codebase on which I've worked where a property did something other than a field access, that turned out to be a massive foot gun. In C#, properties are a means to binary stability, a feature they cannot offer C++. Properties work. Fields work better.
Crazy I know.
&gt; I can think of many more cases where using unsigned is good (for example, logically some values can not be negative, so giving up and additional bit hurts logic, readability, and effectiveness). Additional logic? That's precisely what you get when you use unsigned for arithmetic! (Puzzle: is `0U - 1 &lt; 0` true or false?) How does Rust handle signed/unsigned? Are there implicit conversions? (I hope not.)
You just write generic functions. The definition of `swap` in Rust is: fn swap&lt;T&gt;(x: &amp;mut T, y: &amp;mut T) In Rust (because the way it has first class ownership makes its memory model a bit simpler than C++), swap is completely generic &amp; you don't need to dispatch to any methods of `T`. A better example is something like `min` or `max`, which have signatures like: fn min&lt;T&gt;(v1: T, v2: T) -&gt; T where T: Ord Here, `T` is constrained to implement the `Ord` trait, and ultimately this function calls methods from that trait on `v1` and `v2`. But because they're parametric, its guaranteed to call the same methods using the same logic, regardless of what `T` is. That's what is nice about not being *ad hoc* (ofc this is also a limitation).
I think the reference work stealing queue was not broken, its my misunderstanding about c++11 memory orders. Thanks for your advice.
Thank you for suggestions! I don't have much time now but maybe one day. :)
Of course, Rust isn't some kind of magic. The thing is programmers are human beings and human beings are well-known to make mistakes. Rust protects people from most common, dangerous and difficult to find ones. Even if you have formal model, you can make a mistake in implementation.
Keep in mind that i am saying these things as person who has no experience in rust. Obviously once one knows the syntax it stops being magic, but i would argue there is still amount of mental strain remaining due to all these complex ideas expressed in suboptimal way. Lets begin with hello-world: ```fn main() { // The statements here will be executed when the compiled binary is called // Print text to the console println!("Hello World!"); }``` We got `fn` keyword. We all know that abbreviations are not a good idea for variable names. Why would it be a good idea for language keywords? Python also used abbreviation `def`, however paired with 4 space indentation it aligns function definition name with rest of code. Reading it is aesthetically pleasing. I do not see any gains there. Sure it is short, but considering code is written much less than read/debugged gains are irrelevant. `fmt` is another one that fell victim to being abbreviated. `mem` too. Imagine if everyone started naming their packages and variables that way. This is not cool. `println!`? Exclamation mark after a function name? This is new to me. This is magic. Then we have things like `&amp;`, and `&amp;mut` and uh.. `self.0` in `write!(f, "{}", self.0)`. Or even `for (count, v) in vec.iter().enumerate() {` lacking c-style parentheses. Language clearly adopted c-like syntax and then this change seems to serve no practical purpose other than change for the sake of change. This ofc requires people to rewire their brain to adapt to new style and i still fail to see where gains of this change are. `write!(f, "{}", v)?;` - question mark at the end of function call? More magic symbols. I just looked at some starter tutorials. Good code would be such that untrained eye in that particular language could tell what is going on. I understand rust has new ideas that need some kind of syntax to be expressed in, but the way it is going now it is more complex than it should have been. It is very unfortunate though, because it could have been a vast improvement over c++ in all areas where currently it is only improvement in security.
Two letter keywords or three letter stdlib package names are no less silly though.
Sorry, I actually read the proposal after this comment, and it seems that they re-define bitwise XOR as well. However, I think this proposal has very little chance of getting accepted due to backwards compatability.
C++ is not C# nor it would be better off imitating C#. It requires a different way of thinking. Besides, &gt; Properties are a proven concept And this is the top argument? being "proven" in other languages does not mean that it's a good fit for C++. Both the basic premise (properties being good) and the implication (properties are good in other languages, therefore they must be good for C++) are easily challenged. &gt; Properties are already supported in C++ anyway (using __declspec(property)) Vendor-specific extensions are not "C++". It doesn't make sense to use this as an argument when you are arguing about properties in the Standard. 
Typing is zero effort; reading boiler plates is easy; unpacking short sharp succinct expressions is often quite hard. `std::forward` is pretty clear in its meaning but to me `FWD` is something to do with four wheel drive. `decltype(x)(x)` would probably leave me puzzled as the `decltype(x)` even lacks brackets around it to signify it is a cast.
nvim obviously ;)
(Forced) garbage collection has millions of people that like it and it is still a bad idea. (I should probably point out I am not against properties in the same way)
C# is a fine language and I don't see it as "dumbed-down" (and frankly this is unnecessarily insulting to C# devs). C# just chooses different engineering compromises than C++, giving up certain controls while gaining a few nice features in return.
I'm not masochistic enough to see handcuffs as "nice features"; to each their own.
It's hard to get wrong if you know what you're doing (you would seriously be against making it clear it is a cast?). However most of us do write code that is maintained by other people. I spend most of my day unpicking assembly and early 1990s C (with lots of uncommented bit twiddling and single letter variables). No idea what I'm doing at all. A bit of explicitness would really have helped me. :) 
Thanks for taking the time to respond- glad to see another perspective! &gt; We all know that abbreviations are not a good idea for variable names. Why would it be a good idea for language keywords? I don't think this holds true in general. For example, we use `i` for loop indices because making them longer would actually *hurt* readability by distracting from the real purpose of the code. We use punctuation for things like arithmetic and pointers for the same reason. `fn` is so common that there's no need for it to be longer- it would only be distracting (think `function` in Javascript). &gt; Exclamation mark after a function name? This one is more of a tradeoff. It is mysterious to begin with (though that in and of itself cannot possibly be bad, since that's an argument against any notation not learned as part of basic literacy), but it's very simple and grants a huge benefit to readability once learned- it denotes a macro. C and C++'s macro system is completely invisible except by conventions like `ALL_CAPS`. Similar reasoning applies to `?`- before it was added to the language, people wrote `try!(...)` instead, which meant "unwrap this `Result` and return from the enclosing function if it's an error." It's mysterious at first, but it's also very simple and also a huge benefit to readability once learned- no longer can near-arbitrary expressions throw arbitrary exception types without your noticing. &gt; lacking c-style parentheses. ...this change seems to serve no practical purpose other than change for the sake of change. The reasoning here is that Rust makes braces required, to avoid problems like `while (foo); { ... }` and `if (password_is_valid) thing_one(); thing_two();`. At that point, the parentheses are syntactically redundant and only make things noisier. IMO this isn't as strong an argument as the previous ones, but there it is if anyone was curious. &gt; Good code would be such that untrained eye in that particular language could tell what is going on. I don't think this holds true in general either. Language syntax didn't peak with C++ (or Rust, for that matter), and we can't improve on it without sometimes making changes that are non-obvious to beginners. Like I mentioned above, *everything* is non-obvious to complete beginners, while the vast majority of users of a language are non-beginners, almost by definition. So while these syntactic features make it harder to skim a Rust tutorial for the first time, they also make it much easier to maintain an established codebase, rather than "mental strain due to all these complex ideas expressed in suboptimal way."
`println!` is not a function. It's a macro. C++ also has `&amp;`. What are you talking about? 😛. And `self.0` is similar to `std::get&lt;0&gt;(self)`. It's just a syntax thing. 🤷 The lack of C-style parenthesis has one reason that stems from C++: One True Brace Style. Basically the lack of parenthesis forces you to always use braces, which helps prevent bugs in the long term. Or something like that 🤔 `?` has a long story behind it. It's just syntax sugar for the `try!` macro. For now, at least. Also, it's no more magic than `...` in C++. It's all just syntax in the end.
&gt; But I can do all that with standard getters/setters?! And then when you have two thousand times the same getters / setters, you end up with an header that looks like this : https://github.com/Kitware/VTK/blob/master/Imaging/Hybrid/vtkCheckerboardSplatter.h (ie a poor man's reinvention of properties)
FWIW, just because C++ compilers support `-std=c++11` flags doesn't mean that one gets "C++11 behavior". Most compilers backport features from newer standard to old ones, and also, fix defect reports in all language versions. Not a single C++ compiler from &gt;=2016 allows you to _exactly_ get the behavior of the C++11 standard text. Nor do they allow you to turn on/off single defect report fixes. This is just not feasible in practice.
This is /r/cpp. Those readers that want to get news about /r/rust or /r/programming in general are already following those sub-reddits. Can we keep this C++ only? Posts about C have been removed in the past because they had nothing to do with C++, I really don't know why these Rust's post are not getting removed.
Posts about C have been removed in the past because they had nothing to do with C++. I don't think the bar should be different for Rust. 
Anything is a syntax. And once learned it is just the way it is. Difference is between having to read long pages of documentation to get a grasp of what it actually is or not. Python is a champion in this case. Most of the time looking at python code it is very intuitive and obvious what it does, even for person that has no experience of python. All languages should exercise that kind of syntax. Yes, c++ has `&amp;` and that is why neither of them is better than the other. They are both full of magic characters, but rust seems to have more of that.
From [cppreference.com](http://en.cppreference.com/w/cpp/container/map/operator_at), you're right on point one. My defense is mainly that I've been using my own non-standard containers (and never getting around to re-writing them) for so long. I'm pretty surprised, though. I'll note that Stroustrup 4ed page 100 has an example using `[]` to read from a map with no immediate warning that the map must be non-const for that to work, suggesting it's meant to be idiomatic to read from a map that way. However, there's a note in the third special edition - "Subscripting a map adds a default element when the key is not found. Therefore, there is no version of operator[]() for const maps". That note may be in the 4th edition too - I haven't done a thorough search. Anyway, reads using `[]` are allowed and apparently encouraged in general - it seems odd to me to disallow reads just because you can't insert a new key. Though TBH, my personal choice would be to not auto-insert keys "by default" anyway. My containers don't have `operator[]` at all because of another ambiguity - all containers can be subscripted with a positional index (not just vectors) so in an associative container with integer keys, is the number inside the square brackets intended as a key or an index? Still, ignoring standard conventions was always a mistake. The interface that "works" (to a point), initially purely using it... x = my_map [k]; // This is implemented as a getter call for `my_map [k]`, then an assignment. // If the key doesn't exist, presumably an exception is thrown - too exceptions-as- // control-flow unless you can fool yourself into believing that missing keys are // genuinely exceptional, but a price some other languages are willing to pay for the // nice syntax. I'm not a fan of inserting a default value. Whatever, that's up to // whoever writes the getter for the property. my_map [k] = x; // This is implemented as a setter call. I'm assuming some kind of anonymous default property can be specified for an object, though that probably only makes sense for parameterized properties where use of `[]` for the parameters is assumed. I believe some kind of parameterized properties existed back in the Turbo Pascal days when I first heard about them, included from the start alongside the non-parameterized form. I don't know if TP invented properties or copied them from elsewhere. For defining them, a purely made-up syntax, choosing not to care that I'm stomping on some very common identifiers... // somewhere in the definition of std::map property // no property name - anonymous default property { get (const Key &amp;k) { if (key exists) return value else throw; } set (const Key &amp;k, const Value &amp;v) { // setter needs extra argument if (key exists) overwrite value else insert key-value pair; } }; With move semantics issues, leaving return types to be inferred might be suspect. 
&gt; I don't think this holds true in general. For example, we use i for loop indices because making them longer would actually hurt readability by distracting from the real purpose of the code. Thing is that `i` is universally accepted as a name for index. Other abbreviations are less universally accepted. What is `fn`? Is it a "function"? Is it a "function name"? Is it a "future nonce"? Or maybe "freaking never"? How about if we use 10 abbreviations in the same function and make a typo which coincides with a still valid variable name? There was a great writeup posted a while back how such typo caused problems in some pretty serious systems. Too bad i cant dig it up. &gt; So while these syntactic features make it harder to skim a Rust tutorial for the first time, they also make it much easier to maintain an established codebase Not so sure. Nim managed to avoid much of that magic which in turn made language very readable and no less maintainable. All in all lets agree to disagree. Future and practice will show who is right.
It's horrible enough to have to use C++ on a day to day basis. I don't like people that try to make it worse by telling me that something better actually exists when I will never be able to use it. Its unnecessary. 
Rust code looks quite ugly. Of course, C or C++ code hardly looks pleasing to the eye, but at least they are old. We now have quite a few languages which looks aesthetically pleasing - Python and Haskell from the top of my head. Rust has a problem with abbreviations. fn, mut, pub, impl, etc - why not use the full words. It feels like reading a teenagers sms messages.
wow, that Zeal thing looks really usefull thank you!
&gt; Then we have things like &amp;, and &amp;mut The reason for these is due to the move semantics are mutability restrictions Rust enforces. In Rust, doing this (with a type that doesn't derive Copy semantics) : let foo = bar; Means that it's now a [compiler error](https://play.rust-lang.org/?code=struct%20Foo\(i8\)%3B%0A%0Afn%20main\(\)%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo\(4\)%3B%0A%20%20%20%20let%20bar%20%3D%20foo%3B%0A%20%20%20%20%0A%20%20%20%20print!\(%22%7B%7D%22%2C%20foo.0\)%3B%0A%7D%0A&amp;version=stable&amp;backtrace=0) to use `bar` afterwards. The reason for that is that `bar` now owns that value. That brings us to the `&amp;` symbol. This is takes a reference to something, called a borrow. Borrowing means that ownership stays with the original owner. In that case, [both can be used](https://play.rust-lang.org/?code=struct%20Foo\(i8\)%3B%0A%0Afn%20main\(\)%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo\(4\)%3B%0A%20%20%20%20let%20bar%20%3D%20%26foo%3B%0A%20%20%20%20%0A%20%20%20%20print!\(%22%7B%7D%22%2C%20foo.0\)%3B%0A%20%20%20%20print!\(%22%7B%7D%22%2C%20bar.0\)%3B%0A%7D%0A&amp;version=stable&amp;backtrace=0). Up until now, both have been immutable, and trying to change the value will result in a [compile error](https://play.rust-lang.org/?code=struct%20Foo\(i8\)%3B%0A%0Afn%20main\(\)%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo\(4\)%3B%0A%20%20%20%20foo.0%20%3D%205%3B%0A%20%20%20%20%0A%20%20%20%20print!\(%22%7B%7D%22%2C%20foo.0\)%3B%0A%7D%0A&amp;version=stable&amp;backtrace=0). This is where the `mut` keyword comes in. You have to [explicitly] (https://play.rust-lang.org/?code=struct%20Foo\(i8\)%3B%0A%0Afn%20main\(\)%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo\(4\)%3B%0A%20%20%20%20foo.0%20%3D%205%3B%0A%20%20%20%20%0A%20%20%20%20print!\(%22%7B%7D%22%2C%20foo.0\)%3B%0A%7D%0A&amp;version=stable&amp;backtrace=0) mark a variable as mutable to be able to change it. The `&amp;mut` construct is just a combination of those two, and is a mutable borrow. Move semantics important to understand for function declarations. If you have a function declared like this (for a non-Copy type): fn baz(foo: Foo) { ... } Then calling that function will *move ownership* of your instance of `Foo` to that function, and it will go out of scope and be de-allocated when that function exits. [Example](https://play.rust-lang.org/?code=struct%20Foo\(i8\)%3B%0A%0Afn%20baz\(foo%3A%20Foo\)%20%7B%0A%20%20%20%20println!\(%22foo%20will%20be%20deallocated.%22\)%3B%0A%7D%0A%0Afn%20main\(\)%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo\(4\)%3B%0A%20%20%20%20%0A%20%20%20%20baz\(foo\)%3B%0A%20%20%20%20%0A%20%20%20%20print!\(%22%7B%7D%22%2C%20foo.0\)%3B%0A%7D%0A&amp;version=stable&amp;backtrace=0). If you wish to continue using the variable after a call, you need to [explicitly mark it](https://play.rust-lang.org/?code=struct%20Foo\(i8\)%3B%0A%0Afn%20baz\(foo%3A%20%26Foo\)%20%7B%0A%20%20%20%20println!\(%22foo%20will%20not%20be%20deallocated.%22\)%3B%0A%7D%0A%0Afn%20main\(\)%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo\(4\)%3B%0A%20%20%20%20%0A%20%20%20%20baz\(%26foo\)%3B%0A%20%20%20%20%0A%20%20%20%20print!\(%22%7B%7D%22%2C%20foo.0\)%3B%0A%7D%0A&amp;version=stable&amp;backtrace=0) as borrowed in the function signature *and* the call site. I think that went a bit more in-depth than I intended.
You should edit your post replacing the incorrect `FWD` macro with the correct one. Even if you added "THIS IS WRONG" it could be misleading to people who miss that and don't go through the children comments. #define FWD(x) ::std::forward&lt;decltype(x)&gt;(x)
Not sure why everyone is pouring tutorials over my head, they are totally unrelated to point i was making :)
Heard of www.cevelop.com? Eclipse-based C++ specific. 
&gt; Operations on names. What if I want to build up a name by concatenating two existing ones? That's outside the scope of my proposal, it's a subject for SG7(Reflection). The only operation on names I could provide is "declname to compile time string", e.g. `std::nameof&lt;?A&gt;` evaluates to `"A"`. &gt; Variadic declname and expansions. How would the syntax look? Can I easily achieve something like a named tuple? Yes. There's also features called "designating type" and "uniform designators" that allow you to have: template&lt;class... T&gt; struct Tuple; template&lt;class... T, declname... N&gt; struct Tuple&lt;T.N...&gt; {/*...*/}; Tuple&lt;int.a, int.b, int.c&gt; t1(1, 2, 3); auto t2 = Tuple(.a = 1, .b = 2, .c = 3); // Same as above, via deduction guides assert(t1.a == t2.a &amp;&amp; t1.b == t2.b &amp;&amp; t1.c == t2.c); &gt; what are the benefits/drawbacks over an opt-in UFCS that works by prepending a dot? Haven't seen this syntax before, any reference?
Its like score system in security software where every suspicious detail adds up to overall score. And then when score is exceeded user is denied access. So `fn` is a small insignificant detail which still could be done better (because of reasons i listed before) and thus it adds a little bit to that negative score. And score accumulates. Most vexing parse sure, thumbs up for solving that. I do not see std::invoke/bind/function as a problem in c++ really. Sure implementations are dazzling but they are at least hidden away from user well-enough. My main problem is having more of these complex constructs in a common code.
You are welcome :) It gets even better when you install plugins for Sublime/Atom/...
No one said it yet - SublimeText with EasyClangComplete plugin for code completion.
Because the place they work at forces them to use properties and thus they're accustomed to them. Maybe they aren't knowledgeable enough of the language to know of other ways to solve the problem. Could be that they just like it. A lot of people use JavaScript and they like its dynamic typing. That doesn't mean that dynamic typing is a good concept though.
What? I am tired of same debate over and over again, how many times I need to see another biased articles and brigading from /r/rust into /r/cpp? And posts like "RUST IS GREATEST TOOL ON EARTH!!!!!111 C++ is shit!!!11" What you want to learn from it? How to make static analyzer built into compiler? People are not angry, they are tired. It's like getting same spam on email, over and over again. I know what is Rust capable of, I don't need to be reminded of it every 3 days on /r/cpp, if I want then I will get into /r/rust. And bias in this article is just ridicilous. 
&gt; I think it's a broken design. Having a const version wouldn't help, because calling [] on a non-const map would still auto-insert, even if you're only reading. Not if it had been specified that it wouldn't. &gt; The compiler can't know I think you're seeing my explanation of an alternative-history speculation which you requested as some kind of proposal intended to fit into C++ as a change now. Of course I can't speak for the guy who *is* possibly going to write a proposal, but I doubt he has any intention to change `std::map::operator[]`. The compiler can know, and in some languages does know. Shoehorning this into C++ would mean a special syntax rule something like `container_expr [ subscript_expr ] = value_expr;` for the setter case, valid anywhere a statement is valid. That's the thing about speculating about alternative language features - it's perfectly valid and normal for that to involve alternative syntax. Of course that syntax would conflict with existing syntax (we can already put subscripting expressions on the LHS of an assignment) so probably awkwardness ensues (though context sensitivity and precedence rules are hardly a new idea in C++), but it wasn't meant as a proposal. 
&gt; No C++ compiler nor linter that I know of (and I know many) will even warn you about what is going on here Ironically, your example won't compile with any compiler like that, for a completely independent reason: You declared `idx`, but used `i`, in the lambda ;) Also, valgrind can be useful for safe Rust. It contains more tools than just the default memcheck that checks for invalid memory accesses / leaks.
that makes sense ... still don't like the "?data" syntax, though
The reference also sets bottom = top + 1. Looks broken to me. 
FWIW, `S&lt;int, ?&gt;` makes it an unnamed member. In most cases, you won't see the `?id` syntax because you'll deal with designating types `T.id`instead.
Stuff being in the language generally means it is better integrated. For example, Rust's equivalent of `std::variant` is the enum, which is a core concept in the language. Meaning there are additional first-order features (`match`) specifically designed to deal with it, and it is an expected part of Rust APIs. `std::variant`, by being a part of the standard library rather than the core language, does not enjoy this level of integration. It's still very, very useful though.
It is not that people feel threatened. It is just because it is the 2000s all over again, in a smaller scale of course (C# is so much better than C++, Microsoft is building a Windows project called Longhorn in C#, C# is faster then C++). I had to endure years of annoying people hyping every forum saying how C++ was obsolete with C#... and then what? When someone is enthusiastic about something new, that they believe that it is better, they fail to notice how annoying they become trying to convince other people to see the benefits they have found, and they are more prone to gloss over the flaws, that others can see but are too annoyed to argue about.
Yeah - For someone who prefers Atom (a lightweight IDE), I think VSCode's the obvious choice. It's obviously MS's answer to those lightweight IDE's, I already prefer it over Atom, and it continues to improve at an insane pace.. so I would much rather be on the VSCode train than its competitors. That said.. for C++, I tend to prefer a heavy IDE for anything that isn't a tiny codebase.. so I usually prefer th
You have too much of an emotional attachment to your tools. Use the correct tool for the job. Sometimes other tools are a better fit for the job than your favorite tool. C# is never a better fit for the type of jobs you do? Great. Don't use it then.
&gt; but I can certainly figure out what the issue is from a C++ error. So how do you figure out where the wrong call was made if you provide finite template specializations with exclusion of all the none specified types? I would really appreciate a solution (I haven't found any solution with VS 2015)
&gt; Ironically, your example won't compile with any compiler like that, for a completely independent reason: You declared idx, but used i, in the lambda ;) Well my brain has a sort of c++ compiler inside, and it did compile there :P but... it also has a linter :D And none of them caught this :D &gt; Also, valgrind can be useful for safe Rust. It contains more tools than just the default memcheck that checks for invalid memory accesses / leaks. Right again. I was implicitly talking about valgrind memcheck (which is the part of valgrind I use most). Although for the other parts, I think the only one that remains useful in Rust is cachegrind, and the traces parts. LeakSanitizer is way better at memory leaks than valgrind, at least in C++ (I haven't used LSan on rust yet).
Try [textadept](https://foicica.com/textadept/), very lightweight / minimalistic, although no autocompletion.
Technically still a draft standard, http://en.cppreference.com/w/cpp/numeric/special_math/riemann_zeta is C++17
AFAIK MSVC does not support anything like -std=c++11 (which is a real pity, IMO), so it's not a property of the language - it's a property of the compiler.
&gt; I actually can't stand the -std= argument to GCC. I use it for work because I can only use gnu99 to target my project, and the default, C89, won't fly. The default mode for gcc has been gnu11 since 6.1
 gcc --version 4.1.2 ａｅｒｏｓｐａｃｅ One day I dream of flying C11. One day.
I'd definitely like to thank the author for another extremely thorough and detailed standards meeting report. One of the downsides to the ISO process is that it's hard for "ordinary programmers", however interested, to get involved -- most of us cant afford (time-wise or financially) to fly around the world three times a year for week-long meetings. Reports like this one, summarising the debates that were had the opinions of the various working groups on the papers they reviewed, are a fantastic tool for bridging the gap between the C++ aristocracy (committee members) and us commoners. Making the process more transparent and the end result seem less like pronouncements from on high is a great thing IMO, and I'd like to applaud the author for what must have been a time-consuming report to produce. --- Moving on, and at the risk of re-opening a can of worms, I'm curious as to why the author feels that concept definition checking is such a hard problem in C++, and why it would delay Concepts till 2023 or later -- particularly since, as the author points out, other languages are able to perform the equivalent checks today? 
Not really sure what you are trying to describe here. Are you using explicit specialization, like this: template &lt;typename T&gt; struct A; template &lt;&gt; struct A&lt;int&gt; { /* ... */ }; and you need to find errors where something like `A&lt;double&gt;` is instantiated? Or are you using SFINAE to control the types? template &lt;typename T, std::enable_if_t&lt;std::condition&lt;T&gt;::value&gt;* = nullptr&gt; struct A { /* ... */ }; Maybe a mix of the two? Regardless, I haven't had that problem very often. I rarely am defining a template to be only a partial function. Still, that's different, isn't it? The question was about understanding what the error was trying to tell you. You seem to know the issue: you are using a template with a type that it doesn't support. The question you are asking isn't "what does this mean?" but "where did I do something I shouldn't have done?"
I might want the jobs some have ownership semantics ( shared or unique pointers) rater then just a raw pointer.
Don't forget to `std::forward&lt;decltype(x)&gt;(x)` everywhere too..
Unary `operator&gt;&gt;` for perfect forwarding would be lovely.
&gt; Looking at it slightly differently: the exact same thing that lets Rust run on a platform (i.e., targeting that platform with LLVM) also allows Clang to target that platform. This is confusing Rust (the language), rustc (the compiler) and the fact that currently rustc is entirely based around LLVM (which is not a *requirement*). There is no reason for rustc to be the only compiler and no reason for LLVM to be the only rustc backend (indeed, there is interest in targetting [cretonne](https://github.com/stoklund/cretonne) as well). &gt; but there are platforms that C++ targets that Rust doesn't (and probably never will). Why would it never target such platforms? There's extensive work to support a wide-range of platforms, especially for embedded environments, and I see no reason why support could not be added.
How to compile your program by clang++ in macOS? Currently the compilation failed. Thanks! Clang version: Apple LLVM version 8.0.0 (clang-800.0.42.1) Target: x86_64-apple-darwin16.4.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
You may want to think of Rust traits as *concepts* and Rust generics methods as template methods that are restricted to calling function/methods indicated by the concepts in their signature. I doubt it's a perfect analogy, but it'll get you 90% of the way.
Pro-tip: gcc is **very bad** with `make_unique` forwarding to a non-existing constructor and points to the last token of the file that caused the instantiation (even when the error is in a header). Search for occurrences of `make_unique&lt;X&gt;` where you modified the constructor of `X`...
One nitpick with regards to the first section. The natural way to translate this: int i; int res = 0; for (i = 0; i &lt; 5; i++) res += a[i]; return res; into a loop using a pointer would be this: int *p; int res = 0; for (p = a ; p &lt; a + 5; p++) res += *p; return res; I would imagine the compiler would generate identical code in each of these cases. I think the issue from the first example wasn't that it used a pointer instead of an index, but that it had an extra and unnecessary loop variable.
&gt; Or start permitting -std=rust1.16 or something of the like to guarantee that the compiler acts in an expected manner. If you wish to have the exact same behavior, whether in C++ or Rust, the only way is to use the exact same compiler &amp; dependencies. Anything else is too cumbersome and nobody does it. *Note: and I do mean nobody, `-std=c++11` on gcc 6.2 is slightly different than it was on gcc 5.0, because defects are fixed regardless.*
Indeed. A more "lasting" issue was that `std::string` incorrectly used Copy-On-Write even after C++11, which violated complexity requirements for a few functions. It was fixed later on because it required ABI breakage.
Why do you define WaitFreeQueue::m_array as a pointer and not use it directly as a member of WaitFreeQueue? In the end it's a vector, so you will have two levels of indirection when accessing its elements. On the other hand, you can use alignas(size_t) (c++11, like atomics) specifier to properly add padding between elements (basically you restrict it to be aligned to a cache line). Using the char array, potentially increases the total size of the class beyond necessity (with alignas you save sizeof(atomic&lt;uint64&gt;) for each member). #define CACHE_LINE_SIZE 64 class WaitFreeQueue { typedef std::atomic&lt;uint64&gt; alignas(CACHE_LINE_SIZE) atomic_counter_t; CircularArray m_array; atomic_counter_t m_top; atomic_counter_t m_bottom; };
What do you suppose is the feasibility of supporting a syntax like: [] (...) noexcept(auto) {...;} ... that asks the compiler to calculate the worst-case `noexcept`-ness of the function -- i.e. any reachable `noexcept(false)` function means the calling function is also `noexcept(false)`? I'm assuming this would take into account `if constexpr`...
&gt; What if we went to the rust subreddit to make a bunch of "look what I can do 'better' in C++","why i love C++ as a rust programmer","13 things C++ has that Rust doesnt" type of threads? Annoying right? Actually, supposing that the argument is well-informed and objective, it would probably be well-received. The Rust community is very keen on receiving constructive critics and feedback, it helps make the language better.
We've discussed this internally a bit and we believe posts like these will generally not be allowed in the sub. This article feels more like a speech about convincing you to switch to Rust than an attempt to discuss or improve C++. Posts that are primaly focused on C++ and discuss Rust on the side should be fine though, of course. Otherwise, language comparisons ^(^aka ^*holy* ^*wars*) are better suited for r/programming or Hacker News, as /u/jguegant pointed out.
&gt;print! does compile time validation of the format string. Not possible with variadics. Incorrect. Not possible with *the poor implementation of generics in Rust*. It's entirely possible with `constexpr` and variadic templates in C++.
He is wrong in one thing: C++ compilers do devirtualization, C9 Going Native had a episode about that (final vs override helping compiler).
The only use case I can think of is renaming std::pair's members (first and second)
It is quite hard to get code blocks into markdown tables. There are no tab characters in the docs. I've determined that any blank line in code means that the rest of the code is unindented (and the blank lines disappear). I've had to add "\&amp;nbsp;" to every blank line. :-(
Eh, no. Emotional attachment isn't necessary to know I don't want a Fisher-Price tool set to get actual work done, and trying to copy their pretty bright colors isn't going to make my real tools any more effective.
I did *not*, but this may be useful for debugging once I figure out how to use it. 
I'll trust you, but to be useful, please define "large"
&gt; bringing in unused headers doesn't actually hurt your project in any tangible way it can very much hurt your compilation times in certain situations, which may or may not be important
That's a case of ~~poor~~ incomplete type checking if another overload ***that shouldn't match*** ends up matching. That not a language or library design flaw.
Yes. It was considered acceptable because: 1. Introducing Rust 2.0 now is a bad idea 2. 1.15.1 was just a bug fix. Technically backwards-incompatible, but a bug fix nonetheless. The alternatives are to introduce Rust 2.0, leaving Rust 1.x forever broken, or leave the brokenness in the language itself.
I've always been skeptical of properties in C# and other languages that have them. Also, different languages have different target audiences; features may belong in a language with one target, but not in another with a different target.
Good catch! This is something I hadn't even considered. 
&gt; So yes it is powerful, but is it useful? Template declname parameter will be used as the building block for many template version of high-level things (e.g. uniform designators, designating types, expression alias, etc). So you probably won't see it directly, but still benefit from it. &gt; Also maybe for brevity use auto instead of declname `template&lt;auto&gt;` is already used in C++17, to deduce the type from a value w/o you specifying the type.
One minor comment: it's usual to write macro names in ALL_CAPS to differentiate them from C++ code, so for example #ifdef PROGRAMOPTIONS_NO_COLORS rather than #ifdef ProgramOptions_no_colors Also, the names of your `template.cxx` and `template_noexcept.cxx` files might be slightly misleading; on first glance from the names I assumed they contained two versions of template implementation code (with and without exceptions respectively). Perhaps `sample.cxx` and `sample_noexcept.cxx` or something like that might be an alternative?
I was using Spirit and was comfortable with the code(HTTP request parsing). then I didn't look at it for 12mo and maintenance was a bitch. It took a day to write a recursive decent parser that did the same and was easy to follow and change. Spririt is awesome, but I find that I have to relearn it too often and finding errors becomes more difficult.
&gt; Come on, you know that `print::&lt;"Your name is: {}"&gt;("quicknir")` is unacceptable. Well obviously it is, but why use it when there are macros. I'm not really sure what you are suggesting here, but a printf analogon in C++ would have to use templates as well. You can't have constexpr parameters, nor can you assign constexpr variables parameters. Both fails to compile. making the printf function entirely constexpr won't bring you compile time format string parsing when you print values that are only known at runtime (most times the case). &gt; The reality is that: [...] I disagree on the first two points. Finding out that some C function I read about in a manpage is implemented as macro always gave me headaches. With ! I know exactly when a macro is involved. And about hygienic macros vs non hygienic ones, you probably haven't understood yet what macros in rust are used for. Non hygienic macros in Rust would just make it possible to write much worse code, but not add much benefits. The fourth point is not really a big deal, as if the macro use cases are interesting at runtime, you can just as well expose them via runtime features as well. About the third point, no idea what you've meant. &gt; Constexpr works both at runtime and compile-time. That's awesome. So what? Rust's const fns work both at runtime and compile time as well. What is the point?
Don't do certifications, if you need one your employer would help you with it. I recommend just start working on projects and on the resources you have available. the important thing is not to jump too deep as if you give yourself a challenge to advance your never going to appreciate the small improvements as your too busy looking at the rest of the missing application 
No, certs are largely worthless
To quote [stroustrup.com](http://www.stroustrup.com/bs_faq.html#certification) &gt; there isn't a good certification program for C++ programmers.
I don't really agree with your analysis of std::map. The intent of `at` vs. `operator[]` is not that the former is a hack to get around some failure of the latter. The intent is that the latter always inserts, while the former never inserts. That's why there is no `const` overload of `operator[]`. 
Your post opened my eyes to why a simple "sugar only" version of properties is a really weak thing to add to the standard. I've never done the kind of serialization or UI binding like you describe, but I definitely understand that those things really need generic ways to do things. That being said, I think one way to simplify it is to not factor serialization into them. Properties-as-sugar doesn't have any state other than the member variables that the class already has. I could see UI binding benefit from binding directly to a property. As for your overloading questions, my answer would be no, for the same reasons you can't overload plain member variables. As that plays right into properties being just syntax sugar. All that said, I think it's good that there's discussion being had before throwing something potentially unsustainable into the core language. 
Consider what happens or should happen when assigning that proxy object to `auto foo`.
That's a valid consideration if your writing the class yourself. If the class was written by someone else and they determined that changing `p.r` is an expensive operation then it doesn't matter whether that cost is "obvious" or not, you have to pay it to make the change. Now, it's possible that changing `r` doesn't *have* to have that cost. In which case properties let you convey that *better* - the property is the less costly version and the member function is the more expensive one. Compare that to `operator[]` and `at()` on many of the STL containers (especially vector).
Y'all need to use more C#. I used to have the same opinion as you but after seeing the expressiveness of LINQ combined with reflection, I've changed my attitude. I still hardly use C# but I respect it as something much more than a "Fischer price toy" language. 
http://4coder.net/ is pretty neat, and its extensible via api http://4coder.net/custom_docs.html
I'm tempted to just say #include &lt;docopt.cpp&gt; and never look at your code, but I'll take a peek so I provide actual feedback.
Looking it more closely, this looks pretty nice. One concern is it seems like a fair bit of the logic is a bit ascii console (or whatever that character set is) oriented, and I didn't see an obvious layer of indirection for i18n/l10n type work, so it'd be good to have at least an easy way for someone to handle that. Still, the overall feel is very nice.
When and why should I use cxx suffix? And when cpp? 
Iirc that is for template source files which should not be compiled by itself but be included at the bottom of the hpp. If it would be cool people would think they're standalone, compilable source files.
I've already [shared my thoughts](https://www.reddit.com/r/cpp/comments/6108b0/c_standards_committee_papers_201703_postkona/dfatgp5/) on the changes to the C++17 draft, so I won't repeat them, but it seems there were a few more things discussed I seem to have missed: * [Replacing std::result_of with something better [P0604R0].](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0604r0.html) It seems the renaming of `std::is_callable` to `std::is_invokable` also included proposing a replacement for the unwieldy `std::result_of` type trait. This replacement (possibly named `std::invoke_result`? As always, naming is such a challenge) should hopefully make the querying of the return type of an invocation ("c" or "k"? :P) a much smoother experience and more consistent with the new `std::is_invocable` and `std::invoke` facilities. * [Renaming the variadic version of `lock_guard` to `scoped_lock`, to avoid ABI breakage [P0156R2].](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0156r2.html) This should make lock-based concurrent programming a smoother experience. Though I do not have much experience with concurrent programming in C++, I did not rate the user experience for lock guards very highly. `std::scoped_guard` looks so much nicer to use. I am far too excited to see C++17 features (class template argument deduction) already being used in proposals such as this. Technical Specifications are too large a topic for each of them, so I'll be passing them by. On to C++17 topics: &gt; Should library implementers have the freedom to add constexpr to library functions where the standard doesn’t specify it? (GB 38). ... It was now requested again for C++17; however, the idea still didn’t have EWG’s consensus. There is some hope it may yet in C++20. Looks like GCC's constexpr &lt;cmath&gt; library is still non-compliant, as desirable as it is. There are few reasons not to mark a function `constexpr` when it can be. &gt; Suppose a is a variable of type tuple&lt;int, int&gt;, and we write tuple b{a};. Should the type of b be tuple&lt;int, int&gt; (the “copying” behaviour), or tuple&lt;tuple&lt;int, int&gt;&gt; (the “wrapping” behaviour)? Interesting! This was not a case that had occurred to me when celebrating class template argument deduction. It's clear that the copying behavior is desirable, but it feels like making a special case of sorts, complicating deduction guides. &gt; Whether you should be able to define explicit deduction guides as deleted. That sounds great! :) And on to post-C++17 proposals! How exciting! The committee can't catch a break, can they? * [Consistent comparisons [P0515R0].](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0515r0.pdf) Woah, this is quite an interesting proposal. I have never heard of this "spaceship operator" `&lt;=&gt;` (what a funny name), but the extent of its utility is surprising. It will make defining comparison behavior for user-defined types a much simpler business, but the conceptual shift to this single-operator-for-all is not as simple I feel. And comparison categories... leave it to Herb to write a such a good-looking proposal (unlike one other [recent paper on operators](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0611r0.html)...). And did already I mention how excited I am to see C++17 being used in these proposals? Those initializers in conditional statements are beautiful! * [Implicit moving from rvalue references in return statements [P0527R0].](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0527r0.html) I am very glad to see this proposal be accepted. I was surprised when I first heard that lvalues can be implicitly moved in return statements, but baffled when I learned it did not apply to rvalue reference types. This is a good fix that reinforces move semantics. * [Abbreviated lambdas for fun and profit [P0573R0].](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0573r0.html) &gt; All but the first one were rejected. Haha, I had a feeling that would be the case. I'm glad at least the first proposal made it through. More power to lambdas! I supposed this would make those familiar with functional programming happy as well. Also, if one were to combine this with [[P0428R0]](https://wg21.link/p0428r0), one can write "Hello, world!" more expressively than ever before! #include &lt;iostream&gt; #include &lt;utility&gt; auto main -&gt; int { ([]&lt;typename... Args&gt;(auto&amp; os, Args&amp;&amp;... args) =&gt; (os &lt;&lt; ... &lt;&lt; std::forward&lt;Args&gt;(args)) )(std::cout, "Hello, world!") &lt;&lt; '\n'; } Really conveys the power, expressiveness, and beauty of modern C++, no? * [Generalized unpacking and parameter pack slicing [P0535R0].](http://wg21.link/p0535r0) Before all that, could we allow for type aliasing of parameter packs? I was surprised that was not already an option when I first attempted it: template &lt;typename... Args&gt; auto f(Args&amp;&amp;... args) { using Pack = decltype(args); // ... } Having core-language-supported utilities for manipulating parameter packs will be a great support for those who are involved in even the simplest of template metaprogramming. However, I can't say the syntax appeals to me very much (doesn't fit with typical array indexing syntax). * [The `constexpr` Operator [P0595R0]](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0595r0.html) I agree with the committee; this sounds nice, but the wording may need some work. It's a common inconvenience that a `constexpr` function can be used in both compile-time and run-time contexts without a way to differentiate between the two. Perhaps this may permit in some manner the use of `constexpr` function parameters (an inconvenience I'm certain every first-time user of `constexpr` functions were disappointed by and had to learn to deal with). C++20 is looking just as exciting as C++17. So much to think about and look forward to, even without taking the major TS's into consideration! The consistent comparators proposal is the most interesting, but implicit moving from rvalue references and "arrow lambdas" (we already have IILE's, why not borrow another terminology from JavaScript? :3) are my favorite. It is great how the language is continuing to evolve even in the midst of C++17 draft finalization.
Gotcha. I assumed wrong.
In the original x86 the FPU registers are 80 bits, so every floating point operation is made with extended precision and converted back to its original size afterward. Modern CPU with SSE and AVX have registers that can handle operands with 64/32 bits.
&gt; I dislike use of null pointers for tag dispatching `tag&lt;T&gt;` is a bit more to write, and I can't see that it would buy anything technically, but it's more clear. So yes, thanks, good point. &gt; Prefix is awkward, especially with () requirements. Not sure what you mean here. Regarding your proposed notation &gt; `foo-&gt;*age = 43` I like that :-), ***but***. It requires `age` to be an object. With `age` as an incomplete type one can just declare a name type `age` in a well known namespace, but with `age` as an object one has to know whether that name's already defined. Do you have a solution? 
Where's code for benchmarking?
Yep, makes sense. Going to change that. Thank you! EDIT: [fixed!](https://github.com/Fytch/ProgramOptions.hxx/commit/1b64311f4acdb3e0f30fb2ceeed28194f1588666)
I totally agree, my library is unsuited for bigger projects like the ones you've linked. I reckon [boost.Program_options](http://www.boost.org/doc/libs/1_63_0/doc/html/program_options.html) would do the job then. However, I don't intend to focus on completeness (also as that's very difficult as you've pointed out) but rather on providing a small and overseeable library that's easy to integrate for other tinkerers like me :) Thanks for the feedback!
You should mention this somewhere in the help &gt; "operator[]: designator may only consist of letters and hyphens and mustn't start with a hyphen" I use a bunch of flags with underscores and don't feel like changing them, so I must dive into your source code now :( I also got a couple warnings from clang related to an unannotated fallthrough in switch and unused private member. (will PM you them later). PS. I also hate this syntax. if( !parser( argc, argv ) ) { Why not have a normal method like parser::parse() ? Otherwise thanks for helping me get rid of boost program_options dependency, good job :)
As to your first statement: Yes, I thought of that, too! I tried to come up with a solution but it made the user code very verbose and I didn't like that. I'll try to come up with an easy solution for that scenario. As to your second statement: You're right, I'm going to change that immediately. EDIT: [fixed!](https://github.com/Fytch/ProgramOptions.hxx/commit/70d1c8eb81e068da71e3c4494995357acab3c5cc) Thanks for the feedback!
Changing the source code to fit your needs is very easy. Just Ctrl+F for "valid_designator" and change the lambda either to return std::isalpha( c ) || c == '-' || c == '_'; or even more laxly to return std::isgraph( c ); I have never tried that so please let me know if any problems errors occur. I'm going to include that in the README, definitely. I maybe even relax the designator requirements, but I've never seen a GNU-like CLI program that has anything other than letters and hyphens in its options' names. Do you know any? EDIT: [fixed!](https://github.com/Fytch/ProgramOptions.hxx/commit/10184f01f5c1d577fc0894fa973310b48ab691bb) Thanks a lot for the feedback!
&gt; And even then, wouldn't using `namespace std;` break ? There's potentially issues with doing that anyway.
FYI, nowadays Bjarne Stroustrup recommends to use .cpp extension (if your project doesn't already follow another convention). https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rs-file-suffix
&gt; This is an old C idiom &gt; My modern (C++11) single-header But my point is you can have the same just with {}, without `do` and `while`. 
Firstly, why do you think that *modern* and *tried and trusted technique* contradict each other? Secondly, did you read my link? The author especially addressed the issue with `{}`.
VS is definitely not lightweight. Its intellisense is still kinda broken, sluggish and generates huge db for each of your solution.
If you read the detailed description, the rejected features are most of the time considered a good direction so they can come back later in another form or details.
&gt; Firstly, why do you think that modern and tried and trusted technique contradict each other? I do not say so, it's just that modern is opposite of old - http://www.thesaurus.com/browse/modern Yes, the issue with `{}` is `;`, but you have `;` directly in your macro, which has the same issue #define XXX() do { } while(0); void foo() { if (val) XXX(); else XXX(); } this does not compile 
Using `[]` is IMO not a good way to express that you want to auto-insert. Using `[]` seems like a "by default" syntax. Auto-inserting (especially on reads) doesn't seem like a good default behavior. Even for consistency within C++ - arrays and `vector` obviously supports `[]`, but for indexes rather than keys. Indexes can be considered a special kind of key with some special constraints and behaviors, though, ignoring the implementation and costs - obviously *why* the `[]` notation originally intended for arrays was also used for keys in associative containers. But `[]` on arrays and `vector` doesn't auto-insert for reads or for writes. Either there's an element for that key/index already, or there isn't. If not, you don't even get an exception - undefined behavior ensues. Of course there are other languages that do auto-insert using `[]` for writes, and depending on taste, the differences between associative containers and arrays/vectors are enough to justify that "inconsistency" - personal opinion, really - but I'm not so convinced about auto-inserts for reads. For example, Python... steve@steve-desktop ~ $ python Python 2.7.12 (default, Nov 19 2016, 06:48:10) [GCC 5.4.0 20160609] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; x={"a":"Hello"} &gt;&gt;&gt; x["b"]="World" &gt;&gt;&gt; x {'a': 'Hello', 'b': 'World'} &gt;&gt;&gt; x["c"] Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; KeyError: 'c' &gt;&gt;&gt; The auto-insert for the write works, but trying to read for a key that doesn't yet exist throws an exception. A behavior that one commenter has already tried to claim here would be impossible. Of course Python translates the gets and sets to calls of `__getitem__` and `__setitem__` method calls, so to that extent it's similar to properties - it has a distinct single step to implement the get and set operations so it knows that intent from the start. Python also supports properties, but those magic methods give me the only kind of property-like behavior I ever remember using. Auto-inserting a default value on reads might be useful, e.g. with containers of per-key counts, so the default key-not-present count is zero. Except that for most of the life of `std::map`, the default integer was undefined/uninitialized, not zero. It's also a significant surprise to support special-case usage. 
Yep, you're right and I've [fixed this bug](https://github.com/Fytch/ProgramOptions.hxx/commit/46e52e1ead872da7de765c81103ba363976f8fe6) after my last reply as I was revising the code in question.
I don't fully follow. Do you mean someone takes a reference to the data member, and uses that somewhere? I could see that failing. Well it's won't fully help with backward compatability; but certainly aids it. This would be caught as a compiler error. I was never stating it's an end all, guarenty with backwards compatability, but the less things you break with an API change, the better. I mean, though it's great to have the backwards compatability in the external API; personally I've such idiom in the internal API for slow incremental changes to code. Refactoring a whole codebase off of one small change, used everywhere is very error prone. Having the property retain compatability with both API's is helpful until I can find and change all occurances.
So I'm guessing Dave Chappelle will have another special... We are a big team working from 3 countries with many libraries that are developed by different departments... Dude it's a small price to pay for another rick james bitch
The library developer compiles against every other "client" ? Hell no. Client as in the library user. Yes, when the user gets the latest and compiles he will get an ugly output and he will go to the line and check wtf happened. But it's still preferable that the error would be something meaningful as in obj.nBufferSize not found. I will also prefer returning dictionaries in python than touples btw. You can't beat a concise and meaningful errors.
&gt; Microsoft has begun implementing the Concepts TS [...] Microsoft’s recommendation is: no more delay and uncertainly; bring the Concepts TS forward into the main C++ standards text. They are ready. Isn't the whole point of the TS to have them implemented _before_ merging them into the C++ standard? While coroutines is implemented in both clang and msvc, concepts is only implemented in gcc. Given that it is "a bit" more fundamental than coroutines, I wonder if the GCC implementation alone is enough for this. The only project that I know of that uses GCC concepts is the STL2 implementation, which, AFAIK, nobody is using in any application. It should actually be _the_ showcase of how concepts are to be used, but instead it is a showcase of how to workaround bugs in GCC's implementation. 
I'm really looking forward to having concepts available to play with. They are well past due, IMO.
- What have you learned from these experiments? - How much does definition checking help you write properly constrained generic code? Do you think that something like that would be useful or necessary in C++? (e.g. is it possible to write correct generic code without it?) - What do you think of concept-based dynamic dispatch? (trait objects) - What do you think of concept maps? (e.g. being able to implement trait methods differently for different types)
I already posted the examples in the reply to others. It's mostly a feature for language devs and library devs, as a normal user you probably won't even notice its existence. _Designating types_: Tuple&lt;int.a, int.b&gt; t1; _Designators_: auto t2 = Tuple(.a = 1, .b = 2); _Sub-expression alias_: Variant&lt;int.num, string.str&gt; var(42); cout &lt;&lt; var.num; // prints "42" cout &lt;&lt; var.str; // throws ...and the UCS examples I show in the post. All these are powered by declname under the hood.
If you're polluting whatever namespace / TL when stating `using namespace foo`, then YOU are introducing the incompatibility. There is no standard that states that libraries and APIs must use different type or function names. That's on the developer to manage.
Maybe library writers feel differently, but as a lowly application writer the terse syntax is what makes me excited about Concepts. I've already learnt how to reasonably parse template errors so concepts checking is very much 'meh' for me.
I'm confused, it sounded like from your original comment you were asking the OP to solve this problem with his library?
Definition checking has been very helpful, especially as error messages are generally excellent. It is possible to write correct generic code without it, but it's much harder. Trait objects are something i mean to investigate more fully, I'm only a couple of weeks in, of spare time. Need to look into concept maps more yet.
It's type inference at work. Rust does not assign an integer literal a type from the beginning, it starts as just an integer literal. Then, it will try to infer the type from the context: - `0u32` is of type `u32`, - look for suitable implementation of the [`std::ops::Sub`](https://doc.rust-lang.org/std/ops/trait.Sub.html) trait, - the only implementation found is `impl Sub&lt;u32&gt; for u32`, thus `1` is of type `u32`. If I had not specified the type of `0`, the default integer type would have kicked in: `i32`. But there would have been no underflow so it wouldn't have been interesting. *Note: the value does not matter to decide the type, however if the value doesn't fit the type you'll get an error.*
I don't find using exceptions for programming errors best idea. Exception can be caught, but programming error shouldn't be caught, it should be dealt with by fixing the code. Simple `assert()` would be better, and this will also ensure that it is removed from the code when you compile the final product with `NDEBUG` preprocesor define, which is a standard way to disable assertions. Edit: I see the code is also removed here if NDEBUG is defined. Anyway, I like doing asserts the "standard" way more.
&gt; Do you mean someone takes a reference to the data member, and uses that somewhere? Yeah, that sort of thing. There are several different ways to do things that will break with properties. &gt; Well it's won't fully help with backward compatability; but certainly aids it. This would be caught as a compiler error. There's at least one usage which would break which would not be caught by the compiler: auto &amp;&amp;pr = p.r; pr = 10; // or something With `p.r` being a real member `pr` is a reference to it. When `p.r` becomes a property, now `pr` is just a reference to a temporary. When switching `p.r` to `.get_r()` and `.set_r()`, the compiler does catch that, because `.r` is just no longer valid at all and has to be replaced everywhere. Of course there are other ways things can break, either switching to a property or switching to getter/setter. &gt; Refactoring a whole codebase off of one small change, used everywhere is very error prone. That's what clang refactoring tools are for, and then that's why you have tests for the program.
Is GCC's implementation really buggy? I haven't tried it yet
Instead of adding a new keyword it would better for declname to just be "using". 
My notes (I may edit this later): 1) I believe you should flush the stream before setting/reseting a color by `SetConsoleTextAttribute` if `PROGRAMOPTIONS_WINDOWS` is defined. If not flushed, the color can be set wrong for buffered text. 2) Too much boilerplate code for supporting non-C++14 compilers. You could conditionally remove it by testing C++ version for C++14, by testing `__cplusplus` for value greater/equal to `201402L` (final working draft). 3) You should add a note somewhere which defines can cause ODR issues. If compiler won't inline everything and/or chooses to export the functions. But I guess it is unlikely that parsing of program options will be included in multiple dynamic libraries used by the same project. `NDEBUG` is kind of expected to cause ODR issues, but `PROGRAMOPTIONS_NO_EXCEPTIONS` or `PROGRAMOPTIONS_NO_COLORS` doesn't have to. 4) I would recommend avoiding naming your types with `_t` suffix. I know standard library has many types like that, but you may get clashes on `POSIX` systems, as all types with `_t` suffix are reserved by it. 5) DON'T do things like that, never: m_program_name = std::max( std::strrchr( argv[ 0 ], '/' ), std::strrchr( argv[ 0 ], '\\' ) ); On Windows, it IS possilble for executable file to contain `/` character (although it is "hard" to name it as such, as many applications, including Explorer, won't allow it, unicode versions of file functions will allow it if you use the special long name format, ie `"\\\\.\\C:\\MyFile/name.exe"`), and it is possible to have `\` character as part of executable file name on Linux (easy to name it as such). This can be solved on Windows, I believe, by using `GetModuleFileName(NULL)` and looking for last `\` character, on Linux and other unixes, just by looking for last `/` character. No more time to read the rest of the code, maybe later.
One of the big ones is that the first doesn't require that 'beg' and 'en' are the same ACTUAL type, whereas the 2nd one does. That is ambiguous and unclear to me. For the rest, see page 6+ here: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0587r0.pdf EDIT: My 1st sentence is wrong. In the example I gave for the first one, beg and en ARE the same actual type, but this explicit and not necessary (since I can bring in a new template param). 
It depends what you're doing. If you're a bank handling transactions you don't want to create or destroy money due to rounding. However if you're computing statistical measures based on prices then floating point is the right choice. float is faster than double (less memory, more SSE/AVX lanes) but you need to pay more attention to numerical stability, possible error accumulations and so on. double is the easier/safer but slower choice.
Ah, yeah, you're right. In this case I meant that it was explicit, but not necessary (since you could have a separate tmeplate param). I have the same problem as you, except I'm not sure there IS a right answer. In a personal poll I've done on people aware of templates, the answers are 50/50 split as to which is 'obivously' the behavior.
Yep, I got that wrong. I'll update it.
Well OK the `foo-&gt;*prop&lt;age&gt;` notation is doable by having `prop` as a function template. #include &lt;utility&gt; // std::forward #include &lt;type_traits&gt; // std::remove_reference_t namespace my{ using std::forward; using std::move; template&lt; class Type &gt; struct Prop_ {}; template&lt; class Object, class Item, class Name_tag &gt; class Property_accessor_ { private: Object* object_; public: operator Item () const { return object_-&gt;get( Prop_&lt;Name_tag&gt;{} ); } template&lt; class Value &gt; void operator=( Value&amp;&amp; v ) { object_-&gt;set( Prop_&lt;Name_tag&gt;{}, forward&lt;Value&gt;( v ) ); } Property_accessor_( Object&amp; object ) : object_{ &amp;object } {} }; template&lt; class Name_tag, class Object &gt; auto make_property_accessor_( Object&amp; o ) { return Property_accessor_&lt; std::remove_reference_t&lt;decltype( o )&gt;, std::remove_reference_t&lt;decltype( o.get( Prop_&lt;Name_tag&gt;{} ) )&gt;, Name_tag&gt;{ o }; } template&lt; class Type, class Name_tag &gt; class Simple_property_ { private: Type o_; public: auto get( Prop_&lt;Name_tag&gt; ) const -&gt; Type const&amp; { return o_; } template&lt; class Item &gt; void set( Prop_&lt;Name_tag&gt;, Item&amp;&amp; v ) { o_ = forward&lt;Item&gt;( v ); } template&lt; class... Args &gt; Simple_property_( Args&amp;&amp;... args ) : o_{ forward&lt;Args&gt;( args )... } {} }; template&lt; class Name_tag &gt; auto prop() -&gt; Prop_&lt;Name_tag&gt; { return {}; } template&lt; class Derived &gt; class Property_operator_notation_ { private: auto self() const -&gt; Derived const&amp; { return static_cast&lt;Derived const&amp;&gt;( *this ); } auto self() -&gt; Derived&amp; { return static_cast&lt;Derived&amp;&gt;( *this ); } public: template&lt; class Name_tag &gt; auto operator-&gt;*( auto() -&gt; Prop_&lt;Name_tag&gt; ) const { return make_property_accessor_&lt;Name_tag&gt;( self() ); } template&lt; class Name_tag &gt; auto operator-&gt;*( auto() -&gt; Prop_&lt;Name_tag&gt; ) { return make_property_accessor_&lt;Name_tag&gt;( self() ); } }; } // namespace my #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; using my::Prop_; namespace name { struct age; } // namespace name template&lt; class Person &gt; void test() { using my::prop; using name::age; static auto const foo = []() -&gt; Person&amp; { static Person o{ 0 }; return o; }; static auto const bar = []() -&gt; Person const&amp; { static Person const o{ 44 }; return o; }; Person o{ -1 }; o-&gt;*prop&lt;age&gt; = 42; cout &lt;&lt; o-&gt;*prop&lt;age&gt; &lt;&lt; endl; // 42 foo()-&gt;*prop&lt;age&gt; = 43; cout &lt;&lt; foo()-&gt;*prop&lt;age&gt; &lt;&lt; endl; // 43 cout &lt;&lt; bar()-&gt;*prop&lt;age&gt; &lt;&lt; endl; // 44 } class Qt_person : public my::Property_operator_notation_&lt;Qt_person&gt; { private: int age_; //signal&lt;void(Qt_person*, string)&gt; property_changed; public: void set( Prop_&lt;name::age&gt;, int const value ) { if( value == age_ ) { return; } age_ = value; //property_changed(this, "Age"); } auto get( Prop_&lt;name::age&gt; ) const -&gt; int { return age_; } Qt_person( int const age ): age_( age ) {} }; struct Stringly_typed_person : my::Property_operator_notation_&lt;Stringly_typed_person&gt; { string age; void set( Prop_&lt;name::age&gt;, int const value ) { age = to_string( value ); } auto get( Prop_&lt;name::age&gt; ) const -&gt; int { return stoi( age ); } Stringly_typed_person( int const an_age ): age{ to_string( an_age ) } {} }; using Person_age = my::Simple_property_&lt; int, name::age &gt;; struct More_reasonable_person : Person_age , my::Property_operator_notation_&lt;More_reasonable_person&gt; { More_reasonable_person( int const age ): Person_age( age ) {} }; auto main() -&gt; int { test&lt;Stringly_typed_person&gt;(); cout &lt;&lt; endl; test&lt;More_reasonable_person&gt;(); cout &lt;&lt; endl; test&lt;Qt_person&gt;(); } 
That... doesn't make any sense. The POSIX rule is not "thou shalt not name a _t thing", it's "thou shalt not define an identifier of one's own that says _t". You not using enable_if_t doesn't make enable_if_t disappear from your standard library implementation.
Your Drawable example is fine because it's already a template. My concern with the terse syntax is that it changes whether or not a function must be defined in a header in a way that's non-obvious. If your library is totally header only, you don't care, but there are a lot of non-header-only libraries in the world that are going to harder to write as a result of that syntax. That is, today, the answer to "does f need to be in the header": ``` X f(const X&amp;, const Y&amp;); ``` is "no". With the terse syntax, the answer is "it depends on what `X` and `Y` are". And the result of getting it wrong will be a bizarre ~~linker~~^1 error which will be difficult for most users to understand. If the terse syntax didn't apply to forward declarations this problem goes away. ^1 EDIT: Casey has pointed out that this will cause a compiler error as soon as someone tries to use the thing, not a linker error, so that's better, but still creates a minor foot-gun.
It is quite funny that Bjarne wrote a paper in which he took a dump on static if proposals, because it would mess with his precious concepts, only for constexpr if to be added anyway to C++17. So basically we could have had static if in C++14 :) 
I'll be honest, I'm not sure I follow that argument. Which libraries are going to be written with Concepts that are going to get harder, when you _also_ take into account Modules ?
Yeah, there were some buglets, but gist conveyed. :) I also tend to include a separate set of `CAREFUL`/`CARELESS` macros that let you affect riskier practices like `__builtin_unreachable`s independently from debugging stuff. And this stuff can also be done a little more cleverly if you mix in some `enum` constants, since you can redefine those symbols in an inner scope and change behavior locally. (E.g., I want stuff in this scope *always* to use a trap instead of unreachables.) I’ve seen different compilers complain differently when it comes to unused expressions, so I’d probably at least keep a `void` on the outside of the ternaries—ICC bitches at the slightest provocation, and that might be one of ’em in some circumstances, akin do doing `a() &amp;&amp; b();`. (This is one of those cases where it’d be really nice if C were entirely expression-based; everything fun requires trickery/fuckery and there’s no telling what’ll end up with what kind of diagnostic. `-Werror` is great but it also sucks awfully if every inch of your ass hasn’t been covered in thickest kevlar.) W.r.t. `__clang__` and `__GNUC__`, I’d usually version-check `__GNUC__` and `__GNUC_MINOR__` more neurotically for support of `__builtin_unreachable` and `__builtin_trap`, because IIRC -`_trap` shows up in the 3.x line, possibly per-ABI/architecture, and `_unreachable` in the 4.x line. (I used to have a list of what shows up in what versions/architectures, but I can’t find it and there’s nothing terribly complete or clean online. ICC has its own, slightly different support matrix too with its own macros, but still defines `__GNUC__` &amp;c. quasi-arbitrarily, because of course it does.) `__clang__` can be used to gate a separate `__has_builtin` check, which is a considerably nicer way of doing things, if still a bit funky. Still, limitations of the Reddit medium and all that.
Right. The problem is that with the terse syntax, there's no way to say that two `InputIterator` parameters are allowed to be different types. A `zip` operation might be a better example since it ostensibly should be able to take input iterators from two entirely different sequences (e.g., a vector and a stream) with different iterator types. It's super unclear why `zip(Input a, Input b, Output c)` would fail to compile in that case but the longer `template &lt;Input A, Input B, Output C&gt; zip(A a, B b, C c)` will work correctly, since it just looks like a verbose expansion. At the very least, the terse syntax should expand to the above and not to the form it does now. Two types being the same is an extra refinement and those should be explicit.
If a macro conflicts with a definition in std, any reference to it would result in an expansion regardless of any using declarations, ie: #define foo bar std::foo Will be transformed into: std::bar After preprocessing. 
Also I didn't realize Gabriel Dos Reis is now working at Microsoft. Wasn't he a professor at Texas A&amp;M University?
&gt; In my example, Tuple is a template. In yours, it's not. The point is that you can have a Tuple with custom names on the fly instead of defining those ad-hoc structs. So it is syntax sugar, like lambdas are unnamed functors this is some terse way of defining a templated struct? 
1) This is generally correct but not for `std::cerr` because it flushes automatically before every operation. It is the unbuffered counterpart of `std::clog`. 2) The first version of my library was actually written in C++14 but I ported it back to C++11. The only boilerplate I had to add were some explicit return types (instead of `auto`) and [these 30 lines of code](https://github.com/Fytch/ProgramOptions.hxx/blob/027684bd847ba0d0951ba0f4e490630ed3d7f869/ProgramOptions.hxx#L175-L209). What exactly are you referring to with 'too much boilerplate'? 3) This is a very good point, I'm going to include it in the README. But can you explain how `PROGRAMOPTIONS_NO_EXCEPTIONS` can cause ODR issues? I fail to see it at the moment. 4) I didn't know about that, thanks for pointing it out. I'm going to work out a solution. 5) Didn't know this either, I'm going to look into it. However, it is not all that bad because the only purpose of `m_program_name` is to print it the help screen. Thanks a lot for your feedback!
Yeah, `static if` (and now `if constexpr`) are handy tools, but relying on them for everything is no different than writing functions with mountains of `if` statements: it results in grotesque hard-to-follow spaghetti code that screams out in agony as it awaits being factored into abstractions. :)
Error messages: console.cpp:168:9: error: calling a private constructor of class 'Command_t&lt;void (*)(int, int), int, int&gt;' return Command_t&lt;decltype(func), std::decay_t&lt;ARGS&gt;...&gt;(move(name), func); ^ console.cpp:242:4: note: in instantiation of function template specialization 'MakeCommand&lt;int, int&gt;' requested here MakeCommand("sum", fn::sum), ^ console.cpp:159:2: note: declared private here Command_t(std::string&amp;&amp; name, CALLABLE func) : ^
If you can't export extern functions that'd be really unfortunate. :( I'm not positive.
Can you please tell us a little more about the source to your desired program? 
Is there actually dissent to this suggestion? There was a paper saying that's how they should work, and I think most people think that it is obvious that they should work that way.
Make changes as I said in post right above yours
I was just answering the question, if i remember correctly they were in the earlier proposal.
Somehow ended up as response to wrong post. Reddit mobile gets things a bit wrong sometimes.
1) I haven't noticed you only pass `std::cerr` there. The class itself looked as part of public API and because the constructor accepts `std::ostream&amp;` I thought it can just be any `std::ostream` and will be used that way. 2) Those 30 lines and stuff like conversions from string to integers/floating numbers. There are already functions for it. Such as `std::strtoull` and `std::strtoll` could be suitable for integers, correctly check for errors and after that check if the value is in range for given type and do (now safe) a cast. These should save you many unnecessary parsering lines. 3) The code is different when `PROGRAMOPTIONS_NO_EXCEPTIONS` is defined and when it is not (and asserts are enabled). But it really can be just non-issue as I mentioned, it probably won't be linked into libraries if the code is designed for command line parsing only from main program binary. 5) Not critical, I agree. Problems start when someone uses things like that in more critical code - for manipulating files, deleting, copying, moving, while not checking user inputs for "long file name format". Wrong unexpected results can happen. Another issue is that ANSI Windows API and Unicode API silently treat `/` as directory separators and converts them to `\` before passing to filesystem. This silent conversion only doesn't happen if the Unicode API is used with the long file names (I can't really recall how this is correctly called, sorry). Anyway, I got the prefix wrong, it is `\\?\` for file namespace, `\\.\` is device namespace.
Post a link to that discussion please.
Well `static if` was _way_ more powerful than the current `if constexpr` and `requires` combined. You could do stuff like this: template &lt;typename T&gt; struct foo { static if (std::is_same&lt;T, void&gt;{}) { int a; } }; where `foo` only has a member `a` if the `static if` evaluates to `true`. 
It could be compiler differences for what sounds like extremely simple test cases. It's certainly not OS-related. This seems like a low-quality post all round, it doesn't even say how many tasks/threads were launched - you'll only get real benefits from thread pool if there are more tasks than physical cores, plus if the tasks are reasonably fine-grained.
He has a very valid criticism - the OO style concepts require you to modify the original when you need to extend the concept graph. To be honest - how does it even make sense?! Seriously - I'm might be missing something here. 
I'm pretty sure it was asked before - but is there any easy examples of what you can do with concepts overloading and cannot with enable_if or tag dispatching? 
&gt;Properties are a proven concept (see C#, Kotlin, etc.) so there isn't an argument that 'they don't work', are spurious or whatnot. C++ isn't different enough from those other languages to have a differing view on properties. I disagree, I think properties in those languages are confusing and poorly designed, and those languages are **completely** different from C++ in semantics. &gt;Properties are already supported in C++ anyway (using __declspec(property)), but could be much nicer. Properties are not supported in C++. I don't know about shitty Microsoft extensions, but given that every Microsoft extension I've ever seen has been a pile of worthless junk, I doubt they'll be good. &gt; class Person -- &gt; property int Age The standard style for names in C++ are that they are lowercase. Writing `property int Age` makes it painfully obvious that you just want this feature because you're used to it in C#, as that's the predominant style in C#. &gt;So this is all standard C#-like stuff. If you want standard C#-like stuff, use standard C#. Many of C#'s features are clearly completely inappropriate in C++, like `async`, `await` and properties.
`if constexpr` is intentionally very different from `static if`, which is intentional.
Yes they are! Info about the meeting (such as the venue, and accommodation options if you're coming from out of town) can be found [here](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4636.pdf).
Concepts make a lot of code MUCH easier to read and write, including code that ML people use all the time. I'm thinking of libraries like Eigen, boost::python, and dlib.
Right. EWG broke down the proposal into these five parts, and only encouraged continued work on the first one. Note that even for the first one, we didn't debate or accept the specific syntax yet (`=&gt; expr`) - it was just "come back with a proposal covering just the first point".
The rationale he gives for the over-decrement approach is to save registers, but the merits of that seem very dubious to me.
I wasn't really confusing rustc with rust itself--just conflating the two, because one of the article's main points was that using a single compiler was a major strength of rust. Proliferation of compilers would (or at least might) support more targets, but at the expense of the same "problems" that supposedly plague C++. As for why rust is unlikely to ever target some platforms: the big example would be some obsolescent targets. Current C++ compilers support them because back ends for them were written years ago (in some cases, decades ago) and as long as the compiler continues to use the same interface between the front- and back-ends, it can continue to support them with little or no work. Based on their current market share, however, writing a back-end for them now probably isn't justified. For one rather extreme example, there's at least one commercial C++ compiler (Comeau) that generates its output as an ancient dialect of C. So, essentially anything that has a C compiler (almost regardless of how ancient and crippled that might be) is also a perfectly legitimate target for shiny, new C++ that uses essentially all the most modern features. This means that (for example) modern C++ could be written and compiled for something like a DEC PDP-10, which was discontinued in the early 1980's, when C++ was in its infancy. Now, it's undoubtedly true that if somebody wanted to badly enough, they could write a Rust compiler that produced ancient K&amp;R C as its output. In so doing, they'd allow Rust to target a lot of these ancient machines--but I've never heard of anybody even seriously considering doing such a thing, not to mention its actually being done. In short, I think the "probably never will" statement remains fairly accurate.
&gt; Serious question -- doesn't that violate semantic versioning? There's two ways to tackle this. http://semver.org/ says &gt; What do I do if I accidentally release a backwards incompatible change as a minor version? &gt; &gt; As soon as you realize that you’ve broken the Semantic Versioning spec, fix the problem and release a new minor version that corrects the problem and restores backwards compatibility. Even under this circumstance, it is unacceptable to modify versioned releases. If it’s appropriate, document the offending version and inform your users of the problem so that they are aware of the offending version. Now, this is the opposite situation, but it's basically the same fix: "whoops we really messed up and since it's only been an hour since release, nobody could be depending on this, so just put out a fix." The second approach is that semver does not actually define what "compatible" means. We laid out several RFCs detailing every kind of possible change to Rust and how we defined their compatibility, and in it, we said soundness fixes can be an acceptable way to break code, depending on a judgement call by the teams. In this case, the call was pretty easy. In other cases, it may not be; we've had to do slower migrations for other soundness fixes in those situations.
**Here's a sneak peek of [/r/cpp_questions](https://np.reddit.com/r/cpp_questions) using the [top posts](https://np.reddit.com/r/cpp_questions/top/?sort=top&amp;t=year) of the year!** \#1: [Where does the spit go that the dentist sucks up in the tube? I tried asking my dentist and she had no idea](https://np.reddit.com/r/cpp_questions/comments/4rqlto/where_does_the_spit_go_that_the_dentist_sucks_up/) \#2: [Most beautiful piece of C++ code you've seen](https://np.reddit.com/r/cpp_questions/comments/5c6wwj/most_beautiful_piece_of_c_code_youve_seen/) \#3: [C++ without ever using the letter i in your code?](https://np.reddit.com/r/cpp_questions/comments/5ztsku/c_without_ever_using_the_letter_i_in_your_code/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
I wouldn't say it's syntactic sugar because I wouldn't see templates as syntactic sugar, so I would see this feature as fundamentally next to templates. Right now, with templates you can have generics, that means type substitution. With `declname` you can even go further and have substitution for identifiers which for example enables Tuple which is a template to have customized member fields.
It's an incredibly complicated thing to add to the language just so that you can write widget.colour = "#ffffff"; instead of widget.colour("#ffffff");
That's...so not the point. The claim at issue is `int r = f(3);` is UB.
Ah, yea, that should be fine.
All good points, I think those are the design choices that you have to make depending on your project. Thanks!
Thanks for the write up! I'm the author of that paper, and intend on being in Toronto. Will have a revised paper on just the abbreviated syntax there, and split out the forwarding into its own. I guess buy one, get four free, isn't quite the intent of this whole discussing proposals thing :-)
Dot operator overloading seems like a good way to create some really confusing code.
My concern is that the bit above looks like a declaration of an extern entity, but may in fact a declaration of a template, which doesn't behave like an extern entity as far as physical design is concerned.
Just use policies or include different .cpp files for different targets. MAD.h // declares MAD_naive.cpp // defines MAD_opencl.cpp // also defines...Only include one in project Or for inline, use policies.
Problem is I'm talking about optimisation not per-target, but for the *same* target but where the compiler can pick between functions that happen to be most optimised **in a specific context** as the function is inlined. Eg I might call the function do_multiply_accumulate(1, 2, var) or do_multiply_accumulate(var1, var2, var3), and different functions might be better for each case due to the first having two constants, and the second containing non constant variables I would like to not have to keep track of exactly what's constant, or what the compiler has been able to infer (powers of two) to perform optimisations and manually call these functions. A policy based design would still mean I have to pick which function to execute based on execution policy, which doesn't seem to solve anything
Not really. Operator overloading is something you **know** is overloaded. If you can add two things, and they're not primitive types, then you **know** it's some custom behaviour. The same is not true of `a.b = c`.
Exactly! Thanks for helping in explanation.
Is this a puppet account? I ask because it's a newly made account, giving lengthy examples in response to blog articles that are currently being spammed by Odin Holmes to the cpp subedit. The comment that has been deleted by puppet account NWI4ZjQ1Yjkx Quote: --------- Thanks for the interesting post! I like your analogy about SFINAE and exceptions. As TMP is similar to functional programming, another way to put it is that a SFINAE-friendly (meta)function is like a function that returns an optional&lt;T&gt;, where a substitution failure is like returning an empty optional. I think it's a very useful feature for a metaprogramming library. Here's an example: suppose the user of the library wants to write a function that looks up a type in a list, and if it exists, one overload is used, otherwise a different overload is used. So the way you might write this at first: template &lt;typename T, typename std::enable_if_t&lt;contains_type&lt;T, SomeListOfTypes&gt;::value, int&gt; = 0&gt; auto do_something (T&amp;&amp; x) { using IndexT = find_type_t&lt;T, SomeListOfTypes&gt;; ... } On the other hand, if find_type_t is SFINAE-friendly, you could just write this: template &lt;typename T, typename IndexT = find_type_t&lt;T, SomeListOfTypes&gt;&gt; auto do_something (T&amp;&amp; x) { ... } Without SFINAE-friendliness, you often need to write two metafunctions: one to check for the error case, and another to compute the result once you've made sure there won't be an error. The SFINAE-friendly version is also more flexible, because the caller can still choose to use it in a non-SFINAE way: template &lt;typename T&gt; auto do_something (T&amp;&amp; x) { // now it's a hard error if the type doesn't exist in the list. using IndexT = find_type_t&lt;T, SomeListOfTypes&gt;; ... } Of course, Concepts are expected to make enable_if obsolete in a few years, but in order for this example to have a natural analog in a Concepts-aware metaprogramming library, you would need to generalize a Concept from a predicate returning a simple bool to a function returning an (meta)Optional (either "false" (None) or "true" (with a type, in this example, IndexT)). In F#, there's a feature called Active Patterns, which come in two flavors: total and partial. A SFINAE-friendly (meta)function is like a partial Active Pattern, and a non-SFINAE-friendly function is like a total Active Pattern. So one way to get a better understanding of when SFINAE-friendliness is appropriate is to look at F# examples of partial vs. total Active Patterns. --------- Odin naughty naughty. 
I can buy that. I personally think it's not that big of a problem, but it _is_ a problem. :)
I'll reply to you and /u/ProgramMax because you basically said the same thing Constants are just one thing in the world of compiler optimisations. Say you have a variable where the compiler is able to infer that your value is a power of two. Or the compiler spots some common subexpressions in one kind of argument, but not others. Compilers are real smart these days and can do a whole bunch of stuff, and can know a bunch about variables that's totally hidden from the user I would like the compiler to pick between two functions on at least most of its available optimisations in that context - one function (eg mads) might suck for a power of two argument, but the second function might optimise really well for a power of two argument. Const/non const is only one aspect of what I would like
Please note a puppet account by the name: NWI4ZjQ1Yjkx has been giving responses to posts initiated by the user **Odinthenerd** (Odin Holmes). It is a shame Odin felt he needed to go to these lengths. He usually has interesting things to say about C++ and this was not required.
&gt; Your Drawable example is fine because it's already a template. The problem is that `Surface` is a concept, not a type... and you can't specify that a `Drawable` must have a member function `draw` that accepts any type that models `Surface` - you can only specify a particular type.
 #define exforward(x) std::forward&lt;decltype(x)&gt;(x) ?
Of course, I didn't say it wouldn't be useful in application code, but it'll still be most useful for libraries, and leaving a syntactic sugar to be added later is a minor issue compared to leaving out everything else.
If you don't mind I would really appreciate a response to my comment [somewhere above](https://www.reddit.com/r/cpp/comments/61r0qf/rfc_template_declname_parameter_and/dfit95r/) :).
you can do the same with template specialization in C++
It's public on [github](https://github.com/jamboree/clang/tree/feature/D2) (D2 branch). You can find the corresponding LLVM [here](https://github.com/jamboree/llvm), but I don't have any change in LLVM. Template declname parameters and uniform designators/designating types are implemented. Pack expansion needs more work... And yes, I'm aware of std-proposals, as I've posted [this draft](https://jamboree.github.io/designator-draft.html) there, and people asked me "what about templates?", so I developed template declname parameters. I'll post there again once I have some more well-written drafts.
POSIX also reserves names starting with 'str' followed by a lowercase letter, so C++ was already breaking POSIX compliance with string* and stream*.
Hey that's a good one. I'm working one of the deep learning labs and this is cool!
Yes, I've used cout in the final task to print the results of PI and fibonacci. But after removing it, the time used is still not significant different than before. I still don't know the reasons why Windows is slower than Linux. It may be the different of OS's scheduler of context switch or may be compiler optimisation.
If you don't mind looking up where things are defined, then you shouldn't mind looking up whether `b` in `a.b = c` is a property.
Sorry that I didn't explain in detail. The number of threads is equal to the number of core minus 1. You can see it from the ThreadPool code of my last post. Because I can determine number of tasks so it should the same as the number of threads to make the queue as short as possible. However I also tried to increase number of tasks but the result of time used is not significant different. May be ThreadPool can do his job well. Am I wrong?
Yes because looking up third party class documentation and moving my eyes up thirty pixels are clearly at the same level of effort. I'm okay with looking up what something does when it's immediately obvious that it does something special. I'm not okay with looking up what **literally every `a.b` does in a 100k LOC C++ project**.
What do you mean by "lightweight" IDE? QtCreator is probably the "lightest" of the IDEs going around. Visual Studio is perhaps the most full-featured one at least on Windows. I personally use Netbeans with cmake+ninja as the build system. Works well for my needs.
That surprises me! In the case of the templates: template &lt;typename A, typename B&gt; void f(A a, B b); ...it is "obvious" to me that A and B may or may not be the same time, just as: template &lt;typename A&gt; void f(A a, A b); ...tells me to expect 'a' and 'b' to be the same type. So, if (other syntactic considerations aside) I have: void f(InputIterator a, InputIterator b); ...and I know "InputIterator" is a /concept/, I expect that 'a' and 'b' may OR MAY NOT be the same type, but both WILL satisfy InputIterator. I don't see how any other interpretation would be useful, in fact... but, well, sounds like other folks feel differently! 
MAD can provide different results due to the finer details of floating point math. This is exactly where you want programmer control and explicit options to alter the math for speed vs precision. That may be better expressed as a higher abstraction in the long term though, eg mad_precise vs mad_fast library functions.
It looks like it is, but GCC [fails](https://wandbox.org/permlink/qq3iKXY28tDfkTKx) to eat this code. And quick look over concepts [paper](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4641.pdf) doesn't reveal whether it's an implementation issue or it just isn't envisaged.
POSIX and C++ is not the same thing. C++ has no such requirement to honour POSIX specification.
The most unique feature "languange diversity" from all build systems is the one that I like most. Currently, we use it for almost an year with a c++ and javascript web application. Before that CMake was used for both and it was alfully unreliable and difficult to grasp how to build.
I have to wonder why no one proposed a disambiguity keyword a la `typename`. We currently have `const typename X::foo` as a valid syntax to disambiguate, so why couldn't we do `const concept Foo&amp;`? That way it makes it clear that the following type is a `concept` and should be implemented in a header. The cost is a minor verbosity increase but I can't imagine there being more cons than that one.
No you cannot. You can _emulate_ it, adding a lot of boilerplate (just consider member functions, EBO, ...), but you cannot do exactly the same. Unless by "the same" you mean "get the same behavior", in which case you are correct, and so would I if I say that you can do "the same" using only a single assembly instruction, or even no assembly instructions at all.
I am not saying we should have properties in C++ just explaining why properties are nice, even though they are just *syntactic sugar*.
(So I could see why you might be biased, build2 and all that...) I think you've actually gotten your assessment backwards. Making the toolchain part of the input means that cross-builds are trivial. Need to build and test on Linux and Clang? Fine, maybe that's your default. Oh, want GCC? No problem, just define the GCC toolchain, then run your test with `--compiler=gcc`. Want to compile using MSVC under Wine? That's actually possible. (True story. It is quite possible, I use this on a regular basis. And after defining the toolchain -- once, ever -- it *literally* requires only a flag change and a single command to switch back and forth. I cannot stress enough how much I am *not* exaggerating.) Bazel is big and complicated enough that people tend to be put off by its internal complexity. That's unfortunate, because it does a fantastic job of separating the complexity that typically comes with a build system, from the complexity of the thing being built. Switching from, say, CMake to Bazel is like switching from assembly to C. It's *literally* that much more powerful and portable.
Off-topic.
You are the one who found it funny that `static if `got rejected but `if constexpr` accepted. I find that what happened makes a lot of sense; they are very different features.
1) Yea, you're right. In a way it is public API and somebody is going to use it, so flushing is probably still the right thing to do in order to prevent unpleasant surprises for the user. 2) Advantages of my own integer parser: locale-independent, supports binary numbers, supports exponents, independent of `errno` and thus thread safe. The code already exists so I don't see any reason to give up these advantages. 5) Yea, I'm going to fix that, at least in the UNIX case. Not sure if I want a system call only to cover a rare case on Windows. I think it's safe to say that no sane developer puts slashes in their application's name and expects every API to function 100% correctly. But thanks a lot for pointing this issue out! The more you know...
At this point c++ could use a full-fledged defmacro
maybe I should have made more of disclaimer ;) C++ template metaprogramming is more of a language within the language.
Looks great! I will spend a few hours on this this week-end.
Yeah, the manipulation part is kinda important :) Even if the "manipulation" amounts to changing the binary representation to make it compatible with the platform's requirements. Image format conversions, to be quick, require somewhat specialized code that most compiler's can't vectorize from generic C/C++ yet. And from there things only get more complex. So yeah, a library that merely reads an image into memory and presents it in some arbitrary preset format, or dumps it to disk, is nowhere near enough to do anything with the image other than getting it from one file to another, and it's very hard to use such a library without other libraries that would demarcate their functionality at the same place and take over from there.
I do not know much about neural network but what exactly is meant by "portability"? What kind of platform dependent stuff do these kinds of libraries use?
IDK if my sarcasm is not obvious, but static if was rejected for c++14 but inferior constexpr if and concepts were pushed. :) 
But this sort of example isn't very compelling, because an overload set like this should not be exposed in your public interface. Your interface should just contain the first overload: the fact that it might be implemented differently depending on the concepts satisfied ought to be an implementation detail. Having multiple overloads in the public interface is damaging, not just because it exposes those implementation details, but also because it will make the error messages worse if the function is used incorrectly. Concept overloading could still be used in the implementation, but "if constexpr" is going to be a more straightforward method in most cases. For these reasons, I'm starting to wonder whether overloading on concepts is really a good idea, now that we have if constexpr. Certainly the specification would be a lot simpler if this aspect was removed.
spacemacs w/ rtags &amp; ycmd.
But they're so useful!
This kind of syntax is *precisely* what properties try to get us away from. Kind of like the (insane) `get&lt;&gt;()` on tuples.
Garbage collection works and has zillions of pieces of software using it. Just saying.
Vendor-specific extensions *are* C++, just vendor-specific. I've been using them since forever in MSVC and Intel C++ and I suspect they are supported in other compilers too.
It could but the uglyness of it is what bothers me.
&gt; But this sort of example isn't very compelling, because an overload set like this should not be exposed in your public interface. Sure. This was just a simple example: if you prefer, imagine the above functions were all named `foo_impl()` and a public function `foo()` just dispatches to `foo_impl()`. &gt; Concept overloading could still be used in the implementation, but "if constexpr" is going to be a more straightforward method in most cases. In this simple case yes, but don't forget that concept overloading is able to "pattern match" on multiple function parameters at once, which could quickly get messy using `if constexpr`.
My intent was that an intrinsic could contextually know whether it was running in a constant environment or not. Like `__builtin_strlen` for example.
?
You should probably report this using the feedback button on VS.
&gt;To fix this, you have to guess what the compiler knows about a variable No, you have this backwards; to fix this, the *compiler* has to guess what *you* mean when you say `variable = expression`. Do you actually want the value of `expression`, or do you just want something close enough to it for your purposes? How is the compiler to know? It can't, and no mechanism you could devise would give it all the information it needs to do what you want it to do. Sorry, but if these fiddly approximative optimizations mean so much to you, then the best you can do is just use your approximation functions and be very careful not to write any "accidentally stupid" code.
Then they should probably learn them.
It's not that hard to develop for it. Not the answer you hoped for, but quite possibly the best alternative is for you to make it better for your own needs. The nominal alternatives on all platforms are CLion and Eclipse with various plugins.
Been using it for years. What are these quirks you speak about?
While I don't use an IDE, the one that's advanced immensely in the recent years is KDevelop. You should try it to see if it works for you. 
CLion. Still nothing can beat VS. Technically Qt makes your project "platform agnostic" so you could develop in Windows and port to Linux. 
 Why does the OpenCL compiler not optimize this into MAD/FMA? Is it because FMA has extra precision? Are you sure there isn't a flag to indicate you do not care about any difference in precision? If the OpenCL compiler is really this stupid, you could treat constants are separate types, likely using some combination of constexpr and user-defined literals, and overload your MAD for each combination. At least on the CPU side, on modern intel chips FMA/MUL/ADD are all 4 cycle, so it won't matter much on the host. 
I gave up on it cause it crashed a lot, sometimes losing code.
I do use it exclusively, and I really like it. It has more features than QtCreator, and works well with both Qt and non-Qt code. 
As someone who will not be able to go to this conference, do you happen to know if videos of the presentations will be made available after the conference is over?
Edited: &gt; The difference between rustc 1.16 and rustc 1.17 is similar to the difference between gcc 6.2 and gcc 6.3, neither offer a flag for a minor release. Into the current version. You are correct that Rust is moving forward; my point was strictly related to backward incompatibilities. gcc doesn't introduce a flag for each bug fix.
It's not a "true" IDE but I've been using [Atom](https://atom.io) lately with a handful of nice plugins.
&gt;Why does the OpenCL compiler not optimize this into MAD/FMA? Is it because FMA has extra precision? Are you sure there isn't a flag to indicate you do not care about any difference in precision? This flag exists and does nothing, i have profiled this and checked the spec for anything I've missed &gt;If the OpenCL compiler is really this stupid, you could treat constants are separate types, likely using some combination of constexpr and user-defined literals, and overload your MAD for each combination. Its just not constant vs non constant though, there are other issues like 2 power optimisations which it would be nice to have automatically. I'd like to leverage the entire optimisation potential of the compiler, not just what I know about &gt;At least on the CPU side, on modern intel chips FMA/MUL/ADD are all 4 cycle, so it won't matter much on the host. Sure sure, but sometimes the performance difference between context optimised version and the generic version can be very large - variables that are sometimes constant can take a while to calculate so this is a very desirable optimisation for me
What does "just define the GCC toolchain" entail, *literally*? How would one "define" a VC toolchain to run on Windows? &gt; Want to compile using MSVC under Wine? That's actually possible. [Tell me about it](https://git.build2.org/cgit/etc/msvc-linux/).
&gt; Do you actually want the value of expression, or do you just want something close enough to it for your purposes? How is the compiler to know? It can't, and no mechanism you could devise would give it all the information it needs to do what you want it to do There's a fairly direct and simple mechanism: you define a function called sin_variable, and inside provide two separate definitions that the compiler can pick between. Bam, ez &gt;Sorry, but if these fiddly approximative optimizations mean so much to you, then the best you can do is just use your approximation functions and be very careful not to write any "accidentally stupid" code. I'm uuh.. i'm not sure why you're phrasing this in such a condescending way, context specific optimisations can speed up my code by ~50% because eg constants can be large, and gpus are pretty slow. Mads vs non mads can shave off quite a bit of time, so this is a worthwhile problem for me Of couse the best currently is to do that, but I'm saying this would be a pretty handy feature for me, and likely others
Netbeans is great for C++, especially the latest versions.
That's a shame because it enables so much productivity. But such is life.
Thanks for the info about alignas(). I didn't know you could use it for member variables. I thought it was only whole classes/structs. This is really useful. For why I use an atomic pointer to m_array instead of just using the array directly: It's required for the Grow(). Essentially, we grow the array by allocating a new array and copying the elements from the old one to the new old. This is obviously not atomic. That said, growing and pushing can only happen in the current thread. So, while we are copying, the only thing that another thread can do is steal. So we can safely make the new array, copy over the elements, and then when that memory is flushed, write the new address to the pointer variable. If a thread steals while we're copying, nothing happens; the old array is still valid. And when it steals again, it will get the pointer to the new array.
But GCC *does* offer a flag indicating which language standard of C++ I wish to target (whether or not the compiler is 100% compliant is irrelevant, since this has already been beaten to death and does not answer what I am asking). You admitted that Rust Language v1.10 is different than v1.15. `rustc` should support being able to switch ***to some degree***. This should at least be considered since this feature will be needed when some language version with some breaking changes ships. It seems backwards that so many rust folks are all about language stability, then offer *none* of it with their **only** compiler. I should be able to use a newer `rustc` compiler and run it in a `rust1.14` mode. I don't think this is unreasonable.
CLion probably the best. 
&gt; Rust has a better track record of backwards compatibility than C++. I should have clarified. I meant C++ compilers, not the language. Ultimately, my problem lies with the limitations of `rustc`, not the Rust Language.
It never crashed for me. Once.
Nothing to do with the conference itself, but as someone who spent a couple of years living in NZ, I have to say it's fantastic to see Christchurch getting back on its feet enough to host events like this.
The 2016 releases (and earlier) were appallingly slow, and the parsing was often full of false positives. They've just released 2017.1 which apparently fixes much of this, though I haven't tried it yet.
Worth noting that with the [cpptools](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools) and [cmake-tools](https://marketplace.visualstudio.com/items?itemName=vector-of-bool.cmake-tools) plugins, VSCode is relatively comparable to just about every IDE other than VS proper I've personally interacted with (havent' used newer Kdevelop though). Given what an obnoxious UX step backwards the cmake integration in VS proper is compared to its normal solution support, VSCode+cmake ends up being pretty much identical in usability to VS+cmake. The setup is a little annoying, there's no builtin profiler or graphics debugger, and VSCode desparately needs a real multi-monitor story, but otherwise all the usual stuff works just great.
&gt; customized member fields. And I would want that because...? Like I said I honestly hope this is never added to C++, but I am open to being wrong if Eric Niebler, Howard Hinnant and STL all testify under oath ;) that this is cool and needed. 
I like Eclipse CDT but apparently that makes me a part of a very small minority. :)
Mint 18 and Cinnamon desktop. Would crash for me a couple times a day, just enough to piss me off. KDevelop worked almost the exact same way but never failed on me.
For years I used the Netbeans C/C++ IDE. It's surprisingly good, and much more stable than any of the Eclipse CDT versions I tried. But when I switched to C++11, its features started to fail miserably on even fairly simple constructs. I've switched to CLion, and never looked back.
Distro packages for g++, cmake, and QtCreator. 
The problem with the distro packaging is that the bug reports don't reach the Qt Creator devs directly, they have a middle man. Try Qt Creator from download.qt.io, it comes with its own version if Qt, and rock solid.
Nope, they have a custom parser.
why is VS good?
POSIX happily defers to the C standard, and acknowledges the existence of C++ at least in a footnote, so I would assume that POSIX people won't knowingly use their reserved identifiers to sabotage an existing C++ standard definition.
CodeLite https://codelite.org/
My full prediction is that eventually they will have a POC implementation with a clang-based parser and people will like it so much that they will drop the custom parser.
I'm not at all proposing adding `png_to_bitmap` or `bitmap_to_png` to C++. That would be a mistake, in my opinion. But to play devil's advocate, you are overthinking this way too much. Those functions *are* all that would be necessary. C++ developers know how to iterate over arrays. &gt;So yeah, a library that merely reads an image into memory and presents it in some arbitrary preset format, or dumps it to disk, is nowhere near enough to do anything with the image False. Simply false. Manipulating raw pixel values is *incredibly* useful.
I like [KDevelop](https://www.kdevelop.org/) the most. Just the right combination of text editor and IDE that doesn't get into the way.
Upvoting for your self-awareness, not because I endorse Eclipse!
I think what you're getting at here is [constexpr](http://en.cppreference.com/w/cpp/language/constexpr).
In Qt Creator, you can disable the clang code model and use the old one instead.
I don't know about Bazel, but GN is awesome, and I believe google will eventually replace Bazel with GN. It was built to replace GYP, and it is the most amazing build system I've come across for C++ so far... It is full-fledged, and it could be used as a the basis for a proper package management in C++... alas, we don't have it.
&gt; Mint 18, Distro packages Then you are probably using an old version. Qt Creator is rock solid (though it has other annoyances). 
Has the python plugin improved a lot more?
This is harder than it sounds. Check out ATLAS (automatically tuned linear algebra subroutines) for an example of this. Turns out CPU features and power management get in the way
http://milianw.de/blog/heaptrack-a-heap-memory-profiler-for-linux
&gt; defect reports Like these? http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html Let's not forget about this note (in boldface): &gt; Issues with DR, accepted, DRWP, and WP status are NOT part of the International Standard for C++.
I'm not lying: https://godbolt.org/g/XVVPm9 You are the one who is not using clang, and specifying more things than `-std=c++11`. One gets a warning, but that's about it.
Yet every compiler implements them: http://clang.llvm.org/cxx_dr_status.html deviating from what the standard specifies (since most of them not only add text, but also replace the standard text with different one).
I've used this before to write a nice strong typedef class.
Because compilers are free to implement their own extensions, like providing CUDA support (clang), or Vector Extensions (gcc, clang). GCC and Clang are not strictly C++ compilers, but you can make them behave as such. I think it's a reasonable comparison. As for justifying `-pedantic-errors`: &gt; -pedantic &gt; Issue all the warnings demanded by strict ISO C and ISO C++; reject all programs that use forbidden extensions, and some other programs that do not follow ISO C and ISO C++. For ISO C, follows the version of the ISO C standard specified by any -std option used. Valid ISO C and ISO C++ programs should compile properly with or without this option (though a rare few require -ansi or a -std option specifying the required version of ISO C). However, without this option, certain GNU extensions and traditional C and C++ features are supported as well. With this option, they are rejected. &gt; -pedantic-errors &gt; Give an error whenever the base standard (see -Wpedantic) requires a diagnostic, in some cases where there is undefined behavior at compile-time and in some other cases that do not prevent compilation of programs that are valid according to the standard. This is not equivalent to -Werror=pedantic, since there are errors enabled by this option and not enabled by the latter and vice versa.
Err is this really expert level meta-programming? Once you have a trait defined, you just do: template &lt;class T, std::enable_if_t&lt;is_forward_range_v&lt;T&gt;, int&gt; = 0&gt; foo(const T&amp; range) { ... } This is very easy. It seems like the main thing that concepts gives you is making it easier to write the trait. What am I missing?
And `rustc` should be able to have the language standard specified as a command-line argument e.g. `-std=1.14` or `-std=1.16`
why? no c++ compiler (and c++ standard library) has this either in a way that works reliably (e.g. be able to select which defect reports one wants to use, or really stick to only a particular standard without extensions).
CDT is fine. Admittedly i use Eclipse mostly for Python work, via PyDev, but CDT does the job. 
Btw, the real solution to this problem is to require a translation unit to be compiled by a specific compiler version. If you really want reliable behavior, this works much better than passing a flag to a compiler and require it to emulate old behavior (which is often not possible implementation wise, hence why most C++ compilers don't get this right).
FYI, you've been shadowbanned. You must contact a reddit admin to get that lifted (subreddit mods can approve comments but can't lift shadowbans).
Am I the only one around still using Anjuta these days? I use it for both C and C++ projects. Some good plugins extend the ide.
Yes, out of ~7.5 billion people, YOU are the only one.
&gt;Some of the features are cheap on Linux but super expensive otherwise on other platforms. 6 months ago, if you tried to use Boost on Mac or Windows with its thousands of files and header isolation? Fuck this annoys me. So much developer time goes into fixing things so they work on stupid slow broken platforms. So much developer time and effort has gone into this shit in so many different projects.
How painful is it to migrate from gyp to gn?
Why would you need to convert the format? Build a library using expression templates that applies transformations in a single pass. &gt;So now you're talking an image loader library and an image format converter. Next you add a basic triangle rasterizer, a convolution filter Even if you had the first two, which would be fine, you certainly do not need a triangle rasteriser, or a convolution filter, or 'a couple more steps'. Please don't exaggerate. &gt;I don't see the need for the arbitrary line you've drawn at "here's pixels in a format that likely is not very useful for you, go figure it out". Because it's useful. Again, I'm not saying that it should be added. I'm saying that it's not true that if it were added, it would be useless.
Yusss! I will be there. C++ is my hobby and so much looking forward to this. 
Oh yeah no question. But stuff like the minutia of how install(EXPORT) and export(TARGET) and how those little export temporary names work is kinda strange. But tbh being able to click configure and generate and have the build work EVEN ON WINDOWS is worth it
I like CDT as well. It's too bad Eclipse is so damn sluggish overall.
I use Conan. I like being able to use system packages and once you understand it export() combined with the BUILD_INTERFACE generator work well, and you can use things just like an external user would.
It's not enough. You still have to manage a huge matrix of binaries for each supported platform, arch, compiler, compiler options... Or then hope that the "--build missing" functionality is working for all your dependencies, and my gut feeling is that it won't propagate ABI changing flags.
I write my own conanfiles and it actually does tend to work on all platforms if it works on windows
Eclipse CDT is awesome! But there is a hidden trick. You need to seriously increase JVM memory limit for it to work fast. I have enabled 8Gb heap in JVM settings of Eclipse and 2Gb cache for indexer. Now it's very fast and responsive and reindexing of a big project takes reasonable amount of time.
Yay, it looks great! I'm looking forward to it.
I really don't have a single clue why they might have had a reason to implement their own parser (buggy and slow) instead of using an existing one, which is good.
How good is it at parsing c++11? I thought it used the same autocomplete as QtCreator. If be willing to try it if it is better so compete then QtCreator for things like auto.
Head over to https://www.meetup.com/SydneyCPlusPlusMeetup/ Should be slides released (with potential audio) over the next couple of days...
Great, but the most basic functionality is broken: I cannot copy&amp;paste code anymore.
Do you have any material about setting that up? Sounds pretty good.
The commercial tools we are currently looking into are: AQ Time: https://smartbear.com/product/aqtime-pro/overview/ BoundsChecker: https://www.microfocus.com/products/devpartner/ and Intel Inspector: https://software.intel.com/en-us/intel-inspector-xe 
QtCreator uses clang for completion, so every "auto" should allow completion
Works here - Firefox 52.
GNOME Builder has basic CMake support since last versions. But haven't tried yet.
No as good as PyCharm but I really like it.
https://nickdesaulniers.github.io/blog/2015/07/23/additional-c-slash-c-plus-plus-tooling/
support of c++11/14 was added and stability was highly improved
&gt; QtCreator uses clang for completion, so every "auto" should allow completion I believe it is not active by default. In our company, we use QtCreator to develop a project that uses Qt. The project is now very big and you can really feel it now. QtCreator crashes at least once a day and it sometimes freezes for several seconds when it tries to autocomplete, when you have e.g. unclosed string or a comment. Autocompletion of templated code is almost non-existent (only works for simple templates). Autocompletion of "auto" is also usually non-existent. Clang model is very slow and consumes lot of memory for our project, also there are some parsing error, probably due to how it pretends to be a GCC (ve use MSVC and GCC compiler, while MSVC is active, the defines for clang model are probably wrong). Opening a project with clang model means waiting for 10 minutes to parse it, with an SSD drive.
Yep, I also use mainly the middle mouse button. So... Hm, not good.
Could you provide an example? I genuinely interested how you use variadic templates to do that. 
I didn't mean every single use or abuse of static if, I meant static if at class scope, for the example you've given; you have if constexpr for function scope; what were you referring to? 
+1 :)
&gt; QtCreator crashes at least once a day Something I noticed is that the Clang code model takes up humongous amounts of memory (but my binaries are on the gigabyte side when compiled in debug mode so I don't see a solution for this besides [downloading more ram](http://www.downloadmoreram.com/download.html)). However it has no problem for me completing sfinae beasts from the seventh circle of hell.
Have you considering implementing it like `Try` monad in scala? It should compose better..
If you are on Windows, the easiest way to deal with memory leaks is with the CRT (assuming you are using MSVC): https://msdn.microsoft.com/en-us/library/e5ewb1h3(vs.90).aspx This "tool" is not dynamic, but it still detects memory leaks, and has less overhead than a dynamic one.
I'm trying to fix it! Sorry for not realizing that this was missing!! But https://github.com/Microsoft/monaco-editor/issues/391 seems to have something to do
Yeah, exactly. You simply highlight text while holding the left button down and then paste by clicking the middle mouse button. Thanks in advance for the fix!
Out of interest, anyone on here living in Wellington? Was thinking of getting a user group together. 
On most UNIX implementations, there are actually two copy/paste buffers. 'mouse3' is a paste but it comes from a different buffer than ctrl-v. You can highlight text and they automatically get sucked into the 'mouse3' paste buffer, or you can ctrl-c in some applications and they go into a different paste buffer. See 'background' here where it talks about two buffers: https://www.starnet.com/xwin32kb/copying-and-pasting-in-xterm/
Some colleagues tried this and they said it didn't give them much useful information. I haven't tried it myself yet.
Are you experienced with vim? If so, then it's not terribly difficult. The key is having a compilation database (generated either by cmake or bear). Install YCM from here: https://github.com/Valloric/YouCompleteMe YCM requires a special script to access the compilation flags of each file. This is great because you can implement reasonable fallbacks when it's not found for some reason. In rpclib, I implement this the following way: https://github.com/rpclib/rpclib/blob/master/CMakeLists.txt#L265 https://github.com/rpclib/rpclib/blob/master/.ycm_extra_conf.py For the sanitizers, I just add the respective -fsanitize flag manually whenever I want to use it. I compiled rtags from source: https://github.com/Andersbakken/rtags And used this vim plugin for integration: https://github.com/lyuts/vim-rtags It's important that rtags has a client-server architecture with and you need to run the rtags server and rtags indexer (rc) alongside vim. rc has to run in the project directory. I use screen to run these processes in the background, but a separate terminal window works just as well. And since I also develop with Visual Studio + Visual Assist, I rebound the vim-rtags keys to mimic the VA ones. 
VS intellisense(even 2017) is buggy and sluggish, and also generates huge db file for each of your solution. It's simply not usable for c++ coding without extension like visual assist(which will cost you lots of money).
Now make a vim implementation.
It's not that you can't, it's just that a lot of people will only install a software from their distribution's repository if it's available there and ignore OOB updates, even when compatible binaries are available from the developer's website. So distributions that are locked for many years and holding everyone back. Ubuntu Precise has 2.8.7, Trusty has 2.8.12 so people will still target both. Travis-CI, a popular free CI service for OSS defaults to precise (even if it's going to enter extended support in a matter of days IIRC). When said software isn't available in the repository, then people are accepting the fact they need to install from another source and can update it at will. It is ironic that this is a non issue on Windows and macOS as people have no problem updating, and everyone is saying their Linux distribution is superior when they can't update software at all or get a new parallel installation with a newer version. I love Linux, the convenience and stability but I don't quite agree with all the design choices of some distributions.
&gt; Libclang tools aren't well-received in the Emacs community Why not?
I'm not very familiar with our Windows support (obviously) but I checked with someone who was: right now we just produce a DLL as output. The .lib file is produced by the linker as well, but Bazel doesn't actually know about it yet. We are planing to teach Bazel how to handle dll, lib and pdb files properly, [Support MSVC natively](https://github.com/bazelbuild/bazel/issues/1488) would be the issue to track, but there's not much there now. It's scheduled for 0.6 (we're working on 0.5, right now).
I second that. VSCode with some plugins (notably cpp and Vim extension) can be a really good tool. I've been using it for a couple of month and won't change it by now.
Actually I have written a tiny program to test if clang allows a friend function of a class to access the private constructor of this class. Surprisingly YES! So I guess there might be something wrong or not compatible in the declaration / definition of the friend function in OP's program.
Ah, I did not notice the different syntax. Thanks. That makes what looked like different addressing modes similar. That leaves the different moves, and a rep ret.
I heard about CLion a year and a half ago from a Ruby developer here. That Ruby developer no longer works here, but I've since met the CLion team at cppcon 2016 and decided to try it. There are some things that are a bit more annoying than Qt Creator (in particular, I think Qt Creator has better / more intuitive split views) but just about everything else that I've used is on par or better than Qt Creator. Admittedly, I don't build UIs so I can't say if that's better or worse. I also don't actually use Qt, so I can't say how well (or not) its integration with Qt is. But its integration with CMake, for example, is far superior. Its ability to parse more than just CPP is far better (syntax highlighting for CMakeLists.txt, bash, etc... Ruby with additional license, etc).
Is there a way to have more than one compiler window per source window?
There are problems with that approach on the big projects - the cost of refactoring becoming too big. And usually, there is not enough time to refactor the project own code, let alone the points where it interacts with others. Small, independent components could sovle this problem, but lets be real - most of real projects are "monolithic monstrosity" to some extent.
First the bad: The ways to generate compiler flags for autocomplete (I use ycm) were sluggish and hacky. Builds were slower than ninja. Transitive dependencies between external dependencies is messy. The good: wild card matching makes build files smaller, and unlike cmake do not become stale. I like just writing small bazel build files for my dependencies rather than stringing together multiple build systems. 
I find this really interesting. Of all the approaches to strong typedef I have seen, I find this the cleanest. Is there any library which already implements this?
Thanks for the info (and for not trying to spin it like OP).
I see a couple downsides. :-/ 1\. attempt/handle doesn't seem very different from try/catch. 2\. And this is the big one: **You have to do status checking.** auto first_line = checked("input.txt"); if (!first_line) { // function failed (no output) } The whole point of exceptions is 1) you can't forget to check them; they propagate automatically, and 2) a lot less boilerplate since you don't have to check the status of every operation. You've neutered both of those benefits.
You've been shadowbanned and must talk to a reddit admin to get that lifted.
Ninja can also generate a compilation database (if that is more convenient than using CMake): `ninja -t compdb` https://ninja-build.org/manual.html#_extra_tools
ABI compatibility on a class that is not static asserted as being standard layout is a lost cause anyhow. And ABI compatibility guarantees throughout a larger C++ codebase are almost impossible anyhow. If this is something you want to do you have a C API/ABI. My point is basically, this is good to note but no big loss.
Emacs is a GNU/FSF project, licensed under GPL, while LLVM/Clang is BSD-licensed. By GNU's standard, LLVM is not sufficiently free to promote the interests of users. See [this](https://news.slashdot.org/story/14/01/24/1838241/fsfs-richard-stallman-calls-llvm-a-terrible-setback) link for more.
Good to know, thanks!
Don't worry, it's probably just me. I just feel the new GUI with all the new features could need a small update. Fonts, arrangement of buttons, margins, etc. to make it look more consistent. However, keep up this great work! Can't say it often enough, it's an amazing tool! Thanks.
Thanks, I'll play around with this and see what I can find.
Visual assist is not terribly expensive according to commercial development tools standards. But I agree with your point, at least on older versions of VS (haven't used 2015 or 2017 much)
The point it, you said *most extensions are not implemented in more than one compiler*, well this one *is*. And since the whole discussion is around properties, it's kind of relevant, is it not? I'm not suggesting `__declspec(property)` become the standard. I'd opt for something better. I'm just saying that an equivalent feature is already there, it works and is actually being used by people. From what I recall, real-life implementations is one of those things the committee cares about.
Great to hear, but as someone from Australia I don't see it worth the cost for 8 talks.
hm... not sure what was wrong.. why?
Pull requests are welcomed for smaller features. If you have a big change, ping me over email and/or file a GH issue first to track it.
I don't think you could do this to create defaulted copy or move constructors though, which is rather unfortunate because that would be *extremely* helpful.
You mean injecting a derived-class constructor through CRTP? I could sort of picture what you're getting at, but I don't quite see the use yet.
OP here. Thank you to everybody that posted in reply to this! I found the answers to be very helpful and encouraging! I think that a reasonable course of action (which I have started in on) is to revisit some the basics, to start from the ground up. I got a copy of C++ Primer and think working my way through that excellent book will provide a more solid foundation in the language which has evolved so much since I first learned it. I also grabbed a copy of C++ Template Metaprogramming!
I am not yet sure who 'pacificplus' is, but this wasn't posted by the conference organiser. 
Currently I am not sure if the videos will be posted online after the conference. It is something that is definitely being considered. Thanks.
Wait what? I thought Qt creator was at 5.8 or something
You should be able to use MSVC2015 binaries with 2017 without much problems in the meantime.
Thanks for chiming in here.
I always enjoy seeing these updates. The CMake support is really getting along, especially compared to what was there 2 years ago. Keep up the great work!
I too was surprised to hear it being organised in NZ as opposed to AU. 
It never crashes for me.
CLion! It's fully compatible with cmake. 
Build call trees from every point of usage of some symbol/function upwards. Clicking on a function name in the tree jumps to that function in the editor. https://bugreports.qt.io/browse/QTCREATORBUG-11660?jql=text%20~%20%22call%20hierarchy%22
Yep. The problem is that we already have much better and clearer ways to solve the given problem in C++. I see no reason to introduce another less understandable method (as explained by other commenters too).
VS is *not* one of the top 10 editors anymore. It used to be (15 years ago).
It's more likely they didn't know how to use it. What I do: * start the leak detection in a common dll, in a static instance of a dedicated class. That makes it kick in soon. * include a header that overrides operator new in a way to get file/line of a leak (you get that for new, not for malloc); see MFC sources for inspiration :-) Downside: this detects leaks only for C runtime functions. It does not detect allocations from COM nor from lower-level system calls (LocalAlloc and whatnot). On Linux, Valgrind is a must :-)
Patrice is quality people. Happy to see folks like himself and Ben on cppcast in recent episodes.
There's a weird clicking sound every now and then which is very distracting. Is it in the original data or is the playback on my machine broken somehow?
2) Ok. Just a note: there is nothing thread unsafe about `errno`. It is `thread-local` variable.
Yes, for qmake projects, no for cmake projects. The sidebar has several view options. Try enabling Simplify Tree under the Filter Tree buttons menu while in Projects view, or switch to File System view.
I use it whenever tristate isn't enough and like the proposal very much.
The more general solution here would be to make any arbitrary block, `if` statement, et cetera a valid **expression** *(like Rust)*. E.g. const auto foo = if(something){ 10 } else { 15 }; const auto bar = { 15, 68 }; // bar is 68
It will work as good/bad as the current 'find all usages' feature of the Qt Creator. 'Call hierarchy' would just call 'find all usages' recursively (for each usage found, call 'find all usages' on the function that encompasses that usage). The implementation is boring: you just have to dig through the QtCreator's code to add a loop around the 'find all usages' and present the results in the GUI. 
I would love this so much! 
&gt; `const auto bar = { 15, 68 }; // bar is 68` Eeek. Isn't this a `initializer_list&lt;int&gt;` today? Or was this outlawed in the `auto` rule changes in C++17?
Yes, this syntax is already in use, that's why I proposed to use `return`with it. SuperV1234's example would look like const auto foo = if(something){ return 10; } else { return 15; }; const auto bar = { return 15, 68; }; // bar is 68
I use it all the time and this[1] example shows where i use the trick to initialize a variable and to "directly" get a result and pass it to a function(last argument on line 1028) Look around at the sources of the project and you will see it everywhere and i think i use it too much sometimes. ps: please dont comment about all those white spaces,they look much nicer on my editor and are easier on my eyes and they look much,much,much worse on github. [1] https://github.com/mhogomchungu/sirikali/blob/bcb9e8eea9d394d6db018bd94cfe914340fd4bfb/src/sirikali.cpp#L1006
When you say a c++ chat, do you actually need to do it over http? If you want to implement the http protocol you defo want to use a framework; that's far outside the scope of a uni project. There's many libs for that, as I'm sure you have found. However if you just want to make an app that can connect to another over a socket to chat over, that's different. The main problem there would be a lib for the gui and a a lib for the sockets (some libs like Qt have it all but are monstrous). Can you just make a commandline app, if you really want to do it from scratch? In which case the networking is the only thing you would need to find outside the standard library.
MXE is even better. You don't have to launch that annoying OS.
If you're using gcc/clang and are not hesitant to use extension, you can use statement expressions, e.g. const auto x = ({/* ... */ res;});
Not so long ago, an article flashed here about the fact that such a trick is an antipattern - Lambda Overdose.
Thanks, I didn't know that this extension existed.
If you're not working at Google, Microsoft, or JSF, why are their guidelines relevant? To be constructive, you're missing Sutter/Alexandrescu's book, "C++ Coding Standards: 101 Rules, Guidelines, and Best Practices".
So your beautification, entirely, is "remove `[&amp;]` and `()`"?
I hope that is a closed range, otherwise you just added a hang. And getting `0,1` when you should get `no_such_points` is a minor type error.
Well yes and no... Since rtags is editor agnostic you depend on the addon to whatever editor you use to make this functionality work out of the box. However it is fairly easy to think of a way recursively find all trees, the issue is that `rc` is not human friendly. :) If you're using emacs the addon that the creator of rtags made [should support it](https://github.com/Andersbakken/rtags/issues/728) using `rtags-references-tree`. I am using Sublime with SublimeRtags which does not support it, but it should be fairly straight forward to implement. Example (real code and queries! just made it non-identifiable unless you have access to the same codebase): └&gt; /home/usr/.local/bin/rc --absolute-path --references /home/usr/git/product/module/src/WidgetFactoryImpl.cpp:46:22 --containing-function-location /home/usr/git/product/module/test/WidgetTests.cpp:107:21: widget.setFoo(foo); function: /home/usr/git/product/module/test/WidgetTests.cpp:82:11: /home/usr/git/product/module/test/WidgetTests.cpp:249:10: widget.setFoo(foo); function: /home/usr/git/product/module/test/WidgetTests.cpp:246:16: /home/usr/git/product/module/test/WidgetTests.cpp:1536:14: widget.setFoo(foo); /home/usr/git/product/module/test/doubles/StubWidgetFactory.hpp:205:23: widgets.back()-&gt;setFoo(foo); function: /home/usr/git/product/module/test/doubles/StubWidgetFactory.hpp:200:18: /home/usr/git/product/module/src/WidgetControl.cpp:311:15: widget-&gt;setFoo(f); function: /home/usr/git/product/module/src/WidgetControl.cpp:308:10: /home/usr/git/product/module/src/WidgetControl.cpp:1327:10: widget.setFoo(f); function: /home/usr/git/product/module/src/WidgetControl.cpp:1317:19: /home/usr/git/product/module/src/WidgetFactoryImpl.cpp:46:15: widget-&gt;setFoo(foo); function: /home/usr/git/product/module/src/WidgetFactoryImpl.cpp:36:26: Now you're one regex and one recursive function away from being able to get call hierarchy. Note that if you want to deal with xml, json or elisp instead that is just --&lt;output of choice&gt;.
You need a `.editorconfig` in your repository. See [this](http://stackoverflow.com/a/33831598) Stack Overflow answer.
Yes I agree. Since reading /u/SuperV1234's comment, I was thinking that "returning scopes" is a great idea. That way, scopes would behave like traditional C++ functions: not returning means `void`and returning something will use type deduction.
I'd say [Beast](https://github.com/vinniefalco/Beast) is worth a look. It has a pretty clean and simple design and is built on Boost.Asio, a high-performance, async networking library. I use Beast for pretty much all HTTP work in C++ now, both client and server. Paired with a modern JSON library like [this](https://github.com/nlohmann/json), you can replicate a basic nodejs server with very little effort.
I'm looking to do the chat over http, but I'm also looking for a good production framewrok as well ;)
How do you specify a capture list with this proposal? 
So are you building a client - server app with the server written in c++ serving html, the clients connecting to it through a webbrowser. Or you want a peer to peer c++ app using the http protocol?
But then you possibly pollute the parent function's scope with temporary variables and non-related code. The aim is to increase locality.
I need a http server that implements a chat, no app to app chat..
It would be more of a scope block than a lambda really, so the capture list would always be [&amp;]. 
Whatever guidelines you eventually end up adopting, start with this as a foundation: http://howardhinnant.github.io/coding_guidelines.html
Well, here it's a sort of if-else vs ternary operator debate: do you prefer std::string message; if (i % 2 == 0) message = "even"; else message = "odd"; or std::string message = i % 2 ? "even" : "odd; I find the "returned value" approach much more elegant for a lot of cases.
If you're really curious, I prefer `auto message = GetMessage(i);` personally.
&gt; Our codebase is currently compiled on an old version of CentOS6 and is all pre-C++11. Our plan is to migrate to CentOS7 over the next year or two depending on time. Did you have the discussion about the [devtoolset](https://www.google.co.uk/search?q=centos6+devtools) bits? Might be a way to at least move things to C++11 until your org goes to OS7. For me the sooner the move onto unique_ptr / shared_ptr etc the better.
Yes. You may not understand it until you've been studying C++ for several years :/
&gt; which would allow some meaningless ways to use it meaningless to you. you cannot always think of the relevant use cases that may appear. 
I have been using C++ for a while and I still can't follow lambdas. Maybe some day...but for now they just make my eyes bleed.
My primary use-case for immediately-invoked lambdas is to allow variables which will never change after initialisation to be marked `const`, even when the initialisation is complex. For example int main(int argc, char** argv) { const std::string arg = [&amp;] { std::string s; if (argc &gt; 1) { s = argv[1]; // Get arg from command line if supplied } else { std::cin &gt;&gt; s; // else read from stdin } return s; }(); } The "conventional" way to write this would require `arg` to be mutable, even though its value will never subsequently change. I certainly don't consider using a lambda like this to be an anti-pattern -- quite the opposite in fact.
Personally, I think it depends on whether "GetMessage" will only ever be used in just this one place. If it's never used anywhere else, then you're probably better off with an immediately invoked lambda for initialization. **CppCoreGuidelines** [Use lambdas for complex initialization, especially of const variables](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es28-use-lambdas-for-complex-initialization-especially-of-const-variables) **Reason** It nicely encapsulates local initialization, including cleaning up scratch variables needed only for the initialization, without needing to create a needless nonlocal yet nonreusable function. 
After continued frustration, I wrote a wrapper class for `double`s that does comparison by tolerance, assuredly initializes to 0.0 unless another value is specified, and throws exceptions for mistakes like square root of a negative number. Now I almost never use a naked `double`.
At the highest meta-level, you should first decide why a rule should make it into your standard. In our corporate standard we decided that rules should protect us from bugs that we have *actually encountered* previously. This meta-rule had a real clarifying effect. So for example, ask your co-workers "how many bugs have we had based on the goto keyword" or "how many bugs have we had due to lines being longer than 80 columns." If the answer is "none" then you can ignore rules about using goto, or the number of columns in the editor. 
Thanks ! I feel better now
Hahahha. I don't even know what a lambda is ! lol
Non owning raw pointers are fine. One could create `observer_ptr` though.
**Do not fret** Every single one of the links you gave are a-ok. They also overlap - a lot. Where they differ, it's a matter of taste or context. For example, google guidelines say "no exceptions". I would have hated to code on such a codebase, but their context is an existing exception-unsafe code. Putting exceptions in that is a *bad* idea. Those lambdas - your lead has a point - up to a point. The problem with lambdas is gratuitous jumping up an down the abstraction ladder, not the best of ideas for readability. u/foonathan discusses this in one of his blog posts. So what you should obtain, I think, is "use lambdas, but within these moderation rules".
This code smells. There is a good opportunity to give this piece of code a descriptive name, placing it in a separate function. In other words, it's bad not because lambda is used, but because a function is not used.
And I will concur that is what I've seen. Generally, folks I've talked to say that it's "good enough" for most things and they toss out the stuff they disagree with. 
That is a fantastic idea! Since we're just starting out as a group, we don't have metrics about specific issues we have encountered in this particular codebase (yet). I don't want to over-rely on past experience as many of our developers have barely touched modern C++. A few of them have mentioned how much they dislike boost (and I've never gotten a straight answer from them as to why). My skim through of the codebase shows that we've got a lot of bad practices we're inheriting (many headers have a `#include namespace std;` in them, there's very little pointer checking, etc.). We may have gotten lucky so far. I definitely like the idea of building the standard around actual data - it gives it each rule strength and lets us focus. Thank you!
Agreed, and thank you for this input. So far, it doesn't look like there is a horrible amount of conditional preprocessing. Most of what I see is stuff like `#define PI=3.1415`which isn't too bad. I will probably encourage us to move away from stuff like this.
Agreed - and I think that's going to be my starting point: a skeleton based on Google's standard or the C++ Core Guidelines, and then add in pieces that make sense rather than a wholesale import+hack down. 
Thanks! I'm not overwhelmed with the task, just excited to have an opportunity to shape this program in a good way. There's definitely a lot of stuff in them that I think is common sense (particularly in the Secure Coding / CERT standard). I talked a bit more with my lead today, and the thing that they are really concerned about is maintainability of the codebase. I think I'm beginning to talk them out of a wholesale ban on lambdas, but I've got a ways to go yet. Thank you for pointing out the post from /u/foonathan - I'll read it this weekend.
Program requirements dictate this. The software is deployed onto a system running CentOS6. Moving from CentOS6 to 7 will be a major leap in the technology stack of the development infrastructure. 
Thanks - I disagree with your priority order, specifically for this effort. Correctness is #1, followed by maintainability, then comes performance concerns. 
You will discover that C++, with its Standard Library, is a *huge* language. Try not to be overwhelmed, but just keep chipping away at it.
How can I return an optional reference to a base class whose owner has unique ownership then ? e.g. class foo { virtual ~foo() {} }; class bah { public: ???? getFoo() { return ????; } ; private: std::unique_ptr&lt;foo&gt; m_foo; }; `std::optional&lt;T&amp;&gt;` would be nice but is explicitely disallowed.
I'm glad you emphasize that, because some discussions of pointers assume that a pointer always means ownership, and incorrectly state the conclusion that `std::unique_ptr` or `std::shared_ptr` will be a satisfactory substitute for any raw pointer. 
Do youknow where I could find the docs from proxygen?
Well, there's nothing preventing you from writing `std::optional&lt;std::reference_wrapper&lt;foo&gt;&gt;`.
If you feel the need to embed secure coding concept in your standard then OSWAP is a good source. https://www.owasp.org/index.php/Main_Page
that is exactly the point of C++ Core Guidelines, to quote &gt; These guidelines address the core of C++ and its use. We expect that most large organizations, specific application areas, and even large projects will need further rules, possibly further restrictions, and further library support. For example, hard real-time programmers typically can't use free store (dynamic memory) freely and will be restricted in their choice of libraries. We encourage the development of such more specific rules as addenda to these core guidelines. Build your ideal small foundation library and use that, rather than lowering your level of programming to glorified assembly code.
I've been programming C++ for 20 years and I'm still learning. Don't ever lose that motivation to learn.
In terms of strict C++ usage, yes, a plain pointer would be a reasonable way to implement that. However, I agree with the below suggestion to use ```std::optional&lt;std::reference_wrapper&lt;foo&gt;&gt;```, as that directly communicates what you intend. Stepping back a bit, it is confusing to have an optionally returned reference in the first place. If lazy allocation of the internal ```std::unique_ptr&lt;foo&gt;``` is desired, then that could be handled in ```getFoo()``` without needing to propagate that information to the caller.
&gt; it is confusing to have an optionally returned reference in the first place. Seems quite common to me. Think for instance a window with a button that is created only once another button has been pressed. An opengl surface that may or may not exist. etc..
I like the idea of using gsl::span as it communicates intent better than plain pointers. However, I wouldn't be overly upset with non owning raw pointers used in this case if (for some odd reason) the gsl was not available. I need to get up to speed on the gsl, as I know it exists but haven't used it yet...(shame on me)
If you're used to node, have a look at mana from the includeos project, as it's very heavily influenced by node and express https://github.com/hioa-cs/IncludeOS/blob/master/lib/mana/README.md
Your post has been automatically removed because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/62o0uc/help_to_create_a_program_in_c/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Oh I didn't realize that the std::swap(x, x) could still be non-modifying. That clarifies things!
Wow, this is utterly amazing!
Style guides are often not just about reducing bugs. Easy reading because the code is consistent improves productivity. Limiting line length to 80 columns, or allowing longer lines; either way is not likely going to cause many bugs. But having consistent layout makes it easier to read. 
Also as tc says, you can make the assigned-to value `const`, plus you get the goodness of lambda capture rather than having to manually pass a bunch of fields to some function somewhere else in the code. This pattern is called IIFE, and you use it like ?: except in cases where you need the extra power, like local vars (which also don't leak into the surrounding scope), or you have &gt;= 3 possible return values. You can also combine it with `static` to get a kind of call_once functionality. More info: http://articles.emptycrate.com/2014/12/16/complex_object_initialization_optimization_with_iife_in_c11.html http://www.bfilipek.com/2016/11/iife-for-complex-initialization.html 
Are you sure I did that one? Or do you mean [Jonathan Boccara](fluentcpp.com)?
&gt; Lately, I've been assigning the lambda and then calling it in the following line. It's an extra line of reading, but you will avoid creating an auto whose nature isn't clear for several lines of code. IMO one advantage of the pattern in the first place is that it minimizes the number of variables accessible in the outer function's scope (and as such minimizes mental overhead), but storing the lambda in a named variable as you're suggesting makes the pattern less effective towards that end. I do agree however with your other sentiment: &gt; your syntax requires a reader to notice the () at the end before mentally parsing what your auto at the beginning is. Luckily, [std::invoke](http://en.cppreference.com/w/cpp/utility/functional/invoke) helps here: ``` const auto y = std::invoke([&amp;] { /* same with y */ return res; }); ``` That requires more keystrokes, but makes the IIFE pattern more obvious to the reader. std::invoke is only available in c++17, but a custom version can easily be implemented in C++11 too, since it would only need to support nullary callables.
Unfortunately, I'm right. The name `argv` has no sense to anyone. Wrapping this code into some function (i.e. `getFilename(argc, argv)`) may help to catch the intention. Or may not. It depends from the choosen function name. Without such function I have no idea at all about what exactly the author wanted to do.
As already stated, c++ is *huge*. In a way it's also two separate languages. What is commonly called *Modern C++*, i.e. c++11 and beyond is very different from (and much, much nicer to program in than) "old-school" c++, i.e. c++98/03. It might be worth finding out what your prospective employer uses, as you can save yourself a whole heap of pain if you just focus on modern c++. 
nope. we're working on it for an update to 2017 though. Thanks, Steve, VC Dev Mgr
Oh wow. While you're here can you comment on the wonky top-secret extensions in your compiler?
There is the doxygen documentation which you can generate using the instructions here : https://github.com/facebook/proxygen/#documentation There is a high-level architecture overview here : https://github.com/facebook/proxygen/#architecture And finally, there is the sample code for the server side : https://github.com/facebook/proxygen/tree/master/proxygen/httpserver/samples and for the client side : https://github.com/facebook/proxygen/tree/master/proxygen/httpclient/samples
Yes, I see needing to deal with things that may or may not yet exist are definitely common. What I do not think is necessary when dealing with that problem is to use an optional reference. &gt; Think for instance a window with a button that is created only once another button has been pressed I think there are at least two code design alternatives which communicate more: * Have both buttons created, but only show the ones which are relevant (I've done this in Qt tons of times) * If an object is optional but may need to respond to events (e.g. mouse clicks), you can default construct a version of a widget which maps such operations to a no-op, then substitute the "real" implementation once it comes into existence. That can remove a ton of repetitive checking in an implementation by removing the need to know if some widget is valid or not. &gt; An opengl surface that may or may not exist. If you are trying to do operations with some sort of OpenGL object (ex: SDL2, Freeglut, GLFW, Qt, etc.) and the window is not yet present, it sounds like a larger app design problem, where code checking for other parts existing (i.e. null pointer checks) is a symptom of ill-defined object lifetime relationships. However, without a real project to look at, there isn't much else to say or debate about. Who knows, maybe the situation you're in can't change (i.e. you're using an API out of your control), where there isn't an alternative available to consider.
I actually experimented with it quite a bit a year or two ago and found it to be surprisingly stable. I think I remember it actually working inside of constexpr functions.
If you take he code as you wrote it, neither is optional anyway as dereferencing a null pointer or blindly getting a value from an optional wrapper will either result in a crash or thrown exception. If that is actually the case, returning a ```foo&amp;``` tells me that it will always be available; no need to do validity checks. The code that should be compared is as follows: auto *f = getSomeFoo(); if (f) { f-&gt;foo_method(); } vs. auto f = getSomeFoo(); if (f.has_value()) { f.get().foo_method(); } I'd argue both of those are visually the same complexity. You could also write your own ```optional&lt;&gt;``` type that specializes for ```std::reference_wrapper```, where ```operator-&gt;()``` would go ahead and call ```get()``` on the reference wrapper instead. That would let you write: auto f = getSomeFoo(); if (f.has_value()) { f-&gt;foo_method(); } ...if that really matters to you. All I am arguing in the post is that ```foo*``` tells me less about how it should be used than the alternatives mentioned. Also, FWIW, you can also write your own ```reference_wrapper``` and ```optional``` to specialize better for the in-memory representation's size if size matters that much for you. And if that isn't up your ally either, then yes a plain pointer will give you that size reduction. However, if you never prove that the size tradeoff actually matters, all you've done is trade code expressiveness for a useless optimization: a net loss IMHO.
Thank you! I will keep that in mind!
Thank you. I will keep going because I like it a lot :)
I will make sure to find out :) thanks! 
Oh I'm sure, a very versatile hack though. Can be used within array initializers and even in function declarations
As someone who learnt C++ by their lonesome, don't worry about anything you haven't done yet. Just because you're using, say, vectors doesn't mean you have to know about threads. Start with the basics and work your way up, you most likely won't ever know everything ;)
Yeah, I use ctrl k a lot, but sometimes I need to just see all the files in an organized fashion. For now I'll stick with 4.2
I experimented with it and have no intention of ever using it for any purpose.
Not sure I'm following you. What kind of extension do you mean?
You'll find as you do more you'll start to pick up pace, I didn't know what a pointer was when I started! Become the exponential :P
My $0.02 1. Consistency. I like any new code style to disappear, blending into the existing one. Otherwise feels like something out of place, a pointless distraction. 2. Pick your poison (but follow #1). Use `astyle` or other similar tool for default formatting styles. If you are starting a new project and have some initial code use `asyle` before your first commits on as much as possible of your project, just leave out 3rd party dependencies (don't even try to fix up git submodules or other kind of nested repositories). For "fixing" existing code under version control, don't fall into the trap of changing everything at once, you'll trade off "line author/change" tracking convenience, example, `git blame` would show up that one dev changed everything at the same time. For this is better to do incremental fixes, specially if there is opportunity for devs to refactor selected modules.
I've been very happy using [CppRestSDK](https://github.com/Microsoft/cpprestsdk). It has client and server libs and works on all the main platforms. It implements things like compression, proxies etc... which aren't available in many other libs. 
&gt; That’s not the same as saying it needs to preserve the object’s value, though I can't quite get behind this recommendation. Self-move is either: 1. A logic error 2. A well-defined operation If it's the former, `abort()` is as good an outcome as any. The sooner you crash, the better. If it's the latter, and we view move as simply an optimization over copy, then it should assert the same post-conditions as copy. Self-destructive self-move serves neither of these outcomes very well. And lets be real, if you think a single very predictable branch instruction is relevant to your code's performance problems, you probably ought to rethink your optimization strategies.
https://github.com/Corvusoft/restbed very good option with super nice documentation
Never considered combining an IIFE with `static` to get `call_once`-like functionality. Neat idea!
It can not be. In any program, arguments have some meaning. And the program itself needs to "know" how to interpret them.
But the argument could be any number of things. That code is just grabbing the argument, and then _later_ figure out what it is.
What you mean "just grabbing"? For what? If you don't want to do something specific with argument that make sense, do not touch it at all.
i was really excited then i looked at the date :(
Great trip report - as ever! Btw: any news about the Concepts TS? I saw no word mentioning it at all. Probably the ai decided it to never possibly reaching consensus and being obsolete before even merging and deprecating it in the first place.
wait.. this isn't april fools is it?
We do not talk about Concepts.
I propose the opposite. Type more, to make your intent clear. const auto y = ([&amp;] { /* same with y */ return res; })(); By wrapping the lambda in an extra pair of parentheses, it is clear, that `y` is not the lambda, but the value returned by the lambda. This is the way JavaScript folks have been doing [IIFEs](http://benalman.com/news/2010/11/immediately-invoked-function-expression/) for years. Maybe IILE (immediately invoked lambda expression) could become a pattern in C++? Edit: Reading through the comments I learned about `std::invoke`.
I am curious, can you explain what is wrong with this part?
I think maybe for exit() it means "ends in the normal way" (ie. It doesn't call destructors), rather than that it might not always end the program. 
Instead of your own Maybe monad, you should really use the proposed LEWG expected&lt;T, E&gt; monad. One high quality implementation in the Boost review queue can be found at https://ned14.github.io/boost.outcome/. In terms of the idea for your library itself, I had a similar idea back before I began Outcome, but I decided to discount it because of the hideous cost of throwing exceptions or constructing exception ptrs. That said, if you are a user who doesn't care about spending up to 30k CPU cycles for the convenience of wrapping exceptions into functions, then your library is a nice solution. I'd welcome you considering to send it to Boost, if Outcome is in there by then it would be a natural extension to Outcome.
&gt; I'd argue both of those are visually the same complexity I really disagree. Especially considering that you could write `auto f = ...` for the pointer case (which would remove the need for a refactoring if one day the thing actually becomes an `optional`). I personally write most of the time: if (auto f = getSomeFoo()) { f-&gt;foo_method(); } Replacing `-&gt;` by `-&gt;get()` or `.value().get()` (and not `.get()` like you wrote: you have to dereference the optional, too) is a strict loss, especially when my IDE autocompletes when I type `.` and converts `.` to `-&gt;` automatically. So I'd go from typing `f.f&lt;tab&gt;` to typing `f.v&lt;tab&gt;.g&lt;tab&gt;.f&lt;tab&gt;`. &gt; You could also write your own optional&lt;&gt; type Or complain to people who refused to let std::optional&lt;T&amp;&gt; exist, while it works just like intended in boost and serves exactly this purpose. Seriously, I'm not writing my own `optional` for this. &gt; All I am arguing in the post is that foo* tells me less about how it should be used than the alternatives mentioned. I thought everybody agreed `T*` meant "non-owning nullable reference" but it seems that it's not the case... 
You can not handle arguments without a certain interpretation. If you mean the partial handling or an abstract preparation for future handling, then you need separate function anyway, because it is not about locality at all.
 typedef long long int64_t; int* i; // oops, missing * auto c_style1 = (int64_t) i; auto c_style2 = int64_t(i); auto cpp_style = reinterpret_cast&lt;int64_t&gt;(i); // compile error int64_t tmp(i); auto universal = int64_t{i}; auto cpp_static = static_cast&lt;int64_t&gt;(i); // but universal is tricky too std::vector&lt;int&gt; i_just_wanted_a_tmp(10, 1); if (i_just_wanted_a_tmp != std::vector&lt;int&gt;{10, 1}) { // we constructed a vector with 2 elements } if (i_just_wanted_a_tmp == std::vector&lt;int&gt;(10, 1)) { // we constructed a vector with 10 elements }
&gt; that is exactly the point of C++ Core Guidelines Well, that's the stated point of the guidelines, but they spoiled it by having far too many rules. [Take a look at it](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md), if you don't believe me - it's over 300 pages long, and it's not even complete yet (the string `???` meaning "not complete" appears over 300 times). More, it includes all sorts of style guidelines for things like concepts that don't even exist yet in the standard. I enjoy reading these things, and I've gone over this more than once, but just looking at it again, I find all sorts of stuff I hadn't seen before. A lot of programmers just want to get things done. If you hand them a 300 page book full of rules and say, "You have to read all of this," it's going to be discouraging. Don't get me wrong - it's a very important document, and I've even made some tiny contributions to it myself (near-trivial stuff TBH). It has great value, but it's far too big as a basis for a style guideline, particularly when OP has indicated that they have a lot of disparate teams with disparate levels of C++ skill. I agree with OP's idea. Start with some existing standard, throw away most of it, and then as you run into specific problems (hopefully, in code review :-) ) then add back parts to it. Your other suggestion, the Google C++ standard is somewhat old, but at least it's fairly concise!
That's interesting, to avoid a breaking change it would need to have a different behavior depending on if it's assigned or not, which would not be consistent with the usual c++ rule. Thanks for the input.
No. Both notations are explizit type conversions. And both can result in a constructor call.
&gt; if you hand them a 300 page book full of rules and say, "You have to read all of this," it's going to be discouraging. well, another point of the Core Guidelines is that they aren't a "book full of rules". To quote: &gt; These rules are not meant to be read serially, like a book. You can browse through them using the links. However, their main intended use is to be targets for tools
Good points on the potential collisions. I have added an item to our team's backlog to reduce them or eliminate them. I will back that effort with a rule in our standard. Thankfully the macros that are in place all seem to be in CPP files so it should make switching over easier. 
Good to see most of them have practical usefulness. Except malloc(), I have no clue how I'd implement that.
I think I just returned a char array. Didn't get the job, though.
I like to ask: &amp;nbsp; - What book do you read at the moment? - How do you keep up with modern C++? &amp;nbsp; I always want to ask: &amp;nbsp; - What are the advantages of making the static destructor virtual? &amp;nbsp; ... but my interviewing pair never allows it...
Yes, I agree (to some extent). It is far from perfect. Like in any book, there will be errors, unclear language and other things you don't agree with. One of the biggest advantages of this book is the fact that if you spot an error, you can send an email to the author, wait a couple of days and then refresh the webpage and it should be fixed. So feel free to do so! The book (in many iterations) has been used for the course mentioned in the introduction for the last 25 years. Outside of this group of people (~1000 persons I guess, far fewer people completed the course), it not not well known at all. So the people who were able to comment mostly don't have the skill level necessary to make these kind of indepth remarks. So I think spreading some awareness of its existence is of benefit to all. 
&gt;- What are the advantages of making the static destructor virtual? I'm curious as to the answer to that question? I'd never even heard of a static destructor in C++ before. 
Both questions are a good ice breaker and a way to start a little more informal discussion. Interviewees get more relaxed after a little chat about books, blogs, conferences. Too often they get nervous and visibly block. 
Yeah, software is one of the few lines of work where you are expected to do it in your free time. Art is the only one I can think of. Craft type jobs. Although many fields do have certifications, such as finance. So I guess that would involve studying in your free time.
&gt; Do you have any experience modifying the Linux kernel? At least this one i know the answer to. 
"Mostly recently" night be fairer than "at the moment". But when it comes to learning it's hard to beat the information density of a book, in addition, that most are reviewed by numerous experts before the final draft and it's hard to impossible to find anything better.
Not everybody reads books, some people read internet blogs etc.
I saw this mentioned in another thread, but some people prefer to hire people that match their circlejerk. People who are obsessed with the same things, no matter how trivial. In this case, DVMirchev has a thing for books, so he wants to circlejerk about that with someone else. The thread I saw was about obscure algorithm questions that don't really test programming ability. Some autistic team leader might prefer people who have solved a particular problem on Project Euler. Yeah, they're missing out on talent, but the team leader has an itch they want to scratch.
 void *malloc(size_t size) { return nullptr; }
For anyone who cares, this actually has a name — [IIFE](https://en.wikipedia.org/wiki/Immediately-invoked_function_expression).
This exists as an [extension](https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html#Statement-Exprs) in gcc and clang.
So is the middle one somewhat true? 
I hate April 1st
You seem convinced that he automatically kicks out everyone who doesn't read books
Personally I consider self-assignments (both copy and move), and self-swaps to be performance bugs. But they *do* happen. And it is a common misperception that to make sure when they do happen that self-move-assignment needs to be a no-op to get correct logic in generic algorithms. Every single generic algorithm in the std::lib, starting with std::swap, is resilient when given value_types with a modifying-self-move-assignment. It is counterintuitive, but it is true. Code up a simple `class A` that sets a special "self-move-assigned" state, and then run it through a self-swap: https://wandbox.org/permlink/QXR5mRF4UdfOryIK
I have seen the exact same implementation of returning NULL for malloc calls in very old bare-metal embedded C libraries for some architectures. 
I think it's a good question because it's quite under-specified and the questions from the candidate are useful to gauge their level of expertise (at least, that's the value I see in such question). For example, I would ask: * Can I use system calls to perform the actual allocation? Which platform? If not: * Does it have to handle arrays? Can I assume that I also implement free? * Should it be thread-safe? * Does it have a particular requirement regarding the allocation strategy, asymptotic complexity etc. Of course, if the candidate is not allowed to ask questions then it's kind of a dick question and doesn't provide any value.
There is no such thing as a static destructor in C++, so I think the entire point is to see how the candidate reacts. 
[[res.on.arguments-1.3]](http://eel.is/c++draft/res.on.arguments): &gt; If a program casts an lvalue to an xvalue while passing that lvalue to a library function (e.g. by calling the function with the argument std​::​move(x)), the program is effectively asking that function to treat that lvalue as a temporary. The implementation is free to optimize away aliasing checks which might be needed if the argument was an lvalue. [LWG Issue 1024](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1204): &gt; If the client supplies std::move(x) to push_back, the onus is on the client to ensure that the value of x is no longer important to the logic of his program after this statement. I.e. the client is making a statement that push_back may treat x as a temporary. &gt; *The above statement is the very foundation upon which move semantics is based.* I am having trouble understanding how either the wording of the standard or the reasoning behind its inclusion suggest that self-move-assignment within standard library functions should be considered undefined behavior. The term does not appear in either the standard nor the issue discussion. How does permitting the exclusion of a self aliasing check imply "anything could happen"? I have heard the claim that self-move operations are undefined from other sources as well, but I do not understand how they came to such a conclusion when they cite [res.on.arguments-1.3].
I'm guessing the answer would be assembly, allocate memory and return its address? EDIT: Nm, no need to go so low. Here's a fun read. https://danluu.com/malloc-tutorial/
Allocating a big static array at the beginning and then making your own malloc manage chunks off it is not specific to any OS.
As someone with no technical degree and never interviewed for a programming job (help desk -&gt; sysadmin -&gt; programmer in the same group) I found a lot of these questions irksome when I got back I to the job hunt. Scarier was that the only design pattern or architecture question i was ever asked about at all, ever, was a Singleton. Certainly with the STL, boost, and other libraries, knowing time complexities would cover a LOT of ground. Working in a medium sized firm it seems getting everyone on the same page design-wise is far more valuable.
Exactly the same functionally. In C `void *ptr` was more common, but in C++ you see more `void* ptr`, to associate the pointer with the type instead of the variable.
Mostly because, despite appearances, int* a, b; declares a pointer to int and a plain int. int *a, b; Makes that more obvious I think.
I think emoji and unicode fits the task much more elegant. 
Has any candidate ever declared the interview over at that point? :) Because if the question is not immediately followed up by going out to lunch, I'd seriously consider it.
Regardless of where one puts the star, I'd argue using declarations like those is bad pratice.
I agree, it might make sense in such cases. Though I'll have to agree with /u/l97 and consider it a bad practice that I would avoid at all costs.
That is hilariously disgusting!
I've been asked this in an interview before and I was stumped. But apparently the interviewer isn't looking for an implementation (immediately), but rather to have a discussion about designing malloc and your general understanding of allocating memory. See here: http://stackoverflow.com/questions/14724905/writing-new-malloc-and-free-functions
And later you can add not-very-efficient-but-working and simple `free` implementation, that first stores all "free" calls on some stack, and later handles them when buffer is out of memory.
 void* malloc(size_t size) { return ::operator new(size, std::nothrow); }
Apparently you can also do: void foo(a, b) int a; float b; { ... } 😆
I would say malloc it the perfect task: because there are so many levels. You may start with the trivial always-failing implementation (but still perfectly conforming) posted above in the comments, and then go on adding layers and layers of features and complexity. And how far you go can be a good indication of the topics the person is familiar with. It can proceed like that: - What is malloc's interface? - Write a simplest implementation ever that conforms to that specification. - Write the minimal implementation that does not call any OS APIs but actually returns something useful. - Write a simple implementation that just calls your OS's interface (optional, requires knowledge of the OS interface) - How would you decrease number of system calls? - How would you make it thread-safe? - How about deallocation and memory reuse? - How to make it better in respect to memory locality? 
You basically call sbrk and then create a struct holding the pointer along with some data about its size so that you can free it later. I had to write an aligned memory allocator before and it was a tough project as a grad student. Doubt many people have experience with it, so I'm not sure why it would be asked in an interview.
You could always just reply with a goto reference. I haven't read anything in a while, but I refer to my digital copies of Meyers Modern C++ pretty frequently.
One other potential point of discussion is implementation on UNIX/Linux systems vs. Windows systems. For UNIX/Linux systems, the very first thing the question tests is if the candidate knows brk()/sbrk(), and mmap() on the system call level. On the library level, there are a couple of schemes the candidate can go for: which one the candidate decides to use will depend on the nature of work the candidate had done before. For Windows system, I don't know how they do it. Any Windows experts who would like to chime in? 
&gt; 10+ years I do know that Medical Doctors in USA need to sit for some sort of certification exams roughly every 10 years. I am guessing Lawyers also have a similar scheme. Software seems to be only high-paying knowledge-based discipline which does not require similar certification process, and also seems to be only one where there are highest occurrence of self-proclaimed experienced practitioners who cannot do the simplest of things even competent beginners should have no trouble. Because of the state of affairs in our field, we cannot just come out and condemn the interview process even though it is insulting and annoying.
char fun() and void fun() are jointly inadmissible, in that they only differ in their return types. Either is compatible which each of the other three. char fun(void *v) and char fun(int i, void *v) are always compatible, since they have different numbers of arguments. char fun(int i, int j = 2) may be ambiguous if called with some type that implicitly converts to both void * and int, eg. fun(foo) and fun(i, foo) may be ambiguous calls.
You cannot change return type, and you may not end up with two functions that match a given call equally well
Torvalds isn't a big fan of OOP.
personally I give it its own little island. &gt;void * malloc(size_t size){
`malloc` is usually implemented on top of `HeapAlloc` on Windows, which itself calls `VirtualAlloc` for bigger allocations.
Looks like these: https://www.reddit.com/r/cpp/comments/62ol16/does_msvc_support_constexpr_if_yet/dfo8qte/
There is no joke. Some companies optimize the kernel for speed.
`mmap` all the things!
[res.on.arguments] does not make an exception for rvalue references that alias other references. It says only that it's safe to assume that any rvalue reference to a parameter is the one and only reference to that thing. The possibility that it may in fact alias another reference (as in self-move) is dismissed in this passage. Basically the standard is saying that it can't happen in a well-formed program, so if it does the program must be ill-formed.
zlib uses it as well.
I took the second year when this course was given. This was in the '95/'96 academic year, before there was any official C++ Standard, and compilers were still catching up to the template machinery. I think we used a Silicon Graphics workstation with the accompanying SGI version of the STL. These annotations were background material for a larger programming course. In those days, there was no pre-publication draft Standard and the ISO version still cost more than any student could afford. So regardless of the various (small IMO) technical stuff that these annotations get wrong, it was an enormous help to quickly get stuff done. Nowadays, [cppreference](http://en.cppreference.com/w/) is my preferred extended cheatsheet. In any case, it's great to see these notes still alive and being updated to the latest Standard version!
Because profiling! He also said it is a way to relax the conversation. Not every question has to be 100% about what the job will be.
People tend to not answer trick questions very well under pressure, hence why most interviewers aren't keen on asking them.
But you said c++
The standard defines behavior only for the case where the argument doesn't alias. And so if that doesn't hold then the behavior is undefined by omission (because it is "behavior for which this International Standard imposes no requirements").
I do not believe that applies to this clause. &gt; If a function argument binds to an rvalue reference parameter, the implementation may assume that this parameter is a unique reference to this argument. This is giving permission to standard library implementations to assume the argument is a prvalue. &gt; [ *Note:* ... The implementation is free to optimize away aliasing checks which might be needed if the argument was an lvalue. — *end note* ] This is giving an example of what an implementation can exclude given the above permission. The standard is not "defining" behavior here, it is granting permission to implementations writing standard library functions to assume the argument to be a prvalue. Compare the wording to the other two clauses in the same section, where [[res.on.arguments-1.1]](http://eel.is/c++draft/res.on.arguments#1.1) explicitly specifies a situation as undefined behavior, and [[res.on.arguments-1.2]](http://eel.is/c++draft/res.on.arguments#1.2) which enforces a condition must be true ("the pointer... shall have..."). [[res.on.arguments-1.3]](http://eel.is/c++draft/res.on.arguments#1.3) is a *permissive* clause, granting standard library authors permission to make an assumption about the argument. It is not enforcing a condition (e.g. "the parameter *must be* a unique reference"), nor labeling the case where the assumption is false as undefined behavior.
[ahem](http://rextester.com/KYC91055) 
Arduino is actually not a bad platform to use, and the recent avr-gcc compilers support C++11 (and maybe 14?)
fuck i hate april fool's day.
So I came across malloc in my professional career. Not because I wanted to, but because someone thought to write their own instead of using the built in one (embedded platform). Long story short, malloc is hard (especially when it comes to recycling memory). Use the compiler's version. It's better than anything you can come up with in a reasonable amount of time. 
valid python: `x = "young" if person.age &lt; 50 else "old"` I've always loved that.
If you understand what scope, arguments and function body are, you can understand a lambda as a function-object declared with three parts: `[scope to capture](arguments of function){body of function}` If you would normally write a function like so: int x = 4; int mulX(int y) { return x*y; } You can instead use: int x = 4; auto mulX = [x](int y){return x*y;}; And mulX will work the same way on both versions. On the second version, however, you'll notice you can declare it *inside* another function. Passing [&amp;] means "capture everything in this scope and pass it to the lambda by reference" while passing [=] means "capture everything in this scope and pass it by value"(like I explicitly passed the variable x on my example). In general you don't want to capture anything when working with lambdas so you just use [] as a "lambda identifier", and if you don't need the function receiving parameters you can also ommit the parenthesis. In other words, lambdas are simply functions without names. They are useful when you want to pass a function somewhere as a parameter but you don't feel that you need to declare it on a bigger scope(like when using `std::sort`), or in OPs example, they can encapsule a scope and work as a "protector" for a variable delcaration. Note that OP has a () at the end of their lambdas - because he is actually declaring and calling them inline, just like you would call a function. I'm not sure I was 100% clear so feel free to ask away if you'd like to understand something I missed or glossed over.
Punching my monitor and then buying a new one. 
But I'm on a surface pro :(
Hope you got the dosh, pal
I third this, I switched from QtCreator to KDevelop in windows too. After using clang for their code completion, KDevelop is wonderful tools to use. I admit, I didn't expect that much from it when I was install it for first time. This makes me angry : https://bugreports.qt.io/browse/QTCREATORBUG-17358
depends on the implementation / version, right?
Errors output will be helpful. You may try ignoring default lib or reorder lib. But the best solution would be recompiling everything with the same tool chain.
The github link has a typo in it, twee**b**ny instead of tweeny
nice
So here's the http://agilemanifesto.org/ What's incompatible with making mission-critical systems? Larger point: are you looking to dismiss a candidate for having an opinion? 
One of the major things neovim accomplished was making the sourcecode actually readable.
What does the `void*(*)(size_t)` part mean? You put `(*)` to make it dereference `size_t` and cast it to void pointer? Even https://cdecl.org/ can't find out what it does. Can you explain, please?
I consider Arduino quite a bad platform, they advocate pretty bad programming practices (`loop()` and `delay()` ??), and as far as I know the source files aren't really valid C/C++.
Looks quite nice. Can you get a tween value without mutating the state, though? Currently stepping changes the internals of the tween, while I'd prefer a functional way of querying, e.g. `tween.at(position)`.
very cool! for tweening between two points there is a trick that uses [two FMA operations](https://github.com/OSSIA/libossia/blob/3232ab6d8c96ea80249eeeb227b69f24b31415fa/OSSIA/ossia/editor/curve/curve_segment/easing.hpp#L38), maybe it could give you even better perf ? (explanation of the FMA trick: https://devblogs.nvidia.com/parallelforall/lerp-faster-cuda/ ; https://fgiesen.wordpress.com/2012/08/15/linear-interpolation-past-present-and-future/ ) 
good enough! :)
Does it work well with Chrono types? Can you interpolate through another value than time?
That's not accurate. He's just not a big fan of C++. A pretty standard design idiom in the kernel is to use structs with function pointers (file descriptors, for example), which is definitely OOP.
Yes, there is a difference. In one case, a group of hateful partisans will flame you for having gone with that choice. In the other case, they'll be happy as clams. Of course, there is another, previously silent, group of hateful partisans that will then flame you. The compiler will treat them as the same though. ;-)
Review for the CMake parts: It looks quite good! But you are using target_compile_features(), specify a minimum version of 3.0 and it requires at least CMake 3.1, so you should up the requirements.
 std::vector&lt;int&gt; a; a.push_back(10);
So you're arguing against the use of argv with a lambda, and not the immediate use of lambdas itself. Yeah, so [it's on the guidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-lambda-init).
Well, it comes from C, so that's why. The c std lib is freaking huge. 
 void library_func(std::string&amp;&amp; give_it_to_me) { std::cout &lt;&lt; give_it_to_me &lt;&lt; std::endl; } std::string my_giveaway("hello"); library_func(std::move(my_giveaway)); // Hands off my_giveaway It's not moving anything, you're just binding the xvalue `move(my_giveaway)` to the `give_it_to_me` rvalue-reference. The same way you're not copying anything when taking values by references. To effectively move it, you have to do something like `std::unique_ptr`'s deleted copy constructor, and pass everything by value, then use `std::move` in order to call the move constructor of the new object. http://coliru.stacked-crooked.com/a/e42092b22bbe93ed
I really expected that for-loop to be: for (auto val : tween) printf("%d\n", val); So that would be my suggestion. (ie implement begin(tween) and end(tween))
Just a quick glance at their website and it says you can use .via() method with something like 30 easing functions or even make your own one. https://mobius3.github.io/tweeny/doc/classtweeny_1_1easing.html
No amount of.. anything is going to make it better. I have been doing c++ for almost 20 years, and it feels like I spend more time configuring libraries to work with each other than actually writing code. Even the basics like, OpenSSL, zlib, jpeg... lol. And then figuring out if you should do static lib, runtime dll, etc...then 64bit. There are 2*2*2 = 8 combinations just to go wrong. Then there are some where version x doesn't w/ with visual studio 2015. So you have to find a combination that works. Linux isn't much better.. very very old versions of libraries are shipped so you usually have to build your own dependencies... That's.. not even writing a single line of code. That's why I am doing most of my development in Javascript/node now. Need something, one cli command and one line includes the library. One cli command to reinstall all depencies. Using nodejs, I wrote a simple twitter client that uses google vision api in two days. If it was in C++.. I'll still be trying to get openssl, boost, writing my own oauth2, etc, etc. a month later. I do have a C/C++ project that that uses zlib, iconvlib, boost, dcmtk, openjpeg, openssl, mysql, aws, poco, socket io and probably something else. It uses VS 2013, static runtime, and static link everything. That's the only combination that I have found works. I have a batch file at https://github.com/DraconPern/fmdscp/blob/master/build.bat take a look at some of my other c++ projects for some more examples. Oh, don't bother posting logs. Those do not help w/ linking errors on VS. I have seen a project that was trying to link a /MD library when everything was suppose to be /MT, but it didn't surface until the last link step. The logs give no indication of which sub sub library was compiled with the wrong switch. The only way to find where the offending switch is, is doing a text search into the project. Also, recheckout the whole project into a new directory when you change your solution or switches. Because those cached settings will get you. Good luck.
Windows is just a huge pain in the ass for this stuff. If you use Linux and stick to dependencies in your distro package manager the problem mostly goes away.
Except for splitting strings xD
Yeah, I hardly use STL because we have our inhouse library, but I just wish there was a nice table of the features provided by the STL and things like their runtime impact and whether they do dynamic allocation, etc
Use chlorophyll but uproot to vanquish foes of the forest? Oh wait, those are Ents. What do you mean about ints? 
I don't mean to sound too harsh here, but it does tick me off a little when articles intended to educate the reader make so many stylistic errors in example code. People looking for information can be mislead into thinking the examples are best practice. It is always worth passing even small snippets past an experienced C++ developer before publishing them for the world to see. I would be happy to help with this (apart from how, justifiably, harsh I have just sounded!) 
If you are setting a property of an object, *even if* that setter has side effects, the only natural way of setting such a property is writing `foo.X = bar` and similarly the only natural way of getting that property is `foo.X`. That's it. Calls to `foo.X(bar)` or `foo.X()` are unnatural since a function call typically implies behavior of an object. So `foo.DoSomething()` is fine, but `foo.Age()` feels wrong and weird.
Of course, I'm not against lambdas in general. Only against using them everywhere. There are other means in the language. C++ is not a language for building programs from lambdas.
Are there any situations where one would use a `std::move()` and not consider the object's content invalid after the call? Technically it's just a cast, but the expectation is that the callee is doing something destructive with it.
I see this said all the time, but if you're working on performance sensitive code, why are you printing text? 
Excellent point that I've wasn't aware of, but in most cases you wouldn't be printing it the result of every for loop in production code. I'm sure a use case exists somewhere though...
Well, I chose not to tie with chrono or any specific time structure (earlier versions of it used sdt::chrono::duration) because then you can interpret your duration units however you like (e.g, seconds, miliseconds, etc). It's more like 'how many steps to go from A to B' than 'how long to reach B from A'. It leaves the problem of tracking time to the user.
That is a nice suggestion indeed, thank you! I will look into it!
I'm ok with using any type, I'm just asking if if I use Chrono (boost or std) will it work. From your answer I assume yes. For tweening not based on time, if it's not possible then it's not modular enough. User, ideally, should be able to update the state themself, set a specific state and be able to provide the update source. Otherwise every tweening based on state that is not time will not be possible.
Yes. An example modeled off of some concurrent bounded-length queue code: while (!queue.try_push(move(value))) do_work_or_sleep_or_something(); Ultimately, it's impossible to know whether a value has actually been moved or not, unless you look at the actual implementation of all the code in question. It's entirely possible to write a function like `void foo(type&amp;&amp; value) {}` for instance, or to write code like `type bar() { type value; move(value); return value; }` or any of a number of other weird or useful constructs that use `move` or an rvalue reference but don't actually move anything. Basically, `move` means "convert this lvalue reference into an rvalue reference" but otherwise doesn't actually do anything. Rvalue references likewise don't actually _do_ anything other than allowing some overloading (e.g., copy- vs move-constructors) and offering some binding improvements (e.g., a prvalue will bind to an rvalue reference but not to an lvalue reference). There's literally _nothing_ about `move`/`forward` or rvalue references that actually do anything; they just _enable_ behavior, which the programmer is responsible for writing and using effectively.
Inline assembly doesn't typically work when targeting x86_64 with any of today's major compilers, and many (most?) games are moving to either support 64-bit builds or even exclusively use only 64-bit builds. Also, ARM and mobile and webassembly and stuff means relying on x86-specific features can potentially be problematic. Anecdotally, I don't think I've made a 32-bit build of a game (hobby or professional work) since 2015. :)
You might want to look into the range library. It is the basis for a proposal to include ranges into the standard libray. (and they have figured out a lot of stuff around the range library.) [range-v3](https://github.com/ericniebler/range-v3) 
Meh..
It's a pretty big deal for lower level C++ developers who have to manage dependencies or scale up build systems.
I understand what you're saying, but the argument here is that custom behavior of a property does not warrant a separate object. There's also the added issue of how you're going to, say, call a member function of the owner class if the property itself is some other class. What makes the connection between the two (say, in the case of property change notification)? There are also fairly unpleasant inheritance implications. If properties are defined the way I suggest, a derived class can `override` the base class' setter, for example. If a property is a field of a custom type, the possibility of overriding the behavior is lost.
That's almost never the purpose. If you're outputting enough text for this to matter, usually a human isn't intended to read it all. You're usually serializing tons of data.
Read VS's documentation. I'm removing this question as it is off-topic.
Isn't this on the distribution? I've never seen this happen either
Oh I see. Teeny does not keep time nor updates itself, so you must either `step(duration)`, in which `duration` is an unsigned interger, or `step(percentage)`, in which `percentage` is how much you want it to go forward (i.e, `0.1f` to move 10%). You can also `seek(duration/percentage)` to a specific tween point. Usually I `step()` it by the delta-time of a frame, in miliseconds.
Spoken like someone that never tracked down C++ code with a profiler to discover that std::endl was the issue. Fuck your "almost never the purpose". I saw code generating csv files for other software where std::endl was the bottleneck. More than once. And logs for high performance servers that took more time me to fflush between each log line than to execute the service. And, you know what, there are programs that DO generate text. Go ahead and write your version of 'sed' or 'tr' that use std::endl and come back reporting your results.
Well no, I don't have it backwards. The situation (regrettably) is more nuanced than either of our posts suggest. See http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#f15-prefer-simple-and-conventional-ways-of-passing-information - you could say that I was using the programmers' never, meaning never except when it's right. 
[removed]
I have no tools for that. GN can handle any languages, and it is a really flexible build system. It has a syntax very close to Bazel, and although I can't say for sure, I believe there are plans to eventually have GN in other projects. Also, I don't think that Bazel can match GN when it comes to performance.
Does the standard not just state a minimum?
Scott Meyers Effective C++.
Right, but isn't this exactly the "in &amp; move from" case under "advanced parameter passing", or have I misunderstood?
Could you expand a little on this please? In all the lessons I have found, they seem to be made to be very important, and a crucial part of C++ and dynamic memory. Or am I completely mistaken? 
No problem! I was actually referring to this code: void library_func_p(std::unique_ptr&lt;std::string&gt;&amp;&amp; give_it_to_me) { std::cout &lt;&lt; *give_it_to_me &lt;&lt; std::endl; } std::string isn't a move only type. It can be copied, and can be moved. std::unique_ptr cannot be copied. So by declaring the function as: void library_func_p(std::unique_ptr&lt;std::string&gt; give_it_to_me) { std::cout &lt;&lt; *give_it_to_me &lt;&lt; std::endl; } You are expressing the fact that ownership is transferred more clearly. Any calling code looks the same. Edit: Apologies for the formatting! 
A more detailed explanation of the slides is on Stack Overflow: http://softwareengineering.stackexchange.com/a/163279/2366
&gt;You think having to generate gigabytes of text to be consumed by a closed source program that doesn't support any more efficient format is a common occurrence? Yes. It is. I work for a company that produces Auditing Software. This is a pretty regular occurrence. Sometimes it's solution design fuckups, sometimes it's a legitimate use-case, but in either situation, as a programmer, you don't always have the luxury of just saying "why don't we do this in a better/faster/more efficient/more understandable way?"
Would this be a "proper" usage of move to you? #include &lt;cstdio&gt; #include &lt;utility&gt; #include &lt;memory&gt; struct S { int state = 0; S() = default; S(const S&amp;) { std::puts("S::S(const S&amp;)"); } S(S&amp;&amp;) { std::puts("S::S(S&amp;&amp;)"); } }; void bind_to_S(std::unique_ptr&lt;S&gt; s) { std::puts("bind_to_S"); ++s-&gt;state; } int main() { auto s = std::make_unique&lt;S&gt;(); bind_to_S(std::move(s)); std::printf("state: %d\n", s-&gt;state); // SEGFAULT return 0; } By the way thanks for all the info. This thread has been super helpful!
I meant mostly the hardware, you don't need to use the Arduino software with it. But in any case, the software works just fine with standard C/C++ code. A lot of the modern libraries are using templates for example.
raii and it's uses wrt exceptions.
I'll take a look, thank you. 
`std::unique_ptr` already has its copy constructor/assignment deleted, so you do know that you're not calling `S`'s move constructor, but rather `unique_ptr`'s. All in all, what you have to look for is the *value* semantics, so always receive things as *passing by value* (i.e. no references) if you want to perform ownership exchange.
Mostly with tears and hair loss.
From a comment [above](https://www.reddit.com/r/cpp/comments/62ol16/does_msvc_support_constexpr_if_yet/dfo856w/?context=4): &gt; The compiler devs who "maintain" it tell me that it's a disgusting, horrifying hack. Run away. Plus, it's non-portable, so it won't work with another compiler, and non-standard, so the behavior isn't really defined (at least I'd imagine that is the case for certain edge cases).
&gt; `std::unique_ptr` already has its copy constructor/assignment deleted, so you do know that you're not calling `S`'s move constructor, but rather `unique_ptr`'s. I'm sorry I might be obtuse, but I'm not fully understanding. Are you saying that I shouldn't do what I did in the code I posted? I tried removing the `std::move` call, but that fails to compile (I presume because it's trying to use the copy constructor). Maybe I'm doing something dumb?
Hehe I was hoping for a solution, but I believe your answer is completely accurate.
I see a couple of problems here. 1. The slowdown from `std::endl` is so large that it often matters even for code that isn't particularly performance sensitive. 2. The article is aimed at telling C programmers that C++ is a viable alternative, but then includes code that's fairly likely to (erroneously) lead toward the opposite conclusion. 
Thanks for pointing that out. I am still learning C++ and that's a really helpful tip which I didn't know about. I need to start a list of Do's and Don'ts and general performance tips.
I'm guessing that to evaluate this test, it's probably the equivalent of compiling the bit of code in question and seeing if there are any errors. That would be fragile (what happens when the compiler gets upgraded? Does your way of interfacing with it subtlety break?) and expensive (speculative compilation isn't cheap, which is why most compilers and users try to avoid it).
&gt; I was just wondering what you guys's gotos are? i try not to use gotos myself, as they are considered bad practice. but I second cppreference is pretty nice 
You should use std::endl whenever the output ought to be seen immediately. You should use std::flush the same way when you don't want the newline. Though of course, that only matters for std::cout.
Nice joke. :-)
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/633gi0/what_is_the_best_guide_for_beginners/dfr3fle/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/633hmr/i_am_a_beginner_is_this_a_good_tutorial_website/dfr3g9b/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Your post has been automatically removed because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/633tnc/could_someone_help_me_understand_the_coding_style/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Oh wow. I thought pointers are really important (at least in C).
... and cppreference.com. Indispensable. Tho when I started, there wasn't even a standard so maybe we should start with that...
Great thanks a lot!
We have a [pinned thread](https://www.reddit.com/r/cpp/comments/5lflfj/whos_hiring_c_devs_q1_2017/) for these.
Hi, author of the article here. Based on feedback in comments here, I've updated all "std::endl" instances to use "\n" instead. Text output isn't particularly the goal of the examples, but I agree that using good style is important.
cplusplus must spend a lot on getting top of the google rankings.
1. Since you are coming from Javascript, the thing that probably trips you is manual memory management (no automatic garbage collection). You should start worrying about lifetime of objects. Modern C++ has attempted to solve a lot of issues but you should always have lifetime of objects at the back of your mind. Get a sense of whether you can reason about when a particular object will be deleted. A lot of C++ concepts flow from this train of thought - destructors, smart pointers, RAII etc. 2. Understand "virtual" keyword. Why does it make "inheritance" work? (Fun diversion if you know about pointers: how are the correct methods dispatched?) 
They are, but you have to understand that C++ is not C. With new ways of managing memory (unique_ptr, shared_ptr, etc) there are very few situations when you'll actually need raw pointers. In comments above, presentation was linked, that shows ways of removing raw pointers when they're not needed. 
I've used cppreference and msdn and lot, but out of curiosity, who actually makes the content for cppreference? is it like a wiki, or is it curated? 
Well glad we got your anecdote to balance mine. Only a few thousand more samples and we can know.
Please understand them, though. When you remove the hood, a lot of things you'll see are pointers and you should be fluent in them, even if you don't use. For example, the recommended way to refer to a resource is through a smart pointer. what problems are they solving? if smart pointers are smart, what's a dumb ( or "raw") pointer? For this, you need to know about pointers.
Why do you think there is no better programming language? I know its a hard language to learn, I've actually read people don't like it/criticize it because it's too complicated. I am learning how to use it.
Thanks for letting me know, but this is a floss community project not a business hiring devs... In this case people volunteer.
Thanks, spreading the word is fantastic. ☺
It also contains a huge amount of wrong "information" 
The using directive is one that frustrates me to no end. Every single beginner book out there says to use it. 
Hi, original author here. I think I've fixed this issue in the examples, but I'd be happy to accept further correction if I haven't.
Oh, right, my bad. Ignore that. :P
I've used http://www.cplusplus.com/reference/ a lot.
Huh? I'm not going to waste time making a laundry list if that's what you mean.
can you please explain how does this work? i typed this in my terminal (ubuntu 14.04 g++4.8.4) and got "No manual entry for std::vector" Thank you
Try installing `libstdc++-4.8-doc`.
The prioritization algorithm is a pretty complicated mix of how popular we think the new feature will be and how hard it will be to refactor the compiler to support adding it... But yes, "the libraries guys really want it" also factors in :-)
&gt; exit(3) This isn't calling exit with a value of 3, it's indicating that the documentation for exit is found in [section 3 of the manual](https://en.wikipedia.org/wiki/Man_page#Manual_sections).
I'm not sure it actually matters after compiler optimizations take effect, but I've made that change, too. :-)
Original author here. This is one change I won't be making, for several reasons: * It hurts the clarity of the examples. I would even argue it's not good style in general. * Unless a specific width is necessary, it can be harm performance when you explicitly choose the width of values like that. Better to let the compiler pick based on the architecture. Happy to review other critiques, though!
I have never in my life as a dev had to implement anything along the lines of malloc. And you want this to be a general interview question? You would arbitrarily filter out a lot of good devs unless you want to hold their hand during the process.
It still wouldn't be moved because there's no overload of `operator&lt;&lt;` that takes a `string&amp;&amp;` and moves it (and there's no need for there to be one, it doesn't need to store the value).
Thank you so much. It works now.
http://eel.is/c++draft for the language, https://en.cppreference.com for the standard library.
Illustrating /u/also_stl 's point… Here are a few variations of `typedef` : typedef int MyTypedef; typedef void(*MyTypedef)(); typedef void(MyClass::*MyTypedef)(); typedef int MyClass::*MyTypedef; And now here are the equivalent versions with `using` : using MyTypedef = int; using MyTypedef = void(*)(); using MyTypedef = void(MyClass::*)(); using MyTypedef = int MyClass::*;
But when a concise and clear definition is needed, cplusplus.com often wins.
https://godbolt.org/g/51axj6 Yes, MSVC is *not required* to compute that at compile-time. And yet, it does. 
cplusplus
I disagree. I would like a way of removing the site from my search results, i find that cplusplus is much less useful.
True is 1 and false is 0. That's two numbers total, which is more than one as I wrote.
Because some have a gazillion overloads, especially constructors, so it doesn't fit there.
I have an idea! Give me a while to work on something ("real life" is interfering a bit), and I will be in touch. The idea you're proposing will fit in with this library, though it requires me to implement something from the TODO list that I've been meaning to do. I also have some reading to do. Thank you for the input!
I see. So the bool could internally store true as 0 and false as 1? That's still two numbers, by my count.
One more thing: is there a possibility to improve this and remove the `reinterpret_cast` with `std::function`, so we wouldn't loose type safety with the dangerous `reinterpret_cast` operation? UPDATE: Maybe something like this: auto malloc(size_t size) { static auto malloc_ = std::bind(dlsym, RTLD_NEXT, "malloc"); return malloc_(size); } I haven't tested that. Sorry to bother you, once again.
The complexity of this comment makes me believe that I don't want to use C++, as I find it almost too large to know and understand.
Your code must be fun to read!
If you use Google, they've released a Chrome extension that allows you to disable search results from specific sites. I'm sure there are a million ways to achieve this with every search engine, so just look it up.
Because updates to the language!
What about functions that don't have overloads?
I don't have much time to become a developer, but since I use Kdenlive quite often, I'll make sure to compile the latest versions and see if I can pin down some of the bugs that I keep stumbling upon.
Any good reference site for boost? I find the docs at boost.org very unreadable.
I use `goto` a lot. I have no problem with it... I mean... look... STL algorithm is implemented using `for` and `while`. `for` is defined in terms of `while`, `while` is defined in terms of `goto`. I use `goto` a lot... for some definition of "use". Really, check this out, on cppreference :) http://en.cppreference.com/w/cpp/language/for http://en.cppreference.com/w/cpp/language/while
Consistency.
By this logic, you might as well put everything in one page. After all, you don't just want to know the function's signature but also its semantics. It's an overview, so you have to cut out *some* information. I want to quickly see what's available, which isn't possible if I have to scroll through pages of overloads.
search terms -site:cplusplus.com 
&gt; temporary materialization conversion "Quick, Spock! Trigger the temporary materialization conversion from the bridge to Vega prime!"
what's so bad about it? I always use it in source files. never in headers of course. 
Maybe it wouldn't be such a bad idea to have a pinned thread for open source C++ projects looking for developers, in the same style as the hiring thread. I guess the only question is whether it would get enough traffic from FLOSS projects looking for devs.
&gt; That's almost never the purpose. If you're outputting enough text for this to matter, usually a human isn't intended to read it all. I have worked on an offline billing system ("offline" = done at the end of the month, not in real time), that had as one of it's core requirements (imposed by national legislation), that each step of the billing process, had to be archived and trackable (each step had to be verifiable by a human being, in an audit). For this, they generated intermediary results in the billing process to text files, so an accountant (or financial inspector) would be able to look through them in detail. Running a billing cycle (for a million or so customers) took about two days, and could generate a few Gb of text files, _for the explicit intent of allowing a human being to go through them_, if necessary.
e.g. http://en.cppreference.com/w/cpp/utility/tuple/tuple or http://en.cppreference.com/w/cpp/regex/sub_match/operator_cmp ?
cppreference, cplusplus and the microsoft documentation (I downloaded it for visual studio so I can check it with their Microsoft Help Viewer application). I prefer cplusplus to cppreference in some cases because it always says if a class throws or not, seems I can't find that info in cppreference.
Are you talking about the mouse clicks in the background? Someone was clicking a mouse throughout the episode.
 auto a = make_array(1); a = make_array(1, 2); // error! the fact that sizes are part if array type has not changed. make_array was easy to write, and had the same issues. All this change does is get rid of `make_`.
IIRC `basic_string` has 128 member functions (counting overloads) in C++14, and C++17 added some more. So I'm not exactly eager to dump them all into one page.
Pointers have their uses. The c++ core guidelines has a section covering when and where to use them. 
Oh my. Nice find on `sub_match`; I thought `optional`'s was bad enough, but it's only a measly 30 overloads compared to `sub_match`'s 42...
&gt; So, I grant that lambdas may be more appropriate for the majority of cases once someone embraces more of the modern C++ constructs, but there's nothing wrong with recommending std::bind for people transitioning from pure C std::bind has often a (very) significant negative performance impact compared to lambdas, especially in loops. For this and other reasons, std::bind should be avoid in almost any situation a lambda is usable, especially for beginners to C++.
"Only forward, stay in scope." No biggie.
Not just for C++, but I have really been liking [devdocs.io](https://devdocs.io/). For C++, it's the cppreference documentation, but if you're also using other languages, it's handy to have it all in one place. Bonus points if you use duckduckgo: `!dd &lt;search term&gt;`.
Do you have any examples of what your errors are and when they occur? There are a whole host of potential issues, from not having the right CRT files on the system to trying to link binaries built with incompatible versions of Visual Studio. 
&gt; Why is that? C++ is the only one that works (for the things I do, at least)
Goto Is by far the cleanest way to do multi-level breaks. I really don't like dealing with an extra "is found" or "is complete" bool.
I'm not talking about how familiar the code looks. I'm talking about how hard it is to keep track of which variables are valid where, and where it would be UB to access them. 
CppCoreGuidelines is worth a thorough read after learning the language basics. C and old C++ are, although mostly compatible syntactically, very different (in a harmful way) from idiomatic modern C++, so try to stay away from their idioms when learning new stuff.
&gt; Right, so it's not "fucking up". Please don't get me wrong, I'm sick and tired of the "hurr durr MSFT sucks" meme, but such a [difference in quality of implementation](https://godbolt.org/g/zh7KlT) is... really not what I expected :\
When I started with cpp (a year ago). I pretty quickly realized I had to work in "my own" programming style. If I tried to do everything the most correct / efficient / modern way.. I'd spend a huge amount of time learning, twist my brain until I could match what I actually wanted to express in this "optimal" cpp. (just to realize from some other blogger that another way might be better) I abandoned that, threw away all design patterns, most of the object orientation.. using lot's of raw pointers.. not using any libraries (apart from std).. It was incredibly freeing and my productivity and fun programming went way up. Luckily I program alone.. ;-) Now I can slowly revisit some of the subjects.. see if I can add it to "my way" of using cpp. That.. and learn the STL. A lot is already in the standard library too. 
I haven't played too much with std::move but I'll admit seeing it twice for the same variable looks wrong. Will this be a new "bad smell"? I get that in this version the semantics tell you that try_emplace did not actually move any info out of food, but it does look weird.
This has been my go-to coding exercise when interviewing candidates. It comes down to: 1. describing a data structure that keeps track of allocated/free blocks (the "heap") 2. a simple algorithm to find a suitable free block (the actual "malloc" code), mark it as allocated, then return its starting address Easy implementation: use a single-linked list as (1) and a list traveral/insert as (2).
http://clang.llvm.org/docs/IntroductionToTheClangAST.html
It's not inconsistent if you use a rule like that
Sorry for being pedantic, but normally "transpiler" refers to a [source-to-source compiler](https://en.wikipedia.org/wiki/Source-to-source_compiler) between two languages. I might call what you're asking for a C++ source optimizer. Source: I've had to work with way too many transpilers. 
I still think it's necessary. I actually turned down people with 5+ years experience because they failed coding a proper FizzBuzz.
http://devdocs.io/cpp/
I thought "transpiling" was JavaScript thing? Traditionally it was always called compiling, regardless of source and target language. At least that's how I remember my compiler theory class. But then again it's been awhile now so I might be wrong.
Great and concise sum-up! Is there anything similar for previous incarnations of standard?
The plurality of replies is bringing me into your camp :)
Think of transpiling as a subset of compiling, so either term applies here. I do believe it started out as a JavaScript thing but the term has general usage now. Human language is flexible like that. :)
Those readability benefits aren't applicable to the article's audience, which is people experienced with C and typedef.
 void* malloc(size_t size) { return HeapAlloc(GetProcessHeap(), 0, size); } Kinda feels like cheating, doesn't it? 😐
Okay, I did some research on the performance impacts, and I'm convinced. I'll update the article to use a lambda. Edit: Published an update with the lambda.
You lay the foundation for unforeseen problems. If you have two namespaces pulled in that have functions with the same name, and then you'll end up calling the wrong function without realizing it, making debugging the problem a massive nightmare. If you have an extremely limited scope, it could be fine. But then again, it might not. Of course if there's one particular function you type a lot, and want to save a few key strokes, you can be very specific, such as `using std::cout` for example, instead of including the entire namespace. The problem is that, for beginners, they have no idea yet what all goes into the standard library. So they have no idea that they might run into naming collisions. Telling all newcomers that using directives are something they should always do is a bad idea. 
The project and its runtime environment are not large enough to warrant this. Besides, I like knowing my RAM requirement at compile time, since this affects purchase decision for the MCU to be used in future designs.
[Zeal](https://zealdocs.org/) and [Dash](https://kapeli.com/dash) for the lazy.
Yeah I guess it's a fairly intuitive word. It's a bit how young people use 'performant' instead of 'fast' these days. Gotta make the old sound new and fresh!
Do you know **every** name in namespace std?
int_fast32_t and int_least32_t both specify a minimum width. The difference is that "fast" will choose a data type that maximizes performance while "least" will choose one that minimizes memory usage.
Please read the sidebar; you probably want StackOverflow.
Great for you. But in a "few years" I'll likely be dead
&gt; This change means that copy elision is now guaranteed, and even applies to types that are not copyable or movable. Nitpick: "neither copyable nor movable". And I think this: `return (f(a, b) + ... + 0); // binary fold` can just be this: `return (f(a, b) + ...); // binary fold`
totes yeah brah
The point is not just this optimization. I can't speak for Clang but at least the ICC compiler can do other closed sum forms and in addition will reorder loops so it can reduce other loops into ones that have a closed form representation.
I use `goto` a lot too, only for me it's in the form of a named-let.
+1. These kinds of optimizations may be applicable to array element address computation optimization (subscript optimization) -- either direct, e.g., with subexpressions of the array address polynomial known at compile time -- or indirect, allowing further optimizations. [Scarborough and Kolsky](http://dl.acm.org/citation.cfm?id=1663145) is a classic reference, showing a few simple examples; for instance, the following ones are worth a look (PDF link attached below): - Figure 2: Examples of multiplication, addition, and subtraction strength reduction. - Figure 7: Effect of subscript optimization. The standard compiler has strength-reduced the subscripts for A and B but not for C. The enhanced compiler has combined the J and K subscripts with the addresses of B and C. - Figure 8: Effect of continuing strength reduction until no more reductions can be performed. The standard compiler, initially finding no multiplication strength reductions, has prematurely terminated addition strength reduction. The enhanced compiler has combined I and 4 and executed two subsequent multiplication reductions. PDF: https://pdfs.semanticscholar.org/6b54/b1ed1f2d9c64de583b60e2659bdd29ce15f2.pdf Section 7.5.3 of "Engineering a Compiler" by Cooper &amp; Torczon offers a modern treatment: https://books.google.com/books?id=_tgh4bgQ6PAC&amp;pg=PA364 // Edit: Fixed typos.
We don't actually list the member functions though.
where did you find this list? is there any unofficial documentation of these?
IDA Pro string references. 
Good to know thanks
we do now
When I'm drilling down, I like the "higher level". It's easier to find the functions that do what I'm looking for, and then I can look at the parameters to see if they use the types that I need. 
[dlsym](http://pubs.opengroup.org/onlinepubs/9699919799/functions/dlsym.html) returns "the address of the function converted from type pointer to function to type pointer to void" and it's the programmer's job to convert it back.
You may have a look on a reddit discussion [here](https://www.reddit.com/r/cpp/comments/5dxnwm/why_doesnt_stdstring_have_a_split_function/) or a [standard proposal N3593](http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3593.html), or an excellent [blog post](http://tristanbrindle.com/posts/a-quicker-study-on-tokenising/) by /u/tcbrindle (and discussion on reddit [here](https://www.reddit.com/r/cpp/comments/432n9h/a_quicker_study_on_tokenising/)), or [this](http://stackoverflow.com/a/30967198/4451432) Stack Overflow answer. 
Thanks!
Thank you for the kind words. It's worth pointing out that Range-V3 has a [`split` view](https://ericniebler.github.io/range-v3/index.html#range-views) which lazily splits a range into a range of ranges. Views aren't currently part of the draft Ranges TS (the standardised version of Range-V3), but I recall Casey saying they'll be added eventually. So hopefully, maybe, we might finally have a generic `split()` in C++ by 2020?
Anyone knows whether Rose Compiler is good?
He should probably use a more suitable example then. It feels as if the compiler was proud to have figured that summing n times was the same as multiplying one time, but then the programmer is the one writing braindead code.
Sounds very Linux centric. On Windows your malloc would be a wrapper around HeapAlloc..
What is a fizz buzz and why would you expect 5 years of experience programmers to know what that is ?
This is the top-level comment for **meta** discussion. Reply here if you have questions or concerns about this post.
We can only pin two threads. This seems like a huge ask, unfortunately.
**Company:** Microsoft, Visual C++ Team **Type:** Full time **Description:** We're looking for a brilliant developer to join our compiler front-end team as we take on a new charter for C++ compiler development. (The front-end parses and digests C++, as opposed to the back-end which optimizes and generates assembly code etc.) You will have the opportunity to work directly with customers and other Microsoft teams as we add new features to our language and libraries. You'll experience the indescribable joy of resolving compiler bug reports submitted by library developers, as they use your features in ways that no sane person could possibly have anticipated. We work closely with the C++ Standard committee and continuously evolve our compiler to adhere to the C++ language evolution. We are embarking on some very ambitious and impactful features in several fronts, including language innovation from the C++11/14/17 standards and technical specifications, making the parser robust and fast, and most importantly investing in compiler tools that truly target cross-platform development across Windows, Android, and iOS. Your passion and skills in language design, parsing, binding, static analysis, and C++ programming will help you succeed as a key member of the team. **Location:** Redmond, WA, USA **Remote:** No **Visa Sponsorship:** No **Technologies:** Compiler front-end, C++98/03/11/14/17 (our codebase is a mix of old and new code; new features are used freely and aren't forbidden). The ideal candidate will have 2 or more years of experience designing/shipping imperative language compilers/languages/APIs/tools, experience working with a language standard, and strong C++ coding skills. An MS degree in Computer Science or a related technical field is preferred. **Contact:** Send your resume to batul at microsoft dot com (this is Ulzii Luvsanbat, the compiler front-end dev lead). **More:** We're also hiring a Program Manager. See [this Microsoft Careers page](https://careers.microsoft.com/jobdetails.aspx?jid=280510) for that job description and an application link. **Even More:** We're also hiring one Static Analysis dev (kinda like the FE dev position above, but different) and **many** IDE devs. If you're interested, send a PM to /u/spongo2 (Steve Carroll, VC Dev Manager - also Ulzii's boss and STL's double boss).
With mission critical systems you do everything in seriously reviewed stages. The key is you trust no one at any stage. The requirements are examined, the plan is examined, the design is examined, etc. Then while the system is being built a huge team of people are building tests to brutalize the system when it is ready. There is no room for agile anything in that mix. This isn't just kind of the way you build mission critical systems but regulatory. Independent companies will audit your work with a fine tooth comb and if they think you were not following the plan to the last detail they won't sign off and then your customer can't use your product, which means they won't pay you. To suggest agile for mission critical would indicate a fundamental lack of understanding as to how these things are made. Kind of like suggesting using QBasic to build a first person shooter, and then never delivering the punchline. 
Transpilers is what JavaScript people call "compilers".
Yeah I work on mac / linux most of the time. 
Looking forward to meeting you people!
**Company:** Fractal Technologies (http://www.fract-tech.com/) **Type:** Full time **Description:** Fractal Technologies is a small, fast growing company developing software for chip development and manufacturing companies. Major semiconductor companies world wide are using our software to validate chip design libraries and IP blocks. For the expansion of our international software development team based in the Netherlands we are searching for a software engineer who can work independently, is passionate about his work, and eager to learn. Our main development languages are C++11 and Python. We are now migrating to C++14, and once GCC stabilizes C++17 support we will upgrade to that. Our engineering work is versatile; project examples include the redesign of software components for thread-safety, performance improvements to existing components to handle ever growing design data efficiently, design and implementation of a wide spectrum of validation algorithms, and the visualization and reporting of validation results. **Location:** Eindhoven Area, Netherlands **Remote:** No. We work three days from home, two days at the office. **Visa Sponsorship:** No **Technologies:** Your preferred Linux distribution in combination with C++11, and soon (we are upgrading this week!) C++14. **Contact:** Interested? Please send an e-mail for more information, or your resume to: info at fract-tech dot com
**Company:** [Ubimet](http://www.ubimet.com/), Meteorological Software Development **Type:** Full time **Description:** Ubimet is a leading weather service providers in Europe. We're experts in meteorology and issue customized weather forecasts for several million private and industrial customers. Together with our shareholder (Red Bull), we pursue the goal to be the weather service with the world's best quality forecasts. Our work impacts millions of lives, e.g. through our severe weather warnings or through weather forecasts for airports. We're looking for a C++/Python developer with a good grasp of both languages to work on interesting problems at the intersection of big data, realtime services, and scientific computing. We offer a great work environment and opportunities for growth within an engaged, international team. **Location:** We're located in Vienna, Austria, the city with the highest [quality of living worldwide](https://en.wikipedia.org/wiki/Mercer_Quality_of_Living_Survey). While most people in Austria speak German, it's easy to get by as English speaker. English is used in the office, as ~50% of our developers do not speak German. **Remote:** No **Visa Sponsorship:** Yes **Technologies:** We use C++11/14 and rely heavily on Boost and geospatial libraries like libgdal, libgeos, etc. Python (both 2 and 3) is used for smaller, less performance-critical projects and for glue code. Our automated tests are based on googletest and pytest. We are staunch believers in open source software, and nearly all development machines run Ubuntu Linux. **Salary and Benefits:** The salary range for this position averages between 36,000€ - 48,000€ per year (~39,000 - 51,000 in US $). The salary is negotiable. The cost of living is way cheaper than in most international cities. Renting a decent flat costs about 500-700€ / month. Food expenses are in the 300€ per month range, without penny-pinching. Most of the taxes go into a retirement fund that is available even when retiring abroad. We offer 5 weeks of vacation and our employees usually take all of it. We take life-work balance seriously. Additionally, we have great social security, healthcare is essentially free, including dentists visits. Schools are good and free. **Contact:** If you're interested, please apply via our [hiring portal](https://career2.successfactors.eu/career?career%5fns=job%5flisting&amp;company=C0016085212P&amp;navBarLevel=JOB%5fSEARCH&amp;rcm%5fsite%5flocale=en%5fUS&amp;career_job_req_id=82&amp;selected_lang=en_US&amp;jobAlertController_jobAlertId=&amp;jobAlertController_jobAlertName=&amp;_s.crb=QmF%2bAjlIebHvLmJp6Hsg%2bJdEb4c%3d).
* cppreference for language and standard library * boost * stackoverflow
I have had an interview (for writing performance-sensitive code at a hedge fund, no less) where the interviewer was surprised that I was using `'\n'` or `"\n"` in preference to `std::endl`. When he asked me "How would you flush the stream?" I said `&lt;&lt; std::flush` --- "I have never seen that before". To be fair many people totally avoid the streams library in performant code, so I didn't take the knowledge gap on his part as too alarming. 
A bit late to the party here, but I was wondering: are you folks were planning on supporting [selection statements with initialiser](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0305r1.html) in one of the upcoming MSVC++ updates? I'd ask in a PM but I might as well make any answers to this question semi-visible for those viewing this in the near future.
We already have scope expressions. They're called lambdas.
Know of anybody willing to take an undergrad student studying Cyber Security under their wing? I've learned the basics of C++, and I'm from Washington and willing to move back there in a heartbeat. 
**Company:** [ScyllaDB](http://www.scylladb.com/) **Type:** Full time; remotes welcome **Description:** ScyllaDB develops an open-source, high-performance, distributed NoSQL database, also (total coincidence) called [ScyllaDB](https://github.com/scylladb/scylla). ScyllaDB utilizes the asynchronous I/O engine [seastar](https://github.com/scylladb/seastar), which we also develop, to drive million of operations per second on large multi-core machines with fast SSDs. The stack includes everything from custom memory allocators, through a user-space TCP/IP stack using [dpdk](http://dpdk.org), through high-level concepts like query parsing and compilation and maintaining materialized views in synchronization with the base table. **Location:** Israel, San Francisco Bay Area, and many remotes around the planet (13 countries and counting) **Remote:** Very much, most of the workforce is remote **Visa Sponsorship:** in special cases **Technologies:** C++14, C++17 (very soon), boost, asynchronous programming, future/promise, JIT **Contact:** jobs@scylladb.com 
With `std::array`, it's much simpler: struct Student { using scores_t = std::array&lt;int, 5&gt;; void input(scores_t newScores) { scores = newScores; } private: scores_t scores; }; It makes arrays a regular type instead of a decaying bug factory.
&gt; Having only access to an equality predicate, the algorithm cannot do much better than trying (in the worse case) all the combinations. Trying all the combinations would take `n!` time. The algorithm just counts the number of times each element appears in each range, that's why quadratic.
**Company:** [Christie Digital](http://christiedigital.com) Yes this post is just like last quarter and the previous etc - we've hired, but we need to hire more! **Type:** Full-time **Description:** We make digital projectors based on DLP technology. But the real interesting stuff is projection mapping - taking a bunch of projectors and stitching them together to make a single canvas, and projecting onto screens, buildings, 3D models... [almost anything](https://www.youtube.com/playlist?list=PL7CBEC9E4CFDB1FD9). Basically, [we paint with light.](https://www.christiedigital.com/en-us/projection-mapping) We are looking for experienced C++ devs that like pixels, math, machine vision, machine learning,... But really, the most important thing is just _good coders_. Coders that can make abstractions and write clean code. (maybe "we are looking for C++ devs who like _functions_ and _classes_" wow!). I'll assume you are smart enough to figure out the domain-specific stuff once you get here. **Location:** Kitchener-Waterloo, Ontario, [Canada](http://www.usnews.com/news/best-countries/quality-of-life-rankings) **Remote:** Unlikely. **Visa Sponsorship:** Unlikely. **Technologies:** We are currently mostly using C++11/14 under Windows (MSVC 2015). As we now have a member of the C++ committee on the team (that you get to work closely with! - even less exciting than it sounds!) we are pushing forward towards the latest standard. We also like Boost (of course). And OpenGL and other 3D technologies and open source libraries. And I have to admit (sorry) - knowing Javascript wouldn't hurt either. Seems to always be a web angle somewhere. **Contact:** check out our [job postings](https://www.christiedigital.com/en-us/about-christie/careers/canadian-careers); in particular, the [Projection Mapping](https://apply.hrmdirect.com/resumedirect/ApplyOnline/Apply.aspx?req_id=435003&amp;source=435003-CJB-0) posting. For imaginary bonus points, figure out the email address I use on the boost lists, and email me at that address. Or some other email address of mine (I have plenty), besides my all-too-obvious gmail one.
Use std::array. Once you realize that it is not always 5, use std::vector.
Sounds like something that would happen to Barclay in the transporter.
Maybe instead of requiring an ordering you could impose one on the input data set with a hash. Granted you aren't guaranteed to get a perfect comparison chain, but it could get your worst case to be not as bad. If you don't mind using more memory you could also maybe just dump the first range into an `unordered_set` and see if all the elements of the second range are in there.
Add an alternate code path to use pinch events by default on Macs, and make it configurable. Applications that use scroll events for zooming are unusable on Macs with trackpads. Web applications commit this blunder with some abandon as well. There's about 100M active OS X users out there. Don't make them hate you by default.
Useless images that illustrate nothing yet take about as much space as text does? Instant turn-off.
This is done because people don't understand what anything means and just copy-paste stuff around with no understanding.
&gt; I'm just diving into the modern C++ waters And you decided that the best thing to do is to publish an authoritative-sounding article about modern C++?! &gt; My original goal here was using a parallel construction This makes sense you're showing the transformation from C to C++ as a series of steps: it belongs in some of the intermediate steps. Otherwise, if it doesn't read like idiomatic C++, it doesn't belong in the final variant.
In my favorite question so far they showed me two C API functions for some struct, `allocate_struct` and `deallocate_struct`, with some C++ code to wrap it. The C++ code had some actual coding errors, but also basically consisted of a new and free function. So what they were looking for was me spotting the bugs in the code, but also suggesting using RAII. I liked it because it's one of the few questions I got that does not focus on language specifics or algorithms but rather on insight into writing maintainable C++.
I would say that has more to do with `std::swap` and less to do with moving. Looking at the move ctor and assignment operator for `my_class`: my_class (my_class &amp;&amp; other) noexcept; my_class &amp; operator = (my_class &amp;&amp; rhs) noexcept; You can see that their arguments are rvalue references which means if they are not conceptually rvalues then you've implied something which isn't true. However look at `std::swap`: template &lt;typename T&gt; void swap (T &amp; lhs, T &amp; rhs); It deals in **lvalue** references. Therefore I'd argue that a self-swap is acceptable in some sense (since logically lvalue references should be able to alias) but self-move is not (since logically rvalue references should not be able to alias).
You are of course free to have self-move-assignment be UB for your types. Just be aware that on every single shipping version of `std::swap`, if your type gets self-swapped using `std::swap`, it will produce UB for your types (but not for other types meeting the `MoveAssignable` requirements).
**Company:** Stevens Capital Management LP (http://scm-lp.com/) **Type:** Full-time **Description:** Stevens Capital Management LP (“SCM”) is a registered investment adviser that manages a multi-billion dollar hedge fund that has been in business for 25+ years. SCM specializes in the rigorous development and disciplined implementation of empirically based quantitative trading strategies. Our highly productive team works in a fast-paced collegial environment, utilizing extensive data sets, technology and the scientific method to devise and employ trading strategies throughout the world’s most liquid financial markets. We are seeking highly driven, production-oriented developers who possess strong technical skills and the ability to work in a fast-paced collaborative environment. **C++ Market Data Feeds Developer** This is an opportunity to work in a real-time environment where you can make immediate contributions. You will be part of a small team building real-time data feed handlers for the largest financial exchanges such as the NYSE, LSE, TSE, CME, BATS, ICE and NASDAQ. **Primary Responsibilities:** * Develop and implement infrastructure to support market data and trading. * Develop and maintain market data feeds. * Build and design large scale applications, with a focus on reducing latency and improving the performance of the system. **C++ Software Developers** **Primary Responsibilities:** * Utilising your in-depth knowledge of C++ you will design, develop and implement proprietary trading programs, encompassing trade analysis, price validation, order routing, monitoring and risk analysis. * Develop and support multi-threaded applications with a strong emphasis on high performance. * Optimize our trading strategy implementation and performance analysis platform using network and systems programming. * Create tools to process, store and analyze quote, order and financial data. * Work closely with our quantitative research analysts, engineers and other groups to provide software solutions. **Location:** Radnor, PA. USA **Remote:** No **Visa Sponsorship:** SCM will consider assisting successful job candidates with United States immigration permits, if such a permit is required to work for SCM. **Technologies:** Professional-level C++ programming experience in a Linux environment. **Contact:** Please submit your resume to: recruiting@scm-lp.com 
It should be possible to add a std::hash based hash version of std::is_permutation right? But I'm guessing it wouldn't be standard compliant as the memory complexity would increase (in return for a number-of-operations complexity improvement) right?
 auto less_on_second = ordering_by_index&lt;1&gt;(); Is this a standard thing?
I think ``cppreference`` does a great job in this regard. Before using any non-trivial algorithm, I almost always check ``Complexity`` section and verify that it is doing what I intend it to do. Overall point taken though. ``std::stable_sort`` has this in the description: &gt; O(N·log2(N)), where N = std::distance(first, last) applications of cmp. If additional memory is available, then the complexity is O(N·log(N)). So I guess ``std::is_partition`` can also be done this way.
hash only gets one element to look at -- anything regarding is_permutation will necessarily need 2 ranges. `unordered_Xxx` equality is indeed powered by is_permutation.
Still, there are many common situations where "using" is cleaner, so we might as well encourage its use everywhere. Having one way to write something seems better than having two.
I'm not sure if this is allowed here, but I was wondering what is the starting salary for a fresh graduate in the USA ? I searched online in Chicago(base here) and the average was 60k a year. I love c++ and want to get hired as c++ dev but isn't 60 too low ? That's same as java which is way easier and messier than c++
Please don't do this. The braces initialization is great, but `std::vector&lt;int&gt; a{10}` and `std::vector&lt;int&gt; a(10)` do two very different things despite looking similar. At least use `std::vector&lt;int&gt; a = {10};`. 
[removed]
Also, I took it from functional languages like haskell, where it would be very nice and easy to implement with something like: `sort(zip(container1, [1..]))` And then something to take take only 1st element from each pair (I think there is some built-in functon for this but don't remember). I think something like this would be easy with Ranges. in the future. :)
Not really sure what your issue is but most likely CMake is your solution. Never edit VS project files by hand! You do not want to go there. Use CMake. Learn it properly (modern CMake). Also, vcpkg may help.
Due to the fact it returns `void*`, we can't never make it type safe. I realized this. With `auto` we are changing the function signature, also.
I see. Are you aware of any teams at Microsoft who hire remote C++ devs?
You got my attention. Why do you write: using scores_t = std::array&lt;int, 5&gt;; and not: typedef std::array&lt;int, 5&gt; scores_t; &amp;nbsp; To be honest, I can't really argue one over the other, so is there a specific reason for choosing one over the other in this example? Intuitively I would have used the latter. &amp;nbsp; Edit: This [stackoverflow-thread](http://stackoverflow.com/questions/34463260/how-to-typedef-a-stdarray-with-a-unspecified-size) answered my question. Looks like in this particular example, both *typedef* and *using* would have worked.
Yes indeed both syntax would work, but the typedef syntax cannot be used to create template aliases as opposed to the using syntax. Since I often use template aliases, I prefer the using syntax because I want to use the same syntax everywhere.
Or use QTCharts... Natively compatible, and not depending on another (sigh) 3rd party lib.
Have you tried building it through WSL?
That creates an ELF binary, not a windows executable. I've successfully built cling under WSL.
Sure, but I really wanted to test out this amazing repo: https://github.com/Axel-Naumann/cling-all-in-one This also works (I tested) under ArchLinux and macOS
I'd assume they still hire with visas in other departments ?
And the ELF binary still runs on Windows. The question didn't specify what level of "runs on Windows" is acceptable - this is acceptable in some cases (e.g., using WSL GCC from Visual Studio). So I gave a quick and easy solution that might work or not.
Cool, I'd be interested to try out your cling binary if you're able to share
Your post has been automatically removed because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/63jb42/goldcoin_could_use_your_help/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Good question, thank you. I've included a "Salary and Benefits" section in the top comment. Essentially, the salary is lower than in the US, we don't do six-figure salaries. On the flip side, living expenses are way lower, we have social security, the taxes mostly go into a retirement fund, schools are good and free, etc. Also, 5 weeks of vacation. It's a good life here :-)
Depends on the use case, but they can be executed in parallel. For example if you need to multiply 4 32-bit floats by 25, you can do all 4 at once.
I have been able to compile using MSVC 2013 but I've had to patch some files manually fixing some errors. I have been recently asking on their forums and looks like the only supported MSVC compiler is 2015 but it's not tested daily like the other platforms so it's possible to have stability issues.
Btw, in what countries/territories do you have Visual C++ team/departments? In the past, I've heard you had a team in Hawaii, is this still the case? Also, any non-US (Redmond) locations?
Thanks! &gt; the taxes mostly go into a retirement fund What if the person leaves e.g. after 10 years... Is she able to take that contribution with her? One thing I don't like in [west] Europe - most people rent homes (usually tiny flats, even rooms)... Do you think a developer in Vienna is able to *buy* a good house in a good neighborhood? 
Also, if you can't/don't want to move to the US, maybe moving to another country is an option, since MS has dev centers globally. Source: got an internship at MS Dev Center in Serbia. 
`int` must be at least as long as a `short` and no longer than a `long`. Because a `short` must be at least 16 bits wide, it follows that `int` must be at least 16 bits wide. A small number of embedded compilers do set `int` to be 16 bits, and a small number of (historical) compilers set `int` to be 64 bits wide. http://en.cppreference.com/w/cpp/language/types
Well I'm not here to say "that's the best solution ever" it was a big software for a company which use it on linux and they wanted "the same zoom as google maps". So I found this solution and I thought it maybe usefull for some others persons. I'm not a big boss with qt, if you have better solutions I'm open minded :)
Cool. Quite recent version of GCC I must notice, especially because it is targeting such a small CPU.
I would like to see Intel TBB included, as well as std::async.
You're misunderstanding the very thing you quoted. Suppose you're sorting a list of pairs of ints with a predicate that looks only at the second element of each pair, just as in the blog post. Because the sort is unstable, given the input { {1, 2}, {2, 2}, {3, 2} }, a valid output is { {2, 2}, {3, 2}, {1, 2} } // OK On the other hand, suppose there is a grave error in the unstable sort and you actually get as output { {2, 2}, {2, 2}, {2, 2} } // BAD If you are using a known correct stable sort function to get the expected result, then your unit test will be comparing the outputs above to { {1, 2}, {2, 2}, {3, 2} } // EXPECTED Now, if we follow your strategy and "check that corresponding items in output and expected are equal (or neither less than the other)," we have a problem. If the equality test is done using the predicate that we sorted with, that only looks at the second element, then both the OK and the BAD outputs will pass. If the equality test is done with something that considers the whole object, then neither the OK nor the BAD output will pass. The problem is that with an unstable sort, any subsequence of elements equal under the sorting predicate can be arbitrarily permutated. Hence the desire for an efficient algorithm that checks if one sequence is a permutation of another. 
No, it's about writing code that scales. Basically they're arguing that they have a really cool trick for optimizing bubble sort, and I'm saying, uh... why don't you use quick sort. And they're saying I'm a heretic for suggesting bubble sort optimization isn't important...
&gt; older compiler &amp; infrastructure Any specific compilers you'd like to specifically target? [Most** of](https://gcc.gnu.org) [the free](http://clang.llvm.org) [and](http://www.pgroup.com) [vendor](https://www.edg.com/c) [compilers](https://software.intel.com/en-us/articles/c14-features-supported-by-intel-c-compiler) [support](https://www.visualstudio.com/vs/cplusplus/) C++11 or newer. As for target architectures, you can always do cross-architecture compilation ** - gcc, clang, msvc, pgi, intel, edg 
You don't lose the retirement money. You can access it when you retire, irrespective of whether that's in Austria or someplace else. I don't think you can access it beforehand, though. With a developer salary it's definitely possible to afford a house somewhere close to Vienna. The city itself has mostly apartments for rent or sale, and that's what a lot of younger people do. Often they then move into a house at the outskirts when they get older/have kids. This could be just a cultural thing - I really like living in an apartment close to the center, enjoying what Vienna has to offer.
Well, some places absolutely refuse to upgrade compilers...
Okay, but would that same place even allow the installation or usage of a source-to-source compiler? I highly doubt it
The earliest use of the word "transpiler" I've been able to find is a paper dated 2006 on C++: http://link.springer.com/chapter/10.1007/11951148_14 It's possible that the word has been invented multiple times, because it is a natural portmanteau of the words "translator" and "compiler". It feels natural, because it is loosely congruous with the more commonly accepted "decompiler", which by some definitions is still a compiler. 
&gt; From what I could see from the docs, doesn't rtags obsolete YCM in most ways Yes. When I started, the overlap was a lot smaller. For example, rtags had only experimental code completion support, while YCM was struggling with its "go to symbol" feature (it only worked in the same file). That's not true anymore. &gt; And the compilation database seems useless for header files without corresponding translation unit. Does rtags handle this more smartly? I still don't use the completion features from rtags, so I can't answer that. That said, this is a valid concern, but can be worked around reasonably easily. In fact, the YCM config that I use in rpclib (based on the one that YCM provides as an example), does it here: https://github.com/rpclib/rpclib/blob/master/.ycm_extra_conf.py#L68 In a header-only situation this does not help, altough if you don't have any translation unit where you include your files, you don't really compile anything. The default include paths and defines can be used as a fallback for these cases.
We plan to have all the C++17 features done before the ink is dry on the C++17 standard. More details here: [C++ Standards Conformance from Microsoft](https://blogs.msdn.microsoft.com/vcblog/2017/03/07/c-standards-conformance-from-microsoft/). We still have some nasty issues to fix before we can declare ourselves conforming--the preprocessor is probably the last thing on that list, though we're still working on two-phase lookup and finishing expression SFINAE--but we expect to have that work finished soon as well. Let us know if you have any issues moving to VS2017. You should definitely try it at least for the conformance work and TS implementations (coroutines and modules now, concepts just started, ranges and other lib goodness on the way as well.)
The other wonderful thing about undocumented machinery is that it's not supported and can be changed or yanked out of the compiler at any time. You're welcome to use undocumented machinery, but you're not welcome to expect it to work or to continue working as it appears to work today. If you have a real scenario for any undocumented machinery you should send me mail explaining why you need a public, documented feature in the compiler. 
There are some circumstances that when a company recompile their code by newer compiler, compile error occurs, but no one can maintain that code anymore, so I'm thinking whether my idea can help people away from those problems.
Your website says "6 speakers yet to be announced", not "6 speakers yet to be secured". I was just about to book my flights for this thing and i'm starting to worry it's not going to happen.
Aync rest? That seems like an oxymoron (or I'm a moron? It's possible). Why not just use a service integration meant for async communication?
**Company**: [Cruise Automation](https://www.getcruise.com/) **Role**: C++ Software Engineer **Type**: Full time **Description**: We're the driverless car company. We believe in improving people’s lives by making transportation safer, more accessible, and more convenient. Our team is small and we move quickly. We’re currently testing a fully driverless solution on city streets in San Francisco. We're looking for smart, ambitious people to help build the world’s largest fleet of driverless cars. We are looking to hire C++ engineers across the entire company so please check out our [open roles](https://jobs.lever.co/cruise)! Check out [this video](https://www.driverless.id/news/video-analysis-new-gm-cruise-self-driving-video-shows-more-mastery-sf-roads-time-with-pip-proof-0176178/) of our car driving fully autonomously through SF! **Location**: San Francisco **Technologies**: C++ on ROS **Visa Sponsorship**: We can transfer Visas **Contact**: Anthony@getcruise.com
`auto m = std::mutex{}` If I ever saw that kind of code in the real world it'd become my mission in life to find the author and beat them with a rubber hose. 
It's a very easy program to write, so if you can't write it, all those years of experience don't matter. Basically, you output the numbers 1 to 100, except numbers divisible by three you output Fizz instead, numbers divisible by 5 you output Buzz instead, and both (15) FizzBuzz instead.
I don't think we have any "departments" outside Redmond. I think we have individual remote devs in Arizona and Canada (previously one in DC). I could be wrong about the scale of remote work (I know all the libs devs and all the FE devs I need to meow at about compiler bugs; I don't know all the IDE or BE devs). Many years ago our product unit manager (I think that was his title) was based in Hawaii - I think he had a small team working with him, but that's ancient history now.
same thought. I'd be surprised but it's possible as long as the users promise to read the generated code (who would do that though?).
The semantic differences between C++11 and C++03 are greater than C99 and C89. You'd need some pretty crazy compiler gymnastics to be able to handle constexpr, and with structures involved I'm not sure it's possible. With C++14 constexpr this gets a lot harder. If you want to do all this calculating at compile/conversion time that's fine but your libraries will lose a lot. constexpr int f(); template &lt;int&gt; class C { }; C&lt;f()&gt; c; struct S { int a; }; constexpr S g(S); C&lt;g(S{1}).a&gt; c2; move-only types seem like a non-starter. 
And what about &lt;atomic&gt;?
Interesting. What about Visual Studio in general (outside C++ compiler)? Is there enough C++ work, or is it mostly C# and WPF stuff nowadays (and maybe some WinForms)? Also interesting outside Redmond, or even non-US teams of VS... One I remember was in Zurich, led by Erich Gamma, but I think they were doing mostly JavaScript stuff.
I'm not sure this is possible in a generalized sense, but Boost has library support for using newer features (including many C++11 and C++14 features) without direct support from the compiler or standard libraries.
So no sponsoring of *new* visas (H1B or O1)?
Javascript is different in that you need to wait for all your users to get updated bits before you can use the new feature. But only you need to update your C++ compiler.
AGPL? Saw that license and did not look any further. Basically, if anybody uses this REST API, they have to opensource their entire application. Of course, you are free to use any license you want, but if you want a library to get the most attention in the C++ community, a liberal license like the Boost Software License is the way to go.
So, I've implemented `peek(progress)`and `peek(duration)`. Had to change quite a few things and const-correct a lot of stuff. Thanks for the suggestion again.
That's a pretty terrible analogy. The output of both sorts will be equivalent; whereas binary logging isn't human readable, which very well may be the whole point.
The library is at its alpha stage. We think that AGPL is reasonable choice for a library which is far from productional use. Anyway it is a pity that project's license is discussed instead of approaches to deal with asynchronous requests processing.
Just a heads up: you have a mistake [here](https://github.com/pmalakul/ThreadPool/blob/master/PerformanceTest/getpi.cpp#L216). You're default constructing `num_threads` threads and then later on calling `emplace_back` without reserving space in the vector beforehand, so you're effectively ending up with double the number of threads (but only the second half are actually running anything). The times in your native code benchmark might be artificially inflated by reallocations as well depending on your hardware concurrency.
[Babel](https://babeljs.io/)
Why bother with C++? Multiple answers to that question can be found in here : https://isocpp.org/wiki/faq/big-picture I was a bit surprised that this FAQ doesn't mention the zero-overhead abstractions principle though. Maybe some edits should be done in this regard!
Have you considered to write a backend for LLVM to convert the IR to C++? Maybe make the backend choose the "architecture", i.e., C++98, C++03, C++11, C++14, ... - or even C89, C99, C11? I don't know how feasible it is, but it seems like a much more generic and powerful option.
cplusplus for quick &amp; simple usage reference. cppreference for detailed understanding.
**Company:** Volant Trading **Type:** Full time **Description:** Volant is a technology-driven trading firm made up of a close-knit group of quantitative traders and technologists. For over 10 years we have specialized in automated options, futures and equities trading from our offices in New York, Chicago, and Hong Kong. We pride ourselves on our entrepreneurial culture, flat hierarchy, and cross team collaboration. We are hiring C++ developers with a minimum of 4 years of experience to join our core infrastructure team in New York. This person will work alongside a global team of talented developers as we design and implement core libraries for a high-frequency trading platform. As a flexible and agile company, we are able to match the seniority of the role to the experience level of the individual. **Location:** New York City **Remote:** Not for the first year of employment. **Visa Sponsorship:** Yes. **Technologies:** C++14, Python, Linux. Experience with API design, IP networking, and kernel internals are always welcome! **Contact:** Please apply directly on our [hiring portal](https://careers-volanttrading.icims.com/jobs/1094/software-engineer/job)
Hey this is awesome in principle, thanks for that! Especially that it's header-only. A few comments: * Why did you name the repo restinio-0.1? Versioning shouldn't be part of the repo name. Do it with git tags &amp; releases. * GNU Affero GPL v.3 license: Sorry. Please make it BSD, Apache, or similar. It's unusable with GPL :-( * What spoke against cpprestsdk, except that it's not header-only? I've heard only good things about it? Edit: Actually it has quite a lot of dependencies and seems to need ruby to build. Or only for the examples? It wasn't obvious to me from the Readme.
Do you have benchmarks comparing the running times of these different implementations?
Topics can be focused on C++ best practice, modern techniques, tooling and libraries. There are more details about speaking on the website.
I'm fairly confident that we will see articles like that in 2027, 2032, 2037 and so on. Just like why Java 16 sucks or why I think all software should be rewriten in my beautiful new language "Corrosion" which is totally safe from any sorts of bugs. Heck - it can even develop itself! 
&gt; Why did you name the repo restinio-0.1? Versioning shouldn't be part of the repo name. Do it with git tags &amp; releases. It comes from svn habits, and in my personal experience it is easier to work with independent repos for different generations of a project. I see that my point is not trendy, but that's the way I name it. &gt; GNU Affero GPL v.3 license: Sorry. Please make it BSD, Apache, or similar. It's unusable with GPL :-( There is some truth in what you say. We've got several similar objections, and seems like we didn't give a due attention to a license issue. We'll think about it. &gt; What spoke against cpprestsdk, except that it's not header-only? I've heard only good things about it? And you definitely won't hear bad things about cpprestsdk from me. The reason we've rejected cpprestsdk is that it is very self contained and pushes you to use ppl library and lots of other things to have all the benefits. But for dealing with multi-threading we use [SObjectizer](https://sourceforge.net/projects/sobjectizer/). And we don't want to have many tools for the same tasks in our applications. So cpprestsdk didn't stop us from creating yet another REST library :)
RESTinio is header-only. So building is about samples and tests. With ruby and Mxx_ru you can build all the samples and tests. But we have cmake fles for building 2 samples (see [cmake](https://bitbucket.org/sobjectizerteam/restinio-0.1#markdown-header-cmake) section). And minor offtopic: I wish cmake was as good and easy to use in his area as cpprestsdk in its area so we could provide cmake for entire build. But today only 2 samples available with cmake build.
That is a lot of boilerplate, try to expand and learn about pointers(just so you don't get confused in the future), loops(extremely essential), and arrays by means of std::vector.
if/else if/else if/else if/.../else if/else That's a switch. It's not syntactically identical to the "switch" keyword, but it performs the same function the same way.
try to never repeat yourself(DRY) learn how to use functions and at every viable opportunity use them to make code more readable and succinct. also as already stated switch statements could be a good idea in this case! keep up the good work though and you'll be making cool stuff in no time! 
It's funny because it seems like every high level language that isn't C/C++ is implemented in C/C++ at some level yet they all try to bash it in order to promote their own language. Complete with a VM and garbage collector and so forth and want everyone and everything to use it via hype-oriented development and holywar posts. (See: The "Rust Evangelical Strike Force")
At least in my experience C++ is not loved, rather it's tolerated because there's no suitable alternative in many cases. Nobody loves incomprehensible compiler errors, or glacial compile times, or unreadable template metaprogramming, or hundreds of subsets in the wild which prevent code reuse, or the million corner cases and caveats of unintuitive behavior, or the gigantic specification, or the... C++ violates the principle of least surprise as a rule, not an exception. It takes years of training and researching to avoid the numerous and plentiful footguns in C++. Programmers should be pragmatic, not idealistic. There's no sense in romanticizing pain through masochism when it comes to programming. C++ is often the only suitable tool for the job but that doesn't automatically make it a pleasure to use. Sometimes the only treatment is to drill a hole in someone's head. C++ is that treatment. It's sharp, it's dangerous, but if wielded extremely carefully and skillfully, it does the job.
I know this thread is a week old, but what you're missing is that the traits are hierarchical. That is, `is_forward_range_v&lt;T&gt;` will still be true when `is_bidirectional_range_v&lt;T&gt;` is true, so the compiler won't know where to dispatch (without brittle `is_a&lt;T&gt; &amp;&amp; not is_b&lt;T&gt; &amp;&amp; not is_c&lt;T&gt;` stuff). This isn't an issue with concepts because the compiler will know that `BidirectionalRange` is more specialized than `ForwardRange` and will dispatch there. It could also be easily solved with tag dispatch like Billy said.
My original point still stands. New people simply don't understand a word of what you are saying. I personally use cppreference but I can definitely see why cplusplus.com is more popular for new people, especially if they are looking for practical examples.
Edited the description. Thanks.
&gt; It's unusable with GPL :-( It is unusable with GPL v2, but can be used with GPL v.3. A quote from [gnu.org](https://www.gnu.org/licenses/license-list.en.html#GPLCompatibleLicenses): _Please note that the GNU AGPL is not compatible with GPLv2. It is also technically not compatible with GPLv3 in a strict sense: you cannot take code released under the GNU AGPL and convey or modify it however you like under the terms of GPLv3, or vice versa. However, you are allowed to combine separate modules or source files released under both of those licenses in a single project, which will provide many programmers with all the permission they need to make the programs they want. See section 13 of both licenses for details_.
But Rust doesn't use a vm or garbage collector? Or am I misinterpreting your comment. Also "bashing C++" isn't the same as making constructive criticism.
&gt; As Bjarne said, "Within C++, there is a much smaller and cleaner language struggling to get out." The beautiful thing about C++, is that there's so many way of doing things, you can use only the small subset you need and prefer, and the result of that may be somewhat close to that smaller, cleaner language. I suppose in that sense, C++ wins out over many other languages for approaching the position of being a universal denominator
My previous idea was to modify clang frontend, but your idea seems better.
My idea is that all the check and compile time calculation is done by the converter, the generated code will not consist that, so move might be replaced by a generated `swap` function? For constexpr and template, just hardcode the calculation result and the instantiated version, will that be possible?
"Glacial" built times claims are virtually always amplified manifold by the poor build process and poor modularity (meaning poor support for the modify-build-test cycle). Sure, C++ builds slowly. But applying sound practices helps **enormously**.
&gt; When I encounter that it either involves include abuse or GOD objects that are referenced by everything. Either way it highlights a design issue and can be avoided. You're right about the fact it often highlights design issues, but I have the impression that those same design mistakes with other languages won't bite you as hard for the compile times.
If you want to support that kind of use-case, make sure you plan ahead to make your customers pay for all kinds of support requests because they definitely don't understand what they're doing!
&gt; Source: I've had to work with way too many transpilers. Sounds like you've really enjoyed your time with them :p
Cpp core guidelines 
Also, templates. :(
&gt; convert the IR to C++? Isnt that a supposedly an even harder problem? I am not an expert , but isnt Source to Source transformation a simpler problem than to write an IR-&gt;High Level transformer (this is ofcourse assuming code readability/size/running-time are non-issues)
Another question is: Who is guaranteeing that the transformed source code (if generated) will be readable?
There are a few tweaks that you can do to improve the single-producer/single-consumer vector/mutex solution: - since there is only one consumer the vector swap can be done with a member variable instead of a local variable. This way the vector's memory can be reused. - at the producer side the notify should only be called if the queue was empty before adding the current item. You may also want to check out how `boost::lockfree::spsc_queue&lt;T&gt;` performs. (Only possible for the single producer/consumer case though.)
Exactly. This is for example, why python is more loved than java, because it tries to encourage the good practices and idiomatic (pythonic) solutions rather than trying to restrict developers so they can't do bad practices. Latest C++ standards are doing a great job further improving idiomatic C++.
Arista Networks is looking for great Software Engineers interested in product development in C/C++ and Go to join the team in Dublin advancing the Software Defined Networking (SDN) revolution. Arista is a profitable, publicly quoted company with 2016 revenues expected to­­­­­ exceed $1B. Arista is the number 2 vendor for data centre switches in the world with over 4000 customers including such well known names as Facebook, Netflix and Spotify. Teams in Arista are; **OpenConfig** - building a dynamic, programmable data centre infrastructure using software-defined networking principles such as declarative configuration and model-driven management and operations. **Routing** - working on the core logic of the network that decides on how packets traverse the network in the most optimal and resilient manner. **Platform** - the team working closest to the hardware, programming chips. **Kernel** - works in the linux kernel at the core of Arista EOS **Tools** - continuously improving the tools and build infrastructure so that the many hundreds of software engineers on the team can achieve their best every day. Typical projects include; Writing Linux user space and kernel code to allow 32-bit drivers to DMA 64-bit virtual memory spaces using both Intel and AMD IOMMU controllers. Accessing ASIC registers over SPI bus, SMbus, PCIe and I2C, to implement high resolution timers (sub-100ns accuracy) and read ASIC hardware specifications to gather near-real-time information on large numbers of packet flows and to generate network congestion statistics. Development of configuration management services using Go and Python to support YANG, OpenConfig, NETCONF and RESTCONF over gRPC, ssh and ssl for standardised switch configuration, combined with tools such as git, gerrit, Jenkins, Slack and Trello. Creating a streaming telemetry service for networking devices that will send real-time state updates from the switch to cloud-based data ingestion infrastructure. Working in Go creating gRPC and REST based services using modern development tools such as git, gerrit, Jenkins, Trello and deploying into a backend in a cluster using Kubernetes and docker containers. Development of routing protocol agents (for BGP, OSPF, ISIS) in C/C++ within a Fedora Linux embedded environment. Coding of fault-tolerant, concurrent agents capable of handling the demands of future data centres where high performance and high availability are basic requirements. Fully automated, developer owned, Python based, continuous test harness with 100s of devices under test at any one moment.
OP, A human moderator (u/blelbach) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/63s5f1/arista_networks_ireland_c_software_engineer/dfwjezz/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; At the same time they don't require my project to be GPL or AGPL And again: it is pity that project's license is discussed here instead of project's code or project's approach to deal with HTTP requests. There are lot of programs and libraries which are under GPL. There are projects which are under AGPL. World are very big and there is place for everything. AGPL was selected because we think it is appropriate for sharing out ideas in form of code, examples and some docs. When we will see that out ideas really work and our library is appropriate for everyday production use we will think again about licenses. Anyway it is much better to discuss C++, REST in C++, HTTP parsing in C++, performance, portability and other technical questions instead of holywar about copyleft vs permissive licenses. &gt; Changing the license later is quite tricky because, if you get contributions from outside, you will also need the contributors agreement. We know.
&gt; And again: it is pity that project's license is discussed here instead of project's code or project's approach to deal with HTTP requests. Sorry - but that's how it is. The AGPL is a legal nightmare, so most of the companies (including mine) do not allow any code with it. And I have no intention of trying things that I cannot use, even in theory, in my day to day job.
Yes, but: modularise and move templates into precompiled headers.
Thanks.
The consumer is not busy-looping or timer triggered. The consumer watches the reading event of a fd (created by socketpair). When we put a task into the queue, we notify the consumer by writing a byte to the socketpair. 
That's great. We have concidered these two suggestions that we will implement then in the future. Thanks. `boost::lockfree::spsc_queue&lt;T&gt;` is not suitable for our scenario.
In general: UB in this case means signed overflow. Thus 1. any signed type (overflow) and any type promoted to a signed one (for instance 0xFFFF unsigned short promoted to a signed 32-bit int, the multiplication overflow; it is possible that the promotion allows for exact computation, in that case going to unsigned is OK, going to signed is implementation defined -- note: not undefined) 2. same (a\*= a is defined as a = a\*a)
Close. Will `short` ever overflow?
I have been looking forward to this announcement. I went for the first time last year. Looking forward to going again!
OMG be careful! That table saw and drill press can maim you! It's just too hard to be constantly disciplined and vigilant around them! Here use my patented plastic power tools covered in Nerf! They are perfectly fine for making things out of cardboard.
[they are listed](https://isocpp.org/files/papers/p0636r0.html) in the "Changes between C++14 and C++17" paper on the isocpp website edit: dunno why implementations don't have them.
That probably depends on what exact problem you are trying to solve. Source-to-Source looks simpler, but it is also more complex. If the target language has limited capabilities, how would you express a variadic template, a lambda, a coroutine, ...? If you use IR as a fix-point, your code from the source is already broken down into low-level instructions and chunks, which might make it easier to expess it in the limited language of the target. Plus C is already close to assembler (YMMV) and old toolchains are more likely to support it. Of course it is hard to generate concise, readable, high-level target code. I wouldn't even attempt it. But if you are stuck with an old tool-chain, you might want to give up the readability of the intermediate step as long as you get results.
I couldn't find said discussion, what can I do with constexpr array? How will begin being constexpr helps me if the algorithms aren't constexpr? (or am I missing something) 
`loop()` encourages event-driven reactive programming, so I don't see this as a bad programming practice. It forces you to do things that way from the get-go, and I've never found it to be a problem. There will be such a loop somewhere anyway, might as well make it explicit. 
Oh, wow, I have the 'tism. I'll delete it. 
If you build a state-of-the-art system, mission-critical or not, you'd be using formal methods in design, e.g. the design and requirements would be captured in sysml, and you'd be willing to be state-of-the-art in implementation process as well, so that the process itself enforces human reviews, but also enforces the tests and test coverage, reproducibility, etc. A lot of the latter would be very similar in an agile environment: continuous integration, automated testing, test coverage analysis, use of simulators/emulators to link software to hardware, and so on. When you use sysml or similar formal design entry, you can automate all of the interfacing between that and code and/or hardware (all these methods also apply in digital hardware design and also mixed signal design!). I'm using custom tooling to handle sysml design entry even for very small (think 10kloc) non-critical products and I have requirement traceability from entry to shipping executable just as any mission-critical system would have. I've found it easier to implement it for small projects and scale up. I can whip out a hello world starting with sysml entry in an hour, and there's full requirement traceability with reports at all levels (requirements to design to code to test results). No extra effort once you've set yourself up for that.
You don't need to know what it is, but when it's explained to you, you should implement it or be shown the door. I also think that if you claim 5 years of recent experience in language X, you should be able to write a hello world that compiles without errors on the white board. I programmed in Pascal for 10 years but that ended 2 decades ago, I don't know if I could still get all of the syntax right on the first try (EDIT just checked: I could, yay). But C and C++ - I'd laugh myself out of the room if I couldn't do that (I use C and C++ daily). I've found that answering SO questions helps: it forces you 
It is stated as being of type `T`: &gt; `T a = &lt;any value of T&gt;;`
it's simply semantically impossible for c++
&gt; i doubt you'd be allowed to use Rust I think you don't understand how much influence a bit of marketing fluff can have on a brainless manager. I once worked on a C++ project that we could upgrade to a newer version only because that C++ compiler came in the same package as C#, which was considered the future. 
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/63tegb/any_good_c_practice_exercises/dfwzhhp/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x86 That's Visual C++ 2015, not 2017.
And yet it can't enforce things that really matter, like ownership semantics. That's why they want to introduce "the dumbest smart pointer" so that analyzers can try to help here.
&gt; God, what have you been using? GCC 3.0? I was referring more to errors related to templates. For example, I recently used `std::bind` in and older codebase that was using boost (should have used `boost::bind`), and I got literally pages of indecipherable errors. My beef with C++ is that because this stuff is in the library and not the language, abstractions aren't really that abstracted. You still need to understand how they are implemented, and god help you because most of that code is completely unreadable. If I could understand how `bind` was implemented in libstdc++ then I could go work for RedHat and make a lot more money. Concepts are supposed to help here, but they aren't a panacea. Templates in C++ are being abused because they are more useful than originally anticipated, but the tooling has not caught up. As for glacial compile times, again, it's templates. Current code base I'm working on eats up 12GB of memory during compilation.
Anyone have a good example for both of these functions? I read the cppreference pages but having a hard time figuring out what and how they could be used for.
5 days before code::dive ~~and in the middle of the week~~, rip any chance of attending edit: that's wrong, code::dive is the one that's in the middle of a week. Maybe, then?
Why do they not operate on a string_view?
Thanks, I didn't notice. The 2017 compiler (in my installation) is version 19.10.25017 (and yes, it's not even a whole version number from 2015). I'll need to update that setup...
Then why aren't they templated on the iterator type?
AFAIK that wouldn't work for `to_chars()`, because `string_view` is immutable. It seems like it would have been possible to use iterators rather than raw `char*` pointers though, but this [doesn't seem to be discussed in the proposing paper](http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0067r2.html) -- am I missing an obvious reason why this would be a bad idea?
Fixed that.
I have no influence on when code::dive is. Most people will only have time to go to one event anyways...
I don't want to be a killjoy here, but... this sounds almost as hard as actually writing your own compiler. You want to compile C++ to C++, why you just don't cut the middle man, and write compiler that compiles C++ to assembly? OK, in your first case you don't have to write optimizers, so at least you got that. But this will be ridicously hard and error prone, even more than adding new standard support to existing compiler, and that isn't exactly easy task. And this will make debugging way harder. And what are the upsides? I cannot think of any situation where I can't use normal C++14 compiler, but I could use your transpiler. Maybe if I wanted to compile some files in C++14, and some in older standard...
That why the quotes ;) some languages are often called modern and mature, but in reality they are abominations.
You can have an iterator to `char` that isn't `char*` or `const char*`.
Class template (not "template class"), lambda expression, member function, operator overload, function object. All these are very basic in C++. Why don't you learn C++ first?
He seems to condone using C, yet his crappy C++ example code is also valid C. (Except using "cout" instead of "printf")
if `T` is unsigned integral type no matter what it'll be fine. If `T` is signed and of size int or larger 1. and 2. will lead to undefined behaviour if it overflows. If `T` is signed and smaller than int: 1. `b = a * a` in this expression `a` will be converted to `int` and then the result will be converted to `T` which is well defined if it the result fits in `T`, and implementation defined if the result of `a*a` is more than `std::numeric_limits&lt;T&gt;::max()` **not undefined**. 2. in `a *= a` the behaviour is undefined if it overflows, and well defined if it doesn't overflow.
Yep boost lockfree queues only accept types with trivial destructors, so basically no manually defined destructor. Apparently for correctness reasons, but I don't understand it all. I also don't understand why the others don't have this limitation and assumed it was enabling some kind of performance guarantee...
Will it introduce another serious bug like this? https://gcc.gnu.org/bugzilla/show_bug.cgi?id=79511
If I remember correctly, these guys had chosen raw text reports to ensure the data would not depend on an external viewer (I am not sure - we are talking about a project I worked in ten years ago). The specs for such things tend to change from project to project.
And todays Blogroll (No 96): https://meetingcpp.com/index.php/br/items/meeting-c-blogroll-96.html
When will GCC 7 be released?
I love GCC because in contrast to LLVM/Clang it does not requires 6GB of disk space and 7 hours to compile.
Give [Redhat](https://en.wikipedia.org/wiki/Red_Hat_Linux#Features) a ring, I'm sure they could do it [today](https://gcc.gnu.org/gcc-2.96.html)! :)
I thought I read somewhere, irc or discord, that clang was alot easier to compile? Maybe it was cross compiling.
[removed]
Video links seem to be broken
Thanks for the detailed explanation! 1, 2, 3 were pretty much exactly as I predicted. 4 I completely missed, good to know. The trick with question 2 is surprising. I agree that there are problems with the standard integers. but I don't expect them to ever be replaced. In most cases they are fine, often problems come from using types smaller than int, which most people don't do that often, when you do you just need to be careful. Thanks for this post, it was fun to try to figure this out.
Right, gotta fix that... But the embedded videos still work :)
What are your actual numbers for compilation time in the various cases?
By the way, if you want to play with the Modules TS implementation instead of the clang modules, you can do this (but don't expect to get something that is usable for a real project): std.io.cppm: module std.io; #include &lt;iostream&gt; #include &lt;fstream&gt; export namespace std {} ranges.cppm: module ranges; #include &lt;range/v3/all.hpp&gt; export namespace ranges {} main.cpp: import std.io; import ranges; using namespace ranges; int main() { for(auto i : view::iota(0) | view::take(10)) { std::cout &lt;&lt; i &lt;&lt; "\n"; } } Build with: clang++ -std=c++1z -fmodules-ts --precompile -o std.io.pcm std.io.cppm clang++ -std=c++1z -fmodules-ts --precompile -o ranges.pcm ranges.cppm clang++ -Wno-unused-command-line-argument -std=c++1z -fmodules-ts -fmodules-cache-path=. -o modules_test main.cpp 
CI isn't for pivoting nor scrums nor whipping things up. It's there so that you don't end up with Bob's old 386 in the corner running a copy of a compiler that was last saved on a set of floppies that got tossed two departmental moves ago. Once you have a good virtualized CI, you can expect it to run just the same on hardware 25 years from now. The canary test is the real thing, but hopefully you'll run such a test many times using a CFD code connected to dynamics code and heating code and a hardware simulator/emulator that will run all the CPUs, all the FPGAs and ASICS, emulate Earth-to-Probe communications, and so on. While I haven't deal with any probes, I have had similarly complex CI test systems set up for more down-to-Earth systems where we were quite sure that the device reaching the market will do exactly what we want it to do. CI doesn't imply agile at all, nor does a classical requirements-specs-code-tests traceability system preclude test-driven development.
You are probably right about this, except (I think): &gt; I suspect the main benefit is that the improvements you saw by using precompiled headers and mucking about with your header dependencies will be able to be achieved nearly for free with modules. Reducing header dependencies will always be a huge win, because that directly defines how many files need to be recompiled after modifying a header. Can modules help with that in any way? It would be great if modules allowed you to not recompile dependencies after modifying private members of a class. Or if you could hide template implementations without having to instantiate them in the source file.
I wasn't aware that these are separate implementations. Is there a way to compile dependencies automatically?
Rust is not tied to cargo; actually, for embedded development, it may be better to use alternatives (there is xargo), and of course if using an IDE you may never use cargo itself. Tutorials start with cargo because (1) it's shipped with the compiler by default, so is available and (2) it makes things easier. That's all. And I really wish I had a good package manager with C++; integrating dependencies (even when everyone is using CMake) is still quite painful.
Indeed; I've seen a number of Java puzzlers last year that churned my stomach :(
I don't know the exact case for the boost queue, but mpmc queues are full of races involving object lifetime that become a non-problem when creation/destructions actions are trivial. I believe the moodycamel queue bypasses the issue since it doesn't reuse queue segments until all readers have exited them and each segment only has one writer. Furthermore, from when I last looked multiple readers aren't competing for the same item in a CAS loop but instead use a fetch_add scheme to assign writers to queue spots ahead of time. A lot of implementations probably don't deal with this in any meaningful way and it's just user beware.
&gt; everywhere I look there is this Cult of C++ Hate Is it hate, or is it a desire for better tools? C++ gives me a level of control and performance, whilst still giving me high-level semantics, that few languages can match. Forget D/Go/Java/C#/..., their performance isn't sufficient. Forget C, it's too low-level for my needs. At the moment, there are only two languages I can see myself using: C++ now, Rust maybe at some point (its lack of non-type template parameters is too inhibiting right now for my domain). However, why should I settle for either of those? I don't hold either C++ or Rust as panaceas. I still wish for better. I still *dream* for better. And the first step toward this is to understand, and acknowledge, the pain points of using those languages: - in C++, the primary pain point is Undefined Behavior; not a month goes by without a somewhat mystifying crash (that's the price to pay for bleeding edge performance in C++), - in Rust, well, it's still lacking in the meta-programming department, and there's quite some ceremony regularly involved in getting the compiler to accept "correct" code. I don't *hate* either language (not like I hate Java, and I unfortunately regularly have to delve into it too...). I do wish they were better than they are, certainly.
&gt; (See: The "Rust ~~Evangelical~~ Evangelism Strike Force") FTFY. They even surreptitiously subvert [comic authors](http://www.readcomics.tv/batgirl-2016/chapter-8/10). Tss...
Not that I am aware of. I did not even manage to split a module into two files. However, it was just yesterday when I played with the Modules TS, so I cannot give a definitive answer. I ended up writing a Makefile which manages the dependencies for me. I was thinking about adding modules support to CMake by adding them as a language with the file extension `.cppm`, but I did not go through with it yet.
psl try 2 benchmark w.r.t against folly::MPMCQueue too
Umm, are you aware that Windows 10 comes with an Ubuntu subsystem? So you don't really need to have a binary for Windows, you can just use an Ubuntu 14 library. See [this video](https://www.youtube.com/watch?v=PLF5Y5BXD_g).
The original C++ preprocessors and compilers were written in C++, just the previous iteration of it.
In any decent dev team, you can. If they refuse to program in a non-insane manner, you let them find another job.
No, it was not fixed in one month, but in at least 10 months. https://gcc.gnu.org/bugzilla/show_bug.cgi?id=71107 
It's a lot easier to compile, but clang's installation is a bit heavier. The arch linux repository website lists the gcc installed size as &gt; Package Size: 29.5 MB &gt;Installed Size: 116.7 MB versus clangs' &gt; Package Size: 43.4 MB &gt;Installed Size: 237.3 MB It's not that much of a difference, but these sort of things tend to matter disproportionately to those who care about them at all. Most of the time I've found that gcc produces faster code, but clang is really quickly advancing. Their LTO seems to be top notch, and well documented, but I'm not sure that it's actually any better than gcc's. I'm sure that clang is better than gcc in some areas, but install size isn't one of them.
clang looks like it actually takes more dependencies, but I don't feel like spidering through them to find out the real number.
I was under the impression that compilers identify and track files with full-file include guard and don't even open them a second time.
Dude, it takes like 12 minutes to compile LLVM plus clang. And it requires like two commands.
Rather than magic strings, you should consider typeid hashes. You could probably come up with a typename-based hash as a constexpr, too. BTW, /r/Meowiavelli, a good use case would be for a dynamically loaded shared object that you can swap out.
You probably want to use a pointer, not a reference. While under the hood (from the ABI's perspective), pointers and references are the same, references have some important differences. One of the positive differences is that references are never null (they can be dangling, but that's different), so you don't need to check if they are valid. The downside is that you cannot rebind a reference. One of the consequences is for copy and move assignment operators: class A { public: A(int&amp; _n) : m_n(_n) {} A(const A&amp;) = default; A(A&amp;&amp;) = default; // unfortunetely, these "default" to being deleted. // It's a funny corner case in C++ where "= default" // in the header can lead to a deleted member, // but if it was out of line, it would be a compile error A&amp; operator=(const A&amp;) = default; A&amp; operator=(A&amp;&amp;) = default; private: int&amp; m_n; }; Aside from that, there isn't enough detail to really answer your question. I'd suggest you continue to play around with it on your own, and if you are still stuck, maybe try posting some code.
So it seems that you are storing a pointer to `MyString`, you need to dereference the pointer (you probably want to store the actual value, not a pointer in the class though). is &gt;&gt; *c.make_; is &gt;&gt; *c.model_;
!removehelp
If clang's implementation is like the one that was proposed for C++11, yes, it ought to, but it looks like it's extended to other languages, and that makes me nervous.
Doesn't that get taken care of by using a precompiled header?
Try that in an enterprise context where application features are Jira tickets assigned to developer pools of external contractors. There are a few Fortune 500 companies that work this way.
&gt; It would be great if modules allowed you to not recompile dependencies after modifying private members of a class. While I don't think this particular case is doable (this may change the size of the object, etc), generally, if the compiler produces identical pre-compiled representation, then a smart-enough build system could detect this (e.g., by comparing before/after hashes) and not trigger the recompilation of the dependent translation units. We could definitely do something like this in `build2`.
&gt; Making number parsers generic on the sequence type and/or character representation is "probably an open research problem?" If you don't care about speed you can already use `stringstream` and friends for all the cases you mention to write your own `slow_to_chars/slow_from_chars` implementations in 3 lines of code. But `from_chars/to_chars` are specified to be _fast_ (as in, as fast as libc), nobody has shown that an implementation for forward iterators over any char type can be as fast as libc. &gt; Better specify it now so it formally goes into C++17, then there's plenty of time for vendors to implement it. The standard standardizes "standard practice". That is, the code is written first, specified afterwards, to avoid specifying something that is impossible or very hard to implement (so that it makes it not worth it for implementations to be compliant). Since nobody has shown that the code you are asking for can actually be written... that is not going to happen. If you can shown an implementation that is competitive in performance with libc, and can abstract over the iterator type, write a small paper with a link to the implementation and send it. Everyone agrees that it would be better if we would have `from/to_chars` for other types than `char*`. The reason it isn't that way is that nobody has cared enough to propose it and show that it can be done. It is as simple as that.
Key type is template'd, so you can use other types than strings. I'm using std::unordered_map so you should be able to specialize for pre-calculated hashes.
Reminds me of the [AbstractSingletonProxyFactoryBean](https://docs.spring.io/spring/docs/2.5.x/javadoc-api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html). Convenient.
To give another perspective: I'm working on moving parts of CERN's software stack to use C++ modules and we currently have a project called [ROOT](https://github.com/root-project/root) with about 3 million LOC (of which are 75k LOC are in headers) compiling with modules enabled for most headers. With that the average compile time went down by about 30-40% with the current clang trunk. The time spent on getting included code into the AST of your current translation unit dropped by up to 90%. So the current clang implementation is quite fast, even though there are a few parts that can be optimized in the future, mainly the handling of template specializations and how sometimes modules are compiled multiple times because the compilation flags of the TU that is using them has changed (and there's probably tons of other things that I don't know about yet). Why your results are different can have tons of reasons: Maybe you're measuring wall time instead of CPU time and you just have one clang instance during `make` compiling all your modules. Maybe you have different compilation flags for so many TU that the modules implementation isn't sure if it can reuse existing modules and recompiles them. Or maybe your project is just not spending so much time on headers in the first place (e.g. because you have minimal headers and not a lot of templates). You could use -Rmodule-build to see when it builds modules. Also check out the cache folder if you have multiple versions of the same module floating around. In this case try to unify the compilation flags for your projects (e.g. don't have certain flags just in subsets of your project). There are also a bunch of good talks on youtube about this by rsmith who is the main dev. 
You suggest that compiler reuses some information when compiling different files? E.g. when both `a.cpp` and `b.cpp` include `header.h`, compiler can optimize parsing of `header.h`? I don't think so, because it would require it to store some state on HDD. Usually you use tools like `ccache` for that, but they don't read files AFAIK.
I assume you're saying if you uncomment the constexpr global variable the size explodes? Have you tried labeling it static or putting it in an anonymous namespace? Also in general it's legal to call constexpr functions at runtime, so I think the compiler has to generate them unless it's sure there's no runtime use in the current translation unit. Also if you use a constexpr function in a non-constexpr context I think the compiler is free to decide whether to evaluate it at compile time or runtime. Assuming it's just this one variable triggering it, you could try making an identity struct template -- templated on an integer and just has one static constexpr member which is the same integer. Then instead of setting the variable directly to the result of the constexpr function, set it to the result of the identity template applied to the function, so that you know 100% it runs at compile time. Edit: actually assuming you never want runtime use of these functions, why not wrap them in an anonymous namespace in the header?
I was thinking along the same lines as tending - operate on `integral_constant` like objects. Take a look at [boost::hana](http://www.boost.org/doc/libs/1_63_0/libs/hana/doc/html/index.html), and in particular how it handles [`integral_constant`](http://www.boost.org/doc/libs/1_63_0/libs/hana/doc/html/structboost_1_1hana_1_1integral__constant.html). It defines arithmetic operators that are constexpr and return other integral_constants. If you need the value at runtime, there are constexpr implicit conversion operators to the underlying types. If you REALLY want to make sure a computation only happens at compile-time, figure it out inside an unevaluated context such as `decltype`. E.g. using namespace boost::hana::literals; auto runtimeValue = decltype(42_c + 23_c)::value; Of course the expression inside the `decltype` can be an arbitrary constexpr function that works with `integral_constant`
Looks like you're right! https://gcc.gnu.org/onlinedocs/cppinternals/Guard-Macros.html
So I am just playing around with them again, here are a couple of things I noticed: - You can only have one interface file per module - or at least I wasn't able to split them. So you can have a module that has multiple `.cpp` internal files but only one file that exports symbols: $ clang++ -std=c++1z -fmodules-ts -fprebuilt-module-path=. --precompile -o mymodule.pcm mymodule.cppm meow.cppm clang-5.0: error: cannot specify -o when generating multiple output files $ clang++ -std=c++1z -fmodules-ts -fprebuilt-module-path=. --precompile mymodule.cppm meow.cppm &gt; mymodule.pcm clang-5.0: warning: argument unused during compilation: '-fprebuilt-module-path=.' [-Wunused-command-line-argument] $ clang++ -std=c++1z -fmodules-ts -fprebuilt-module-path=. -o modules_test main.cpp clang-5.0: warning: argument unused during compilation: '-fprebuilt-module-path=.' [-Wunused-command-line-argument] fatal error: error in backend: Invalid encoding clang-5.0: error: clang frontend command failed with exit code 70 (use -v to see invocation) clang version 5.0.0 (trunk 299783) Target: x86_64-unknown-linux-gnu Thread model: posix InstalledDir: /usr/bin clang-5.0: note: diagnostic msg: PLEASE submit a bug report to http://llvm.org/bugs/ and include the crash backtrace, preprocessed source, and associated run script. clang-5.0: note: diagnostic msg: Error generating preprocessed source(s). [gcc seems to be able to do that](https://gcc.gnu.org/wiki/C++ModulesFirstExec). Has anybody tried their modules branch yet? - I am not sure whether `export namespace foo {}` should export symbols in that namespace previously declared without `export`. I haven't looked into the proposal though. - The standard library is not modularized yet. At least VS 2017 offers interface files for the standard lib. - Obviously no tooling/build system support yet. I usually try to compile my code with two compilers minimum. But I can't just take the code and compile it with MSVC. - You have to make your source code incompatible with pre-modules compilers. You can use clang modules and remain backwards compatible (and libc++ ships with a modulemap). Not sure if I would want to do that with an experimental feature that is still a proposal for C++. PS: I am playing around with them right now and noticed that if I forget to import a module that is imported by another module, I get a nice error message: main.cpp:5:11: error: declaration of 'ranges' must be imported from module 'ranges' before it is required auto f = ranges::view::iota(42); ^ ModulesPlayground/ranges.cppm:4:18: note: previous declaration is here export namespace ranges ^ 1 error generated. That must be what a caveman feels like when he discovers electricity.
That's a bummer. Would be interesting to know what Clang devs think on this. BTW, neither does VC report imports with `/showIncludes`.
Decorating everything with constexpr won't do the trick. That's not how meta programming works. Functions are still functions, objects are still objects. Compiler may decide to optimize them away or not. You should use them as types, enums, template arguments... to force them to be evaluated in compile time.
Our windows setup for clang 3.9.1 is 2.9 gigs - albeit not comparable to Linux packages as it also has extras and docs also included :)
English is not my first language but... I have a really hard time understanding what you wrote. You should really pass over it and fix the typos, add missing words and rephrase some sentences.
Neither mine as you may have guessed. I tried to improve the README a bit, I don't know if I succeeded. Thanks for reading.
Many times copying the object you're operating on is not an option. I would say that if your callback outlives the object then there's unclear ownership and that needs to be fixed somehow.