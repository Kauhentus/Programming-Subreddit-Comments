I think that for task-based concurrency it is easier to use some of Actor Model implementations for C++: C++ Actor Framework, Just::Thread Pro, SObjectizer (note: I'm one of SObjectizer's developers). You can also look on FastFlow library.
Sounds very similar to my workflow. I use the CMakeLists.txt file enough so CLion can keep track of all the files and the refactoring and searching works. I usually have to deploy the code onto the server cluster before I can run anything meaningful anyway. I do run my unit tests via CLion, since they don't require any specialized environment. 
Well I prefer the more descriptive name. Short names are prone to clashes. But nothing stops you to shorten things for your project: namespace dmx = dynamix; // Party Up (Up in Here) #define MSG0 DYNAMIX_MESSAGE_0 // etc 
I'd rather have that stuff as non-members in a `std2::str` namespace, or something like that.
&gt; use_facet and friends would take a unique_ptr or similar Why?
Stable algos are more expensive, so in C++ you dont want users to pay for stability by default
My division and industry uses grid computing for HPC, which works pretty well for process based parallelism. It's unclear to me where HPX intends to sit in the world of parallelism and they do a poor job of conveying what it is and what distinguishes it from other projects on the website. What interests you about it? Not the first time I've seen it, I tend to take interest in trends too but this one looks a little half cooked to me.
Eclipse has been around for a long while, and was decent even 3-4 years ago, not sure before then.
Interested and will follow along
Not in my own code yet, but I think most of the tests are single-locality. The last time I checked if it built right I had no MPI at all present on the system.
[The docs on initialization](http://stellar.cct.lsu.edu/files/hpx-0.9.11/html/hpx/manual/applications.html) tells me that there's a few ways of spinning up the first HPX thread. You either: * include `&lt;hpx/hpx_main.hpp&gt;` to rename your `main()` to `hpx_main()` and sneak in its own `main()` that inits HPX for you; * define a `hpx_main()` and run either `hpx::start(..)` or `hpx_init(..)`. If you use `hpx::start` it will block until the HPX session is done, launching your `hpx_main` as a function in which you can use the API. If you use `hpx::init` the main thread will be left alone and your `hpx_main` will be run in a separate thread-of-execution. In this case, you may not use the HPX API in actual `main`, just `hpx_main`. The macro abuse is akin to what SDL used to do for hooking their initialization for the more amusing platforms, if you're familiar with that.
Then, wouldn't it make sense to copy the comments to the other-language file?
See /u/brakmic blog post: http://blog.brakmic.com/high-performance-computing-with-hpx/
&gt; poignant Surely you meant something like 'salient.'
Should I still be getting weird behavior from Intellisense? I get 'errors' reported from Intellisense which the compiler does not have. For instance, Intellisense reports: static constexpr uint32 uid32 = security::hash::fnv&lt;uint32&gt;("some_string"); for the prototype template &lt;usize N&gt; using cstring = const char(&amp;)[N]; template &lt;typename T, usize N&gt; static constexpr T fnv(cstring&lt;N&gt; constStr) as *function call must have a constant value in a constant expression*. This compiles fine under MSVC and under Clang. Intellisense also seems to have a lot of trouble with template variables... template &lt;typename T&gt; constexpr T _FnvOffsetBasis = 0; // I didn't want to initialize this at all, but MSVC requires it even though GCC doesn't template &lt;typename T&gt; constexpr T _FnvPrime = 0; // I didn't want to initialize this at all, but MSVC requires it even though GCC doesn't template&lt;&gt; constexpr uint32 _FnvOffsetBasis&lt;uint32&gt; = 0x811C9DC5_u32; template&lt;&gt; constexpr uint64 _FnvOffsetBasis&lt;uint64&gt; = 0xCBF29CE484222325_u64; template&lt;&gt; constexpr uint32 _FnvPrime&lt;uint32&gt; = 0x01000193_u32; template&lt;&gt; constexpr uint64 _FnvPrime&lt;uint64&gt; = 0x100000001B3_u64; Which throws the Intellisense errors: * *explicit specialization of variable "_fnv::_FnvOffsetBasis [with T=uint32]" must precede its first use ()* * *explicit specialization of variable "_fnv::_FnvOffsetBasis [with T=uint64]" must precede its first use ()* * *explicit specialization of variable "_fnv::_FnvPrime [with T=uint32]" must precede its first use ()* * *explicit specialization of variable "_fnv::_FnvPrime [with T=uint64]" must precede its first use ()* This, again, builds fine under MSVC, Clang, and GCC. It is annoying as it makes Intellisense less useful as a tool, and floods my error list.
Some kind of variadic template/function arguments was my first thought.
Perhaps something like this? https://github.com/chriskohlhoff/executors/blob/master/src/examples/executor/bank_account_9.cpp
Looks like they had a good teacher -- I've always felt it best to teach coding with examples and projects that provide feedback and motivation for the students, and graphics is certainly at the top of that list for most learners. Especially at that age. The code has a very straight forward "C in assembly" style, which is nice, especially as examples to learn from. When I get around to teaching my son assembly language (assuming he has the desire to learn it, of course), I may come back to this as a source of examples. 
There are also messy codebases with trash comments (sometimes with huge unfilled comment templates in each file) and lots of commented-out code. Then I just stop caring about what those people thought: leave that in the version control history and debug the actual code without the noise.
Had to search a bit for slides)
The proposal is here: https://isocpp.org/blog/2014/05/n4046 thread_pool: https://github.com/chriskohlhoff/executors/blob/master/include/experimental/thread_pool
Looks like you've found a constexpr bug and a variable template bug in EDG. (Variable templates in particular arrived at the last moment before release, and I was unable to enable STL support for them in time. I am currently blocked by VSO#232074 "EDG can't instantiate variadic variable templates" and VSO#232077 "EDG ICEs with default template arguments in variable templates".) I can file bugs in our internal database, if you send me self-contained repros. Here's an example, showing that C1XX (the usual MSVC compiler) works, while EDG doesn't, via an undocumented command-line option /BE: C:\Temp&gt;type meow.cpp template &lt;typename... Types&gt; struct count_types { static constexpr int value = sizeof...(Types); }; static_assert(count_types&lt;void, void, void&gt;::value == 3, "WOOF"); template &lt;typename... Types&gt; constexpr int count_types_v = count_types&lt;Types...&gt;::value; static_assert(count_types_v&lt;char, short, int, long&gt; == 4, "BOOM"); C:\Temp&gt;cl /EHsc /nologo /W4 /c meow.cpp meow.cpp C:\Temp&gt;cl /EHsc /nologo /W4 /c /BE meow.cpp meow.cpp "meow.cpp", line 7: error: expected a '&gt;' template &lt;typename... Types&gt; constexpr int count_types_v = count_types&lt;Types...&gt;::value; ^ detected during instantiation of "const int count_types_v [with Types=&lt;char, short, int, long&gt;]" at line 9 1 error detected in the compilation of 'meow.cpp'.
Shorter overview on Stack Overflow: [What are the new features in C++17](https://stackoverflow.com/questions/38060436/what-are-the-new-features-in-c17)
I'm disappointed that the source code information capturing and [P0205][1] (Allow seeding with std::random_device) didn't make it in to C++17. Also the multi-dimentional array_view/slicing stuff would have been nice. I'm glad the [`std::rand()` replacement][2] hasn't been adopted yet, since I think [Simplifying simple uses of &lt;random&gt;][3] is a better replacement. `std::optional` and `std::string_view` will of course be very nice. [1]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0205r0.html [2]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4531.html [3]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0347r0.html
They seem like a nice candidates for C++20
https://github.com/synesissoftware/FastFormat Very similar to fmt with very good performance...my choice!
But what is it? A library? Stand alone application? What does an application look like that uses it? What it supports is not a description of what it is. I work on a big monolithic application that we're looking to distribute over grid engine, with the pieces communicating using MPI. What would HPX offer us?
Maybe over the years I've converged to a workflow where I avoid, without realizing, the problems others are facing with it. Installing CDT being a problem could only be imaginable on Windows, since on Linux, you just download Eclipse for C/C++ developers and it just works without even "installing" it (you just unzip it.) It has no problems finding the compiler etc., it just works. You can get going in under a minute depending on your download speed. On Windows, it used to be a hassle to get it to find MinGW etc., but nowadays it just finds it as well. The only overhead is the fact that you have to install MinGW, but I think the time it takes to install MinGW AND Eclipse is a fraction of that of Visual Studio. As for the maze of menus/windows/tabs, every IDE takes time to get used to, I don't think Visual Studio is any less annoying in that department, BUT, I rarely ever deal with those menus anyway, I use CMake for build configuration, so my project is completely defined by my CMakeLists.txt. And CMake has a very nice Eclipse project generator. For me, the complexity of the UI is irrelevant, since I think it's ALWAYS a bad idea to depend on an IDE's built in build configuration regardless of how simple it might hypothetically be...
Non-`const` keys work just fine for `boost::multi_index_container&lt;&gt;, `boost::container::flat_map&lt;&gt;`, and `boost::container::flat_set&lt;&gt;` and I've yet to shoot myself in the foot. Imposing that the entire object be `const` just so maybe one field doesn't change is over-protective and unnecessary. TL;DR: I agree with the GP. :-]
Remember, Boost is not a library, it is a _collection_ of libraries – some of those have long compile times, _most_ don't. Boost.Multiprecision in particular has no noticeable compile-time overhead on my ageing system.
No mention of coroutines. Any idea?
Life would be so boring were we all to agree. :)
Or should I say, I *meant* to be talking, and phrased it incorrectly.
&gt; vector&lt;bool&gt; taken out and shot Honestly, I'm not sure that is thorough enough. It probably should be drawn and quartered first.
The logic in ICU seems to work well enough.
`std::rope` - i need this
This StackOverflow post explains modules effects on templates: http://stackoverflow.com/questions/11802807/will-modules-make-template-compilation-faster &gt; If the issue is not addressed, it is likely to become worse as the use of templates increases and more powerful declarative facilities (like concepts, contract programming, etc.) are added to the language. &gt; Modules address this issue by replacing the textual inclusion mechanism (whose processing time is roughly proportional to the amount of code included) by a precompiled module attachment mechanism (whose **processing time—when properly implemented— is roughly proportional to the number of imported declarations**). So modules, when finally implemented, will reduce load time by some amount, depending on how heavily you use templates in your code.
http://www.babysick.co.uk/wallpaper/babybel1024.jpg
Coroutines were voted into a TS, to get implementation and usage experience. VS already has an implementation, and clang is close. Try it out, tell us about the good, the bad, the ugly and help us to make an informed decision.
If I just grew up near Bjarne Stroustrups Tower everything would have been fine.
Cool. Edited :)
A valid program cannot have a null reference; an invalid program is of no interest to anyone.
I think, signed size_t is useful to calculate difference of the sizes.
The source is valid, however shortening the release cycle was just an on the idea which some (influential) people were thinking about at that time. In Oulo I heard less support for the idea, which does not necessarily mean that it was dropped, but I wouldn't be surprised if it was.
Too old for 2016
what about [p0202](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0202r1.html) - constexpr algorithms?
Well, considering that those 60MB would only page in when you touch the operation, you're fine. If you are in an embedded situation where you really do need to cut out all the unnecessary bits, I don't see that as being particularly hard with case conversions.
&gt; I think the answer that too many people are relying on them is not a very good reason. Backwards compatibility is a *very* good reason. Having multiple (incompatible) versions of the standard means fragmentation (smaller community), tool maintenance (companies would not want to upgrade), library incompatibilities, to name a few. &gt; I would propose to have some very progressive updates once in a while. No this is not a good idea. Changes for the sake of changes, to be hip, to get cool but broken features isn't helping, it's disturbance, not progress. Evolution is. 
well but assuming sizeof(size_t) is same as sizeof(signed size_t), the difference in sizes could be beyond capacity of signed size_t or am I wrong?
If helloworld.exe were 60 MB that would be bad. It isn't a runtime perf thing, it's a deployment size thing. Need the platform to do it to be practical so storage cost is amortized across programs.
Ah yes, the Nest of the Cute long long.
I don't see the SFINAE Fields?
On the one hand, I agree with a lot of people that the release isn't that huge compared to 11/14, but on the other, it's the middle of 2016, so I hope the committee can finalize 17 now and start focusing on the next version :) As soon as more work progresses on the other features, we'll get partial implementations in Clang/GCC/MSVC (shoutout to /u/STL for already being ahead of the curve on a lot of library parts). Also, for me, string_view can't get here soon enough.
It would be difficult with my format to demo a proposal that is not available for any compiler yet.
:(
Although this paper is a month old (pre-Oulu mailing), I didn't find a discussion about it in this sub and it wasn't referenced very often. It contains background information from its authors Matus Chochlik and Axel Naumann and **a lot** of examples for the current proposal [P0194r1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0194r1.html) which contains the most recent wording. Example code in the paper includes logging, enum value &lt;-&gt; string conversion and serialization. Although I'm not an experienced cpp programmer it looks pretty useful to me. At the moment there seems to be a lot of discussion whether to reflect typedefs or their underlying type. Can we nevertheless expect to see static reflection in a TS after some of the next meetings or is there still a very long way to go?
Oops, I should have realized that was you. Anyway, I agree. At least the paper has a good part of a sample implementation.
Thanks. I saw this thread but I thought this more recent paper was interesting because it contains a broader overview instead of just the wording. The blog entry linked in the older thread refers to this paper but it wasn't published back then.
I was thinking std::rope was a metaphorical joke... looking closer, though, it's not standard but GCC has an implementation. std::power not sure on.
It is true that there is a small overhead at function call boundaries when the function is not inlined. This overhead is small compared to the cost of the functional call, but it is there. But this also means that anything performance sensitive could be inlined to get the same performance benefit. 
Why not?
That's a little overly dogmatic to be useful. 
Draft author here. This is not formally submitted to the standard yet so don't expect it to appear in C++ anytime soon. For the record, the reason I haven't submitted it: * I didn't find a champion to present it to the standard committee. * Other group held me back for a more restrictive one (like [P0329R0](http://wg21.link/P0329R0)). * Richard Smith suggested a more powerful but also much complex model that is incompatible with this simple design. (like Concept v.s Concept-lite).
The design presented in the draft is easy to implement (experimental [implementation](https://github.com/jamboree/clang/tree/feature/designator) exists). However, I'm not sure if most people would be satisfied with this simple model, at least I know there're people who want to be more aggressive on this. For example, something like this is not possible in the current design: std::function&lt;void(int .a, int .b)&gt; f; f(.a = 1, .b = 2); this is a more powerful model suggested by Richard, but much complex.
This was a high-level observation of an overall performance improvement. We couldn't attribute the effect between inlining differences (potentially across compilation units) or other optimization techniques. Relative to what you've said, though, I had actually thought supporting exceptions was supposed to be 'free' in good implementations for execution that didn't actually throw or prepare to catch.
That would be an amazing feature to have added to C++! But unfortunately, it really feels like the language designers are completely out of touch with the needs of the people actually *using* the language every day to write real code. Instead of working on desperately needed features like designated initializers, unified function call syntax, auto parameters for functions, modules, concepts, etc ... they waste our time with UTF-8 character literals, attributes for namespaces and enumerators, and library support additions that we needed 20+ years ago (optional, any, filesystem, etc) but have since already written on our own =(
Anyone have a different link to this talk? The audio and video of this one is trash
The artist that made the map together with her, no longer has the same availability. http://cppcast.com/2016/04/elena-sagalaeva/
So do I. I'm the co-author of the paper on this. Unfortunately it wasn't ready for the 17 time frame
It's not in yet.
Just to clarify, while we were considering a 2-year cycle, we're sticking with 3 years for now. The committee parlance is "C++-Next".
Cool stuff. I've grown to really appreciate the direction that the Swift is heading with their API design guidance of [clarity at the call site](https://swift.org/documentation/api-design-guidelines/)
&gt; Note: Last time I mentioned that there was some thought of moving to a two-year cadence after C++17, but for now we’re staying with three years, so the next standard after C++17 will be C++20. That is sad. I was really hoping for 2-year cycle
Library-wise sure, but I'm not so sure language-wise.
Compile time strings would be very nice to have.
What happened to array_view? I'm also wondering why there isn't any usage of optional and string_view in the to_chars/from_chars functions, I would think that would be more ergonomic to at least have overloads that use that.
As far as I know, they are more like beta. They are experimental. They will be implemented and used, and with the feedback they might (or might not) change 
Another question I have is not really treated in the blog, but I've been wondering how the parallel algorithms work. I can write: std::vector&lt;double&gt; v(10'000'007, 0.5); double result = std::reduce(std::par, v.begin(), v.end()); after http://en.cppreference.com/w/cpp/algorithm/reduce with C++17. Previously I could write `tbb::parallel_reduce` but I had to use `tbb::task_scheduler_init init;` first to initialize the task scheduler. Where does the task scheduler get initialized in C++17 code?
&gt; I was under the impression that user code opening the std namespace is not allowed Users may specialize existing templates from namespace std. 
Regarding 2): &gt;There is also a new overload of insert that takes a node handle and inserts the node directly, without copying or moving it. For the unique containers, it returns a struct which contains the same information as the pair&lt;iterator, bool&gt; returned by the value insert, and also has a member which is a (typically empty) node handle which will preserve the node in the event that the insertion fails
&gt; including games, embedded, and real-time so three cases where command-line argument parsing isn't needed ? 
&gt; The STL now avoids using thread-safe "magic statics" except when absolutely necessary, improving codegen. We were curious about this one and hoping /u/STL might be able to explain. Was it a performance issue? How does one avoid using a magic static if it is the default behavior?
Is there any information on when this version will be released? Any indication as to when compilers will support it officially?
&gt;desperately needed features like .... unified function call syntax Oh give a fucking rest already, will you? C++ is **not** getting that toxic stupid idea. Go use D if you want that obfuscating shit.
This is the top-level comment for **meta** discussion. Reply here if you have questions or concerns about this post.
What would that last snippet mean? The class is implicitly templated on the type for that member? 
GCC 5.3 supports `void func(auto x)` in `-std=c++14`. Too bad Clang doesn't.
There are the languages people complain about and then there are the languages nobody uses.
isn't void fun(auto) already in c++14?
Herb Sutter describes the process in detail in his [trip report](https://herbsutter.com/2016/06/30/trip-report-summer-iso-c-standards-meeting-oulu/). tl;dr: the C++17 standard will be officially released in (late) 2017 (if everything works out as planned). We hope and expect to have the first compilers ready shortly after that (but I know of no official statements there). 
Edit: made example clearer, reduced verbosity. I haven't thought through in too much detail how or if it would work or not, but just like for functions (Concepts TS) and lambdas (generic lambdas), it would provide a way to use `auto` in place of the typical `template &lt;typename T&gt;` usage. So instead of: template &lt;typename T&gt; class MyClass { T x; public: MyClass(T _x) : x{_x} { } }; ... something like this, perhaps: class MyClass { auto x; // Type deduced by template constructor arguments. public: MyClass(auto _x) : x{_x} { } }; int main() { MyClass myClass(42); // MyClass::x deduced as int } Such a class would have to have it's types deduced by the arguments to the template constructor. I'm not sure how sound this suggestion is, but I think we may eventually see something of this form in a future C++ standard. C++23, perhaps? ¯\\\_(ツ)_/¯ 
Any idea why support for `void func(auto x)` is delayed? 
&gt; Richard Smith suggested a more powerful but also much complex model that is incompatible with this simple design. (like Concept v.s Concept-lite). Could you go more in depth about this suggested model by Richard? Otherwise a link or something else would be nice. Thanks :).
AFAIK C++14 introduced `auto` as parameters only for lambdas, `auto` as parameters for ordinary functions is part of Concepts TS and neither part of C++14 nor C++17.
Oh, it does! How curious. With `-pedantic` (which I use nearly always), GCC 6.1 says: error: ISO C++ forbids use of ‘auto’ in parameter declaration ... so I had assumed it was only available with `-fconcepts`. Looks like it successfully compiles if `-pedantic` is not given. Aren't abbreviated function templates part of the Concepts TS? Why is that enabled when the rest of Concepts features are not? Edit: From my brief research into this, it seems that GCC allows abbreviated function templates, yet does not enable features from the Concepts TS without the `-fconcepts` flag, which AFT's are a part of, so either this is a compiler bug or GCC is treating AFT's as something separate from Concepts. However, it still flags it as breaking ISO standard if `-pedantic` is given, so I'm not sure what they're thinking. Edit 2: Since `-pedantic` pretty much means, "I promise to strictly follow ISO C++ standard", if you're okay with not strictly following the ISO C++ standard, then I suppose why not? ¯\\\_(ツ)_/¯ 
It's a consequence of it being a part of Concepts proposal which didn't merge with C++17 but became a TS. AFAIK that happened because some people were not confident that all doubts and questions about Concepts were fully answered and didn't want to rush it out without much field experience.
A TS ("technical specification") isn't really a beta so much as it is for a chance to get more experience with a larger change to the IS ("international standard"). Having a feature defined in a TS lets compiler implementers prove that the feature is implementable and lets developers bang on those implementations to make sure it's a feature we really want to adopt. That said, getting into a TS can seem like it's as much work as getting into the IS :) Here's a great overview of the process: https://isocpp.org/std/the-life-of-an-iso-proposal As for the 2 and 3 year cycle question, my personal opinion is that 3 years is right. We've already started a cadence with 11 and 14 and now 17. And it takes a long time to adopt the standard: we've just agreed on a CD, but probably won't have a final vote to adopt the IS until this time next year. There is pipelining--much of the committee is already looking at C++next (20?)--but the work of adopting an IS is always the priority. I think that three years is a decent period for the cycle.
is it possible to do Qt-style Variant Maps now with something like std::map&lt;whatever, std::any&gt;?
I have always assumed that this is indeed the intended use, and I can't come up with any other useful way to use it. So what was the *presumably intended* use of `std::tie` that OP wouldn't consider as abuse?
This one is not as focused on C++ practices as the other ones and didn't have much overlap, as it was more abstract in a way. Sean himself said at the beginning that this talk was prepared for a non-c++ audience from another conference and he later added some C++ for this specific presentation on C++ Now. Most of the talk revolves around what Sean defines as "Good Code" and dives into the properties he thinks Good Code must have, that being: * Good code is correct: Consistent, without contradictions * Good code has meaning: Correspondence to an entity, specified, defined * Good code is efficient: Maximum effect with minimum resources * Good code is reusable: Applicable to multiple problems, general in purpose While talking about each of this points Sean does point out things that he thinks are wrong in C++, such as reading from an partially formed `int` being allowed by the standard, and how he would change them. Overall I think it was a good talk to watch, as all of Sean's presentations, and would recommend if you have the free time.
Well, I think that std::tie is more useful when you compare values in a given order, e.g. in operator&lt;,== etc. For, this feels like abuse: bool b = false; std::map&lt;int,int&gt;::iterator it; std::tie(it,b) = mymap.insert(std::make_pair(23,42)); if(b) ... else ...
Cool! We are entering a new era of C++ :)
&gt; if (int a = b) Don't compilers (java?) warn when you use the assignment operator in a conditional expression? Now this is supposed to be okay?
Can you clarify what "whatever" should be? I'm unfamiliar with Qt/Variant Maps.
This could be possible with std::any. QVariant is only an any with a variant interface, std::variant you need to specify which types it can hold. Maybe a std::variant&lt;std::any&gt; ;) Also Qt uses copy on write, the standard will never do that. 
could you show me some example code to recreate that Qt code i posted, but in c++17?
D is not a successor of C++. It is more like a cross between C and Java. Everytime this discussion comes up, everyone forgets Ada. People, there is a better language than C++ which covers the exact same domain as C++ and it is called Ada!!! 
cool, can't wait for msvc to support this.
**Company:** Susquehanna International Group (aka SIG) **Type:** full-time **Description:** At SIG, we build some of the most powerful trading systems in the financial markets. Our developers work on low-latency applications that drive our trading. We focus on performance and optimization, while bringing our ideas into production quickly. **Location:** Philadelphia, PA **Remote:** No **Visa Sponsorship:** yes **Technologies:** We look for the best technology to build optimal solutions. We work with C++11 (Clang, GCC) C++14, Linux, Python, and high performance data structures, along with new technologies we investigate. **Contact:** Zanaya.wagner@sig.com [See how we use technology at SIG.](http://www.sig.com/technology/technology/?utm_source=reddit&amp;utm_medium=social&amp;utm_content=070516&amp;utm_campaign=technology_devcplus ) 
After playing a lot of Resident Evil, I'm hesitant to trust Ada.
&gt; there is a better language than C++ What's your definition of "better"?
So a TS is more going to be like a Release Candidate quality wise? 
No, that's the intended use. Also there's `std::ignore`, so if a function returns multiple values but you don't care about them all, then you don't need any declarations for the ones you don't care about. bool b; std::tie(std::ignore, b) = mymap.insert(std::make_pair(23, 42)); if (b) ... else ... I wouldn't call using `std::tie()` to implement comparisons as you describe an 'abuse', but as far as I can tell it wasn't an intended use. The two intended uses I find in the [related][2] [proposals][1] are returning multiple values and decomposing a tuple returned from a function. Also, the [boost documentation][3] on `tie()` indicates the same thing: &gt; A tuple unpacking operation like this is found for example in ML and Python. It is convenient when calling functions which return tuples. [1]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html [2]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2975.pdf [3]: http://www.boost.org/doc/libs/1_58_0/libs/tuple/doc/tuple_users_guide.html#tiers 
&gt;Can i code games, android programs or desktop programs? Yes, yes, and yes. Links to resources on what *could be done* with C++ would be **really broad**. What seems exciting to you?
[removed]
There isn't much you can't do with c++, it may not be the most comfortable option for some stuff, but you can do pretty much anything.
ah yes, i missed that distinction. thanks.
It appears as though you've not heard of `std::string` :)
i just figured out a simple way of doing this: struct Variant { bool boolean; int integer; std::string string; }; typedef std::map&lt;std::string, Variant&gt; VariantMap; int main() { VariantMap variantMap; variantMap["bool"].boolean = true; variantMap["int"].integer = 42; variantMap["string"].string = "foobar"; std::cout &lt;&lt; "bool " &lt;&lt; variantMap["bool"].boolean &lt;&lt; std::endl &lt;&lt; "int " &lt;&lt; variantMap["int"].integer &lt;&lt; std::endl &lt;&lt; "string " &lt;&lt; variantMap["string"].string &lt;&lt; std::endl; system("pause"); return 1; } though, i would like to know if there's any way to shorthand it to auto select a type member when referencing a map index (since only one of those members would be filled in per instance).
That's not a variant but a tuple. Use a union instead of a struct as a poor man's variant.
I know that but the problem is that i am using GNU libmicrohttpd for base http server. That is an implementation in c and most of its api accept only const char *. therefore for now i am sticking to it. But i hope that once the internals work all fine, i will be able to expose string directly for all api calls to internal engine :)
would you mind giving me an example? my attempt to use a union didn't work for me.
Java is "better" for Android, since Android was designed with Java-programmed apps in mind, and the tools are almost exclusively Java-based. If you want to use C++ for Android, you need to use Android NDK, which I'd say is not for the faint of heart. 
A lot of the examples are really contrived and don't reflect modern C++ style. Who uses raw `malloc` or macros for anything but class or function building? Just seems like another "I read Linus Torvalds rip on C++ and it sounded reasonable" even though that response was written well before the C++11 standard was gaining traction.
You can use any IDE you're comfortable with. Google "simple C++ game" or something similar to get started. For games in particular, **start simple**. If you try to make Pong or Tetris, you'll succeed and you can grow your ideas from there. If you try to make Mortal Kombat or Call of Duty, I promise you will get overwhelmed.
Company: Ubisoft Montréal Type: Full Time Description:We make games, opening is for a product used by game pipelines Location: Montréal, Bilingual team french / english Remote: No Visa Sponsorship: Yeah Technologies: Strong C++ skills, C++11, C# (not much) custom libs usage Contact: Ubisoft.com career or pm me, the opening are for my team 
Hi first thanks for taking the time and reviewing the code base. I am aware of asio although been a long time since i have used that. Let me brush that up and will try to move from mhd to asio. About macro , you said that benefits outweigh the costs? not sure if i get that, all the macro are evaluated at compile time so no apparent effect in execution of code-base so why to avoid the same ? 
In log[.h|.cc] you are declaring constructor and destructor but they are empty. Better leave the compiler do the job instead. 
http://www.boost.org/doc/libs/1_61_0/doc/html/variant.html#variant.motivation
**Company:** [TICRA](http://ticra.com/news/software-development-engineers-needed-our-interface-group) **Type:** full time **Description:** TICRA provides state-of-the-art highly accurate electromagnetic simulation software for reflector antennas and related feed systems primarily for use in satellite communication. We are looking for talented C++ programmers to create user interfaces, 3D-visualization and data presentation in our constantly evolving electromagnetic modeling and analysis applications. You will be part of a team of 5-6 interface developers. **Location:** Copenhagen, Denmark **Remote:** No **Visa Sponsorship:** Can be arranged. **Technologies:** We target 3 major platforms (Linux, Mac and Windows) and use latest tools (GCC, clang, Visual Studio, Jenkins CI, Squish). Knowledge of Qt and C++11 (and above) is required. Any experience with python, OpenGL, Open Cascade and/or multi-platform development is a big plus. **Contact:** [ej@ticra.com](ej@ticra.com) Do you like discussing about UI design details during lunch? Or geeking about C++17's *If and switch with initializer* at out Friday's study group? Or simply you like to admire the view of Copenhagen from the roof top? If any of the answers is yes, come and join us!
The cost is not in performance but in safety, maintainability, and debugability. Macros can do just about anything (since they are just text substitution), and they are not scoped. If somebody else decided to use HttpResponse for something else, they can't because your macro has polluted the namespace. Also, you do not need HttpResponse. Looking at your code, you are just returning the pointer you passed in after setting a resp member variable. Also, I can see no reason for request to be pointer and not a variable. A simple change that would get rid of your need for a macro would be this. In this example, I am using string instead of const char* struct request { // Bunch of stuff std::string resp; int respCode = 200; void reply(std::string r, int code = 200){ resp = std::move(r); respCode = 200; } }; Then you would change the code that processes stuff, to just look at the request that you passed in (as a reference) and not at the return value of the handler (which should be void). This means that your test case would look like this void hello(request&amp; req) { req.reply("Testing if macros are good"); } Here you have eliminated the macro while making your code just as easy to use. In addition, because you got rid of the macro, you no longer need to have any "magic" parameter names. However, I think you will want to do a whole redesign with boost asio. There is a lot of non-idiomatic C++ code that you have. Here is a little trick you can use to write idiomatic C++ code. Write your code without having any `new` or `delete` calls. You should be able to get pretty close to that if you write good modern C++. In addition, I think you will want to design your whole library to be async. You have a sync design baked in to how you handle requests. What if hello wanted to read from another website or database in generating the response? With a fully async design, you could do that without blocking a thread. Anyway, keep up the work. This is how you improve at any language - trying to make something and getting feedback. 
It is possible to use Qt (with QtQuick for the GUI) on Android pretty painlessly. Not sure the Android API support is as good from C++ as from Java if you need system integration though...
Look into SFML. It is a multimedia library for C++ which lends itself very nicely to making 2D games (3D also possible, but you will want to hold off on that as it's pretty advanced/tricky).
**Company**: Spondool Ltd **Type**: Full Time **Description**: 5+ years experience. Strong proficiency in C++ with thorough knowledge of the standard library. Familiarity and experience with templating in C++. Experience in the design and implementation of highly performant, scalable, distributed and resilient systems. We're putting together a small team to build filtering and content analysis software for a specific industry. **Location**: Dublin, Ireland **Remote**: Nope **Visa Sponsorship**: Sadly not at present **Technologies**: C++, Linux. Small team, new project open to suggestions. **Contact**: [scandox@gmail.com](scandox@gmail.com)
Most apps don't need much processing power. Others do. For those that need to really be concerned about battery, CPU, memory, etc...C++ is a good option. I program games on mobile and we use C++ for everything. Generally though you'd use C++ for the process intense stuff, or the long running thing *maybe*, and then the interface would be in Java.
Just looked at the GitHub source: in [variant_fwd.hpp](https://github.com/boostorg/variant/blob/f4b7d2e50c6433bc9e981ee8d44531a7ba928926/include/boost/variant/variant_fwd.hpp) there is a macro that conditionally expands to true variadics or a macro emulation up to a fixed limit
yes, but mostly in corner cases, like degenerate types. 99% of users should just be able to replace `boost::variant` with `std::variant` when it becomes available
Yes, they share the same interface. But gotta bug David Sankel more about this, the next time I see him :)
Interestingly, structured bindings is one of those features (like std::initializer_list) that blurs the line between language and library. Do any of you consider this to be inelegant?
Although this is clearly not the case in this code base, there are legitimate use cases for using plain const char\*. For instance for an API which expects to be mostly used with string literals. In that case it would be a waste of time wrapping an std::string around the literal every time. Also, std::ifstream c'tor takes a const char\*.
&gt; to me compile time is one of the biggest C++ problem today Did you try to move to a unity build? The idea is instead of compiling 1000 individual .cpp files, to #include all of them into a single .cpp file and compile that file instead. Compiling your code like saves 99% of the template instantiations that bog your compilation time. Instead of being instantiated in every translation unit, every template is instantiated exactly once. It also significantly reduces link time since it now has 1 object file where previously there were many. This kind of build doesn't fit every project and you might find it difficult or impossible to convert yours to it, but its worth a try. Some difficulties may arise if you have static functions with the same name in several .cpp files or in any other case where the code implicitly assumes it is in its own translation unit. 
They distinctly differ in the guarantees they offer, esp. default construction, empty vs. valueless, exception guarantees (during reassignment), performance and space overhead (with the `std::variant` allowing for better performance and less overhead) The interface will have slight deviations (most visibly on the empty state), but you can and should use boost until your implementation(s) provide `std::variant`. 
[Slides](https://github.com/boostcon/cppnow_presentations_2016/raw/master/00_tuesday/better_code.pdf). Report slide-viewing issues [here](https://github.com/boostcon/cppnow_presentations_2016/issues).
Okay, not to necro too much, but the slides are now living at https://github.com/boostcon/cppnow_presentations_2016 (although https://github.com/brycelelbach/cppnow_presentations_2016 is an exact mirror). A lot more slides have been uploaded, including the keynote. I should get the rest of the slides soon. Sorry for the delay, guys!
tell me more about std::visit, does it support lambdas &amp; chaining of them?
Holy crap, this is great. There's really opens my eyes on how much C++ can do. Thanks!
Somewhere in between. TS have very high requirements on (voting) process and wording. This means there has to be a great deal of polishing done (which would support the RC analogy). On the other hand the point of the TS is to test the Design of the features, so it is expected that there will be (sometimes significant) changes to the design. (which is closer to what betas do) 
Agree largely with what /u/FabioFracassi says. There's not really a quality correspondence between TS and product releases. You can have bugs in anything--implementation or design. And the implementation is separate from the actual TS wording. But a TS goes through a lot of vetting: discussion, review, voting, wording. So they are pretty well polished by the time they get implemented by the second vendor. 
Is there almost ready solution for now ?
I think it's a valid identifier in other languages too, it's just used for stuff you don't care about by convention.
Is just `std::variant` gonna be in 17 or have `std::optional` and/or `std::any` already been voted in previously?
Games absolutely do command-line processing. Both embedded and real-time do as well in my more limited experience there. It often isn't a human typing them in at a command line but rather puppet scripts and other automation and test suites, but still.
I really like this generally. It's along the lines of what I float on the isocpp mailing lists some time back. I'm glad someone else is thinking along the same lines, and then actually doing something with it. :)
Yeah, and for even more reason here. It is _very_ hard to see or explain why `MyClass` would have to live entirely in a header - function definitions and all - and not just be linked from a separate translation unit. That said, I think the concerns for both cases could be solved if we just added the requirement that any class or function using an auto-deduced member/parameter also use the template keyword, e.g. template void foo(auto x) { /*...*/ } template class MyClass { auto x; //... }; 
OCaml, F#, Rust.
&gt; What do you think's wrong with unified call syntax? It changes the meaning of existing programs, and that is completely unacceptable. In other words, you can take your working program, recompile it successfully, but end up with a program that does something different - because UCS results in a different resolution of a symbol in a function call. I like and enjoy new features. I desperately, desperately want to avoid creating new, perhaps invisible problems for no obvious reward. I would slightly have preferred that C++ had been created with UCS. But it's not a "desperately needed" feature by any means, and I'll lose that slight convenience in order to make sure that old C++ programs continue to have the same meaning.
We did – `auto [a, b] = foo();` and `auto const [a, b] = foo();` are valid C++17. It's 'structured bindings' in TFA.
Cool, thanks for the info!
Does the function signature have a syntax sugar for the return type too?
Wasn't aware you guys are in Pittsburgh. That's pretty neat.
Thanks for doing this! I start a new job next week, which I found through a previous posting here on r/cpp.
You can find his comments in this [thread](https://groups.google.com/a/isocpp.org/d/msg/std-proposals/gtGWEUtATU4/2dTt3Kk0BAAJ).
As of C++17, `return {5, "hello"};` finally works given an explicit tuple return type.
Both `std::optional` and `std::any` are in.
Provided you have access to the APIs you need, most languages can do whatever you want; albeit with different performance characteristics and ease of implementation. I think it is important to realize that what you can do with a language is generally not a feature of the language itself.
1. never would i have imagined that the maintainer of MS stdlib would be uttering /u/rectal_smasher_2000 2. a big shoutout to /u/4rt4 whose idea this was originally
Unity is a global company, it started with a bunch of people remotely working together. Their HQ is in Copenhagen. But they have some 7-8 other 'large' offices. They used to have a Boston office but that has been dissolved IIRC :(
Do you really need to look at four different source files at the same time ? 
Not applicable for the job since I'm not looking to move to Philadelphia, but please allow me to shamelessly plug my high-performance (~~BSD~~ MIT-licensed) [logging library](https://github.com/mattiasflodin/reckless). I think trading software is one area where it may make a difference. I'm not far from releasing a new version that I expect to improve performance even further, and also add Windows support.
What the hell are you on about? 
One thing that works fine is: variant&lt;A, B, C&gt; var; std::visit([](auto&amp;&amp; v) { using v_t = uncvref_t&lt;decltype(v)&gt;; constexpr if (Same&lt;v_t, A&gt;{}) { // do this; } else if (Same&lt;v_t, B&gt;{}) { // do that } else { // do this other thing } }, var); /u/meetingcpp what do you want to _exactly_ do with lambda chaining? Something like: `visit([](A a){...}, [](B b) {...}, var);`? Do you want it to work fine when C is convertible to B? Do you want this to produce an error when it isn't? Do you want it to be exhaustive? I'd rather have some exhaustive pattern-matching with destructuring than lambda chaining, what we want to write is neither the generic-lambda + constexpr if nor the lambda chaining, but something like match var { A a =&gt; { ...use a... } B(x, y) =&gt; { ... the x and y struct fields of B .... } _ =&gt; { ...do something else, like: __builtin_unreachable(); ... } } 
Working with boost::variant, you often would like to be able just to provide multiple lambdas as handlers for a visitor. Including [](auto v){} as the default case. Indeed in the combination with constexpr if this might be possible now. Yet its not a very pleasant solution I feel. Its also clear that pattern-matching would be more powerful, and would get rid of a lot of boilerplate one still needs to write. But that's never going to make it into C++17.
thank you! i'll look into it:) 
Why the heck would you decide on the `[]` brackets instead of `{}` for this? It makes no sense whatsoever. `[]` is used for array indexing. And `{}` for initialization...
Has the Bay Area always had 3 C++ meetups a month?
It is the only default behavior that makes sense. How would your hypothetical non-throwing system heap allocator return from constructors, destroy bases and members, or roll back transactions? Plenty of C++ users rely on this behavior (and yes, linux's overcommit policy is one of the first things to disable when deploying reliable software on that OS).
Ah. Thst makes sense, thanks.
no. AFAIK the east bay one is new. 
The big change on the std::tie side isn't that you don't have to type std::tie anymore, it's that you don't have to declare the variables before giving them to std::tie.
For libmicrohttpd you have 2 main options. 1. Use a cmake module file to find the microhttp paths on the system and use those when linking / including. See [here](https://cmake.org/Wiki/CMake:How_To_Find_Libraries) for details on how to find libraries. [Here's](https://github.com/ttroy50/cmake-examples/tree/master/01-basic/H-third-party-library) an example for finding boost . I can't see an official FindMicroHttp.cmake but I did find some examples [here](https://github.com/hlrs-vis/covise/blob/master/cmake/FindMicrohttpd.cmake) and [here](https://github.com/01org/IntelRackScaleArchitecture/blob/master/RSA-SW/PSME/cmake/FindMicrohttpd.cmake) from a quick search. 2. If you want to build a specific version that you include you might want to look into something like the cmake [external project](https://cmake.org/cmake/help/v3.0/module/ExternalProject.html) command. This can be used to download / build projects that use alternative build systems. You will end up with a target like `make microhttpd` that can be used to build it in a staging area and you can then include it by pointing to that path.
Anywhere, you can have multiple ones. See `scope(exit)` in D: https://dlang.org/spec/statement.html#ScopeGuardStatement Basically it works like destructors do in C++, but it's more explicit.
Holy mother of god. Well done.
How similar is this to Boost.MetaParse?
I'm not convinced a large percentage of users are relying on recovering from bad_alloc. Maybe some polling is in order, though. If the standard library is conditionally noexcept, then things will work fine if your allocator class potentially throws, and otherwise will be noexcept. The default allocator class would be noexcept, so you'd get noexcept behavior by default.
Btw, for some reason I thought that c++ `regex` is/going to be constexpr. Any reason it's not yet the case?
Two books: **Software Build Systems: Principles and Experience** by Peter Smith PhD et al. Link: https://amzn.com/0321717287 **Advanced C and C++ Compiling** by Milan Stevanovic Link: https://amzn.com/1430266678
Thank you.
We could cut out the middle man and copy-paste a complicated patronizing unhelpful answer right here!
There isn't any standard standard. `lib` usually has libraries of compiled code, either "shared libraries" or "static libraries". `bin` usually has the executable "binary" files - the final programs you run. `utils` means "stuff I have nowhere else to put". :-)
What's really funny about these two books is that neither of them discuss the one of the most important factors about building a c++ project, which is: Code layout! Roughly 300 pages each and not a single word on the topic.
If I remember correctly Gabriel Ros in one of the latest videos explained that all entities including template instantiations are owned by the module where they are defined. So for unique template parameter set only 1 instantiation will be created in owning module. This instantiation will then be shared with consuming modules and it will work like today's extern template. Check it out: https://channel9.msdn.com/Events/CPP/CppCon-2015/CPPConD02V014
If the project uses a version control system _(and it better does)_ then I check which files are often touched, and which ones were modified during the last month, this way I can focus my efforts to understand the project using those specific files, this will probably lead to false/positives though but it has helped me get on track most of the time. Additionally _(or if there is no VCS)_ I use a code analysis tool to visualize how are the connections between each files and the entire project.
I presumed that signed size_t was less capable than std::size_t to treat sizes. Like int and unsigned int.
Hopefully the project has unit tests Generally the components with the most rigorous unit tests are the ones that are both the simplest and most important components Otherwise, just find the main function(s) and follow the yellow brick road
I thought so, but when I noticed that it isn't then I decided try to write it as constexpr.
Run doxygen over it and enable it for uncommented functions and generation of UML. This way you can get calling / inheritance graphs between various classes to see how they interact. I've also heard good things about opengrok but haven't used it myself.
I am primarily an iOS and game dev. I work with IDEs which do all the work for me. You are correct, I am new to manual build systems. I'm looking for resources to wrap my head around the recommended structure.
I figured. Hence the books. They're not classics by any measure but they should help you get started.
- C++ language standard does not specify anything about file system layouts of the project. It hardly ever mentions 'files' at all. (I think only then `#include` directive is specified, and even then the rules how and where compiler searches for files remain implementation defined). There is no 'default' layout either. Every project is free to use any directory layout its developers consider convenient. So this is purely stylistic thing, like braces placement. - Given that, directory layout can be chosen according to a build system used. Again, there is neither 'standard' nor 'default' build system for C++. There are many build systems in use, like make, cmake, autotools, MS VC, etc. Some of them are completely flexible in regard to project layout, others encourage or enforce some structure, but there is no uniformity whatsoever. The key here is to know what build system this project uses and how the build process is set up. Look at the top level build system config file (for example, `Makefile`, `CMakeLists.txt` etc) and then follow what directories it uses. Also, it important to understand that there are 3 main kinds of directories: source directories, where the original source code (`.cpp`, `.hpp`, and any other) resides, intermediate directories (where intermediate build artifacts are placed, like object files `.o`) and output directories, where final executables and libraries are placed. - There are, however, several typical conventions, (like there several common code styles). For example, `include/` directory typically contains (public) headers of the project, `src/` cpp source files, `bin/` - executable files, `lib/` either compiled library files (dynamic or static), or source files for the libraries, `build/` - intermediate files generated in the build process. But remember these are not hard rules, and in the particular projects these names can have different meaning. Edit: my answer assumes that you are trying to understand the structure of some existing project. If you are going to lay out your own project, other comments here would serve you better. 
Does it cover C++17 though?
I personally use [GraphViz](http://www.graphviz.org/) but others will also recommend [Doxygen](http://www.doxygen.org). I used to work in a company that had a license for [Source Insight](http://www.sourceinsight.com/) and once I saw a co-worker using something called [SciTools — Understand™](https://scitools.com/). Hopefully one of these will look appealing to you. EDIT: Fixed malformed link to Doxygen.
It does not contain everything of C++17, since the text of the book has been finished a couple of months ago, so before C++17 was finalized. However, on a few places we mention a change that is coming in C++17 compared to what the text explains.
`[]` is also used by C++11 lambda expression to introduce *capture*s. `auto [a, b] = foo();` is similar to `[a,b]{}` in that - the types of `a` and `b` are not specified, and - the initializers of `a` and `b` are not specified. 
As a noob, can I just ask what are you doing in math.cpp with those symbol things? eg SYMBOL(E); Where symbol is defined as #define SYMBOL(x) struct x { static const char * identify() { return #x; } } What is that "#x" in the return ? 
This raises the question: why?
I've never been happier to have a "cpp" search engine that searches cppreference.com, so I can simply type `cpp&lt;space/tab&gt;vector` and go to a list of results on that website. Occasionally, it's unambiguous enough to go straight to the page (e.g., `iota`). ITT: There are a lot of docs programs.
`#x` is the preprocessor's stringizing operator. If you do `SYMBOL(E)`, `#x` is `"E"`.
Wow. I never realized there was an "export template" option in VS. When I read your title I thought you meant this: http://en.cppreference.com/w/cpp/keyword/export As this isn't really an /r/cpp question, please send me email or PM me with an email address. I'll ask your question inside of the MSVC team and I'm sure someone knows how to do this. My email is firstname.lastname@microsoft.com. 
[Dash](https://kapeli.com/dash)?
In general, a small C or C++ program will have the following: - src, containing the source of the project. This folder is *often* named something else - such as Sources, Implementation, libxyz, ... This is the stuff that's compiled and otherwise not distributed as source. - include, containing the files that you need to distribute as source to be able to use the library. They are typically headers but may include template implementation files or other similar things. - obj, which is where the sources get compiled to. Each source file corresponds to a single object file. - lib, which holds the assembled "library" of object files. This can either be literally an archive file - a static library - (.a or .lib) which just stores the object files, or it can be a shared library which combines the files to a single whole with a more explicit interface. - bin, which contains any executable variants that can be run. After you've compiled everything this should contain the stuff you want to copy to your system's installed binaries folders. When you install, you copy all binaries to /usr/bin, you copy all headers to /usr/include and you copy any libraries to /usr/lib. This also explains part of the names above - they're just a local folder for the same purpose as the global folder of the same name. This applies to any unix system. Windows, of course, is different.
Btw there is [Zeal](https://zealdocs.org/) which is an alternative for dash for linux
Why not simply slap `constexpr` on every moving part of a working runtime parser? At some point you'll have to reimplement some containers and algorithms to avoid dynamic memory allocation, but it should surely be easier than doing the whole exercise using template meta-programming.
Find some point of interest in the code, place a break point, write out a psuedo-code description of the stack trace. Function calls, important parameters, leave out edge cases and error handling. Similarly: find some interesting procedure in the code (ex: system initialization), write out a psuedo-code log of the interesting functions called in the process. Sometimes functions set up work to be completed later instead of linearly. I annotate that as "then later: Do Step2." And put, "later Step2: " as a separated log after the first. It doesn't take long doing that to have a readable map of interesting parts of the code.
&gt; auto [x,y,z] = f(); Yea, that's not really an argument for not making it `auto {x,y,z} = f();` I'd say it's not related or am I missing something?
Hmm ok... from my perspective, conceptually, captures are quite different though.
This has nothing to do with overloading. It's an introduced change in the interface of a function that happens to take optional arguments.
Perhaps `cppman` is worth a look: https://github.com/aitjcize/cppman
In the mention of expressions like `foobar(foo(), bar())` not having a defined order of evaluation, that's [been fixed](http://wg21.link/p0145) for C++17 Edit: Also, apparently this article was originally published in 2014, and was updated in some unspecified fashion in February 2016. So, it has an excuse for not mentioning the above. OP doesn't have an excuse for posting something so out of date.
&gt; In the mention of expressions like `foobar(foo(), bar())` not having a defined order of evaluation, that's [been fixed](http://wg21.link/p0145) for C++17 Chapter 8 in the linked paper was adopted, so `foo` and `bar` still have an undefined order of evaluation, they just must not be interleaved.
Right your are.
Did you check their webpages or test yourself? If latter I'd like to have test codes so that I can check Intel compiler.
**Company:** Optiver **Type:** Full time **Description:** At Optiver, a proprietary trading firm, we need the most advanced technology and continuous innovation to remain successful as a global market maker. We build high-performance software that is used by our own traders to trade a variety of financial instruments on exchanges. Our story begins in 1986, with a single trader on the floor of Amsterdam's options exchange. Today, we are at the forefront of trading and technology, employing around 950 Optiverians of 40 nationalities across offices on four continents. ****Jobs @ Optiver**** * [Graduate Software Developer](http://www.optiver.com/amsterdam/careers/job-vacancies/details/9281/Graduate-Software-Developer?utm_source=Reddit&amp;utm_medium=Jobposting&amp;utm_term=Graduate%20Software%20Developer%20Reddit&amp;utm_content=Textlink&amp;utm_campaign=Graduate%20Software%20Developer%20Reddit%20Posting#.VzC82IRcRBc) * [Software Developer](http://www.optiver.com/amsterdam/careers/job-vacancies/details/9101/Software-Developer?utm_source=Reddit&amp;utm_medium=Posting&amp;utm_term=Software%20Developer&amp;utm_content=textlink&amp;utm_campaign=Software%20Developer%20Reddit%20Posting#.VzC7-YRcRBc) **Location:** Amsterdam, Netherlands **Visa Sponsorship:** Yes **Remote:** No **Technologies:** C++14 on Linux, next to that C#, Python and Lua and FPGAs also form part of our technology stack. **Contact:** Please e-mail Jan Bernhart at recruitment@optiver.com for any questions. For more information about our jobs and events, click [here](http://www.optiver.com/amsterdam/careers/jobs-and-events?utm_source=Reddit&amp;utm_medium=Jobposting&amp;utm_term=Job%20overview&amp;utm_content=Textlink&amp;utm_campaign=Job%20overview%20Reddit%20posting).
This is actually a good idea, especially if the tests for a feature have varying "hardness", so that we can say something like "basic variadic templates work, but they break if combined with structured binding.".
What about library features? Some compiler/library pairs on some platforms don't support some features (e.g. GCC/Windows/threads or GCC/AndroidNDK/stoi). Or should that be another page, solely for standard library implementations?
Very nice list! Fingers crossed for operator.()!
How is fintech doing in Amsterdam? Can one hope for 6-figure salaries?
MSVC is green under "SFINAE" but range-v3 is not compiling yet, I thought they still missed some expression SFINAE stuff? Or was that something else?
This. In my experience, it's more important to let people work how they want than to enforce a particular style. There's very little gain from being overly consistent, but a large overhead. I do wonder where the idea that enforcing a consistent style is a good thing came from.
[hljs](https://highlightjs.org/) is the best I think. Yours seem to have some [issues](http://i.imgur.com/biD5ml8.png).
The status is that our Expression SFINAE support is Partial in Update 3, subject to a number of limitations. The support has improved considerably over time (the last I heard, Boost was able to start using it). In the Standard Library, `function` and `result_of` fully support SFINAE, as verified by exhaustive tests that I personally wrote. (This is possible because the STL needs only a fraction of full compiler support, and we're willing to use workarounds in our source code to sidestep the compiler's remaining limitations. There are currently two: I structured my invoke() implementation to avoid unnecessary Expression SFINAE via struct dispatch, and we use "unique tags" to work around a void_t/decltype limitation.) We also support all other mandated forms of SFINAE in the STL (e.g. allocator defaults, iterator_traits) with one exception: we have not yet implemented common_type SFINAE, which was a C++17 Library Issue that was voted in a while ago.
Everything I've filled in is based on documentation published by the various implementors - the supporting links are at the bottom of the page.
Thanks for the note. Updated as suggested.
Right now, those are in the same table. If you're feeling bold, splitting the library implementations off into their own table would probably be good.
Linus, is that you?
place .clangformat file in repository, gently nudge people to use clangformat. 
Finally something fresh. Small but fresh.
It [does](http://en.cppreference.com/w/cpp/utility/initializer_list) have the `begin` and `end` member functions, so you can use those with either a new-style for loop (`for (type value : collection)`) or an old-style one based on iterators instead of indices (`for (ridiculously::long::type::name it = begin(list); it != end(list); ++it)`).
Because they're not really needed. You walk through all elements by using iterators. Ranged-for is an abstraction over iterators, but you can use them manually.
Generic code would use begin(), end() methods. What if you pass in a std::list into a generic function? It also does not have a .at(), .data() or operator[]. The code is only "universally" generic if it models its data access as a ForwardIterator type, since that is the most basic, AFAIK. If you really want to use those methods, why doesn't your function accept a std::vector? It will be constructed from the initialized_list from the call site.
IYAM `std::initializer_list` shouldn't exist and brace-init-list should be an expression of type `std::tuple&lt;...&gt;`. 
I don't think GraphViz on its own will do much for this. Doxygen together with GraphViz can be valuable. There's lots of commercial tools that may be helpful. One recently released which looks unusual is [Coatl](https://www.coati.io/). (I haven't tried it, but it looks interesting and relatively inexpensive.)
In VS2015 they caught up quite a bit in the C++ 1X standards so that not necessarily true anymore.
I don't think that is still the case. [C++ compiler support](http://en.cppreference.com/w/cpp/compiler_support)
I love it. If I had a complaint I'd say it's really heavy weight. 
I am not sure it is hated. Most C++ devs in my circles use it, and love it.
&gt; Typing can lag. Can't blame the compiler for an insufficient hardware setup. I've been on a self-built gaming rig for a few years and have never experienced typing lag. ;) Thanks for the insights, especially from someone on the inside of things!
Vectors and arrays have certain guarantees (random access), and initializer_list has a different set of guarantees (forward traversal). Whatever the standard doesn't prohibit, it allows - so your initializer_list could be abstracted away to a pure forward-iterator implementation based on some crazy formula. By adding random-access constraints, they would have limited what compiler implementers could do. Practically speaking, the implementation is likely to be identical to array&lt;&gt;, but the standard has provided the freedom to implement it as a generator or other construct.
They're fixing as much as they can without a full rewrite. A lot of the problem that prevents huge changes is backwards compatibility. That said, they are making huge strides. Look at what /u/STL brings here regularly
Wouldn't this be a problem porting between any two compilers since they all have different ways of handling things? Excuse me if I'm incorrect, since I've never done something like this.
I expected that, even though moving from gcc to clang was as easy as changing the command line. My problem was a large number of bugs in VS.
That. Thats why they are going to adapt Clang as a frontend.
Thinking this way is a telltale sign of an amateur. 
It does compile without it but i want to move away from QStringList to std::initializer_list&lt;&gt; because i think std::initializer_list&lt;&gt; were designed for what i wanted to do and that is to efficiently pass arbitrary number of objects of the same type to a function. Most general purpose containers like QStringList or std::vector can get the job done but they do it inefficiently since they heap allocate. In my use case,nothing is gained from increased efficiency. I just decided to do it to gain more knowledge and experience with modern C++. The QStringList overload is still there because there are [still](https://github.com/mhogomchungu/zuluCrypt/blob/a2f0d2ffb5f056671d6b39e7eed01195b90eeca9/zuluCrypt-gui/openvolume.cpp#L260) code paths that calls the API with a QStringList argument. 
&gt; The reduced mental overheard when reading code, ability to dive into other project's code more easily, and lack of discussion in reviews about formatting are the main benefits. This is the common argument, but is it really true? Maybe I am unique but I don't find I slow down when I come across legacy code written in a slightly different style. I'm not paralyzed by 3rd party code written in a completely different style. And I don't struggle to read the code when I start at a new company that is usually in some style I've never seen before. The vast majority of the time I spend trying to understand a piece of code when reading it is dedicated to understanding the entry and exit point and decoding what the loops are actually doing. The formatting offers very little help in this regard so I really do not see a benefit. Of course, the style needs to be readable, and should be consistent at least in a function and probably a whole file, but other than that I don't personally see a benefit to a project wide consistent style. 
Something is fundamentally wrong there then. I ported a similarly sized and quiet complex framework from windows-vs to linux-clang/gcc with almost no problems. In fact the only problems I encountered where that cl was too permissive in some cases. Care to list some of those compiler errors? 
I used Gaddis "starting out with &gt;&gt;&gt; C++" in school. No complaints.
It wasn't a global, but an element of enum class. I also had to put SDL include inside a namespace, because SDL included some windows headers that defined things like Rectangle.
&gt; I personally think it's the best IDE / Compiler combo out there, but some of the reasons I've heard: What other IDEs have you ever worked with? I do find it bloated indeed.
That has nothing to do with Visual Studio IDE or the compiler. That's the Win32 API stabbing you there. 
&gt; IMHO visual studio is a great debugger, clang is a great compiler. I like this sort of stance on things. I do enjoy debugging in Visual Studio. It makes things pretty easy.
&gt;Visual Studio is the industry standard for C++. Everyone complains about it because they all use it. **/s** Fixed that for you. If you weren't intending to make that first statement sarcastic, then I have no clue what world you're living in. EDIT: Wow. a lot of Microsofties around here don't accept reality. VS is used for some C++, but it is **not** the industry standard by any means. EDIT2: Downvoting me won't change reality. Microsoft **is** trying to turn over a new leaf and improve the garbage that was Visual C++, and now it isn't terrible, but Visual Studio **is not, and has never been** the industry standard for C++. For C#, yes, but not C++. That honor goes to GCC's g++ compiler. I like clang++ a lot better than g++, but *that doesn't make it the industry standard.* Intel's compiler collection has been the pinnacle of compiler technology for a long time, but even it isn't the industry standard. You lot are confusing.
You ported to gcc. gcc is good so it went well. The guy you're responding to ported to MSVC. 
As I expected it is only going to reduce compilation times for lazy code bases that include everything in the headers just because. That not only worsens compilation times but also makes the code harder to understand and fix since everything seems to depend on everything else. It is just lazy spaghetti code. 
Can you suggest a good guide to setting vim up for c/c++ on Windows? Seems to be a nightmare, although I'm still very new to vim in general.
You might want to try looking again. They have really turned a new leaf in the last few years. 
My fault for using the terms compiler and IDE interchangeably. They're entirely separate things, but I'm sure the rest of the people in this thread knew exactly what I meant.
I think I'd rather just have something that works off of libclang.
I agree with most of these points, but this doesn't address what I see as the real problem with visual studio: it's project/configuration/build management. It's way too complex for small projects, but still too inflexible for larger ones. And it's loaded with confusing and Byzantine options with mysterious default values. And it's preferred method for editing these things is through a GUI tool, which makes things like copying and saving configuration settings quite difficult. There are things i really like about visual studio, it has good refactoring tools, intellisense isn't that bad, and it's debugger is still the holy grail of all debuggers. But I dare not trust .sln and .proj files.
Worked in two game companies and a computer graphics company. They all use Visual Studio for C++ regardless if they use DirectX or OpenGL. The built in Visual Debugger for DirectX is pretty awesome as well. This is pretty much the first time I heard about this intense hatred from the C++ community.
Our project compiles cleanly with gcc 4, gcc 5, clang, and mingw-64 with basically zero work. I had one of my guys try to build it with VS a couple weeks ago, and he had to give up after just a few hours. First time the guy ever met an internal compiler error.
I bounced from IDE to IDE for years... stuck with Netbeans for C++ the longest. But CLion is the tits and the dog's bollocks.
"Industry standard" is meaningless. Of all the major compilers, it's the least (ISO) standards compliant and also the flakiest. And the omissions *are* significant; if you target multiple platforms it's always cl that's breaking on code the others cope with, and it holds you back from writing code using ISO standard C++ simply due to its shortcomings. And then you've got all the shortcomings of PE-COFF and the rest of the Windows platform on top of the language problems. It's "getting better" but it's still far behind GCC and clang.
ICEs are always bugs, by definition. Because the conditions required to reproduce them are extremely sensitive to the source code, we require self-contained test cases (preprocessed files + command lines are sufficient). Please submit them either through Microsoft Connect or the IDE's feedback tool.
That is incorrect. initializer_lists are guaranteed contiguous. Their begin/end are required to return raw pointers. Even vector and array are allowed to return (contiguous, random access) iterators of class type. Source: I am an STL maintainer. I am STL.
We would if we could extract a self-contained test case that doesn't basically include half our project. Sorry. If it's any consolation, Intel can't compile the code either. :)
I agree. That being said, it's not just a text editor. I feel like intellisense is pretty resource hungry.
&gt; Our legal department has agreements that your company and ours can sign Yes, but that's an awful lot of work on my end, and I'm unwilling to burn political capital on helping you fix your product. I know it's your baby, and you care about its quality a great deal. It's nothing personal. It's just more work than its worth for me. &gt; affecting your work. We just don't use VS, so it doesn't really affect our work. MinGW is weird, but basically fine.
&gt; They have really turned a new leaf I'm the last few years. Yes, in some ways they have. The people maintaining the C++ Standard Library distributed with Visual C++ -- and the STL in particular -- have been putting a priority on keeping the library current with the ANSI standards lately. And they've been quite successful with that. And good for them. But the people maintaining the compiler -- not so much. VC++ is still not quite C++**11** feature-complete, and very significant portions of C++14 are not there. Meanwhile, GCC has been C++11/14 feature-complete for over a year, and Clang has been for over 2.5 years.
Vim + libclang (via, I'm guessing YouCompleteMe?) has auto completion, and go to definition, and that's about all, the last I checked. It doesn't have find all references, searching types by name, inheritance hierarchies, call graphs, etc etc. And vim + libclang is simply indisputably slow for large projects. These projects all depend on clang to reparse your file right after you edit it for e.g. auto completion. But in a very large project, with many includes, leading to many transitive includes, parsing a leaf file can easily take multiple seconds. This is a lower bound on auto completion time. 
I remember doing the same thing after 2010 came out, except for me it was gcc's lack of lambdas and its poor standard library support. Lambda came soon after, but gcc sure dragged their heels bringing the standard library up to spec. Both gcc and visual studio had different priorities for adding C++11 support, and it was quite messy trying to be cross platform while still leveraging the new goodies. But times change, and while VS isn't 100% C++1* compatible, I haven't noticed it nearly as much as a few years ago. I'm sure library writers are still chomping at the bit for the missing features, but as more of a C++ end user, the VS team did a great job delivering the features I needed most first.
Which generation of Pi? If it isn't at least a Pi 2, the experience would be so terrible that you would probably gain nothing but a distinct hatred for it or Linux. The Pi 2 is tolerable, whereas a Pi 3 is actually a somewhat pleasant experience.
there are some clang-based solutions, you could try some
&gt; Yeah, I gave it a try for a while. CTags didn't quite cut it for me. I understand Clang integration has gotten better, but I dev primarily on Windows boxes and at the time Clang / LLVM on Windows just wasn't quite ready. I'd be willing it give it another go. I use clang base completion on quite a large 20+ years old project and it seems to work well enough. It's nowhere near perfect and yes, visual assist is better. But it's good enough in most cases. &gt; FWIW you can add Vim style key bindings to VS :-) I use VsVim when I have to deal with visual studio and it's better than nothing, but still, once you try more complex stuff, you quickly see how much is missing.
I haven't ever been at a company that didn't use VC++.
First time I've heard of it, too. I love VS as well.
Have you tried YouCompleteMe? It works pretty well for me.
My favorite comment in code reviews, when I see whitespace inconsistencies, is: "Space. The final frontier."
&gt; i think std::initializer_list&lt;&gt; were designed for what i wanted to do and that is to efficiently pass arbitrary number of objects of the same type to a function Efficiently? The elements are copy-initialized and cannot be moved from, so in many cases, no, not efficiently. At least with `std::array&lt;&gt;` or `std::vector&lt;&gt;` you can move from the elements.
not sure why you got downvotes because you've coded in sheltered environments that didn't care one bit for cross platform capability. Of course there's a lot of very good non ms locked in developers...
not surprised. recent versions of msvc can have wierdo behavior with constructors crashing for no apparent reason. Caused me more than a few headaches. And I myself use vim/elvis for coding. We're still stuck using jam for our builds, mostly because we set it up in the 90s and it works well enough for cross platfoem builds (within cygwin on windows). ssh server was a godsend for sanely working within windows.
cygwin is an easy way to get it. i would guess msys might get that for you too.
unit tests are superior to debuggers. i almost never run a debugger, i just drop in a test to try to break things. and debuggers are useless when it comes to multithreading, and debug code runs diferently from release as well. i only work in release mode on windows and only selectively compile individual source files debug under linux when i must.
&gt; mingw might bite you if you need to use some binary only libraries. Not allowed on our project. If we can't get a source license to the code, with permission to make changes, it doesn't make it in. We've gotten bitten in the ass by shitty third parties too many times, and we simply will not compromise our ability to update the build.
odroid c2 is noticeably superior to rpi3 for compilation tasks. emmc and native gigabit...
I was using cygwin with Babun for a while, but vim kept giving me trailing "\^M" errors when I opened it in Babun, and completion didn't cooperate with gvim. The constant library errors with clang format is what got me to try mingw without much luck so far 😕
None of those seem to be a replacement for CScope from what I'm skimming... or am I missing something?
You can compile with clang in visual studio. I usually run my debug build with msvc and release with clang. Reduces the cross compiler issues greatly.
They had a lot of distance to catch up, but they're getting there. I would give good odds that they'll be C++17 feature complete by the time the standard is formally published. And they've implemented some TS's that others haven't yet. From that point on, I expect they'll be able to keep pace with the standard's evolution.
Right, forgot that `std::initializer_list` wasn't added until C++11. For other containers, it's still used because not everybody has upgraded.
No - but my posts to our internal C++ mailing list were. Where do you think I spent all my time before reddit?
Ah, the pain of accidentally opening a file for whose extension VS is the default program. And then the long minutes of regret as you attempt to close the massive, sputtering thing while the fan spins up to max.
Seems similar to conan. Can you compare them?
This looks awesome. I'm currently using bower + cmake to manage my dependencies so I have a few questions: * Does it support zip and mercurial urls? I sometimes have dependencies in both. * How are dependencies of dependencies handled? * Will there be windows support in the future?
Also: * https://twitter.com/MalwareMinigun/status/692115113692762112 * https://twitter.com/MalwareMinigun/status/727544662051840000 
Maybe I don't fully understand the problem scope you are solving, but couldn't you achieve the same thing with git submodules? git submodule add git@github.com:philsquared/Catch.git lib/Catch git submodule init --update
msvc's workflow has an msvc way of doing things. doesn't work very nice with other platforms. not exactly sure what you mean by enterprise. my experience is with satellite systems, mass image processing, physics simulation, visualization, engineering/survey grade. in my experience game developers who work on desktop applications are sloppy as hell, especially when it comes to validation work, testing, simulation, etc. All those things help amazingly. These other folks you refernce typically only care about one platform and develop for that, they don't typically constantly ensure everything is constantly working. I never cross compile, i'm always on bare metal working on the native platform itself.
The trouble with .*proj files as with all other generated source files is that they don't play nicely with version control and they're very hard to build abstractions over. Version control: It's very hard to diff and merge generated sources. You can't simply diff two repository revisions 6 months apart and see how your project configuration has changed. Abstraction: If you have 50 projects, and you notice some repeated pattern among them, there's nothing you can do to programmatically express that pattern unless you're lucky that an ad-hoc feature of the GUI editor happens to exactly fit that pattern.
Some of it was cool but it could've been significantly condensed.
.*proj files are in XML format; they are MSBuild files, and MSBuild is _very_ well documented. Your 'abstraction' part is thus nonsense, as you can take any part of an msbuild file and put it in a separate property sheet (which, incidentally, are managed with the Property Manager window, which I certainly assume any VC++ user is familiar with). The GUI is there for the simple shit; why would one assume the actual build system is so limited?
Looks like a defect. However, putting paths as keys in a hash table is almost certainly incorrect; you need to test for path equivalence in most such scenarios. That is, "/foo/bar/../baz" and "/foo/baz" are the same target but are not the same path. Similarly, "./bar" and "./bar" may be different paths, depending on the value of `current_path` in the first context vs. in the second. Edit: Related: [The File System is unpredictable](https://blogs.msdn.microsoft.com/jaredpar/2009/12/10/the-file-system-is-unpredictable/)
It's warranted because its comparing apples and oranges. While good unit testing is useful to reduce the number of instances when you need to debug something...you will eventually need to debug something. So once you get to the point of needing a debugger, all that unit testing is meaningless if you only have a shitty debugger to work with. The point about debugger being useless in a multithreading environment is also entirely incorrect. If anything, the visual studio debugger is pretty good at that.
Some of the issues they still have are due to lack of compiler support. cl was originally designed for an entirely different computing era -- when you couldn't load your entire AST into memory or write out giant files during compilation. It has inherited and maintains that legacy, which is part of the problem. As I am aware though, their compiler team is working on slowly untangling that mess and bringing cl into the 21st century fully so that it can support all these nice C++11 and above features. Considering that an effort like reworking the ~~backend~~frontend of a compiler is not cheap in cost or time, its very likely they'll see it through to the end. I fully expect cl to get better and better at keeping up with the standards over the next several years. Its slow coming, but its coming.
FYI, compiler terminology is that the frontend parses C++ (and builds an AST, hopefully) while the backend is responsible for codegen and optimizations. C1XX and Clang are frontends, C2 and LLVM are backends.
Well, a few of the big ones: 1. XML, it's icky. Hardly the most grevious sin, but a lot of the others stem from this. 2. It is incredibly verbose for 'small' projects. In my ideal world a very small project has a very small project file. This is not true with proj files wheer then umber of required fields is not astronomical, but pretty large. 3. They don't "read" well, when looking at a .proj file to figure out what it does there's no simple flow through it you can follow, you have to jump around quite a bit from place to place. Sure all the _related_ configuration options are near each-other, but that's the problem, things are grouped by similarity of type rather than following the structure of the project's modules or the flow of the build process. 4. Stemming from 2 and 3, it's just not very user friendly 5. And largely related to waht /u/enobayram has pointed out, it doesn't play nicely with other tools, weather it be version control or project similarity. Well documented or not it's a pain in the ass. So largely, I've just done similar to /u/Genocidicbunny. And everywhere i've worked with a functioning flow has too. sln/proj files are treaded only as intermediary files generated by some other tool which actually handles the versioned project data. I've used CMake for my own projects, which despite having a less than stellar reputation as to being understandable still feels miles better then sln/proj. (EDIT: oh, also only tangentially related to sln/proj, I also thing the whole build environment is terrible, though that may be a more Windows issue than Visual Studio)
Thanks! * If by zip url, you mean url to a zip file (http://site.com/library.zip), yes. It does support zip, tar, gz, bz2. If you mean something else, like urls to resources within a zip file, not officially, but you could probably make it work. * It currently does not support mercurial urls (feel free to open an issue though). * It has some support for dependency resolution – For example, we use curl with openssl. By specifying "dependencies: openssl" in our curl specification, Needy ensures that openssl is built and available before curl is built, so we can just pass the `--with-ssl=...` flag to curl. That's the extent of dependency dependencies so far. * Yes. It shouldn't take much effort and it's something I want to do *really* soon. (There's already an issue open for it.)
IDE versions have been: 8, 9, 10, 11, 12, (skipped 13) 14, 15. Branded versions: 2005, 2008, 2010, 2012, 2013, 2015, to be announced. So aside from Dev10 == VS 2010 where they lined up, the versions are not two-digit year abbreviations. Customers never, ever understand this, and I guess I can't blame them. If you look at my writings, I try to avoid referring to the IDE versions, and I've done so since 2012. (Sometimes it is difficult to avoid.) To make things more fun, the compiler has a separate, higher version number, as it predates the Visual in Visual C++. This is primarily visible through _MSC_VER.
I wanted to save a number of paths, some of which might be equivalent, in the same unordered_set and iterate over them. Because path{"/usr/tst/../tst2"} == path{"/usr/tst2"} (since they're both absolute and resolve to the same file system object) if they were both included in the set I would be iterating over that path once. That was the desired effect.
&gt; That is, "/foo/bar/../baz" and "/foo/baz" are the same target but are not the same path. Similarly, "./bar" and "./bar" may be different paths, depending on the value of current_path in the first context vs. in the second. Isn't that what [`std::experimental::filesystem::canonical()`](http://en.cppreference.com/w/cpp/experimental/fs/canonical) is for?
Why use an LL(1) parser instead of a finite state automaton? Ease of implementation?
Ack, you are of course correct. I blame it on too much 4th of July revelry.
Sounds like you are yet to discover property sheets. They are great. Not perfect, but really great.
`canonical` can't fix the "filesystem is a race condition" problem. It's still better than nothing.
game dev here as well and I couldn't imagine using anything else. I guess different industries have different preferences.
Yeah - that's a great point. SLN/PROJ just feels clunky no matter what. Actually, I think they only work well for the smaller projects (assuming you're configuring through the GUI exclusively... I've never manually edited PROJ files unless updating my team's MS SDK samples...) Larger projects, I prefer some make-based approach, although that's still imperfect in my opinion.
I use :YcmCompleter GoToImprecise to go to definition, and it's always instant. It works about 95% of the time, and I had similar results with Intellisense. It's true that VS has way more features in code navigation. I'm lucky to be working with my own code only, so I don't need it as much. But there are also code browsing tools like Coati (https://www.coati.io/), which in turn leave VS way behind. But it's not even about speed of code navigation. Merely typing in VS has visible lag. How can you program in that?
No. You can go from `tuple&lt;T, T, T, ...&gt;` to `array&lt;T, n&gt;`, but you can't store values of multiple types in `array` (you can initialize structs with `= { x, y, z, ...}`, but you won't be able to do so with tuples and `std::initializer_list`). The `const T` is also broken because it inherits retardness of `std::initializer_list` - it doesn't work with move only types. `std::tuple` can replace them because I can use it with the main use case of `for_tuple(t, [&amp;](auto&amp;&amp; x){ cont.push_back(std::forward&lt;decltype(x)&gt;(x)); }`.
BUILD_ALL and ZERO_CHECK are CMake-isms. You can essentially pretend they don't exist. (To my extremely limited understanding, they're related to how CMake forces VS to rebuild the projects if `CMakeLists.txt` changes.) I hope the IDE gets native CMake support someday.
Have you ever worked on a large, consistent code base? I think there is a non trivial cost for the inconsistency; I notice it when I work with really old, pre-style-guide code. Hell, I notice it when reading Java, which has different rules. That said, I'm sure with practice the cost is lower, and maybe you're the exception. However, I think it's likely you underestimate how much we 'chunk' familiar information. I find it amazing how much easier it is to remember a name written in our alphabet than Cyrillic or Thai for example.
&gt; &gt; msvc's workflow has an msvc way of doing things. doesn't work very nice with other platforms. You can use Visual Studio as a frontend development tool with other compilers (like Clang or GCC) used in the backend for further testing upon deployment, which is common. &gt; not exactly sure what you mean by enterprise. Large business. You would be surprised how wide that term is, and how heavily VS is used. &gt; in my experience game developers who work on desktop applications are sloppy as hell, especially when it comes to validation work, testing, simulation, etc. All those things help amazingly. Game developers also have time schedules that would make you cry, though you don't have time to cry, as you're working 80+ hours a week and have time to eat, sleep, and work. &gt; These other folks you refernce typically only care about one platform and develop for that, they don't typically constantly ensure everything is constantly working. You're speaking for a lot of people. Game developers usually are developing for potentially multiple systems. There are plenty of people out there who write crossplatform code while primarily using VS. Just because *in your experience* people have not done so does not mean that people are incapable of doing it or are not doing it. &gt; I never cross compile, i'm always on bare metal working on the native platform itself. Good luck doing that on a PS3 or an Xbox 360. Or a mouse that happens to have a small microprocessor in it. And, if you're wondering why my tone is hostile, it's because you had the nerve to call me 'sheltered' because I commented on the fact that basically everywhere I've worked has used Visual Studio in some capacity. You're coming off as exceedingly arrogant. Ed: Removed some identifiable information.
The way I see it, the project files are a configuration format for the ide. I'm still using them for that purpose.
&gt; Than there's the dreaded MFC, which even Microsoft didn't use for its own code. Wait, really? Care to give a quick history lesson?
While I encourage my devs to use a pre-commit hook (or ide plugin). Whitespace style gets enforced by running clang format on the server side. We also do some naming convention style checks using clang tidy.
I'm sorry, I'm not able to maintain a civilized discussion with you.
Spouting nonsense you _evidently_ know nothing about is not a 'discussion' to begin with.
I'm not that bothered by the size of visual studio, really. In an age where I can buy a 2tb hard drive for less than my monthly broadband subscription,... Even a 256GB SSD can be had for less than 70 pounds. It does install a lot of cruft though, and it's impossible to get rid of. 
I hate cmake. I am sure eclipse is doing something right when its client is 230 mb
I have two parsers in code ... one which parse expression with LL1 grammar and create output object which represent regular expression which is finite state automaton. I used LL1 because I needed to be able to deal with parentheses. 
Not to be that guy, but you just listed different versions of the same compiler three times and a compiler specifically constructed to be a drop-in replacement for the one you previously mentioned. I wouldn't expect many compatibility issues to arise between those use cases, even if you relied on undefined behavior in your codebase.
"Manually formating code is a huge waste in itself." Where I come from, we call that "typing". We type the code in. There's no way around it. I simply have to type it in. "You kind of provoking discussions about source formatting" I disagree. Here's how the discussion goes when someone new joins the team: "Is there an enforced coding style?" "No. You're a professional, just write sensibly formatted code that isn't hard to read. If anyone really finds it hard to follow, they'll say so, but it hasn't happened yet." Often, people choose to write new code similar in style to the code near it, but that's not mandated; it's because they're adults who understand that other people need to be able to read it. Just because we don't enforce something doesn't mean there has to be a discussion about it. I literally cannot remember the last time we had a discussion about coding style. We're all adults here; everyone knows that code is as much for a reviewer/maintainer to read as for the compiler to eat, and they act accordingly. I could certainly see, however, that if a team contains people who simply *cannot* just get on with it, and simply *must* have a coding style to adhere to, and not having one will mean you're constantly having to deal with a stream of complaints about four spaces vs. two spaces and how to name variables, I could see the argument for an exact, prescribed coding style if it meant getting them to shut up and stop wasting everyone's time.
Ctrl+F5 will run without debugging, but in general you don't want to do that. Visual Studio makes it super-easy to run your code under the debugger, and this is a good thing.
I'm pretty sure it says Team Explorer on the Git Integration because Visual Studio comes bundled with the Team Foundation Server version control, and Git was a more recent addition. 
Pretty much. I've had issues porting VS code to Clang as well.
I've been at many. How to determine the absolute truth from two isolated anecdotal data points? This is crazy, it's like anecdote isn't data.
Consider trying out MSYS2, it uses a port of pacman to manages packages. You can use it to install Qt Creator and basically every library you need (there might be a few missing though). You can install both GCC (Mingw-w64) and Clang, which have worked great for me on windows (Clang since 3.8).
&gt;Like what? Other than SFINAE, VS2015 is pretty... standard. Some SFINAE things (the "`void_t` trick" doesn't seem to work, or maybe I did something wrong), missing C++14 `constexpr`, but the one that I found most annoying has been missing NSDMIs for aggregates. 
I'm sure there are many other reasons, but one thing that always got me was that MFC is more of a "Wrapper of the C API in C++", meaning that yes, it uses classes - but it's not elegant and not what you'd call "good C++".
Try using it once, you will quickly see how horrible it is.
&gt; I personally think it's the best IDE / Compiler You forgot to mention the debugger. The VS debugger is lightyears ahead of anything else available on any platform. It is simply a joy to work with and I miss it dearly every time I have to work on something else. The editor however does have a few things it could learn from IntelliJ example.
What are you talking about? - https://msdn.microsoft.com/en-us/library/4yeh01cw(v=vs.90).aspx (from 2005)
Two phase lookup, variable templates, extended constexpr, C99 preprocessor and many small bugs
/u/RogerLeigh apparently meant two-phase lookup which is still not supported. 
Yes, if the calling code is constexpr, it'll have an easy time there. If looping over the whole tuple, it's easy as well. If passing one element to a function, it's technically possible to use a runtime index, but it's certainly not a thing that has caught on. 
I need to look into rtags. I see it has more features than Ycm. Do you know how the two compare in terms of speed and accuracy? 
I've never used YCM. I will say though that rtags auto completion takes virtually no time on top of what is required to parse the file, which is beyond the control of both rtags and YCM. In other words, YCM can only do better if it extensively leverages pre-compiled headers. I'm not sure whether or not it does this, was planning to try at some point. Other than auto completion and flycheck, everything is very fast. It is incredibly accurate. It parses your entire codebase, so when you do go to definition it's just a lookup into that. It basically never makes mistakes. It takes a bit of time to do the initial parse, but it's not bad. It's also trivially parallelized, so it scales well with # of cores. I index a large codebase with 20 cores in &lt; 5 minutes. The maintainer is also very responsive and nice. Overall I very highly recommend rtags. I'm using it with spacemacs which gives very good vim emulation. I'm not sure how the vim frontend for rtags is.
More so than the C Windows API it's wrapping?
I have to use vim too, I found that using a snippet plugin plus omnicppcomplete setup works on most versions of vim. It helps a lot more than vanilla vim, I just created a ctag file for stl and tags for a few of my most used libs and the project itself. With this there's decent intellisense and with snippets theres a decent productivity gain. Although I'm not good enough at vim to rival an ide.
Because I was clearly responding to a data request for a research paper and must have mistakenly replied with anecdotal data that I wasn't truly aware of the reliability of, and not just a post claiming that functionally nobody uses VC++ in the 'industry'.
I tried clang with Update 2, I think, and got some very basic compile errors, and google didn't help. I'll try again some time, it sounds like it might solve some of my problems.
I am developing my own 3d engine in Visual Studio 2015 and I love the debugging tools. For example i wrote a feature rich memory manager with bucket allocator, freelist allocator, frame allocator and so on. So while testing them I debugged a lot especially the so called watch is amazing, because you can write code in run time into the watch and see how the variable, pointer or what ever behave. Also the memory window helped me alot.
`void_t` works and the STL uses it extensively. However, you need a workaround in certain situations. `void_t&lt;SomeClass::NestedType&gt;` is fine, but `void_t&lt;decltype(EXPR)&gt;` needs a workaround, because the compiler currently can't distinguish the contents of decltypes. You need to define a unique tag type, then say `void_t&lt;UniqueTag, decltype(EXPR)&gt;`.
Our ClangCrew team (which I'm part of, making sure that Clang/C2 works with the STL) has been putting out releases every 6 weeks or so, continually improving things. We're still in a "preview" state, but things are much better. If you're seeing problems with Update 3 and the latest Clang/C2 release, please report them. Note that we are currently focused on compiling portable code.
A lot of it is history. MSVC++ used to be one of the worse C++ compilers on the market. It's still lacking in some important fundamentals that they've never fixed and probably never will--that make it fundamentally non-conformant. Intellisense used to bog down the system and get everything wrong. In the 2010 VS it got worse and would spin a bunch of new processes that sucked your system dry. They've improved it a great deal. They are also working hard to include important things like Clang integration. Most other IDE's are rather agnostic about what compiler you use. Historically VS has not been, but they're obviously improving that. Laying out a project in a non-flat higherarchy on disk is still a PITA. But the integrated debugger is still the best I've ever used. To really get into hard stuff you still need things like wdb (basically gdb but not as good) and other rarely used tools. For most work it does great though. Historically this has been the only feature VS had that made it worth using at all. Basically we have a couple decades at least of VS just sucking balls that a lot of us are used to bitching about it. People new to the industry don't have that experience and VS has improved so much that it probably seems weird that people would hate it. But if you'd worked back then with it you'd hate it too. The best thing that ever happened to VS was Herb Sutter.
&gt; Certainly I'd expect the standard library shipped with their next compiler to be 100% C++17 compliant. We **can't promise** this, but we're working on it. Specifically, I maintain spreadsheets of the C++17 features and library issues that we still need to implement. (We're down to a couple of C++14 library issues, too.) They voted in a whole bunch of stuff at Jacksonville and Oulu, so we need to play catch-up again. We're strongly prioritizing quality over quantity - I want everything we ship in the STL to be perfect, and I would much rather ship a few perfect features than many flaky features. Working from memory, the things that may take us longer to ship are the parallelism library, the special math functions, and the standardized Filesystem library (we have support for the TS, but I don't want to switch it over to the Standard namespace until we've fixed various bugs).
I'm not a VS user, but don't these always suck? What is it about VS that makes the problem worse?
&gt; I think "industry standard" is more meaningful than ISO compliant. I wouldn't call a tool that only works on a single OS, only targets a single OS, and fails on multiple levels to interact successfully with tools that cross those boundaries--"industry standard". The industry is a great deal larger than just Windows and games. And Windows profiling tools suck balls compared to what else is out there.
By being the only one that works on any of it. Even then...meh.
Updated comment to acknowledge you do now ship such a flag. And admittedly, most of my qualms are with MSVC2008 or before. Thing is, some platforms (WinXP, WinCE) that are still currently being used on production systems cannot be compiled for with a more recent compiler, which means that I'm still stuck in that hellhole of support. It's the reason we have 5 stdint.h's in our source tree - all five to compensate for MSVC2008's lack of one, subtly incompatible and causing ODRs.
Ada has packages?! But i see your point in terms of the C++ standard.
Ah, I see. Your comment didn't have anything to do with /u/muungwana's question. It was just a vaguely related off-hand comment. &gt;No. You can go from tuple&lt;T, T, T, ...&gt; to array&lt;T, n&gt;, but you can't store values of multiple types in array Oh, sure if you want to do that then tuple is the right data type to use, but when looking at the original question your comment didn't make much sense. &gt;The const T is also broken because it inherits retardness of std::initializer_list - it doesn't work with move only types. You're right, I didn't really think about this before you commented on it. Apparently initializer_list was designed ~2005 and move semantics ~2009. several papers have been submitted to try to resolve the issue, first with a specialized std::initializer_list, std::initializer_list&lt;T&amp;&amp;&gt; and then with a new type: std::own_initializer_list&lt;T&gt;. Sadly, AFAIK neither of these have been accepted into C++17. &gt;std::tuple can replace them because I can use it with the main use case of for_tuple(t, [&amp;](auto&amp;&amp; x){ cont.push_back(std::forward&lt;decltype(x)&gt;(x)); } I've tried using for_tuple, it's impressive, but it's not enough to fully replace initializer_list, you can't for example use tuple in any of &lt;algorithm&gt; because tuple doesn't have iterators. Even if all of the values have the same type you can't just try to get pointers to begin and end by using std::get&lt;0&gt; and std::get&lt;tuple_size&gt; because tuple isn't guaranteed to have such predictable data layout. So you'd just end up creating an array putting the data in there and using that, but then all the values have to be of the same type or convertible to the same data type, so in that case, why are you using tuple if all the types would have to be the same? &amp;nbsp; IMO Tuple offers flexibility in one place while removing it in another. They should both be used wherever appropriate.
Actually that's a MIT license
Office skipped 13 too. I don't pretend to understand upper management, and for all I know they're right. (It's not that we're superstitious, but customers might be.) The compiler, however, didn't skip 13. The 2002 compiler was 13.0, the 2003 compiler was 13.1, and the 2005 compiler was 14.0.
WinCE is special, but 2015 Update 3 supports targeting WinXP. In fact, supporting XP comes at a great cost, and is preventing us from doing awesome things in the Clause 30 threading library.
Always sucks but when you use and ide and you drag and drop things or the autocomplete make things appear you think that the ide understand what you want and will do it but no, when you compile you realize that all is a bullshit so dont let me do that things that later will make an error
Nvidia Nsight too
Oh, you're right. I thought the one thing while typing the other. Thanks.
**Company:** [Christie Digital](http://christiedigital.com) **Type:** Full-time **Description:** We make digital projectors based on DLP technology. But the real interesting stuff is projection mapping - taking a bunch of projectors and stitching them together to make a single canvas, and projecting onto screens, buildings, 3D models, [almost anything](https://www.youtube.com/playlist?list=PL7CBEC9E4CFDB1FD9). Basically, [we paint with light.](https://www.christiedigital.com/en-us/projection-mapping) We are looking for experienced C++ devs that like pixels and math, machine vision, machine learning,... But really, the most important thing is just _good coders_. Coders that can make abstractions and write clean code. I assume you can figure out the rest once you get here. **Location:** Kitchener-Waterloo, Ontario, [Canada](http://www.usnews.com/news/best-countries/quality-of-life-rankings) **Remote:** Unlikely. **Visa Sponsorship:** Unlikely. **Technologies:** We are currently mostly using C++11 under Windows. As we now have a member of the C++ committee on the team (that you get to work closely with!) we are pushing forward towards the latest standard. We also like Boost (of course - just got back from BoostCon!). And OpenGL and other 3D technologies and open source libraries. And I have to admit (sorry) - knowing Javascript wouldn't hurt either. Seems to always be a web angle somewhere. **Contact:** check out our [job postings](https://www.christiedigital.com/en-us/about-christie/careers/canadian-careers) and [apply online](https://apply.hrmdirect.com/resumedirect/ApplyOnline/Apply.aspx?req_id=enc-16.8087458939218087&amp;source=258482-CS-18236), and for bonus points, figure out the email address I use on the boost lists, and email me at that address (not the gmail address that matches my username here, that would be way too easy.)
FWIW, we're definitely improving with regards to Boost. We've been using popular libraries as a way to drive our conformance work. We've now gotten to the point where Boost no longer defines BOOST_NO_CXX14_VARIABLE_TEMPLATES or BOOST_NO_SFINAE_EXPR for MSVC. They should also stop defining BOOST_NO_CXX11_CONSTEXPR soon--it turns out there was a `constexpr` bug in Boost that MSVC was finding that GCC/Clang were not finding (no diagnostic is required, so all three compilers were doing the right thing. See 7.1.5p6 in the standard.) Here's the Boost mailing list mail on the subject. Note that it says they're turning off BOOST_NO_TWO_PHASE_NAME_LOOKUP but that's an error. /u/stl pointed out to them that it's still broken--the details are later in the thread. The Boost posting is here: http://article.gmane.org/gmane.comp.lib.boost.devel/268077 
Very nice, given that it is hard for some of us to argue to our managers that we need to time to create a complete test case for a compiler that is not central to our work/product it is good that the Visual Studio Compiler team has access to large open source C++ codebases such as Boost to go and use as examples. I wonder if clang or gcc might have tests for their compilers that could be of use as well. Probably the license could be a problem, but otherwise it is not uninteresting.
Given a `map&lt;string, vector&lt;int&gt;&gt;` with 100 keys, each with a vector that's 100 values big, I can, by hovering the mouse, tell you the 56th value of the 74th key in *literally* a split-second. Can gdb do that?
Well first of all, that it is able to read any values 100% of the time. When I'm debugging using Xcode or Android Studio, it often happens that lldb just can't access some value or another not no apparent reason. Another major point, specifically compared to Xcode is that it is lightning fast in almost anything. Some other features that come to mind - ability to format any value using a watch modifier. for instance "x,s" will display x as a null terminated string, "x,16" will display x as an array of 16 values of whatever x's type is - ability to write a custom watch formatter for any class. A language for specifiying these formatters has been around ever since VC6, although it has been redone from scratch in VS2010 I think. - little thing - you can just drag any text from the editor to the watch window. This feature alone saves me a small amount of mental burden perhaps a hundred times every day. - remote debugging - it just works, and the experience is 100% as if you're debugging locally. - symbolication - again, it just works. you don't need to worry about where's the symbols file. Also, the debugger can access an MS with all of the symbols files of all of Windows DLLs of any version ever. Also, when it doesn't work for some reason, the debugger gives you a detailed log of what it tried and what failed. it also gives you a chance to fix it on the fly and retry without restarting your execution. - ability to filter what exceptions are caught by the debugger. you can filter for a specific C++ exception class and a specific SEH code. - using the "gflags" tool you can attach a debugger whenever a process of some name starts and be able to debug it from its first instruction - The debugger can still work correctly even if the current source code doesn't match exactly the code that was compiled, and it warns you that it's not accurate - The MS CRT contains a rudimentary infrastructure for finding and pinpointing memory leaks. In many cases that's all you need and it's readily available with just a compiler switch - watch window pseudovariables - view GetLastError(), view the time from the last breakpoint, view the pid, tid, envars, command line EDIT - a few more - Nice UI for memory view. I realize this is something you can do in any debugger but it's always on the command line. In VS you can open as many as 4 memory views and watch them concurrently as you step though your code. You can also change the size of the word and column alignment easily and change the value of any byte in memory with a click. - Naming threads. You can add a one liner at the start of your thread code to give it a unique name in the debugger so you won't need to browse through tens of threads named "_beginthread()" before finding the one you need. - Interactive disassembler - again, gdb and lldb also has it but only in command line. In VS you can step thought and set breakpoints in assembly as if it was just regular code.
Oooohh! .... I get it now! 
&gt; I can, by hovering the mouse, tell you the 56th value of the 74th key in literally a split-second. Can gdb do that? not entirely sure how you would do that in msvc, but in qtcreator it is fairly straightforward: https://i.imgur.com/BR5Qp9X.png (edit: you get info when hovering with the mouse in the source code view as well, but that disappears when I launch the screenshot tool.) I haven't needed to do anything like that in "plain" gdb (I usually only do that when I do plain C, otherwise I use qtcreator), but "p testmap" dumps the entire contents of the map, but it can't seem to resolve the correct operators for it for some reason: (gdb) p testmap["1"] Cannot resolve function operator[] to any overloaded instance edit2: from elsewhere in this thread: https://www.reddit.com/r/cpp/comments/4r8n41/what_are_some_reasons_why_visual_studio_seems_so/d50k9gg
&gt; these days I use CLion on Mac and QtCreator on Linux Very curious about this. CLion and QtCreator both run cross platform, so how come you don't use one or the other?
Not quite as established as Charm++, there's also RaftLib (http://raftlib.io) which seems far more intuitive than all of these for me (although it seems to be in alpha stage). Feels like c++ streams, but we're really hooking together something like threads or processes. Initially found a reference to it on stackoverflow w/a hello world: http://stackoverflow.com/questions/15297755/c-library-to-build-up-execution-pipeline. One of authors gave a presentation at C++Now, watched from their website was decent. Wish they had more benchmarks to compare, found some blog posts...and tutorial. Not sure how it compares to Charm++ or HPX in terms of perf. 
Update to my previous: I finally decided to stop procrastinating and try YCM. It is indeed substantially faster than rtags for completion and flycheck. I don't know what exactly the trick is, maybe the precompiled preamble. Since they both run off of a compilation database and they excel at different things, I'm now using both together, best of both worlds.
`const` in the context of a function parameter definition just means the function won’t (shouldn’t) try to change it—the function just *sees* it as `const`. A non-`const` value can coerce to `const` for assignment or argument-passing, so (e.g.) a char * will happily turn into a `const char *`. (Ofc a `char **` won’t coerce to `const char **`, but it will to `char *const *`.)
FANNYPACK?
&gt; still lacking in some important fundamentals that they've never fixed and probably never will--that make it fundamentally non-conformant Like what? 
If all you want is to have the declaration opening on another tab you can just press F12 while the text cursor is on the symbol name. I find it even better than ctrl+click as I can jump to a declaration/definition pressing F12, look around using arrow keys and use ctrl+- to get back to where I was, all without touching the mouse at all.
It sucks when it comes to compliant compilers. They are getting better but if you have a C++ project it is best to look elsewhere for a modern compiler. 
You must realize that the non compliant compiler is a big issue, right? Let's face it they have had years, decades maybe to put a little effort into CPP. Now yes I understand things are getting better but the rest of the world hasn't come to a standstill. MS really needs to double up on C++ and get serious. As for IDE performance that is an issue for all of them be it XCode, Eclipse, EMACS or something else. Features cost you performance!! Given that it has been a long time since I've even looked at Visual Studio as frankly nothing interesting was happening there. I really doubt I will ever look at it again as MS has nothing I'm interested in programming wise. 
The problem is that if you really want to leverage property sheets, you need to hand edit them at the MSBuild level, and that is not well documented. The IDE is clunky for managing property sheets, having a slow and limited UI for connecting them. For instance, you have to bind property sheets to each configuration, and if they're out of order in one or more of the configurations, the UI for reordering them only allows you to move them one step at a time. I worked on a project that used property sheets extensively and the UI for managing the references became so painful we had to edit the .vcxproj files directly instead. At the MSBuild level, the property sheets are *much* more powerful, and you can do things like automatically dispatch to child property sheets based on current configuration. Problem is, the MSBuild framework itself is not that well documented, and the VC++ build framework built on top of it is, AFAIK, completely undocumented. Once you start getting down to the level of trying to create custom build rules that work correctly with dependency checking, incremental builds, and the compile single file command (Ctrl+F7), it's pretty rough. 
&gt; VC++ has spent a lot of its life cycle lagging far behind the C++ standard; every now and then it catches up, and then it lags far behind. It always bugged me each time Microsoft said they didn't have enough bandwidth each release to implement more of the standard, yet they found time to implement three full nonstandard variants of the language (Managed C++, C++/CLI, and then C++/CX). 
See link in my original comment.
&gt; invoke functions/methods/expressions Unfortunately this one is still a weak point in VS. You can do it but if it works or not is a crap shoot. Specifically, it will most certainly not work if the function your trying to call has more than one overload. &gt; I believe with gcc/clang debug symbols are built into the resulting binary when enabled Not for anything you'll ever want to deploy. Stripping the debug symbols to a separate file is a standard procedure in most gcc/clang build systems. A stripped executable of 30MB can have symbols data that is upwards of 1GB. You don't want to carry that 1GB around.
This [post](http://blog.llvm.org/2009/12/dreaded-two-phase-name-lookup.html) from 2009 seems to indicate that GCC didn't properly support two-phase lookup back then. That's the complaint against VS: improper support. It does sort-of support the feature, much like GCC did. Clang itself was only released in 2007. Since it's only 2016 now, decades must be hyperbole.
I'm not good at ELI5 and also not an expert at GP (I'm more of a user but I have yet to find a satisfactory implementation, hence my comment here), but [this link](http://mlss2011.comp.nus.edu.sg/uploads/Site/lect1gp.pdf) Slide 18 sums it up pretty well I guess.
I had to install these packages to run configure (Debian): libgflags-dev, libgoogle-glog-dev, autoconf, libswscale-dev, libfreetype6-dev, libpng12-dev Seems to match the list in your .md file. (Somehow missed it on first reading.) However, libgflags-dev does not supply any `pkg-config` literature, so this line in `./configure` will fail: `PKG_CHECK_MODULES(LIBGFLAGS, libgflags)` Adding `#` into that line and rerunning `./autogen.sh` made it possible to successfully run `./configure`. Compilation still fails though: g++ -std=gnu++11 -DPACKAGE_NAME=\"hiptext\" -DPACKAGE_TARNAME=\"hiptext\" -DPACKAGE_VERSION=\"0.2\" -DPACKAGE_STRING=\"hiptext\ 0.2\" -DPACKAGE_BUGREPORT=\"jtunney@gmail.com\" -DPACKAGE_URL=\"\" -DPACKAGE=\"hiptext\" -DVERSION=\"0.2\" -DHAVE_CXX11=1 -DHAVE_PTHREAD_PRIO_INHERIT=1 -DHAVE_PTHREAD=1 -DHAVE_LIBJPEG=1 -I. -Isrc -I/usr/include/x86_64-linux-gnu -I/usr/include/x86_64-linux-gnu -I/usr/include/x86_64-linux-gnu -I/usr/include/freetype2 -I/usr/include/libpng12 -I/usr/include/x86_64-linux-gnu -g -O2 -MT src/libhiptext_a-movie.o -MD -MP -MF src/.deps/libhiptext_a-movie.Tpo -c -o src/libhiptext_a-movie.o `test -f 'src/movie.cc' || echo './'`src/movie.cc src/movie.cc: In member function 'void Movie::PrepareRGB(int, int)': src/movie.cc:56:42: error: 'PIX_FMT_RGB24' was not declared in this scope width_, height_, PIX_FMT_RGB24, SWS_FAST_BILINEAR, ^ In file included from src/hiptext/graphic.h:10:0, from src/hiptext/movie.h:9, from src/movie.cc:4: src/movie.cc:64:38: error: 'avcodec_alloc_frame' was not declared in this scope CHECK(frame_ = avcodec_alloc_frame()); ^ src/movie.cc:66:19: warning: 'int avpicture_get_size(AVPixelFormat, int, int)' is deprecated [-Wdeprecated-declarations] int rgb_bytes = avpicture_get_size(PIX_FMT_RGB24, width_, height_); ^ In file included from /usr/include/x86_64-linux-gnu/libavformat/avformat.h:318:0, from src/movie.cc:10: /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h:4898:5: note: declared here int avpicture_get_size(enum AVPixelFormat pix_fmt, int width, int height); ^ src/movie.cc:66:19: warning: 'int avpicture_get_size(AVPixelFormat, int, int)' is deprecated [-Wdeprecated-declarations] int rgb_bytes = avpicture_get_size(PIX_FMT_RGB24, width_, height_); ^ In file included from /usr/include/x86_64-linux-gnu/libavformat/avformat.h:318:0, from src/movie.cc:10: /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h:4898:5: note: declared here int avpicture_get_size(enum AVPixelFormat pix_fmt, int width, int height); ^ src/movie.cc:69:14: warning: 'int avpicture_fill(AVPicture*, const uint8_t*, AVPixelFormat, int, int)' is deprecated [-Wdeprecated-declarations] int prep = avpicture_fill(reinterpret_cast&lt;AVPicture*&gt;(frame_rgb_), ^ In file included from /usr/include/x86_64-linux-gnu/libavformat/avformat.h:318:0, from src/movie.cc:10: /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h:4883:5: note: declared here int avpicture_fill(AVPicture *picture, const uint8_t *ptr, ^ src/movie.cc:69:14: warning: 'int avpicture_fill(AVPicture*, const uint8_t*, AVPixelFormat, int, int)' is deprecated [-Wdeprecated-declarations] int prep = avpicture_fill(reinterpret_cast&lt;AVPicture*&gt;(frame_rgb_), ^ In file included from /usr/include/x86_64-linux-gnu/libavformat/avformat.h:318:0, from src/movie.cc:10: /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h:4883:5: note: declared here int avpicture_fill(AVPicture *picture, const uint8_t *ptr, ^ src/movie.cc: In member function 'Graphic Movie::Next()': src/movie.cc:94:5: warning: 'void av_free_packet(AVPacket*)' is deprecated [-Wdeprecated-declarations] av_free_packet(&amp;packet); ^ In file included from /usr/include/x86_64-linux-gnu/libavformat/avformat.h:318:0, from src/movie.cc:10: /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h:4040:6: note: declared here void av_free_packet(AVPacket *pkt); ^ src/movie.cc:94:5: warning: 'void av_free_packet(AVPacket*)' is deprecated [-Wdeprecated-declarations] av_free_packet(&amp;packet); ^ In file included from /usr/include/x86_64-linux-gnu/libavformat/avformat.h:318:0, from src/movie.cc:10: /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h:4040:6: note: declared here void av_free_packet(AVPacket *pkt); ^ src/movie.cc:94:27: warning: 'void av_free_packet(AVPacket*)' is deprecated [-Wdeprecated-declarations] av_free_packet(&amp;packet); ^ In file included from /usr/include/x86_64-linux-gnu/libavformat/avformat.h:318:0, from src/movie.cc:10: /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h:4040:6: note: declared here void av_free_packet(AVPacket *pkt); ^ Makefile:1006: recipe for target 'src/libhiptext_a-movie.o' failed make: *** [src/libhiptext_a-movie.o] Error 1 I was just curious to see how this program performs in xterm, given that it seems to make certain assumptions about unicode and ttf fonts. I am using the `-misc-fixed-bold-r-normal--15-140-75-75-c-90-iso8859-15` font and `en_US.ISO-8859-15` locale.
Yes. Really.
I haven't shared the slowness on linux, but then I use oracle Java (but I appreciate that some aren't able, or don't want to, use it).
Reason for the implicit constructor: std::optional&lt;int&gt; do_the_thing(const int x) { if(x &lt; 0) return 0; if(x &gt; 2) return 1; // return std::none; this can be even simpler: return {}; } This looks simple; Consider writing the same code with an explicit `std::optional` constructor.
&gt; But each of these elements is actually a different kind of DerivedClass. No, that's not what you have. As soon as you added the elements to the vector — which you did by copying them into the container, or moving them, which is still a form of copying — they ceased to become instances of DerivedClass. When you made that copy, only the base portion was copied, because the destination of the copy is an instance of base, not an instance of derived. None of the derived-ness remains in the destination. You have a misunderstanding of how objects work if you expect a vector of base to be instances of derived. The only way to do that is to make a vector of pointers to base, or some other form of indirection. (I guess you could have also emplaced the elements in the container, but in that case there were never DerivedClass instances at any point in their life.) 
For libgflags you need to install from the github repo, that's what fixed it for me. libgflags-dev doesn't install a .pc file
MSVC is coming from a bad place with regards to standards conformance. We've made great improvements as of late and are hoping to be standards-compliant (completely) early next year. Some details are here, feel free to mail me for more. https://blogs.msdn.microsoft.com/vcblog/2016/06/07/compiler-improvements-in-vs-2015-update-3-rc/
Likewise, we are targeting full standards conformance in the compiler early next year. We've made a lot of improvements recently (e.g., https://blogs.msdn.microsoft.com/vcblog/2016/06/07/compiler-improvements-in-vs-2015-update-3-rc/) but we know we have more to do. So /u/millenix might not be smoking anything interesting :)
Our expression SFINAE support has been improving greatly (Cf. https://blogs.msdn.microsoft.com/vcblog/2016/06/07/expression-sfinae-improvements-in-vs-2015-update-3/). Boost recently removed their macro that turns off expression SFINAE for MSVC.
Neat.
Variable templates are supported in VS 2015 Update 3.
Sorry (shared directly from isocpp.org) here's the direct link: https://www.cevelop.com/2016/07/06/neon.html
I sympathize, /u/DragoonX6. Things should improve with the next version, VS "15". But yes, right now uninstall can be hairy. 
We've been working on CMake integration. If you have something to add--specific scenarios, odd requirements, especially around CI--let me know and we'll try to make sure to address them. 
Have you tried VS Code as a code editor? Linux/Mac OS support with lots of IntelliSense-like capability: https://blogs.msdn.microsoft.com/vcblog/2016/06/01/may-update-for-the-cc-extension-in-visual-studio-code/
You'd have to use a container of std::variant, std::any or pointers to avoid slicing. You can protect against doing this accidentally by making the copy constructor &amp; copy assignment protected members (assuming BaseClass is intended to be a base class that's never used directly).
Honestly, after using vim for so long I think it would take too long to get used to a different editor. I've already got a way to use clang-format in vim, and the fuzzy auto-complete in YCM is clang-based, so more accurate than the tag option VS Code offers. If I want to add tags, that would be trivial too.. I see no reason for switching at this time
I tried this and wanted to like it when it was first announced, but I bounced right off, because I had to solve a startup issue (it tried to use different than default Java, got confused) and I didn't like the UX. Has this improved/is there a short article about common use cases?
Try cleaning the solution 
Could someone give an opinion in how Qt creator holds up in comparison to CLion?
I've used both for small projects, although I have dug into CLion a lot more than Qt Creator. In the basic sense, they are very similar in terms of opening and building C++ CMake projects. They both have great support for a number of keybindings, quick editor actions, quick fix options, etc. Compiling is very much similar, debugging also is fairly similar (albeit, poor when compared to Visual Studio). I believe CLion pulls away a bit by being a lot more focused on being a C++ IDE and has much greater options for refactoring. Finally, CLion has a great plugin community.
Yeah, its hard timewise. I could say that if we used cl.exe for our product you could bet that we would be producing this stuff because we have some hard reliability demands. Itanium, how was it working with the instruction set. I heard a lot of mixed stuff, but not from an expert. Did it suffer from being too dependent on the compiler as the word of mouth was at the time?
how is it compared to JetBrain's Clion?
Also, probably not the case here, but if you are using buffered output, this could be the reason for messages not showing up in the console.
CLion is not free though and performs worse on large projects (last time I checked). Also it had very poor support for anything after C++11.
Love the CMake integration! Also, I started it up, created a MinGW compiler entry pointing the compiler path to g++.exe and the Debugger to gdb.exe from STLs distribution, selected the compiler in the kit and selected Ninja as CMake Generator (CMake and Ninja are in my path) Boom - everything works. Nice!
Alright, just disabled bitdefender and the problem is solved! Thanks!
Yes, and even though it doesn't directly apply to me, I'm very excited to see the increasing standards support from MSVC :-)
To add a breakpoint press f9 on a line where you want it, to hide it press f9 again.
Thanks. Over the next few weeks, I'll be setting up a new CI node with just the C++ Build Tools on, and I'll try to track down exactly what's not working here. I take it this should be sufficient to build common libraries such as Boost, Xerces-C++ etc.? Or are there any known issues with these? It may simply be that we're reliant upon the full VS install in some subtle way, and it will all just work once I've tweaked those bits.
The Itanium had every good idea in chip design since 1988 crammed into a single die. It was an insane chip. It was a compiler writer's dream and nightmare. A really good optimizer could write great code for the Itanium. Facilities like a sliding register stack combined with software pipelining made for incredible performance. But in the end, most of the "EPIC" parallel bundles had a few NOPs padding them out. It was really, really hard to write good code for the Itanium. We did pretty well, and Intel did well, of course, but it was hard. With another 10 years in the market it would have ruled. 
The Boost library should work well--we've been using that to get our expression SFINAE and `constexpr` in shape. I don't know if we've been using Xerces for anything. In my humble opinion the best way to parse XML is to scan directly for the closing tag and ignore the nasty middle bits :) If you find that you're missing something in the C++ Build Tools that you have in VS, please mail me so that I can investigate/fix it. Thank you! 
Right, and the reason I use these in C is exactly that I don't know the order in which the members appear in the struct's source code.
I would recommend all books from Scott Meyer, "effective C++" 
Perhaps class Interface { virtual ~Interface() = default; // ... }; class TypeA final : public Interface { //... }; class TypeB final : public Interface { //... }; class SliceCity { //... std::vector&lt;Interface*&gt; m_types; }; where the Interface pointers are owned by the vector would satisfy his requirements? I'd use a std::vector&lt;std::unique_ptr&lt;Interface&gt;&gt; which would cause a failure to compile until I deleted SliceCity's copy and assignment operators, but while I'm not actually very familiar with C++ pre-C++0x, I don't believe that would happen with owned raw pointers?
Overall less features, but **much** more responsive. 
&gt; poor when compared to Visual Studio what do you find to be better in the VS debug experience ? It's certainly a matter of habit but it makes me pull my hair when I have to use it...
I don't want to comment on Clion, but I am proud of the excellent device support we have in Creator. It manages to compile, deploy and run your qmake projects on Android, iOS, Linux devices and qnx out of the box. We even have a plugin to deploy via gdb to tiny devices without OS and just a couple of KiB of RAM. Creator also supports a wide range of different build systems incl. CMake, qmake, qbs and even autotools (experimental). It also supports a wide range of version control systems (all the free ones but also perforce and clear case), debuggers (gdb, lldb and cdb on Windows), and compilers (clang, gcc, mingw, mscv, icc on linux, a couple special ones for embedded development on qnx, android, etc.). Creator has support for drawing diagrams for a couple of releases now, which is rather cool if you need to wipe up some diagrams based on your code. And the locator (hit ctrl-K and just jump to classes, methods, help pages, files, ...) is something I can not do without anymore. And creator is of course free software (with a commercial option) under GPL.
this is going to be awesome! 
&gt; std::vector&lt;Interface*&gt; If you have this, you have a vector of pointers to objects of type Interface and NOT a vector of objects of type interface. If you copy this vector, there are no copy constructors (of Interface) involved, you will just copy the pointers. So it is different from the situation the OP described, hence my question. Further, if you use std::unique_ptr, you can no longer copy the vector, since you cannot copy unique_ptr (you can still move it). You could also use std::shared_ptr, then you can copy the vector and get correct memory management for free. But you would still get no copies of the underlying objects of type Interface. 
I want it, I have a branch with a working server, an extensible protocol with implementation, basic functionality to extract a lot of data from CMake and am trying to get that ready for review. Stephen and me had a discussion about the code and mostly agree on the ideas behind the implementation. Initial reception of the proposals I made to the CMake mailing list were positive: I think we agree on the big topics by now, but I expect a lot of small topics to pop up still. But all the initial set of changes to CMake core functionality are already merged and available in the master branch. The rest is almost completely self contained code for the server itself and related classes. Note that basically none of the things Stephen demoed are present at this time: From my point of view there is no reason to debug CMakeList.txt files in creator when creator does not know what exactly the project described by that CMakelists file contains:-) Everybody agrees that getting a minimal set of useful functionality in is what we should aim for at this time, so project structure (what is built out of which files using which compiler flags, etc.) is that minimal set. I currently do not yet feel up to the task of polishing all the enablers necessary inside CMake with the little exposure to the CMake code base. So those have to wait for that reason, too. I do hope to work with Stephen to get all his great work polished and production ready! https://github.com/hunger/CMake has my changes and a to-do list in the issues. Most important mailing list threads: http://public.kitware.com/pipermail/cmake-developers/2016-June/028545.html http://public.kitware.com/pipermail/cmake-developers/2016-June/028777.html 
Visual Studio is mostly hated because if you install it on a 7-year-old machine like the one I'm using right now, it's near-impossible to use due to sheer lag in ordinary typing. Visual Studio assumes, and always has, that you've got a modern computer with whatever the current going rate of the amount of RAM actually is. I started out on a laptop with 16Mb RAM and VS6 and it was more or less OK. In terms of feature set, not much has happened in the 15?20? years since then in terms of language features. All the advancements in working with code have happened thanks to R++, CLion and similar. The compiler I cannot complain much about. I [blogged](https://blog.jetbrains.com/rscpp/microsoft-cpp-compiler-bugs-ambiguities/) about compiler issues when I was back at JB, but honestly, as a user of the Intel C++ Compiler, I'm used to things which are a lot worse, because Intel is in no rush to get its compiler up to standards, and that's not the point anyway, at least it feels like it. VS Code is a good foray into making the IDE lightweight and usable, but it needs *a lot* more TLC before it can replace VS. And then there's the wealth of ecosystem solutions for VS, including the CUDA Toolkit, Intel Parallel Studio, and other platform-specific
https://groups.google.com/a/isocpp.org/d/topic/std-discussion/ko5ceM4szIE/discussion
The compilation errors arise from libavcodec though.
Yes :( this decision with the pkg-config ended up unfolding a lot of drama. I need to go back in and not rely on that. - https://github.com/jart/hiptext/issues/35#issuecomment-228422068 - https://github.com/gflags/gflags/issues/120 
As the sidebar advises, /r/cpp_questions is a better subreddit for beginners. Good luck in your studies, we've all been there.
Bother, you're right. `std::launder(arr[0] + 2)` would be OK though, no?
It shows as a red circle at the left edge of the line. Press F9 to add/remove. You can use the Breakpoints window to see all breakpoints. Accessible from the Debug menu &gt; Windows &gt; Breakpoints.
&gt; And the locator (hit ctrl-K and just jump to classes, methods, help pages, files, ...) is something I can not do without anymore. ctrl-K is THE IDE killer feature
Not sure I understood your issue well, but here goes: http://coliru.stacked-crooked.com/a/b307ba823be71e41
Nice answer. I was wondering if any of this build systems is more popular right now, and if I could find something close to Maven.
~~Can't compile its own "Hello, world" project out of the box. Pass.~~ You have to manually "Build all" once up front, and then subsequent debug/release runs will do an incremental build.
ctrl-K is great, but could definitely include a bit of the sublime text "fuzzy" matching where I spell a file in the opposite order or with wrong cases, etc...
&gt; I have about 1-2 weeks Here's an approach that might for work you: http://abstrusegoose.com/249
If you are worried about needing 1tb, why not 2tb 2 years later? and 4tb the 2 years after? I mean as much as everyone loves to mis-qoute Bill Gates on this - content sizes aren't growing like that and the performance gains trump the slight annoyance of only storing 200gb of media/games instead of 2tb so it is really not that big of a deal. 
What is wrong with kiss_fft? I've used it for a number of projects and it is pretty good in my opinion. Also it's complex variable type maps directly to `std::complex` which makes using it with the `std::complex` number functions pretty easy. Can't use a `valarray` though I don't think, but that is easy enough to work around. Also this is probably a better thing for /r/cpp_questions than here.
Whats wrong with FFTW?
well, math errors sounds like something like SIGFPE., and all abort()-calls are automatically catched by default. you can set breakpoints for javascript exceptions as well in qtcreator. but from that description it sounds like a bit of a nightmare of checkboxes.
You have your project like normal, you add a dll with the the autocomplete and all is fine until you compile it, it will say that the dll is unknow Or you change your classes draging and droping with the mouse, is very natural and normal but it will end with a link error saying that the .obj it cant be linked Or if you create another project in your solution the most probably thing is that you will have to touch the options because it will fail only where you compile, the autocomplete will access your classes like normal but it is an illusion, the linker will screw you up Normal things that you usually do and you have to fix with the linker options adding and modifing folders like it you were using cmake, i am using VS because i dont want to create my compilation file, there are no extreme cases, there are nothing fancy and it fails, in C# nothing of that happens, if the autocomplete works with the file all is good and ready to go so you should try to make like it, qtcreator works much better in that aspect that VS, if the tool can help you you wont have never a link error Feel free to ask more if you want
Well... the fact that those 20 years of experience are what marks your dev career and not what you've accomplished during those 20 years of experience might be the reason why. I don't intend to be overly rude, but, as the saying goes, there's 10 years of experience and 1 year of experience 10 times. I'm not saying you fall into either category, but you might give of the impression that you do...
I find it fairly straightforward to use, after using it a few times. Its defaults are sensible enough and finding the right exception isn't hard. And yeah, when I said math I meant several options, some for floating point errors, some for integer errors etc. Either way, the point of the thing is to be able to set breakpoints on events, not lines of code (in a similar vein, VS also allows breaking when memory addresses get accessed and predicating breakpoints on various conditions) so I find VS's breakpoints to be much more flexible. I believe QtCreator only allows breaking on lines of code, whether in JS or C++.
You don't need fold expressions to avoid recursion, you can use the aggregate initializer trick. See our `_For_each_tuple_element` for an example. It is essentially: int ignored[] = { (static_cast&lt;void&gt;(func( get&lt;Indices&gt;(forward&lt;Tpl&gt;(tuple)) )), 0)... }; (void)ignored;
&gt; ... my goal is to show one important aspect of `initializer_list`’s interface: its `begin()` and `end()` return raw pointers. "That can't be right," I said to myself. Then I looked it up. It's right. Seems a bit odd. The iterators for `std::vector`, `std::array`, and `std::basic_string` are not required to be pointers -- although they might be. Why are `std::initializer_list` iterators required to be pointers?
I gave an overview talk on this a while ago, existing cryptography libs: Botan, CrpytoPP and libsodium. Standardizing is not enough, you also need good and easy to use apis like libsodium shows. Also, this would have to happen with expertise, cryptographers are usually not also good C++ coders, but you'd need them for standardization. Time frame: at least 5 years, so C++23 earliest. Maybe one could start with hashes, and also support symmetric and asymmetric encryption. RSA &amp; AES are standardized, so the committee would 'only' have to come up with an API and things like enums for key length etc. But, there is much more in encryption, and I'm not sure if its a good thing to standardize things which will be weak to quantum computing attacks pretty soon after they are released. And the network proposal afaik does not include protocols currently, no http, only sockets based on asio.
tl;dr initializer_list elements are const, so initializer list constructors have to copy the elements. Wow, that's super dumb. There was a proposal years ago to fix this (N4166) but it didn't seem to go anywhere. This makes initializer lists effectively worthless.
You could have the compiler/stdlib to allow to link to an external library like openssl, for the sake of 'do not roll your own', although that would probably make a lot of trouble.
Seemingly "random" behavior is often caused by uninitialized stack variables.
Have you proven any of this cost in optimized code? The post is entirely on the level of C++ semantics, and does not talk about what it actually compiles this to, which is the important part in practice. Edit: The semantics level is important too, of course, and it can constrain the compiler. But does it?
I'd take the web route, books are expensive and out of date a year or so in the future (I'd post a picture of old Java/VHDL/Perl books stacked in the corner, but I'm sure you probably have one too). I've had similar questions from students/co-workers in the past. Here's the path I'd take: 1) I don't like the site as a reference, but it has a decent beginners tutorial: http://www.cplusplus.com/doc/tutorial/ there's also http://www.learncpp.com 2) I was going to list some other website, but check out the bottom of https://github.com/kenfox/learn-c-plus-plus/blob/master/README.md as it has many good references that I'd have listed 3) More decent references here: https://github.com/parnurzeal/learn-c-plusplus 4) Chat with other c++ folks here: http://chat.stackoverflow.com/rooms/10/loungec 5) The best cpp reference on the web: http://en.cppreference.com
In my opinion, initializer_list is essentially useless anyway. Most production code doesn't initialize dynamic containers like that. Sometimes you will initialize a static table like that, but for that we have a plain arrays, and even std::array, which can also use aggregate initialization. I fail to see the point of all the complexity initializer_list has added. 
Is there a particular reason not to use pkg-config for your library? Works with cmake. 
I haven't heard of it before.
I think you meant to reply to /u/quicknir, not me.
&gt; I believe QtCreator only allows breaking on lines of code, whether in JS or C++. no, it allows the same as vs. you can break on memory access on static addresses or addresses given by an arbitrary expression, syscalls, exceptions (thrown anywhere, js and c++), process forking, process starting, fatal()-calls, qWarning()-calls, qFatal()-calls, QML signal emission, exception catched, function names (not tied to any source file and line), etc. and you can give arbitrary conditions for each of those (like matching syscall number or whatever else you can come up with).
&gt; Whenever a list-initialization is requested, and compiler determines that it will use the initializer-list constructor for initialization, a temporary array is created, wherein **all the necessary elements are copy-constructed**. This has a couple of implications. It appears to be possible to "move construct" elements in std::initializer_list&lt;&gt; avoiding one copy constructor. struct foo { foo() { std::cout &lt;&lt; "default contructor" &lt;&lt; std::endl ; } foo( const foo&amp; ) { std::cout &lt;&lt; "copy contructor" &lt;&lt; std::endl ; } foo( foo&amp;&amp; ) { std::cout &lt;&lt; "move contructor" &lt;&lt; std::endl ; } foo&amp; operator=( const foo&amp; ) { std::cout &lt;&lt; "copy assignment operator" &lt;&lt; std::endl ; return *this ; } foo&amp; operator=( foo&amp;&amp; ) { std::cout &lt;&lt; "move assignment operator" &lt;&lt; std::endl ; return *this ; } }; With above struct: foo x ; auto l = { std::move( x ) } ; std::vector&lt; foo &gt; e = l ; produces: default contructor move contructor copy contructor 
Use intels libs e.g. mkl? Even the commercial license is reasonable. Performance is very good. It may not support valarray but in the past it did support packed IQ or separate IQ vectors. Id recommend you use this for other matrix etc vector operations on x86 and also the allocators in intels thread building blocks. If you are doing the same fft regularly, it is worth precalculating a 'plan' to get twiddle factors and data arrangement sorted e.g doing a convolution via fft, multiply, ifft.
Use sublime 
File bugs.
This. I use VAssist and Resharper C++ and you get nice syntax highlighting and a bag full of refactoring options.
It should say "copy initialized", which may invoke a move.
[Resharper?](https://www.jetbrains.com/resharper/)
 I spent a fair amount of time recently filling out detailed bug reports with the C++ compiler.. only to have them sit there with no response for 1 week. And then they vanished. No indication of what happened. Aggravating to say the least..
This. FUCKING THIS. UUUUUhhhhhh ghhhgrrrr. I've spent like whole day looking for a solution. It was just a antivirus software.
Well, it would be a bad overview if I only presented one library. I did this on purpose, also to have a feel which implementation I should use. So I don't see an indication for standardization in this. Well, first you'll need a secure RNG, which the standard currently does not offer. That's something that could go into C++20, when you have the ability to push it soon in a proposal. Then hashes, maybe RSA &amp; AES on top of that in C++23. But standardization is slow, and driven by volunteer work, so some one in the industry probably would have to push this.
Yeah, I need to spend some time reviewing the existing C++ offerings. Most of my experience is with C APIs like OpenSSL (shudder) and PKCS #11. It's entirely possible to standardize a set of cryptographic APIs that are independent of the underlying algorithms in use. The inputs and outputs for the various types of algorithms are pretty much the same as they've always been. It's the algorithms themselves and the size of said inputs and outputs that have change over time. On that front, I think all we'd want to do is standardize the identifiers for algorithms and leave which algorthms to support and when up to library implementers / providers.
Elias Daler here. Feel free to ask questions about Lua/C++ and game dev stuff. :)
Yeah, if you've used languages like Python or Javascript, you can see how useful initializer-list-like syntax can be. The way [mongodb](https://docs.mongodb.com/manual/crud/) uses object literals, for example, makes otherwise complex operations very readable. However, in my opinion, the main reason for using c++ is performance. So if a new c++ feature isn't as performant as the old "ugly" way, it's not worth using. That's why I'm hoping that proposal gets taken seriously, although it wouldn't be until C++2x.
Would have thought it was pretty famous. It's pretty easy to configure with a .pc file and with cmake you just call a built in function, I can look it up if you can't find it. It would work kind of like custom made find_package() for cmake, but I guess you can use these with autotools too. 
I don't think I have ever hard coded a map like this, and that's what I mean by useless. Sure, the syntax *is* nicer, but usually the data is coming from disk or otherwise, not hard coded. And even then, you've only saved one line because you could write it like this too; static std::array&lt;std::pair&lt;Key, Value&gt;, 2&gt; list = {{ {"key", "value"}, {"another key", "another value"}, }}; static std::unordered_map&lt;Key, Value&gt; map(list.begin(), list.end()); Furthermore, I could still use an array + lower_bound, since the data is static I can keep it sorted: static std::array&lt;std::pair&lt;Key, Value&gt;, 2&gt; list = {{ {"key", "value"}, {"another key", "another value"}, }}; assert(std::is_sorted(list.begin(), list.end())); return std::lower_bound(list.begin(), list.end(), std::pair&lt;Key, Value&gt;("key", ""))-&gt;second; 
Before 2015, VS was utter hell for C++. 2013 just started to be kind of usable, although it failed at lots of trivial C++11 constructs. 2015 covers a lot of C++11, with a few points missing because of historical reasons. I would recommend 2015 without an hesitation, it is good enough for most devs IMO. Advanced C++11 (and above) devs might be frustated by the few missing items, but even gcc and clang were in the same situation only a few years ago, and it's sometimes harder to get fresh Linux distro included recent ones than it's to update VS. (Although there are drawbacks in the other directions, obviously.) Edit: I'm concentrating on the compiler and libraries. I don't care much about the IDE. 
Couldn't one technically do: std::ignore = { void(func(get&lt;Indices&gt;(forward&lt;Tpl&gt;(tuple))), 0)... }; as well?
Observer, iterator, command and null object are the most widely useful imo.
I guess the question, is why do these *need* to be part of the language? Cryptography can be implemented externally and doesn't require any special compiler support.
cache coherency, naming things, and off by one errors
Moving implies you only need to do it once, and quite sure copying a hard coded list only once is not going to have impact in performance unless you should be using something far more advanced and probably uglier. I am a guy who loves performance but I don't care about anything that users will never notice. This is a good trade-off between performance and readability. 
I have been testing different compilers and have found it really depends on the particular compiler you use.
copying strings byte by byte, or even better, copying elements of vector one by one(invoking copy constructor in process) is O(n) operation, while pointer reassignment(literally all you have to do to move one vector to another) is O(1), so the bigger the vector/string, the bigger the difference
Some context would be useful - C with Classes was "good C++" when MFC was designed.
/u/frog_pow &amp; /u/Sunius: I'm responsible for the C++ compiler and I'm sorry your bugs disappeared or got stale. I really appreciate you taking the time to report bugs--especially given that you created a repro--and it's frustrating when I don't get to see them. First things first: using Connect is the right option. It works for tons of issues that get reported, etc., etc. **But feel free to send mail directly to me**, either with the bug or pointing to your Connect issue. There are two ways to do that: my email is Andrew.Pardoe at Microsoft (i.e., firstname.lastname@microsoft.com). But there's an email distribution list visualcpp at Microsoft that has me and a few others on it. That's probably the most robust option just in case I'm on vacation or otherwise distracted. Heck you can add both email addresses and I'll read it twice read it twice. (Not really. Exchange deduplicates.) Now for what might have happened. I'm not sure exactly how the Connect system works so I am speculating. I searched online and didn't find an explanation of the process. There are others on my team who know better (e.g., /u/stl has been working with the Connect folks to make things better) but here's my take on how it works right now. 1. You enter an issue in "Visual Studio and .NET Framework". 2. Someone in VS somewhere posts a note saying thanking you for the report and saying that we're looking at it. 3. The issue gets recorded as a bug in our tracking system--hopefully under C++. 4. Someone on our team sees the bug and either moves it to the right area on our team or handles it. 5. When the bug gets fixed the Connect issue gets resolved with a note to you. The process can break down or lag in step 3 or 4. Because you don't have a way to say "this is a Visual C++ bug" there's a necessarily latency while it gets triaged to our team. And when it does get to our team, the devs on our team who get the bug don't always remember to make a comment on the Connect issue. In short, thank you for reporting issues, we're sorry they got lost, I know we can do better. But I also know the VS people are working on improving Connect. In the short term, though, send me bugs directly: the visualcpp email is best. But there's also Reddit, Twitter (apardoe), shouting loudly in the direction of Bellevue, WA, US, whatever works for you. 
WRT to updating VS, you can also try out daily drops of the MSVC compiler pretty painlessly through NuGet: https://blogs.msdn.microsoft.com/vcblog/2016/04/26/stay-up-to-date-with-the-visual-c-tools-on-nuget/ 
Such as the lack of a parser that can enable us to do two-phase name lookup. But we're working on the new parser (cf., https://blogs.msdn.microsoft.com/vcblog/2015/09/25/rejuvenating-the-microsoft-cc-compiler/) and we expect to be fully standards-conformant early 2017.
Thanks, PMed.
I find it difficult to make compilers *not* elide copies when they are permitted to do so, even with optimizations disabled. With Clang I have to explicitly pass in the 'fno-ellide-constructors' flag.
That's awesome, and this means people can use all this goodness from VS Code. But for Visual Studio's problems to be resolved, it would have to be redone from the ground up, in 64 bits, without any of that WPF driven nonsense. And I'm pretty sure no-one at Microsoft is prepared to fully admit that VS needs to be re-done completely.
IIRC, CLion also relies on clang for parsing.
Hmm, I though I read it somewhere but after further investigation, I indeed found this not to be the case. (e.g. https://blog.jetbrains.com/clion/2015/08/clion-1-2-roadmap/ in the comments) My apologies for the misinformation.
Sure it is better than it use to be but the hate for this suite is due to history not the current almost there compiler. When someone asks about the current attitude towards Visual C++ you can help but to reflect on just how horrible that compiler has been in the past. 
std::valarray is not a very popular container, and I don't expect you can find any library working with it directly. You probably will have to write a simple wrapper anyway. So my advice would be to take any library and write a simple wrapper. If sizes of your fft's are known at compile time, you may want to have a look at [gfft](https://github.com/scpp/gfft) 
I think this went very well. Please look for an announcement for next weekend. Or visit http://www.slashslash.info/cppchat/ for the link and information on the joining the chat room.
Nice info, point taken. I feel your pain for m4 scripts, I try to completely avoid them and learn the least I need to port old code to cmake. 
Yeah, but that stuff is not "likely will never be fixed". :) It's being fixed!
Any code that the compiler accepts that is not allowed by the standard would be a bug. We intend to be standards conformant. In cases where existing code breaks, note that we may temporarily only break existing code when the developer opts in with a switch or some such. Microsoft is very keen on not breaking existing code. Having a developer base is a blessing and a curse. 
I'm not arguing that MSVC has a history--much of coming well before September 26, 2007. But your original statement was in the present tense :) Yes, OP's question does reflect on the past. But I'm going to be forward-looking and say that we're getting better, quickly. 
There was an interview with Anastasia from jetbrains on cppcast where she said that thr currently have something custom but might use clang for it later
I use Resharper C++ and Reshaper C# (resharper ultimate), the intellisense from MS isnt very good
I had a similar question. I got a reply in the programming sub: https://www.reddit.com/r/programming/comments/4rnrs3/an_interview_with_sean_parent/d53rfoq
Big O notation is only relevant when n is very large, and is only relevant when comparing different values of n. If you have enough elements hardcoded into an initializer list that big o complexity starts becoming an issue, you have bigger problems.
Do you use both at the same time? How did you configure it, so they don't interfere with each other? Manually configured all settings &amp; keyboard shortcuts?
Thanks Jon, enjoyed it very much :)
I'm gonna go out on a limb and say that we don't make serious breaking changes, regardless of whether It's a major version. Have you looked at the breaking changes lists for VS 2015? (https://msdn.microsoft.com/en-us/library/mt723604.aspx) It's a bunch of warnings off-by-default and PCH changes. We track breaking changes very carefully. Some say too carefully. But when it's your code that breaks, it's a different story. So no, (maybe) sadly, we probably will be sticking fixes like that under a switch or something. We have a lot of customers who just want their code to keep working. 
Nice job for a learner! I adore the comments and the documentation. But, as you wanted to know whether is it as awesome as you see it, here is criticism. &amp;nbsp; * Forget about cstring. The C++ Standard suggests using string (#include &lt;string&gt;). You can measure it's size by calling the method std::string.size(), you can compare them using operators ==, !=, &gt;=, &lt;= and so on. And if you really need cstring, you can call std::string.c_str() to get it's c-string equivalent. Read more: http://www.cplusplus.com/reference/string/string/ &amp;nbsp; * Forget about plain "[]" arrays. You need to delete them, you can't reliably get access to their size (unless you store it, which is another problem), and resizing of them is a bit of pain. I suggest (and Stroustrup also does) using #include &lt;vector&gt;. Read more: http://www.cplusplus.com/reference/vector/vector/ &amp;nbsp; * You should never have public variables. You have many in List class. The reason not to have them is because if some gentleman decides to write something to that public members, then he'll probably crush all the program. To make things safer, move all that variables to the private section. If you really need to give somebody the rights to change them, make public methods like "setTitle(string title)" or "setList(vector&lt;Todo&gt; list)" (I'm still talking about your List class). In these methods you can check the arguments and see if they are valid and do nothing if somebody tries to pass your "setSize(int)" method an argument "-1". Google about Encapsulation, or better read about it in some book (can't suggest, I was reading C++ in russian) &amp;nbsp; * Do not create global variables for pretty much the same reason you keep your class members private. Because a global variable allows everybody to change it, and if everybody uses this opportunity, then your program will become a mess. Looks like you have managed to do everything fine even with globals, but later on you'll see the horrible consequences of that when your 5000-line program will suddenly stop working properly. &amp;nbsp; * Add more classes. You should not have any plain functions. A better idea would be to organize functions with similar purpose in one class. Even more, the addition of more classes would, probably, help in eliminating global variables in a beautiful way by making them class variables or instance variables. &amp;nbsp; * Your program sould have 2 * N + 1 files, where N is the number of classes. The class definition and method prototypes should go into .h file, and method implementation - in .cpp file. The main.cpp file sould remain almost empty. .cpp and .h files should have names like "classname.cpp" and "classname.h". Although it's not Java where the program won't run if these conditions are not fulfiled, it is a very good idea to follow this javaish convention. &amp;nbsp; * Didn't want to start a holywar there, but pay attention to the code style. https://google.github.io/styleguide/cppguide.html I suggest reading the Namng, Comments and Formatting sections of this guide and NOT reading anything else - Google has kinda weird C++ style designed for those who come from other languages. &amp;nbsp; And again, well done! Keep up, use standard template library (STL), and you'll soon defeat this monstrous language! (seriously, after a few years of C++, Java and C# will look like a piece of pie - the code there just WORKS)
Hi Andrew, Looking at connect I am noticing that there used to be to a category for "Visual Studio 2015 with Update 2", that seems to have vanished. https://connect.microsoft.com/VisualStudio/feedback/LoadSubmitFeedbackForm My bugs were filled under update 2, and connect is no longer showing update 2(or update 3). I suspect that any bugs filled under update 2 are lost or just not showing up. 
**Note: it's only my point of view. Others may have different view on this. Main thing is to be consistent so that code reader will know how you do this.** Well, it's good advice to usually place only one class/struct in single header file. But there are cases when you might add others like: * nested classes (class inside class - i think it's better to add both _prototypes_ in single file since nested class usually have only sense in parent's class context), same goes with in-class enum declarations * helper classes/structs/enums that should only be used with one given class and shouldn't be used without it and probably other too. Go have a look at some opensource projects and see if there are header files with multiple class/struct/enum declarations. It's not really written law or anything (it's not Java), but i think if something small is used only internally for one specific class/struct, it might as well be defined in same header so that someone who reads code will know it's not some generic object, but it's use is binded to that given class. &gt;Where is the correct place for enums to be declared? Entirely up to you. There is no law or anything. For me - bigger declarations (like many values) each have their own header, but if something is used in many contexts, then there might be one header file containing many small (not many values) enums. Simple test for question "should i put two enums together?" is "do you usually use both?". If yes, then why not group them, one include less. If not, then why include something that you won't use. But if you want clean design you could put each enum in different header file.
Initializer lists aren't perfect for everything =&gt; they are useless for everything.
Microsoft should simply buy Whole Tomato and integrate it into VS by default. As a longtime VA user, using VS without it is painful.
In my opinion, the increase in code quality is not worth the decrease in performance. You could argue that it should be used in cases where there is no decrease in performance, but considering the non-obvious nature of these performance decreases, that's a hard rule to enforce. It's much simpler to have a "no initializer lists" guideline than "only use initializer lists on POD-types". Moreover, the more performant alternatives to this (the main one being variadic functions) aren't less readable; they just take some extra work to implement.
-1 for &gt; Add more classes. You should not have any plain functions. A better idea would be to organize functions with similar purpose in one class. Even more, the addition of more classes would, probably, help in eliminating global variables in a beautiful way by making them class variables or instance variables
I'm pretty sure this is trolling. Three posts in one day of videos of someone typing something.
This feature is VS's way of migrating not file state, but rather project state. It allows you to create a new project from that template inside of a folder with your source files already in it. The thing about navigating around with the Solution Explorer, is that you can make a folder / file structure that doesn't mimic the structure on disk (which sometimes can be confusing). This let's the Solution Explorer see a reference to a file that may not actually be in that folder. More like it *should* be there. Project templates are not for distributing end user source or binaries, that is much more what NuGet is for. They are for recreating a Visual Studio project once you already have the requisite source / binaries already at hand.
What I imagine Twitch for programming would be like. Zzzzzzzzz...
There is already twitch for programming, surprisingly people watch it. Can't remember the name of it right now though. 
I suspect that you'd be very interested to see what '\r' (carriage return) does when printed on the console. Give it a try, and you'll see why your 'trick' is the wrong way.
Just another garbage tutorial spam from India...
This looks interesting, it would be good to have pre-packaged binaries for select platforms though (Ubuntu, Mac OS X, Windows). I've also be interested to see what it's like running on Windows. Theoretically if you built GTK3 and the other dependencies for Windows it would be possible. Has anyone used this? What's the project/build support like?
Not yet, but we have an open enhancement issue on NeoVim integration: https://github.com/cppit/jucipp/issues/163. Not sure when it will be prioritised by the current contributors, but feel free to make an initial pull request and we can help complete the integration. However, I found the NeoVim documentation a bit lacking on how to do this last time I had a look (https://github.com/neovim/neovim/wiki/Plugin-UI-architecture), so if someone knows more about this, help would be much appreciated. For instance, GUI session protocol description and a complete list of documented GUI session commands would be of great help. 
At least initially, we focus on MSYS2 for Windows, as it has hundreds of precompiled and easily installable libraries. Regarding pre-packaged binaries, we hope instead that distribution contributors pick up the project and create binary packages for the various platforms. We already have build packages for MSYS2 and Arch Linux (EUR). The main reason of course is to lessen our work load, but we might automate pre-packaged binaries for some systems later. 
Still using Turbo C++? Are you from India? There are A LOT better, free alternatives to Turbo C++. Please talk with the teachers to change that because they are dragging a whole new generation of programmers using this obsolete program
Regarding MSVC, see my previous comment on MSYS2. We have not tested compilation of juCi++ with other compilers than g++ and clang++. 
Since nobody has pointed it out to you yet: There's actually a really good [CMake plugin for Visual Studio](https://visualstudiogallery.msdn.microsoft.com/6d1586a9-1c98-4ac7-b54f-7615d5f9fbc7). Just make sure to go into the settings and turn off the old style all-caps syntax default (assuming you don't prefer it).
I feel like the side bar should be updated if those books aren't good anymore. Both learn programming and this subreddit recommend accelerated cpp and don't even mention discovering modern cpp. Is discovering modern C++ the main book you would learn for new C++ progammers or is that more for the scientific purposes of his post. If I shouldn't read Accelerated C++ then what should I read? C++ primer?
Any reason you re using NULL over nullptr?
Thanks, I wasn't aware that boost even had a nascent crypto proposal. You're right, that's probably a better place to start than going straight for standardization.
Why not simply contribute to Qt Creator? * it's open source * has libclang code model * has cmake project support * it's lightweight / modular * has a steady release schedule I can understand the experience that one gathers from writing an IDE, but why reinvent the wheel?
That's the point.
Yes. I am expressing admiration for it.
Actually, juCi++ is more lightweight; faster and uses less memory (see for instance https://github.com/cppit/jucipp/issues/248), and juCi++ has a much smaller code base. It is also developed extensively using C++11/14 features, including heavy use of the standard library. Many of the classes can also be reused in other projects with few changes. Examples are the src/git.* files and the src/cmake.* files. Additionally, we have created tiny-process-library that can be reused directly without any dependecies. I would also argue that Gtkmm is a more modern C++ GUI library, and works well together with other libraries due to their heavy use of the standard library. That said, Qt Creator is a great tool, and for instance, we have yet not found/chosen a good solution for finding usages in unparsed files that would work adequately for larger projects. 
/u/frog_pow: I don't know. We're asking the Connect folks if something is amiss but I don't know about the specific categories. 
Another great example of this kind of thing can be found here: https://github.com/andrivet/ADVobfuscator (I'm not the author)
You are making too many assumptions about the memory layout of a function. What if my function's prologue starts with a relative jump? Also an alternative to using a 'rel jmp' as a hook would be a push 0xDEADDEAD ; Interceptor retn; Pops address from the stack and sets ip to 0xDEADDEAD This way there is no need for calculating the delta for a relative jump. To support cases like I described above (Functions with no prologue or functions which have been already 'hooked') , I suggest you to use a disassembler (eg. Capstone?) so you can see if the first instruction is branch instruction and you can extract the instruction size for internal checks (Might be useful for creating a trampoline.) Also your library isn't thread-safe, race-conditions can occur while writing the jump. You have two options here, first one is to suspend all threads except the running one, then by getting the context of a thread, you can inspect its ip. If it's safe to write, apply the patch, resume all threads. The second option is to use atomic instructions like cmpxchg8b (x86 only). Other things I noticed: - address_t and byte_t can be replaced with uintptr_t and uint8_t (from cstdint) - bit_manager can be replaced with std::vector&lt;bool&gt; or std::bitset
You say that like it matters. What matters is emacs compatibility.
well they don't listen, they think the simplicity and ugliness of the TC++ is too good to be true.. I use g++ at my home with Atom.io editor
GTK? What does it look like on macOS?
Gtk works quite ok on OS X, but there are some minor issues compared to Linux and Windows. The looks depend highly on the theme you chose to use though, and some themes might be harder to install on OS X. 
I'm not [/u/andralex](https://www.reddit.com/u/andralex) but I think [`std::lock`](http://en.cppreference.com/w/cpp/thread/lock) would not be usable here because it is defined to work with classes that model the [`Lockable`](http://en.cppreference.com/w/cpp/concept/Lockable) concept, which only require `lock`, `try_lock` and `unlock`. On [/u/andralex](https://www.reddit.com/u/andralex) case, he needs to acquire a exclusive lock from the mutex on `this` and a shared lock from the mutex on `rhs`, which is done by calling `lock_shared`and is beyond the requirements for a class that models [`Lockable`](http://en.cppreference.com/w/cpp/concept/Lockable).
&gt; we have yet not found/chosen a good solution for finding usages in unparsed files that would work adequately for larger projects. I would check out rtags; it just blasts the entire codebase through the frontend and keeps it in a database. It scales with # of cores too, so if you work on a large codebase but have a 20 core box then it works out. It does a good size codebase in a few minutes, but even if your codebase is large and it takes an hour, this isn't the end of the world as it serializes it and updates it as you change code. Full reindexes should be rare.
I really hope they record all talks and make them easily available. I'm really interested in a few of them 
[All of our talks are professionally recorded and publicly posted.](https://www.youtube.com/user/CppCon)
You can also write debuggers directly as GDB python scripts, called pretty printers. Qt Creator works with them automatically.
Nah, it's using Dev-C++ instead of Turbo.
Struggling to see the value here. If you want an abstraction layer over make surely it's preferable to use cmake or similar?
So the earliest form of the next standard (post 17' ) will be a 2020 release?
How good is this? Juts found cevelop C++ IDE (which is a bundled CDT from elcipse) that looks great.
Somehow, I think you'd have a hard time selling the logic that "3 years wasn't enough to finish large items. Let's fix that by shortening the release cycle even more." Realistically, I'm not at all sure things like Concepts, Ranges, or Modules are close enough to done that they we can say with any certainty that they would be included in a C++19 if such a thing were done. Once the features for the next release are set (like right now for C++17) quite a bit of the work on features not included in that release tends to get suspended or at least substantially slowed. Until the next release is approved by the whole committee, the committee will concentrate pretty heavily on finishing wording (and such) for the features it does contain. After that's done, work on the newer features will resume at a faster pace again. At the same time, keep in mind that the feature set tends to be finished around a year (or maybe a bit more) before the official standard--and compilers (at least gcc and clang, though vc++ has been improving lately as well) tend to have those features implemented well before the standard becomes official either. In short, those features may not be entirely official until 2020, but they'll almost certainly be available by 2019--and probably even earlier than that (an easy guess, since Eric Neibler implemented ranges before he proposed them for standardization, and Clang and VC++ each implement a modules proposal).
Does anyone have a conference agenda? I've been looking for info and can't find any.
[`std::shared_lock&lt;T&gt;{rhs}`](http://en.cppreference.com/w/cpp/thread/shared_lock) is a `Lockable` adaptor that calls `lock_shared`on `rhs`.
If you exclude C++98 and C++14, yes.
Huh... What are the odds for that...
So, if I did understand it correctly, all you would need to do is create some local [`std::shared_lock`](http://en.cppreference.com/w/cpp/thread/shared_lock)`&lt;T&gt; slock{rhs, `[`std::defer_lock`](http://en.cppreference.com/w/cpp/thread/lock_tag)`}` and pass as a parameter to [`std::lock`](http://en.cppreference.com/w/cpp/thread/lock) instead of `rhs` directly. Is that it ? That's good to know, thanks for the info!
It's more about steganography though: what is not easy to find is not that likely to get modified. A simple string search in the binary will yield nothing; it forces people to spend time and energy. Just like other kinds of obfuscation.
I'm curious if the presenter has ever considered producing a video on applications of the group axioms to software design and computer programming. Particularly, closure.
The conference agenda hasn't been posted yet. We'll be putting up the full agenda on Sunday.
[I am the speaker] Thanks for posting! If anyone has questions about something in the talk, feel free to ask me here and I'll be glad to try to answer! Also, the slides are pretty difficult to see. The slide deck is available [here](http://ldionne.com/cppnow-2016-metaprogramming-for-dummies).
Ah I think you could essentially do that with an optic microphone.
Looks wonderful !
Thanks! What's the meaning of &gt; Generative Fast Fourier Transforms in C++ using template metaprogramming ?
Nice to see a talk about MAME dropping C and switching to C++. 
And this is why I enjoy using graphical debuggers.
Poor Jason Turner had his name misspelled.
How'd you make those slides? They're sharp. 
You should put the code and not a video, even less if you dont have a micro, it looks bad, very bad
:D
**Company**: [StorageCraft](https://www.storagecraft.com) **Type**: Full time. **Description**: StorageCraft provides high-reliablity backup, recovery, migration, and management solutions. Our backups are volume-based, with an emphasis on being fast to take and fast to restore. We're an established (10+ years) company with a reputation for being one of the few solutions that actually *works* when it comes to recovering your machines and data. **Location**: Salt Lake City (Draper), Utah **Remote**: For exceptional candidates. **Visa Sponsorship**: Yes. **Technologies**: Currently, it's a bit of a wild mix. We do both user and kernel development for Windows and Linux. We target desktop and server environments and also write the software to support and run our cloud solutions. We support back through XP, and currently back to RHEL6 and Ubuntu 12.04. We've got everything from C++98 through C++14, Windows-flavored C89, and C99. There's a good deal of Python at the product level, and even some C# and Java. That said, we are *definitely* a native-driven company. We use Qt and Boost (up-to-date), and our builds are primarily CMake-driven (also up-to-date). Source control is done with Git and we make fairly thorough use of Atlassian's products e.g. JIRA, Bamboo, Bitbucket Server, etc. **Contact**: PM me with any questions, or if you'd like to email/chat about the jobs, or send an application in via the [job portal](https://www.storagecraft.com/iApplicantPro) directly. Even if there's not a job currently posted, we're always looking for strong candidates.
I like the .dll.lib extenstion. But I'm also a terrible person that tends to tack on .exe on my linux executables too :)
Well, when compile parameters are changed, you need to do a reparse in any decent indexer. Changing the definition of a macro can completely change where a symbol is defined, so how can you change a macro and not expect a reparse? In practice I just don't change compile parameters as far as the indexer is concerned, e.g. I'll compile in debug or deploy, but I won't bother reindexing according to that. Ctags, and text based tools in general are a disaster in C++. Most people I know who used this stuff for years (because they were hardcore into emacs, or they've been programming since before IDEs had good indexers, etc) say the success rate is around 60 or 70%. I think you'll find that an IDE that uses ctags/cscope is a deal breaker; the people that are ok with that are mostly in vim/emacs land, people who use IDEs generally want real indexing.
I would love to see .dll.lib instead of two types of .lib.
We use Ctags to find implementations as a fallback when libclang does not find any in the parsed files. Ctags works well for declarations and definitions because these are easier to identify, compared to for instance usages. Ctags find all platform specific implementations too, while libclang would only find implementations for your current platform depending on your build. Ctags is not perfect, but neither is libclang yet either. For instance, doing a full project parse with libclang just for project usages is quite resource wasteful as libclang currently do much more than just find the project cursors. There is no parameter we can pass to libclang yet to reduce the amount of parsing it does. However, CXTranslationUnit_KeepGoing, might help. What we have implemented so far is the apparent good solutions that works in most of the cases. Your feedback on cscope is very valuable, and it might be that libclang is the best way to solve finding usages in a project. We will investigate this further. 
&gt; foo.dll.lib and foo.lib I'll just throw in with the chorus and support this convention. It seems clear, and it would have saved me a lot of confusion when dealing with Windows.
How about just having a Makefile with reasonable defaults (why would anyone start a brand-new project restricted to c++98?), and a comment that says "Change here if desired". Also, you should at least respect common environment variables like CFLAGS, LDFLAGS, etc.
I don't think you're going to find a standard. Everyone does it differently. I personally would prefer putting them to different folders so it's easier to tell them apart at the first sight. Other suggestions like ".dll.lib" or "libthing.lib" would confuse me to not end.
If the goal is obfuscation, then sure. If the goal is anti tamper, then I call BS.
I don't. If I were just someone who wanted to see if I could tamper by doing a hex search for strings and couldn't find them, I'd likely give up. You're trying to keep people honest, not stop dedicated people.
They discussed getting better AV Equipment for next year in may, I hope they replace all 3 cameras with newer models. Yet the conditions at C++Now with lights and beamers can be difficult to record properly. AFAIK they still use the same cameras they did in 2012, not sure how old they are, but newer camcorders should make a huge difference.
Initially, my original Makefile came with CFLAGS, but then decided to use a more generic name that would or could compliment both languages, C and C++ respectively. &amp;nbsp; As far as concern LDFLAGS and the rest options, I decided to let it to users who want to fully customize the generated Makefile. &amp;nbsp; Now, about the C++98 project restriction; well, we still have projects that can't use newer C++ versions for reasons beyond the scope of this project. &amp;nbsp; GCC for instance still use C++98/C++03 flag as their standard compilation procedure, thus someone could use a subset of C++ with lots of important mechanisms let outside. &amp;nbsp; If you want to help with project's improvement, please feel free to fork and implement accordingly. &amp;nbsp; That's the objective of a FOSS project to be honest with you. &amp;nbsp; By the way, thank you for your question, it was really nice to have such feedback. &amp;nbsp; Cheers.
They should use the slides to help make the video better. u/kevin_hall made a [revamped video](https://www.reddit.com/r/cpp/comments/41c2p9/sfbaccppu_jan_12_2016_bjarne_stroustrup_on_no/cz17tt6) of a talk by Bjarne Stroustrup in this way. The original video was terrible, but the audio was fine. The end product was something that was much easier to digest.
Actually, me too, haven't noticed it before (It says Kirs instead of Kris)
**Company:** [Nitro,Inc.](https://www.gonitro.com/about/jobs) **Type:** Full-time **Description:** We are looking for candidates interested in 2 roles we have available in our Dublin office. A **C++ Developer, Team Lead** role is currently available in addition to a **Senior C++ Developer role**. At Nitro, we’re changing the way the world works with documents. From the desktop to the cloud, we make it easy to create, edit, share, sign and collaborate – online or offline. More than 500,000 businesses run Nitro, including over 50% of the Fortune 500. We’re the PDF software partner of choice for Lenovo, and our award-winning products, including Nitro Pro and Nitro Cloud, are used by millions of people around the world every month. Australian-founded, we’re headquartered in downtown San Francisco with offices in Melbourne, Australia; Dublin, Ireland; and Nitra, Slovakia. One of the fastest-growing private companies in the world, Nitro is also a multiple Inc. 500/5000, BRW Fast 100, Deloitte Technology Fast 50 and Software 500 award winner. **Location:** Dublin, Ireland. **Remote:** Most work onsite but flexibility for remote work on an occasional basis **Visa Sponsorship:** Not necessary in Ireland. Relocation package available for EU citizens **Technologies:** C++, C++14, Win32 and Win64 APIs, MFC, the STL and the Boost libraries (Windows) **Contact:** [apply here](https://www.gonitro.com/about/jobs)
One of the things I've learned in my life is to not let someone else's disappoint ruin my excitement.
I thought networking made it in as a TS? 
and yes, this blog post exists thanks to feedback on reddit from the video version. thanks as always for your feedback. :-)
I really don't like this slide system - it looks nice but you have to constantly watch the navigation arrows to see whether the next slide is down or right, which is kind of terrible from a usability point of view. *edit*, oh actually if you hit 'space' rather than arrow keys it seems to do them in order... Good talk though :)
Slides available here: https://github.com/SuperV1234/cppnow2016/tree/master/multithreaded_compiletime_ecs Library available here: https://github.com/SuperV1234/ecst
How is that a tutorial? Just shows the game, scrolls the code "Here it is!"
I prefer `static` over `inline` for that purpose. `static` means internal linkage - not used anywhere else, which is exactly what we want. `inline` is more it can be present elsewhere, but as a duplicate of this one. That said, I do use anonymous namespaces in implementation files for helper functions.
Would be much cooler to add mos6502 back-end to LLVM and get c++17 and all kinds of other things on C64 =)
&gt; better CMake support for MSVC It's called `build2` ;-). Being able to cross-compile with `cl.exe` from Linux to Windows -- priceless...
All C/C++ libraries are supported through CMake. Although, the CUDA kernel is written in it's own C-like language is it not? If so, only syntax highlighting would be supported when writing the kernel I guess, unless the kernel functions are declared in a header file. 
Yeah, did that with a bunch of videos this year too, as they mostly recorded the speaker only. That is lots of work, as if you only have the slides, you kind of have to guess when the slides change...
Slides might be found here: http://boost-experimental.github.io/di/cppnow-2016
And here I was all excited for an official 6502 gcc port...
It looks great, but I had a few suggestions: - Add the option to exclude certain folders from symbol search - Add comments to the JSON parser. I know comments aren't part of the standard, but it looks a lot cleaner than the `*_comment` values - Recognize that `CMAKE_CXX_FLAGS_RELEASE` and/or `CMAKE_CXX_FLAGS_DEBUG` is set to `-std=c++14`, instead of just `CMAKE_CXX_FLAGS` - Documentation/Doxygen comments - Autocomplete for `#includes`
Your code looks like C I made [this](https://github.com/e4lejandr0/SnakeGame) a couple of days ago using ncurses
I'm on Arch linux. I grabbed cevelop from the [AUR](https://aur.archlinux.org/packages/cevelop/) on a fresh system: [BOOM java.lang.RuntimeException](http://pastebin.com/M2H27Ve3). Ah, now I remember why I stopped using eclipse.
Cuda and its .cu and .cuh extensions are actually supported by gtksourceview, so it is already supported in juCi++. But the autocompletion would only be keyword and buffer based.
Before anything else, you should make sure that you aren't presenting your code as light text on a dark background. It's simply more comfortable for your eyes to have dark text on a light background - like the subreddit you're reading - rather than, say, [this subreddit](https://www.reddit.com/r/elderscrollsonline/).
yeah dark theme on everything please. White backgrounds are so painful for the eyes
No, but it's just one way of doing it. If your editor/IDE supports copying HTML markup, please use it. :)
Looks like vim can do this. Interesting stuff. Good post.
Nice, I'll add the bit about other editors being capable of copying HTML markup. :) Thanks!
True, but in this case "used wrongly" is the default case. In most of those dumb "never use this" guidelines, the features are only bad when *misused* (ie. operator overloading). With initializer_lists, the inefficient case is *correct usage* of the feature.
Having trouble finding the paper but that's written in 1980. So it's reasonable to assume they used CRTs? With perfect blacks? What about LCDs where we have a contrast ratio. What about the aliasing inherent with LCD displays? I'm not discarding the study and not going to make any unsubstantiated claims but a study from 1980 (with no mention of hardware they used) for modern display panels hardly seems to be a good citation. Maybe OLED displays change our perception again. BTW, I'm middle aged with somewhat poor eyesight and bright background with black text really hurts my eyes (if I turn down the brightness then my eyes hurt trying to read the words) whereas the same is not true for darker themes. Totally anecdotal however.
Some of the text on the slides is illegible due to blurriness even at 720p, namely it seems like anything with red syntax highlighting.
Another way to do it is to use pandoc to write your posts and let it do the work (pass `-s`). While not as color-full as the way in the article, it also works without Javascript which some people disable by default for security-reasons. Also: Using a turing complete language to parse and color statically known code is an abomination!
&gt; Well, the following well-known programs and sites use dark-on-light by default: &gt; * reddit * github/gitlab/bitbucket * emacs/vim/XCode/Visual Studio (I haven't looked at VS in years, though) * terminal (in Ubuntu, RPi, and OS/X, at least..) * http://melpon.org/wandbox (perhaps less known but I use it almost every day) * readability.com Certainly the default color scheme for unix terminals is light-on-dark (and by extension vim). Hit Ctrl+Alt+F2 - what do you see? Also, what kind of weird version of Ubuntu are you using which doesn't use the default white-on-purple color scheme? Atom, VSCode and Sublime Text - three modern and popular text editors use light-on-dark by default. &gt; And ~~the science~~ *one study from 1980* seems to show that people on average are 26% (not a misprint) more accurate at reading dark text on a light background. How long did those people have to read the text? Most professional programmers probably look at text on screens for 6+ hours per day and the main issue with dark-on-light text is that it causes eye strain over time. I'm sure I'd hear more detail in my music if I were to double the volume but after an hour or so my ears would hurt. Also, were those people used to light-on-dark text? After all, the study was done in 1980 and almost all printed text is dark-on-light. 
The sanitizers add the checks to the compiled binaries directly, so -fsanitize needs to be add to every compilation unit that you want them to run on.
I personally don't need a tutorial for this, but others might do My point was that your video is not a tutorial at all
Are all the videos there? I didn't find the session winner videos. http://cppnow.org/2016-conference/announcements/2016/05/20/close-of-2016.html
Thanks! Yes, I designed and developed it from scratch as my BCS thesis project *(the thesis can be [found here on GitHub](https://github.com/SuperV1234/bcs_thesis), if you're interested)*. 
On structured bindings, is the following legal? struct { int; char } foo(); auto [x, y] = foo(); or struct members must have a declared-names? 
I'm not sure where else to ask this but how do I "import" a current project? I have a directory with a CMakeLists.txt file in it and while I'm able to open a directory and it all gets parsed and what not, using the Compile button from the dropdown menu doesn't seem to do anything.
That was true 6 years ago. From section 3.5.4 of the C++11 standard: &gt; An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has internal linkage. The C++14 standard hasn't changed that, and the same holds there, in section 3.5.4. That said, it's arguable that the point of internal linkage is to make a symbol inaccessible to other translation units. If you place a function inside an unnamed namespace, it will not be accessible in external translation units, and so as far as they're concerned, it's non-existent. Lastly, you can't get internal linkage for a class with `static`.
Backporting compilers is "easy". I backported gcc5 to RHEL4 just by following the instruction. The only caveat is that you may need to go through an intermediary compiler version to keep boot-strapping up to the required level, although I suspect you won't need to if going from trusty.
You're right, I stand corrected; I didn't realize that C++11 changed unnamed namespaces to give _all_ their contents internal linkage rather than just nested namespaces. Sorry for the confusion! EDIT: Note that you only quoted half of the relevant standardese (that the namespace itself has internal linkage); the equally-important part is &gt; A name having namespace scope that has not been given internal linkage above **has the same linkage as the enclosing namespace** if it is the name of &gt; - a variable; or &gt; - a function; or &gt; - etc., etc.
FYI Clang got support for it some hours ago. I'm building it right now. I am already using some features from C++17 like, fold expressions and constexpr if, can't wait to test this one.
What warning or error messages are you getting? One possibility is that you have previously created an in-source build instead of out-of-source build. The default build directory is ./build, but cmake will not create files in this directory if you a have already an in-source build. The solution then is to remove all the previous build files from the project root: CMakeCache.txt, CMakeFiles, and so on. 
Thank you. I've added the comment feature on my todo list. 
Im still learning C++ and was wondering if you could explain this little bit of code: static timer_set_t &amp;get_timers(void) { static timer_set_t timers; return timers; } How is `timers` not empty?
not yet, 2 and a half days worth of talks are still not upoloaded but, I guess, they will be added to the same place 'What is the basic interface' was one of the last talks on the conference tho so, probably, it will be uploaded as one of the latest too
What is the purpose of differentiating those two pretty similar concepts ? 
Haha, thanks! I had the same problem but it didn't occur to me until I was writing a program that indexes C++ code. At that point I noticed my team mates using those words interchangeably, too. Which led to a lot of confusion on my part ;)
then just call it a value, or a parameter value, or an argument value, or &lt;name of variable&gt; value. The differentiation is basically meaningless, especially when context is a large part of the english language and it's very easy for the listener to understand what the speaker means via said context. 
Proper? Considering that the standard has definitions matching the linked page, I'll argue that for this group the proper definitions are those. More generally, both nomenclatures have been in use since before my time (and a third using "formal argument" and "actual argument" as well BTW). One may prefer one set, but considering the others as improper does not seems right.
The Template visualization seems useful.
You cannot sleep accurately, but this library is not sleeping. It's perfectly reasonable to expect it to be accurate if all it does is a spin wait.
For C++14: - [defns.parameter]: "_**parameter &lt;function or catch clause&gt;**: object or reference declared as part of a function declaration or definition or in the catch clause of an exception handler that acquires a value on entry to the function or handler_" - [defns.parameter.templ]: "_**parameter &lt;template&gt;**: template-parameter (defined in [temp.param])_" - [defns.argument]: "_**argument &lt;function call expression&gt;**: expression in the comma-separated list bounded by the parentheses_" - [defns.argument.templ]: "_**argument &lt;template instantiation&gt;**: expression, type-id or template-name in the comma-separated list bounded by the angle brackets_"
So since the differentiation between parameter and argument is ostensibly "meaningless", we should add the word 'value' to the end and _that_ makes things clear? WTF..?
Thank you very much.
How widely applicable/acceptable is such definition? Only in context of C++?
Unfortunately this definition does not apply everywhere. In Fortran for example C++ there are "dummy arguments" (what are "parameters" in C++) and "actual arguments" ("arguments" in C++). The term "Parameter" has a different meaning in Fortran. I'll edit the article to note that I'm talking about C and C like languages to minimize confusion ;)
What is important is to understand the audience and use their language. What I dislike is when language communities starts creating a vocabulary that is bending common usage. C++ is hard to get into, so it is important to communicate in a way that most programmers would understand. Standards often redefine common words into narrow/skewed meanings that are unsuitable for education, like the whole mess with «rvalue», «prvalue» etc. If you want to change terminology you need to get it into commonly used textbooks and have educators adopt it.
Got me! ;)
That clears things up. /s
Travis guys just don't care about linux enough. They have container-based Trusty environment, but they don't whitelist packages at all. It's been more than a year, since wxWidgets3 got false positive in their setuid/setgid check (easy to notice), and there wasn't any progress on it ever since. It took them a lot to even have Trusty env, while they pump out new xcode images regularly (though when they forgot to include cmake in the new image, it took them about half a year to fix it too). That's very strong contrast with appveyor ci support (windows builds). Also, I think travis is partly responsible for llvm apt temporary shutdown, since if you wanted to get somewhat new llvm or clang, you had to install it manually (no preinstalled/cached c++ compilers) every time. I think it'd create a massive load on llvm mirror. UPD: Just read the issue completely - it seems that we've come to the same conclusion)
Another kind of distinction that can be drawn here is that for a given function, it only has 1 set of parameters - those declared at the function definition. But it may have *many* sets of arguments. Every call site provides a different set of arguments (though possibly with some repetition), and there can be many different call sites to a single function.
I didn't even knew that there was still precise. I've been using trusty for almost a year with travis, with the ppa, for a C++14, Qt5 app that uses a lot of libraries, without any problems. I also have a docker image with g++-6.1 and latest Qt5 &amp; boost based on CentOS 6.8 to produce appimages.
I get it!
With gcc and LLVM who in their right mind would use this? Even if you ~~want to pay someone~~ need support there is the Intel compiler
&gt; This is actually a pretty slick **little** use...
Done, i hope it will help improve the testing in C++ who really needs an improvement
Clang _3.3_, though, IIUC – not even support for generic lambdas... ;-[
I believe the idea was floated on the isocpp mailing lists. Of course, that's all irrelevant unless someone actually writes and submits a proposal. :)
I will summarize the results in this thread in about 1-2 weeks or so, once most people have had a chance to participate. :) 
Is the Dinkumware STL a selling point? The clang C++ standard library is already excellent, and I thought quite a bit more up to date with respect to standards conformance? Wouldn't they be better served fixing it up to work on Windows so that you get the same features across the board on all platforms? clang 3.4 is already the minimum baseline for my work projects, which is good because earlier releases had some awful bugs.
I have a bad tendency of using the word "method" to refer to member functions on a regular basis (force of habit gained from other languages like C#). I wonder how many other people do this too. Does it necessarily matter if we have two terms for the same thing though? It's a common occurrence with human languages to have some variety to spice things up. I can see it being confusing to someone who is new to software development though. 
Porting libc++ off of POSIX is non-trivial. Dinkumware is, for better or for worse, _the_ Windows standard library, as libstdc++ was for a long time on *nix.
Customer feedback is definitely very important for us. After all, if we want people to use our product we should probably make sure we are building and improving the features they want to see! 
Decided to download and test my [C++ I/O Benchmark](https://cristianadam.eu/20160410/c-plus-plus-i-slash-o-benchmark/) with it (copy a file by read/writing 1MB). In that benchmark Visual C++, which also uses Dinkumware STL, was 3x slower with the `fstream` API compared with `C FILE` API. Clang 3.7 using Visual C++'s STL was ~4.5x slower. I've compiled the app as `bcc32c.exe -O2 test_io.cpp` and ran the `test.cmd`. Results below: Average c I/O took: 109.43ms Average posix I/O took: 110.22ms Average c++ I/O took: 4170.11ms `fstream` API was **~38x** slower than `C FILE` API! Congratulations to the Microsoft team for the 12x speed increase :) 
&gt; You cannot sleep accurately How do you mean? The [clock_nanosleep()](http://man7.org/linux/man-pages/man2/clock_nanosleep.2.html) call is pretty darn accurate.
Ah! Missed that. Thanks.
I know that specially VS is trying very hard to be better day by day, you make it "free" for everyone, you put the feedback smile option to send feedback quick and easy and you try with things with that, you are not the first vs team post where i coment and you has really interest in our opinions, so i am glad to see that you are working hard to make it the best ide I tell this to your other mates, change what you want or need but tell to the world after that, one month ago i didnt know the drag and drop option in the debugger until i saw it on channel 9 and it was there since 2010 if i dont remenber back, so please, tell and make good docs about what you make/change
While we're on the topic of naming, it's a class template rather than a template class.
No love for [KDevelop](https://www.kdevelop.org/) in "What IDEs or editors do you use for your C++ development?"
Odd. Research.net is just a Survey Monkey brand, I think. 
Just finished it on chrome on android. No issues.
Hmm weird. This is indeed set up through SurveyMonkey by the way. I think that's a lesson for me to avoid that drag-and-drop question format in the future, it's additionally confusing with the secondary dropdown list selection criteria. 
Sadly given the large number of potential IDEs and editors that could be used for C++ development, some got missed. I'll make a mental note to include KDevelop in future surveys, unfortunately it slipped my mind this time around. Feel free to fill it in under "Other (please specify)" though, I will tally those results up as well when I post the results. 
Here I am stuck working in mostly Visual Studio 2008 :(
I was thinking something along the lines of `using myclass { ... }`, but `namespace class myclass { ... }` sits better. Then again, it doesn't introduce a namespace. Maybe `class namespace`...
Then again `enum class` isn't any kind of class ;) From all the proposals here i like `namespace class foo { ... }` most (`class namespace foo { ... }` close second) as it's similar to `enum class` and says `now we introduce scope for this class's implementation`. It might be simple syntax sugar, but on the other hand, i could live without it. At least now when i see `[return type] class_name::method_name(parameters...) { ... }` i know exactly what am i implementing, and there might be many `init()` (or something like that) methods in code. Also if people start messing with clean-code rules and put implementation of more then one class in `.cpp` file, then it would be hell to always check which `namespace class` is first before.
Honestly, modules will probably somewhat solve this problem anyway.
Nope nope nope nope nope. Do not recommend. In the middle of migrating all of my teams code away from Embarcadero's VCL platform and there are so many issues with their entire setup. The ONLY redeeming feature of their platform is the tightly integrated form designer although it heavily encourages software design that creates a mess of spaghetti code where there's no distinct MVC design and makes testing far more annoying. Seriously cannot wait to be free of their BS
How much whiskey do you get through in a week?
Hi, C++Builder PM here. It's possible to turn on additional optimisation flags beyond -O2; the compiler is a Clang driver so clang arguments can be passed via -XClang. For example, you can use -Xclang -O3 to pass that through, and similar with specific CPU targets or other flags. We don't test with anything other than the published argument list, but that list is what it is in order to maintain classic bcc32 compatibility. We're looking into exposing and officially supporting more of the Clang options directly. Streams are an interesting choice for a benchmark; they're notoriously slow.
Yes, it's Clang 3.3, though we've backported a large number of fixes from newer versions. To give insight, we've been focusing on platforms recently - iOS, Android, and we have Linux support coming soon. I can't comment on whether we'll move to a newer Clang until we release a public roadmap, but I can say I'm as aware it would be nice to use a newer version as you are ;) We tend to focus on the benefits of our libraries and frameworks, because on the ground, being able to write an app without extra work across platforms is what matters. Compilers are a tool to get there. iOS / Android support for example: in VS while they "have" support, it's very basic - you still have to write Java code to get an Android app working, for example! Whereas we have complete frameworks and built-in native support to the toolchain, including for things like Android bootstrapping. That goes for the UI too, where our UI framework works on mobile/Win/Mac. In practical terms, being able to use something across platforms makes development faster in a way that the C++14 tweaks to the language don't - so we focus on those first. We are closely investigating updating language support, though - keep an ear open.
Thanks! There are some online IDEs like [Ideone](http://ideone.com/) or [this one](http://www.tutorialspoint.com/compile_cpp11_online.php) but they don't seem to offer rich highlighting (probably because they're using something like highlight.js).
Maybe that should be flagged as a bug if it's not consistent with the rest of the document.
Lucky you! (I'm stuck in 2005)
The latest my office has is XE7 which the 32bit compiler only supports up to 2003 and the 64bit compiler has problems with its floating point header which meant we weren't able to use a number of XML or JSON libraries to build in requested features. Going to be doing a massive rebuild and it'll be so satisfying when it's done and we can hit uninstall
The slides are linked to in the description.
Hi - not sure what you mean by only supporting up to 2003 - is that Server 2003? We support the versions of Windows (or OSX etc) that are supported by Microsoft at the time of release. XE7, a while ago now, should support up to Windows 8, probably 8.1, whichever was around at the time of release. Of course in practice it should work fine with newer versions anyway. Re the floating point header: I'll piggyback on the above comment to ask if there's a [bug report](https://quality.embarcadero.com/)? Getting us to solve the bug or provide a workaround is probably a lot less effort than you rebuilding your entire product. We also backport important bugs to older versions, so many bugs fixed in 10.1 Berlin are currently being backported to Seattle and XE8.
I guess he's referring to the old compiler which ships with an incomplete boost 1.39 and has issues with several of those libraries...
Do you plan to release regular updates to this free C++ compiler? People might want to use the compiler, report bugs and the see the bugs fixed and informed like /u/STL does for Visual C++. What about the debugger? The package has no debugger. Which type of debug information does the compiler generate? Is it compatible with Microsoft Debugging Tools (cdb?), GDB, LLDB?
Please start a new thread. This one could be buried by then.
MSVC should use Catch and help develop a mocking framework to work with Catch. (Google Mock is the best mocking framework around -- that I'm aware of anyway -- but I hate using Google Test.)
Note that the definitions of terms 'formal argument', 'actual argument', 'formal parameter' and 'actual parameter' in the draft standard were [removed in Jun 2014](https://github.com/cplusplus/draft/commit/50dfba2293729baf00f8bf98eeaaebcd8e5a5d2b).
All very exciting! [P0145](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r1.pdf) is I think particularly important. Once I read the first revision of that paper, I realized that I - and everyone else - had been doing things that, strictly speaking, were undefined or at least indeterminate behavior. As the paper basically points out, if compilers really broke on such code, no one would get any work done. ;-) But it's a nasty hole. This paper proposes a solution by formalizing what we've already been doing, so we can be sure. Good job! On a personal note, [P0272](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0272r0.html) fixes an issue that has nagged me for years. 
Have you heard about our next version of VS? We're working hard to completely overhaul the installation experience so you only install the workloads you actually want to use. We're decoupling all these different features from each other to make that possible. You will be able to pick and choose exactly what you want from the installer, so you can avoid all this overhead from languages you are not actually developing with. 
The 64bit compiler supports C++11 but has that floating point issue which means we can't use whereas the 32bit compiler only supports up to C++03 so that locks us out of many other libraries. I'll respond to the PM in a while.
It would be cool if the source code could be made available (released under the public domain) seeing as how it is obsolescent. It would definitely be of historical interest...
"String C++ skills"?
Note that non-const string::data() is already shipping in VS 2015 Update 3 thanks to /u/BillyONeal.
I appreciate you actively engaging me on this, but honestly the ship has already sailed.
Yeah it was an older compiler. But it still left a sour taste in my mouth... did they not test their included libraries even once before shipping it out the door?
Folks, please join our VC Migration DevLab (http://landinghub.visualstudio.com/devlabs_c). If you are targeting one of the platforms that VS still supports, we are interested in helping you migrate your codebase to the latest VS compilers and/or IDE. We can also chat over email if you want - drop me a line at mluparu at microsoft dot com. Marian Luparu / Visual C++ PM Lead
hmm, sounds interesting. One question: do you know if VS 2008 can open seamlessly VS 2005 solutions/projects? i.e. not to prompt converting, but just open it (with the ability to build/debug/etc...).
These days they're good about keeping Xcode up to date, but that's a recent development. For a while they were regularly months behind.
Unreal is a great engine to work with and will get you making awesome stuff quickly using C++. There are great YouTube tutorials out there. Plus, it has the added benefit of being pretty standard amonst AAA titles. If you want to go a more indie route with excellent tooling on other platforms, then Unit is a solid choice, but it leverages C# (although I've heard the engine is actually in C++).
It was still possible to get a non const pointer through indexing, but this is certainly better. 
It's possible that it may be slipped back into the language. The simply wasn't enough time at the meeting to work out the small kinks, but they were dealt with shortly after. 
Okay, I hate to bombard this link with comments but this is the only place I know where to get any type of support on this. Has anyone else had trouble with C++11 keywords not being recognized? I keep getting errors from the IDE saying, "'auto' type specifier is a C++11 extension". I've googled this and it seems like a warning for clang so I think I have to find a way of suppressing them.
I'm liking Microsoft's efforts into C++ lately. They locked it out of Windows Phone UI, so I hope they eventually put it back
https://github.com/boostcon/cppnow_presentations_2016/blob/master/00_tuesday/practical_performance_practices.pdf 
Adding -std=c++11 to the compile parameters in your CMakeLists.txt should solve this.
&gt; P0145 My understanding is that this proposal was not completely accepted, the part about function call arguments order was not kept. Can someone confirm this? (BTW I'm a game dev and I think the performance argument for this case is a bit ridiculous)
Are you using the classic compiler or the new one? (Edit: in 10.0 Seattle and above) we ship two 32-bit compilers for Windows. The Clang-based one has full C++11 support. You can toggle them in project options, C++ Compiler, uncheck 'Use classic Borland compiler'.
XE8 was the first to include a Clang based 32bit compiler, XE7 only had the Borland compiler for 32bit.
I think I tried that but I don't remember if it worked. You know, I might be messing everything up by doing all this with a CUDA project. I'm not at home now but I can push up my project to github and you can take a look if you want. The project is like 5 files. I'm just trying to get compilation and my build system set up. Edit: Okay, so I tried throwing `-std=c++11` to the CXX flags but it didn't seem to help. [This](https://github.com/LeonineKing1199/cuda-stuff/blob/master/CMakeLists.txt) is my CMakeLists.txt file and from there you can parse the rest of the project, if that's relevant. Edit edit: Okay, it seems like it's only a problem in header files. I'm using the .hpp extension. I'm not sure if that would be an issue but it might be worth mentioning. But yeah, source files seem to be fine but it's the header files (all except domain.hpp). Even then, domain.hpp can't seem to find the first Thrust include either.
If I remember correctly from looking at memory-barriers.txt, the fabled DEC Alpha would happily take advantage of the difference between consume and acquire, but my x86 certainly wouldn't, nor would a lot of other architectures. I'm curious if people write C++11 for the Alpha, that sounds like heaps of fun. Are there any other CPUs today where consume wouldn't be equal to acquire in hardware? 
All zeros makes total sense. The array lives entirely on the stack, so capture by value (aka, capture by copy) would result in the values being preserved.
&gt; Are there any other CPUs today where consume wouldn't be equal to acquire in hardware? That's not quite right. On all CPUs except the Alpha a consume does not require any memory barrier instructions. On the other hand an acquire requires a memory barrier instruction on architectures such as ARM &amp; PowerPC (and Alpha). So basically using consume instead of acquire is useful on ARM &amp; PowerPC since it allows you to avoid a memory barrier instruction.
Is javascript really necessary to display some text?
That's a good way of looking at it. argv is the argument vector. It's the parameter which holds a vector of the command-line arguments. argc is the argument count. It's the parameter that tells you the count of command-line arguments. Seems consistent to me, given that a command line doesn't have formal parameters in any way, only arguments.
Jeff Preshing, one of the contributors to the [redefinition](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0190r2.pdf) of memory_order_consume, wrote a good [article](http://preshing.com/20140709/the-purpose-of-memory_order_consume-in-cpp11/) two years ago about the benefits for X86-64, PowerPC and ARMv7.
Looks like you and I both tried to solve the same problem in roughly the same way. I went with an invasive CRTP approach in [mine](https://github.com/LB--/events) (still somewhat WIP) to support event inheritance, but yours is still mostly the same idea: all the listeners are stored in a global list, and you inherit from listener classes to listen to events. One problem you and I both run into with this design is that the global data isn't really the same when you want to have multiple dynamically linked libraries using the same event system. I solved this with a macro to define the storage within the source files instead, making each event type have its own global list of listeners, but it's still not very pretty. Not sure what to do here. Another issue is that, in many cases, you really only want one listener per event type. Imagine a game where each enemy was a listener for `EnemyEvent`s: that would be a lot of enemies receiving mostly events that didn't relate to them at all, because they'd have to check if the enemy instance in the event was them. Instead you would want a single global listener that then tells the enemy in the event what to do. Having multiple listeners is then really only useful in a context where you want to mash together listeners from different sources (e.g. unknown dynamically linked libraries at runtime). It also separates the logic from the definitions of the affected classes, but this was already present in your "before" example anyway so isn't much of a concern. Despite all that, the advantages and type safety are enough for me. I'm just a bit concerned about the typeid stuff and the single `std::map` - why use runtime searching to find an event type when you can do that process at compile time? E.g. make your `EventDispatcher` class a template on the event type and get rid of the typeid stuff. No more map!
I think it should be as simple as changing your `EventDispatcher` class to be a template with a parameter for the event type, so that you have different global list of listeners for each template instantiation (and therefore each event type). This wouldn't complicate the usage much at all and would eliminate the need for `std::map` and `typeid`.
Just as a note, you can easily avoid dynamic_cast by using a type member variable and an enum and you avoid both RTTI and overload. By the way, how much time of professional experience do you have? I'm just curious.
1 month with c++. Although I first dabbled with it some years ago in college.
I'm confused - how would that avoid `dynamic_cast`? Unless you plan to use `void *` and `reinterpret_cast` instead?
P.s. I think using a type member is not really avoiding run-time overhead. Plus it's more error prone IMO than taking advantage of virtual functions and other language features.
Definitely DON'T use UE4 to learn C++. I don't know why they recommended you this but don't, trust me. When you begin to develop with UE4, you wonder why it's so tricky and hard to read, as well as think if you really know any C++, because you'll understand like 2% of engine's code. There are so many things to learn about C++, that don't even think about "mastering" it short-term, I realised this a couple of months ago xD I've began to do C++ coding tests (I'm finishing my Master's in Games Programming), and I can tell you what I see most of tests ask and what mid/big companies ask for in their job descriptions. - Memory management. They want to know if you're really familiarized with stack/heap, allocation/deallocation... - OO. Polymorphism, inheritance, components. - Software design patterns used in games. Observer, Singleton, Factory, just to name a few. - Math. At least basic trigonometry, algebra, vector/matrix operations... Then, you'll need to know specific things or things that are more widely used in different areas: - AI. State Machines and Behaviour Trees, steerings... - Animation. Blendings, State Machines too, bones-based animations... - Physics. Really strong 3D math and physics knowledge (obviously). - Network. TCP vs. UDP, probably multithreading for server-side, sockets, data packaging (you want to send the less possible amount of info). Note that a strong math background is a must in all positions, you always need to use vectors, matrices and algebra xD Hope this helps you and good luck.
http://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html
Actually, is this the only case where arrays are copied element-wise? The spec seems to have to explicitly mention that for arrays, its the elements that are direct-initialized ([expr.prim.lambda] 22).
Ah, right. But, that only works when you know what all of the types are in advance.
That's what I do as well - use a enum member variable and static cast. I'm curious to know how far is rtti from the enum solution. I cannot think a reason why the rtti implementation should be very different from the enum + static cast. 
&gt; It makes it difficult to find out which class &amp; instances are listening to an event. Seems like you could just search for the event class if you want to know who is listening to it, at least with my scheme. But I do see what you mean about the event emitters being obscured. Thanks for the info!
I started looking in to it, and I dug up this interesting [SO question](http://stackoverflow.com/questions/5134975/what-can-make-c-rtti-undesirable) answered by Chris Lattner. 
This is actually one of those odd cases that is more likely to trip up experienced C++ developers than novices. For someone who hasn't written a lot of C++, it's "obvious" that the array will be captured by value at the time the lambda is instantiated. More experienced C++ devs on the other hand are used to raw arrays behaving in "non-obvious" ways almost everywhere, turning into pointers at the drop of a hat, so it's actually kind of surprising that this "just works". It takes a little knowledge of how lambdas are implemented (i.e. as a struct with a function call operator) to work out why this does what it does. In any case, if this turned up in a code review I'd be inclined to recommend changing the raw array into a `std::array` instead. That way the behaviour of the capture-by-value will be immediately obvious to anyone who looks at the code.
http://www.copperspice.com/docs/cs_api/signals-slots-c.html http://www.boost.org/doc/libs/1_61_0/doc/html/signals2.html https://github.com/pbhogan/Signals https://github.com/NoAvailableAlias/nano-signal-slot https://github.com/jeffomatic/jl_signal https://github.com/cpp11nullptr/lsignal https://github.com/Barath-Kannan/SignalsAndSlots (this is one I wrote)
First off, good job. For just being a month into C++, this is pretty neat! :) But, signals and slots are really a better design choice. I agree that trying to use Qt signals and slots is not worth it if you aren't using them for GUI-related events. However, as u/iamcomputerbeepboop pointed out, there are many signal and slot libraries available. The really cool thing about some signal and slot libraries is that they use std::function internally which allows you to do some really cool things including [argument contravariance](https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science\)#Contravariant_method_argument_type) (and if for some reason you need a return value from handlers, it supports [return value covariance](https://en.wikipedia.org/wiki/Covariant_return_type) too). In other words, you can make the following function: short Foo::bar(double value, std::string name); an event handler (slot) for the signal type: int(float, const char*) The *float* and *const char** get implicitly converted to *double* and *std::string* and the return type of *short* gets implicitly converted to *int*. That's really challenging to do on your own, but it does open up a lot of flexibility. The other thing that using std::function provides is that slots can be free functions, member functions, or even lambda expressions. And if you do choose to use a member function, there's no special base class to inherit from or any macros to use. *It just works!™* Anyway, creating such a signal and slot library is a bit challenging (though std::function makes it much easier). But if you didn't want to use one that already exists, I suggest studying the implementations so you can figure out how to roll your own. :)
&gt; is this the only case where arrays are copied element-wise? The default copying behavior for a user defined type's array members also does element-wise copying. This is why using a struct with an array member (such as `std::array&lt;T,N&gt;`) works so much more sanely than using raw arrays directly. struct S { int arr[10]; }; S s = {{1,2,3}}; S t; t = s; // copies the array 
Probably a noob question but why shouldn't he use new in examples?
&gt; Update: and this is a proposal for a new definition of memory_order_consume Also [this](http://preshing.com/20140709/the-purpose-of-memory_order_consume-in-cpp11/) is important link.
Sorry for asking such a question but where can I read more on event dispatching patterns? And what would the use cases be?
I always thought atomic variables and operations are left alone by the optimizing compiler. 
It's the "invalid program" part. Let those who have never introduced undefined behavior static_cast the first stone, and all that.
That's okay, I didn't really know either! But it seems like a good place to start is to look up the Observer design pattern and "signals and slots" as they are implemented in QT and elsewhere. Use cases include building GUIs with MVC pattern -- users generate events and send them to another object to be handled.
Sure, that would be nice.
That's true, the use of dynamic cast is not necessary... I was "paraphrasing" it from memory but maybe I made it worse! Still I prefer separate methods to a big switch statement.
I didn't benchmark, no, I guess I should! But Stroustrup says virtual function calls are about 25% longer than regular calls, plus I find it way more readable.
If you have control on the event types that your dispatcher can handle I would do it that way: http://coliru.stacked-crooked.com/a/03bb1122f5bd221e Your events can have unrelated types. You can also extend it to receive more than just methods, and just anything callable. Note that you still pay the price of a virtual call due to the type erasure of std::function. If you don't want to register manually all the types usuable by your dispatcher, here is another version: http://coliru.stacked-crooked.com/a/8e01b35ff5829f9b
&gt; AFAIK you can just static_cast if you know for sure what type is it. Doesn't work for polymorphic types with virtual bases.
`{}` is not a valid initializer in C. If you enable -pedantic, gcc will tell you "ISO C forbids empty initializer braces".
Right.
I did not know that actually. Thanks! On the other hand, i think that in such simple case like here, we can work it out without using virtual inheritance in event subclasses.
In modern windows apps (UWPs) you can even bind c++ to xaml. Many of the in-box apps across win10 family are c++. - Steve, vc dev mgr
Yeah, the best approach to use heavily depends on what your needs are. My needs include not knowing what all the involved types are at compile time, but that's a rare scenario for most people.
You're right. My bad. The 32-bit Clang compiler [arrived with Seattle](http://docwiki.embarcadero.com/RADStudio/Seattle/en/What's_New).
The exact same use cases as `std::vector&lt;char&gt;::data()`, which got even more support in C++17 with `std::data`. EDIT: For a concrete example, C++17's [`std::to_chars`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0067r4.html) is a perfect candidate for `std::string::data()`.
The better question is, like, what you wanna even _do_ with templates, man? Like, what are you trying to solve?
Yeah, I found Eclipse was pretty terrible for C++. I was using Nvidia's fork, Nsight Eclipse edition, and it was just terrible. For some reason, the IDE didn't recognize inherited methods. I've now since switched back to juCi++ and CMake.
&gt; Are the type of basic quick fixes that Eclipse provides for java just not in demand when developing C++? Was it deemed too complicated to implement? There is demand for it. Someone just needs to do the work of implementing it. Keep in mind that Eclipse is an open-source project; the person contributing the feature could be you!
And make_shared and make_unique.
Thanks for the link!
Absolutely. As a sidenote, `std::make_unique` is available only in C++14 and onward, not C++11. If your compiler supports only C++11, you can add your own `make_unique` as follows. template&lt;typename T, typename... Args&gt; std::unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args) { return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...)); }
Wow this is awesome, I didn't know about it. I'll replace all my ugly std::tuple stuff with hana :D Why is there only `eval_if`, `if_` and `while_` though? I need `switch_`! I guess I'll have to build my own \^\^
Looking at boost.log even more critically...
I'm a dev working on the Visual C++ for Linux Development. It can be made to work with clang, we added that feature recently, it will be available in the next release, 1.0.5. Regarding lldb, that is currently not supported, the debugger team has that on their backlog, no date on when that will be available yet.
&gt;Do not use eclipse for c++. It's just quite bad at it. Even when you're used to the ide, it makes things harder than they need to be. Really? I've found CDT to be quite useful for developing C++. The largest hurdle in my experience has been getting the indexer to do its job. That sometimes requires manually editing the include paths for things like Boost, MPI, TBB, etc., but that needs to be done just once for each project (which can be a pain with lots of projects, admittedly). It's C++14 support is partially lacking, but the CDT team is working on this for the next release. In my workflow, I use several different languages (e.g., C++, C, Fortran, Python, Perl, Bash, assembly, gmake, and autotools) and being able to work on them all inside of a single interface is an absolute must for me.
nsight doesn't keep up with the standard Eclipse release schedule, so it's running on a very old version of Eclipse. I am unsurprised you had a bad experience with it. I really wish they had just made a plugin for CUDA rather than trying to make their own IDE.
&gt; The largest hurdle in my experience has been getting the indexer to do its job. Right, I never figured out a systematic way to make it grok C++11. Making it work involved a lot of semirandom clicking (as suggested by various blog posts) around various settings, but I couldn't make it work after recreating the same project in another location. I just switched to Netbeans; also setting up remote builds with NB is sweet easy. I also think NB's gui is way better than Eclipse's SWT/GTK ugliness.
... seriously?
1 has been largely superceded by constexpr (which most often compiled faster than templates and is more normal-looking C++)
Sadly they missed the s instead of the a.
Not sure why the article's named that way. It's about initializing arrays filled with 0's. I expected something about `memset(ptr, 0, size)` being optimized away. TL;DR for code compiled with VC++: &gt; What I want to do at this point is to recommend that all C++ programmers prefer “= {};” over = “= { 0 };” when initializing structures and arrays. I find it aesthetically superior, and it looks like it almost always generates smaller code.
[This video](https://www.youtube.com/watch?v=Am2is2QCvxY) I know, learning from videos sucks. But this one is an exception. Imho it is one of the best tutorial videos about programming i have ever seen. Perfect pacing and so many aha moments.
Great video. Thanks. :)
Clickbait headline, trivial content. 
I think it's fine. It's okay to try to generate a bit of attention to this kind of stuff, especially when you submitted a bug report for it 6 years ago and the compiler is still producing embarrassing results.
LLDB - no. Now I use it in my work with clang and remote gdb :-)
The [C++1z implementation status](http://clang.llvm.org/cxx_status.html) page for Clang says "no" for [P0127R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0127r2.html) The [C++1z Support in GCC](https://gcc.gnu.org/projects/cxx-status.html#cxx1z) page doesn't even list P0127R2 (or its predecessor P0127R1).
thanks for the links ! 
And it's on VC's list of stuff to do, but we haven't implemented it yet (there are higher priorities).
See [this proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0223r0.html). 
Thanks! Makes sense now. Had no idea about the existence of `std::atomic_signal_fence` :) 
Thats really cool. CppCon is getting better every year :)
&gt; A general purpose C++ runtime system for parallel and distributed applications of any scale from https://github.com/STEllAR-GROUP/hpx
It's a form of aggregate initialization that has been in C++ since before it was standardized.
Did not know that - thanks.
&gt; I am unfamiliar with the ={0} method. It's C-style code. C doesn't allow initializing structs and arrays with empty braces, so C code uses braces with a single zero. People used to that style then do the same thing in C++. &gt; Seeing it I would assume it would only set the first element, not the entire array. Is that behavior even in the language spec? The single element in the braces does only set the first element of the array/struct. The remaining elements are value initialized. Many developers have been tricked into thinking that because `int arr[10] = {0};` zeros all the elements, doing `int arr[10] = {1};` will initialize all elements to 1, but that is not the case. Only the first element will be initialized to one, and the remaining elements will still be zero. This is all clearly defined in the C++ language spec. 
From the link in the comment you replied to: &gt; Hana is a header-only library without external dependencies (not even the rest of Boost).
Hartmut, do you really need to adorn us with every minor point update of what is essentially your deviled egg? There are so many C++ libraries on the net, could you imagine every time someone has a brain fart of an update for their pet project they decide to post a note on this subedit - the noise we'd see? Let's assume for simplicitys' sake that the two to three guys that follow your project do so directly via its repo or blog and leave it at that. 
Thats was just an expression optimizer, kind of a proving ground for their rework. I would rather not judge the final results by it.
Well there's a strawman opener if I ever saw one... State the real question, don't beg it.
Come on, there aren't too many steps in it... `size_t to_chars(char *first, char *last, T value, int base = 10);` 
Show something better, then propose it as an improvement to the previously linked paper. Otherwise this is empty, and from my view naive, criticism.
I'm curious how they each compare to std::array's constructor (the C++11 way of doing this).
It took me entirely too long to figure out this wasn't an ad for a tool for turning JSON. I need more coffee (or maybe just to spend less time in JS)
&gt; &gt; &gt; It would be nice to repeat the test when the SSA based optimizer comes out though. why wouldn't they just contribute to clang... ?
It's interesting, but I figured the compiler would have an optimization that treats `={0}` as the equivalent to `={}`. I mean it's so pervasive in C and C++.
&gt; tfw your library gets mentioned :D :D :D :D :D
I'd say the latter
Let's take the [full quote](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.103.6084) in context: &gt; We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3% My take on this quote is that you should focus your performance decisions solely on the parts of the code that are going to affect your critical path. In other words, you should worry about algorithmic complexities (O(n) vs O(n^2) or other macroscopic effects (e.g. cache-friendly algorithms, optimization level of compiler, etc). Focusing on `++i` vs `i++` or `{0}` vs `{}` is pre-mature optimization because it's highly unlikely to impact the critical path through the code. The `i++` vs `++i` case is a little controversial because there are corner cases where it can be degeneratively expensive, but IMO that is extremely rare &amp; unlikely to actually matter enough on the hot-path to worry about initially. Everything else should be deferred to optimization passes later on once you've profiled the code, understood the bottlenecks, addressed them &amp; verified the performance increase. 
Techniques discussed on the boost mailing list related to Hana helped me optimize some of my templates for Sol2 (though Sol2 still needs a LOT of work to compile faster). Thanks for the work you've done!
I agree with all of this. I think we're more aligned than opposed. 
I am personally an advocate of deferring optimization, so I completely agree with you. But, I do think that things that cost nothing to do, and may generate better code are not premature optimization and should just be automatic. One example: pass by const ref should be the default for anything bigger than a pointer because it's probably going to be faster the vast majority of the time. You wouldn't advocate pass by value by default would you? What is a valid example of prematurely optimizing is passing out parameters by reference instead of as a return value because there is a cost in messing up the interface for probably 0 gain.
It's mostly an oversight (feel free to create a GitHub issue if you need that functionality, and it might be added (by me or another contributor)). However, keep in mind that `eval_if` and `if_` will be replaced by `if constexpr` in C++17.
It's all right, just nothing like c++ using any of the common semantics. 
I'm really glad it was helpful to you! FYI, you may also find it useful to follow the development of the [Brigand](https://github.com/edouarda/brigand) metaprogramming library (if you don't already). They work very hard in optimizing the compile-times of pure-type computations, and so far they are definitely the fastest compiling metaprogramming library around (although it's limited to type computations).
You have to write *something*. You can't decide that since you don't know whether `= {}` or `= {0}` will be faster, you're just going to write neither of them until after you've profiled. Defaulting to `= {}` doesn't mean "go through your codebase and change everything" or "reject any new code which introduces `= {0}`". It just means that when you have an option which might be better and has no downside, you might as well just type it and not the possibly worse one.
I worry about things as trivial as `{}` vs `{0}`, but not because of performance – the latter is an unidiomatic C-ism that has no more place in a C++ codebase than does `typedef`ing every UDT to bring them into the enclosing namespace.
That's fine. As I said originally. I have no problem with preferring one over the other for stylistic/code health reasons. My point of contention is that the article tries to justify it with one about performance which is misguided IMO &amp; just helps perpetuate this notion that micro-benchmarks (particularly specific to 1 compiler on 1 machine) are useful or should in any way influence what amount to stylistic decisions.
Slides are here: http://modern-cpp-examples.github.io/match3/cppnow-2016 Code is here: https://github.com/modern-cpp-examples/match3 Game is here: http://modern-cpp-examples.github.io/match3
The CUDA cmake scripts, which includes cuda_add_executable, is in FindCUDA.cmake located in your cmake install. I could not find anything regarding this issue, so it might help ask on a cmake forum or create an issue at the cmake project. However, I managed to work around the problem by copying an compile_commands.json file I had created for another project into cuda-stuff/build. You can then add parameters there, like additional include directories. libclang would then find the needed parameters to successfully parse C/C++ source files. Note that after manually editing compile_commands.json, any C/C++ file would have to be reopened for the new parameters to take effect. You can get a simple compile_commands.json by creating a new C++ project in juCi++. The compile_commands.json file will then be located in the build folder. edit: I corrected the second paragraph. 
Yes, watch that video. Seriously! Walter Brown is the father of template meta programming
The constructor was made "conditionally explicit". There was a good SO question on the topic of you want to read more, and cppreference has the change noted as well.
VC bullshit strikes again. Really it is compiler specific nonsense.
Diving into the deep, dark, murky depths of C++ Template Metaprogramming are you? Might be worth looking into these: http://en.cppreference.com/w/cpp/language/template_specialization http://en.cppreference.com/w/cpp/language/partial_specialization http://www.derivativesinvesting.net/article/554081016/c-11-simple-compile-time-calculator-with-constexpr/
I fully share your opinion, I has chosen to implement my own socket abstraction layer for small size and fast compilation (and also just for fun), but for reasons which you mention above, I have to use to boost, that's the only way to avoid many troubles in the future, so soon I will migrate backend to asio. Btw, the only platform dependent part is sockets abstraction layer, which consist from 2 classes (maybe more in future), so porting to another OS is consists from providing these two classes for specific platform or just rewriting them as wrappers of another library
Nice try! I suggest to use POCO because it has network and Json components all in one, so it's easy to have only one dependency
&gt; This was prompted by /u/davidmillington, who should hopefully be okay with me quoting... I'm famous! No, seriously - good stuff. I'll add some flair myself. Glad to see it was a good suggestion.
By underwhelming I mean not worth looking at. The slides are just labels of the sections of his talk. They literally just say 'compiling', 'debugging'. It isn't a mistake, just not worth anyone's time.
https://i.imgur.com/GkeIpzD.png https://i.imgur.com/HRE9TB3.png These _literally_ just say 'compiling' and 'debugging'... /s
&gt; In order to label something as an error and offer a quick fix, you need to be pretty sure that it's really an error and not a false positive, else you just annoy the users. Eclipse is already labelling a lot of these scenarios as errors, adding quick fixes to those error notices doesn't really increase the annoyance value - if it's a false positive you're already annoyed even without it but if it's an actual problem you make it a lot easier for the developer to make the necessary changes. &gt; You also need to be pretty sure that your quick fix really solves the problem, or else again it just eventually gets dismissed as noise. Just like the java variant, the solutions offered don't necessarily have to always be useful. If you look through the gallery I linked, some of the suggestions like "add a type parameter to main(String[])" or "add a cast to [your freshly created on the previous line] p" aren't especially helpful, but if they're helpful at least some of the time then they're worth putting right there next to the error message where the developer can hit it when they read the error message if they think it's the right course of action. Since I posted this I've been having a play with CLion. The price and licensing model is somewhat prohibitive but it really does do for C++ quite a lot of what eclipse does for Java. It's a little less good at the "close but not quite" suggestions (i.e. Mytype vs MyType) but as far as CMake aware refactoring, generate-from-usage style of writing code, and good indexing/documentation, I'm really liking it. The clang-based tool you suggest sounds interesting, I'll take a look and see how friendly it is. Clang integration does in general sound like a good way to go, but that's more about error detection rather than offering the necessary refactors/code changes to fix it, which is more of a separate issue, and it's this latter part eclipse is missing more than the former, but we'll see what comes with time.
wow, thank you for pointing...
It offers exactly the fixits that the clang frontend itself offers. Anytime you see clang suggest something to you when you hit a compile error (missing semi colon, misspelled name, etc), that shows up directly in vim/emacs. I have used CLion and I just don't agree with your assertions. It's just another third party parser. With Java, the tool you use to compile your code and the tool that's giving you errors and fixits are one and the same. With CLion, there are still false positives, and even more so false negatives. You can't offer a correct fixit if you don't know whether or not there's an error. With clang, the error generation process is the same process that actually compiles your code. If there's no red dots, it compiles. If there are red dots, it doesn't. The red dots update every second. There's just nothing that can beat that. As far as refactoring goes btw, you have access clang rename from inside emacs via rtags, not sure what else clion is offering these days. There are a few things that are better in Clion like include management, but nothing can touch the red dots. Plus it's a huge shame that CLion committed to CMake. clang based tooling is based on compile_commands.json, which is strictly better as one can generate these files effortlessly for CMake, but also do it for other build systems (with varying amounts of effort).
Is it only for C++ related jobs? Can I set mine as "Game Developer" for example? Might be relevant for some discussions.
That's totally fine. Indicates what kind of experience you have.
For makefile projects, I found the following to work reliably: in Project Properties -&gt; C/C++ General -&gt; Preprocessor Includes etc. -&gt; Providers -&gt; [Your Toolchain] Built-in Compiler Settings, uncheck "Use global provider shared between projects", and add "-std=c++11" to the "Command to get compiler specs". (Then rebuild the index.)
https://github.com/hakimel/reveal.js/
Great!
Awesome work -- good looking descriptions. I have two suggestions (advanced usage only). These come from me doing *way too much* work on Bloom filter optimizations and compression and are probably irrelevant for the normal use case. Feel free to ignore me. **Better distribution for large number of `numHashes`** A major issue with double hashing (the algorithm in `nthHash`) is that when you're using a large number of hash functions (what constitutes "large" depends on the number of bits in the filter), bad values for `a` and `b` will ruin the FPR of your Bloom filter as common results of the multiplication operations will be hit more often than others. Ideally, your hash function will *not* give bad results, but I've seen things. If you want to test this out, change your implementation to a counting Bloom filter (make `m_bits` a `std::vector&lt;char&gt;` and use `++` instead of `= true` in `BloomFilter::add`) then print out the counts. In an ideal world, there will be very few values above 2, but you might be surprised (or not, depending on your data set). This is surprisingly easy to fix. Instead of double hashing, use a PRNG from `&lt;random&gt;`. It doesn't need to be advanced -- `std::minstd_rand` works well enough in my experience. It requires a bit of refactoring (since it is really inefficient to pass `n` repeatedly). template &lt;typename T, typename THash = std::hash&lt;THash&gt;&gt; class BasicMixer : private THash { std::minstd_rand m_rng; std::size_t m_bitCount; BasicMixer(const T&amp; val, std::size_t bitCount) : THash(), m_rng(THash::operator()(val)), m_bitCount(bitCount) { } std::size_t operator()() { return m_rng() % m_bitCount; } }; Then, you use it in `BloomFilter::add` (also `BloomFilter::possiblyContains`): void BloomFilter::add(const T&amp; val) { BasicMixer&lt;T&gt; mixer(val, m_bits.size()); for (int n = 0; n &lt; m_numHashed; ++n) { m_bits[mixer()] = true; } } The use of a LC PRNG gives slightly better bit distribution, which might mater. **Improved cache hits.** One of the biggest problems with Bloom filters is they completely thrash your cache. Since an ideal hash function jumps around memory in a random-looking fashion, your CPU will spend all its time waiting on bits to load from memory. Luckily, there's a cool paper titled ["Cache-, Hash- and Space-Efficient Bloom Filters" (PDF)](http://algo2.iti.kit.edu/documents/cacheefficientbloomfilters-jea.pdf) which helps you solve this problem (and not lower effective FPR). The simple idea is that you have to pick a region and then update all the bits inside that region together. I like my regions to be 512 bits wide, since the cache line size of your typical CPU is 64 bytes. Luckily enough, with the same "mixer" pattern from earlier, you can get whatever you want! template &lt;typename T, std::size_t KSubAlign = 512, typename THash = std::hash&lt;THash&gt;&gt; class CacheFriendlyMixer : private THash { std::minstd_rand m_rng; std::size_t m_baseOffset; CacheFriendlyMixer(const T&amp; val, std::size_t bitCount) : THash(), m_rng(THash::operator()(val)), m_baseOffset((m_rng() % (bitCount / KSubAlign)) * KSubAlign) { // Memory access violations later if this isn't true... assert(bitCount % KSubAlign == 0); } std::size_t operator()() { return m_baseOffset + (m_rng() % KSubAlign); } }; Of course, if you *really* want the benefits of this, the contents for `m_bits` need to be 64-byte aligned. Depending on your memory allocator, you might just get lucky, but I like to assume that anything that isn't guaranteed by some standard is out to kill me. A thorough implementer might rely on the Intel AVX instructions to perform cache-bypassing reads and writes. Different elements are always accessing different cache lines, so the cache is usually not helpful at all and you don't want to ruin it for other threads. The technique is to load a block locally and give the CPU a hint to bypass caches (using a `_mm256_stream_load___` intrinsic) and then do the calculations on the loaded block. Again, you can see some pretty major performance increases with this technique, but it is way more of a pain in the ass than you might hope.
You should really have a look at Vittorio Romeo's [Implementing `static` control flow in C++14](https://www.youtube.com/watch?v=tMuXZkPiVOY) presentation. However, keep in mind that I want Hana to be backwards compatible between minor version numbers, so if you submit an `if_`/`else_if` construct it has to be backwards compatible (and not too penalizing at compile-time). Otherwise it'll have to wait for the next major version, but that next major version might use C++17's `if constexpr` instead :-).
Should use `std::bitset` instead of `std::vector&lt;bool&gt;`
Sure. Although I personally feel that "C++ Committee" is too vague and that specific working groups are more informative, but I am definitely not a typical person.
I had him RES-tagged as 'THE'.
Direct link to schedule: http://meetingcpp.com/index.php/schedule16.html
I can also advise you to use boost::property_tree instead of JsonCpp. Much easier to work with imo.
Isn't the size based on the required error rate ? I think that mathematical formula can be computed at compile time if the needed error rate need not change dynamically 
Wow, he is even reluctant to fix the typo pointed out by somebody else. That's an Ego indeed.. :)
My new job is working with win32API and MFC, so I kind of don't have a choice but from what I've seen that's the general consensus of MFC.
Agreed. I work with MFC everyday and there are so many better frameworks. Like sumo952 said, QT is a great choice. That being said, MFC has not evolved much in the last 5+ years. Almost any reference material will be fine. Remember it's a wrapper class around the part of Windows that hasn't changed dramatically since the 1990s. 
MFC is a pretty thin C-with-classes layer over the Windows API. You're better off just learning the WinAPI itself, then MSDN docs should be enough to get you going with MFC.
&gt; The complier is completely free to use the same function addresses for functions that contain the same binary code. Actually, the C++ standard forbids this explicitly; it just so happens to be a common optimization useful for people who don't rely on correct behavior.
Be careful: You are living in a world that is &gt;15 years on the past. Worse so, if you are learning C++ also with MFC, then the MFC programming style even has the potential of ruining your programming skills forever. You've been warned :-) PS: I currently also need to do MFC from time to time, and it couldn't be worst ;)
Thanks for the responses, all. I'll only be working with it from time to time hopefully, and by the sounds of what you guys have said I hope that's most of the time! 
my condolences - I was in the same position last year....in hindsight, it would've been far more efficient to rewrite the whole thing from scratch in Qt or in a Java based GUI framework than to waste all that time I spent hacking up MFC and creating custom MFC extensions
Professional MFC Visual C++6 by Mike Blaszczak Is/Was pretty much the defacto standard
No problem, hope it helps you. After 4 months of developing our final project with UE4, my opinion is that you can't try to dive into many parts of their source code, because there are not human-readable parts, at least not nooby-humans like me xD but it's just like any other professional C++ codebase I've seen. On the other hand, it's not that hard to get used to it, since you can use Blueprints for everything and then find the way to translate it to C++ (mainly because, unluckily, most of doc and forum's posts use blueprints). My point is that you should learn the basics of game's programming in 2D, with something like Cocos2d-x, and then get to 3D.
Just read that back and it didn't make sense at all aha, hopefully I'll rarely be working with it :).
Constexpr functions work only with arguments known at compile time. To my knowledgte, it cannot help to accelerate manipulation of tuples. 
Tuples themselves can be `constexpr`, so why wouldn't you want to be able to access their elements in a `constexpr` manner (just like `std::get` allows)?
Doesn't the "both represent the same address" part make it conforming, since merging the functions results in the pointers to two different functions representing the same address? Just looking at that sentence in isolation my interpretation would be that it's covering the inverse case of being able to form pointers to different addresses which nonetheless point to the same function. If the third clause isn't supposed to apply to function pointers at all then it seems like very poor wording.
What makes the first edition better than the second?
To me, the only good reason is to be able to return images from function without triggering a deep copy. But with move semantics (and guaranteed copy elision), it does not hold anymore.
&gt; This led to the many IDEs that developers favor today, such as Visual Studio, Xcode, and IntelliJ IDEA. Personally, I think that none of these IDEs can compare with Smalltalk's IDE in simplicity, elegance, and velocity of development; the original is still the best! yea, no
That sounds good. I'll say apart from that little nitpick, your library seems pretty well thought-out. Good luck!
Sadly, while I'm an enormous fan of Smalltalk, there are inevitably a number of errors... 1. "Smalltalk introduced the world to the language virtual machine" - quite simply wrong. For example BCPL used "O code", in the late 60's. 2. "Smalltalk also pioneered JIT (just-in-time) compilation" - wrong again, that was Self, a Smalltalk derivative that also introduced prototype-based inheritance. 3. "From the very beginning, Smalltalk had closures, which are lexically scoped first-class functions." Actually, it had blocks, that are very similar to closures, but not quite the same. Particularly, they didn't close over their environment - it was not safe to return a block that accessed variables from their environment, as they may no longer exist when the block was executed. Later variants fixed this. 4. "Smalltalk was the first language tool to support "live" programming and advanced debugging techniques such as on-the-fly inspection and code changes during execution." Again, wrong. LISP did this much earlier, and was a heavy influence on Alan Kay in the development of Smalltalk. 5. "Smalltalk made "duck typing" a household word" - actually "duck typing" was coined much, much later. Smalltalk and LISP both used it, but I think the phrase arose first in the Python community I think. That's pretty rich for their first few paragraphs. Overall though, I think Smalltalk was pioneering and, like learning functional programming, can change the way you approach coding, especially OOP. 
C++ had RVO before C++11 and move semantics, no?
I think copy on write is hard to implement in practice, but having the image itself be writeable, movable and explicitly copyable, while also providing separate views that are read only would be the absolute ideal solution, I believe.
Yes
So I guess I don't understand the post from /u/matthieugarrigues which suggests that shallow-copy-objects are good for returning them from functions, especially before move semantics was part of the language.
I'd argue that it's less about the benchmark (which isn't really that significant, especially as it's using VC++), and more about the semantics. Using `{0}` to zero-initialize a whole array is semantically weird, because it explicitly sets the first element to 0 and then zero-initializes the rest, rather than `{}` which idiomatically zeroes the whole array. I think it's more about intention than anything else. If your intention is specifically to use the first element as a zero and you just want the rest blanked, `{0}` makes sense. If you just want the whole array blaked, `{}` makes most sense. Your code should convey intention as much as it possibly can.
It used to be an optimization, that might or might not happen. If it didn't, you ate a copy. Nowadays the worst case is a move, which is generally much cheaper, and with C++17 some cases of RVO are now a language feature -- it must happen, no matter what the compiler thinks.
Even if the address was taken, the body can still be folded - one just have to insert some nops (or jumps) so that each function can be at a different address.
I would start a transition by first using a C++11/14 compliant compiler...
Question, do I need to put pragma once in my c or cpp files, or only .h files?
`constexpr` functions work at run-time *or* compile-time depending on whether the arguments are themselves `constexpr`. With that in mind, there is no reason why all pure functions (and constructors!) shouldn't be `constexpr`; it's free performance where possible with no overhead where not.
Indeed, the problem there is that it's _only_ compile time. It's easy enough to add some syntactic niceties like operator overloads to `std::ratio`, template&lt;std::intmax_t A, std::intmax_t B, std::intmax_t C, std::intmax_t D&gt; constexpr auto operator+(std::ratio&lt;A,B&gt;, std::ratio&lt;C,D&gt;) { return std::ratio_add&lt;std::ratio&lt;A, B&gt;, std::ratio&lt;C, D&gt;&gt;{}; } but we probably also need a specialization of `std::ratio` that allows taking non-constexpr values to get to something that's more generally useful.
I think the ideal would be that the *library* be able to use either, more or less interchangeably. For the *presentation*, however, I'd pick one and talk (almost) exclusively about it, with the exception of a short mention that the real library also supports the other. For the presentation, I'd probably use the one that's in the current TS. 1. What's standardized is likely to be closer to this. 2. It's less verbose, so it does less to distract from the real subject at hand. 
Thanks for your insight.
What about runtime?
Single-header vs single-Operating System
No, and I get that this is part of the problem. I'm simply pointing out that it exists.
I totally agree. A class with `constexpr` members would be much better IMO. It's unfortunate that when you need the functionality at runtime, you have to turn to a library or writing it.
Your `switch` statements look fine. In one of your loops, you're checking against `sizeof(opts)` instead of `opts.length()`.
I've since updated it as somebody else mentioned that, but it didn't change anything. Does anything else look off?
I mean... is the second switch statement in the wrong spot or something? I'm so lost.
It's too bad it doesn't support `constexpr` on the mutating operations. You [can since C++14](http://coliru.stacked-crooked.com/a/59658748c1f78175).
I don't see anything obviously off. Try adding some `cout`s after each step and make sure it matches what you think it should be doing. 
I'm so damn lost, and this is due before tomorrow morning... After printing out the buf.st_mode and the mask after changing it, I notice that it didn't change the mask at all... 
Hmm... well, after printing out the mask and the buf.st_mode, they are the same even after I thought I changed it. But the switch case where I bitwise OR with the mask and change it is entered... so I'm lost, and not really experienced with gdb.
I guess the next thing would be to just add a cout before and after the mask in the 'u' case. And, ruling out the obvious - as /u/PurpleOrangeSkies mentioned - are you sure the bit you're setting in the mask, isn't already one of the bits set prior to your program being run? Looks like S_IRUSR on most machines is 0x0400. Could you reply with the values of st_mode, S_IRUSR, and mask (after the mask)? Also, just so I know your method - how did you verify the doR switch statement was being entered? cout?
Fix your formatting. You declared `fonk2()` as taking a pointer to int as its parameter, but you're trying to call it as `fonk2(x)` where `x` has type `int`. Also, if you are actually compiling this as C++ and not as C, then you will need to either reorder the functions or provide prototypes, because C++ does not have implicit prototypes. Although you should not be using that feature if you're compiling as C, so do this anyway. This is a subreddit about C++, not C. And it's not for questions, that's /r/cpp_questions, but if you're actually writing C then you shouldn't post in a C++ forum. 
I agree, but it's often the easiest way to do something. If I want to use an `optional` class but can't rely on `std::[experimental::]optional` being present, then I can either i) add a dependency on Boost.Optional, or ii) find a nice [single header implementation](https://github.com/akrzemi1/Optional) that I can just copy and paste into my sources (changing the namespace so it becomes "mine"). If I have no other dependencies then the latter is vastly easier both for me, and anyone else trying to build my software. Really, this comes down to the fact that unlike most other major languages, C++ does not have a de facto standard package manager like Pip or Cargo or what-have-you. I know that there are a few available, like Conan and Hunter for example, but none of these have reached critical mass yet, in contrast to the way CMake has become the de facto standard build system. The failure of BiiCode was a major blow in this regard, as it made a lot of people (like me) wary of trusting a third party service. 
`bind` is from TR1, which was published in 2007 – not a C++11 feature.
I suggest this tutorials: http://www.functionx.com/visualc/index.htm 
Because OpenCV is a fairly badly engineered library, full of cruft, piled on features, inconsistent APIs and implementation, and questionable design decisions.
OP here, I realize the code isn't realistic. I boiled it down to the smallest example I could come up with, but here's the actual function I was trying to write. To help people understand the motivation if anything. boost::expected&lt;Window, std::string&gt; // I also tried just "auto" here, doesn't work make_window() { auto const title = "Hello World!"; auto const flags = SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN; int const x = SDL_WINDOWPOS_CENTERED; int const y = SDL_WINDOWPOS_CENTERED; auto const height = 800, width = 600; auto raw = SDL_CreateWindow(title, x, y, width, height, flags); using WindowType = SDL_Window; using WindowPtr = std::unique_ptr&lt;WindowType, decltype(&amp;SDL_DestroyWindow)&gt;; class Window { WindowPtr w_; public: Window(WindowPtr &amp;&amp;w) : w_(std::move(w)) {} // movable, not copyable Window(Window &amp;&amp;) = default; Window&amp; operator=(Window &amp;&amp;) = default; Window(Window const&amp;) = delete; Window&amp; operator=(Window const&amp;) = delete; // Allow getting the window's SDL pointer WindowType* raw() { return this-&gt;w_.get(); } }; if (nullptr == raw) { auto const fmt = boost::format("SDL could not initialize! SDL_Error: %s\n") % SDL_GetError(); return boost::make_unexpected(boost::str(fmt)); } WindowPtr window_ptr{raw, &amp;SDL_DestroyWindow}; return boost::make_expected(Window{std::move(window_ptr)}); }
Indeed, I completely forgot this one, it is actually used in imageNd::subimage
MS released a "free" (as in for non-commercial projects IIRC) and easily downloadable VS Community Edition a year or more ago. If you really do not have _any_ Windows license whatsoever, if you're at a Uni, you can get it from Dreamspark. If not you can use AppVeyor CI. Of course it will be a bit tedious to fix problems with VS this way. But a good library is supposed to have CI for at least Linux and Windows anyway. I know it can be inconvenient, particularly if your main development OS is not Windows, but as long as VS is still not 100% C++14 compatible, I restrict myself to the features that are available on the latest VS version with the latest update. If you don't use advanced expression SFINAE or relaxed contsexpr then this means you're not really restricted at all actually. It's a minimal additional effort but it makes every Windows user and developer happy. In any case as dodheim pointed out VPP might already work or be close to it, if I find some time I might try :-)
You don't need to use make_expected for your return value, the implicit constructor does this, you only need to do it for unexpected. You should only need it if you want to use it with auto, and a few use-cases
And yet it is a de-facto standard for this kind of operations. Do we have any better library for that?
&gt; std::shared_ptr doesn't give you a way to store different sizes for each owner. Actually, shared pointer has something like that, it is called an 'aliasing constructor' [(number 8 here)](http://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr). It allows to refere to the control block (and thus the reference counter) of some other shared pointer while storing the different pointer to data. This way you can have shared pointers to views all refer to the control block of the actual data storage. It is not exactly you want in this case (pointers to views are unmanaged that way, so you need some other mechanism of deleting them), but sometimes can be very useful. For example you can store a pointer to the element of some data structure using control block of the whole data structure. 
I have questions more about process. I'm so far out of the loop on common C++ development practices. How did you test on all those different platforms? Did you use Travis or another continuous integration tool? Why didn't you add configure CMake to download Catch?
It _is_ thin, in that it offers very little abstraction over the WinAPI itself except for having a C++-with-classes API rather than straight C. I never called it a "wrapper", and I didn't use the word "lightweight" for a reason.
Well, I don't know whether my development practices are all that common! But I'll answer as best I can. For testing, I happen to have a Macbook Pro which dual-boots OS X and Windows 10 on the internal SSD (via Boot Camp), and I have an external hard drive from which I can boot into Fedora 23. On OS X I have access to AppleClang (via XCode), and LLVM Clang 3.7, 3.8 and GCC 6.1 (all via [Homebrew](http://brew.sh)). On Linux, the system package manager gives me GCC 5.3 and Clang 3.7 (using libstdc++ rather than libc++). On Windows, I have [Visual Studio Community 2015](https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx) with the ["Clang with Microsoft Codegen"](https://blogs.msdn.microsoft.com/vcblog/2016/01/20/clang-with-microsoft-codegen-january-2016-released/) package (which can compile things like Range-V3 that standard MSVC currently has trouble with), and [MinGW](https://nuwen.net/mingw.html), which contains GCC 6.1 and a few other things. Now that I think about it, that's an awful lot of different compilers! I haven't got any CI for this project yet, although I really ought to get around to setting up both Travis and Appveyor. I've used them for other things and once they're set up, they're very very useful (if only so I don't have to keep rebooting!). But the initial bootstrap process -- edit .travis.yml, commit to git, push to github, wait for build to fail because of a configuration problem, edit .travis.yml, etc etc... -- is so tedious that I haven't put myself through it yet. As to why `catch.hpp` is included, it's because that was the easiest way to get started, and the easiest thing for anyone who clones and builds my project. CMake's ExternalProject has problems whereby it can sometimes generate paths which are too long on Windows(!) which I've been bitten by before so now I avoid it. I could have used a Git submodule I suppose, but there doesn't really seem any benefit -- I don't want to track Catch master anyway, so switching the submodule commit from one release tag to another is basically the same as downloading and committing a replacement catch.hpp.
I think the first goal of OpenCV is to solve as many problems as possible, and then, when possible, use a good design. It's a completely different approach that seems to work. Let's see in 10 years if another lib has taken over :)
Thanks for the answers!
Lines 75 to 80 are useless though.
&amp;
Do you know boost.Fiber? It has just become a official boost library and will be added to the next release. https://github.com/boostorg/fiber It is based on Boost.Coroutine and exposes the primitives you can use to implement a go style concurrency, for example: http://olk.github.io/libs/fiber/doc/html/fiber/synchronization/channels.html
Quick! Someone go and tag everything as a duplicate so it can match the rest of stackoverflow
Yeah, the compiler is being kept at a particular version. But we still wanna, say, walk a directory. May as well wrap up the code in a way that conforms to C++17 (or 11/14, whenever we wrote the feature). Later, when the compiler is updated the lib switches to the vendor version. Our code doesn't need to change.
I agree 100% with all you said. OpenCV is fairly badly engineered. Still it's the de-facto standard. Matthieu brought it to the point: It "solve(s) as many problems as possible, and then, when possible, use a good design". Big companies behind it doesn't mean it's well designed. It's the best we have, and hopefully it will improve. +1000 :-)
Yep, but there are better ways of solving this than to introduce reference counting on the image data (as OpenCV does). The reference counting introduces an unnecessary overhead that you can't escape.
[The preview (posted on July 11th)](http://cppcon.org/preview-algorithms-exceptions-games-2016/) said: &gt; The full program will be published next Sunday. Was that supposed to come out the 17th, or is it going to come out on the 24th?
It will be posted today. We were a bit delayed.
Awesome lineup. Looking through the program, I wish I could be in multiple rooms at the same time :)
&gt; Win32 with custom, lightweight C++14 wrappers Back in the late 90s, there was an interesting set of C++ Win32 wrapper classes ~~whose name I can't recall~~ from [Reliable Software](http://www.relisoft.com/Win32/index.htm). Do you know of any modern Win32 C++ wrapper classes? Merely for academic reasons, as I don't develop in Windows anymore. 
Does this really need to be a video? Seems easier to just read about, and it takes far less time: http://en.cppreference.com/w/cpp/language/fold
Neat idea. C++ introduces new concepts very gradually. Just look at `std::future`. There's no `next` method! This single omission makes it impossible to chain operations together--but then, I do kind of get it, because the whole addition of `std::future` was very ambitious to begin with. Though that said, have you considered writing up a proposal? You can submit it to the C++ standards body for consideration, that's how everything winds up in the standard.
&gt; Looking through the program, I wish I could be in multiple rooms at the same time :) Same here! :-)
Your definition of bind requires F(T) to return another std::optional. That's a pretty stringent requirement. Maybe you could do some overloading and SFINAE tricks so that you can handle an F(T) that doesn't return a std::optional. An alternative to your original code... auto a = do_something_useful( get_window_position(conn, get_focused_window(conn).value() ).value() ); If the value isn't present, you will get a std::bad_optional_access exception. You can write a non_member function similar to bind that does the same thing. Unfortunately, that results in syntax that feels "inside-out", with the last call to execute being the first call showing up in the code listing. I would recommend a name other than 'bind' though, as that is easily confused with the (mostly discouraged) std::bind facility. 
Cool, thanks. I only got approved for a 2-day visit (which I'm really looking forward to!), but want to see the schedule before I book a hotel (which I'm sure are starting to fill up). 
&gt; Your definition of bind requires F(T) to return another std::optional. That's a pretty stringent requirement. Maybe you could do some overloading and SFINAE tricks so that you can handle an F(T) that doesn't return a std::optional. Sure. The code I used for the function is just for context. &gt; An alternative to your original code... auto a = do_something_useful( get_window_position(conn, get_focused_window(conn).value() ).value() ); If the value isn't present, you will get a std::bad_optional_access exception. That's a nice alternative, but it breaks the design I want. &gt; You can write a non_member function similar to bind that does the same thing. Unfortunately, that results in syntax that feels "inside-out", with the last call to execute being the first call showing up in the code listing. I thought of writing an operator for that, but I feel it's not the correct way of doing things. &gt; I would recommend a name other than 'bind' though, as that is easily confused with the (mostly discouraged) std::bind facility. I agree. However, I took them from the std::expected proposal, and `map` and `bind` have different functionality (I can't recall the difference now). 
GitHub: https://github.com/networkprotocol/libyojimbo Made by the author of the following: - http://gafferongames.com/networking-for-game-programmers/ - http://gafferongames.com/networked-physics/introduction-to-networked-physics/ - http://gafferongames.com/2016/05/10/building-a-game-network-protocol/ - GDC 2015 talk -- Networking for Physics Programmers: http://www.gdcvault.com/play/1022195/Physics-for-Game-Programmers-Networking
So far as _precisely_ why they're missing... you haven't written a proposal paper to add them yet. :) Nothing gets added to C++ without someone putting in the work of writing a proposal and pushing it through. The authors of the original proposals either didn't care about the feature or didn't care to defend it at committee. Regarding _why_ the authors mightn't have cared (I can't speak for them), my take is that since C++ lacks many features to do `optional`/`variant` _well_ the current library types are just rough "good enough" approximations that will be out-dated, deprecated, and ignored once the language catches up (sum types, pattern matching, etc.).
And it was/is unusably buggy and slow. Wasted the first half year of the subscription on a totally unusable RADStudio with a broken compiler. Berlin is less bad, but still a productivity &amp; motivation killer due to numerous bugs, low compile &amp; execution speed and an extremely sluggish IDE.
Yes, it's horrible UX-wise. Using space rather than right arrow makes things more acceptable though, as it will navigate downwards when possible. 
Oh, by all means, I completely understand and respect that! Very convenient to just drop the file when it's no longer needed. I keep trying to use the std:: functions whenever possible, but they always end up being *so* much more annoying to use, I mean take this: std::optional&lt;std::reference_wrapper&lt;int&gt;&gt; get() { return x; } Versus: maybe&lt;int&amp;&gt; get() { return x; } And there's also performance implications ... I'm betting std::optional&lt;std::reference_wrapper&lt;int&gt;&gt; isn't optimized down to just one pointer of memory usage (with a nullptr counting as "no reference assigned.") std::function is similarly a nightmare when you want to bind member functions, so I wrote an alternative: function&lt;int (long)&gt; f; int Foo::test(long); Foo foo; f = {&amp;Foo::test, &amp;foo}; //this would be a mess with std::bind, std::memfn, etc. 
I would strongly advise against it, but you could override the global &gt;&gt; operator for optional&lt;T&gt;: // In case the object F has a return value template&lt;typename T, typename F&gt; auto operator&gt;&gt;(std::optional&lt;T&gt; opt, F&amp;&amp; f) -&gt; std::enable_if_t&lt; !std::is_void&lt;std::result_of_t&lt;F(T)&gt;&gt;::value, std::result_of_t&lt;F(T)&gt; &gt; { if (!opt) throw rude_exception{}; return f(opt); } // If it doesn't. template&lt;typename T, typename F&gt; auto operator&gt;&gt;(std::optional&lt;T&gt; opt, F&amp;&amp; f) -&gt; std::enable_if_t&lt; std::is_void&lt;std::result_of_t&lt;F(T)&gt;&gt;::value, void &gt; { if (!opt) throw rude_exception{}; f(*opt); } I didn't have an actual implementation of std::optional handy so this is an approximation, but it would allow you to chain your calls like this: get_focused_window() &gt;&gt; [&amp;conn](auto w) { return get_window_position(conn, w); } &gt;&gt; do_something_useful Again though, this is not really an approach I would recommend because of the potentially far reaching consequences of overloading an operator on a standard type.
Hello, I am working on a project that would allow to that automatically. So far it supports a lot of languages. https://github.com/fredlo2010/Json2Model Unfortunately I need help adding support for C++ (I have never programmed in it) if you are up to the task you can help me out by reading the reporting issues section.
Map wraps the result unconditionally and bind normalizes it so that you don't start with an expected and end with a nested expected.
Somehow this website crashes on me.
It's condescending regardless of how you quote it, try removing the work **actual**, additionally your actions in these reddit comments are just proving yourself as not very professional, rather then taking criticism and looking at improving things you've resorted to calling people trolls and taking offence to comments on what is bad code. And I don't really care what's on your resume.
What can you tell? That I don't have 15 years of professional experience, but have over 15 years of non-professional experience? I would hate to work with someone like you on a project if the way you approach feedback is to take offence and resort to "I'm right, I have XYZ years experience"
Quoting Gafferongames (aka Glenn Fiedler): &gt; Yes. I am well aware of overloading operator new. Are you able &gt; to read code well enough to understand why I chose not to do it that way? 
Quoting Gafferongames (aka Glenn Fiedler): &gt; This code is cut &amp; pasted from a sample. I can take no credit for it, &gt; and seeing as it simply walks across the set of network interfaces on &gt; a system, I think you can agree that it's not particularly... important? 
yeah, can't let ppl make dumbass comments and get away with it.
I'm guessing because no one wrote a paper for it. If you are inclined to do so, you should make it possible for people to lookup with a string literal as well... without creating a temporary std::string in the process.
I have more often seen operator | used for chaining / piping results together. It's still not something to do lightly though. It is very difficult to grep code for uses and definitions of overloaded operators. It is also very difficult to search online for documentation related to cleverly overloaded operations. C++ still gets lots of flack for hijacking the bit shift operators for I/O. Think hard before making an overload that doesn't obey pre-existing language conventions for an operator.
[direct link to the video](https://www.youtube.com/watch?v=VIuZakDjNkI)
I agree completely. It's absolutely a terrible idea and in more ways than one. Still, if it's for a smaller hobby project, I feel *some* shortcuts might be forgiveable.
I didn't find Bjarne's talk in https://cppcon2016.sched.org/... 
There are a few permissive open source alternatives for setting up a 'bare bones' Android application in C or C++ using a platform abstraction framework like Cocos. Some others are SDL, SFML and Allegro. I'm curious as to why MS picked Cocos2d and if anyone's really done a thorough comparison of the major ones. I've been using SDL so far but it feels rough around the edges. There's a fair bit of setup and the process to get everything up and running on Android isn't all that pleasant. Also SDL uses polling for events so I have a concern about battery life with it (but I haven't measured yet) I really wish there was a 'clear winner' amongst all these libs with really easy setup, active development, large user base, etc. I'd really love to be able to use a single lib and then deploy to Windows, Android, Linux, OSX, and iOS.
There also is https://github.com/vurtun/nuklear
I have done the same and much more than that, and it seems that we come to very different conclusions. The more I have looked at the library's internals, the more horrified I got. Certain things are impossible to modify or extract in there, because everything is intricately interdependent. Code organization is a mess. APIs are inflexible and old-school. Type safety is pissed upon ([Input|Output]Array, anyone? WTF.). The same runtime-typed(!) "matrix" class is used for both images and mathematical operations, when it shouldn't be. Compilation for mobile platforms is not properly documented. Technical debt just piles up. It just isn't written by software engineers who care for good design. And if you need ultimate performance (e.g. for mobile applications), you will *have* to roll your own library, no way around it. The only two reasons why people are using OpenCV are: 1) it has lots of features, and 2) there's no good open source competition. And, yeah, it kind of does the job, if one is willing to put up with it. Again, that's not a reason to stop criticizing it.
string_view&lt;&gt; isn't fully integrated everywhere in the library. This could have been an oversight, although it's possible there was a reason it was omitted. I'd ask on the [public reflectors](https://groups.google.com/a/isocpp.org/forum/#!forum/std-discussion).
&gt; The code example above would, hypothetically, look like this: &gt; &gt; auto opt = get_focused_window(conn) &gt; .bind([&amp;conn](auto w) { return get_window_position(conn, w); }) &gt; .bind(do_something_useful); If I saw this code I would wonder what it does (as it is not explicit/obvious). &gt; So, my question here is: why are those functions not in the std::optional design? Why do you think they should be? I would prefer not to have them in std::optional, for the following reasons: - monads are not necessarily a good fit for C++ (at least, not at the level where developers are in consensus about it) - it introduces a way to do things that requires you to understand other abstractions, besides std::optional (search "what is a monad" and see what you find - I _think_ I understand what a monad is, but I'm not sure according to whom - there are a lot of definitions for it "out there") 
I prefer this syntax, for solving the same problem: if(auto opt_col = optget(a, b, c)) return std::stoi(*opt_col); It's less code to write, simpler, more explicit, etc. It also only triggers value computations when there is a value, and it requires no extra abstractions.
Thanks, now it makes more sense...could I move the implementation to the source file this way, or it's still not possible?
Just call MiniDumpWriteDump manually? :)