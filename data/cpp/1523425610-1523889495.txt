Not a great interview question, but someone asked me to give all the permutation given a sorted string
I mean the this pointer is copied, but not the shared pointer. I don't really see the problem...
&gt; A way of quickly. mapping an enum to a value. Isn't a switch statement best for that? What else do you have in mind? &gt; Perhaps a nice way to use enums as vector indexes? You can implement your own class that does the cast inside the `operator []`.
1. static reflection proposal: enum E0194 { kFirst, kSecond }; using E0194_m = $reflect(E0194); using kFirst_m = get_element_t&lt;0, get_enumerators_t&lt;E0194_m&gt;&gt;; cout &lt;&lt; get_base_name_v&lt;kFirst_m&gt; &lt;&lt; '\n'; // prints "kFirst" 2. the metaclasses proposal is your best bet. 3. std::map + static reflection would help you automate the creation of an associative array between two enum types. 4. ???
What are you even trying to accomplish? Most all of the requests are better served by something else or completely miss the point of an enum. &gt;switch case hell You'll like yourself a lot more if you use a container and just find the matching flag you're wanting and then figure out what the result is supposed to be. Which would make it far easier to debug errors for since everything would be forcibly contained; especially given the above example falls apart as soon as you stop using multiple returns due to no breaks;
Yep.
Has anyone had a go at trying to do this? Assuming it's trivial to set up, this would be amazing
Map has a tonne of overhead in both memory and time if you are only converting an enum to a value
&gt; Isn't a switch statement best for that? What else do you have in mind? Pattern matching I agree about getting element count - to string is also useful
I imagine something along the lines of https://en.wikipedia.org/wiki/X_Macro but each of the elements are defined when the enum is defined 
That goes against zero overhead. You are using a container which doesn't give you any benefit over switch case.
Great to hear! I am really excited about the possibility of seeing modules in C++20. Having that paper be an April Fool's paper would have been one of the cruelest jokes ever plaid on the C++ community.
[this] currently works, is that going to stop working?
&gt;zero overhead You're still paying for the branching until that path is warmed enough that it's just assumed to be valid. It's minor yes; but its non zero. If you were to be using if constexpr() and doing it with a constexpr function/as a template parameter then I'd agree. Technically yes; the container way is a bit more expensive but for the case you gave above it fits much more inline with how you're using it. aka a key + value lookup. &gt;maps do not ensure you have a defined value for every enum um. How do you add something to a container that doesn't have some defined state? What chunk of memory are you reading these bogus values from exactly? In any case; you'd have to fill out the container much like you're filling out your current logic just in a data format instead of direct code. Also to my mention of having branch lookups: if you are constantly hitting the same lookup for your container(s) the cpu is just going to prefetch the values anyway.. But sure; If your switch cases somehow manage to wind up in your hot loop and you have a proper fixed amount that's hopefully reasonable (not 200+) then using switches/ifs is a good way of doing things; otherwise go for what expresses the intent of the code more easily.
The point of the vector&lt;enum&gt; / array&lt;enum&gt; would be that the size of the possible enums is defined at compile time, therefore it would be nice to use an efficient vector instead of a map to associate data with a case.
Will do, thanks!
Order of evaluation is not specified
Interesting effort. I like that your SuperString supports the different representations of Unicode. I was surprised that I couldn't really find much tests even, but here's a starter for unicode-specific tests you should consider writing : https://www.unicode.org/reports/tr36/#Canonical_Represenation
Thank you for the comment and specially for the link, I'm working now on tests. Generally most feature are working correctly.
This is neat, a string class that does a away with the notion of single fixed length buffer for greater practical performance. I think it would greatly increase your traction in the community If the API were closer to std::string (Preferably to the point of this being a drop in replacement in common cases) and you carefully explained the differences. For example the documentation doesn't indicate support for iterators or the being/end functions, this makes it hard to pass one of these to one of the std algorithms. An another example, std::string is guaranteed to have contiguous memory so it is possible to take the address of the first character and use a pointer (and the size) to reach into the strings data, but with a typical rope construct that really wouldn't be a good idea. At present you don't say was std::string is better or worse for. You also don't state the time complexity of the member functions on the SuperString.
What I meant by "Project setup agnostic" is that it doesn't matter if you build an EXE or DLL, or if you use several DLLs, link against LIBs, etc. The structure of your solution and any projects it contains does not matter. I put this up because some people were under the impression that Live++ only works for DLLs, and I wanted to clarify that. I'd be happy to change the phrasing on the website if it's somehow misleading. Would something like "independent of project/solution-setup" be better?
Is it also more efficient than SmallString introduced in llvm sources? I would also be good if there were different test scenarios. Not only one with almost unknown test set.
Couple of feedback things. 1. I think to say much about whether a library is "fastest" you need benchmarks (based on time, not instructions retired). That may look good for SuperString if basic_string's additional memory consumption in this test blows up the cache, or it may look bad for SuperString if any additional pointer chasing for the rope structure hits memory stalls. 2. Which std::string are you testing against? [Implementations can vary quite a lot](https://twitter.com/MalwareMinigun/status/814196564507799552). 3. Your ropes link is broken. Perhaps you meant to link to https://en.wikipedia.org/wiki/Rope_%28data_structure%29 ? 4. Splitting a string is a pretty classic example where string interning/rope-like structures do really well, but to fully characterize your data structure you also need to measure the things with which ropes have trouble. For example, if you have to bake a SuperString out to a const char * or a BSTR or similar, what does that cost? If you want to generate by concatenating single characters at a time (C string escaping, various kinds of encoding, etc) what does that cost? Users will get more out of your library when they know where to use your library where it excels. 5. How do you iterate over SuperStrings? 6. Have you compared with other rope implementations?
Thank you for reminding me that I should implement iterators. This is a newborn work-in-progress, in which the main goal is to be memory optimized then fast. I will try to make more comparison and benchmarking to demonstrate where std::string and SuperString are different.
Yes, it requires the MSVC toolchain at the moment. clang and lld would already be supported by Live++, but I'm missing three important things in the PDB produced by LLVM to make this work in a generic way. I've filed bugs for these issues weeks/months ago already and tried getting in touch with the LLVM developers, but haven't had any luck so far. I'd really like to support clang &amp; lld for several reasons, one of them being that lld is much faster than MSVCs linker, the second being that LLVM does not have *any* Edit &amp; Continue-like functionality at all.
https://www.reddit.com/u/cleroth might be able to answer this
No, that proposal is about the implicit capture. I haven't read the proposal, but I guess the problem is that even if you capture by value `[=]` and use a member variable inside the lambda, you don't get a copy of it because what you are actually capturing is the this pointer.
Thank you for all those feedbacks, I will absolutely fellow your "advices".
- enum class like thingy suitable for bit flags, which would allow bitwise operations while preserving scope rules and safety of enum class - a way to automatically assign values for enum items in ecponential way (e.g. PREV * 2 instead of PREV + 1 like regular enums do) - an operator which would return maximal value for an enum (to never have to write MYENUM_MAX again)
Why not say exactly what you said in this comment?
&gt; Neither way is really more intuitive than the other. People will always be coming to it with different expectations. This seems like an argument for removing the default.
And what do you do, when your enum name differs from the name you want to serialize?
Making them work with range based for loops would be nice. I also like your idea of a compiler generated to_string.
For no. 4 I've used things like this: template&lt;typename TIndexable, typename TEnum, typename = std::enable_if_t&lt;std::is_enum_v&lt;TEnum&gt;&gt;&gt; auto at(TIndexable &amp;indexable, TEnum enum_index) { return indexable[std::underlying_type_t&lt;TEnum&gt;(enum_index)]; } https://wandbox.org/permlink/9wx1ph04LamXUSdO Not operator[] syntax, but it's still pretty concise: `at(some_vector, some_enum_value)`. C++11 version: template&lt;typename TIndexable, typename TEnum, typename = typename std::enable_if&lt;std::is_enum&lt;TEnum&gt;::value&gt;::type&gt; auto at(TIndexable &amp;indexable, TEnum enum_index) -&gt; decltype(indexable[typename std::underlying_type&lt;TEnum&gt;::type(enum_index)]) { return indexable[typename std::underlying_type&lt;TEnum&gt;::type(enum_index)]; } 
&gt; Because why should member variables also be copied? because [=]
I've been using it for the past few days. It is extremely trivial to set up, and works right away. It's specially useful in my field (game development). I'm actually very confused as to why this isn't as popular as it should be. I've been waiting for something like this for years (there are a few other solutions but they're either in-house/private, have too many limitations, or require coding in weird ways). Having rolled my own solution with hot-loaded DLLs, I practically can't live without hot-patching nowadays. It's just too damn useful. Now Live++ makes it much easier to integrate into any project, without altering the codebase. /u/tivolo is also pretty receptive to suggestions and support. I requested automatic detection of source code changes rather than having to press a hotkey, and this was implemented and released in about a week. With that said, Live++ is still in early days so I think there's a lot of room for improvement. These are the things I think could still benefit Live++: * Live++ doesn't seem to use multiprocessor compilation, so changing a header which is included by multiple TUs ends up taking a very long while, in which case closing the application and building it with `/MP` might be faster. * Under normal conditions, I'd prefer not having the Live++ window in the way. I've already suggested to have an option to keep it in the SysTray already, but this isn't everything. Namely, there's a bit of a lack of feedback as to whether it's detected anything or if it's still working. Live++ uses Win10's notifications popups but I find those to be a bit hard to read/easy to ignore. The situation is worsened when having 2 projects which share the a source folder in common. I'll have the server project say "no changes detected" but not notification from the client that it's detected changes and begun compiling. Only when it's done do I get notified of the patch being complete. * In some cases there are some odd linking errors with globals. I'm not sure if it's due to this project's odd code or something, so I'll try tracking down the problem and reporting to the dev eventually.
Making ref capture (`[&amp;]`) implicitly capture `this` would still be fine IMO, but the behaviour is not as expected when using implicit value capture (`[=]`). I would definitely be in favour of making `[=]` not capture `this` implicitly.
From the top of my head this could be caused by 3 issues: 1) The exe or dll in question is loaded at a fixed address (caused by using /BASE or /DYNAMICBASE:NO ) and competes for address space with other modules. 2) AutoCAD reserves (not commits) a lot of address space so that new modules won't fit anywhere in the -+ 2GB range. 3) Live++ made an error. In any case, please contact me at support@molecular-matters.com and I'll look into it. I'm sure this can be solved.
&gt; SuperString uses Rope (data structure) and game theory techniques. But most important of all: Does it utilise block-chain technology?
By definition, string is a chain of block (*character are a type of block afterall*)
Thank you very much for the feedback! I agree that especially the UI can be improved. I'd like to hear your suggestions on this. Regarding the linking errors, please report this to me should you find the time. Parallel compilation will be added in a future update.
Do you think that `this-&gt;foo` and `foo` inside lambda should behaive differently or do you think that [this](https://wandbox.org/permlink/TrBhGBIHx91fYg6f) should capture shared_ptr?
No one is stopping you from capturing the this pointer explicitly.
[This is actually not my shortest paper ever.](wg21.link/p1005r0)
Performance is like the ocean; there's always a bigger fish.
Yeah. I lol'ed when I saw: ``` void subscribe(EventReceiver const&amp; receiver, EventID eventID) ``` So, you can subscrive to events, but are forbidden to mutate any state when receiving one ? I was more or less expecting to find a processEvent()-like function that would return something like a StateUpdate object, to be applied later, but as the return of reactTo() is ignored, I decided to do the same with the whole article...
Do not underestimate the fact that std::string already have an api, and that you should to aim at being a drop-in replacement for common use cases. I looked at your code, as I could use something like that in a current project, and was immediately put away by the fact that method names are gratiutously different. Because, guess what, I already have std::string in my code, and changing *all* the code just to test your string is not going to happend. 
I like how cppreference examples are used as motivation.
Please provide evidence for this claim. I think you are vastly overestimating here.
This is only true in the case where the enum values start at 0 and are contiguous.
&gt; raw pointers do not work nicely with copying If you think so, then don't use raw (`this`) pointers with copying? [Like this](https://wandbox.org/permlink/sIOTBooBzKdXzF9r). Jokes aside, Between `this-&gt;foo` and `foo` I would ban use of `foo` without `this-&gt;` inside lambda. IMO `this-&gt;foo` makes it obvious which part is copied.
&gt; I agree that especially the UI can be improved. I'd like to hear your suggestions on this. Putting Live++ in the sys tray and making the icon change when Live++ is compiling (similar to how ShareX does when uploading a file--it just shows the % completion of the upload. I'm not sure how accurate a % would be for Live++ but at least I'd like to know it's working). Regarding the notifications, I can only think of two solutions: being able to add multiple source folders (so that I can include the 'shared' code folder along with the specific project's folder), or simply removing the "no changes detected"--I don't find this notification particularly useful. And if you implement the "busy icon" in the sys tray, this will already be implied (if you don't see the icon, then it didn't detect anything). One thing I love in VS is that you can configure it to play a sound on build success or build error. I find this very useful as I don't even need to read anything to know whether it just finished and whether the build succeeded or not. Perhaps this could be an additional thing for Live++, play a sound when the patch is done (possibly configurable, even if by just replacing a .wav in Live++'s folder). Another thing with the UI: the log scrolls all the way to the top on occasion, bit frustrating when trying to read through it. I've not noticed this on the new version though, so it may be fixed already.
Or std::map which was designed for, you know, mapping values of one type to values of another type...
Powerful enums came from Java ;-)
Next up C++ String-theory? Though now that I think about it that may just get confused with C++ std::string theory...
Ad 3. It is possible to make something that kinda behaves like (strong) enums but also can easly store other values. I was thinking about something like this: (A quick sketch that may have flaws) http://coliru.stacked-crooked.com/a/6c598c337802c4d2
I already explained why it's not a good idea.
That's missing the point. Z01dbrg wants to capture member variables by value. Capturing `this` explicitly still won't get around the problem.
Not sure I follow. What do you mean?
I see, then once again the metaclasses proposal.
If you don't like the Map solution you could use fold expressions but that would be likely worse in term of performance. namespace detail { template&lt;class Out, class In, Out... To, In... From&gt; constexpr Out convert(In value, std::integer_sequence&lt;Out, To...&gt;, std::integer_sequence&lt;In, From...&gt;) { Out res = 0; ((value == From &amp;&amp; ((res = To), true)) || ...); return res; } } template&lt;class Out, class In&gt; constexpr Out convert() { //use static reflection to call the detail::convert and return its value }
&gt; // in case NULL is not defined #ifndef NULL #define NULL (0L) #endif // NULL -- &gt; //*-- Bool /** * The famous boolean type with its two values `FALSE` and `TRUE`. */ typedef unsigned char Bool; static const Bool FALSE = ((Bool) 0); static const Bool TRUE = ((Bool) 1); \*backs away slowly...\*
In the last committee reporting thread, committee members said that reflection is expected around C++26. So I think anyone who needs this feature in less than 8 years will have to implement something themselves (e.g. some form of code generation or macro boilerplate).
I recently wrote something like this, actually! It was mostly a test and not ready for production, but it can mostly be done under C++11. The problem is that without reflection there's no way to automatically define the valid range of the enum. So I made a traits class that the user needs to specialize first. It needs a relatively dense enum. If the values are sparse then a map is probably better.
I'm not sure about the overhead, but have you tried `std::variant` of empty distinct types? With `std::visit` you could get a compile error on forgetting to handle a newly added enumeration in that case.
I agree with you, but there is still a takeaway from the article: &gt; But if you put an empty optional in a container, why put it in there at all? This is a question that should be asked (and answered) when creating a function that returns a container from a source containing optional stuff, something that some of us may have glossed over.
I think unordered_map doesn't provide any guarantees to users (the order depends on an implementation). 
I think unordered_map doesn't provide any guarantees to users (the order depends on an implementation). 
You're 10 days late I'm afraid...
I didn't see that, it seems?
These are the three things I'd also love for enums to have that remain in my mind whilst I'm using them. std::bitset seems nice but I can't see it as being very easy to put them in save files or what have you, and the history of the code I work on has means that it already uses enums for flags all over the place (and I can't afford to try refactor the code to use std::bitset anyways).
If enums were actual classes than maybe you could achieve that throug iheritance
TAPKAR. ^(**T**he **A**cronym **P**reviously **K**nown **A**s **R**aii)
I like SBRM more. 
&gt; ++ operator Whether or not that's allowable in whatever language you're using, you probably shouldn't do it. Ignoring the fact that you'd expect that operator to modify the object it's operating on, which makes no sense for enums that are by definition constant, if you're doing arithmetic on a value, that value should be a numeric type. If arithmetic doesn't make sense, it generally should not be a numeric type. There are a couple of exceptions I can think of, mainly around making something an integral type purely for some efficiency gain, but that is a good working rule. Enums are intended to be semantic constants that have some logical meaning within the domain of your program. Even though they're implemented as constant integers, they aren't really supposed to be semantically numeric types. What are the natural semantics for "Color::Red++" or "IOError::FileNotFound++"? For most cases where there is a reasonable meaning (like your days of the week example), I'd argue you're probably better served by implementing an actual type for that where you can have more sophisticated behavior than just increment operators anyway. If "Day::Monday++" yields Day::Tuesday, then shouldn't you also be able to do "Day::Friday - 2" and the like?
I would be interested in seeing a 'With' sugar for RAII where you never actually use the resource (e.g. a mutex).
You should change Previously to Formerly, then you have an acronym in the same spirit as The Artist Formerly Known As Prince.
Yes that is a bad problem and I'm glad they are fixing it.
 #define with(expr) if (auto e = expr; true)
Did you hear a whoosh as the joke flew past your head?
&gt; game theory techniques. Throwing in a buzzword like this without any obvious application to the domain in question borderline hurts your credibility, when you don't explain anywhere else on the page what exactly you used (as someone knowing both C++ and a moderate amount of game theory, I have no idea what you could be referring to, let alone the average programmer who doesn't know anything about game theory).
Apparently?
IIAR = Input Iterators Are Ranges This can be used to describe std::filesystem::directory_iterator.
Like with all proposal, the committee needs time to properly discuss how things should be designed, to ensure a good result.
It was april fools 10 days ago
I don't know what's actually going on with standardizing fmt, but I suspect it may be a victim of being closely related to something else that is "almost" standardized. That is, right now fmt can only detect problems with the format strings at runtime. This is a big, big disadvantage. But if C++ had compile time strings of some kind (which are a pre-requisite for meaningful reflection), then this disadvantage could go away. So some may argue that fmt should wait until C++ has compile time strings. Not a terrible argument but at the rate things are going it's going to be ages until C++ has compile time strings.
My super special vector beats vector when inserting. 100x My super special vector is actually a RBTree... Not sure if OP is just trolling or just bad... 
If C++ had an animal mascot, it could be the SBRM Whale.
I don't know - if C++ was bad at acronyms, wouldn't the letters be all wrong? I would say C++ is bad at naming things, but does okay with acronymizing those bad names.
I don't think it's possible. I've encountered this issue before trying to find nice ways to do generic key value pairs. You definitely can't do it if you want to perfect forward. I thought constraining the template would work, but in the end it doesn't and I'm not sure why: http://coliru.stacked-crooked.com/a/6561625a609d82b9.
The best solution IMO would be to make plain `[=]` refuse to capture `this` _or_ member vars, then require `[=, this]` for capturing this, and possibly add something else for implicitly capturing member vars by value. Updating existing code would only require adding `, this` to their captures, and the unexpected behaviour would be gone.
Let me explain what I mean with game theory, in garbage collected environment when an object has no more references it's automatically destroyed. In superstring, there's two type of references (let's call them srrong and weak). Strong reference are variables, weak references are by example substring (substring doesn't copy data). so normally when a string isn't anymore strong referenced, it ask its weak referencers to copy data (I called that reconstruction). Now let's imagine that our string has many weak referencers, and the reconstruction process will cost more memory than just freeing the object, then we just should keep it. This evaluation of freeing and reconstruction costs is what i mean with game theory.
resources and time are not on reflection side - modules, concepts and ranges are to be dealt with in the nearby future, and those are BIG items
literally O(n!)
Upvoted for a prompty explanation! But I have to agree with PP that it isn't anything to do with [game theory](https://en.wikipedia.org/wiki/Game_theory) which Wikipedia "the study of mathematical models of conflict and cooperation between intelligent rational decision-makers". Now, game theory has applications even when there isn't more than one decision-maker, but you aren't using any of the techniques or terminology of game theory either. What you're doing is optimization.
This doesn't have anything to do with game theory though. It's just an optimization problem. Generally speaking, game theory is defined by having multiple participants. These participants are often competitive, but more importantly they are making decisions separately. In your example there aren't separate decision making entities, it's just a class deciding whether to destroy something or not based on some state.
Right on. I myself write in languages that aren't English - and I know I make terrible mistakes. In the context of the sentence, "I will follow your "advice"" means _exactly the reverse_ of what it appears to mean, because of the quotes.
That was actually my first thought as well, especially since `enum class` already has an inheritance-like syntax. It's very tempting to do something like this: enum class Color : Primary, Secondary { BLACK, WHITE }; Unfortunately, this gives backwards semantics: `Primary` is a `Color`, not the other way around. This provides the wrong implicit conversions (you can call `void foo(Primary);` with `Color::BLACK`). Instead, we need to flip everything around: the inheritance-like solution wouldn't provide composition, but a subrange: enum class Color { RED, YELLOW, BLUE, ORANGE, GREEN, PURPLE, BLACK, WHITE }; enum class Primary : Color(Color::RED, Color::BLUE) { }; enum class Secondary : Color(Color::ORANGE, Color::PURPLE) { }; That has the right semantics: `Primary` is a `Color`. There's a couple advantages over the composition solution. Having all the enumerators together makes assigning values a bit clearer and more robust against change. The values are the exact same for the sub-ranges, which is a nice property (with the composition version an offset has to be added or subtracted when converting). But there's a lot of questions I have that arise from this syntax. I'm not exactly sure how you define a sub-range. I showed one possible solution, but I don't like it. And what is a sub-range anyway? It has to be based on the declaration order, not the numeric value. And it looks really tempting to add more enumerators inside the derived enumerations, but I don't think that should be allowed. In the end, I think inheritance is the wrong way to go. If we make `enum class` more class-like, inheritance like this won't be part of it.
Reflection does seem to be the generic way to 'fixup' enums. Especially if there is a std::enumeration 'class'.
Humm the graph are great but you need timing in millisecond or relative to each other not instruction count. How much cost Object creation How much cost Object destruction
Why implement `bool`? There is already a native boolean type in C++. Also, you should try it on windows. You'd be surprised that `long unsigned int` might not have the size you'd expect.
You mean like using in C#? That'd be fantastic.
Ah, yeah, I see. I'd prefer any capture-by-value to be explicit anyway in this case. Doubt this will pass since it can break the existing code.
Even if enum value are sparse, it shouldn't be a problem in a perfect world. enum myEnum { flagA = 1; flagB = 2; flagC = 4; flagD = 8; } Then an array of size 4 should be created, and when accessing them, a constexpr function should do the conversion (for example converting the access of the index `flagD` to `myEnumVect[3]`.
3. Console_colour colour(const Test_result&amp; test_result) noexcept { using TR = Test_result; using CC = Console_colour; switch (test_result) { case TR::untested: return CC::FG_DEFAULT; case TR::success: return CC::FG_LIGHT_GREEN; case TR::output_mistmatch: return CC::FG_LIGHT_RED; case TR::crash: return CC::FG_LIGHT_RED; case TR::timeout: return CC::FG_LIGHT_RED; case TR::testing: return CC::FG_RED; case TR::no_reference_data: return CC::FG_LIGHT_YELLOW; default: return CC::FG_DEFAULT; } }
Uhhh, so you were rude and condescending?
Theres a number of hot reload open source projects on GitHub. Curious if you've tried any of those in comparison to Live++?
An acronym should be pronouncable as a word (like NATO or ASCII). If those are attempts at acronyms, they have failed. They are acceptable as Initialisms. 
I allude to this in the post, but I think the right way for this to happen is to have the linker emit the ABI XML (or hash) while generating the output dynamic library, probably by way of a linker plugin.
I haven't been able to think of a good-enough way of doing it, personally.
Those are about the only thing I *like* about Java.
Yea, I have. Some like a Alcantarea I couldn't even get to work (too old). What ones are you thinking of?
Yes, that might work. It totally depends on the enumeration, the indexing function that's needed, and the time/space tradeoff (would you rather waste some space, or take extra time to index ... something that the compiler can't really decide for you). I'm not sure I like the implied O(n) behavior to index an array -- at a minimum that needs to be controllable. We also have to consider what happens when the value is not one of the enumerators. The first tool is to just say it's undefined behavior ... except, I could see *wanting* defined behavior with the enumeration you set up -- I might want to index `flagA | flagB`, for example. This is another customization point. I kinda like my traits class solution. I think that might provide enough customization to do what you're proposing, but it could default (if we had reflection, at least) to a simple cast for indexing. I'll have to play around with that a bit more.
And 11 minus 10 is... ?
I had an interview experience like this. "Imagine you are doing contract work for a veternarian's office. Clients can phone in after hours and type in numbers via the phone, that you need to interpret as a few words like "dog" and "cat", etc...." So I said, take all the words you want to accept, and put them into a (multi)map of letters to words. ie 364 -&gt; "dog", 228 -&gt; { "cat", "bat" }, etc. Then when something is typed in, just look it up. Interviewer looked at me blankly for a second.... OK, that makes a lot of sense. That's actually better. But imagine we didn't do that and instead... The problem turned into a permutation problem (which was also interesting). 
You would not be required to overload the operators. In some situations it would be useful to increment. For example in a state machine you could increment the state to the next state. You could choose to throw or wrap after last element depending on your use case.
Is that list publicly accessible somewhere? I understand (at least some of ) the problems with making internal preliminary plans public of course, but it would certainly be interesting to see a summary of your plans.
http://quick-bench.com/L_PBEOIiYgJI1mPlBqKjJqKwEEY
Thank you for https://blog.molecular-matters.com/ I've been reading it for many years.
I havn't tried but I'm almost certain there will be a crazy amount of overhead that I don't want to write when using an enum
I get the argument, but I'm just saying that I think there are very few situations where you want something like operator++ but you don't need any internal state or more complex arithmetic-like operations. And as soon as you need any of that, you should be writing a class, not an enum. I personally don't want to deal with enums that can throw or allocate memory or do any other bizarre stuff. I already have classes for that. 
The original SGI STL had a rope type with a string-like API. It's certainly doable.
Never really used Java. I just know that Abrahams, Gregor, Lattner etc are big names in the STL world and have written numerous books on the topics. Swift's stdlib has a really this-is-what-we'd-do-if-we-could-rewrite-cxx-from-scratch feel to me. 
Yes this is true, but is dangerous - You can forget a value to this array and by requesting it you will be accessing invalid memory
Please avoid posting duplicates.
Suh-fi-nay Rai Cuhp-pihb-ah You can pronounce _anything_ if you put your mind to it. :p
Also removed as duplicate.
You can do sparse initialization of an array in C++ like this: const Console_color result_colors[] = { [Test_result::untested]=Console_colour::FG_DEFAULT, [Test_result::success]= Console_color::FG_LIGHT_GREEN, // ... etc. };
DIMWITS - Destruct Instance and Memory When It's Terminated by Scope I mean it fits right in with existing practice. I do dimwitted coding all the time! :p
&gt; It's only done at compile time Only if it's passed a literal. If it's passed a `myEnum` variable, then this cannot happen at compile time and indexing the array is O(n). &gt; If the value is not one of the enumerators, it should be a compiler error. If the value isn't in the enum, this mean that is came from a cast, and thus it's UB. Except that's not UB and can't be a compiler error. [It's completely valid.](http://en.cppreference.com/w/cpp/language/enum): &gt; Values of integer, floating-point, and other enumeration types can be converted by static_cast or explicit cast, to any enumeration type. ... the result is the same as the result of implicit conversion to the underlying type. Note that the value after such conversion may not necessarily equal any of the named enumerators defined for the enumeration. However, I think it might be acceptable to say that using an enum with a value that's not one of the the enumerators as an index results in UB. The problem is that forces adding a custom enumerator for every possible flag that might be used, and that pretty much defeats how an enumeration like that is designed. &gt; Obviously, a isValue&lt;myEnum&gt;(size_t value); utility function should be provided to be able to convert any size_t value (eg. provided by the user at runtime) to handle the error yourself before asking the enum to string conversion. Yes, that's definitely a missing piece. Especially if it could trigger UB.
Enums, Maven and... I can't actually think of a third one. Good tooling because of no macros and simple grammar?
Wow I did not know about that one. I like the history of OSes, so I'll take a look at it :)
Are you aware this is not the same person?
No I did not. 
How does this compare to [Eigen](http://eigen.tuxfamily.org/index.php?title=Main_Page)? That supports [lazy evaluation](http://eigen.tuxfamily.org/dox/TopicLazyEvaluation.html), is that not as good for doing compile time look up tables?
SFINAE is not an acronym. It's actually Latin for "nobody ever really masters C++."
There's no overhead when all types are trivial.
These are the ones I've starred on GitHub but I haven't tried them: - https://github.com/fungos/cr - https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus
At that point, why not just use frozen::unordered_map directly instead of shoehorning into an array?
`std::hardware_constructive_interference_size` 
I was looking for solution to your question short time ago and came up with something like this: #define REGISTER_ENUM_NAME(EVAL) (registerEnum(#EVAL, int(EVAL))) #define GET_ENUM_NAME(ETYPE, EVAL) (getEnumName(#ETYPE, int(EVAL))) void MultithreadGame::registerEnum(std::string name, int value) { std::string type = getEnumType(name); registredEnums[type][value] = name; } std::string MultithreadGame::getEnumType(std::string name) { size_t type_end = name.find_last_of("::"); if (name.length() == type_end) return std::string(); return name.substr(0, type_end - 1); } std::string MultithreadGame::getEnumName(std::string type, int value) { return registredEnums[type][value]; } REGISTER_ENUM_NAME(sf::Event::GainedFocus); REGISTER_ENUM_NAME(sf::Event::JoystickButtonPressed); REGISTER_ENUM_NAME(sf::Event::JoystickButtonReleased); REGISTER_ENUM_NAME(sf::Event::JoystickConnected); ...
!RedditSilver
I'm interested what the goals are of the discord channel compared to the existing Cpplang slack channel. I notice the include-cpp GitHub has the Slack channel's code of conduct in its repositories.
I think it fulfills a different use case. In the case of compile-time evaluation, no code is ever generated. In the compiled program, it just looks like a constant array was filled with "magic numbers". Lazy evaluation still generates code that evaluates at runtime, it just generates more efficient code.
A bit off-topic but what it takes for small quality-of-life improvements to be voted into the standard instead of sitting in a TS, like http://en.cppreference.com/w/cpp/experimental/map/erase_if ?
That was the whole context of this thread, indexing an array using an enumeration.
Interesting, how would that work? Are you preposing being able to iterate all possible values of an enum, like a sort of static set? Or do you mean enums that take on multiple (bitflag) values?
r/simd would like this :)
It seems like the "generic" approaches were always faster than the specific procedures that tried to minimize memory accesses? It seems like you should talk about that. Why even mention the specific procedures if they're no better than the simpler "generic" ones?
I like DARTH VADER (Destructors Are Resource Termination Handlers Vacating All Duly Encapsulated Resources)
Regarding the missing empty base class optimization for MSVC. There's this: https://blogs.msdn.microsoft.com/vcblog/2016/03/30/optimizing-the-layout-of-empty-base-classes-in-vs2015-update-2-3/
I think there is something very wrong with your comparison between SuperString and std::string on the project homepage. I don't see how splitting lines of a 209KB buffer could end up using more than 456MB.
Yes, and I'm mentioning _alternatives_ to using an array that guarantee constexpr access and O(1) runtime lookup...
&gt; Help for conferences in reaching minority groups with calls for papers, and suggesting candidates to invite to speak. &gt; Help for companies in improving their C++ job advertisements to improve appeal to minority groups. &gt; Help for minorities and junior programmers in submitting talks for conferences or job applications. Discriminating by race... yay?
This is very good and proper. Kudos!
`std::allocator_traits&lt;Alloc&gt;:: propagate_on_container_copy_assignment`
I'd guess performance would depend on both datasize and architecture. SIMD has lower overhead in some architectures.
Two things that make Live++ stand out in comparison to many of the alternatives: 1) You don't have to rewrite your code or write C++ in a certain way 2) Your code doesn't have to live in DLLs These are the two major ones I would say.
[Godbolt for those interested in actual assembler output](https://godbolt.org/g/eb43cW). I think the 'minimization' of memory access just doesn't do anything. All of those loads are going into hot cache anyways. And note that you don't save on register moves as you need to move `chunk1` to `chunk0` in registers and not only in language semantics. Additionally, all of the instructions in non-generic version are data dependent on the result of the immediately preceding one. Since in todays processors, you can actually do multiple register loads in a single cycle (4 if I remember correctly for that architecture) through good utilization of the micro-ops scheduler and out-of-order execution, that might translate into a real performance loss or at least no win. What might be interesting would be to see if manual loop unrolling could lead to increased performance. Based on the generic version, we could reuse `chunk1` but with additional incentive for the compiler to reuse the registers instead of swapping them around to reuse the exact same `pcmpgtd` instruction with same input registers.
I've merged the PR adding meson support to the repo.
Yes, but they thought I lived somewhere where it was 10 days ago. By your logic, what is (10-10)th of April?
Thanks for posting. A few comments and questions. 1) For performance testing, instruction count does not matter that much. Modern CPUs are much faster than memory and having contiguous memory allows better caching. In fact, vector will typically beat list on inserting in the middle up to a pretty large N. String has contiguous memory and that may make it more cache friendly. 2) In terms of your benchmark for memory savings, in real life, I would probably keep the content string, and use string_view to store the lines. 3) What is the thread safety profile of the code? What operations are safe in multithreaded code? 4) What are the exception safety guarantees of the String? 5) Looking through the code, I am seeing a lot of naked pointers and "new" and "delete" calls which is a code smell to me. In addition, you are redefining stuff from the implementation or standard library (for example Bool for bool, Pair for std::pair, Size for std::size_t, Null for nullptr, SingleLinkedList for std::forward_list). In addition, the interface feels very foreign as a C++ container. 
For some reason `Instance` did not cross my mind for the first `I` in `IIAR`.
Imagine I have an enum called suit with CLUB, SPADE, HEART, DIAMOND defined. And another called number for ACE through KING. I would like to be able to make a deck of cards by doing something like this: for (auto x : suit) for (auto y : number) vec.push_back({x,y}); Or you could use it for matching. Right now, enums are typically used in these grossly long if statements. There's other ways of doing these things, but they are much longer and lose the safety features of enums.
I had this discussion here, but let me point this out again: there were reflection proposals for at least five years now. Yes, there was a big reset a year ago, but that adds up to 15 years (if C++26 is realistic). I can't imagine that honing proposals to perfection can yield more value than releasing *something*. Quoting my own earlier comment: &gt; I feel there should be more focus on the things that need language support, as opposed to library enhancements. The reason being is that more often than not, there are libraries available already to do the work and very often those very libraries are what's standardized with slight changes. Which is great. But in the meantime, I can't use reflection without substantial effort (as opposed to using ranges or asio today, which I can do fairly easily). &gt; But this is just my perspective and I understand that others have different priorities. I'm grateful for all the work you guys do - I remember the pre-C++11 times, and the velocity today is so much better.
He should probably discuss that, but I'm glad he put it in there instead of making people come to that conclusion themselves.
We're in agreement then. I misunderstood what you were trying to do. Sorry about that.
No, it is not publicly accessible. I wish there was a way to communicate this without turning it into schedule commitment; however I am excited by the fact that the VC++ team is just as energined about it as it has been about driving the toolset to useful standards conformance.
Not sure. I kinda like when the message is a single string.
No, it can’t - that is part of what testing revealed. Remember that the standards are roughly cumulative. Most code failing with C++14 also fail with C++17. This is independent of whether the language version was explicitly requested, or the default (C++14). What we do expect with this scheme is to give some legroom for the ecosystem to catch up so that **future** releases could make the correct contemporary value set by default. 
I find `[&amp;]` captures useful when using STL algorithms. I don't care about lifetimes and stuff, I just want all variables to work. I follow this rule for all lambda that are completely enclosed in their parent's scope. If the lambda escape the current scope, I capture explicitly each variables. I find this rule quite generic and easily applicable and enforceable. I never use `[=]` unless I return a lambda that only and use all argument and locals of the current function, if arguments are all received by value or const reference. That rule is really complicated, not generic and I usually end up enumerating every variable I capture in this case too.
I hadn't thought about using `std::variant` for this. I'll ponder on that for a bit. In the meantime, here's some initial impressions: &gt; * Works already without new features This is very important -- C++ is complex enough already without adding feature after feature. It's also a library solution, which is generally preferred in my book. &gt; * Runtime overhead Yeah, that's the elephant in the room. And since it uses allocation ... this is pretty heavy-handed compared to what an enumeration should be. &gt; * Values not guaranteed contiguous/unique I'm OK with that. This is even an advantage in some ways: it knows that `Primary::RED` and `Secondary::ORANGE` are different, even though they have the same value. But if the programmer wants different values, it's up to them to handle that manually -- not ideal, but I'm willing to sacrifice that feature. &gt; * Can't use Color::RED (would need to use Primary::RED) I can live with this as well. &gt; * Can't define additional values in the union type (but could get around it in this case by including `Neutral { BLACK, WHITE };` That workaround is perfectly acceptable. However, in the end I think `std::variant` is too heavy to implement this. Type erasure isn't really necessary: since all enumerations can fit within a sufficiently large integer, that can serve as type erasure for an enumeration. The problem is how to use this thing inside something like a `switch` statement when using scoped enumerations. Everything has to get casted back to an `int`, defeating the purpose of `enum class`. Ugh. I'll have to think on this.
It's a more tightly controlled community than the slack - there are a few bad actors on the slack who make the experience worse for everybody, but they're not dealt with. This channel is intended to be fully moderated so that we can discuss C++ without dealing with all that BS.
Not an industry but I hear it's useful for Unix permissions
Personally I like octal 0, since I o3ft ujynce got praise for catching am octal 0 bug in a driver while pair debugging a test
It's not about "need," and for that matter it's not really correct to say that "cpp" multimaps are "just a tree." The standard doesn't specify the underlying implementation, only the interface (although admittedly, as witnessed by my errors in this thread, that interface is often specified with enough constraints on template args/runtime guarantees/iterator behavior/etc to rule out obvious alternatives to the popular implementations). The interface for vector pretty much requires relocation since the size is unbounded and pointer arithmetic has to work on the underlying storage. Other structures still might benefit from using contiguous storage to improve their runtimes by relying on pointer arithmetic (as well as locality and other practical concerns that might not be reflected in the performance guarantees) -- but not if the API guarantees things like reference stability. You know, for a library that went to *extensive* lengths to remain flexible to compile-time implementation decisions, these APIs are sometimes surprisingly opinionated about which additional constraints to impose on library implementations in order to back guarantees that most clients might not really rely on. I trust the STL more than any other software design to know better than me when I think something is off, because it's written very carefully by very smart people with whom I would undoubtedly agree, were I to put in the hefty work of understanding... or, well, maybe work's just had me in Java for too long.
&gt; I feel that the event registration, as described, is inherently a nested structure I've been turning this one over today, and I guess I agree -- it directly translates my intuition that for a given type of event, we have a set of listeners that want to be notified of its occurrence (OK, I'm pretty sure set is preferable to vector here, but that depends more on application requirements than API readability). But abstractly, for the most part, a map&lt;K, set&lt;V&gt;&gt; is really the same as a multimap&lt;K, V&gt;; these are different notations for the same mathematical concept. So, semantically, when *would* you find a multimap preferable? Do you find there are concepts more naturally expressed in the "flattened" version, or is this strictly an engineering tradeoff based on the gritty details of template parameter requirements, runtime optimization, etc?
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8bk8yw/good_system_design_blogs/dx7t2ki/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Never heard of CPPIBAA can't find an answer after googling ? 
So the former.
Does anyone know why it wasn’t autovectorized ? I make this assumption that the compiler will do what’s best and I should play around with sims. Should I ? 
See above link.
The sick thing is this is a library function issue in c/c++. One way to deal with it is via localization. Localization is a shit show of itself but it makes more sense than not here. setlocale(LC_OCTAL, "sane"); // use 0o to denote octal Make that the default, problem solved. 
I like `0c`, as in “0ctal”
You should have a default constructor if it makes sense. This is often analagous to asking whether that class has an "empty" state. An empty Person doesn't really make sense, so don't provide a default constructor. Meanwhile, a vector or a string make sense with an empty state, so they have default constructors*. * Tons of STL classes have default constructors that don't follow this principle. I don't like most of their default constructors, but ¯\_(ツ)_/¯.
Thanks. I like the notion of an"empty state". 
Then you probably want a function that initializes and returns the constructed object. I honestly can't think of a case where delayed-initialization is a mandatory design, or even a _benefitial_ design 
Perhaps. I'll give it some thought next time I run into the situation and get back to you.
You don’t need a separate is_sorted function since next_permutation returns false only if it wraps around to the first permutation, which is the sorted permutation
start, end of content, end of buffer A pointer to data is always the same size.. one pointer.
Your title should have made it clear this was talking about the literal acronym, not the process.
This is something of a symptom of the fact that C++ doesn't allow you to declare and initialize objects separately.
Should you remove the auto generated one if the thing your class tries to model doesn't have such a state? Also this will sound like a really dumb question but how do I do that?
In this case it's hard because the compiler doesn't know how long `input` is (you can leave early if you spot disorder early), and CPU instruction sets do an atrocious job of making it easy to handle that. If you do a boolean reduction into an integer (`bool`s don't work for whatever reason) then you do get rudimentary autovectorization.
I think one problem is that there's no way of making a class fully emulate an enumeration. C++ had all the tools to make a class act like an arithmetic type, or a pointer, or an array ... but not an enumeration. I've seen a couple proposals that might help (such as letting classes work in a `switch`). I'm not sure if the right direction is to make enumerations more powerful or let the already very powerful class act more like enumerations.
Isn't an uninitialized object just some number of bytes in memory whose values dont mean anything useful in the context of whatever type the object is supposed to be?
If you define another constructor your object won't have a default constructor.
`struct A { A() = delete; };` You can mark constructors as deleted.
In languages I've used which allows separate declaration/initialization, your code won't compile unless the compiler can prove that you never access an uninitialized object.
You're right - I didn't notice that on first read.
&gt; default [=] capture means members are copied I don't think anyone is proposing this (though someone might do in the future).
FWIW, we're trying to make memory allocation work in constexpr for C++20, so it should soon be much easier to do this kind of thing. For example, `std::vector` should be constexpr in C++20 if everything goes well. See [p1004r0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1004r0.pdf)
Challenge: find the easter egg in [p1004r0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1004r0.pdf).
tldr: Zircon is the kernel of Google's upcoming Fucshia OS. This it the github page describing C++14 usage in the kernel. While things like no-rtti and no-exceptions, no statically constructed objects etc are to be expected in a kernel, as they are common in embedded C++, the reasons for not using STL and a bunch of other language facilities are quite interesting, IMO. 
I usually do this, separate data from behaviour by collecting data in structs (usually immutable) and functionality in constexpr (pure) functions.
cool! IMO, that era could be summed up by “no one had a decent OS on low end hardware and every one was shitting their pants at seeing what NeXT could do in 8Mb which was quickly becoming available to the masses”. Be had something ok (but far from NeXT quality and ease of dev), OS/2 was trying too hard to preserve mainframes. Apple had the apps, but was crap, at both hardware and software, and MSDOS was a very successful joke. UNIX players where just too expensive, and had no end user apps. Fun times. Everyone and their little brother were frantically trying to create something to capture the growth, while retaining their investmentt, and were building monsters. (Pink &amp; Cairo comes to mind). The only runnable taligent built I touched, needed a 128Mb machine to run. At that time, high end was around 16Mb... Fun times!
It would be better if octal is displayed in a different color. I remember very old IDEs that run in text mode that had the option to use a different color for different bases. 
`std::variant` doesn't use type-erasure - you're probably thinking of `std::any`. In this case, it (almost certainly) won't use allocation either. A really simplified implementation, at least for basic types, in pseudo-C++ should look something like: template &lt;typename... Args&gt; class variant { using storage_type = typename std::aligned_storage_t&lt;max_size(Args...), max_align(Args...)&gt;; storage_type storage_; uint8_t which_{0}; // uint8_t for simplicity, should be integer type sized such that lenth(Args...) fits within the type }; Constructing/setting the value is a matter of using placement-new + constructor call - no dynamic allocation required.
If you ever need to create an STL map with objects of your class, you would need a default constructor as it uses it in it's operator[]. That's the only reason I can think of where this design isn't optimal. Otherwise this is IMO the superior design compared to checking if the object is initialized in every method call and *throwing* a tantrum about it.
pfft. I can do it in o(1): bool is_sorted(const array_wrapper&lt;int32_t&gt; array) { return array.is_sorted; } 
Here is a better solution. Assuming uniformly distributed input the result is correct with probability 1/N! and it is super fast! template&lt;typename T&gt; bool is_sorted(T something) { return false; }
You don't neccesarily need it, you just can't use the [] operator. Especially insertion with emplace is quite comparable: std::map&lt;std::string, Person&gt; aMap; aMap.emplace("SomeKey", Person{"Bob", 23}); //compared to: aMap["SomeKey"] = Person{"Bob", 23}; //C++17 -&gt; more clear syntax for checking if a key exists if(auto it = aMap.find("SomeKey"); it != end(aMap)) //do something here What the bracket operator really excels at, is scenarios, when the map value is something like a container (or a count), where it allows you to write very handy and short code. std::map&lt;std::string, int&gt; wordFrequency; std::vector&lt;std::string&gt; aBook; for(const auto&amp; aWord : aBook) wordFrequency[aWord]++;
There is a fundamental tradeoff here. First thing, a default constructor eases integration with other libraries. For example, if you want to resize memory for a vector, you need default construction for your objects. But adding a default constructor where it makes no sense is also a concern, since you can violate invariants for the object more easily. For example, you cannot have, maybe, default persons because it would make no sense. If you do, now you have to clutter ALL functions in the class person for logic checking about emptiness if you want to recover that safety, making code more complicated to read. These objects that are default-constructed in an undefined state are usually called partially-formed. I would avoid when possible, unless it is a requirement. You can always delay construction of an object through std::optional&lt;NonDefaultConstructible&gt;. This way you can default construct an optional and later fill it in with something that makes sense. For example. you could have, in the case of the vector that you pre-resize, a vector&lt;optional&lt;NonDefaultConstructible&gt;&gt; and it would do the job for most use cases. All in all, there are tradeoffs but my preference is to not use a default constructor where it makes no sense and use alternatives such as optional when need to adapt things. However, try to provide default constructors if they make sense, they ease integration with other components.
Single most expected feature on my side. BTW, I keep reading but I am a bit confused: are those #export or import "something.h" in? I am not a big fan of these features that clutter the modules. Would these proposals affect modules compilation performance in some way? I favor much more having plain old #includes and users should use that than cluttering modules themselves with legacy cruft. Especially because I think that C++ should, better sooner than later, set some rules to be able to evolve (that paper about stability and velocity) breaking some backwards compatibility to do some cleanup. I think Vittorio Romero had a good idea (in my opinion, I do not know where it ended up) on how to isolate standards in different modules without affecting the rest of the users.
Only ever fails in weird corner cases :D
But why?!?! Profit?!
It more "linking agnostic" and "editor agnostic" but tied to one specific compiler. It's too much far away put, it will work only on Windows.
Why are operator overloading and initializer lists not allowed?
Looking at what clang says with , the auto-vectorization is broken by exiting early. I tried adding a bool flag, but that did not work, apparently this was not seen as "reduction". Switching the bool out for an int however did the trick on both clang and gcc: https://godbolt.org/g/34DB5X
Looking at what clang says with `-Rpass-analysis=loop-vectorize`, the auto-vectorization is broken by exiting early. I tried adding a bool flag, but that did not work, apparently this was not seen as "reduction". Switching the bool out for an int however did the trick on both clang and gcc: https://godbolt.org/g/34DB5X
Some people don't like things that confuse them. Some people are purists and close minded. Some people just like to complain.
All press is good press.
To be clear - we have moderators on slack, but there is no reporting mechanism. If people report stuff to me, I'll investigate and arbitrate. Otherwise, I can't do much - I don't have a lot of idle time to spend on slack reading the general channels.
Would make more sense to override an explicit prefix e.g. bxk would be k in base b, with 0xk special-cased as hexadecimal. That way you could have 16xk for hex, 2xk for binary, 8xk for octal, and you'd also get access to literals in base 12, 20 or 6 if that makes sense for your usage.
yeah, sorry, didn't mean it to come out like that. I appreciate you and your work :)
Building C++ code for new programmers is difficult to manage and understand when starting out. Also dealing with memory after coming from a scripting language can be mind boggling to some.
Because it's not Javascript.
Hey. Your talk on C++ 17 features was great. I have learned a lot from you.
You can't just google for "why is X bad" and hope to find reliable information. X can be C++, JavaScript, vaccines, radio waves, Australia, or anything really, and you'll get pages of crap. As for "blind hate against C++", this is not something I'm familiar with. The companies I've worked for and programmers I've known certainly don't share that sentiment. In what context have you seen this?
Well. I rarely get to work on C++ right now, but the general reaction I get when talking to people is mostly negative. Also when talking to students the sentiment that C++ is unwieldly is very prevalent, yet they have no issue with for example java's verboseness.
I love C++, but many of my friends hate it because its not easy to understand and documentations arent detailed. Thats how I understood them.
It's not. It's loved. You should google: "C++ great good fast"
There was a lot of hate of C++ pre C++11, and rightly so. The specs were incomplete, the compilers didn't always generate the best code, the language is confusing as hell (and still is). People didn't like things like operator overloaded because it made it difficult to see what the code was actually doing (allowing operator&amp; to be overridden is causing issues today). If you want to see the compiler vendor-specific hoops people had to jump through take a look at the source code of Boost and run away.
Obligatory quote: "There are only two kinds of languages: the ones people complain about and the ones nobody uses" --- Bjarne Stroustrup
Very nice! I was also experimenting with constexpr-based linear algebra recently, [ctla](https://github.com/moroneyt/ctla). I agree with you on the likely use-cases for such libraries being the compile-time generation of what would otherwise be just "magic numbers". Actually I had included a compile-time least-squares regression example similar to what you described above.
A C++ project has a high upfront cost, but long term stability and performance. That makes it a good fit for long term projects. Most people trying a language do not start with a long term project, and even if they did they'd likely make fundamental mistakes from unfamiliarity with the language. So most people who try C++ have bad experiences. And in a university setting you typically want to quickly hack together something for a class or problem, not build a tool for long term use.
I just wanted to chime in and say that this was actually easier to set up than I thoguht xD I'm working with a huge C++ Codebase with all kinds of oddities in the build system and I got it to work within 30 mins. I'll evaluate it a bit more to see who in our company could profit from Live++.
Did you **See** `std::visit`?
The benchmark has a UB: `content` is not zero-terminated. And, most importantly, `std::string` benchmark is completely wrong: lines.push_back(string.substr(last, last - i)); this should be `i - last`.
Thanks. When dealing with vectors i always have to reserve space as opposed to resizing the vector, and i often have to use emplace_back instead of push_back. I've found that, even when another library requires a class with a default constructor, there is usually a way to work around that. I'll have to take a look at std::optional and see how it works. 
Documentation for what?
Someone doesn't run tests. 
Many parts of the standard library rely on dynamic allocation and exceptions. Also some parts are too generic, leading to possible code bloat. 
Javascript on the backend is absolute disaster waiting to happen. I don't know why people keep trying to make it happen. Please stop x.x
It's all QC anyway!
Tests had nothing to do with this, they all ended up passing, but you have to actually _write_ the feature first, and that was the difficult part.
Like any tool, C++ has a limited range of tasks that it can be optimally used for. I’m not sure about other people here, but wouldn’t build, say, my personal blog or a new app back end in c++ because the performance gain isn’t as important as developer productivity for creating a usable thing. But generically I think there are just a lot of really good languages these days, and people talk trash about other languages as a weird type of negging/ signaling how “smart” you are.
Well, JS on the frontend is not so good either, but poor programmers don't have any other choice :/
It takes years to really get a grasp on it and lower level programming in general, where as any beginner can hop in to C# and not care about dynamic allocations or pointers becoming invalidated. Eventually not knowing that stuff will bite you in the ass regardless but it's less shit to keep in your head when you program for the first time. 
Probably, it's because of outdated university syllabus. When I was learning C++ in university (2007-2008 year) we haven't taught to use RAII, C++ 0X draft, TRs. Don't remember about STL, though. Lector has taught about how to add classes, templates and virtual methods to C. We was struggling with new and delete. Perhaps, it's a good theory base, but there was a quite few things to like there ☺ Hopefully, we had a great C++ instructor during practice lessons. Additionally, as has been mentioned before, until C++ 11 it felt a bit outdated for late 2000s, in comparison with C# or Java. 
Did they use cpprefererence.com? Reading the C++ standard is pretty difficult 
I have written a lot of code. I have written a lot of C, C++, Go, and other languages. Of all the languages I know or have known, C++ requires, BY FAR, the highest amount of mental effort to comprehend and to get things done. I don't hate C++, I had a lot of fun with it, but I am glad it is not my primary tool any more.
PHP is also a hated language, so I'm not sure that's a good comparison.
C++ requires some skill to get right, so people blame their tools instead of their own incompetence. Those who use it professionally and successfully usually have better things to do than to whine about programming languages.
They do now with compiles-to-JS languages like TypeScript. And it's probably going to get even better with WebAssembly.
C exposes people to low-level concepts about computers themselves, and this is often taught alongside the high-level concepts of C++. It's a *lot* to process at once, and people have a limited tolerance for being yelled at by their compiler.
They almost certainly used cppreference.com, because it's high in Google results. Very few people look at the spec when learning about a new language. That's even more true for C++, since the official standard specification costs 200 USD.
wow, I've heard this quote but I didn't know papa bjarne said this. papa bless.
I think it boils down to the fact that programming in C++ has a steep learning curve and stays hard even after you learn it, when compared with other popular languages. Pretty much the only advantage C++ has over those languages is speed, but most programmers don't need that speed most of the time.
At least C++ has a legitimate purpose.
&gt; Also dealing with memory after coming from a scripting language can be mind boggling to some. Using python/numpy coming from a more C++ focused background I find mind boggling. Where is this memory stored?!?!
I'm only a novice programmer, but most of my time has been spent with C++ (and a little C, and a wee bit of Processing). Coming from a 'beginner' perspective, I think it's because C++ doesn't have singular &amp; obvious ways of doing some things. It doesn't mean those ways don't exist, just that because C++ has 'backwards compatibility' as a feature, it means some deprecated stuff sticks around for awhile. My current class is being taught in C++11, but the instructor wants us to get used to C++17, so there's a bit of confusion when it comes to things like concepts for template programming and such. Some people get uppity about (strictly) typed languages too, so there's that. I personally love using coding in the language though.
Or, to think about it slightly differently: It's not so much that people complain a great deal more about C++'s faults (whether perceived or real) than anything else. It's that C++ has persisted for all these years despite complaints, and remains one of the most productive high-performance application languages in the world where other languages have fallen to the wayside and thus aren't around to be complained about as much. And other languages with a similar tenure (e.g. Java) receive their fair share of hate as well. 
It's not so much as by C++ as it is by static typing. A parallel to your example is TypeScript and JavaScript, where you can read lots of anecdotes with how it definitely made stuff easier when they moved to the former. At its best C++ has a very strong and powerful type system. At its worst there's a minefield of quirks and gotchas which novices often step on.
A language construction kit would be one of the LISPs. C++ is C with a language construction kit accidentally tagged on. The cacophony is good, otherwised we'd be stuck with a boring OO purist language with no way out. And on the contrary, C++ has a very strong opinion on important things: zero-cost abstractions as much as possible.
Thanks :)
I know and thanks :)
In europe, "Informatics" engineering which is a mix between computer engineering and computer science, we learn more C or even assembly than java. I can't understand how can someone get a computer-related degree and don't even know about pointers and basic computer architecture.
Really, any language where `typoInVaraibleName = 3` doesn't even give a warning is one where all hell can break loose, PHP or not.
There's a certain point when you've written so much C++ code and involved yourself in the ecosystem that you start to appreciate C++ holistically. It's not just appreciating each individual feature but it's more like a good feeling and sense of things working together nicely. I guess many people only, at each moment, try to write C++ code using a very limited subset of the features. Like professors focusing on a specific feature in each lesson or students emulating code from books and tutorials. They don't get to ask themselves if the feature they're using is really the right thing for the job, and when it's not then some of them complain about it (often those who have more experience with other languages, and you know often it's not easy or appropriate to equate specific C++ features to those of other languages).
I have a script which I keep in my Dropbox dir. It's called move_in and sets up any Debian/Ubuntu system with all of my tool chain and fav settings. It's evolved over many years (including moving to Dropbox). A little bit of up-front work and long term payback. I also keep my emacs settings there and symlink them to the correct locations.
C++ was over-hyped at one stage, people went object-crazy, went too deep into the bag of tricks, with an inevitable backlash. I had a chance to look at MFC classes the other day, so I can appreciate the fact that C++ is considered an ugly mess. However, lessons have been learned, and we can now do much better. C++ gets you most of the way to Python, but with type safety, and it works faster. As such, what's not to like? The reason why C++ is hated so much?: because it's fashionable to hate on it. So all the tired old tropes are trotted out about what's bad about it. As Stroustrup himself says: "Doctor doctor, it hurts when I bang my head on the table. Well, don't do that". C++ is a big language, and I doubt that many programmers say they have a deep understanding of all of its parts. Template programming seems a particularly arcane art. And yes, it still has areas where things are rough (I think C++ really needs to sort itself on Sum Types. It's really hankering for something like Haskell's typeclasses). Despite all this, I think most people would be far, far better advised to program in C++ over, say, C. What you do notice that the Stroustrup is steering C++ in the direction of being an "engineered" language, by which I mean safe and correct; as opposed to C, where pretty much anything goes. The perfect language is some kind of C++/Haskell hybrid, I think.
I'm a mechanical engineer, but I've done a lot of software engineering as part of daily job responsibilities for about a decade now. Variety of languages - Matlab, C#, C++, primarily, some others as well. I've *slowly* come to *start* to enjoy some C++. Some of my own perspective is below. At my organization we didn't have a resident C++ expert so for some projects that came up, I had to go figure it out on my own. *** **Learning by Example Code - Pre C++98 to Beyond C++11** I often learn by looking at code that's been written by others. Something that was difficult for me getting started in C++ (not long after C++11 became a thing) is the array of different coding styles. Finding old code with "new" or raw pointers everywhere and thinking that was standard practice, but then discovering that's poor practice, to use RAII, or any number of features which were introduced in C++11 and beyond. Having to figure out "Yeah, everyone *used* to code like that, but that's not good practice anymore" without an experienced mentor around. **Documentation** Something I enjoy about Matlab and C# is that there is pretty much *one* definitive resource on documentation, from the Mathworks and Microsoft, respectively. You always know where to go for the most up-to-date stuff. With C++ it took me a while to find your go-to source of up-to-date information and best practice. **Development Environment** I develop on Windows, and I was accustomed to developing in Visual Studio for C# before starting in on some C++ projects. Especially as a self-learner, I think the IntelliSense etc. in Microsoft's C# editor is a lot better and more obvious than the C++ equivalent. Beyond that - being introduced to header files, and the order in which things are declared, took some getting used to. **Other People's Experiences And/Or Misconceptions** There are a few people here who had dabbled in C++ ages ago in the 90's. Lots of groans about doing C++ work, just from that and not being aware of what the current state of the language is. *** With all that said, the *performance* of C++ is *incredible.* That's by far the most attractive thing for me. There are engineers who start out writing code in VBA (*yuck*). Then they get into Matlab and say, "Oh wow that's a lot faster." Then maybe they get into C# and realize a lot of stuff in C# can be much faster than Matlab. Then you take the jump from C# to C++ and it's another step yet in performance. That's what really got me interested. I'm sure any of my above comments could be argued or given counter examples. Whatever. Is what it is - just what my experienced had been.
I can't speak for others, but here are a few things that might not have helped: - I never had any formal training on C++. In university I followed courses on algorithms and data structures, and those used C++ (among others) as a practice language. In this situation you start at the nasty end of the language, and mostly use it to juggle pointers until it stops crashing, which can leave a nasty impression. I also helped a friend from another university who had to implement three separate sorting methods. He had been given a framework by his professor that was all void pointers and casts - basically just C with printf replaced by cout. - Early C++ was a lot less nice than C++ is today. Nowadays we rely on standards being followed; in particular, STL behaves the same over all platforms. This was not always true, and gave STL a reputation for less than stellar reliability. Similarly, one early compiler I can remember had a flag for "make all member functions virtual". Something like that would be unthinkable today. - Early C++ also suffered from not always having optimal implementation. There was a lot less optimisation going on, exceptions were slow (something that tarnishes their reputation up until today), the inline keyword was still a necessity if you wanted code to be inlined, etc. - Early C++ programmers did occasionally suffer from Java syndrome a bit, going wild with inheritance hierarchies and abstract factory producer factories. Of course C++ programmers still do that today, but now they go wild with templates and coroutines... I roll my eyes in despair whenever someone wants to add two numbers, and one of the suggested methods involves four pages of template code. It happens often enough on this site. Ultimately, is c++ really that bad? It has some pretty damn good sides as well: - Great performance. Even without trying to squeeze every cycle out, you generally get excellent performance out of the language. - Great tools. And even better, many of them are either free or virtually free. I believe we have Richard Stallman to thank for this; I doubt Microsoft would be selling Visual Studio for peanuts without gcc (and nowadays clang, of course). - Longevity. If your program needs to live for longer than one hype cycle, writing it in C++ is a good way to ensure that it will. You are not stuck with a single compiler vendor either. And despite all the complaints, modern C++ is actually a pleasant language. Between RAII, auto, unique_ptr, lambdas, and a host of other things, modern C++ lets you express your intent clearly and usually fairly concisely. Of course if you started out in pointer juggling hell you'll never believe this. And it's not just that, but the rest is a bit more difficult to explain... C++, for me at least, always felt like a language that was ready for whatever I wanted to do with it. I programmed professionally in a few other language (Pascal and Powerscript being two of them). Pascal is really nice, I loved it - right up until the day that I wanted a string that was longer than 255 characters. At that point Pascal will let you down badly. Similarly, Powerscript is fantastic: so simple, so readable, with so few non-alphanumeric characters littering around your source code... as long as you do things Powerbuilder was intended for. But don't even think about doing something that is not in the base language. With C++ I never had that problem: if I wanted something, the language supported it. Finally, it's just popular to hate on C++. That seems a bit unfair, but I suppose that comes with being an apex language... 
I'd argue that C++'s shines best in using it to "manually" managing memory. That's when we care about algorithms and data structures and their performance implications on hardware. We make easy and safe to use abstractions, and we're now finding that it's imperative that we know how those abstractions perform so that we can build a good mental model of how our program manages its data/memory. The problem is that I don't think teachers teach or encourage appreciation of this aspect of C++. We're now starting to realize that faithful OOP with C++ isn't that good at all. Also that it's not that right for abstractions to be made and treated as black boxes. I guess what I'm trying to say is tangent to yours, but this is one reason I can think of why people don't quite appreciate C++.
Are header files not enough?
I had I professor that made us write a language comparison paper. C++ is often viewed as unsafe, so I mentioned that, along with the flip-side that it gives a user more control and is very versatile. My professor looked my paper, but when we discussed the language in class, she told myself and another student who wrote about C++ that we were misinformed because C/C++ aren't as versatile as Java... She also mentioned later in the course that she's never used or learned C/C++, but she was constantly putting it down throughout the course.
Modern C++ can be written like Python, except the introspection is still mostly missing. In fact, it’s extremely easy to do almost 1:1 machine translation from Python to C++ as long as the introspective and dynamic features are addressed at compile time. 
&gt; Also, C++ doesn't allow you to have uninitialized objects Uh, that’s obviously nonsense. A simple locally declared `int i;` is a counter-example. And of course the same holds for custom trivial types.
You should be at an advantage, when the system handles the memory for you you know it isn't just "magic".
Same as PHP. It's by no means the most elegant language, but it's so widespread and I honestly can't think of a better backend language for the web.
Good list here: https://wiki.theory.org/index.php/YourLanguageSucks#C.2B.2B_sucks_because
You might be thinking of a framework based app or something along those lines. A NodeJS app takes zero boilerplating. You can just create a JS file and start writing code that will run. Even an Express app takes only a handful of lines to get running. Express or Koa apps are as complicated or as simple as you want to make them. I know more than a few simple production apps that are less than 2 or 3 files. 
screw all those guys. Honestly there is only one thing I dislike about c\+\+ and c# shines because of it. Array declerations. int numbers\[\] is an int variable called numbers\[\]. You want an array int\[\] numbers. Fight me!
I'm still not convinced it's healthy that a language designer convinced himself that people calling the language badly designed is a good thing.
I don't know how to write correct C++ code, and it worries me that other people think that they do.
Pulling latest and needing to wait half an hour for your project to recompile. Clicking go to definition in your IDE and having it take you to ... not the definition. Forgetting to forward declare a class and having the compiler lose its mind providing no useful diagnostic. Template errors.
One thing that I can think of offhand is that there were a ton of additions to &lt;memory&gt; in C++11. For instance, `shared_ptr` and `unique_ptr` were added (and all the infrastructure to support them).
Python is a well-liked language and doesn't suffer from the brain aneurysms of PHP.
Can you name some issues you have with PHP 7.2?
&gt; C/C++ aren't as versatile as Java So reason #1 for the hate is misinformed teachers. We get it.
It's still a fractal of bad design. There's no standardized way to do sane error management that applies uniformly across the entire platform. The standard library still suffers from irregular names and argument positions. There's still tons of legacy PHP code that the community as a whole is not interested in modernizing. Ultimately, its feature set was not designed orthogonally, but rather as a collection of things someone deems useful but without an overarching concept.
&gt;It's still a fractal of bad design. Yes, we've all read that old article that holds very little modern relevance. &gt; There's no standardized way to do sane error management that applies uniformly across the entire platform. ErrorException? Throwable? &gt;The standard library still suffers from irregular names and argument positions. This is something that will be fixed in a future version, but this is hardly the worst thing in the world. &gt;There's still tons of legacy PHP code that the community as a whole is not interested in modernizing. Blaming PHP for crappy legacy code is no different than the complaints you hear about C++. &gt;Ultimately, its feature set was not designed orthogonally, but rather as a collection of things someone deems useful but without an overarching concept. This again could easily be said about C++.
Template hell before boost was created. And before that, code written by Microsoft. See MFC.
Final draft of the standard is freely available. And, by the way, most of the other languages don't have a formal specification at all, they typically only have a reference implementation.
Wow! Way to put words in his mouth...
Why would you do that? auto t[] = { 12,9 }; Much more clear, and likely to be used in an array operation later on.
In particular I quite disliked maintaining an MFC project back in the mid 2000s. Using C# was amazing in comparison.
Yes, and C++ is, honestly, a badly designed language just as much as PHP when compared to other languages. It has one of the most horrendously complex and ambiguous grammars of any programming language and a myriad other problems that you're not going to find in other competitors. No, it still holds modern relevance perfectly. I would pick Python, Ruby or Clojure literally any day over PHP. Any one of the modern features that PHP implements, it does so badly. Borked namespaces, borked object orientation. There's always *something* in the implementation of said concepts that shows the ignorance and lack of attention to detail paid by its developers. 
Lol make
 uint64_t reverse(uint64_t a) { uint64_t b=0; int i; for(i=0;i&lt;8;++i){b&lt;&lt;=8;b|=255&amp;a;a&gt;&gt;=8;} return b; }; Both produce the same code in gcc -O2 and my version is unlikely to have any bugs.
I published two articles in Linkedin about it at https://www.linkedin.com/pulse/pythons-pandas-c-update-hossein-moein/. That is the extend of documentation I have at this point. There is also a test program in the codebase that shows how to use the object.
&gt; I would pick Python, Ruby or Clojure literally any day over PHP. I will keep note of your personal preference. All of those languages are also quite a bit slower than PHP. Also, can you explain to me why Python's lack of encapsulation (access modifiers) is a good thing? `_` means private, and `__` means super private. Should I assume that `___` means super-duper-do-not-touch-ever-private? &gt;Borked namespaces, borked object orientation. How did they mess up namespaces exactly? &gt;There's always something in the implementation of said concepts that shows the ignorance and lack of attention to detail paid by its developers. It's almost like dealing with legacy means you can't do everything you want.... Java's type-erasure comes to mind........
that's why people write tests
There are not smart enough! Fucking idiots. /s
C++ features encourage cleverness that can end up derailing/distracting you from your objectives.
I guess the former is about a "least amount of surprise", as operator overload can be abused (although it's a bit overzealous imho, especially when you control the commits) No idea about the former. Performance issues, maybe ? (as it frequently result in a `for` loop, even stuff like array or vector that can be deduced at compile-time)
The core C++17 language that’s complete and useful is not much different than, say, most of Python. People often do the darndest things and it’s easy to see it in StackOverflow questions. Manual memory management when objects have well-constrained lifetimes is quite prevalent. C++ as C-with-classes is indeed pretty damn bad. C++ as a value-centric statically typed language is a whole different ballgame. Save a few warts, C++17 can code be beautiful and concise. Going back to C++11 reintroduces some warts, so the more modern the version the better it gets. Also - I don’t get teachers who don’t treat boost as an indispensable tool in writing concise C++. Doing a lot of stuff that’s simple in Python (e.g. networking) is just as simple with boost...
Yikes. 
Many popular languages do: * [C#](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/) * [Java](https://docs.oracle.com/javase/specs/jls/se10/html/index.html) * [Go](https://golang.org/ref/spec)
boost is the defacto standard library. Qt is really due for a big overhaul in its design. Qt on top of C++17 would be a treat. 
&gt;&gt; I would pick ... or Clojure literally any day over PHP. &gt;I will keep note of your personal preference. All of those languages are also quite a bit slower than PHP. Nah. You might want to recheck your benchmarks. Clojure runs on the JVM. But even if it were the case. If you're designing your architecture around the speed of your web layer then your issue is not the web layer, it's your architecture.
&gt; If you're designing your architecture around the speed of your web layer then your issue is not the web layer, it's your architecture. And here I was thinking that technologies used were part of my architecture. Silly me.
I see two and a few bits of reasons with merit. The first is a lagging standard: feaure-wise, C++ has been behind other languages for over a decade - a time where there was a kind of "consolidation and propagation" of programming concepts. (Arguably, this reaches back even further, e.g. with fundamental types being library rather than language elements and having various functionality and portability issues.) The second is one of education. For a long time, we've taught C++ from the ground up: basically starting with the C core, teaching low level concepts, building high-level concepts from them, etc. Which meant all the oddities and gore came first, and the useful stuff kind of takcked on. (my go-to illustration is that to use vector class, we first had to understand raw memory management, array-pointer-decay, classes, operator overloading, templates and exceptions. It made sense once upon time...) These two are, or in the process, of, being rectified. And for the bits... C++ places itself as multi-paradigm language: you can write procedural, OO, functional, ... whatever. It certainly allows that, but it's perfect for neither. So from whatever concept you come, C++ will look clumsy to you. Another of these failed expectations is low-level microcontroller programming. Tooling lags behind by a decade or so, many tiny processors tend to come with toolset that was once branched of gcc, got a corporate slash screen stamped on, and never updated. Which means that these ressource-strapped environments often end up with unloved, unusable "good for the box art" C++ support. That's another large community that learnt - often the hard way - that C++ is a waste of time (for them). 
I'm not sure I'd consider variables of primitive types objects.
Must...not...start.......flamewar....
&gt; The standard library still suffers from irregular names and argument positions. This is honestly a surface-level attack. PHP is rottten to the core and people like you keep complaining about a mis-shapen face.
Given that it frees you from almost all of JS and HTML shit (you still need some CSS for styling), I'm surprised it's not more popular and that there don't exist toolkits with similar philosophy for C# and Java.
I'd argue that not being able to use map's `operator[]` is a *good* thing.
&gt; I’ll now ensure I use `-std=c++98` when building C++98 code. I think it would take quite a pathological codebase to not benefit from move semantics at _all_, and personally I'll take the compile-time hit for any runtime efficiency improvement.
It's literally the first counter argument you made when other languages were brought up. But the speed difference of those languages should be negligable if it's only acting as an API. The only other explaination for this argument would be that you were building your computational microservices that might cause a bottleneck, are written in PHP. Which would be fucking stupid. 
The Pascal string length limitation is kinda silly in retrospect: it is not hard to use a variable-length integer encoding to make small strings have little overhead, and arbitrarily long strings possible. And it’s not new stuff either: X.25, a rather old yet open telecom standard, already does variable length integer encoding. Such encodings are not expensive to convert to native integer types, and the conversion overhead - hint hint - also scales with the value. This is really the holy grail of pay for what you use and sensible scalability: short strings can be very fast, with length conversion done in a cycle or two on modern architectures as well as old ones; longer strings have length-conversion overhead that’s hard to measure, much less having any practical impact.
how about the parser front-end: just like GCC is much faster than G++...?
In my opinion, three main things; * The language and standard library have warts - 'special cases' where what looks simple and intuitive can lead to unexpected behaviour. Learning C++, you must learn the corner cases. This is one of the reasons that there has been a movement towards re-writing the standard library. This adds significant complexity and creates a certain reputation. * Universities - C++ 03 and C++11 are in many ways two totally different languages. C++03 feels clunky and outdated when compared to the features of python and Java. C++11 and beyond modernise the language and make it safer. C++11 is not taught at university. People instead start with C and add classes. This leads to incorrect expectations and wrong approaches to programming. * Errors - C++ is seen as being clunky because its compiler errors traditionally used spec language, and, thanks to templates, can be long and indecipherable. At run-time on the other hand, there is generally no compiler checking. You get a segfault, which is significantly harder to debug, and in some cases (e.g. UB emitting ud2, incompatible ABIs) requires knowledge of assembly to diagnose.
Total savage
As far as I can tell, both are correct. The most concise explanation I can find is here: https://english.stackexchange.com/a/25137 (To summarize: both terni- and trini- are derived from Latin distributive adjectives, and are synonyms) (I don't actually know Latin, just the little bit I've picked up here and there from learning English etymologies)
When my app nodes have dual 56 core gold xeons and I need 30 such nodes; working with a language that is 2-3x slower means I need 60-90 such servers. That's a massive price difference. This wasn't *the* reason PHP was chosen, but it could be *a* reason. I don't live in a black/white world that you apparently do. You must lack real-world experience to be making the kinds of claims you're making.
[Initializer lists](http://en.cppreference.com/w/cpp/language/initializer_list) or [`initializer_list`s](http://en.cppreference.com/w/cpp/utility/initializer_list)? The former wouldn't make any sense, and if the latter then they're spelling it out strangely...
I use boost’s implementation of `variant` and it’s really not that bad. In my experience most of the visiors i use are just a single lambda with an `auto` argument. And visitors are even more powerful than the article suggests, because you can visit multiple variants simultaneously, allowing differing types to be visited in every permutation. 
That makes sense. Thanks for clearing that up. 
I see. If you want both do you have to define them explicitly?
&gt; Memory for instance is going to be a bottle neck long before CPU cycles will be, and PHP is awful at that. PHP's memory usage? Compared to a compiled language, I'm sure it is. Compared to python, java or any other high level language... it's either par, or better. I've never in my life had issues with PHP's memory consumption, but I have with java. I honestly question your credentials based on the arguments you're making. Have you ever actually worked with a real PHP project that wasn't wordpress or drupal?
Was [this](https://www.radford.edu/ibarland/Manifestoes/whyC++isBad.shtml) the article? What part of the article do you think is misinformation?
&gt;In context of this discussion about C++ this is actually not much different. I've often integrated with C libraries which naturally don't use exceptions so we have multiple error systems going on. This is an awful critique, because this is true of literally every language with a FFI that communicates with C, including Rust, Python, PHP, and even motherfucking Haskell.
Yep.
&gt;Have you ever actually worked with a real PHP project that wasn't wordpress or drupal? Not on anything that wasn't legacy. I would never consider working for a shop that considers PHP anything but a legacy mole.
That's a shame. Many websites are run with PHP, even new ones.
It’s a very sensible experience. I went from Pascal with a bit of VB thrown in, straight to C++ of the late 90s. Things got way better today. But many people still don’t have the elegant, succinct, non-hacky coding mindset. A lot of software design has to do with how humans interact with source code, not with what machines need. It’s sad that in spite of it all, the common snafus persist: 1. Doing manually what the language guarantees will happen anyway. `if (x) { delete x; x=0; }`, `{ ifstream f; ... f.close(); }`, etc. This silliness, and its ilk, seems to be infectious. 2. Splitting tiny modules into separate headers and sources; not understanding how interfaces and implementations interact and that an `.h` file is an entirely arbitrary way of separating things. Locality of reference is not only for cache utilitzation, it’s also for our mental caches. If you have a 1000 lines of code that all belongs logically together, don’t split it across 10 files for fucks sake. 3. Inability to minimize and write in minimal style. Prevalent on SO questions. Like, seriously, a reproducible example doesn’t have to start with three source files that you pasted into the question. This is interrelated to not understanding how to leverage values and RAII: if all of your code can easily fit into 50 lines within the body of `main()`, don’t make it any harder than that. When prototyping shit, don’t start out by opening up ten files for the headers and sources. Keep it all in one file until the direction you’re going shows promise. 4. Use of technical abstractions where human abstractions work. If there’s stuff to be factored out - factor it out in a way that makes the use of the abstraction clearly reflect the meaning. Instead, people devise entirely new abstractions isolated from their domain in their quest for factorization - abstractions that have no reflection in what the code actually is meant to do. Abstractions that retain the implementation details front and center in the code they will be used in are just a bad ideal all round. 5. Inability to leverage version control as an integral part of the workflow. I can’t imagine working without self-reviews: looking at the diff browser before every commit and making sure things look right and there’s no gratuitous fluff. And that conceptually independent changes don’t get intermingles. For reals, we have free tools that let you select what chunks get committed and what stay for later, we have stashes, we have all sorts of ways to make the development process sensible. And yet we don’t teach it from day one. I can’t imagine a sensible intro programming class that doesn’t make git or hg an integral part of the curriculum. 
Seems like he should be unrolling at least as much as the number of registers he has available. Some machines only have a few though.
I stand by what I said. This is an excuse only the C++ community uses, it seems in order to ignore the qualitative difference between how people talk about C++ and how people talk about, eg., Python.
That in itself doesn't say anything about quality of any library/language. Would you be surprised to learn that an image in memory takes up more space than a PNG stored on disk?
Similarly, I get sweaty palms for a good month every time I switch from a strongly typed to "fuck it, we'll do it live" typed languages until I get comfortable again.
Registers don't have much to do with it because of OoO hardware. The issue is effective use of the functional units.
I don’t get your beef with callables. Care to explain? From the top of my head, we have plain functions and class methods, instance methods bound to objects, and functors (callable objects). All of those are fairly easy to understand and are not gratuitous. Are three kinds of callable concepts are a plethora for you?
`std::variant` doesn't allocate, period. If it did, it wouldn't have to deal with the `valueless_by_exception` silliness. So there's no type erasure or allocation, and in fact all special members are trivial — literally as _not_ heavy as it gets.
In this case, it's not a matter of compression. It's a matter of memory management. They're trying to fix it with Arrow and pandas 2.
Shouldn't a precompiled header file which includes standard library headers fix this?
University lecturers fucking __love__ doing tricky stuff with virtuals and templates over more immediately practical stuff like how 90% of problems can in reality be solved with a for(auto&amp;... and a std::vector It's like they got excited about OO a few decades ago and never let go.
Somehow this doesn't make the things seem better.
No objection here, only adding that C++ seems to use C libraries far more than those other languages you mentioned, except possibly Rust, so having multiple error systems is more common.
The part about dynamic allocation is only true if you use default allocators, though. And while std::allocator has [downsides](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html) those arent [entirely impossible to work with](https://github.com/foonathan/memory)
Two of those people are incorrect and clearly incompetent.
Lol. You're hilarious.
&gt; until C++ 11 It is worth keeping in mind that prior to C++11 things *were* pretty bad compared to other modern languages. Modern C++ is steps above what it used to be. I can't even imagine writing C++ now without std::move. Before C++11, no lambdas, no std::nullptr_t, no auto.
it's not just something cpp developer say. It really is a phenomenon present with all popular things. As the user base (or rather amount of people exposed to it) grows the number of people that don't like it will grow proportionally until it reaches a critical mass that it becomes audible. Enough people complain about python as well and, as with C++, some of it is reasonable and some of it is not.
Doing C++ without boost is kinda futile. The productivity without boost or a comparable library stack just sucks. 
&gt; Also, can you explain to me why Python's lack of encapsulation (access modifiers) is a good thing? _ means private, and __ means super private. Should I assume that ___ means super-duper-do-not-touch-ever-private? &gt; &gt; You can read the reasoning about: developers are consenting adults and can break the interface contracts if need be, at their own peril, but allows great flexibility to work around badly designed APIs. I have not missed enforced private members. &gt; How did they mess up namespaces exactly? There's a million blog posts on this matter. They lack a lot of features other languages' namespace systems support.
Nope. Just a software engineer building web based apps.
And some people turn off exceptions so refuse to use libraries that don't use error codes.
Well then this further answers the OP question. I doubt, but I don't know, that universities are going to teach C++ with the boost library. 
&gt; Highly optimized for performance, with critical code paths written in Cython or C. That is from the official page. So if you’d write something like that in c/c++ would it maybe take the same amount of memory if optimized for the same performance?
"You can see it on your computer or phone or tablet." Gives managers a hard on.
What I mean is: try using Python without its libraries... it’s just as futile. Boost is a very good library, it’s a mainstay and almost an afterthought. You do C++, you do Boost. It’s that simple. It’s not the core language’s goal to support networking, parsing, etc. Libraries did and do this job. Real world code heavily depends on libraries. 
Don't put words in my mouth. Python does not everything right and as a user of 10 years of it and PHP I have a lot I can complain about. But the complaints about Python are specific to certain aspects and are well-known language warts with acceptable workarounds. There are on workarounds to the lack of the design of PHP.
You suggested that PHP is only for web designers and brochures? That's... a strange statement.
Why would Ada be a more appropriate language? I don't know much about it and I'm curious. I thought it was an old language that wasn't used anymore?
Yes, people talk differently about C++. You would not see a post titled "Why is Python so hated" on the Python subreddit. I am not denying that there is a natural baseline of dissenting opinions, I'm arguing that Bjarne's quote is used to ignore the fact that C++ *isn't at that baseline*.
I'm suggesting that I only care about the usage across websites only matters to designers creating brochures. There is no shortage of companies running their entire infastructure on JVM, Go, and Node or any other stack that isn't shit. I have worked at a handful of companies and interviewed at even more than that, and the only thing that is common between all of them is the hate for PHP.
You're absolutely right -- I wrote that in haste and mixed it up with `std::any`. `std::variant` has access to everything it might hold, so it doesn't need the same level of fanciness.
Python
Yeah, I can see that.
Visual Basic 6 had an amazing "hack something together quickly, suffer for all eternity" mindset. Still it is the language I learned programming in back in the 90s before I had internet access.
C++, duh!
What does OoO have to do with it? From my understanding you can only benefit from unrolling simd in 2 places... the instruction cache and the actual computation. If you unroll more than you can process at a given time, it may benefit you in the instruction cache, which can help produce better OoO pipelining, but if your operations are dominated by actual simd computations, then the pipeline will be delayed only based on the number of existing registers (or the size of your registers). 
&gt; I have worked at a handful of companies and interviewed at even more than that, and the only thing that is common between all of them is the hate for PHP. That's mighty anecdotal.
Nobody here has mentioned the elephant in the room: if you don't have a default constructor then you now have a choice between making your object immovable (or making movement equivalent to copying), or having a special toxic "moved from" state that doesn't show up in any other way. Both of these are bad, but so is having a default constructor when you don't really need one. I don't think there is any one shot solution, very sadly.
PHP leads to depression. U can't compare PHP with C++ in that respect, not even Java. PHP is a disgrace to human intellect! 
I vastly prefer C++ to Perl 5.
I don't think I follow what you're saying. How would unrolling help i-cache? Surely more code is only worse for that? Also, why would the pipeline be delayed because of the number of named registers? Skylake has 168 physical vector registers; isn't that what really matters? The point of unrolling is to amortise out work that is taking up throughput (eg. instructions in the loop header and the `if`), giving more room for the core vector operations. This has very little to do with what you seem to be referring to. 
And there are tools those ecosystem use to create new apps like create-react-app which will have your up and running with a simple command line envocation. And they only reason we have those is for build quality. You can still load react the old fashioned way with script tags. The point of the boilerplate apps is to scaffold a near production ready app, that transpiles to the target browsers javascript support, optimizes the code for delivery to browsers, and setup testing and linting for quality control. It is the difference between setting up a kitchen to make a meal for yourself vs making 100,000 meals for customers.
Hell Preprocessor
Very true, C#/WPF is my go-to for stupid little timesaver things
Utrecht University (Netherlands) replaced their "Informatica" bachelor mix of Java and C(++) completely with C# after a push from Microsoft. A lot of coursework was rewritten in C# and they provided Xbox devkits for our game oriented track... for about 2 years and then you never hear from them again. You already overhauled your curriculum and probably are too busy to change it back, right? Fun thing is any new teacher thinks exactly the same you do, especially in the master *designed* to continue from that specific bachelor it is just magically assumed you know C++ or you are doomed. I have seen intentational students in the master that got alllllll the math and theory in the advanced graphics course but 80% into the course their code was just still a hell of dangling pointers and they could not wrap their head around object lifetimes and had to drop out. This is after the teacher gave them weekly extra office hours just to learn about C++. 
but, like, it's JavaScript... XD
There is more to C++ than performance. It has a strong yet flexible turing complete type system, multiple facilities for metaprogramming and zero cost abstractions just to name a few.
I wasn't aware that c++ was "so hated". It's difficult for, at least, 3 reasons: it provides low level access, is VAST in capabilities, and there is lots of legacy support built in. I've been using c++ for about 20 years now and I'm still learning things all the time
You think C++ is so hated, you should try Fortran.
Seems good. For someone really starting out, Stroustrup's book Principles and Practices is clearly the best.
They probably learned C++ back in the 80s, had a bad experience, and haven't bothered to update their knowledge base. Hell, our local state university *bans* C++11 in at least some of their classes. They have to use the original ANSI standard.
&gt; turing complete type system I'm not sure accidentally Turing-complete type system is an advantage. It certainly adds to the steep learning curve. &gt; multiple facilities for metaprogramming When compared with the ease of use of reflection in C#, I don't see how C++ has the upper hand here. &gt; zero cost abstractions "Zero cost" is all about performance. I thought there was more to C++ than that?
I upvoted this despite the xd
As far as I can tell, the only published material is the "Chapter 1: Introduction", an excel spreadsheet called "sources" that has some really excellent links, and some blog posts on the blog [https://fastwareproject.blogspot.com/](https://fastwareproject.blogspot.com/) . Scott mentions that he has licensed the material to other people. In particular, Andrei Alexandrescu \( [http://erdani.com/index.php/training/](http://erdani.com/index.php/training/) \) has some training material on performance. I think he is a great speaker and have learned a ton from his talks. Here's a couple of his performance oriented talks: [https://www.facebook.com/notes/facebook\-engineering/three\-optimization\-tips\-for\-c/10151361643253920](https://www.facebook.com/notes/facebook-engineering/three-optimization-tips-for-c/10151361643253920) . I also really enjoyed this post: [https://www.facebook.com/notes/facebook\-engineering/three\-optimization\-tips\-for\-c/10151361643253920](https://www.facebook.com/notes/facebook-engineering/three-optimization-tips-for-c/10151361643253920) and Brian O'Sullivan's haskell post on the same topic [http://www.serpentine.com/blog/2013/03/20/whats\-good\-for\-c\-is\-good\-for\-haskell/](http://www.serpentine.com/blog/2013/03/20/whats-good-for-c-is-good-for-haskell/) . There are move videos on youtube on performance. I've learned a ton from Chandler Carruth \( [https://www.youtube.com/results?search\_query=chandler\+carruth](https://www.youtube.com/results?search_query=chandler+carruth) \) and Mike Acton \( [https://www.youtube.com/watch?v=rX0ItVEVjHc](https://www.youtube.com/watch?v=rX0ItVEVjHc) \). There's a book entitled "Efficient C\+\+ Performance Techniques" by David Mayhew and Dov Bulka but it was published in 1999. O'Reilly's "Optimized C\+\+" by Kurt Guntheroth does not have great reviews. The C\+\+ Concurrency in Action has great reviews, but is about performance in the sense that exploiting multicore might help things \(a new edition updated for C\+\+17 is available in draft version\). Oreilly has a video course by Fedor Pikus entitled "High Performance Computing and Concurrency" that I just started looking at, but is promising. MIT OCW has a lab\-oriented course on Performance Engineering \(with videos\): [https://ocw.mit.edu/courses/electrical\-engineering\-and\-computer\-science/6\-172\-performance\-engineering\-of\-software\-systems\-fall\-2010/](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-172-performance-engineering-of-software-systems-fall-2010/) . The course uses C, but should not be a barrier :\). The "Computer Systems: A Programmer's Perspective" book is not C\+\+ specific, but is a phenomenal book \( [http://www.csapp.cs.cmu.edu/](http://www.csapp.cs.cmu.edu/) \). It uses C, and unlike books by Patterson and Hennessey, is written from a programmer's POV instead of a computer architecture guy's POV. The facebook folly library is also an amazing resource. They have markdown documentation for a bunch of their components: [https://github.com/facebook/folly/tree/master/folly/docs](https://github.com/facebook/folly/tree/master/folly/docs) . The FBVector one is amazing: [https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md](https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md) .
If you say so. PHP is not as prevelant in the industry as PHP developers like to believe it is. I kind of find it funny that you think I'm the one in the bubble. 
The best undefined behaviour is tested undefined behaviour!
&gt; I have a wide range of languages and experience on my resume. So do I. Not sure why that's relevant. We're in the C++ subreddit you realize.
&gt;It's still a fractal of bad design [ah here we go the circlejerk at it again](https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/)
I never stated this. 
[removed]
Your comment has been automatically removed because it appears to contain profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8bouu7/why_is_c_so_hated/dx92bvv/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Hello World in NodeJS: console.log("hello world") Hello World Express.js: const express = require ('express') const app = express () app.get('/', (req, res) =&gt; res.send("Hello World") app.listen(3000) To run both of these: `node index.js` You may think "these are just simple hello worlds", but as I said in my last reply that there are many production products running exactly like this, just with their business logic instead of printing "Hello World", with their frequency amplified by things like Lambdas. 
&gt; Great tools. I used to think that the tooling was pretty good until I had to touch Java. IntelliJ is **miles** ahead. By comparison, C++ tooling is mediocre. Which of course means that anytime I have a colleague who primarily develops in Java touch the C++ codebase, they'll cry at the state of the tooling: - IDEs are barely adequate: - tracing use-sites of variables/functions generally fails in macros/templated codes (either it's omitted or unrelated variables/functions are included), - without proper tracing, all functionalities fail: find, rename, refactor, ... - and any pull/rebase leaves you hanging for ages as the IDE recomputes all the references (because compilation takes ages), - Debuggers are barely adequate: - can you indicate *which* function to step into? (avoiding seeing that `unique_ptr` is implemented in terms of tuples when `*ptr` is passed as argument), - can you evaluate any expression on the fly? (gdb fails to evaluate any inline function call, because there's no generated code to call), - can you print the state of any variable? ("optimized out" I hate you) - do you have an accurate stack trace? Or a barely usable one due to all the inlining? - Package management and build systems are a complete hell: - integrating 3rd-party dependencies generally requires repackaging them, - and you may also want to redo their build script (sorry, but I don't want no autoconf in my project), - and even after all that effort, it'll still be slow as hell to build. Yes, C++ is usable. But its tooling is **primitive** and **slow** compared to Java's.
They are a pretty good running business with some nice clients, so why not. It's not 1 guy in his basement working on it (note: it's 1 guy in an attic). 
Aww... I see. Thanks for clearing that up. So something like the following: User user = getUserInfo(); And the function getUserInfo() would do the work of getting the user's name and age, and returning a properly initialized User object.
Thank you for the detailed reply. I like these kind of recommendations where the OP has personally used the books/resources and found them useful. I will check all these links. One more question: Do you know if "An Overview of the New C++ (C++11/14)" by Meyers have any published material?
&gt;It's interesting, because many major websites are written in PHP And yet you named you named all 3. 
Two of those are top 5 websites. Are we seriously going to play the game of what sites use what? How many of the top 25 are written in ruby/python or closure? I bet more of them are done in PHP.
&gt;Are we How many of the top 25 are written in ruby/python or closure? I bet more of them are done in PHP. Again, it doesn't matter what the web api is written in. These "sites" are not "sites", they are partial GUIs to complex infastructures.
This might be an unpopular opinion in a C++ subreddit, but when you say: &gt; long term stability What do you mean exactly? Do you say this because of static typing? Because there are a lot of languages that also offer static typing, yet also have greatly reduced risk of introducing errors, thus leading to better stability than C++ offers.
&gt; long term stability Our C++ product has long term instability.
Ada is designed with writing safe software in mind. I'm not that familiar with it to be honest, you're better of reading the Wikipedia article if you'd like to know more. The fact that it's an old language shouldn't stop you, many older languages are still in use today (C, Forth, Smalltalk), and Ada has many interesting features.
All my thoughts are from my perspective as an embedded developer. I write plenty of C++ and C applications and libraries. Many times I find that it is at least twice as much work to design nice reusable C++ code. This is fine if I ever am going to reuse it but wasteful for code that will never be reused. I also find that C++ usually is a bit harder to easily read through then a straight C. C++ can make low level memory management a bit more difficult and requires a high level of understanding to know how resources are being distributed. Many things such as the standard template libraries in C++ are extremely resource intensive and again requires a rather high understanding to be applied to the embedded world where resources can be scarce. Much of the STL and C++ in general is designed to use dynamic allocated memory off the stack or heap. When I design timing critical application for an embedded device I prefer to statically allocate everything if possible and create my own buffer pools for anything that must be dynamic. It is much harder to deal with failed dynamic memory allocation in an embedded device with RTOS timing constraints rather then a higher level PC application so I much prefer to know all my memory is properly allocated at compile time.
Might also want to keep track of QuantStack's xframe project: https://github.com/QuantStack/xframe
It goes both ways. From an embedded perspective I think C++ can often take away much of the low level memory management I need. Dynamic memory allocation is easy and great when you have an unlimited amount of RAM to tap into.
[Original removed by automod because apparently the F word is too much for the sensitive snowflakes of this sub...] I have been programming in C++ for &gt;20 years but dear God how I hate modern C++. The people designing it are just determined to cram every kitchen sink feature from every other language in there with no regard for the usability or maintainability of the result. If they want a new language they need to go make their own, not keep screwing up this one.
The static typing helps. The backwards compatibility of language and STL changes help as well. I've seen commercial code from the early 2000's being ported to MSVC 2017, there are not that many (high performance) languages around that long.
No problem, I hope you will share other links you discover that you like. You can purchase PDFs of Scott's "Overview of the New C\+\+" and "Effective C\+\+ In an Embedded Environment" via his website: [http://www.aristeia.com/books.html](http://www.aristeia.com/books.html) . They cost $30 and $25 respectively. 
Pre c++-11 i hated it myself. It seemed clumsy and verbose. Portability issues between compilers. Cranky/overly-manual build tools. But things have improved a great deal since.
So rust is really remarkable, because it managed to be the language that everyone complaints about and nobody uses.
Python has its haters too, though I am not among them. The most common complaint is about using whitespace to define blocks.
"Zero cost" is also a boon for not bloating the size of the target.
root is doing something similar
Even if he is a she
Oh, man, that takes me back. I spent many a pleasant summer afternoon as a kid hacking 6502 assembler on my trusty C64. I think the supermon interface is burned into my retinas forever. 
The one C++ job I had waaaay back circa 2000-2001 was so awful it scared me away from the language for about seven years. I got better. Then c++ got better and now we're both much happier with each other.
I am interested in performance optimized software, so I've recently started the following: http://a.co/gGW0u4H
To me it's absolutely stupid to ask (and wait) for the server to rerender the page (i.e. resend the html) when you click on a freaking "expand" button. Or when you switch tabs. Or when you do anything. With stuff like angular or react sure the start-up time is longer but damn at least you only hit the server for DB data
What's root's dataframe called? 
&gt; enum class like thingy suitable for bit flags You can mostly get this now by marking flags enums with a trait or a dummy enumerant that conditionally enables templated bitwise operators and other helpers. I do that in one of my projects.
I have something like this I wrote myself for my work. I waft between the generic+visitor like setup you have done and more concrete things like: typedef DataFrame&lt;IntCol,DoubleCol,StringCol&gt; DF1 Where slices would return: DF1 df; DF1::slice_view slice = df[index]; I'm starting to lean more towards the later, as by the time I use a compiled language I don't usually care about generic column typing and or variadic data in this manner. Obviously this makes the dataframe not suitable for research. Anyways, my current dataframe class is currently designed like yours. 
I’m taking Programming I at a university currently, and it seems like every time I have a conversation with experienced programming colleagues, they say something along the lines of “you can’t do anything with this language” or “there’s no point in knowing this language because it’s so out of date that you’ll never use it in the real world. After researching a little though, it seems like cpp is one of the few languages that you can do literally anything with. Is it because cpp at its core is harder to understand than many other languages?
C++ is a language that will gladly let you shoot yourself in the foot. It will gladly let you leak memory, overwrite your hard drive, even flash your BIOS if you tell it to. It took C, warts and all, and added on top of it. Most people who complain about C++ will come at it like they're writing C++98 code and ignore everything that's improved since then. They'll attack the backward compatibility as a weakness not a strength and they'll not use smart pointers, RAII, and other commonly held best practices. C++ (and C) are most developers first exposure to raw pointers and CS classes tend to overdo it as they're trying to teach the concept, not best practice and students can't separate the two. They hate C++ because they couldn't manage to write the double linked list assignment without segfaulting, even though almost nobody writes raw data structures like that in real production code.
**Company:** [RaySearch Laboratories](https://www.raysearchlabs.com) **Type:** Full time **Description:** RaySearch is a technology company with a difference - our software is a vital weapon in the ongoing battle against cancer. We help save lives through innovative software for radiation therapy, which is one of the most important forms of cancer treatment. Our success has led to rapid growth and we are therefore looking for talented software developers. RaySearch believes in investing in its people. We offer outstanding staff benefits and excellent career development opportunities in a flexible and stimulating environment. We prioritize knowledge-sharing, creativity and collaboration, and you will work together with some of the most talented and highly educated people in the industry. You will work in a modern office environment with access to the latest hardware and tools. We encourage a healthy work-life balance and have created a strong social culture, with regular events and activities for employees. RaySearch is committed to equal opportunities. We value diversity and are dedicated to preventing discrimination. [About RaySearch Laboratories](https://www.raysearchlabs.com/About-RaySearch) **Role** We are recruiting skilled C++ developers to join our development department. Our development department is organized in agile teams with physicists, algorithm developers, application developers and test specialists, all dedicated to designing and evolving cutting-edge medical software. Developers generally participate in all steps of the development process, including analysis, architecture, design, implementation and testing. We recruit for full-time positions based at our head office in central Stockholm. **Education &amp; Experience** * MSc in computational science, engineering physics, or similar. * 3-10 years of experience in an academic or industry environment. * Strong programming skills is meriting, especially in C++, modern C++ and architecture. * CUDA skills are meriting, but not required. * Strong algorithm skills preferably including parallel computations on CPU and/or GPU (especially CUDA) is, meriting. * Specialized knowledge in physics or algorithm development is meriting for the respective competence groups. * Software development in C#/.NET is meriting. **Location:** Stockholm, Sweden. Fluency in English is required. Fluency in Swedish is a strong advantage. **Remote:** No **Visa Sponsorship:** No **Technologies:** * Parallel algorithms both on CPU and GPU (Cuda). * C++11/C++14, will adopt C++17. * Visual Studio, boost, google test with visual studio integration, ReSharper C++ &amp; C#. * The algorithms are implemented in C++ and the application layers in C#/.NET, under Windows, for Windows. Scripting in Python. **Contact:** To apply, email your letter, CV and transcript of records including course listing with grades to work@raysearchlabs.com, subject "reddit c++". Questions are asked to the same address. More information and positions, in Stockholm and elsewhere: [RaySearch Laboratories Career and other open positions](https://www.raysearchlabs.com/career), [RaySearch Laboratories at Stack Overflow](https://stackoverflow.com/jobs/companies/raysearch-laboratories). 
&gt; and a huge package ecosystem In the case of JavaScript, this is a liability.
&gt; can you recommend some good material on high performance C++? - https://github.com/fenbf/AwesomePerfCpp - https://github.com/dbartolini/data-oriented-design - https://github.com/MattPD/cpplinks/blob/master/performance.tools.md
I think productivity is a more apt description. There are a large number of mature features and libraries, allowing competent developers to be much more productive in C++ compared to other languages. Modern C++ brings much better memory safety, and less verbose syntax. It's highly interoperabile with other languages and assembler. Blows all other feature rich languages out of the water when it comes to performance (Java being nearly as fast is complete rubbish. A lot of the benchmark comparisons thrown around are simple serial operation programs which JIT compilation can handle reasonably well. Garbage collection puts a hard limit on data structure optimisation, and there is no native SIMD support which severely limits compute throughput.) It's not a perfect language, it has some ugly warts are kept around for backwards compatibility, but it's pretty damn good. 
Uninformed_Nitwit_Teacher nitwit; nitwit &lt;&lt; std::stfu() &lt;&lt; std::endl;
It's an issue of familiarity. While I have a perception similar to yours, I think there are more developers familiar with NPM than with CMake.
Not going to fight you, but will encourage you to check out the improved array types were added to the C++ STL in the 2011 standard.
You win.
Thanks!
C++ has lots of features and techniques that can be used by software designers. Those features themselves are neither good nor bad. As with all design domains (architecture, circuit design, etc.), it is strictly on the designer to employ the features and techniques intelligently.
&gt; C++ STL in the 2011 standard oh you beautiful person. There is now nothing wrong with C++ (I honestly need to brush up on my STL)
- Reddit is not the real life. It's not because many "hipsters" here dislike it that everyone else, hates too. If C++ is so bad, then why is it one of the most used languages today in various programming fields ? We have lots alternatives(Rust, D, Nim...) but C++ continues to be very popular in real world. - A good amount of people has a poor knowledge of how the language works correctly, many still use it like some kind of "C with classes" or "C with `cout` instead `printf`". They don't know techniques such as RAII, for example. - It's not easy to learn. C++ learning curve is long and tougher if compared to most of mainstream languages. It can bother many people who come from "simpler" languages. - C++ is hybrid. It's not necessarily low level like C, but not high-level enough like Java or Python, then it becomes an easy target for people who are hardcore fans of C or higher level languages. - Tooling is not good if compared to most of mainstream languages, especially dependency management. It bother people accustomed with such tools in other languages. - People who come from languages like let's say, Javascript, dislike it because it has tons of low level details, they don't want worry about things like pointers, ownership, memory management, etc. - Legacy stuff: people can have bad memories from things like MFC or have nightmares with bad written legacy code(which were usually written like "C with classes" rather than proper C++). - To use C++ properly, you need to have a certain amount of discipline and know good programming pratices. C++ can be disastrous in the hands of an unprepared or bad programmer. But this point is also strictly valid for C as well. And all we know that lazy programmers accustomated with the facilities of higher level languages simply dislike it.
6 years later and people are still citing it, even though the vast majority of complaints are outdated or irrelevant.
As always, it depends on what you are going to do. In some cases a map is a good choice. E.g the stable iterators can be a bonus.
Some of us entertained ourselves with Sinclair BASIC in the 80s. Coming to DOS and finding that the crude QBasic frontend had a \*line\-by\-line debugger\* was practically mind\-blowing, even if it seemed to lack a PRINT AT.
Looks like they are just spelling `initializer_list` weird, since they are definitely using the initializer lists: https://github.com/fuchsia-mirror/zircon/blob/master/system/ulib/fbl/include/fbl/array.h#L15
I don't like how long it takes to compile. Which is ironic, for a language so hell-bent on performance they completely forgot to optimise the compiler itself. What a bunch of idiots!
Excellent observation.
That paints std::map in way too good a light. If you care about performance in the slightest then there's a better approach.
Huh? Where do you see people complaining about Rust? Granted it’s a young language, so I’ll let you get away with the “nobody uses” part, but from what I hear there’s a lot of optimism about the language, but maybe that’s just my /r/programming subscription...
Hell, it's also becoming way too complicated try or its own good. This is what happens when PLT people go berserk. Just like C++ resulted when Industry went wild. Maybe Academia and Industry need to work together better.
In my intro programming classes they taught c++. One thing they did was show us vector before the built in arrays. When they did show us arrays they said now never use this outside of this one assignment. Same goes for smart pointers and raw pointers. Improper memory managment is where I think most the hate comes from.
Genuine question: what is C\+\+ taking away from you? Why can't you just do the low level memory management yourself, in C\+\+? What is it you're unable to control? What about C\+\+ is forcing you to use whatever is causing you to run into issues?
Some of this sounds like what I've recently implemented in my image representation library: https://github.com/kmhofmann/selene
Agreed. Having learnt C++ 98 way back in college, seeing the changes in C++11 rekindled my love for C++. It is almost a watershed release.
&gt; C++ done poorly creates a huge mess, just like Perl done poorly. &gt; I question the idea that Perl can be done well. &gt; &gt; &gt; I've seen much more poorly done C++ code than well done C++ code. &gt; &gt; &gt; &gt; If somebody has only been exposed to poorly done C++ code and not to any well done C++ code (which is quite possible), you can bet they're going to hate C++. We might also extend that to legacy vs modern versions of C++. The other big factor is that some people (the haters) often believe for some odd reason that they need to use every possible feature of a language. So they end up using or better said "try to use" features they don't understand. The only real thing that sucks with C++ is the verbosity and event that is being addressed.
C# I didn't get the 'even Node' part, Node is really cool server-side technology.
 &gt; But abstractly, for the most part, a map&lt;K, set&lt;V&gt;&gt; is really the same as a multimap&lt;K, V&gt;; these are different notations for the same mathematical concept. Yes and no. There is an isomorphism that you can build between the two, yes, but only if you build it. Consider a set of children in a class. There may be more than one named Jack. So we store them in a multimap (or multiset). Nothing about the class data suggests a different structure. All children are equal and belong at the "top level" of the data structure. It doesn't make sense to arrange the students into the Jack group and the Bob group, etc. So that's a time I'd use multimap. If the class was a split grade, say both grade 5 and grade 6 in the same class, maybe you'd group them by grade, and then map of vector would be more "natural" for data. (or map of multiset or whatever) This all leads into databases and queries, where the structure is an implementation detail - you query by grade or by name or by whatever. But for normal C++ data structures, one structure is probably more natural than the other, typically based on natural data relationships, and *secondarily* (but closely related) based on usage. For this event system, we might be leaning more on usage - we want to get all the listeners for a given event - _and_ we want to do this very often. So we pick a structure that prefers this. At this point, however, multimap vs map-of-vector might still be the same performance. However, that goes back to my code example - the usage, if written top-down, doesn't need to change. The usage also suggests nested, so I'd probably make it nested. Later, you might realize that the "am I listening" lookup needs to also be fast, and you might end up with a database-like (or boost multiindex) data structure. But the usage code stays the same. So in general this seems like a case where the data structure is more dictated by (expected!) usage, but often it is decided by the natural interrelationships. 
I see people complaining about Rust (more specifically the Rust community) on /r/programming
Golang is fun and pretty easy
I need a piece of this too!
I'm sure some veterans did, but I was at the ripe age of 4 years old when the 80s were over, so my humble experience only started with the newer candy and didn't have to go to school on foot through the woods uphill both ways.
It isn't hard to write, just a couple of defs to cover package management and then a list of packages to be installed, some files to get copied. Maybe thirty mins to get everything installed with all my Emacs, Bash, Elixir, C++ and Ruby environments installed. Start simple, build it over time. The main thing is to realize that spending time now automating things is time well spent.
C++ has pretty much painted itself in a corner. It can only add stuff to make it better - but it doesn't stop people from dealing with decades of older legacy code. Bjarne Stroustrup has a superpower of talking about his language and making it seem "OK". Some programming needs the performance of C++ with zero overhead abstractions. If you can code something without C++ you should _seriously_ consider doing so (kotlin, java, go).
Integer sizes / gotchas suck too, and I could probably come up with more. One of the problems where I work is actually the opposite of what you describe. Everyone writes 95% C, calls it C++, and makes a bunch of mistakes with the handling of buffers. There's a strong resistance to learning even C++11. 
Some people wish for(int i=0; i &lt; vec.size()-1; i++) would work like they expected C++ has a lot of good features, but it also has a bunch of unintuitive things that more modern languages avoided completely - eg UB on signed integer overflow
No, they are not. We need metaclasses.
I dream of the day when browsers can interpret Python....
will look, thanks
I believe that article is mostly about C or - if you wish - the C part of the C++ language. C++ is intented to be (also) a systems programming language, giving you the privilige to e.g. manipulate raw memory. With privileges comes obligations. You must know what you do and if you do not need the low level access then do not use it. The example code given in the article (all of it nothing anyone would write in the "real" world today) are examples of such bad style. A modern C++ compiler will warn you against that kind of code (e.g. "do not use new" or "do not use C casts"). So - yes - that article is misinformation. And you do not even have to understand C++ or programming to understand that. The language it is written in by itself is a strong indication that this is not a neutral paper - it is a rant.
Very low quality teaching. Teaching "C with classes and no standard library"
Great question. Unfortunately, I've never popped the hood on an open source project to see how well it was written, so I do not have a recommendation to give.
Could you elaborate on what Python does better than PHP? Also, I hate to burst your bubble, bur PHP7 is [verifiably](https://benchmarksgame-team.pages.debian.net/benchmarksgame/compare/php.html) much faster than Python 3. I'm not sure where you came up with that dogmatic statement.
Could you elaborate a bit on how and why these are a better choice as a server-side language?
&gt;And as for backend language, there's a lot u can think of? Could you give me some examples, along with the what/how in terms of their superiority?
A man can dream.
Hundreds of thousands of developers work in C++ every day. I would bet the majority of software you use is primarily a C++ program. Sure Python, Java (Android), JavaScript (Node, Electron), etc. are popular these days as they can be quicker and easier to work with but C++ is still hugely popular. 
It's okay. It looks like plenty of others did that already. I'm not seeing any convincing arguments though... just a lot of "PHP is bad. [insert other language] is good!" without any reasons being given for stating so.
Oh what a surprise another emacs user! But why not give a piece of it and help you brother out?
C++ for a long time was a language a lawyer could love. Lots of trivia and very specific knowledge to writing code. There were many articles and ads for "what's wrong with this code?" in the 1990s and beyond to attest to this fact. Great programmers could could write good code but the potential for poor quality code was great. 
uh.. I don't think any of the desktop software I routinely use isn't written in C++.
&gt; The example code given in the article (all of it nothing anyone would write in the "real" world today) are examples of such bad style. A novice programmer might. They don't know what they are doing, yet. They are relying on the compiler to tell them when they make those terrible mistakes - but it won't, because it's technically valid code, since C++ still contains "the C part". From what I could tell, that was what the author was getting at. Novice programmers are inevitably going to get caught up in one of those holes that an experienced programmer would know not to do. &gt; A modern C++ compiler will warn you against that kind of code (e.g. "do not use new" or "do not use C casts"). What C++ compiler warns of those things? G++ 5.4 doesn't.
&gt; WxWidgets is almost dead among hobbyists. Citation needed. &gt; Qt/Qml adoption is slow. Citation needed. -- In other news, a preview of UWP's XAML compiler that targets C++/WinRT is being released next month. Not that UWP itself is hugely popular, but this will change the landscape of energy-conscious UWP apps IMO and I've been looking forward to it for a long time now.
I tried out Wt for a toy "hello world" project a while back and I was pleasantly surprised. It's not particularly a great replacement for regular web app development, but it really excels in some particular use cases. In particular, if you have an existing C++ desktop app and want to adapt it to a web app, without hiring a bunch of JS developers to rewrite it in JS, Wt would accomplish that goal very well. The Wt 4 release also both allows and follows "modern C++" idioms better than any other GUI toolkit I've seen. The developers really seem to "get" modern C++ and clearly put some thought into getting it right.
Most desktop apps just don't require extremely high performance, and with anything that doesn't require very high performance (or have legacy requirements), that knocks out one of the very major reasons to use C++ to start. For example, Matlab's environment has been snappy since I first touched it 15 years ago, it's a lot more intensive than many apps, and it's GUI is written in Java. As much as I like C++ when you factor in everything it's hard to argue that it's going to be more productive than Java, C#, python, and a few others, when overwhelming performance is not a necessity. For desktop applications where performance is very important, like games, photoshop, chrome, some IDEs, you often see C++ as quite dominant. Of course, nowadays I basically never use any desktop applications at all except chrome, emacs, a terminal emulator, and video games, so...
What's a good cross platform GUI library ? What does something like Chrome or OpenOffice or Firefox use for their GUI?
Python doesn't suffer from PHP's brand of brain-damage, no, but it has its own kind of brain-damage. * Default arguments are static bound references. This has surprising implications for default arguments set to empty lists and dicts: Quite suddenly, you find that the default argument is no longer empty. * Various parts schizophrenically choose `TypeError` and `ValueError` exceptions. * The bytecode machine uses a variable-length 1- and 3-byte encoding, and all instructions are unorganized and haphazard. Some of them behave very differently from how they are documented. * Python has no support for pure functional programming. Lambdas are hobbled to the point of uselessness, closure captures behave very differently from LISP pedigrees, and continuation-passing style is nearly impossible to implement reasonably. * Python is implemented like a functional language, but using quirks in its design that make it very much not that. Classes are actually function closures, but part of their creation copies locally-scoped names to the closure function's attributes. It's quite bizarre and has made one of my projects an order of magnitude more complicated than it needed to be. * A "secure" Python is an impossibility: It's not possible to sandbox Python scripts. At all. I've tried. You have to create a new, incompatible interpreter to get anything resembling sandboxing. I've only been working with Python for a little over 3 years now, and I already hate it with a passion. I'll still take it over PHP, but I hate it.
Whitespace is the *least* of Python's troubles. You can tell how long someone's been working with Python by whether they mention whitespace *at all.* I goddamn hate Python, but you won't hear me complain about the whitespace. Not any more.
IIRC they are around 10 people 
Many cross-platform programs such as the ones you mentioned use their own GUI libraries. Chrome uses Aura. Firefox uses XUL along with native OS UI toolkits for each platform where it makes sense for better look and feel. LibreOffice uses something called [VCL](https://docs.libreoffice.org/vcl.html) which unfortunately shares its name with an old Borland Object Pascal library but is not related. 
Exactly. Pretty much every internet driven app is going to be limited by network latency and bandwidth before it is limited by code execution speed differences between Java and C++. Writing Slack, Instagram, Twitter, etc. apps in C++ doesn't really make a whole lot of sense as performance is directly tied to network performance so using Electron makes a lot of sense from a business perspective. 
Unlikely. A lot of the overhead in Python objects is type and object references, attributes, and a few other things. You can work around that by using things like `memoryview` to get contiguous memory, but then it comes with sometimes intractable limitations. The problem is crossing the C and Python FFI barrier: Python expects extraneous crap that C doesn't use. To get the kind of performance you expect in C and C++ is doing things like rearranging data to fit in cache lines, adjusting for memory alignment issues, segmenting data for multiprocessing, interleaving or de-interleaving data, etc. In Python, about the best you can do is put numbers in a `list` and then take a `memoryview` of it and hope that helps. As an example, I needed to implement LZ4 a while back. A typical C implementation uses about 64KiB of memory, in total. My carefully-optimized Python implementation used well over 250KiB, and we compensated by making the dictionary smaller and running it over smaller batches of data. It's still the slowest code I've ever written, even *after* weeks of tuning and optimization. (It was for an embedded microcontroller; we timed it in terms of seconds per kilobyte.) For any C `struct x` in an array, you can probably expect that making it fully available to Python will demand a non-negotiable `sizeof(x)*6 + 24` stride unless you just don't make certain things accessible to Python or restrict it to `memoryview`s.
How could a novice programmer do that? I really do not see how you could reasonably expect a novice programmer to write a program in the way proposed. I have big troubles imagining him getting caught in one of the examples given in the article. Perhaps a better example could have been the most vexing parse, where you accidently declare a function and not a variable. Anyway that does not form a valid critique of C++. The audience for C++ is a professional one, and a small amount of teaching/self-learning is necessary if you want to program in a language like this. I am not so familiar with gcc, but clang gives the following errors: &lt;source&gt;:7:25: warning: use of old-style cast [-Wold-style-cast] Party *invitation = (Party*) (new Trouble()); ^ ~~~~~~~~~~~~~~~ &lt;source&gt;:6:10: warning: unused variable 'weird' [-Wunused-variable] char weird = "house"[-1]; ^ &lt;source&gt;:4:8: warning: no previous prototype for function 'f' [-Wmissing-prototypes] Party* f() ^ &lt;source&gt;:6:18: warning: array index -1 is before the beginning of the array [-Warray-bounds] char weird = "house"[-1]; ^ ~~ This is for the following program: class Party { }; class Trouble { }; Party* f() { char weird = "house"[-1]; Party *invitation = (Party*) (new Trouble()); return invitation; } 
But people use very less desktop software. I use QtCreator, Firefox, Skype, Slack(non C++), Outlook and VSCode(non C++). Usually, most commonly used app is web site. Now a days, everything is done in a browser.
&gt; How could a novice programmer do that? Check /r/cpp_questions. There's no end to the crazy shit novice programmers will do accidentally. It's easy for us to forget what it was like to learn. When "My code didn't compile so I added or removed `*`s and `&amp;`s until it did" was a viable means of completing an assignment. class Party { }; class Trouble { }; Party* f() { char weird = "house"[-1]; Party *invitation = (Party*) (new Trouble()); return invitation; } int main() {} $ g++ test2.cpp -o test2 -Wall test2.cpp: In function ‘Party* f()’: test2.cpp:5:10: warning: unused variable ‘weird’ [-Wunused-variable] char weird = "house"[-1]; 
&gt; Citation needed. https://github.com/topics/wxwidgets - 114 repositories tagged in wxWidgets https://github.com/topics/qt - 1855 repositoris tagged Now, look at the popular https://github.com/topics/electron - 4088 repositories tagged 
Great info! Thanks for posting!
&gt; What's a good cross platform GUI library ? Qt is cross platform between ubuntu and mac. WxWidgets is cross platform between windows and mac. &gt; What does something like Chrome or OpenOffice or Firefox use for their GUI? Chrome is gtk with custome toolkit for look and fell. Firefox uses Gtk for linux and native win32 for windows. It has it's own wrapper library. I don't know about open office.
Upvoted. I frequently see people writing C code, compiling it with a C++ compiler, and calling it C++ code. It's not. There's a C way of doing things, and there's a C++ way of doing things.
And these problems are even worse when you're trying to develop on an embedded system. Some of it is downright maddening. Package management and library reuse is also a big problem.
The Standard Template Library is the foundation of modern C++. The creation and publication of this code and its documentation set a new standard for the formal specification of what a computer program should do, how it should be designed and how it should be formally documented. These pages were maintained first by Silicon Graphics and then later by Hewett-Packard. In January of 2018 these pages were removed by H-P. This is a historic blunder. I have recovered the original STL Library Document and hosted them here.
Qt is the notable (and IMHO best) cross platform C++ toolkit, including GUI. That said, none of the three you mention use Qt, they each use their own custom cross-platform components (though Chrome and Firefox build on top of GTK+ on Linux).
Upvote for good ol' QBasic, which was also present on Windows 3.1 systems on DOS 6.22.
I program in Java mostly, C++ probably my second most used language. Here are a couple of reasons I try to use java over C++ when its not the clearly worse choice: 1. First and probably most importantly, I learned it first. 2. Strings &amp;&amp; Config files. I have never liked Strings and their usage as much in any other language as in Java. Once you get really used to C &amp; C++ you can get a method of libraries going that works well with whichever version of String that you end up using, but even then, you might encounter headaches where certain algorithms you find use a different type of "string" class than you. 3. Syntax can be really confusing/annoying. Like for instance, when I first started getting back into C++ after not touching it for like 5 years, it was EXTREMELY frustrating to not be able to use "this.a = a" in the constructor of the .cpp file where the method declaration was in the hpp file. 4. Not easy to get started in/deploying for the first few times. I remember compiling an exe with Visual Studio and then trying to run it on a separate machine only to realize that it relies on the machine having certain distros already installed. 5. IDEs. Netbeans and Eclipse are both free, and once you get the hang of them, they can be extremely powerful (I prefer netbeans in most cases, but generally use Eclipse when doing J2EE stuff). Now, I have spent probably 4/3 more time in Netbeans than in Visual Studio, so it might not be a completely fair comparison, but from what I have seen and felt, Netbeans was 100 times more intuitive, and every bit as powerful. I have tried other IDEs for C++ and VS ended up being the most similar to what I like, so I stuck with it. 6. Multiple Inheritance/The Diamond Problem - this is probably 100% preference, but I guess I just prefer the Interface design style over that of multiple inheritance. It just feels "sloppy" and "wrong" when I use it in C++. 7. Dealing with Arrays and memory allocation is a huge headache compared to "easier" languages at first. One thing I like to do is make a bunch of util classes with static methods for manipulating Generic Arrays, objects, etc, and dealing with the dynamic array size and the templates is always much more of a headache than Generics + Java Arrays. I also feel there are a ton of situations where its harder to debug and figure out what exactly happened ("undefined behavior" ugh) in C++ when compared to Java. Then again, I haven't been using Java on embedded chips with very picky memory handling, so the tasks I take to Java tend to be much more intuitive. 
I can clean up many C++ messes, but my time is going to cost you more than that of the guys that you paid to create those messes.
I love the static typing and deterministic destructors.
We're still copy and pasting entire files into each other....so any form of package management is better than our approach...
It's in mix of C++ and Rust. I was talking about eco system for desktop app. Most network switches use C/C++ which use assembly which use binary. Should we give credit to assembly and binary ?
It's been a long time since I last saw a non-C or non-C++ desktop app. Not sure what you're talking about. Everything I use on a daily basis is a native C or C++ application. My browser, my mail client, my music player, my movie player, my virtualization software, my document editor, my terminal emulator, my FTP client, my VoIP client, my IDE... Actually I don't remember when I last used a desktop app that wasn't written primarily in C or C++. But maybe this is only true for the OS I'm using (Linux). It might be different on Windows and macOS?
&gt; Qt is cross platform between ubuntu and mac. Actually Qt is cross platform between Linux (not just Ubuntu), Windows, macOS, Android, iOS, and quite a few other ones (including BSDs, commercial Unix brands, embedded devices...)
Thank you so much for doing this. Looking through those pages brings back lots of memories. I remember reading them, and Mumit's STL Newbie Guide http://web.archive.org/web/20041027083116/http://www.xraylith.wisc.edu:80/~khan/software/stl/STL.newbie.html trying to make sense of what this weird library that was unlike any other data structure and algorithm library. Thanks again for preserving this very import piece of C++ history.
 &gt;"Check /r/cpp_questions. There's no end to the crazy shit novice programmers will do accidentally. It's easy for us to forget what it was like to learn. When "My code didn't compile so I added or removed *s and &amp;s until it did" was a viable means of completing an assignment." I do not agree. If you have a problem with some code, randomly adding/removing characters is not a good way to solve your problem. You should understand the cause first - then it will be easier to fix. This is the essence of learning. Also if you want to be a serious programmer, you must have a desire to understand the problems you have. Regarding the cpp_questions reddit, I did a very brief check. I did not see anything looking vaguely like the problems descibed in the anti-C++ rant. Instead I saw questions that could have been found in just about every language. I used -Wall -Weverything to compile. 
I see both of these problems regularly, I think the [Core C++ guidelines](https://github.com/isocpp/CppCoreGuidelines) are trying to provide a baseline for the community so people know how different they are being. I think this kind of effort will pay off in years.
OpenCV isn't bad to use. I haven't gone digging around extensively in its source, but that's mainly because I haven't had to. The Eigen math library is also pretty good. Most boost projects don't suck, but some of them are too clever because they can be (Looking at you, program_options.) If you want a good example of a bad one, look at Gdal. It assumes extensive domain knowledge and familiarity with the library on the part of the programmer. Sure, you can do just about any GIS-related thing with it, but you'll spend most of your time trying to determine who has ownership over what objects.
"Chapter 1: Introduction" and the sources excel spreadsheet are actually located at http://www.aristeia.com/Fastware/
You give credit at the abstraction level where it is relevant. For the same reason machine code shouldn't aspire to be used for making UI widgets, why should we expect C++ to transcend to higher levels of abstraction where other solutions are viable due to lack of constraints?
I see. Thanks for clearing that up. 
Jesus, you came here for an argument.
C++ is way too... Big. There's too much going on. Writing waterproof C++ means accounting for countless edge cases, especially if you're developing a library. There's no single way of doing anything and the language has no coherent understanding of what it wants to be: instead it tries to be a Jack of all trades and ends up being a master of none. If you're looking for a solid, modern, low-level language that's actually designed for, you know, human beings in mind, spend some time playing around with Rust. It's still evolving, but what it can do right now is extremely impressive. I promise you won't be disappointed.
have a look at the libc++ or STL implementations. Or llvm
&gt; The problem is crossing the C and Python FFI barrier Thanks for this. A lot of people in scientific computing get caught up seeing isolated benchmarks where a single piece of python code that is using BLAS behind the scenes performs well. But in real world complex code, python is a couple orders of magnitude slower than most C++ code.
Really interesting, I had no idea that was in the works!
Very cool, I'm glad I'm not the only one to attempt this. Maybe it's a little less niche then it seems!
That's kind of navel gazing. I think he means things like actual applications and domain specific libraries.
JUCE is great, they've taken a hard line stance on coding their-way, their-style, and it's paid off: clean, modern, delicious. It's open-source for GPL'd projects, commercial license otherwise. https://juce.com 
https://www.reddit.com/r/cpp/comments/8bouu7/why_is_c_so_hated/dx9ohgq/
You can take a look at seastar framework
&gt; enum class like thingy suitable for bit flags, which would allow bitwise operations while preserving scope rules and safety of enum class This is already relatively easy to do: [flags.hh](https://github.com/mawww/kakoune/blob/master/src/flags.hh) Just declare `constexpr bool with_bit_ops(Meta::Type&lt;MyEnumType&gt;) { return true; }` just after you enum class definition to opt-in flag operator support.
I am probably heavily biased as I am the main author, but I believe [Kakoune](https://github.com/mawww/kakoune) has a pretty clean C++14 code base.
[HPX](https://github.com/STEllAR-GROUP/hpx)
The i-cache doesn't care about branches; you seem confused enough on this point it might be worth revisiting what the instruction cache does. In essence the instruction cache hides instruction fetch latency on accesses to instruction memory, and you harm it by having a working set of active code that is larger. On the other side of things, branch predictors are very good in predictable loops like this, so you will tend to only mispredict once per loop (plus negligible noise). This means you'll actually mispredict *more* with unrolling, since you need a second loop for cleanup! Reducing branches does reduce the cost, but it's only the cost of actually running those instructions, not of branch misses. This discussion should mosty still apply to any Opteron, though I am not an expert in that class of machines specifically.
https://github.com/rigtorp/awesome-modern-cpp
That's pretty good. (I must admit that I'm pretty impressed at how neat ICC's assembly is, being used to Clang and GCC's.) The only obvious suggestion I can think of is using a sentinel value, aka. https://godbolt.org/g/khEKzk. I'm not sure how much it'll help but it should be nonzero.
If they're using Perl for building C++ I'll take a guess that their build platform (and maybe even the target platform) is Linux. In any case you should check out Nix, you might become the hero who "came and solved all our build issues".
My recommendations: https://howardhinnant.github.io/date/date.html https://github.com/nlohmann/json https://github.com/fmtlib/fmt
Mumit Khan and the STL for newbies, had almost forgotten it. When I stumbled on this site (days before Google), I had shared it across the whole company (developers)
Error reporting in C++ is awful, especially if any STL is involved. I mean just look at this monstrosity: std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;::basic_string(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned long, unsigned long, std::__1::allocator&lt;char&gt; const&amp;) I'd say 80+% of coding time is spent reading and/or debugging, and C++ makes both of those tasks very miserable with code noise and cryptic errors.
&gt; Where a dev problem (time to make/maintain) is turned into a user problem (high resource usage ) Unfortunately extremely inefficient resource consumption didn't stop slack from becoming a multi-billion dollar company. You might think that 2GB RAM is too much for a chat application, but the users won't be able to narrow down the reason why their computer works so slow, so they won't blame Slack.
Thank you for your constructive answer and giving me your time, I really apreciate it :) &amp;nbsp; &gt;How do you know if `param1` or `param2` is passed as a pointer? Go see the type. &amp;nbsp; Exactly, but at first sight one can not guess it, and if the type of the object is behind a shorter name, so this one must be seeked because whith the rollover the editor will just say 'CustomType', so it becomes an disgusting travel (read, stop, seek, read, stop, seek [...] okis, all under control). With an visual indicator one can avoid most of that cases. &amp;nbsp; &gt;The same holds for smart or raw pointer. `std::unique_ptr` makes things more explicit, so the situation is better with smart pointers &amp;nbsp; I think keeps happening the same, the only alternative I am able to think is to add in the name of variables if its a pointer and what kind (Unfortunately it is quite unseen nowadays). &amp;nbsp; void function( Foo foo ){} // Copy void function( Foo &amp;foo ){} // Address reference void function( Foo &amp;&amp;foo ){} // Move &gt;Also, there's a problem with your third line. Taking a `Foo&amp;&amp;` is NOT pass by move. In fact, you cannot move ownership calling this overload. It's taking a reference, which means no ownership is transferred.[...] &amp;nbsp; The behavior when called with std::move is like if it were transfering the ownership, so since a time ago I assumed it was being transfered (I always keep track of destructors). The same happens with pass by value, most of the times can not be optimized and it is copy, so I usually call it this way just by habit, not due anything else. &amp;nbsp; &gt;was moved and is not present in this scope. &gt;&gt;I highly disagree with that. You can use moved from objects. Here's an example &gt;&gt;As you can see, it's useful using moved from values. &amp;nbsp; Thanks, yep, it is. I never though about using it that way. But, just take in account that without that error, calling that functions I commented is a runtime crash, maybe catch in time, or not. &amp;nbsp; function( foo_pu ); // Do Copy of Foo ( Not the pointer ). &gt;Oh god please no. You want any values to be implicitly constructible from a pointer?? You want things to be clearer with more implicit copy even when using a pointer? &amp;nbsp; :) , I confess that I didn't liked when I wrote it at first, it is excesively^2 accesible. I included it for to feed threads, and for take in account that my unsucessfull original menssage, even with some term mistakes, is for to try to make all the operators visible at first sight and with external/aparent *matching* operators behaviour. &amp;nbsp; function( &amp;foo_ps ); ············ function( foo_ps ); ········· call ( std::shared_ptr&lt;Foo&gt; ){} &gt;So if I understand correctly, When passing a pointer around, we should use `&amp;`. But then, you copy the pointer.[...] &amp;nbsp; That `&amp;` would work mostly like the std::move template, with some kind of xvalue type modification? what would let the compiler catch the lvalue as it works nowadays, it would be like if it where just an esthetic `&amp;` when is together with a smart pointer. But, for let the compiler to know when to do it this way or not, would be necesary another indicator/flag, lets say `OperateAsPointer`, in the templates of the smart pointers (or any user custom object definition wishing similar behaviour). I thought also that with the cross of the time the people would not keep the discipline and they would not include such `OperateAsPointer` in their definitions, but... well, I am just saying what I see. &amp;nbsp; &gt;I must agree that having an operator to move and forward would be really nice. I absolutely loved the `&gt;&gt;` operator proposal to forward a value. It's really sad it was rejected, the syntax was really clear and much less verbose than current solutions. Maybe we can resurrect the proposal with an additional unary `&amp;&amp;` to move values? ;) &amp;nbsp; :) the variables inside `std::move` becomes very unconfortable to read, but at least it is visible the intention when it is done. &amp;nbsp; &gt;If your proposal were accepted, how would you pass a reference to a pointer? Imagine that &gt;Under your syntax, calling this function is not even possible. &amp;nbsp; You are absolutely right, that posibility would be lost, but I did not found a practical example using it. Yours sound a bit forced, although it is rightful/legitimate. So even if it were a serious proposal following the template, with some weeks of deep developing, and also including some stack and heap things for to cover more matters that could be included taking the ocassion, problably would be rejected because something like this. &amp;nbsp; &gt;I have a suggestion for you: work to clear your mental model about pointers/reference/objects. Reference are not objects. Pointers are objects themselves. &amp;nbsp; I am just suggesting to make them distinguishable in function calls with a visual indicator, for to help in the reading code intuitiveness, and at same time give them some kind of superficial matching operator behavior. &amp;nbsp; &amp;nbsp;
You could try Nim if you don't want to trade away execution speed. 
&gt; Having a generic container was such a big step compared to hand crafted containers storing data as "char *" and typecasting it back. Well Mr. FancyPants, back in my day we stored our data as `void *` and we liked it!
Is boost::variant better than std::variant? Because std::variant turned out to be annoying AF to use IMO.
Your debugger problems happen because you use optimizations, and well while there are obviously some ways to improve this it will cost performance.
People who understand their tools well are entirely qualified and should feel morally compelled to bitch about them.
So you'd make something like UTF-8? Values between 1-127 on one byte, up to ~30k on 2 bytes, etc. I bet it would perform better than C-style strings in many situations.
This one? https://www.youtube.com/watch?v=fI2xiUqqH3Q
But finding out bugs in Javascript is hard, since it will happily convert anything into something else to avoid throwing an error.
There's a reason it's Perl hates PHP.
As long as your Python code is 99% calling expensive functions like BLAS, you won't feel any slowness since these functions use C or C++. Having Python to go through your folder and calling a C/C++ program on each file is great (considering how painful it would be without `std::filesystem`).
&gt;Qt is cross platform between ubuntu and mac. [Here](https://mhogomchungu.github.io/sirikali/) is an example of a GUI project that uses Qt and it works in Windows, Linux and MACOS. Scroll to the middle of the page to see screenshots of how the GUI looks like in Linux and Windows 10.
That might, _maybe_, be an interesting metric if your question was regarding OSS, but as it is... The code I write at work doesn't go on Github, and the code I write at home doesn't go on Github (for the most part), so I can hardly consider Github tags to be a worthwhile metric, especially in regards to an ecosystem where most code is proprietary/closed-source. Keep in mind that Qt offers a commercial license – Github doesn't help you measure that.
&gt; I can’t imagine a sensible intro programming class that doesn’t make git or hg an integral part of the curriculum. Nobody in university ever mentioned something along the lines "you should use source control". I started using it because I figured out commenting old code just made a mess and it wasn't very safe.
Simulate?
You'd be surprised. Books that rely on fundamental math remain useful decades after their publication. I'd bet at least 80% of the books is still relevant. It's the programming books that go bad like milk. ;) 
I haven't used `std::variant` yet, but looking at the docs, it's quite similar to `boost::variant` in many respects. 
Yes. Use high bit to denote whether it’s the last byte of the value or not, and order the bytes little-endian. Each byte then adds 7 bits to the value. 
C++ is a system programming language nowadays. It is more used to write platform software such as OS, browsers and platform, in another word, where the performance matters.
There is KDE with it's Plasma 5 desktop and many applications like Kile, KDevelop, Kate, Juk, Okular, Dolphin, ..., ..., ... But indeed, it would be nice to have more contributors (as always).
Boost is a collection of libraries and each is documented in slightly different style. The proper way of documenting stuff for boost would be to adopt the cppreference style. They do usually document everything, though. Submit a bug report when something is missing. All public APIs should be mentioned in the docs, and usually are. Sometimes finding them is hard when there are many layers to the documentation of a single sub-library. 
A lot of the JRE SE is written in C, but Java apps are Java apps.
old language -&gt; large / old codebase -&gt; legacy / little say -&gt; moaning.
The entire company is, but the main developer is 1 guy. The others are often working on other projects. 
I didn't take it that way :)
You seem to have narrowed the scope of what a “good” language to the exact feature set of your preferences (wrt semantics, libraries, distribution, build systems, etc.) and then come to the obvious conclusion that only your preference makes sense.... well duh 🙄. The point of that quote starts with the fact no language that is used is perfect and ends with all perfect languages have no users. 
Because it encourages bad practices, mainly no dependencies and “the compiler is your enemy not your friend”. It is also difficult, though not impossible, to write code in it. What’s close to impossible is telling whether the code you wrote is correct.
Compared to Gdal, it's a dream. 15 minutes in the tutorial and you'll be up and doing image recognition. You can talk about what's going on under the covers all day long, but if people can't use your code, it doesn't matter how clean and elegant it is. It's still just a big pile of unusable code.
How can you know it will be safe forever? Do you have a proof it won't disappear in the future? 
Very good idea with the sentinel, and thank you for the spotting the bug, I'll correct the link again.
Not an attic! It's the upper floor of a cowshed! :-) Well, it used to be a cowshed decades ago...
Well, you've got some fancy pants too! You've probably never used C before it was standardized. Glorious days when they added void and even better void* to refer to a block of memory with unspecified type!
I'm proud of these: https://github.com/Ebenezer-group/onwards/blob/master/tiers/genz.cc https://github.com/Ebenezer-group/onwards/blob/master/tiers/cmwA.cc They are open source, but there's also a closed source component. My approach has been to minimize the amount of code you have to download/build/maintain. 
Yep you are unfortunately right. Though I don't think we are even close to hitting the peak of the problem, Electron is still pretty new and as more and more start using it the bigger the problem it will become. I am interested to see what will happen at that point.
LOL...no I never used C before void/void*. I can't imagine what those days must have been like.
FYI: qt/QML is not c++... but hints at the new reality... The world has changed, for the most part we don’t write single language programs anymore. More and more C++ is being used as a back end/library language. It is you shared/reused cross platform code. Wrap it however you want to do the ui. Right tool for the job and all that....
Thanks and yeah I've heard about Nix and yeah target platform is linux!
&gt; Does C++ actually make it harder to develop desktop applications? Well, only if you think installing something like Qt or wxwidgets is hard. I feel like a lot of what you said is technically correct, but also reflects a huge amount of denial in the C++ community when it comes to how software is being built these days. The fact of the matter is that developing a modern GUI with C++ is incredibly labor intensive - framework or not. Web technologies make this process far, far, far easier, and that's why they've succeeded so hugely. Note that I write C++ nearly every day, and I totally love the language. But I think the process of doing a GUI in C++ is frightening and horrendous, and I would personally rather use web technologies to make a GUI. It's not even difficult at all to get something running with web tech. It's almost terrifyingly easy. I really feel like, for all it's improvements, C++ was damaged incredibly by the 8 year hiatus between 03 and 11. That was when web tech really took off, and the C++ community was just mostly silent while it happened. Anyway, I'm not trying to be negative nancy, but I feel like our community simply has to get past the denial about how difficult it is to develop UI tech in C++. The thing is that the UI _is_ the product, and this is something that a ton of web developers really really really understand, and yet it seems to have utterly escaped our community.
I believe John Kalb still provide this training once in a while I don't think anyone can share freely the content but as I had the chance to see the material, I know that the following talk include many slides provided by this course: - Talk: [CPU cache and why you care](https://www.youtube.com/watch?v=WDIkqP4JbkE) - Slides: https://www.aristeia.com/TalkNotes/codedive-CPUCachesHandouts.pdf It only cover one part of the class (with less slides that the original pdf, but he talks in details about the topic regardless)
Which I why I think simple assembly is the best introductionary language. Not Javascript. Not Python. Not Java. Assembly.
Oh, I didn't know it was lost and needed to be recovered. I could've helped: I made a local copy of it some years ago. That said, I'm not sure the original documentation is very useful these days, since it doesn't cover recent additions. I mostly use cppreference.com and cplusplus.com nowadays.
C++ implementations are slow because they are not implemented the same way as the faster implementations. Example, I wrote the new k-nucleotide entry that is now the fastest in benchmarks game https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/knucleotide.html. I found out previous fastest C++ implementation (C++ G++ #3) did things differently from the top entries, and those difference is what made it slow. One example is, it fully recomputes the key for every insert to hash table, this is different from top 3 entries that only does incremental changes to the key. 
You can also have a look at my http tool: https://fabiobento512.github.io/FRequest/ The mainwindow file has a lot of stuff but other than that I guess it is quite well written. It uses some modern C++ features like for loops, lambdas, new keywords like override, smart pointers etc. It has also some raw pointers but that is because I am using Qt, which requires them for their libraries.
Thanks. We don't intend to stop.
His debugger problems can be solved by doing a debug compile and using Visual Studio.
A lot of stuff is accidentally Turing complete though, This doesn't only apply to C++.
How did you get that from what I said, given I mentioned none of that? If you want me to actually put forth an argument for my position, it would be more like comparing [this](http://en.cppreference.com/w/cpp/regex/regex_search) to [that](https://docs.rs/regex/0.2.10/regex/struct.Regex.html#method.captures). Clearly only one of these is healthy.
&gt; It takes years to really get a grasp on it and lower level programming in general, where as any beginner can hop in to C# and not care about dynamic allocations or pointers becoming invalidated. Right, but while the beginner can easily hop into C# the beginner will also fail at writing code that has good performance. It's much harder to write slow C++ than it is to write slow C# and slow Java.
That university is not being responsible towards its students.
I actually would suggest Alex Stepanov's lectures at A9. He takes you through writing a bit of code, and then analyzing it and rewriting it to become better and better.
&gt; As long as your Python code is 99% calling expensive functions like BLAS, you won't feel any slowness since these functions use C or C++. Sure. But at that point why am I using python at all?
Well, I too would like to see an C++ mode that breaks backwards compatibility. "C++20-strict" or whatever comes next.
Wouldn't using string_view in WriteCount gain more performance?
&gt; Is it because cpp at its core is harder to understand than many other languages? It's not really harder to understand, but a C++ programmer has to have some understanding of the basics of the underlying system to use it properly. It seems students nowadays have no interest in learning HOW a computer works. Basically you can't be a professional C++ programmer (as in someone that's employed in an organization for the purpose of writing C++) without also knowing the basics of assembly language programming. You will undoubtedly have to fire up a debugger as some point in time and look at actual machine code. Universities also don't teach the language correctly. What they should do in the first weeks, is have an introductory course in OS fundamentals. Bits and bytes. OS memory management and assembly language. Stack and heap and how C++ relates to all these concepts.
Do you plan on seeing if you can get `archive.org` to take it up too?
So why would a compiler report a string like that? I'll bet that the original source code looked very different from this - probably without all those std::'s, the allocators, etc. Why is it necessary for the compiler to provide the fully expanded symbol name, instead of what the programmer originally typed? A while ago there was a script where I think someone stripped all the namespaces out of error messages. Turns out you can actually read them if you do that! So isn't this simply a fact of compilers doing a lousy job at generating error messages, rather than some fundamental problem with the language? 
Also you can until June 10th submit your talk ideas to Meeting C++: https://meetingcpp.com/meetingcpp/news/items/Submit-your-talk-to-Meeting-Cpp-2018-.html
Do it! Also pass is as `const char (&amp;)[N]` so the size can be deduced from the string length using a simple deduction guide (N would be needed to reduce by 1 due to `'\0'`).
Why don't you reach out to him and suggest he submit something!
Thanks.
What kind of stuff?
Irrlicht is old and has bad API. Not sure if it was good even for 1998/03. They even require you to manually change reference counts in resources, but the library also changes them inside.
I mentioned it, going through folders is painful in C/C++ and `std:filesystem` is not available everywhere (and I still think Python makes it easier). If you want to process many files, a script calling C code is a very normal thing to do.
Well it's usable but the documentation is terrible for most functions and I got bitten because functions did things I didn't think they would do because the interface is specified in a shitty way. Having to read the code of the function to figure why it's extremely slow is not good library design.
Imagine days before `typedef` and `const` existed.
They `std::promise`'d it will be always available in `std::future`. It would be bad if we lost it into the `void`.
Throwing an exception shouldn't be a problem or cause a deadlock. The exception should be propagated normally out of the `call_once` function. The throwing call doesn't count toward the 'once', and so some other `call_once` invocation should call the function again.
Thread t1 throws exception and then exits. I am getting deadlock in call_once for remaining threads t2, t3, t4.
[Here's][1] the example in clang trunk. I also tried with gcc trunk and it seemed like it might have deadlocked. In any case, it shouldn't and if it does that's probably a bug in the implementation. [1]: https://wandbox.org/permlink/KItOvCvTrbqH3J0y
Interesting differences in the compile times as well. A metric that is often forgotten. 
I can confirm, it does deadlock most of the time on GCC 7.2, clang 4, clang 5 (all with libstdc++ 7.2). Ubuntu 17.10. 
Indeed, like the steam engine and the mechanised loom...
That’s what I’m saying: those 90% should be very ashamed. Even pros might change something and not quite recognize exactly what made stuff break. Noobs? They need all the help they need. git makes noobs more productive and less afraid of trying things. My uncle teaches a 3 semester long programming intro course and he doesn’t even begin talking about C++ until they can manage their `README.md` without fuss, and can push and pull from their school repo. The school runs github enterprise or something similar for their students, so the repos are all private and class repos are not forkable between students for obvious reasons. 
There are flatmap implementations out there. 
The memories, I have spent so many days going to the SGI web site to learn it.
Thanks. I guess it wouldn't be accepted because it says here: https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/knucleotide.html#knucleotide" That programs must use the same algorithm for a task.
This one looks like C++ again, the last one I checked looked more like C. Great work whoever wrote this!
What does gz means? (next to mem/cpu/...)
However, there is no C++ porn, because C++ IS porn and horny.
The description also says &gt; Mapping the DNA letters to the bytes 0, 1, 2, 3, and using a hash function that concatenates those two-bit ~byte~ codes is an acceptable (but not a required) optimization. There is no limitation on *how* the mapping is done.
But I have to call vector::resize() to to get the correct size with vector::size(), and correct iterator end.
Thanks for sharing. This article was really interesting.
I guess you're right. I just look at all implementation on knucleotide and see all of them use look up table. So probably the "use the same algorithm" also meant using look tables for all implementations. 
Thanks!
From cppreference: &gt; If value-initialization in overload (1) is undesirable, for example, if the elements are of non-class type and zeroing out is not needed, it can be avoided by providing a [custom Allocator::construct](http://stackoverflow.com/a/21028912/273767). About `std::array` - I just meant to replace C arrays to STL array to avoid duplicated numbers.
What happens if someone in the Discord chat uses the word "guys" to refer to a mixed-gender group?
403 FORBIDDEN ERROR
[Its a measure of source code complexity.](https://benchmarksgame-team.pages.debian.net/benchmarksgame/how-programs-are-measured.html#source-code)
Thanks.
Hey, it's funny to meet you again. How is my cat doing. Still the paper clip's friend?
&gt; Yes, people talk differently about C++. You would not see a post titled "Why is Python so hated" on the Python subreddit. I am not denying that there is a natural baseline of dissenting opinions, I'm arguing that Bjarne's quote is used to ignore the fact that C++ isn't at that baseline. This is not a healthy attitude towards criticism. I think this is all true. But my next question is so what? C++ is ugly mostly because it's stuck in the framework of backwards compatibility with C and ancient linking technology and because it leaves a lot of flexibility to the implementation (which is, again, largely inherited from C). Bjorne knows this - he himself has said "Within C++, there is a much smaller and cleaner language struggling to get out." But it's not going to come out regardless of whether the C++ standards committee accepts criticism or ignores it because they're not going to break backwards compatibility either way.
[Crabs](https://www.technologyreview.com/s/427494/computer-scientists-build-computer-using-swarms-of-crabs/) are almost there. The OR gate works pretty well, but apparently the little critters are fickle when it comes to ANDing.
Nah, it's deprecated. [Just 2 functions](http://en.cppreference.com/w/cpp/memory/allocator) and ctor+dtor.
I don't think json/xml/yaml/toml should be included in the standard library. They are just fine as external libraries and I don't see any huge advantage in including these in the standard (plus these text data formats tend to be volatile in its specifications and global usage).
If you are concerned about out parameters you can use a little C#: func(arg1, arg2, /* ref */ arg3);
package manager then pls
Yes a package manager + modules should solve this.
Great work! A few general style comments, cos I'm being picky: * It's usually better to use a signed integer type as a loop variable, as the compiler can assume overflow never happens * `auto` as a parameter to a (non-lambda) function is a GCC extension, not part of standard C++ (yet) * `string_view` as a function parameter should be taken by value, not by reference * There's no need to receive the result of `CalculateInThreads` by `auto&amp;&amp;` -- you're just lifetime-extending a temporary anyway. Plain `auto` would be fine, and would appear less magical to readers * While IO isn't exactly going to be a bottleneck, you can get better performance by turning `sync_with_stdio` off
&gt; Also, I fear using `unsigned` as loop counters is suboptimal. Depends on the compiler. In some cases, using `unsigned` can be faster - in others, slower. `signed` doesn't allow for *more* optimization, just *different* optimization. I tend to prefer using thin wrapper types in those circumstances, using the compiler's equivalent of `__assume` to establish value constraints. Gives best-case performance.
It seems that it is easier to dismiss the language rather than their own inability to comprehend things. It's amazing how much ignorance there is w.r.t. the lack of knowledge. People will rather bitch about the language how bad and complicated it is rather than getting the hands dirty and actually _learn_ the topic. With such an attitude they're being dishonest to themselves first because they are not realizing it's them who are missing, and second, they're polluting the community with negative and incorrect information. There's however a very small minority of people who actually give constructive criticism and that has been always very well welcomed.
Where in that file so you see initializer lists?
Look at the boost library project 
I worded that completely wrong. C++ and object oriented programming in general is very focused on dynamic memory allocation. Sure you can jump through hoops to redefine the memory allocation operators to throw errors and you can even attempt to rewrite the memory allocation yourself to be safer and deterministic. You really must have a certain mastery of C++ to navigate these waters though and it really isn't worth the trouble in most of my experience. If you take away dynamic memory allocation from C++ you cripple many of the OOP features that gives the language its strength. In general I see C++ and OOP as a programming methodology that strives to abstract away from the underlying system it is running on. This is extremely useful and powerful for many applications. In the low resource, real time and safety critical environment that I usually deal with, C++ becomes more of a liability. When you are focused on direct effect of each function call to the underlying hardware, abstraction greatly complicates things. It becomes harder to see the resource costs of each line of code so debugging and code reviews can become a nightmare, especially to those who have spent most of their careers coding in pure safety critical C applications.
This pattern is very similar to the one given by [Chandler Carruth in this talk (40:04)](https://youtu.be/yG1OZ69H_-o?t=40m4s). `unsigned` in that case slows down the code. What optimisations does `unsigned` allow which should make it faster?
There are some ifdefs for portability between platforms. There's only one global variable. I don't think there's a problem with using both exceptions and asserts. I use makefiles on Windows, but will include project files for Windows if that's helpful.
Interesting article. Just one thing that could be confusing: part of your article refer to "visitor" struct (first example), but in your code, it is called "overloaded".
thanks, those are good points, it all makes sense to me. I was only amazed by how unsigned arithmetic was faster than the signed arithmetic in one benchmark that I did. So from then on, I was using unsigned in everything. You can test it here: https://ideone.com/QfmPCL . 'GenUnsigned' and 'GenSigned' are PRNG functions that are called 200million times in loop. They all show the same result but have different timings. I tried turning off sync_with_stdio() before, but got weird behavior when writing to output, it was not showing the output until after the program exited, do I have to call flush() each call to cout?. Or was probably a bug on GCC or something. 
&gt; Default arguments are static bound references This is actually one of the stupidest implementations I've ever encountered. I'm not sure if anyone ever in the history of programming has ever wished for Python's particular implementation.
&gt;constexpr Array() `: ptr_(nullptr), count_(0U)` {} That's member initializer list, if you didn't know.
Nice work! I also found some room for improvements (but did not measure them): 1. Instead of `freq.insert({..., ...})` the `freq.emplace(..., ...)` 1. Pass the `string_view` by value 1. In `operator std::string() const` you can `reserve()` the tmp's length with `size`
What is "by gz"? What does that measure? 
I initially read this as "knuckle-otide". Gave me a chuckle-otide.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8c0ias/could_you_please_participate_in_my_survey/dxb381b/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Would that bit twiddling still be faster than the array lookup, if every nucleotide has to be converted to uppercase first, in case the letters are randomly uppercase / lowercase ?
At a guess, the unsigned vs signed thing is because of the modulo operation in your example, which IIRC is more expensive for signed types. Not showing the output until the program exits isn't a bug, it's intended behaviour -- `cout` is buffering the output until its destructor runs. Like you say, you can do an explicit `flush` (or `endl`) if you do need to see the output in "real time".
&gt; OpenCV isn't bad to use. It's OK to use, but the implementation is AWFUL. The API is also a mishmash of the old old old C interface ported to C++, with some typesafe bits and bobs sort of shoehorned in. Also, some of the files are an absolute nest of #defines, and speaking as a CV person, some of the algorithms are of dubious correctness as well. I still use OpenCV of course, but please don't take it as a good example of C++.
Rust came out of industry: Mozilla is a company, not a university. Plus, ownership is complicated.
Yes, the method is case-agnostic. In ASCII the case is signalled by a bit not relevant for this method. See `man ascii`.
I would say about 80% of the opinions I've heard about rust are actually positive
Ugh. Make is a fantastic tool. I really really really wish the build system "designers" who want to do "better than make" actually understood make before trying to improve it. 
I found that the code in the example doesn't actually compile, I had to change it to the following to make it work. #include &lt;string&gt; template&lt;class... Ts&gt; struct overloaded : Ts... { overloaded(Ts... t) : Ts(t)... {}; using Ts::operator()...; }; template&lt;class... Ts&gt; overloaded(Ts...) -&gt; overloaded&lt;Ts...&gt;; auto func() { auto f = overloaded([](const std::string&amp; a) { return a.size(); }, [](int b) { return b; }); return f("hello") + f(2); }
I agree that optimizations will, intrinsically, mangle the code to some degree indeed. I can live with inlining, loop hoisting, common sub-expression elimination which move the code around. What is really hard to live with, however, is the fact that the compiler+debugger could not figure out a way to *reconstruct* the value of the variables they eliminated. The DWARF format, I think, allow encoding information which allows such reconstruction, but it's been my experience that "optimized out" regularly pops up. Just last week, I had 3 frames of the stack where *all* parameters were "optimized out". It makes it really difficult to analyze what's going on :(
i know..
Did you try doing the same with static locals? Honestly I just use static locals for this, I find that it's just easier to use, especially when the code is not generic.
Don't put flush after every call to cout, only flush after writing considerable amount of data to the output. Writing to output is expensive. Better to do it once with a lot of data than multiple times with little data.
Yes, because as it is now it is a) confusing (« he said a different name, but not what the name is. Does he mean ‘overloaded’, or is this something else? Does it works exactly as the example or are there other changes? »), and b) hard to us(« cool. let’ s copy/paste it. Uhh? Do I need to read all thing and change stuff? God, why?”) 
Since to_num is not being changed you can generate it as a constexpr. constexpr auto make_to_num() { std::array&lt;unsigned char, 128&gt; tmp = {0}; tmp['A'] = 0; tmp['a'] = 0; tmp['C'] = 1; tmp['c'] = 1; tmp['T'] = 2; tmp['t'] = 2; tmp['G'] = 3; tmp['g'] = 3; return tmp; } constexpr static inline std::array&lt;unsigned char, 128&gt; to_num = make_to_num();
&gt; Imagine days before typedef and const existed. [What?](https://i.imgur.com/7JLwsqH.gifv) 
&gt; There is no Valhalla of languages, they're all just tools. If that were true, Lisp, the third-oldest programming language, wouldn't be making comebacks every few years.
I see \- thanks for the response. I guess my view on that \(as a C\+\+ dev\) is that when I hit a part of the codebase where OOP is either unnecessary or an active impediment I can instead manage everything myself, using C itself. So in C\+\+ I can wrap everything in what \_to me\_ are useful, abstracted structures but when necessary I can employ pure C. I guess what I'm saying is that to me I've never seen a reason to actively employ C \(which to me seems like deliberately restricting myself to a subset of features\) rather than to employ C\+\+ and program as if I'm using C when that becomes more useful or even necessary.
You know you don't actually have to use every new feature in the standard library, right?
C++'s problems are predominantly self-made. Adopting a good response to criticism would help prevent making further mistakes.
Basically Windows API. Where there is `VOID`, `BOOL`, `CONST` and type aliases are through `#define`. They also macro certain function names into other functions names - and they are not uppercase!
Where is the value shown? 
Oh, I thought you meant {}. Well, they really need to reword this, because it's totally unclear!
&gt; You could in fact use .at() and get an exception thrown when you go off the rails. Some people do exactly that. &gt; Unfortunately, I've also seen that same code neglect to handle the thrown exception, at which point it bubbles all the way up and slays the program anyway by aborting it. So, yeah, you can do that if you're willing to pay for it, but you have to actually make sure you deal with the consequences! This is exactly what you want. Fast and obvious failure. Incidentally, reading this, it feels like the author isn't really a C++ programmer.
&gt; C++'s problems are predominantly self-made. Any examples?
/u/waray_waray I'm not familiar with the rules of benchmarkgame, but are you allowed to use compiler instrinsics? It's possible to greatly accelerate the runtime, esp if you can use AVX512F/VL/DQ/BW (and if they run it on a recent CPU)
What does it even mean to be “really a C++ programmer”?
gzipped size of source, afaik.
We've had the same need for our [build bots](https://stage.build2.org/?builds) so here are a few suggestions based on our experience: 1. You want as high core density as possible (cost permitting) since managing physical things is a pain. 2. Avoid desktop-grade hardware, it is not reliable enough for autonomous/continuous operation. You also most likely want to go for ECC RAM. 3. Currently RAM will probably be your biggest cost, especially if you go for a DDR4-based system. 4. AMD Threadripper looks interesting and we will probably get a test system to play with once the second generation is out. The big issue with AMD is reliability/software support and that Linux segfault fiasco did not instill any confidence. Generally, you want to write your code not debug hardware issues. 5. If you are looking for performance per dollar, it is hard to beat a dual Xeon E5-2670 (SR0KX)-based system from ebay. We recently bought a bunch and two CPU (so 16 cores), Supermicro motherboard, 64GB of ECC DDR3 RAM and a PSU (new) cost us the same (~$800) as just the Threadripper CPU alone! They have been running now for almost a year non-stop without any issues. 6. Use decent, MLC-based SSDs. We've chewed through about 50% of Samsung 850 Pro in about two years of building (which in our case involves snapshotting VMs, building, and then discarding them). The Intel Optane 900p looks quite interesting for this. 
&gt; I'm sorry, but the performance argument is BS: even relatively simple desktop applications benefit greatly from running smoothly. Yes, and many user applications run smoothly, despite not being written in C++. You've provided exactly one example, and it's a JS example to boot. Maybe it's just badly written? My terminal emulator is written in *python*, one of the slowest popular languages, and it runs quite nicely, and from what I saw the source code does not have any crazy hacks to make it fast enough. There will be exceptions to this, but they're just that: exceptions. Most GUI apps just aren't doing anything that intensive and you can easily have a good user experience without C++, and there's piles and piles of examples (on windows I don't think many desktop applications are written in C++, for example). &gt; Does C++ actually make it harder to develop desktop applications? Well, only if you think installing something like Qt or wxwidgets is hard. C++ makes it harder to develop almost everything. It's not just the package manager. It's just a complex language where you have to read lots and lots of best practices to write good code even after you know approximately how things work. I work at a very good place and I still find myself constantly saying things like: "hey, you don't need to use unique_ptr to defer initialization, you can use optional", or "hey, don't make your vector data member const, your moves will be slow". There's a reason why there's books and books and books full of common pitfalls. When someone I know is learning python and they come to me and say some behavior is really bizarre, without fail it is one of the same 2-3 things. Because to get to an intermediate level of python, there's really only the same handful of things that make people go wtf. In C++ I would need at least 50 entries to capture as large of a percentage of peoples' wtf moments as they learn. I honestly find your comment pretty shocking because nothing here should be controversial: not that you can get good GUI performance with GC'ed languages, and not that you should probably avoid C++ unless your domain requires a high level of performance/control.
I'm also not familiar with its rules, I guess it depends on the benchmark category, because SIMD intrinsics were used in [n-body](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/nbody.html) and [mandelbrot](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/mandelbrot.html) for both C and C++ programs, but then for other category the rules were more stricter like not accepting my [previous entry](https://alioth.debian.org/tracker/download.php/100815/413122/315946/7709/main.cpp) because it was forcefully inlining the "UpdateKey" function with metaprogramming. I think it's okay with SIMD intrinsics though
Hi. I'm by no means an expert, so take my post with a grain of salt, but I'll try to summarize my own impressions. 1. No matter what, make sure your build machines run on SSDs. It makes a huge difference, and a crappy HDD can slow down your massive CPU to a crawl. 2. I'd always prefer a beefy server running VMs to dedicated machines. It gives a lot more flexibility and encapsulation, it's easy to backup, and it's not hard to setup by any standards. 3. Cpp builds scale great with multiple cores and also with hyperthreading!!! Hence, I'd recommend a beefy CPU with many cores and threads. Possibly a ryzen is the best choice, although I haven't used one myself. 4. Fine tune your builds - i.e. you can run each build over 10-20 threads - useful when you run builds rarely and you want them done asap after triggering them. Or you can run them on a single thread - useful when you have a lot of people running a lot of builds at the same time, and you don't want one person to wait 2 hours for everyone else's builds in the queue to finish. 5. Consider the legal side of it - cross platform desktop probably means windows and macos. And most likely visual studio and xcode, and maybe some extra proprietary tools. You can minimize licensing costs, having 1 windows VM with 16 cores assigned, running multiple jobs, compared to 8 VMs with 2 cores each. Or depending on your application you can cross compile on linux VMs if you use gcc. As for MacOS, idk how things are but you might need an actual physical Mac - idk the legal status if hackintosh VMs. Cheers
I disagree. Rust may have come out of Mozilla, but if you look at the people involved as well as where the type system concepts itself came, Rust is deeply entrenched in PLT. Furthermore, they make no secret of it, and consider Haskell to be one of their prime inspirations., specifically its type system. Ownership is complicated? Not really. The concepts themselves are rather simple. The implementation is complex - offloading the manual burden of keeping track of everything to the programmer. How much it really scales is yet to be proven. I have done quite a few medium sized projects, and from my experience, set-up takes extremely careful planning (even more so than what one would normally do) if you plan to make major modifications later on, especially when it comes to designing your APIs (owned, borrowed, mutable borrowed, etc.). When some big company (aside from Mozilla) starts creating large codebases, then we'll really see how well it scales. I suspect that is one reason why the Rust team (last I heard) was actively contemplating (re)introducing an optional garbage collector. 
Agree with your comment apart from this bit: &gt; Poor programmers migrated in droves from C to C++ and created these awful edifices of object orientation. I suspect that while most of the initial code that might be considered badly written would no doubt have been from a C and/or C++ background, over the years, there have been plenty of people (both new to programming, or from other languages) that have managed to add on to this corpus of horrendously bloated code. In part, I blame the Gang of Four book being given far more importance than it really deserves. Generations of people without the experience of the authors have managed to shove down as many patterns from the book as they could (for whatever reason) so much so that it's almost a red signal to review the code carefully when you start seeing "standard" patterns being used by a new programmer. 
Just someone that uses C++ professionally on a daily basis.
Yeah, looking at it a bit more the rules seem a little flakey. Certain categories have rules akin to, "You must use the standard library, but if your stdlib doesn't have X, then you must use this library or nothing else", which doesn't seem quite fair. Not all standard libraries have the same implementations and forcing such arbitrary restrictions just give the end user the wrong impression of the performance of the language. It also seems they aren't keen on metaprogramming either, which is... unusual. If they allow intrinsics, my point still stands, you'd definitely be able to squeeze out a little bit more performance, but only if the compiler isn't already vectorizing everything. You should profile first, and then do the work. 
Does anybody still do C++ in Visual Studio?
Because Chandler used the wrong sized unsigned type in that example. The optimization he wants to trigger in that case is widening the int to the machine register size; but using the correct integer type to index an array, `size_t`, requires no widening.
The code worked fine as-is; if it didn't, then your compiler does not yet support base-class initialization of aggregates.
If metaprogramming would be allowed you could precompute the results with constexpr at compile time and the runtime would basically 0;
The code above also uses an unsigned (int) as counters in the for loops. So it should suffer from the same problem. Or am I missing something?
Ohhhh you initialize it using aggregate initialization, I was calling it like a function. Cheers! 
I'm using a couple of semi-beefy OEM xeon servers and a mac mini server, all running ESXi and being managed by vSphere. The mac runs a couple of virtual macOS instances and the other two handle Windows and a variety of Linux instances. More cores beats clock frequency. RAM is very, very important. Local SSD beats network storage. And a smart build tool and maybe some caching has more ROI than most of that for CI builds. I'm using jenkins to spin VMs up and down via the vSphere API as needed - I can get better throughput by serializing somewhat and building on fewer VMs with more threads at a time. Throwing more RAM at the system would mitigate that, but I think it'd still be useful to do in some cases. Single developer, distributed application with a bunch of C++/Qt apps being built out on several versions of macOS and Windows and an assortment of Linux distros and versions, along with a little Solaris and BSD occasionally. The E5-2670s berium mentions are probably what's going to replace my existing servers later in the year. Running in "the cloud" is tempting, but it can be fairly pricey to get enough performance to meet your needs for CI, probably requires quite a lot of in-house knowledge on automated provisioning tools and needs sysadmins who understand the cloud platform you're using. Getting some experience in provisioning is likely a good investment, cloud or not.
I believe you can pass a custom allocator to vector whose implementation would do nothing (to avoid initializing new elements).
[I answered a similar question a month ago, and it might be helpful to you](https://www.reddit.com/r/cpp/comments/83u202/how_do_you_manage_your_ci_environment/dvl6c1h/).
Can you list the static analysis tools that you use?
Well, I didn't mention that in the original post since I stick to only free tools, so my list is not that vast: just cppcheck and [scan-build](https://clang-analyzer.llvm.org/scan-build.html). Btw, from those two only cppcheck finds out that there's a null pointer dereference in my snippet.
Then BOOO to that code :/
It is a decent IDE, why wouldn't there be people using it? You don't need to use the included compiler if you don't want to..
You need to run your program under valgrind and/or LLVM sanitizers to be sure it does not have bugs, this is true even for the most experienced developers. The reality is that the language is and will be unsafe, but the modern tooling (both static and runtime checkers) helps you catch most of the issues.
I probably wouldn't do that unless I also had a tool to enforce its usage everywhere (excluding library code, I guess). It would be easy to forget it somewhere.
It's interesting that Rust is loosing to C++ on almost all benchmarks besides one (11/12). Probably this has something to do with also using modern G++ versions.
Eclipse (and Qt?) have ability to syntax highlight non-const reference parameters in a different color. I use it.
Well, unfortunately even a combination of static analysis + sanitizers do not guarantee you bugs-free code (even in terms of memory/thread safety, I'm not talking about the business logic), so I would rather not say "does not have bugs". I'd rather say it's just about lowering the probability of having lots of bugs :) But yes, the thing is that one HAS to use that tools, it's not just like a suggestion or some kind of a being "a good boy", it is a necessity that one just can't ignore. Otherwise even a simple program might ruin your ~~life~~ day.
I agree with your point, just saying that things are unlikely to change in most places for now.
At slide 34 he mentions _hb-subset performance_. harfbuzz has [hb-subset.cc](https://github.com/harfbuzz/harfbuzz/blob/master/src/hb-subset.cc) in the github repository. I assume it will be part of harfbuzz.
For this particular case, is there a way to change the standard so it would stop compiling without breaking too much bug-free code? You can't really ban conversion from `0` to `nullptr` since that's used a lot (even if it shouldn't), and `nullptr` to `const char*`is potentially useful I guess.
Electricity consumption is another thing to keep in mind. It's pretty easy to set up a bunch of machines and forget you're blowing $4K on electricity a year. A single big beefy machine is usually way better on this front. 99 times out of a hundred an organization or department won't be smart enough to account for energy efficiency. But if you've got smarter bean counters in your organization it's something to keep in mind.
Too many Tide pods? :-D
If you're interested, this is the discussion on /r/rust. https://www.reddit.com/r/rust/comments/8c19q9/c_is_now_the_fastest_knucleotide_implementation/ I for one think it's awesome that C++ was able to push further. I'm often jealous of int generics and constexpr.
Adding an `explicit` keyword to the constructor I've mentioned will solve the issue... but it will break a very convenient way of using a C-style string as an `std::string`, like std::string s("c-style string"); But I would rather ban this `0` to `nullptr` conversion. Yes, it will break a lot of old code, but actually I can't think of any change in the standard to solve the issue that won't break a lot of old code.
Thanks for the hint! Will add it to all my c++ projects. I wonder why isn't it included with the `-Wall -Wextra` flags though..
No idea. I found that collecting a list of all useful warning flags and just including them everywhere (potentially with `-Werror`) does solve a lot of weakness in the standard.
&gt; I wonder why isn't it included with the -Wall -Wextra flags though.. because the compiler writter get yelled at if they add flags to -Wall -Wextra because it may break existing builds. The only really useful flag if you want to ensure maximal safety is clang's -Weverything.
I thought about that, but converting C-style strings automatically is something reasonable to do and it would break too much code. I guess it's possible to require a warning in C++20 for the `nullptr` conversions, and ban them in C+23.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8byb2r/stdcall_once_with_exception/dxbsd4g/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I was speaking less about whether a throw or an assert is more correct (the OP makes no such comment about this), and speaking more to the fact that the author seems to think that the abort/termination itself is bad.
So dynamic checking only? Hm, better than nothing, but probably not enough.
&gt; -Weverything This one is really nice, I hope some day they will introduce it to gcc as well.
I just add all the flags to my debug make that are possible to use on each system I have. Don't need to know what they are, just need to know how to look them up once. It isn't a "shame for the language." There are solutions the language provides to all of these problems. 
-Wall -Wextra -Wextraextra -Weverything -Wseriouslyeverything No not you -Weffc++
I have implemented a C++17 constexpr library that enables using Python syntax for packing and unpacking of structs. The goal was to allow sharing the same struct format between Python and C++ programs. It was a fun constexpr challange. Would love to hear your opinions!
Why change the standard when a change in the string library is enough? #include &lt;string&gt; #include &lt;iostream&gt; class MyString { public: MyString(const int size) : m_string(size &amp; -(size &gt; 0), 0) { } MyString(const char * const pString) : m_string(pString) { } const char * c_str() const { return m_string.c_str(); } private: const std::string m_string; }; void test(const MyString&amp; s) { std::cout &lt;&lt; s.c_str() &lt;&lt; std::endl; } int main() { test(0); }
Well, generally speaking there are *some* solutions that address *some* problems. My use case, for instance, can't be just evaded easily, while I would agree that I did a wrong thing at the first place relying on the compiler to assist my refactoring. And IMO maintaining the list of that flags for all the projects doesn't sound like a real solution. One thing is to keep a tuned CI process for all the projects, while "a need to know how to look the things up" is something completely different, not to mention it doesn't scale up well. But that's just my opinion.
&gt; A single beefy server that runs all the build agents in VMs? What platforms are you building for? If iOS or OS-X is in the mix, this shifts your options for that sort of approach. &gt; A bunch of decent desktop boxes each dedicated to building only for a particular target platform? Seems like a plan that maximises management overhead and fiddling. &gt; Dedicate the bulk of the budget to the CPU? More memory? Faster memory? Faster storage? My general rule of thumb is that people underestimate the importance of storage. &gt; If VMs, do multiple builds run in parallel or do you try to serialize them? Do the VMs share hardware resources or do you allocate each some set cores/memory/storage? In general, you want things to happen in parallel, up to the limit of actively using so much RAM that the host is swapping and thrashing. &gt; I recognize this question is only somewhat related to C++, but C++ builds are such complicated and expensive beasts compared to so many other languages. They are CPU, memory and filesystem intensive, which means they can easily be bottlenecked in several different ways. You should probably measure your bottlenecks. You are aware that things can be bottlenecked is several different ways, but us randos on the Internet can't be sure about what issues you are running into. You are the only one who has built your app. Profile the build. Measure things. Fix the slowest parts. &gt; I realise that some of you work for large organisations that have dozens of staff dedicated to manage massive build farms. Heh, that sounds nice. If it's actually mostly just me, do I get dozens of salaries? &gt; So, what would be your general advice for a small team (without the time or expertise to design, build and profile a bunch of build server configurations) that just want quicker nightly and CI builds? AWS. You can spin up big fast instances with a bunch of CPU's and memory, and have them working in parallel on different builds in The Cloud, for probably not more than what it would cost you to buy a server that has the same capacity, back it up, cool it in a datacenter, keep spare parts on hand, etc.
In `operator std::string()`, don't return with `std::move`, as it prevents (N)RVO. Instead, just return `tmp` (oh and BTW `reserve()` the size before): operator std::string() const { std::string tmp; Data data = _data; tmp.reserve(size); for(int i = 0; i != size; ++i, data &gt;&gt;= 2) tmp += cfg.to_char[data &amp; 3ull]; std::reverse(tmp.begin(), tmp.end()); return tmp; } 
Actually, you could also fill the string backwards directly instead.
Mostly agree. I know that the MS Standard Library implementation has asserts for this kind of thing. It seems reasonable that any other reputable implementation does too. But they are usually compiled out in a release build, which likely means that the real problem is either a lack of unit tests or that the unit tests are built without asserts enabled. To me, that's more of a problem than a developer making a mistake. As mentioned in other comments, I too have a philosophical problem with trying to catch programmer errors with exceptions, which is what using .at() instead of operator[] gives you.
Here’s an example. Suppose i initialize an array of gpu devices available using some OS call or another. My program needs at least one card to do anything reasonable. So maybe in this case i can call at(0). Assuming i have a policy where exceptions are essentially irrecoverable and handled separately from other error conditions. Contrived maybe but I could see it. 
The excerpt I quoted implied that one should catch whatever `at` throws immediately, which I contend is about as stupid as stupid gets. I don't see how irrecoverable exceptions are related at all, or why `at(0)` would somehow be better than `throw something_sensible{};` in any case.
Don't know how if it would alleviate the problem in the case of the fn function in the example but the longer I go on, the less I think default arguments are a good idea. I'm sure there are places where you can't live without them but I see them used in places, usually when retrofitted to an existing API, where it just makes it harder for the compiler to reject bad (or unintended) code.
Haha yeah, that snippet is a doozy.
It's not complaining about ambiguous constructor here? Since it can implicitly convert to either.
It would be reasonable to implement from a clang plugin, but there's a pretty sharp learning curve for getting started with that API. I have something similar that generates javascript bindings by looking at my C++ classes for data members and functions, but it's 6k lines of code to deal with all sorts of situations... like templates.
Yes, it will not compile with 0. 
In this case the deduction guide is not necessary, the compiler can deduce the types through the [constructor](https://godbolt.org/g/xLbMZg).
I think their point was that the MS/Dinkumware stdlib has debug checks in e.g. `operator[]`, which is the proper approach for logic errors (not exceptions). (libstd++ likewise has `_GLIBCXX_DEBUG` and libc++ `_LIBCPP_DEBUG`.)
Yes, Zach Laine will be talking about string theory http://sched.co/EC6z
Reading that, I at first wondered what kind of prior experience one would have had to assume accessing something that didn't exist wasn't a conceptual error. Then I realized. Javascript.
A sorted vector (with reserved size too) might be faster than std::map in WriteFrequencies. 
Metaprogramming is allowed, the submitted post here uses it. But the data is provided at runtime.
I think it does, I will try comparing this with std::map, thanks. 
The maintainer of benchmarksgame doesn't allow compile time function execution. But I'd apply this if maintainer allows it. 
The operator is only called exactly 20 times in this benchmark so I think it won't have huge improvement. But it is cleaner, So I will use that. Thanks.
Considering constexpr is a major language feature of C++....
-Wwhen-i-say-all-i-mean-all
Yeah, still there, along with Dilbert :)
This is the default, 16 color compatible colorcheme, we do have much nicer looking ones (look at the gallery on Kakoune.org), and clang autocomplete is supported both though direct calls to clang binary (the bundled clang.kak files provide that) through cquery with the https://github.com/cquery-project/kakoune-cquery plugin, or with general language server protocol support (various in progress projects try to implement that). We also have a Qml based UI at https://github.com/doppioandante/kakoune-qml but that work has not been progressing much lately.
Depending on how much you want to optimize you can take a look at calling ` std::ios::sync_with_stdio(false);` from main http://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio 
Yes I was also sad when [my previous entry](https://alioth.debian.org/tracker/download.php/100815/413122/315946/7709/main.cpp) was rejected because it forcefully inlines the "UpdateEntry" using template metaprogramming, It was faster by ~300ms. For constexpr, I think it's alright to use it to calculate some simple expressions for constants, but not constexpr functions. 
Then we can safely declare the benchmark game to have invalid results. 80% of my day job working with C++ is template metaprogramming and constexpr. Not using those language features results in bad code.
Doesn't have to be always.
another thing you can do is disallow implicit casts
unpopular opinion on this sub, but not having a bunch of legacy cruft is a big advantage of something like [Rust](https://www.rust-lang.org/). C++ has been used for great things, of course.
As for hardware, try out your build on some cloud providers and see which of their configurations work best for you. 
I didn't believe you, so I tried it for myself. Sure enough, I did not get a segfault. I got terminate called after throwing an instance of 'std::logic_error' what(): basic_string::_M_construct null not valid Aborted (core dumped) Which seems pretty explicit about why it's failing. I'm not really sure what I'm trying to say here, other than that I don't understand the sentiment of &gt; I'm very frustrated and actually my current intention is to move the development to a more, like, safe language (Rust, for instance). I get how 0 being implicitly cast to nullptr isn't great (although as /u/CptCap mentioned, there's a warning that will save you there), but this really doesn't seem like a problem to me. You did something dumb (and the way you got to "something dumb" is very understandable, code changes and it's easy to end up with "something dumb" without explicitly writing it that way), and it told you exactly what was "dumb" about the code (and where you did it, assuming you opened the core dump). It would be better if it told you that at compile time, as is possible in this case, but it *will* tell you that at compile time as long as you have the right warnings on (and fail to compile, if you're using -Werror). Maybe the take-away here is to make sure you aren't just relying on -Wall/-Wextra, and to always use "-Werror", and all that I would agree with, but removing a parameter of a function, **especially** a function that had default arguments, and expecting everything to just work is kind of insane to me. Maybe I'm just too far gone into C++land and can't see my own craziness, though.
&gt;Another perk of using "the cloud" is how readily and cheaply […] Reluably means one of the major cloud providers (Google, Amazon, etc). And those are by no means cheap. For example I can get an 8 core Xeon-E3 box on Hetzner (generally agreed to be much cheaper that any major cloud providers) for one year for about the same cost as buying a 16 core dual Xeon-E5 machine I mentioned in another reply. This of course does not take into account electricity cost nor admin cost (nor things like Mac OS support) so it might still be more cost-effective to go the cloud route for a small shop.
It isn't a `nullptr` conversion as it is a `0` which is implicitly converted to `const char*`, making actual `nullptr` do something special when passed into `std::string` could be interesting but that wouldn't solve this program. The chance of having anything but a static analysis tool catch int to pointer conversions outside of special warnings is low though, since C code typically heavily relys on it and tons of C code is used in C++ projects.
Maybe its because my brain is more wired towards hacking than development, but this just seems obvious to me.
Why not make &gt; static inline unsigned char to_num[128]; as a constexpr array? What is using the inline keyword there doing? I was under the impression inline variables were about ODR issues, and not re-arranging code?
In your auto CalculateInThreads(const Cfg::Data&amp; input) function, surely the main thread could do a bit of work itself before calling thread.join() ? Without thinking too strenuously about it, it seems to me that we wouldn't even bother with spawning threads if the amount of work was small, so the main thread will wait on the spawned threads for quite a while (relatively speaking).
 auto&amp;&amp; frequencies = CalculateInThreads&lt;size&gt;(input); std::map&lt;unsigned, std::string, std::greater&lt;unsigned&gt;&gt; freq; for(const auto&amp; i: frequencies) freq.insert({i.second, i.first}); You're binding the lifetime of the temporary as an rvalue-reference, but then never "moving" from the temporary or it's pieces. Perhaps not that relevant from a performance standpoint, but you could instead use const&amp; to better indicate your intent.
Lastely, why use __gnu_pbds::cc_hash_table ? Is std::unordered_map not sufficient?
Could you provide more information on specifically what they said about your previous entry? That UpdateKey function looks essentially indistinguishable from hundreds of functions I've written. It's hard to get more idomatic c++17 than that...
How did you decide on 4 threads? Could that information be looked up at program start?
Beast from boost and nlohmann::json
I used beast before. I think that for my purpose it is too low-level. But I might be wrong, I will review it again :)
https://github.com/h2o/h2o It's based on libuv and quite good. If it were me, I would just start from the ASIO standalone library (there's an example HTTP server there). But I prefer low level :P.
Based on personal experience (day work) we have used cpprestsdk for our REST server. The same issue has been analyzed in a similar [subreddit](https://www.reddit.com/r/cpp/comments/7ghn75/defactoindustry_standard_restful_serverlibraryapi/dqjt2bh/). 
It's needlessly eclectic. Yes, there are good historical reasons for that and no, if I start programming in 21st century, I don't want to think about integer promotion, implicit constructors, and one definition rule. Nobody does. Here's a fine example. I have a decade of professional experience with C++ and yet I managed to brake a CI build just a couple months ago merely by optimizing the code. It turns out, while __declspec(dllexport) does ensure that the inlined functions will be available from the DLL, it doesn't ensure anything for the static build. Also in C++, unlike in C, inline keyword doesn't actually mean inline, it only means that the compiler doesn't have to keep this function anymore if it doesn't want it. So when I made a function lighter, it started to actually get inlined, and compiler didn't have to keep it as a function anymore. Which was fine on my machine, since I don't build all the possible configurations, I only do DLL, but blew up on the CI. it's a little bit crazy that in order to optimize things mathematically, I have to know how the linker works, what exactly Microsoft language extensions do, and that inline keyword is not actually about inlining, since the compiler does that anyway whenever it wants, but more of "by signing this I resent my rights to have my function properly placed into the translation module". You need to be somewhat of a lawyer to be good in C++ and people hate lawyers. Guess, this translates to the language.
boost.beast should be fine enough, if you are familiar with asio's async model. But for simplicity, you may try [served](https://github.com/datasift/served).
You can take a look on [RESTinio](https://bitbucket.org/sobjectizerteam/restinio-0.4) for HTTP-stuff (like GET/POST) and [json_dto](https://bitbucket.org/sobjectizerteam/json_dto-0.2) for JSON (json_dto is based on wonderful RapidJSON).
There is one: I have some C++ code that I want to expose as a web service. I will save doing bindings to call this API and complicating things. Getting a server and calling this C++ API is the fastest thing to do since it is quite a simple service.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8c6awa/advice_on_fastest_way_to_write_c_server_that/dxcip3l/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
&gt; I agree optimizers should give you finer control so you can still see variables if you want. It will obviously limit performance in some cases, but it's quite helpful for debugging. That is not what I was talking about. There are DWARF debugging instructions to explain things like *"variable `i` was optimized out, but its value can be obtained by `rdi + eax * 4`"*. The code itself is exactly identical; this is "simply" a mapping from assembly to a formula giving the value the variable would have had. Of course, tracking this formula across code transformations is likely quite complicated; and obviously not working that well at the moment. See GCC's [Var Tracking Assignments](https://gcc.gnu.org/wiki/Var_Tracking_Assignments). In the [debugging options](https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html) it is enabled by `-fvar-tracking` and `-fvar-tracking-assignments` which should be on by default when compiling with `-g` (unless you start specifying debugging formats, etc...).
Just click on the benchmark results. You will find a line like that &gt; 10.22s to complete and log all make actions 
Do you use C++17? cppcheck choked when we started using C++17 goodies :/
I think this is the same as [C++ G++](https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/knucleotide-gpp-1.html) which is slow and a memory hog. [Actually the largest in memory usage.](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/knucleotide.html)
You're right, I was only used to passing non-primitive type as references, and value types for primitive types. 
thanks, this is useful. I never knew about this. 
boost is a fat ass dependency I dont think that would be ideal
benchmarksgame has been using a test machine with Q6600 quad core CPU for all its benchmark. https://benchmarksgame-team.pages.debian.net/benchmarksgame/how-programs-are-measured.html
Great code, but you should almost never `return std::move(x);`. Forcing a move prevents copy elision.
Interesting side effect.
Nope, in my company we are stuck with c++11 (and 14 in some rare cases), and I personally decided to migrate to other languages for my own projects instead of waiting in vain until they fix everything in some c++20.
It makes more sense now, though I wonder if it would still work when code deemed useless/ "constexpr'd away" by the compiler was removed. Do you need some additional flag for that?
&gt; Do you need some additional flag for that? I don't know if any other flag exist which would increase the precision of the debug information; unfortunately :/
Yeah, I didn't check whether that function was call often or not -- but returning with `std::move` is a well-known anti-pattern.
Maybe my suggestion is a bit off-topic: I would suggest you also review if your project is built efficiently. Some legacy project may still use plain-old manual writing Makefile which is poorly organized. I've seen some old project improved the the building time from 20 min to 2 min by just replacing the Makefile with decent building tools (CMake+Ninja for example). Try to monitor the CPU usage during build progress. *All* cores should be 100% used during building. 
I will try to implement all of your suggestion. Thanks 
I'm interested to know which languages you've migrated to? 
I know this is late, but to your question why I would use an optional&lt;int&gt; - because it documents that I have there might be no value. Ex. I work on a cross-platform DPI detection tool and some platforms can't tell me the DPI of the monitor. So I could either set it to 0 and write in the documentation "0 means unknown DPI" or I could use an optional value so that the library user immediately sees: aha, I need to handle the special case where the DPI is not available. 
Yes. The OP's problem was that for backwards compatibility reasons 0 is still convertible to a null pointer, which screwed him in this case where an integer 0 was intended to be passed as a parameter.
What is your list of "extra" flags, ooi? I usually just use `-Wall -Wextra -pedantic`
One thing that’s really interesting is that we moved from LLVM 4 to LLVM 6 quite recently; I wonder if codegen has changed, and nobody has looked at it yet. Also, there’s a longstanding lack of explicit SIMD which really hurts Rust on several of these. That’s being stabilized right now though. That said, this one seems to be thanks to constexpr, which will still be a long time out. Well done to the the author!
constexpr is idiomatic. Templates are idiomatic. It's not our fault if the other languages are poorer in their variety of achievable idioms.
Don't forget air conditioning &amp; its expenses. Where there's electricity consumption, there's heat. Even a half-rack can make a modest office toasty warm.
I wrote a Quora.com answer for this specific question: http://qr.ae/TU1JF3 Thought you might like this :-)
I decided to go for Rust: it has some strong guarantees regarding memory safety and data-race freedom, explicit-style type conversions, algebraic data types, feature-rich standard library, lots of zero-cost features, and so forth. Ah, and also Rust forces you to handle possible runtime errors properly :) So after coding mostly in c++ for so many years it was like a fresh breath of air :) It took me some time though to get used to some strict rules of the language (actually a couple of months), but as for now I'm very happy with it. It's not a silver bullet (obviously), but it definitely serves my needs :) I also looked in direction of golang, and generally I would recommend at least having a look at it, but it just didn't suit me.
Unrelated, but would static analysis be considered a lightweight formal method?
I've been bitten by this before, and now when I want to remove a parameter, I first replace it with a new dummy type, then compile and find and fixed all call sites. After that you can remove the dummy parameter and it should build fine. 
I'll bet `-Werror` is the reason compiler devs don't add new warning flags to `-Wall` and friends more often. Code that compiles cleanly and without warnings in $CC vX.0 now breaks "for no reason" if the team upgrades their compiler to $CC vX.1. Yes, yes, teams shouldn't use `-Werror` if they're going to be upgrading compilers, but that sometimes is an institutional question ("{my manager / our build team / $THAT_GUY} makes us use `-Werror`!"). And now would could have been a 2-step compiler upgrade (1. upgrade compiler, 2. fix warnings) ends up as an unexpectedly painful slog because with `-Werror` you *have* to solve both at once before your build works again.
`-Wsign-promo -Woverloaded-virtual -Wcast-qual -Wcast-align -Wold-style-cast -Wnon-virtual-dtor -Wodr -Wzero-as-null-pointer-constant` This one is quite old, some of these might be obsolete.
I essentially refuse to use projects from source forge. They ruined it, and they aren't getting it back. Also... The site just sucks in comparison to GitHub.
Which of course is silly to begin with. You have -Werror enabled when developing and on your CI infrastructure, but when you ship a source distribution you skip -Werror. And when upgrading compilers you can simply downgrade specific warnings if necessary.
What's the harm in making it constexpr and manually typing out the 0s in your braced init? You're potentially preventing constant value propagation, and also potentially preventing having the entire to_num array being stored in the read-only data section of your binary.
Does your framework have any dependencies ?
There are just two dependencies for SO-5 itself: our small library timertt and [optional-lite](https://github.com/martinmoene/optional-lite). The copy of optional-lite are incorporated into SObjectizer's source tree. Sources of timertt are included into SObjectizer's archive on SourceForge (sources are incorporated into SO-5 sources on github).
Sorry, but there are too many complaints about different things like hosting, version control system or code style. Those are just tools and we use those tools which are useful for us.
question related to llvm: why does rust even come with its own version of llvm instead of doing what clang does?
We fix bugs, and we want them to be fixed before upstream fixes them. We try to upstream patches in a timely manner, but we’d still have to wait for it to hit a release.
I hate Borland with a passion. I started using Brief editor on my first day of employment, on OS/2 and DOS. A few years later Borland bought and killed Brief. After a grieving period, I found and bought CodeWright 
&gt; The purpose of the benchmark game is comparing the performance, amount of lines of code, and binary size of idiomatic code for different languages. If they only want code that's implemented as close to identically as possible in each language, then what they're doing is comparing *compilers*. If they're comparing languages, then to say that template meta-programming is off limits, is effectively the same as saying C++ wins by default, because other languages can't compete with 2 of the largest, more commonly used, most powerful, aspects of the language. I'm glad they're so amenable to admitting defeat so easily. /s And even so, the OPs submission out performs other languages even without the use of template metaprogramming / constexpr functions.
Templates and constexpr are orthogonal. They happen to be able to accomplish many of the same things, and they work wonderfully together, but they have distinct purposes, uses, and abilities. &gt; Also one can do much better than C++ in this case performance-wise in pretty much every single programming language if everything becomes allowed. Could you elaborate? I'm having trouble parsing your statement.
Borland/Embarcadero later bought CodeWright, too. ;-D
Actually, it would probably be good to do &gt; auto&amp;&amp; frequencies = CalculateInThreads&lt;size&gt;(input); &gt; std::map&lt;unsigned, std::string, std::greater&lt;unsigned&gt;&gt; freq; &gt; for(const auto&amp; i: frequencies) &gt; freq.insert({i.second, std::move(i.first)}); to avoid the allocation and copy of of the string.
&gt; timertt So if I compile the source code from github do I get these dependencies separately or do they come with it ?
how small?
I remember asking my mom to buy me one of those "Learn C Programming" books at Comp Usa in the mid/late 90s because kid me thought it looked cool. It used Borland.....I think I made it to about the 2nd chapter before I had to give up due to the amount of compiler errors and tricks 8 year old me could never figure out. 
Sourceforge was bought by someone else who's trying to turn it around. The malware downloads are a thing of the past.
I just treat `.at()` as a more concise version of "assert and then index." On a related note, my release builds have asserts enabled.
Then use `boost/std::optional` to delay initialization.
There's a kind of "interesting" solution to that problem that is conceptually clean but practically a little annoying: Make your move constructor `T(boost::optional&lt;T&gt; &amp;&amp;)` rather than `T(T &amp;&amp;)`. In other words, since you're going to be moving out of something, have an optional wrapper provide that "moved out of state" rather than forcing your class to. In practice, this is somewhat annoying because T still needs a "moved out of" state to ensure that its destructor does the correct thing; it's just never visible to the user, because the `optional` is empty by the time the move constructor returns. Also annoying: you have to use `optional` in places that you're moving out of.
&gt;While it’s technically possible to run Windows 95 on a modern x86-64 machine thanks to the architecture’s extreme backwards compatibility, it’s more compatible, simpler, and safer to virtualize it. Meh. Boring. 
If they do, people will expect it to behave similarly between the compilers, and then they'll get shy about adding to it because somebody depends on the behavior... And then somebody will make -Wabsolutely-everything and the cycle will repeat.
Any chance this has fixes for ICL's compilation issues on not-MSVC?
I've recently added [serialization support for boost::base_collection](https://github.com/Ebenezer-group/onwards/tree/master/poly) to the C++ Middleware Writer (CMW). To the best of my knowledge, the CMW is the only serialization lib to offer support for this interesting container. Thanks to the author, u/joaquintides, for helping me get this working.
Note that the patch have been ready for several months. I'm not sure why it have not been merged in a release yet but it have been planned for soon. (I helped with the patch and it's easy to just copy paste the FindBoost.cmake file from thatpatch in your version)
.count works well for sets because there are only ever 0 or 1 items. if( numbers.count(5) ) { ... } 
The link to Windows Binaries is broken (404). &gt; Visual C++: [...] 14.1 What version specifically was this boost release tested to work? With the many updates MS is doing, it is no longer sufficient to just say "14.1". At the minimum, what about `cl.exe` versions 19.12, 19.13 and 19.14?
He sounds like he has never actually used windows 98. Yes, the command prompt was that shitty. Compared to what we had in linux in 1998, windows was a complete joke. Even the windows NT command prompt was a joke, and that one was light years ahead of the windows 95/98 one. The editor itself of Borland C++was fine for its time. Definitely and totally better than vim. But, to each his own i guess.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8cbtc5/complex_while_loop_conditions_syntax_help/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
At least we got a Weird Al song from it.
Wouldn't this also work? MyString(nullptr_t) = delete; 
You need to build boost. The headers are generated for your compiler and platform. Some of the libraries also require binaries.
It was just about the pentiums.
Not all boost libraries are header only. Installing boost consists off building the shared/static libraries (or having your package manager download prebuilt libraries)
You're right. I just looked at rust again and saw this: fn encode(c: u8) -&gt; u8 { (c &amp; 0b110) &gt;&gt; 1 } Which if I understand correctly, this is the same algorithm in that paper? So this is why rust was the fastest before. And C and C++ implementations all use lookup tables.
Different song. http://www.metrolyrics.com/windows-95-sucks-lyrics-weird-al-yankovic.html
[Every OS Sucks](https://youtu.be/YRlPTbKHIPQ)
From github you will get SObjectizer-5.5 with all dependencies. When you download so-5.5.22.zip (or .tar.gz{bz2,xz}) you also get SObjectizer-5.5 with all dependencies.
AFAIK, SourceForge doesn't do that last years. And many useful projects use SF for distribution (MinGW-w64 for example). But another thing is the most important: we develop SObjectizer on our own, it means that we pay all bills. We invest many resources in development, testing, documenting and so on. And we distribute SObjectizer for free. I think we have right to choose those tools which we like and want to use. Even if all other think there is no any better than Git and GitHub. If someone doesn't like SourceForge he/she can use GitHub-mirror, or can make its own fork, or can choose any other similar framework, or can start its own project and spend its time, money and resources and host its project on any hosting. There is a plenty of choices. But please don't bring that argument on discussion about SObjectizer. Releasing SObjectizer to the public we want to discuss SObjectizer's features. But not mistakes done by some commercial firms in the past.
Wherever you want \- I put them in Program Files\\boost\_1\_xx\_x and then add C:\\Program Files\\boost\_1\_xx\_x\\boost to the includes path. If you're using Visual Studio, right\-click on your project, go to C/C\+\+, then the General page, and you want your chosen path in the Additional Includes setting. Also, if you're on Windows you won't be getting out any .a files. If you need the binary libraries, use boost's built\-in tools \(relatively well documented in the Getting Started in their documentation\), and it will give you a range of .lib and .dll files in \\stage. You'll want to add the \*full path\* to any .lib you want to use \(whether it's an actual static library or the stub for a DLL\) to the project properties Linker \-\&gt; Input \-\&gt; Additional Dependencies, and the path to \[boost dir\]\\stage to Linker \-\&gt; General \-\&gt; Additional Library Directories. Can't really help you with Clang\+\+ on Windows, but the principle is the same \- you tell the compiler where the headers are as an additional include directory \(something like \-I "C:\\Program Files\\boost\_1\_xx\_x\\boost" on the command line I'd imagine\) and then the linker what libraries you want \(something like \-L "C:\\Program Files\\boost\_1\_xx\_x\\stage" \-lboost\_filesystem\).
Have you filed a bug report or searched for an existing one?
I'm using the build tools from the commandline. Can I still use that? And if so how? Or rather could you just point me to where I can find the manual or docs for it online? Google always takes me to outdated docs on the microsoft website. Also is MSVC++ generally the preferred compiler on Windows compared to clang++ and g++?
const char * has no guarantee to be zero terminated either. 
When dealing with strings, if your `const char*` isn't null terminated, you will have the size of the string around somewhere (i.e. a string-view). APIs using `const char*` without taking a size will assume the string is null-terminated. Suppose someone called `remove_suffix()` on the `std::string_view`; then reading the `const char*` would act as if the call had never happened.
&gt; all string_view objects directly generated by string literals would be null terminated And all `std::string_view`s generated not from a literal will now be easy to use unsafely and incorrectly, as they'd decay into a `const char*`. &gt; I think most people that use C++ would just long by now have replaced const char * with std::string Legacy code. Calling into C libraries. Also, there is plenty of non-legacy code that assumes string literals are arrays of chars, that would be broken by this change. I don't have the time to go into all the details, but an implicit conversion from a type A to a type B doesn't mean you can substitute A for B everywhere. For example, only 1 implicit conversion will happen, not 2, so if just `const char* -&gt; MyType`, `std::string_view -&gt; const char* -&gt; MyType` isn't allowed. I guarantee there is code relying on string literals being `const char*` that will break if they suddenly change to be `std::string_view` &gt; it's just the language level string literals being pointers seems a bit "leaky" to me I have to agree with you here. Most of my grievances with C++ are due to its legacy and compatibility with C. But the thing is, one of the reasons why C++ is so good is its backwards compatibility and not having to worry about old legacy code breaking (beyond trivial fixes).
If I understand correctly, all libs built with 14.1 toolset are ABI compatible with VS2015 and VS2017 compilers output, so you should be able to link without knowing the exact compiler.
For linking you also need the headers. And they need to compile. Compile errors in the headers in newer MSVC versions caused quite a bit of pain in the past and boost is usually quite slow at testing/fixing these.
Most libs don't need to be built, and some (boost.system for instance) have macros that allow them yo be used header-only
This looks cool, but I can't help but wonder why Direct3D/OpenGL/Metal were chosen rather than Vulkan. Even Mac has support for it through MoltenVk(now free) now. Surely it would be simpler and more portable to only have to support Vulkan, at least at the start, and possibly more efficient due to the control Vulkan offers. And I would expect, but don't quote me on this, that it's more likely for an embedded device to get Vulkan support than for any of the others. When i think embedded I sure don't think Direct3D, thats for sure. Is there anything obvious i'm missing, arbitrary choice, etc?
FYI: string literals are not `const char *`, but `const char[n]`
I was really happy about this until I realized it's closed-source. No thanks.
&gt; Templates have well defined uses, for which they would be considered idiomatic. And this uses are allowed. But not all uses of templates are allowed, for example, a program that uses templates to perform compile-time computations that could be done with constexpr won't probably be allowed because it is not an idiomatic use of templates. 
If you say Pure-GPU Renderer, does that mean that you parse HTML on the GPU? All the layout calculations are done one the GPU? Although in theory this is parallizable in practice it feels odd ...
&gt; You did. No, I didn't. That sentence you quoted cannot be interpreted the way you strawmanned it.
You said that templates are idiomatic, period. I said that they are not idiomatic for all cases. You exploded for some reason, that's fine, it happens.
Agreed with points 1 and 2 but point 3 doesn't make sense. Plenty of engines/studios have Vulkan support.
&gt; You said that templates are idiomatic, period. Yes, the are. Because they're not a hack. The keyword "template" is standardized. Partial specializations are standardized. `std::make_index_sequence` is in the standard library. That still does not make the sentence mean "every conceivable use" is idiomatic. Templates, the feature, is not the same thing as the esoteric usages people discover. &gt; which is why not all usages of templates are allowed in the game. The one that got rejected used fold expressions for variadic templates. That is idiomatic. It wouldn't even count as metaprogramming. You're literally defending the rejection of idiomatic templates, because, what else would you use fold expressions in variadic templates for? &gt; You exploded for some reason You have a strange definition of "exploded". Maybe it makes you feel like you win an argument by imagining the other person is emotional.
&gt; That still does not make the sentence mean "every conceivable use" is idiomatic. Templates, the feature, is not the same thing as the esoteric usages people discover. That's the only thing I pointed out, nothing more, nothing less. &gt; The one that got rejected used fold expressions for variadic templates. That is idiomatic. I never said otherwise. &gt; You have a strange definition of "exploded". Read your posts, to me it looks that you are only arguing with yourself because you cannot admit that you weren't sure what I was meaning and instead of asking for clarification you just assumed the worst.
&gt; I never said otherwise. Then why are you defending the rejection of idiomatic code?
vcpkg is a command line tool too, luckily. It's supposed to Just Work with normal projects - cmake ones take some fiddling of properties.
Immediate Mode Gui like this one are fairly independant from the Renderer optimization. While Vulkan might be more performant if done correctly, there is only one function that use it. I'll argue that it doesn't bring much. Search Immediate Mode Gui on the web for more info Source : I've implemented one in my code at work. 
For a point of reference, in Servo parsing of HTML/CSS as well as matching of CSS to HTML nodes is done on CPU, then a display list is built and handed off to WebRender which uses the GPU to compute the rendered output. I would (naively) expect this project to follow a similar route.
This is a very compiler-specific subject and not related to C++ whatsoever.
&gt; Because it encourages bad practices, mainly no dependencies and “the compiler is your enemy not your friend”. Please elaborate.
So you gonna propose writing high-performance game engines in Java and patching in the entire „time critical code“ via c modules? 
look website: "WebCore has LGPL code, how can you be closed-source? We will release all modifications made to WebCore during our first official release and ensure all WebCore code stays in a separate module to satisfy the licensing requirements of the LGPL license."
The [Windows Binaries](https://dl.bintray.com/boostorg/release/1.67.0/binaries/) are working for me now, maybe it was an issue with them syncing immediately after the release? 14.1 Binaries were built with 15.6.1 (You can see this in [DEPENDENCY_VERSIONS.txt](https://dl.bintray.com/boostorg/release/1.67.0/binaries/DEPENDENCY_VERSIONS.txt)), but as others pointed out should work with any 14.x version (VS2017 and 2015). That said, it was only tested for linking with 15.6.1.
Thanks for the info!
I made a friend install kakoune without telling her anything about it \(not even what modal editor means\). I just often asked her to press the escape key\). She never used vim \(or any console\-based text editor, except nano\). It was so fun to hear her testing stuff, and discover it !
&gt; Already supports OpenGL ...The main page of the site this very post links to clearly says that it currently supports Direct3D, with OpenGL and Metal support is coming **soon**. If the page lied, thats it's problem. &gt; Creator wasn't experienced with Vulkan? 🤷 &gt; Seeing as the target audience is game development, I think that's a okay reason why DirectX is chosen. I would think thats even more reason to use Vulkan, since game development is moving towards there too. We already have great Vulkan titles, like DOOM. IIRC the mainstream engines(unity, unreal, etc) already support it. And more will support it as time goes on. It's not like *old* games are going to use this library, they've already been made. Which means it should be targeting *future* games, in which case i believe Vulkan would be a good first API to support.
The link on the page is pointing to the beta version of the binaries (and it still does not work for me): https://dl.bintray.com/boostorg/beta/1.67.0/binaries/ If I substitute "beta" to "release", it works: https://dl.bintray.com/boostorg/release/1.67.0/binaries/
If you can parse runtime input at compile time you are god. (or know the input before the program even starts) Either way such a task is bad. But if all task programs have 2 different run-time inputs i.e. the program is executed twice with different input, then it will be impossible to just print out the right result computed at compile time.
So no consumer PC ever has a GPU that doesn't support vulkan?
https://en.wikipedia.org/wiki/Borland_Turbo_C#External_links If you want to bask in the blue and yellow nostalgia, Turbo C 2.0 is freely available now. Amazing that the entire thing is less than 5MB.
I started of programming, also with Borland, using Borland Turbo Prolog 2.0, on a 386sx if I remember well. It was strongly typed, just like C (which made it a real pain to program in, given that learning Prolog was already a totally different mindset). Oh, yeah, those we're the days.
Why complain to me? I already mentioned that compilers have freedom to do a better job, yet somehow still fail spectacularly at reporting errors. At any rate: the three main compilers all report errors this way, and bad error reporting is most definitely part of the reason why people hate the language. Of course one might wonder why it is bad if C++ does it, yet if someone descends seven levels down into macro hell in C and gets an error message that is at least as hard to understand as any C++ template error, it's all peachy... 
practice
thank u but i want reference to practice can u suggest sources
&gt; If you can parse runtime input at compile time you are god. (or know the input before the program even starts) Either way such a task is bad. The input of these programs is fixed, and so is the output. Rust, D, and many other languages, can interact with the file-system, the network, launch threads, etc. at compile-time.
It does depend on the competition quite a bit, e.g. high-school level olympiads don't require in-depth knowledge of graph theory and such so often focus on text algorithms or other tasks that you can arrive on a solution without too much specific background. Others like ACM, IEEEX will require graph theory and constantly keeping in mind your algorithm's time complexity so you don't go over the time limits. Really can't substitute attending the first competition with just preparing for it. You need to get that cold shower and then improve on what you discovered were the bottlenecks. However the overall guidelines(from my experience) should be similar: * Pick a language that suits the competition and which you are comfortable in. You may be good in C, but if the competition would benefit from having data structures like sets and a lot of string manipulation, it might be better to choose something else. * Figure out how you best approach algorithmic exercises. Usually some people prefer starting with pen/paper and doing small example tests to get ideas and write code iteratively while others start approaching from the algorithm side and will start proving/deriving a solution. * Some people like writing tests to get immediate feedback after some time investment, others test manually after putting more time into the solution itself. You really need to figure out which approach suits you. * If it's a team competition, try to have a diverse set of teammates. E.g. one person being good on theoretical side while another can quickly write the solution into code. * Maximizing your score may require certain tricks. E.g. if you see the solution space being small and you are almost out of time, having a program output a constant value can get you some points with barely any time input. * Similarly, don't get too stuck on a task if you can't find a solution. Finding the balance here comes with practice.
its not my project, I just shared it here because I felt it was good alternative to electron and a c++ library :)
Adding another input for each task is not a breaking change for existing solutions. If an existing solution breaks by such a change, then it means the solution is relaying upon and using prior knowledge of the runtime input and as such should be disqualified.
Might... I don't remember for sure what is accomplished by the shaders and what is not :)
It'd be a crime to not mention the godfather of STL Alexander Stepanov in this thread
He means "C++ isn't going away", not "C++ isn't evolving".
&gt; Who would want to work harder on something far more complex for lesser money? Salary isn't just about how hard something is. Salary is also about supply and demand. If a lot of companies need JS developers and there's not that many in the market then salaries will be higher to try and create a market for them. If only a few companies need C++ developers and there's plenty of them lying around then salaries will be lower. Also, with respect to your comment on something being 'hard', this is completely subjective and aspects of C++ you think are hard are probably very natural to someone that's spent years in the industry working with C++.
He probably means that C++ doesn't seem to be dying off.
There is no such thing as well-paid single language job. You are paid for achieving results, not for using tools.
&gt; What I'm getting at is, is C++ a viable career option in 2018? Yes. There are plenty of C++ job opportunities that pay very well, e.g. at Google, Facebook, financial companies, etc. I guess it depends more on where you work than the choice of the language. See for example https://danluu.com/startup-tradeoffs/ (not C++-specific other than that large companies often use a lot of C++).
I think it's more about the domain. If you know JS then you can start on the frontend team, then transition to the Node backed, then back. You may not be an expert in these areas but you can help existing teams as priorities shift and thus you'll be a valuable asset to the company for a longer time. C++ tends to be more project based. You make the backend and you're done. You can't just transition to another team smoothly, the company needs to create work for you e.g. start using WASM in the frontend so that you don't sit idle. Which is not really that valuable to the company. Just my two cents.
Ah, I misinterpreted it, thanks.
Maybe this can be done for some of the problems as long as the new solutions satisfy the problem statement, e.g., some valid solutions assume that the inputs are smaller than some number provided by the problem statement. I guess somebody just needs to do the work. AFAIK the maintainer attempts to invest as little time as possible with this.
I miss the Borland package experience thou. When I was looking into start programming again in 2011 I looked around for something comparable to my experience with Borland Delphi 2 package, with everything in one box bought and pay for, I found nothing in C++ land. I ended up making my own virtual box consisting of printed versions of Bjarne Stroupstrup's two latest books, the Code::blocks IDE and mingw-64 c/c++ compiler. 
I miss the Borland package experience thou. When I was looking into start programming again in 2011 I looked around for something comparable to my experience with Borland Delphi 2 package, with everything in one box bought and pay for, I found nothing in C++ land. I ended up making my own virtual box consisting of printed versions of Bjarne Stroupstrup's two latest books, the Code::blocks IDE and mingw-64 c/c++ compiler. 
Small UTF-8 strings can be iterated repeatedly OK-ish, or one can add an index - but for generally efficient processing, it’s ropes or even indexed ropes that are needed. Any variable-length encoding suffers from that of what’s encoded is subject to being indexed. You can of course use a wider encoding, and then it makes sense for the length to use the same units. E.g. UTF-16 would have 16-bit length words, UTF-32 would have 32-but length words. Then of course the code unit indexing is fast, but complete glyph still requires indices and/or ropes...
I know. But I’m not going to be any less outraged and vocal about it.m :). I am passionate about this stuff. 
I like this idea! But I have problems with the implementation :-) * You really need a consistent identation style (data_view uses 3 spaces, format uses mixed tabs/spaces (!), CMakeLists uses 4 spaces, etc.). Also files need to end with newlines. You can use [editorconfig](http://editorconfig.org/) to handle this stuff for you. * Some of your includes for your own files use `&lt;this style include&gt;` and others use `"this style"`. Be consistent. * You've used VSC++ extensions. In particularly, data_view needs to be rewritten because specializing a function at a class scope is illegal and GCC and clang will reject it. You need to do something like this instead constexpr void store(data_view&lt;char&gt; d, char v) { d.bytes[0] = v; } ... more overloads ... * Your CMake file doesn't work for me. Also it should probably expose an `INTERFACE` library so consumers can use your library with `add_subdirectory` without building any tests. Also you don't use the `enable_testing` stuff. I'm no good at CMake, but something like this cmake_minimum_required(VERSION 3.8) project(cppystruct LANGUAGES CXX) add_library(cppystruct INTERFACE) target_compile_features(cppystruct INTERFACE cxx_std_17) target_sources(cppystruct INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/include/cppystruct.h ${CMAKE_CURRENT_SOURCE_DIR}/include/cppystruct/calcsize.h ${CMAKE_CURRENT_SOURCE_DIR}/include/cppystruct/data_view.h ${CMAKE_CURRENT_SOURCE_DIR}/include/cppystruct/format.h ${CMAKE_CURRENT_SOURCE_DIR}/include/cppystruct/pack.h ${CMAKE_CURRENT_SOURCE_DIR}/include/cppystruct/string.h ${CMAKE_CURRENT_SOURCE_DIR}/include/cppystruct/unpack.h) target_include_directories(cppystruct INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/include/) option(CPPYSTRUCT_TEST "Generate tests.") if (CPPYSTRUCT_TEST) enable_testing() add_subdirectory(test) endif() and then another CMakeLists.txt in the test directory that does the git and catch stuff to build tests would be better.
I'm hiring for my team and it's so frustrating dealing with other managers and recruiters. I get asked questions like "do you need C/C++, python, or Java?" and when I say "I need a good engineer" it confuses everyone
I'm using Visual C++. If I need one of the Boost DLLs, is there an easy way have Visual C++ automatically copy it to my project's build output directory (where the compiled/linked .exe(s) go)?
I find it quite shocking that FPGA jobs make 1/2 to 1/3 of typical developer jobs. 
I was a bit blocked on answering this because doing this question justice is a herculean affair; I could very literally write a book on just the things C++ did wrong. In an attempt to keep it manageable, I'm going to restrict my answer to ten points, with no particular effort for them to be comparable, of similar magnitude, or particularly well partitioned. I also haven't proofread this yet. ## C has move semantics C++ has probably tricked you here, but C actually doesn't have copy semantics. This is probably more obvious when looking at Rust, which has sane move semantics. In C, when you have typedef struct { char *data; } string; string new_string = old_string; you are performing a transfer of ownership (or potentially shared ownership), *not* a deep copy. This corresponds to Rust's moves, or a copy when the type has no destructor. C++ decided to replace this with deep copies despite that being exactly the opposite of what already existed, a major cause of performance issues and an utter mess semantically. It's true that C's method requires the programmer to keep track of ownership, but as Rust shows this is not a difficult thing to solve. The most obvious way to do this is to ask resource holders to add a post-move hook, that happens after the `memcpy` and post-move hooks have been called for each of its members. class string { public: string() { ... } ~string() { ... } operator move(string *new, string *old) { old-&gt;data = nullptr; } } Note how suddenly the semantics of the language become so much simpler. You do not need copy constructors. You do not need move constructors. You do not need rvalue references and their confusing rules around inference. You do not need `operator =`. You do not need to worry about hidden copies. You do not need overloads on `push_back` and a million other functions. You *also* don't need to know yet another bunch of rules about when the default copy and move constructors are implemented, since it's the same thing every time. (One has the same concerns about constructors, FWIW, which C got right and C++ changed to something wrong.) ## `std::map` and `std::unordered_map` It should be well known that C++'s maps are a disaster. `std::map` should have been a B-tree and `std::unordered_map` should have used open addressing, but the standard prevents reasonable implementations. It seems there wouldn't be much to say on this, but no, [it gets worse](https://youtu.be/smqT9Io_bKo?t=19m9s) (skip to [42:59](https://youtu.be/smqT9Io_bKo?t=42m59s) for the shorter version). ## So-called "iterators" Real iterators have a very long history, and there have even been many papers on the two major approaches (internal vs. external iteration). Of course, C++ didn't end up using either approach, and it built something terrible instead. I'm not going to rant on this here; instead see two previous posts (only one of which is by me): 1. https://www.reddit.com/r/programming/comments/4vto4r/inside_the_fastest_font_renderer_in_the_world/d62swqy/ 2. https://www.reddit.com/r/programming/comments/4vto4r/inside_the_fastest_font_renderer_in_the_world/d62jqeu/ (NB: C++ may eventually get ranges (aka. what everyone else calls external iterators) at some point, which is great but too little too late [also, [eww](https://www.reddit.com/r/programming/comments/3vt4eh/ways_to_avoid_complexity_in_modern_c/cxrfabn/)]) ## Grammar, `operator ,`, iostreams `a &lt; b &gt; c;`, `++it1, (void)++it2`, `std::cout &lt;&lt; "enough said"`. ## `&lt;random&gt;` I owe an attempt at a full blog post on the many ways that `&lt;random&gt;` is dangerous, but I can link to some short and incomplete discussions, like [this blog post by O'Neil](http://www.pcg-random.org/posts/ease-of-use-without-loss-of-power.html) and [this thread involving myself](https://www.reddit.com/r/programming/comments/6e10b8/when_random_numbers_are_too_random_low/di6upbd/). I do not consider these comprehensive evaluations of the flaws of `&lt;random&gt;`, so watch out for my future publications if you're interested and I actually end up with something I'm happy to publish. ## String handling, parsing, `&lt;regex&gt;`, etc. Admittedly, C++17 gave us `std::string_view`, `std::from_chars` and `std::to_chars`, but I can hardly think of anything else C++ does right with strings. [Chrome made the news because of C++'s awful string handling,](https://groups.google.com/a/chromium.org/forum/#!msg/chromium-dev/EUqoIz2iFU4/kPZ5ZK0K3gEJ) pre-`from_chars` parsing was horrific if you wanted something reasonable (it was easier to roll your own much of the time for correctness), pre-`to_chars` serialization was [intrinsically slow](https://www.reddit.com/r/cpp/comments/7imd4w/string_conversion_benchmark_in_modern_c/dqzz0ps/). The problems with `&lt;regex&gt;` aren't just its horrible interface (where it [does this](http://en.cppreference.com/w/cpp/regex/regex_search), Rust [does this](https://docs.rs/regex/0.2.10/regex/struct.Regex.html#method.captures) and [that](https://docs.rs/regex/0.2.10/regex/struct.Regex.html#method.is_match) [and note that Rust's version is *better*, not just nicer]) but also just its [really poor implementations](https://lists.gnu.org/archive/html/lmi/2016-07/msg00010.html) ([see also](https://www.reddit.com/r/cpp/comments/732ubp/why_isnt_cs_stdregex_search_worstcase_time_linear/)). ## `auto_ptr`, `template &lt;typename&gt;` and other obvious mistakes I'm going for low hanging fruit here, but it's telling that C++ keeps on retrying the same thing because its first attempt was bad. `auto_ptr` died. `template &lt;typename&gt;` isn't just stupid grammar, but it was a replacement for `template &lt;class&gt;` (fixing too much keyword overloading by adding more keyword overloading, how the standards team amazes me) that wasn't even right the first time so we had a mix of "new" `typename` advocates mixed with `class` advocates (since that one still worked) until C++17! Then there's `std::make_unique`, which missed a standard for whatever crazy reason they somehow forgot it. And the huge number of different construction syntaxes, that I pray may some day stop growing. And the second return type signature, since the first one was specified in a problematic (and strictly worse) manner. And so on and so forth. --- I'm tired of writing so the next three are shorthand. ## Exception safety C++'s exceptions are not just really utterly strange for a language of its class, but also [mix really badly with its semantics](https://www.youtube.com/watch?v=AKtHxKJRwp4&amp;feature=youtu.be&amp;t=24m00s). ## Template errors and SFINAE I don't really know if this needs to be proven. ## Pervasive overloading and confusing lookup semantics does not mix with tons of implicit casts Effective use of overloading requires knowing what overload gets used; implicit casts make this really hard. Implicit casts are only possible to handle reasonably if they happen in obvious and predictable ways; overloading borks this. It's enough that C had implicit numeric casts, which are at least defensible, but it didn't have struct casts, and it certainly didn't have pervasive overloading! 
Cool tyvm for explaining!
Also the JS developers market (and honestly almost all the mobile/web market) is filled with bad developers so when you get a good one you try to keep it -&gt; increase the salary.
Don't worry about being a language specific programmer. Find a well-paying job that has work you'd find interesting at a company you'd enjoy work for. That's what I've done and so far I've used Java for Android dev, JavaScript on both the front and back end, c# both front and back end, c++, php, and go. And I've used many databases. It's been a fun ride so far and every time I learn a new language, it helps me with all the others. (Except php. It's a serviceable language that's boring to develop in and doesn't have any interesting, unique concepts.)
I set it as a post-build event. Project properties -&gt; Build Events -&gt; Post-build event, and then something ike copy "C:\Program Files\boost_1_67_0\stage\boost_filesystem-vc141-mt-x64-1_66.dll" $(TargetDir) for each library you want. It's not pretty or sophisticated but it works. Alternatively just add boost's stage directory to your path, but I do prefer having them sit locally beside the executable and have never really bothered seeing if there are any secret gotchas doing that.
Too bad that the writer didn't mention the fact that you can use std::invoke with a member pointer and an object to get the member
&gt; The less surprising behavior would be to replace an existing element if the key already exists, but instead it just does nothing in that case, which is rarely what you want. [`insert_or_assign`](http://en.cppreference.com/w/cpp/container/map/insert_or_assign) then?
two weeks of book study and IDEone tinkering can get you to a solid place in any language, imo.
Dunno about how much of it is a bubble vs. just actually being more in demand, but I do think things may shift in the next 5-10 years. Right now there's a lot of senior programmers who learned C/C++ at school, but now a vast majority of Universities are placing emphasis on python, javascript, and java, with only some specific C programming electives. My experience as a recent grad was that skilled C++ developers might be highly sought after in the next decade or so, as graduates are taught higher level languages and--let's face it--learning lower level languages like C++ can be a frustrating experience, meaning I think those grads are less likely to branch out to a language like C++ than Haskell or whatever trendy cross-compiles-to-js language there is.
I appreciate the thought and effort that went into your reply. I disagree with some of the issues you mentioned (Rust-style move semantics rely on a borrow checker, which is not possible in C++ if you wish to remain backwards compatible with C; red-black trees are superior to B-trees for applications in which memory access is not extremely expensive; given that C++ containers hold copies and not references and the elements an be arbitrarily large, open addressing in C++ containers is a poor choice because it requires a max load factor &gt; 1.0; poor regex performance is due to vendors, not the standards committee - if vendors just built off of boost::regex, they would've had much better performance)
Yep exactly. Don't really mind if a hire needs a month to learn a language if they are otherwise solid because the average FTE will be around 2-3 years
&gt; the backward compatibility thing could be solved by adding an implicit type conversion to const char * for std::string_view I guess No... most string views are not null-terminated, so this conversion would be horribly unsafe and broken The best fix that I know of is to use `zstring_view`, described here by Nicol Bolas: https://stackoverflow.com/questions/41721808/why-does-stdstring-viewdata-not-include-a-null-terminator
&gt; Rust's borrow checker is only needed for borrow string a = "foo"; myvector.push_back(a); std::cout &lt;&lt; a; What happens? Does myvector contain a copy of `a` or a move? If it is a copy, then you need copy semantics. If this is a move, is `a` a valid object by the third line of the program? If so, what does it equal? This is where a borrow checker is needed. &gt; A red-black tree is effectively a bad version of a 2-3-4 tree, so it is very odd to hear you say that they are ever better. Well yes, a red-black tree is effectively a binary B-tree. When you said B-tree I assumed you mean nonbinary because otherwise people typically refer to the more specific name. I've never heard of 2-3-4 trees being better than red-black trees. After Googling around a bit, I couldn't find any articles that suggested a performance difference either. &gt; Vectors have a load factor &gt; 1.0; this has never been an important criticism. That's true, but only if you are using `push_back()` without `reserve()`. 
All the major commercial game engines have vulkan integrated already. Very few games are shipped on home-grown engines.
Most of the top CS programs don't teach specific languages. They teach concepts and use the languages as a way of demonstrating those concepts. Try asking new grads "what was your favorite class?" - one set will say things like "I really liked my Java programming class" and the other set will say something like "I enjoyed my distributed systems class" - the first one, I might hire as "Java programmer", the second is more likely "Software engineer". I guarantee that "java programmer" tops out faster while software engineer has a pretty unbounded top.
&gt;They teach concepts And the point here is that concepts which exist and are important in C++ don't exist in some of those other languages, and so aren't learned or fully understood by those students.
There are a lot of c++ positions paying very well. Shout out to my company, [Cruise Automation](https://getcruise.com, for paying well and having interesting challenges! We’re hiring for exactly those positions, so if you’re interested DM me or apply on our site.
The only big one that people seem to not grasp when they haven't touched c/c++ is pointers and details around memory management. I can have conversations about parsers, functional programming, distributed agreement protocols, etc without needing a specific language to drive the conversation.
I agree it would be more useful to spend time on this than some other stuff but education changes slowly.
This looks pretty nice but can it only store `vector&lt;uint8_t&gt;`s? If so then that's a very limited use case, right? Any plans to extend that?
Elements are added as a pair&lt;&gt; consisting of a pointer and size.. So you can add anything you want...
Yeah who would have thought that all the circle jerking didn’t amount to anything.
It's less verbose and less error-prone for the caller to pass a value when calling rather than explicitly specifying the template arguments, since they may (read: will often) forget to specify `&amp;` for lvalues.
It's less verbose for the caller when they have the format as an expression (e.g. `(PY_STRING("c")`) since it avoids `decltype`. That said, it should be `countItems(Fmt)` rather than `countItems(Fmt&amp;&amp;)` – as-is, the code would fail to compile if the caller passed an lvalue.
(for that one particular benchmark*)^(get rekt Haskell)
I'm the author of this library and I would be glad to answer all your questions or suggestions right here. The support for a non-owning view on a callable object in this library was requested many times through different comments. The usage is similar to other well-known implementations such as llvm's function_ref but with the benefit of having qualifier correct invocation and support for multiple overloads as known from the owning function2 type erasure wrapper. Personally, I'm using the library in my [continuable](https://github.com/Naios/continuable) library for allocation aware futures, for which function2 provides the backend for type erasure.
&gt; Dunno about how much of it is a bubble vs. just actually being more in demand, but I do think things may shift in the next 5-10 years. There is a huge bubble in tech and finance and risky vaguely "tech" companies. When we finally roll over into a bad recession within the next three years shaky companies like Tesla and Amazon may go under. You don't think this will drag wages down? Most of the HFT shops and a load of hedge funds will shutter, too.
&gt; full allocator support I'm interested in hearing how you achieve this, since the standard had initially tried to specify allocator support for `std::function`, but after some real world experience, it was dropped. I believe that before being removed in C++17, no major standard implementation actually supported allocators in `std::function` (hence the committee giving up). How do you go about doing type erasure for the allocator? Does it really provide *full* allocator support, such as respecting the allocator traits values for `propagate_on_container_copy_assignment`, `propagate_on_container_move_assignment`, and `propagate_on_container_swap`. Also, is there a performance penalty associated with this feature? I'd assume it needs as least one indirection to actually dispatch to the allocation and deallocation functions. Maybe I've made some incorrect assumptions, but I'd consider dropping allocator support. It's not an in-demand feature (I don't think there was much pushback when the standard was considering getting rid of it) and the entire allocator model has some problems (hence the addition of memory resources in C++17, as well as talk about re-writing the allocator model for inclusion in the `std2::` namespace).
Some languages have more devious and sneaky pitfalls than others, C++ only keeps to the almost sane level thanks to great tooling. Python is almost completely sane (just be careful of how you divide stuff) and can be picked up easily. Javascript you might think you can, but the sneaky parts will come down on you later.
Good job, I liked that site it's too bad. Wish there would be an alternative to it.
Things people will probably dislike: * Single letter namespaces. * Factories and Pointers (at least not owning). * Hidden threads. * GPL. Not even LGPL, it's GPLv3! Exception-free overloads like in ASIO or an result/expected approach would be a good idea. How do you get native handles to display and window for OpenGL context creation?
3.11 is already compatible with it.
The lack of event-driven design is an active point against for a GUI, IMHO. Far from being annoying, it's the easier and cleaner way to reason about user interfaces. Still though, if you're going to make one that tries to completely hide an event loop as an internal detail, there's no reason not to keep going and try to avoid the dependency on the current windowing libs.
There's no reason to go back over C++98 code and change it just for the sake of changing it. C++11 is still not supported on some older systems so by requiring it you may prevent OpenCV for example from being used on embedded devices or other gear with poor support from cutting-edge distros.
If you primarily write your software with free software in mind GPL is the ideal choice. I'm same I have zero interest in supporting some closed source crap. However of course it's nice that foundational libraries such as boost use such a permissive license.
No clear numbers that I know of, but as others have said, all the major commercial engines already support it or plan to, it's supported on all three major OSes, mobile devices are getting/already have support for it, GPU manufacturers already support it, etc. Basically, things look pretty good for Vulkan.
This is a quite interesting project, I prefer C++ over C any time, because of advantages of using it.
Managing dependencies in C++ is really painful, there is no portable way to do that, so many projects just have as a rule that they don’t allow any dependencies. This forces everyone to re-invent the wheel in sub-par ways, but in C++ this is often better than dealing with build system issues. Compiler error messages are pretty bad. For subtle things like returning dead references to the stack or when a template is underconstrained one doesn’t get any. For harder errors when one passes the wrong type to a template one gets 100 of lines of error message. One has to put in extra effort to try to make sense of these error messages, and often to try to make them shorter compilers leave information out that’s critical for debugging the issue. Often the user needs to try to break the compiler in creative ways to make it spit relative information. All of these contribute to the feeling that the compiler is working against you. In other languages with nice error messages the feeling is very different.
On the other hand IDE RAD tools on linux were a complete joke, and they still kind of are.
Kylix ruined it for everyone.
&gt; C++ &gt; great tooling 🤔
You probably don't want to use OpenCV on embedded devices because of how inefficient with memory it gets. Opaque types like `cv::Mat` are not something you want in these environments. And it's not just about rewriting all the code, it's about moving newer versions / APIs toward a new standard. Plus that doesn't make the lack of templated class justifiable, because it's so much better to have templated functions that are literally unchecked casts.
I strongly disagree, but that discussion is out of place here.
I'm not saying it's *great* code. Its main positive qualities are that it's free and functional. It's the leading library for what it does, so you *DO* probably want to use it. It will run [on phones](https://opencv.org/platforms/android/) ffs. Incremental improvements are good, but I don't particularly care if they're using C or C++98. That is secondary to the other good points. Nevermind the specifics of OpenCV for a sec. I'm just saying that going back over a mountain of older C++ and changing a bunch of stuff just for the sake of "modernizing" it is hardly worth it to most people. In the case of doing it to a popular library, it can have the unintended effect of generating a bunch of work downstream and/or making the library unusable for a lot of people.
**Company:** Storro (https://storro.com) **Type:** Full time **Description:** We are looking for a C++ engineer who is passionate about building secure and scalable systems. You will work with a small team of professionals on Storro. Storro is a user-friendly portable p2p file collaboration platform that can be described as a mix of Blockchain, Git, TrueCrypt and BitTorrent. In a nutshell, Storro offers users a writable file system with revision history that can be shared and auto-synchronized with other users on a fine-grained level. File metadata and content is signed, encrypted and deduplicated. Authorization checking is performed by a distributed access control list mechanism. You may work on subjects like: distributed PKI ACL’s, p2p network infrastructure, distributed storage, trusted services, multi-factor authentications and iOS/Android. We offer a modern environment based on C++17, Qt and Gitlab on the major operating systems. Full job description: https://storro.com/jobs/cxx-software-engineer/ **Location:** Hengelo (The Netherlands) **Remote:** No **Visa Sponsorship:** Yes **Technologies:** C++17, Qt, Linux || Windows || OSX, GitLab **Contact:** jobs@storro.com
Eh... what's the point of that site? I don't get it.
**Company:** Storro (https://storro.com) **Type:** Full time **Description:** We are looking for a C++ engineer who is passionate about building secure and scalable systems. You will work with a small team of professionals on Storro. Storro is a user-friendly portable p2p file collaboration platform that can be described as a mix of Blockchain, Git, TrueCrypt and BitTorrent. In a nutshell, Storro offers users a writable file system with revision history that can be shared and auto-synchronized with other users on a fine-grained level. File metadata and content is signed, encrypted and deduplicated. Authorization checking is performed by a distributed access control list mechanism. You may work on subjects like: distributed PKI ACL’s, p2p network infrastructure, distributed storage, trusted services, multi-factor authentications and iOS/Android. We offer a modern environment based on C++17, Qt and Gitlab on the major operating systems. Full job description: https://storro.com/jobs/cxx-software-engineer/ **Location:** Hengelo (The Netherlands) **Remote:** No **Visa Sponsorship:** Yes **Technologies:** C++17, Qt, Linux || Windows || OSX, GitLab **Contact:** jobs@storro.com
I have to agree, especially compared to java, the tooling is not that great. That beeing said. I think the current QtCreator with the integrated clang code model is a big step in the right direction. It gives you compiler errors and warning almost instantly inside the IDE without explizitly compiling the code. Refactoring and name resolution works much better too.
&gt; no major standard implementation actually supported allocators in `std::function` We did :)
yes
ugly bug clickable
your example on your github page should make that more obvious.
My main problem with OpenCV is I need to use it because for many algorithms the alternatives are even more a pain to get to work but that doesn't make it less badly designed. I wouldn't say Android is really embedded, you have a lot of margin when it comes to memory and processing power. There isn't much to change in the current codebase (except the lack of documentation even for core parts) but a C++11 (or even 14/17) API could be considered in a likely future for a major version but by the looks of it it's not happening and I think it's a shame. And you could even improve it a lot keeping with C++98 if you avoided to type erase everything + terrible doc to make everyone rage when they used the wrong type because they assumed from the half a line description that you needed something else. OpenCV is also hardly C++, the templates are mostly simple casts, the classes are almost all internal, useless and forced, the only thing I'll give them is the RAII with reference counter on `cv::Mat`.
I contribute to free software in my spare time because I like contributing to the community. I don't want my code used in software I myself cannot use, why would I then choose any other license than GPL? And to clarify, if that means some closed source for-profit company cannot use my software, it's simply not interesting to me at all. I mean, why would I care since I cannot use it anyway? 
If it doesn't recognize Boost 1.67 try using the Boost_ADDITIONAL_VERSIONS option. I already tried building with it and it seems to work fine.
so what's that benchmark for?
What Cmake update? What do you mean?
Good for citations, when explaining your decisions to management or other developers. Saves time proving the same thing over and over again.
Sounds interessting, but why is there no example for the API?
What can you say about "non-major" locations like Princeton or Lugano? Can you list pro/con-s? like, e.g. in terms of career development, how do these places compare to NYC or London?
The closer that I know about is this one: https://github.com/kostya/benchmarks/
https://www.libcxx.org/w/helloworld.html
&gt; Linux segfault fiasco Source?
How does your server compare to [cquery](https://github.com/cquery-project/cquery)? And how does your plugin compare to https://github.com/autozimu/LanguageClient-neovim?
Google for 'ryzen linux segfault'.
I've really been absent from these projects. I will hopefully be getting back to it here in the next couple of weeks. Months late...
&gt; Change in [vector.bool] 26.3.12/1: &gt;&gt; To optimize space allocation, a specialization of vector for bool elements is provided *(we are sorry)*:
It is more like a tree view, since it does not own the data. Not sure what it is useful for.
But if no updates are allowed, then I'm not sure how relevant the data is.
Hello /u/_naios, I'm the author of [P0792: "`function_ref`: a non-owning reference to a Callable"](https://wg21.link/P0792), which aims to standardize an abstraction that's very similar to what you have implemented. The proposal has been approved by LEWG and sent to LWG for wording review, but I would appreciate your feedback/suggestions on the matter since you have experience with an implementation, and since there's still time to make changes/improvements to the paper. Thanks!
The page is being shut down. Its pointless to accept new contributions when you are going to close the website in a couple of months anyways. 
&gt; const char * also has no guarantees that it must point to the address of a null terminated string True, but many functions require a null-terminated string literal. So `string_view` is not an appropriate argument. If you create interfaces that take `string_view` but expect null-termination, those interfaces will constantly be misused because not every call to them needs to be on `const` data. Programmers expect `const char*` to be null-terminated assuming it is pointing to a string. &gt; it's just the language level string literals being pointers seems a bit "leaky" to me They are not pointers. They are `const char[]`. You use raw pointers to refer to them but not to own them which is the generally accepted use of raw pointers in modern C++. In fact, `string_view` is probably a couple of pointers. `string_view`'s nature is also why there isn't much merit to replacing `const char *` with `string_view`. `const char[]` will be implicitly converted to `const char *` for the constructor of `string_view`, stored internally and then used when implicitly converting to `const char*`. But you had that type available anyway so the rest is extra steps.
Sysadmin time is definitely a major concern as it's just a part time role for one person. The consensus among the replies make it pretty clear that a single beefy server is definitely the way to go.
Reminds me a lot of Scitter (https://sciter.com/), which has free binaries but $310+ subscriptions for sourcecode access and static linking. Would be nice to see a proper comparison.
&gt; What platforms are you building for? See my edit to the original post for the answer to this an other questions. &gt; You should probably measure your bottlenecks. Well the tricky thing about bottlenecks is that they move around when you build on different systems. :) On my development machine the build is 100% CPU bottlenecked, on our current server I suspect that storage is bogging things down, but on our new fancy theoretical server it could be something else. &gt; us randos on the Internet can't be sure about what issues you are running into But sometimes a bunch of Internet randos who happen to have expertise, enthusiasm and experience can be a really great place to start gathering information, as this thread shows. Especially when looking for general advice, not specific fine tuning. Thanks! 
As soon as you have the option of showing me all of the function parameters from the signature as I'm filling them in, I'm switching over.
Slightly off topic, but still highly pertinent. One shouldn't buy new hardware if one isn't getting the most of what one already has. I've already put a fair bit of effort into ensuring our builds are highly parallelisable. On my development machine CMake+Ninja can keep my 8 virtual cores pegged at 100% for the full 24 minutes it takes to build. MSBuild, not so much, but it isn't terrible.
&gt; You can minimize licensing costs This isn't something I had considered at all, but it's a very good point. Thanks!
I could say the very same thing about this project myself. I had some substantial improvements planned for my observer implementation, but I've been really busy with other things lately.
&gt; Ownership is complicated? Not really. I disagree, or rather that depends on what you're doing with it. &gt; The concepts themselves are rather simple. The implementation is complex - offloading the manual burden of keeping track of everything to the programmer. Well, that's the same model as C++, really: you push the burden onto the programmer but give the programmer enough tools to automate most of it away. Rust appears to give the programmer more tools to be precise about what they mean. The trouble is with that is that you really have to have it nailed down. &gt; I suspect that is one reason why the Rust team (last I heard) was actively contemplating (re)introducing an optional garbage collector. My guess is it will hit the same problems as C++. Garbage collection only really tracks memory garbage, not other resources and besides, C++ (and Rust---it's basically the same kind of thing from this point of view) generates little garbage. I guess the thing you'll lose in Rust is the really precise ownership with GC, so you'll get no help with races. At that point why bother with Rust anyway?
are autocompletions planed?
You are both correct. I suspect that they didn't like the results, given that they are Linux people.
Very inefficient C++ implementations and looks dead.
If you're concerned about depending on GTK, then presumably you're working in an extremely constrained environment. Basically I see the use case for this being the display on a 15-year-old elevator (that probably shouldn't be using X11, but that ship sailed long ago). People probably don't expect it to be beautiful.
Can somebody explain why there are so many clang-based language servers? Rtags, cquery, cland, now cxxd, probably some others I don't know about.
No idea. I haven't used any of those. I must say that I have never understood the reasoning of such questions on this subreddit. It's kinda annoying and it is putting people back from publicizing their work because it feels they have to explain themselves for doing it. In other words, I cannot anticipate that every developer out there working on his own private projects will try each and every similar tool out there and provide in-depth analysis just for the purpose of presenting it to the public. Although the question you asked (and many others will have the same question for sure) does seem like a valid one, it does imply that the author has (or should have) tried and understood all of the other tools out there before making his own tool public. That simply doesn't hold. No one has indefinite amount of time on his disposal to do such analysis. My point is: I am not trying to sell anything here, I'm just reporting back the work I have done which I believe it can be useful to the community. To be more on-topic: * `cxxd` is a language server which does **NOT** implement the `LSP` but instead it has its own protocol (reason for another protocol is not the dislike towards `LSP` but the reason is that `cxxd` protocol was created before `LSP` has been publicly announced). * It implements a variety of features as [documented on the home-page](https://github.com/JBakamovic/cxxd#features). I feel most of these features overlap with other features found in other similar tools such as `cquery`. One of the bigger feature `cxxd` is missing right now is auto-completion. * It offers features which are not part of the `LSP` such as support for integrating build-project feature. * It is not Clang-centric: it also offers features which don't require any compiler frontends (see the next bullet point for example). * It offers a very flexible async framework which enables integration of any feature you can envision and which you can find handy in your daily work (e.g. test-runner, integration of other wealth of static analysis tools, etc.). * It is implemented in Python (which I regret right now but I can't change that very easily) so it probably suffers a bit on the performance side. * Plugin for Vim is only a thin layer which reflects and makes use of the features found in `cxxd`. Nothing very exciting about it. All the hard work is done in the core. Have a look at the [`cxxd` public API](https://github.com/JBakamovic/cxxd/blob/master/api.py) to see it yourself. Cheers, Adi
Another fucking language server, why didn't you try to improve any existing ones, rather than making a new one ? This is why we have 15 standards for everything!
Thanks for your kind welcome and your supportive words. Perhaps, next time try and show us some of your work, ha?
Hey OP, this is great, I have been following your progress on yavide for a while. I think it might be time to try the switch from vim. Are you aware of any caveats, especially when working on _large_ projects with possibly large files? I see there might be slowdowns when scrolling with cxxd-vim.
I would love to get them in ... yes.
The former. I'd be really interested in an in-depth comparison and why people choose to build new C++ language servers instead of improving existing ones. Clangd looks the most promising at the moment, with Google (and now Apple) behind it.