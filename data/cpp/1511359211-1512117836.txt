Have you seen gRPC?
I think it is undefined in older standards. (haven't actually checked)
You may be using the wrong compiler.
Some background information for the story... let's start with a simple x86 intrinsic example (assuming unnamed structs are valid with the used compiler - just for example's sake) union float4 { __m128 v; struct { float x, y, z, w; }; }; The types aliasing here are not same so the compiler can't just go and use insert/extract (or equivalent) to access the vector lanes. If you, for example, read from x the vector has to be stored in memory and the correct float scalar has to be read from the memory location it is stored at. The fact that it works at all is because some compilers prefer to do the expected instead of just invoking UB. That's nice of them, but it is inefficient anyway so that doesn't help us at all. We want to extract that vector lane #0 and get the result as a scalar. Now here things get interesting. What's scalar when you are on x86 SSE or better? Well, it's of course the SS (Single Scalar) mode of SSE. The registers are still 128 bit wide but there are number of instructions that only operate on lane #0 which is the scalar lane for each register. Now it works just like scalars instead of vectors. So good so far. Now, if you multiply a vector by scalar the Intel doesn't really mix instructions like that. It is either 100% scalar or 100% vector. The scalar has to be upgraded to vector by broadcasting the lane #0 to all components so that a * b.x is actually a * b.xxxx in terms of vector hardware Intel has on their CPUs. On my example code in the article I wrote a * b.x, but the compilers step in and help with this. I originally had a tons of overloads for vector*scalar, scalar*vector, vector*vector and it worked great; the code did overload to a * vector(b.x) which then did the broadcast. This stuff is not necessary anymore after compilers got smart a few years back. It took a long time but they did it. GCC, clang, MSVC. Now I only have non-explicit constructor that takes a scalar so the expansion is done in the CTOR and it "just" works. The example demonstrates the expression to compile into 2 instructions. It's just so cool. For the architectures that DO have vector*scalar, the overloads can be implemented so that unnecessary expansions just go away. 
I use my phone for browsing Reddit frequently. It is still a hassle to type on the phone. Navigating text, editing blocks of text, etc is a pain if you are, and definitely will be, used to typing on a physical keyboard. Phone won't be comfortable for typing code.
[Simon's Meeting C++ blog post](https://blog.tartanllama.xyz/meetingcpp-2017/)
I had somewhat very strange bug yesterday. My project in Eclipse was building fine in debug, but not in release. `fatal error: no input files`. I looked at the command GCC received and everything (in terms of flags and paths) was fine but there were no source files indeed. Only library, include paths and standard specs. I opened console; `make all` and got errors about `"` and "unexpected EOF". I started to verify all makefiles that Eclipse generated in both configurations but everything seemed fine. I started then to `sdiff -s` related pairs of makefiles from debug and release. Everything was the same except debug/optimization flags. Normal. But I found inconsistency within some paths so I reordered them and removed extra last backslash from `C:\files\C++\include\`. **And this was the cause.** Eclipse, when generating makefiles always packs paths within `"``"` to avoid any space and other breaking characters problems. This fucking backslash has escaped ending `"` and reversed all remaining quotations, thus removing source files from the command. Damn MS, who the fuck has made the OS use `\` as both a separator in paths and an escape chacater? I'm never going to use their `\` again. You can't even copy paths from explorer into console, because console treats it with escaping. Good that they have made `/` working too. I'm working always on Linux but when I try to do something in home on Windows ... I discover bugs that I had never though of that would exist. 1 more to my list, which is already mostly occupied by path and file-system related problems.
Cool, thank you very much! Yes the swizzle-syntax is indeed really cool and it comes "natively" with your implementation, which is really nice.
I'm currently using it in a small, commercial, embedded context. I picked it up for a few tools I've found useful: the narrow-casting facilities, `gsl::byte`, `Expects` and `Ensures`, and `gsl::span`. I've already gotten used to using similar utilities in my projects and decided I may as well use something with wider adoption. The library really isn't very big so I felt I had little to lose by incorporating it. So far it's met my needs. `gsl::narrow` in particular has saved me a couple times and the `Expects` and `Ensures` macros are convenient for asserting with a bit more semantics and control (there are macros to configure their behavior).
The problem for making `sizeof(optional&lt;bool&gt;) == 1` is that you have one of two choices, mutually exclusive: * The value accessor can return `bool&amp;` * The value accessor can be `constexpr` You'd probably pick option one - but it still kind of sucks to have this kind of inconsistency. 
I use it, mostly for span. I basically just copied and pasted the header into my source tree, grabbed a few of the tests and changed them to work with our unit test framework (gtest). It's definitely a lot cleaner to pass span than pointer + size. I wouldn't say it was a night and day difference. It's just a convenient utility class that every C++ programmer has thought of at some point. Rather than waste time writing a version that would end up being less well thought out, I grabbed this code. If it had taken more than an hour (or two) to make it ready to use with our build system I probably wouldn't have bothered, to give you a sense.
I've used and relied on using unions of four floats and a float[4] array plenty. I don't know if identical types are considered undefined behavior, but it seems to have been a very good design decision so far. (I actually use unions of different types a lot, some for atomic operations on bitfields)
Don't get me wrong; I have done that as well and it's fine. The main course was mixing intrinsic vector types and floats by not mixing them. ;) Union of same types is valid C++. I don't have the standard to quote with me but it should be there. SO might have something about it. Wait a millisecond... https://stackoverflow.com/questions/34677343/accessing-same-type-inactive-member-in-unions Duh. Of course stackoverflow had something about it. Should be good to go. :)
[Seems like it's still alive](https://github.com/thrust/thrust/issues/892#issuecomment-341822340)
Original MS-DOS didn't use backslash as a path separator because (like CP/M, which it was originally a compatibility layer for in pre-Microsoft days) it didn't support folders. After all, the only disks it supported were quite low capacity floppy disks, and the filesystem was based on the CP/M one which also didn't support folders. The forward slash was used for options on commands for reasons that also predate Microsoft (I believe CP/M copied it from some mainframe series). So when Microsoft added folders to MS-DOS, although Unix was the model they were aiming to imitate, the forward slash was already taken. There were options to change the option and path separator characters even in early MS-DOS, but they couldn't be the default without upsetting existing customers, and as they weren't default no-one really used them. As for conflict with escapes in double-quoted strings - no such conflict existed. Pathnames couldn't have spaces in them, so there was no need to wrap them in quotes. The backslash-as-escape convention really didn't exist on MS-DOS, except in one particular programming language which at the time showed little sign of winning over others that had different syntaxes for string literals. For quite a while, it seemed like Pascal (or something else in the same family) would ultimately win. That didn't have a real escape character - if you wanted to include a double-quote in a double-quoted string, you doubled it - "here - "" - is a double-quote in a Pascal string literal". VMS (and probably other mainframe series) IIRC used backslash for paths, so it's not as if there was ever one true convention for path separators. And considering that all those conventions predate Eclipse by a few decades, if Eclipse is failing to sanitize strings (the same as everyone has to do e.g. when generating SQL) and as a result generating invalid makefiles, the fault lies with Eclipse, not Microsoft. And of course every bug is annoying when it affects you personally (ATM Android Studio won't work for me on Linux, even though command-line Gradle works just fine) but it's just a bug, and no project is immune to them. I use Linux too, but the annoying mixtures of conflicting conventions we have aren't Microsofts fault. For example, the use of non-ASCII-standard line endings on Unix-alikes (the carriage return exists for a reason - did you never wonder why internet protocols, often designed by Unixophiles, use carriage return and line feed?) combined with certain Unix-obsessives who insist on not recognizing ASCII line ends also cause occasional problems. Do your research into Unix history and you'll even find some conventions that started as bugs which so many people depended on that they could never be fixed (e.g. the dot prefix for hiding filenames from `ls`). The truth is that it's all just history, and no one particular person or group is to blame for the failure of everyone to agree to one particular perfectly self-consistent set of conventions. When I was a Windows fan, this blame-Microsoft attitude bugged me. Now that I'm a Linux fan, it bugs me even more because I'm affected by the Linux-fans-are-just-twats impression it creates too. Besides, Microsoft have done plenty of genuinely bad and stupid things - there's no need to blame them for things that aren't their fault. 
I disagree. It's much more simple that using system API and it gives you nice sockets library.
Someone at NVIDIA recently started working on it again. So I assume it will be improved. That said, I find it has a nice API already and even though it's not C++14 it 's very usable. Not sure about production uses.
On github the commits keep going on https://github.com/thrust/thrust
Looks like for some reason #pragma pack(push, 1) makes GCC output code like that. If you remove it the code is identical to Clang 
yea kind of. last commit 11 months ago. But 0 issues open! 
What is the name of that operator overload you do in the Scalar Accessor struct? I've never used that overload before, and I can't find it on cppreference. Just curious if there might be some unexpected fun stuff that happens with it, it seems handy.
Why would I choose an inferior solution?
http://en.cppreference.com/w/cpp/language/cast_operator
&gt; However, it was pointed out that in e.g. `[x] -&gt; decltype(x) { return x; }`, the `x` in the `decltype` and the `x` in the body refer to two different entities: the first refers to the variable in the enclosing scope that is captured, and the second to the captured copy. That's exactly one of the reasons I want the `=&gt;` notation to be in the language. _sad_
Thanks!
The key word is "separate". So it's not supporting tests equally well when there are separately declared mocks and base classes.
That's true for this stripped down example. Unfortunately in my real structs it does make a difference, and since the data is written to disk and size is an issue I cannot forego the packing.
IDK. I'm just asking, never used gRPC, maybe there is something better then? My point was it's crossplatform by default. I have bad experiences with COM at work so I tend to run away from them. Developers who write e.g. C# "don't care about memory management" and all goes to .... I don't know if this is a problem with implementation on COM side or C# side but I prefer to work with COM with C++... there are smart pointers and I do not have to delete/release them manually... Anyway I'm trying to learn here not to teach, that's why I was asking. Still if the idea of shared crossplatform COM interface failed then I do not understand why to use that interface. WinRT is written in COM and now they write wrappers for C++ and .NET because even plain C has better api interface than COM. Or are there any reasons? ...
In VS2017, auto s = fmt::format(FMT_STRING("{}"), 42); builds, but adding a ":d" format type specifier, causes C1001: An internal error has occurred in the compiler. Also my experience so far with VS2017 for C++ development is that it is too buggy to be used as one's primary IDE. In VS2015, the std branch will not compile at all: 1&gt;fmt_test_console\format.h(1119): error C3249: illegal statement or sub-expression for 'constexpr' function 1&gt;fmt_test_console\format.h(1124): error C3249: illegal statement or sub-expression for 'constexpr' function I hope Microsoft will get these issues resolved soon. 
Good, but it should probably have a customisable allocator.
looks a lot like this: https://github.com/bulletphysics/bullet3/blob/master/src/LinearMath/btVector3.h check line 572
Actually it does - it's just that to keep the code short and sweet I opted to use the default allocator, `reddit::standard_vote_allocator&lt;reddit::vote_type,reddit::default_fixed_chunk_multi_linked_preallocation_traits&lt;reddit::vote_chunk_allocator,reddit::standard_manipulation_strategy&lt;reddit::OPTIMAL_VOTE_MANIPULATION_DETECTION_PROXY_STRATEGY_BUFFER_CHUNK_DESCRIPTOR_ALLOCATION_TEMPLATE_DEFINITION_COUNT&gt;&gt;&gt;`. 
Clang doesn't link against a different libstdc++. 
I need that so badly. It would simplify 99% of my lambda and one line functions. Also really sad that unary `&gt;&gt;` for forwarding has been refused too. Forwarding is so verbose by now, using it really hinder what the code is supposed to do.
We should just outright remove /Wall
Nice, looking forward to the next part.
Not purely encapsulation/interface thing but they are rather anticipated to be a replacement for legacy header-based inclusion system which was one of the biggest offenders w.r.t. compile times. You can think of modules as precompiled-headers on steroids.
&gt; text_extents() without OS API calls that are all platform dependent. how can something like this be platform-independent ? at the very least it has to react to the font scaling in the OS, cleartype settings, etc etc
I used thrust quite a bit in grad school too. I always considered it very high level compared to writing raw kernels. Why do you consider it low level? 
Why is your build looking at system DLLs!?
Is this what you mean? std::vector&lt;bool&gt;* v; // wait for it auto b = v[0]; // wait for it delete v; if (b) { // BOOM }
oh i mean in the sense that its C++ like, i dont mean like bare metal. Ive been doing computer vision and machine learning for a few years and there are all these super high level apis that allow you to use the gpu without even really knowing the gpu was there. I dont even know how much the developers of tensorflow, for example, even did with memory management because nvidia has neural net sdks and I dont know how much they abstract away. Ive been wanting to play more with cuda for a while because i used to really enjoy it. I was just thinkig so long as its just for fun i might as well play with a tool that is still relevant. Yea but its definitely higher level than managing blocks and grids and such.
The _interface_ had certainly better be platform independent...
Thanks for a very detailed question. If you know so much history, I would also like to know: - why Windows has built-in case ignorance (I know people like to search, GUI etc but even in console - the fuck why?) - reserved directory names (`con` etc) - `cd C:/foo; cd ../../D:/bar` I know. It will never happen. But I hate it. - Windows API. Everyone agrees it's absolute trash. But what's the cause? Why do we have `HANDLE` not `void*`? Why `LPCSTR` and not `const char*`? Why `HWQUERYINSTANCEINFO`? Even `CONST` macro?
Honestly to me this sounds like the n-th reason why the aliasing rules in C++ are in dire need of a thorough review.
I can find a lot of software that implements it in a way of another and gives consistent results on different OSes. But the internals are different for each OS. Having an uniform API would be great. Fonts are supposed to render the same no matter the OS. I know I could use libraries to do this, but the only good ones are C (and don't even compile with VS2012), and you need to initialize them, half the functions or not threadsafe, etc. Platform-independent font rendering is really something that would be great to have.
&gt; Fonts are supposed to render the same no matter the OS. ... what ? no, I thoroughly disagree. Every OS does stylistic choices with fonts.
Thrust is amazing. I use it in my meshing code
I've been considering using it a few times over the past year or two. But to be honest what kept me from it is exactly the fact that it doesn't seem active anymore and the last release was in March 2015, and who wants to bet on a dead horse. Yes, true, libraries in some domains mature and at some point they are mature and don't need (m)any updates anymore. But GPU computing/accelerators is a very fast moving domain and so much is happening in this domain, that it pretty much means if a project isn't updated for a year, it's probably dead. I'd love if thrust became really active though, the library and API seem really good! And I'd love it to be updated to C++14/17 :-)
OS can give options to customize rendering obviously, but it should be possible to have consistent size for your font. 12 in Windows should be highly similar to 12 in Linux. They can do their own stuff with AA and the like, but they better render the glyph before that consistently.
It isn't. The compiler is using those DLLs.
Before: `Some(True)` = `1 1`, `Some(False)` = `1 0`, `None` = `0`. After: `Some(True)` = `1`, `Some(False)` = `0`, `None` = `2`.
I looked at it when I needed gpu acceleration, but it didn't fit my needs particularly well so I just wrote my own cuda kernels instead.
I must say I agree: STL and Boost are both horrendous. No phrase is more appropriate here than [a camel is a horse designed by a committee](https://en.wiktionary.org/wiki/a_camel_is_a_horse_designed_by_a_committee).
Do you know about https://github.com/VcDevel/Vc ?
Yeah, a long time ago (decades) I asked Stroustrup to add properties to C++ where you can declare a member and assign getters and setters to it. The compiler would automatically use the getter on read and the setter on write. Borland C++ Builder has this and is used by VCL. MSVC has it as an extension. It's super useful. But Stroustrup responded that there were alternative ways to achieve the same thing. I tried to explain how useful it is, but since it's mostly syntactic sugar, I didn't get anywhere. 
A user flagged this post for astroturfed comments and I have to agree. Please refrain from such behavior in the future, and let your posts attract real comments. (In the unlikely event that these were somehow real comments, the guidance against astroturfing stands.)
&gt; why Windows has built-in case ignorance Why not? In English, case normally doesn't determine meaning - "apple", "Apple" and "APPLE" are all understood to refer to the same fruit. A common complaint about Unix has always been that you can have two different commands spelt identically except for the case, which a lot of people find confusing and error-prone. And again, it's not just Windows that chose case insensitivity. I wonder what you'd make of others that didn't even *preserve* the original case (including DOS, of course) or which didn't even have both uppercase and lowercase letters. My guess would be that the Unix (or Multics) developers either objected to the cost of implementing case-insensitivity or just left it out to start with and got locked into that accident. Whether that's right or wrong, the different case-sensitivity conventions are just history. I doubt there ever was one true convention. &gt; reserved directory names (con etc) I'm not a fan of that either, but given that Unix has "files" that aren't really files such as `/dev/null` (and is proud of that fact) the real issue is only that `con` isn't tied to a particular path and just floats around everywhere. Probably just history again. The very earliest versions of DOS didn't have a concept of folders or subdirectories. When they were added, I imagine there was a compatibility issue with old applications - they didn't know they were running in a subdirectory or even that subdirectories existed yet still expected `con` to work. &gt; Windows API. Everyone agrees it's absolute trash. When I first learned the Win16 API, I actually loved it. OK, it had its flaws, but segmented addressing on x86 wasn't Microsofts fault, C being C wasn't Microsofts fault, and the complexity was mainly because the Win16 API was a lot more powerful than the only other GUI API (the cut-down version of GEM on the Atari ST) I had used at the time. Of course back then, QT and GTK simply didn't exist, though X-Windows did. I first used X-Windows (used as in user, never programmer) shortly before Windows 95 was released. It was slow, ugly, and not very usable at a time when 16-bit Windows was, if not good, at least less bad. And that was running on much more expensive hardware than the PCs of the time, with huge high-resolution displays that ended up display less than Windows did on smaller screens because X really liked drawing everything huge. &gt; Why do we have HANDLE not void*? For one thing, you're not supposed to know or care that it happens to be implemented as a pointer. For another, in the early days, for reasons that weren't Microsofts fault, there were two different `void*` types and other complications (segmented addressing on 16-bit x86). For another, the Windows APIs actually predate *any* formal C standard - Windows dates from 1985, the first C standard was in 1989/1990. For `CONST` - well, although `const` was added to the C90 standard (it wasn't in K&amp;R C) some compilers had it before then, others didn't. And even after C90, a lot of C programmers ignored it at first, and adoption of the new standard took some time. That meant that in C, using `const` could cause big compatibility problems depending on which compiler and which third-party libraries etc. Using C++, `const` was much more accepted, to the point that some C programmers thought it was a C++-ism and rejected it pretty much just for that reason. I don't actually know which language got `const` first. So `CONST` was so that you didn't need to worry about compatibility issues with `const` - you could move source around and the API figured out whether `CONST` should mean `const` or not. Why is `CONST` still there now? I don't know, but I assume the usual back-compatibility, old code, old books and documentation. You can't completely trust even Petzold editions 4 and 5 now, but it's surprising how much still does work and how small the fixes are when they don't. So again, it's history. Languages have evolved, platforms have evolved, Microsoft itself hasn't advocated using the Windows API for a long time (even Windows Forms, the .NET API originally intended to replace the GUI parts of MFC and Win32, was replaced around a decade ago). I don't think GTK has even existed as long as Win32 has been obsolete. 
Same here. For general cases, it was nice to prototype with. But we had very specific matrix sizes so hand written kernels + cublas was more performant.
I know [pytorch](https://github.com/pytorch/pytorch) uses Thrust, though that's still more research-oriented than production I suppose.
Paging u/blelbach. 
I think they mean the problem is that vector&lt;T&gt; does it inconsistently (depending on T). It wouldn't be nearly as bad if you had a proxy_ref_vector&lt;T&gt; that does it for every T - even though it would still have your problem, it's at least consistent and we would learn that (as we did with iterators) 
I am imagining stuff like Qt, OpenCV, FFTW, and OpenImageIO all using some hypothetical shared vector math types from std::glm in a few years, and it almost makes me want to cry how much simpler some things could be.
Would love a detailed blog post on this whole topic. It sounds facinating. I've done the simple union with __128 and four floats and never even knew about the aliasing rules.
cool! Thats the sort of thing I was wondering. Pytorch is a big deal, I was really wondering what interesting projects used it. Thanks!
whos that? The guy at NVIDIA?
Most of the renderfarm servers I have ever had to manage in the VFX industry. Any graphics related web service running in the cloud on a VM with no access to hardware. Code that needs to interoperate with existing software rendering code. Test cases running on a CI server that doesn't have access to a GPU.
I just wish that both articles were up 2 months ago. Very good read!
All by itself? The probability of that is **orders of magnitude** smaller than you making some mistake. So you really should provide details of the proof for your claim :-) beyond "some dlls have strange date". Note this: when building, under windows, the compiler **does not care at all** about 3rd party binaries all by itself. It cares about their \*.lib files, and that is not shipped nor updated by the system. It cares about dlls only if you #import them, but if you do that, well, **you** do that. 
Indeed.
What do you mean by that?
Thanks for the tip. If you're interested in the details, here's the same bug [experienced by others and reported a year ago](https://social.msdn.microsoft.com/Forums/en-US/56046314-8bf2-4ddc-885e-f0a61528e5ff/project-always-out-of-date-because-system-dll-has-future-date?forum=visualstudiogeneral). 
Coroutines as the *default* would be better.
With image, you mean texture? ;) Seriously, wouldn't such servers benefit from dedicated GPUs that can accelerate such tasks?
You don't have to use the standard 2D library to plot scientific data. Web server visit statistics should be rendered on the client side to scale properly (try WebAssembly and WebGL). Same goes for online maps etc.
&gt; Still if the idea of shared crossplatform COM interface failed then I do not understand why to use that interface I was being ironic and pointed out the that people who have been accusing Microsoft of using "proprietary, incompatible standards" chose to "invent" something own and incompatible (dbus) instead of using DCE-RPC which had existed at the time. + dbus doesn't work in a distributed scenario so you DO need something like grpc on those platforms.
Not sure I understand what you're objecting to. You don't have to set a 3D perspective, after all …
Actually, the trend partially goes in the other direction as well. Vulkan and DX12 are closer to the hardware.
We already did something similar with in-house git servers and manual patches to the libraries (mainly fixing horribly outdated CMake files). I found it useful to have the same structure for each installed third party library. include/[osname] lib/&lt;osname&gt;/&lt;config&gt; &lt;libname&gt;-config.cmake license.md It allows us to use the same directory for Windows, Linux and FreeBSD development, when accessed over samba or directly in WSL. It also allows us to automatically consolidate all licenses into a single .md file and convert it to html for distribution.
I feel like I missed part of the coroutine train where they explain the motivation for coroutines. 
Yes, I use it in production as a safer way manage device vectors.
LoC is around 300,000. Right, I need to ask this in rtas issue tracker. I posted the issue here because I want to find someone who have experiences on both Eclipse CDT and rtags, so I can be sure I'm not setup something wrong. 
If you ever wrote async code using callbacks versus sync code, you probably noticed that the sync code is generally shorter and easier to read. However, because it blocks the thread you need to use other threads to do other work while the code is blocked. This works but means you need to do a lot of context switching. The async code can be a fair amount faster, but it looks ugly. With coroutines, you can have the best of both. You can write code which looks like the synchronous code but when combined with a thing like the io_service in boost asio allows you to get performance just like async code. Better yet, the presence of "co_await" in the code at all the places where it can (asynchronously!) pause makes it clearer how the code will run. This isn't the only thing though; if you ever wrote complex iterators to do something like iterate over a persistent keyvalue map on disk or over the network, where you have to internally do work like handling batches or filtering or simple transformations, it generally has a lot of boilerplate. In principle, a well-written generator class wrapper would let you just write one loop that reads all of the data and co_yields every element in sequence. This is generally simpler to write and now you can iterate over the generator instead to get the exact same effect. Coroutines allow you to do a bunch of things that currently require a fair amount of boilerplate to achieve, without most\* of the boilerplate. That's what I am personally looking forward to. \* You have to write boilerplate in the coroutine wrapper type but just like with manual memory management this can often be avoided just by using a library of standard types that handle this for you.
python, C#, ... have "properties", so this _is_ a thing. One advantage imo is that with properties you can feel safe to let go of having a private variable coupled with a setter and a getter, because "at some point in the future you might want to change/remove/... this variable but keep the api". With properties you can make the variable public, drastically reducing the load on your apis, and if the need should arise to modify/remove the variable you can keep your api intact by introducing a property in its stead. It's also easier to type `object.x = ...` :)
Hi, NVIDIA hired me in September to take over development of Thrust. For those of who don't know me, I'm a C++ committee member, and I do a lot of C++ community organizing (Boost/CppCon/C++Now). I'm also one of the authors of HPX, which has drawn ideas from Thrust over the years. I've spent my entire professional career working on open source software. Thrust is currently released as part of the CUDA toolkit. The version in CUDA 9.0 has a new CUDA backend which has some significant performance improvements over previous releases. Unfortunately, all of this great work has not made it to GitHub - yet. We're aware that this divergence is a problem, and confusing to users. As far as where Thrust is going, I can't get into details yet. I'm collaborating closely with Jared, one of the original authors, on future plans for Thrust. Rest assured, Thrust is no longer in maintenance mode. It's a part of CUDA, and NVIDIA now has a engineer dedicated to it. Thrust is an important part of CUDA C++ I'm wash on the #cuda channel on the C++ slack (there is a link in the sidebar) and on Freenode or OFTC IRC. You can also reach me on the Thrust Google group or via email (add @nvidia.com). Also I'm @blelbach on Twitter.
Using QtCreator on a multi-million line codebase. Everything is instantaneous, or very close to. So ymmv I guess.
See my other post. Thrust is being actively maintained (by me - I joined NVIDIA a few months ago) and is released with CUDA (the last release was in September 2017). The latest versions have not been pushed to GitHub; that's a problem that I'm working on right now. I think you'll get your wish of increased activity :)
MapD too. I have a big list of users on my work computer, but can't get to it now.
I have heard about it but never used it so restrain from commenting. Looks very extensive from what I quickly browsed from the link you provided.
What codebase/project/type of thing, if I may ask? I like to keep a list of who is using it.
Prototyping is one of the purposes of Thrust :)
I don't know what else I can squeeze out of the topic. The C++ standard is a bit too complicated for my brain to remember every nuance and detail so I have to compromise: I write code using idioms that I know will work. I try to avoid UB and if code I am not entirely certain that code I write won't work I try to use simpler way to state the same thing. Such article or blog post should be left to someone who has better way with words. I'd read it! =)
no idea what astroturfed comments are, but I just replied to one comment as the others were pretty much similar.
The fact that C++ does not explicitly allow unions to be used for bitcasting even for standard layout types is a huge deficiency of the language. I'd be _very_ surprised if it actually offers any benefit for optimizations, and in a lot of cases it actually leads to extremely clumsy code (as exemplified here) when not downright inefficient (having to trust the compiler to optimize out memcpys when appropriate is a hack, not a sane solution).
&gt; Unix has "files" that aren't really files such as `/dev/null` (and is proud of that fact) They are actually called streams. It's kind of an advantage when you can mix them with bash and create own devices. I much greater like the simplicity of `drwxrwxrwx` and single-rooted file system over Active Directory and complex Control Panel. Also, have you searched what happens when you fill all disk letters in Windows (No, there is no AA, AB like in Excel...)? And for case ignorance, I still don't get why you can't rename files with new name different only by case (try by yourself, change only letter(s) case and rename will be rejected). I understand know that most of the things were a compability concerns from the past. The lack of standards for sure complicated things. However I just can't understand why Excel can not open 2 files with the same name (from 2 different directories). They even had effrontery to make an error dialog specifically for this!
!remove
OP, A human moderator (u/blelbach) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7eya7u/join_the_battle_for_net_neutrality_it_will_die_in/dq8a810/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Sorry, but this is off topic.
Am I reading the explanation of `async_manual_reset_event` correctly in that any suspended coroutines will be sequentially executed on the thread that calls set()? Also, could you add some example code around your type to show how it would be used?
Am I reading the explanation of `async_manual_reset_event` correctly in that any suspended coroutines will be sequentially executed on the thread that calls set()? Also, could you add some example code around your type to show how it would be used?
The part I find most annoying about many examples you can find in the internet is that they don't demonstrate actual synchronous code. The just sequentially call asynchronous interface functions, but very few demonstrate how to actually perform multiple different things asynchronously.
I mentioned io_service from boost asio above. This is the thing which allows asio to do multiple async things in one thread. Normally, you will perform some async actions passing the io_service and a callback. The io_service runs in a loop which repeatedly waits for the first of many operations to complete and then calls the associated callback. The callback can perform more operations which set more callbacks, and once that callback returns, the io_service goes back to waiting. None of your code ever runs in parallel (unless you call the io_service.run() loop from multiple threads) but the async operations can all happen at once. Coroutines allow you to hide the callback stuff behind code that looks mostly synchronous, but everything essentially works the same way.
I am really surprised that C++ hasn't adopted C's restrict yet. Though that doesn't help with unions (Though C has rules about them too that I don't think C++ does).
 template &lt;class T&gt; using computed&lt;T&gt; = T; // why specialize &lt;T&gt; for T?, probably a mistake, there should not be "&lt;T&gt;" template&lt;&gt; using computed&lt;int&gt; = double; &gt; As of why this isn’t supported by C++, I’m not sure. Alias templates do not have instantiation rules like function and class specializations. They are replaced very early, which means they can not be specialized https://stackoverflow.com/questions/6622452/alias-template-specialisation
Someone please explain what is Redit, C-Ray and LAME. I don't know what was actually compiled.
How about CUB? I may have found a bug in CUB but haven't got any acknowledgement that the (mis)behavior that I found is really a bug. The Google groups no longer seems to be actively maintained. Isn't Thrust built on top of CUB BTW?
&gt; They are actually called streams. Actually no, `/dev/null` is called a device. And the reason I call it a "file" that isn't really a file is because the name `null` is an actual entry in the filesystem. Streams are different, though yes, you can certainly send a stream to or receive a stream from a suitable device just as you can a suitable file. Windows has streams too. So did DOS - though they were limited and severely clunky, because after all DOS was a toy operating system for toy systems, so the real question about why Unix-fans of the time were so desperate to call DOS a toy is why they cared. The answer being of course that at the time Unix was fragmented and failing, with those toy systems that Unix didn't support rapidly taking over the world, and it was easier for Unix fans to throw dirt than to sort out their own problems. Thank God for Linus Torvalds, who could fling dirt AND make things work, and was the hero the Unix world needed at the time (though he probably couldn't have done that any earlier anyway - Linux actually started as learning 32-bit x86, if he'd been learning 16-bit x86 then Linux would probably have ended up as a kind of LT-DOS - learning different hardware with different capabilities means the learning project goes in different directions. &gt; drwxrwxrwx and single-rooted file system over Active Directory and complex Control Panel The flags for files in DOS were much simpler than those in Unix (because DOS was a single-user toy operating system with no user accounts or permissions). The flags for files in Windows are different to those for Unix, not particularly better or worse. The complexity in Unix-alikes for managing permissions is, as in Windows, much more than just having the flags for files. And I'm currently using Linux Mint 18.2, which has it's own complex control panel, but of course you still have to use separate utilities or else Google for the command-line trickery - which is of course is also a lot like Windows, because those operating systems have been evolving to be more similar over time even though the reputations are a bit different. The thing is that operating systems for modern desktops and servers are complex because they are operating systems for modern desktops and servers. &gt; Also, have you searched what happens when you fill all disk letters in Windows So what? They're an ancient hang-over from CP/M, before folders even existed. You don't need them - you can mount a drive to a particular position in the filesystem, not so different from Unix. There's also a path syntax that uses the GUID of the volume. The only reason to still use drive letters is because they are familiar, convenient and still there. The only reason they're so hard to avoid is because everyone still expects them and uses them. &gt; However I just can't understand why Excel can not open 2 files with the same name (from 2 different directories) I wouldn't know. I haven't used Microsoft Office since the 2003 version. I don't recall ever having that happen then, though I certainly would have had copies of documents still with the same filename but in different folders. I assume you're going to carry on your quest to find everything you can to criticize about Microsoft. I've wasted more than enough time on this, so I'll just leave you with [this link](https://www.perl.com/pub/2000/12/advocacy.html) to an old blog post called "why I hate advocacy", written by a Perl advocate. I may as well mention that I've hated Perl longer than I've hated Microsoft (though these days I hate Microsoft more), but the sane thing to do when you hate something is definitely not to hoard a massive collection of grudges and vomit them out whenever you see someone failing to hate it as much as you do. 
Yep, restrict is in some sense is the other face of the coin: it serves as a hint to the compiler that pointers that may alias will not, whereas the union _in practice_ allows you to alias memory that normally would not. And yes, C has had explicit type-punning support via unions since C99 at least. I really don't understand why C++ does not, at least for standard layout types.
300k is not that big of a codebase (I'm currently on 3m LoC project codebase) and definitely not the size which would make dev tools crawl. Even though I am not using any of these tools (Eclipse CDT, rtags), I suspect that there must be something wrong with your setup. After all RTags is implemented in C++ (although I'm not sure about the quality of implementation) ... I'm working on a very similar tool but implemented in Python and it is definitely not that slow ... all operations like jumping to a definition, searching for references and alike are finished within a second(s).
Yes, Thrust's CUDA backend is built on top of CUB (which is another NV research project). CUB isn't a "part" of CUDA though; it's just an implementation detail. It's kinda within my sphere. Did you file a GitHub issue?
Erm ... No I did not. I did post on nvidia CUDA devtalk tho' https://devtalk.nvidia.com/default/topic/1026095/cuda-programming-and-performance/setting-begin-end-bit-parameters-in-cub-deviceradixsort-sortpairs (Check out the last sample code on the thread.)
Guys!!! I need to let you know, I've found the reason and "fixed" it, now rtags runs lighting fast!!! Okay, here the details. Since my project is huge, the rtags cache contains many subdirectories and files, and I realized that IO problem could be a severe bottleneck, given that rdm cpu consumption is so low. So I used /dev/shm (tmpfs) for rtags cache. Wow! Fast! Fast! Couldn't be happier~ :) Now it's totally comparable to Eclipse CDT~ Almost the same runtime!
Right. It turns out the issue is disk cache. I used tmpfs now, and it looks very smooth now.
Ah. Please file an issue on GitHub against thrust or cub. Devtalk is very high volume, and not everything posted there gets turned into a bug.
Making fake accounts, or asking your friends to, to simulate apparent support.
Hm. Connect page they linked to is dead. Still not enough info, still not believe you.
Good points! :-)
Can you clarify? Do you mean performing multiple things concurrenctly? Async and concurrency are two different things. "just sequentially call[ing] asynchronous interface functions" is the reason for async because it makes code look and feel synchronous and avoids splitting up functions into several callbacks. Awaiting does not involve concurrency (except by freeing the thread to do something else in the meanwhile).
Wow, this is amazing news! I'm thrilled :-) Hope to see the activity on GitHub soon! Amazing, good luck with all your efforts, and I'll have a close eye on thrust's GitHub :-)
I see. Unfortunately I can only guarantee I didn't do anything dodgy, but I can't control what other people do.
Yes, you are correct in that `async_manual_reset_event::set()` resumes each of the suspended coroutines sequentially before the call to `set()` returns. Each resumed coroutine will only execute until it hits the next suspend-point. If a waiting coroutine was going to do some long-running synchronous operation after awaiting the event then it may be beneficial to have that coroutine immediately suspend and schedule itself onto another thread to allow other waiters to be resumed and the caller of `.set()` to continue execution in a timely manner. &gt; Also, could you add some example code around your type to show how it would be used? I've added a simple usage example to the post. I hope that helps.
Great, thanks for the quick response.
Would you mind pointing me somewhere I can read about this? I've coded in C++ as a hobby for years and Im not following. Also, I couldn't find what bitcasting is. 
&gt; (except by freeing the thread to do something else in the meanwhile). And exactly that is the important part. If you don't have any other work that you can do with the thread in the mean time, asynchronous APIs don't give you any advantage over simple blocking APIs and there is no need for coroutines in the first place. So imho, a good coroutines example has to show actual asynchronous execution of multiple independent functions to a) make the example more realistic and b)motivate the whole asynchronous idea. Otherwise, people just compare it to the traditional blocking approach, which is even simpler. I had a similar problem back when everyone talked about `.then` (which unfortunately is still not standardized) and almost all examples only showed situations, where the semantics (and thread utilization) would have been exactly the same when all callbacks had just been merged into a single function that is executed on the main thread (or a single worker thread).
For the last couple of years, most of my free-time coding has been on the train commute using a reasonably sized tablet and a Bluetooth keyboard. I've been using Cloud9 (c9.io) as my IDE. 
No need to convince me - I'm aware of asio, both with and without coroutines. My point is that most examples fail to show coroutines in a context, where asynchronous execution is actually useful in the first place.
Bitcasting aka type-punning refers to the reinterpretation of a given bit pattern as if it were a different data type. For example, a 32-bit IEEE-754 compliant `float` type would represent the value `1.0f` as the value `0x3f800000`. One way to find this in C99 is: union { float f; int i; } val; val.f = 1.0f; printf("%d\n", val.i); In C++ accessing a union member after setting a _different_ union member, as above, is undefined behavior. I'm afraid I don't know any specific resources where you could read more about this aspect of programming though, maybe somebody else can chip in.
&gt; It also breaks itself; won't boot with NVMe SSD. Microsoft apparently forgot to add the NVMe driver in the OS update. Dafuq?
I'm not the one objecting to anything.
Most of my types have public members. It's actually rare I need a private member *and* adding direct accessors (getter) for it. Most of the time I add a getter, it's because accessing the getted value is not trivial and need other call or another private member's value.
That's also what I prefer, I'm not a fan of getters/setters that do nothing but access the variable. 
I don't see how would returned references preclude such optimizations in C++? In Rust you can also get reference from the option, i.e. you can convert `Option&lt;T&gt;` into `Option&lt;&amp;T&gt;`. Say you have `option&lt;bool&gt;` in C++, if `false` is represented by `0`, `true` by `1` then missing value can be represented by `2`. If there is a value then you can still get valid reference to `bool`. Am I missing something?
I seen get_x, getX, x() all used. Often depends on coding convention on rest of the project. Interesting that they choose to please everyone. :)
Could you please check again with the latest version on NPM (4.0.0)?
I'm exited for them even without any asynchronous things: `co_yield` makes iterators so much nicer! Instead of having to write a class, where the state is stored in member variables and have the `operator++` do the update, you can just write a loop and `co_yield` each item.
If you want to learn design patters you can check out https://www.goodreads.com/book/show/85009.Design_Patterns As for architecture I recommend looking at other people's code and showing your code to people. architecture is very specific to the type of code your writing and the purpose of the code. Their are also some books on architecture such as https://www.goodreads.com/book/show/4845.Code_Complete?from_search=true but I'm not a huge fan of this book. If you are into video games I recommend this book: https://www.goodreads.com/book/show/24316573-game-engine-architecture-second-edition?ac=1&amp;from_search=true
I personally like the [Game Programming Patterns](http://gameprogrammingpatterns.com/) book, you can read it for free on the website. Even though it says game programming, it is applicable to general programming, but instead of a list of products in a shopping cart the book will be about a list of enemies to be slayed. [Head First Design Patterns](http://shop.oreilly.com/product/9780596007126.do) is also a good book if you like examples, the examples in this book are in Java. The original Gang of Four book [Design Patterns](https://en.wikipedia.org/wiki/Design_Patterns) also includes examples (in c++), but fewer than the earlier mentioned books. 
I just asked this question out of idle curiosity as I was looking to tinker with something that would be fun and interesting and the feedback on this sub has been great. It's really great to hear from you and about the work your doing.
There's a dedicated Chess Programming wiki out there, I don't have the link handy, but give me a minute. I built a (non AI) chess game with a friend last year as a university project and have to say, move generation is A LOT more complex than anticipated, I'll give you a link to the GitHub page (It's in Java, which might be easier to understand if you don't know C++ already). 
Design Patterns is kind of required reading, more so than most other textbooks, it's up there with Algorithms.
Excellent article. For those who are asking "Why coroutines" -- I'd contribute this: 1. They make it easier to write and grok code that used to have either async state machines or callbacks. 2. Please don't use boost::asio as a supporting example. It's a layer of detail that is not necessary in order to understand the benefits of coroutines. 
Pm sent. Its control software for an imaging technique, basically msvc 2015, qt, cuda
**Yes**. There was already a link to the Markable library, however I think it is somewhat limited. I would personally attack the problem by identifying the *niche* values and then build on that: template &lt;typename&gt; struct niche_values; // Assumes that false is 0 and true is 255. template &lt;&gt; struct niche_values&lt;bool&gt; { constexpr static std::size_t nb_values() { return 254; } constexpr static bool is_niche(std::byte const* head, std::size_t size) { return *head != 0 &amp;&amp; *head != 255; } constexpr static std::size_t get_niche(std::byte const* head, std::size_t size) { return *head - 1; } constexpr static void set_niche(std::size_t value, std::byte* head, std::size_t size) { *head = value + 1; } } As a consumer, you can therefore: - determine whether a type has niche values which can be leveraged for shenanigans, - query whether the current value of a raw byte view is actually a niche value, - get/set the niche value. The nice thing is that this is *composable*. // Reserve one niche value in underlying T representation, if any. template &lt;typename T&gt; struct niche_values&lt;std::optional&lt;T&gt;&gt; { using nested = niche_values&lt;T&gt;; constexpr static std::size_t nb_values() { auto nb = nested::nb_values(); return nb &gt; 0 ? nb - 1: 0; } constexpr static bool is_niche(std::byte const* head, std::size_t size) { return nested::is_niche(head, size) &amp;&amp; nested::get_niche(head, size) &gt; 0; } constexpr static std::size_t get_niche(std::byte const* head, std::size_t size) { return nested::get_niche(head, size) - 1; } constexpr static void set_niche(std::size_t value, std::byte* head, std::size_t size) { nested::set_niche(value + 1, head, size); } } Now, when implementing `std::optional&lt;T&gt;` you can specialize the storage depending on whether the type you wrap has a niche value: template &lt;typename T, bool&gt; struct optional_storage { constexpr bool isValid() const { return mIsValid; } // ... std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type mRaw; bool mIsValid = false; }; template &lt;typename T&gt; struct optional_storage&lt;T, true&gt; { constexpr bool isValid() const { return !std::niche_values&lt;T&gt;::is_niche(&amp;mRaw, sizeof(mRaw)); } // ... std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type mRaw; }; template &lt;typename T&gt; class optional { // ... private: optional_storage&lt;T, (std::niche_values&lt;T&gt;::nb_values() &gt; 0)&gt; mStorage; }; 
Head first design patterns is pretty good once you get past the cheesy picture on the cover. I read it a long while before I learned C++ but I think it's pretty broadly applicable.
Thanks for the response will look in to those.
Just remember that design patterns should be used to describe your architecture rather than used to implement your architecture! A shared vocabulary, not words to force into everyday speech.
Oh that makes total sense now. I guess I just hadn't seen that word before. It seems like it should be allowed, I agree. Though I could see how it could help people write more error prone code. Its kind of like not using a type system at all.
[removed]
Thanks, but it's mostly other people's work. I just inherited it.
Seems kinda weird. Looks more like a band-aid than a solution. Tmpfs should be making no big difference as OS is already caching I/O for you automatically.
You may want to look at [stockfish](https://github.com/official-stockfish/Stockfish) which is one of the strongest chess programs and a surprisingly concise (about 7000 SLOC) open source C++ implementation.
If you aspire to be a code monkey then sure it is.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7f17bh/looking_to_make_chess_in_cpp_but_not_sure_where/dq8wpl6/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Does this technique is undefined behavior or not? It seems the inactive members of the union is indeed the same layout as the active one. Is it well formed?
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7f0sbx/how_can_i_learn_design_patterns/dq8wv85/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
In case you decide to read the Gang of Four book "Design Patterns", feel free to check out and play with the code from my repository at https://github.com/BartVandewoestyne/Design-Patterns-GoF
It's more of a way to temporarily and locally override the type system under very specific conditions. It's not unlike “safe” languages and their possibility to escape to unmanaged/unsafe when necessary/appropriate.
PCH files are basically memory dumps of the compiler. It's not what I would call a stellar design today, but they weren't designed today. Microsoft has had them a long, long time. Back when they were invented they were downright amazing. "Clang modules" are a far better PCH design. 
/u/ninereeds314, you're a bit too well-informed and rational to be on the Internet /s By the way, if there's anything I can do to help you hate Microsoft less, let me know. 
You understand that "hate" wasn't meant to be taken literally - after all, I started out arguing *against* unjust Microsoft-blame. Anyway, MSVC tools is entirely the wrong department for that. My top complaints about Microsoft are the usual Windows 10 and Windows Update things from the last few years. Because I was never really an IDE person, use LibreOffice and just generally don't use much Windows software any more, it was easy and pain-free to drop Windows when Microsoft started abusing the trust in Update, so that's what I (mostly) did. The final straw didn't need to be that big a deal because mostly I was drifting away from Windows anyway - choosing other things isn't an attack on Microsoft. I have given VS code a go. I don't think I'll stick with it, but I can see that it's technically excellent as usual. 
I've come up with something similar before that helps integrate clang-format into CMake, allowing for the following targets: * make format - format the whole project. * make format-check - check format of whole project and exit with error (for CI). * make format-changed - format only changed files in git. * make format-check-changed - check format of changed files in git and exit with error. The source and details are [here](https://github.com/ttroy50/cmake-examples/tree/master/04-static-analysis/clang-format)
I would also suggest using editors (Sublime, Visual Studio) that has clang-format plugins that enables format on save. 
No worries, I'm not offended. And I read he whole thread so I know where you're coming from. The offer stands. If there's anything I can do for you, do let me know. I know it's unlikely but no matter. 
Before windows vista in kernel mode using more than 12KB of stack was practically throwing dice to get a blue screen. 
Can this be configured to check only certain aspects (trailing whitespace, tabs vs space etc) but leave the rest of the formatting alone? I encounter a apprising amount of situations in day to day programming, where the result of clang format is less than ideal (in particular if you want to align things in consecutive lines).
Do you know which editors support live clang format? Like everytime you close a brace or insert a newline? While it is much less powerful, I prefer - by far - the integrated Autoformat capabilities of most editors that format my coffee while I wait to the offline pass of clang format.
And I've taken your /s on board and I see where you're coming from too (not my biggest mistake in this, but you're right).
Many embedded systems have lcd screens that could benefit from a standard but host optimized 2d display library. As long as it is free if you don't use it, I would be ok with that.
People are doing c++ on devices like atmega's and esp32/esp8266's that do not have a GPU. having a standard way could increase code quality.
&gt; in particular if you want to align things in consecutive lines You can switch clang-format off just for those lines. 
Aligning lines is a code smell anyway and have been forbidden in all places I've worked at.
The rtags db can get very big for big projects and it is comprised of many small files. If you repeat the slow query it completes instantly because the OS will have cached the relevant files. The OS can't predict which files tags is gonna use, though.
You've never have to type an OpenGL 4x4 matrix then.
I'd rather let clang-format deal with it and move on.
Have you tried?
&gt; Adoption takes time, yet the languages I referred to are used in very important products of high profile companies. I never disagreed about that. As I said I value OCaml a lot. I started learning how to program with it, and when we moved towards C, C++ and Java (in order for students to be employable that was and still is a necessity) I missed the type system, type inference, etc. (C++ has got auto now but still misses a lot). Anyway, those languages are good, but in the grand scheme of things they are not significant. Hopefully they will be in the future.
I think these examples will come with time. Once compiler vendors start shipping stable coroutines you'll probably see many examples of people using them. I don't think many people want to start using them in production code when the standard is still changing at every meeting.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7f40eu/if_i_have_a_class_vector3_with_the_expected/dq9dbp2/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I wonder what is the performance hit because you can't trivially test the value. Especially considering you aren't likely to care much about the size being 1 or 2 since it's unlikely you'd have so many it would matter. The case where it does matter is if you have like a large vector of `double` because going from 8 to 9 ends up doubling the memory you need because of alignment and you might actually have enough values so that the memory cost matters. Thankfully, we invented many years ago `NaN` that solves this issue.
IMO live clang format will take too much computing resources. I don't any editors that supports live clang format.
This has nothing to do with C++, take it somewhere else.
Well, you probably don't want it to be live both, because of potential performance issues and some possible confusion if the string will keep reformatting as you type. Qt Creator's plugin reformat your code on every file save, which I think is a reasonable compromise (if not advantage).
Like op I have been mainly developing in .Net for the last 4 years, but I am trying to improve my C++ skills too, it's a much more complex/cooler language :) comparing to .Net. Since I only have little experience in C++, it's quite challenging for me.
clang-format supports ranges for formatting, which should work perfectly fine for on the go formatting, but it won't be the entire file.
Cool stuff, Rust keep delivering.
Unrelated... I would **never** offer any tooling for crashes. He who gets stuff like SIGSEGV or SIGILL is **way** better served by a crash dump or a debugger (plus, of course, any logging/tracing they might already have).
&gt;requires C++17 (filesystem support) Oh, very modern. I wonder what the example code looks like... #define CR_HOST // required in the host only and before including cr.h #include "../cr.h" int main(int argc, char *argv[]) { // the host application should initalize a plugin with a context, a plugin cr_plugin ctx; // the full path to the live-reloadable application cr_plugin_load(ctx, "c:/path/to/build/game.dll"); // call the update function at any frequency matters to you, this will give the real application a chance to run while (!cr_plugin_update(ctx)) { // do anything you need to do on host side (ie. windowing and input stuff?) } // at the end do not forget to cleanup the plugin context cr_plugin_close(ctx); return 0; } Oh, my. No RAII. Using C-style library prefixes instead of namespaces. Using unscoped enums with C-style library prefixes. `void` pointers in user-facing types instead of using type erasure (if there was a performance reason for this, it wasn't indicated in the code with benchmarks to demonstrate it). There are also a lot of extern "C" functions. Is this serving as a dual-purpose interface for both languages? I won't pretend that I completely understand what all of the code is doing or how it would be used, but the library could definitely use some cleanup to bring it into the C++17 era.
Huh? It seems that you miss the point of all this: and the point is for quick iteration. The library is destined for **developers** to use during **development process**. It's basically a way to have a live-patching-like environment outside of Visual Studio.
I loved the conference as well and will definitely attend next year as well :)
If something crashes, I need to know what happened. A debugger or a crash dump gives me that. In development, it's exactly the debugger. If I my latest changes crash, there is 0 point in going back to a stable state, as that erases the crash information. And I have to tell you, you are **unbelievably** naive if you think that a module that encountered SIGSEGV (or something similar) can be safely unloaded, *in general*; if you think that, you do not know what "undefined behavior" means and what is the relation to SIGSEGV and similar.
The cult of RAII strikes again. If this works, why bother with stylistic changes?
That example code is C. The post title and GitHub description specify this is for hot reloading C. The library is implemented using C++.
I use Vim with [this](https://github.com/rhysd/vim-clang-format) plugin which works well. You could probably set up an autocmd to format the buffer on write but I just bind it to a shortcut (C-i when not in visual mode reformats the whole buffer, C-i in visual mode reformats the selection).
&gt; No RAII You're saying it like it's a bad thing. Disregarding the fact that the API is in C I still wouldn't find a problem if this was also done in C++ because if it doesn't throw anything then that means that us who don't appreciate exceptions can also use it. Not every feature of the language is a blessing and they tend to stick together.
You should add a `_guid` literal operator.
To be fair, RAII protects from more than just exceptions. res = acquire_resource(); err = do_thing_1(); if (err) { release_resource(res); return ERR_THING_1; } err = do_thing_2(); if (err) { release_resource(res); return ERR_THING_2; } release_resource(res); You have to make sure you release resources before every `return`. Often times in C, this is done with `goto` to avoid code duplication but even that is limited. It's a source of bugs and RAII is a nice and clean solution to this class of problems.
I'm not arguing against the actual good use cases of RAII. It's essentially a necessity for exception safe code like in your example. But if you're not using exceptions at all because of any valid reason I find that RAII can make a programs design cumbersome because at that point your essentially modelling your program after something that might not even be solving the problems you have. Or as you might put it; some of us are actually just using C++ as C with cherry picked features.
This is very high on my wish list for C++ features. I'm really hoping some version of this gets added in the relatively near future.
At least MSVC does not allow constexpr user-defined literals. I did not check with other compilers, though.
That's incorrect, which you can verify by attempting to use constexpr chrono and complex literals.
I think you're missing my point - RAII is still useless with exceptions turned off. If you forget to release all the right resources before each `return` statement, then you are leaking. This becomes a non-issue with RAII. Let me give a more elaborate example. A* a = create_a(); if (a == nullptr) { return ERR; } B* b = create_b(); if (b == nullptr) { destroy_a(a); return ERR; } C* c = create_c(); if (c == nullptr) { destroy_a(a); // very easy to miss a line like this destroy_b(b); return ERR; } destroy_a(a); destroy_b(b); destroy_c(c); Notice how the `destroy`s accumlate and you have to remember to`destroy` the right ones at the right time. unique_ptr&lt;A&gt; a = create_a(); if (a == nullptr) return ERR; unique_ptr&lt;B&gt; b = create_b(); if (b == nullptr) return ERR; unique_ptr&lt;C&gt; c = create_c(); if (c == nullptr) return ERR; Both of these blocks don't use exceptions. But the second block uses RAII. I prefer the second block.
That is interesting, can you elaborate, why this is a code smell? Typical example that comes to mind in addition to matrices would e.g. be writing all the [c][r]begin/end member functions with all the correct const, constexpr, noexcept ... boilerplate. I find that much more readable if each function gets one line and all parts (constexpr, return type, name ...) are aligned. Overloaded operators (+,-,*,&lt;,==,...) are a similar example, although this is usually not a problem, as all those functions declarations have same length. Or what about small switch statements?
Yes, indeed. It might be my memory from the first failed attempts to implement constexpr GUID parsing (or was it before 15.3?), but now it works in VS 2017 15.4. I will update the code to add a UDL in a while. Thank you, STL, for pointing that out.
Live reformatting is a standard feature of every IDE I know: I type a line, hit enter and it will reformat it. I close a brace and it will reformat the block. I never found that to be confusing or slow (although clang format does much more than the typical IDE feature of course). The question of whether live formatting is desirable or not aside, format on save also has the disadvantage of re-formatting the whole file, which potential introduces a lot of noise.
To be fair, I think that the more reasonable way to write the non-RAII version of your example would be: A* a = create_a(); if (a) { B* b = create_b(); if (b) { C* c = create_c(); if (c) { destroy_c(c); return SUCCESS; } destroy_b(b); } destroy_a(a); } return ERR;
You're welcome! Our constexpr implementation initially had a large number of bugs and limitations, which you probably encountered. The bugs are still being fixed, but it's much better now.
not that you're wrong but in fairness those aren't user defined
Cool- so that’s one CppCon Talk off the list I don’t need to watch then 😜. 
from a 150+ talks list... thats a start :D
Exactly!
I have no shame so I would have solved this differently. Created fake container that captures reference to legacyRepository and has a forwarding method called push_back or insert. Method just forwards the argument to addInRepository where second argument is the member reference to legacyRepository and the first argument is the argument to push_back/insert. Then you could just use std::(back_)inserter on that fake container.
As a side note I think if you wanted to show off and not use for each loop or std::for_each with a simple lambda you could have used std::for_each with std::bind where you bind the second argument of the free function to the legacyRepository. I know std::bind sucks but I think in this case you would not hit any of the problems with it. 
The Standard Library is a user as far as the compiler is concerned.
I had that setup too, but the problem I had was that you have to be sure that the version of clang-format that your editor uses is the same as your CI. In my case, we do all development in a docker container so the version of clang I have locally on my laptop is different to the one in our dev containers. Because of this using the editor plugin causes incorrect formatting. I really wish they had added backwards compatibility in clang-format
What your describing is about line breaks though, not aligning using whitespace? I too prefer lots of line breaks in complex statements, but I only indent them and don't bother trying align.
Yes this means autoformatting by the CI is a no-go. It would create an incredible amount of git noise as formatting slightly changes as clang is upgraded.
What part of a SIGSEGV involves undefined behavior? It's just a signal, you can handle it like any other
The challenge I have found with writing good async examples is that they tend to have a lot of moving parts in order to be both functional and meaningful (ie. showing the benefits of async) which can make them overly long. Often, the point an example is trying to demonstrate is about some sub-problem of the async space and so giving a real-world but overly long example can often obscure that point. Perhaps writing shorter examples will be easier once the abstraction level that people are working at is a bit higher? Having said that, I do agree there needs to be more examples that actually show the higher-level, running multiple things concurrently, real-world benefits of coroutines and async programming. This is something I hope to address in future posts.
Where did you get that impression from? No, it is not about line breaks but alignment and it is not about complex code, but about lots of trivial, repetitive, statements.
It's totally fine to write code in any style that you like, but the sample code you include above isn't really a good example of keeping a function "minimal". Note that this doesn't make your code 'bad' per se, it's just extra work and maintenance. You don't need all that code unless you just want to avoid using the std library for some reason - and you may have a totally valid reason, but that reason is not clear from what you've written above. Using RAII actually allows you to write less code; sometimes dramatically less. RAII is also a great way to shift a lot of the monotonous book-keeping to the compiler/machine. And honestly, isn't that where it belongs?
Unreadable mess.
So I don't always agree with all the things that any group of language enthusiasts says is the 'right' way to do things, but I really don't understand what you mean by 'cult of RAII'. I'm totally open to hearing a valid critique of RAII, but I guess I'm just not sure what that would look like. &lt;&lt; why bother with stylistic changes For reduced maintenance burden? That's a pretty good reason for me!
&gt; The rtags db can get very big for big projects and it is comprised of many small files 300k is _not_ a big project :) Also, 20min to index a 300k project sounds a bit too much to me but I guess I will have to try RTags myself. &gt; If you repeat the slow query it completes instantly because the OS will have cached the relevant files. The OS can't predict which files tags is gonna use, though. What I meant by I/O caching is that R/W operation issued directly to the hard disk is not going to be much slower than if the same is done with tmpfs. Or it is not going to be slower at all: the difference will be negligible.
Please provide a few code examples so we're on the same page, and I'll show my version without alignment.
Because "don't forget to clean up your resources in all possible code paths" _is a stupid idea._ 
&gt; But they are too tied to exceptions imo. The code in the comment you are answering does not use exceptions. I suggest reading the comment thoroughly before answering.
That's horrible - particularly if you have a lot of resources.
Say, what?! From the original link: &gt; requires C++17 (filesystem support); So you are required to be compiling with a C++17 compiler to use this library.
Pretty damn clever! Bonus: the code is super easy-to-read and understand.
The argument as I understood it was &gt; Even without exceptions it's still good And with my reply (the part you quoted) I actually meant &gt; Yeah, I see your point but I don't think that good part negates the bad part from my point of view which are the exceptions.
Don't you leak a and b on success here ? IMO that's the main purpose of RAII (beside exceptions). You *can't* forget or mess up the clean up. And don't tell me that it's not relevant because you're not supposed to do mistakes in the first place, that happens all the time to everyone. 
**What?!** You have no idea **why**, in practice, you get a SIGSEGV, do you? I suggest to pick up a book. To make it shirt: in practice , you get it because the code tried to read memory off an address that is not mapped to the process address space. In other words, it tried to read something it has no knowledge of. Prey tell, what do you think can be the behavior had the code actually succeeded doing so? Then, note that, in practice, the code may have already read or written memory that is mapped in the address space, but is not allocated by the program. By the time code gets a sigsegv, it may already completely destroyed itself. So yes, you can register a signal handler and "handle" it. But the nature of the signal is such that **no reasoning about the state of the program is possible". (To be fair, there are situations where asignal is "clean", that is, no actual damage has been done, yet, e.g. dereferencing NULL).
In most situations where a SIGSEGV is involved, it's a **possible** outcome of some undefined behavior. You have no guarantee that the signal will be sent, anything can happen. 
I absolutely agree with you. It's less code and less stuff to think about - which is great. I'm totally on board with that. My point was that it's just a tool. It has it's uses just like with the rest of the entire C++ language. And imo just because you aren't using RAII (like in the API above) doesn't mean that suddenly that API is badly designed. It might be sometimes, but not always. And to be fair this community has a tendency to follow this train of thought: &gt; Either no RAII &gt; or no exceptions &gt; or no STL &gt; total garbage Which is just dogma if you ask me.
I've been using similar [crash protection in Runtime Compiled C++](http://runtimecompiledcplusplus.blogspot.co.uk/2011/09/crash-protection.html) (old blog post &amp; video linked, latest code is xplatf). The intended use is for during development, when a code change could easily cause a crash and this gives you the opportunity to both inspect the state of the application at the point of error with a debugger and fix and re-run with the same data. It's rare that this fails to work well and assist development.
Haha, yeah. You need two additional cleanups in the success case. Then again I'm writing on my phone so I'm having some issue seeing the entire thing on a small screen. :) Absolutely, mistakes happen constantly and RAII is a great tool, I've mentioned that several times. The main point here was supposed to be that just because the API isn't using it doesn't mean that it's a bad API.
Exposing a C interface is a great way to increase the usefulness of a project even if the project internals are written in modern C++ - people choose to program in C not because they don't have a compiler capable of compiling C++17 but because they want to program in C. In addition the C interface can be easily used in C++, and if you feel you need to add a wrapper to get RAII then that's fairly straight forward. The author stated the reason C++17 was used: to get filesystem support. My own implementation for [Runtime Compiled C++](https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus) would add about 1/4 to the length of the header if written in the same style and I'm looking forwards to eventually being able to remove it.
If you run hot-reloading with a debugger, you can make the debugger break where your program crashed, so you can inspect the code/state and correct it for the next iteration.
I used vcpkg once to get boost, only irritating thing was that boost did not get the boost 64 bit version. Quite irritating. Had to get also boost-64 or something like that. Not hard, but confusing.
&gt; I won't pretend that I completely understand what all of the code is doing or how it would be used, but the library could definitely use some cleanup Your attitude is toxic poison to the community. Productive people are sharing stuff and you are nitpicking on stylistic stuff that are unrelated. For the love of programming and manking, stop doing that. This is what makes everyone miserable and sad, this is what makes competent people who actually knows their shit not share stuff on the internet. 
you define `constexpr auto base = N == 39 ? 1 : 0;` on line 68 and then don't use it on line 73. You should actually get rid of line 68, whose place should be after the throw, where you can better see it's useless.
&gt;Your attitude is toxic poison to the community. Holy shit what a fucking overreaction. &gt;this is what makes competent people who actually knows their shit not share stuff on the internet. I'm pretty sure anyone who knows their shit isn't going to stop sharing stuff on the internet because someone said that `void` pointers aren't the best idea.
`s/memcpy/memcmp/` in the `Smart lookup` part.
&gt; people choose to program in C not because they don't have a compiler capable of compiling C++17 but because they want to program in C Also, a C interface makes a library easier to use with many other languages' FFIs.
Nice article! And particularly nice code. After some bad experiences I'm skeptical about lock-free thread-safe structures, but having readable, clear code makes auditing the code for correctness much easier, and more, convinces me that the writer was able to understand their own code. --- This one line in `shared_double_reference_guide` puzzles me: data_ptr_struct new_data_ptr{ , nullptr }; Is this even legal? --- Pedantic quibble - it's a _thread-safe_, lock-free, wait-free hashmap. `std::unordered_map` is a lock-free, wait-free hash map - it just isn't thread-safe.
Aha, yes. Thanks!
`const std::array&lt;std::string, 8&gt; `. Why the string is not const? `const std::array&lt;const std::string, 8&gt; ` or string view if possible.
This kind of please-use-this-and-that pedantic derailing is hostile behavior. If as a community we don't recognize it, we'll keep turning people off programming. I only found this thread because it was being linked to with a "C++ communities are hostile to devs" comment. 
It's not hostile behavior (the tone might have been but that's besides the point), for people who are actually willing to learn it's great to be told how certain things are done properly so that they don't repeat their mistakes without even knowing what they're doing is wrong. [Look at this other thread in /r/programming about someone elses C++ library and their responses.](https://www.reddit.com/r/programming/comments/7ez480/my_first_c_library_small_engine_to_print_to/) The OP seems to appreciate all the """please-use-this-and-that pedantic derailing""" and that's great. Do you seriously think it'd be good if every new C++ programmer was never told to use `std::vector` and to continued spam raw C style arrays with thoughtless `MAX_SIZE` `#define`s all over the place just because it "turns interesting people off programming"?
Yes, you are right. It is a leftover after a small refactoring after adding UDL.
Debugger will break there without hot reloading. State inspection needs to be done without hot reloading. The problem I have is: he who gets SIGSEGV or some such, cannot have any confidence whatsoever that anything at all will work, **including unloading the (apparently[1]) offending module**. Trying to do anything after SIGSEV (or worse yet, SIGILL) is a fools errand. Or at best, a crutch for people not competent enough to use a debugger or a crash dump. [1] Nature of UB is such that a crash in one place does not mean that the *problem* is in that place.
Thanks, this looks very interesting! One question why it is for C and not for C++ ? I did not look deep at the code for now but I did some hot reloading test in the past and it worked with C++ of course with some limitations. 
Forgive the ignorance, but what difference does that make? arr[0].clear; Would fail either way because arr is const and the const version of operator [] returns a const &amp;. Right?
Your code leaks 'b' and 'a', and by the time you get that right, it will be pretty darn ugly. That ugliness is why people use 'goto'.
&gt; your code doesn't look like how I think good code should look Well... It's rather "your code doesn't look like how *most* think good code should look". The discrepancy between "C++17" and the style is indeed massive. The actual tone of the poster is not particularly hostile, I should think. So 'toxic' is more harsh than his tone.
&gt; Live reformatting is a standard feature of every IDE I know: I type a line, hit enter and it will reformat it. I close a brace and it will reformat the block. I never found that to be confusing or slow (although clang format does much more than the typical IDE feature of course). That'd be true if clang-format dealt only in indentation + bracket placement (that's already done by pretty much every decent IDE). There are way more features in clang-format than that. Some are a bit more than simple code reformatting, like adding comments to namespaces or restructuring includes. Also, I think some one them would be pretty hard to do, if some entity isn't completely typed out yet. Though it doesn't really mean that live clang-format is impossible. It'll probably happen sooner or later (I saw some discussions on qtc mailing list), it's just not very straight-forward. &gt;format on save also has the disadvantage of re-formatting the whole file, which potential introduces a lot of noise. Noise where? In the end, you'll get the same file regardless of how frequently clang-format was run. There could be some CVS history noise if clang format is applied to a big project that didn't closely follow any codestyle, but that's irrelevant to what is discussed here. 
Strings are constructed differently, compilers have tons of optimizations. For example, a `const` string may have removed member pointer of the reserved memory.
Maybe try a more supportive subreddit like /r/learncpp
 r/cpp_questions
That’s not the point, OP posted a library, and because he stated that it needs a C++17 compiler people are suggesting he should use more C++17 idioms and features. It’s off topic. The guy isn’t asking for advices, he posted a library that is useful for some and the library suggest he’s not a newbie programmer. I’ve seen people very patiently and politely fend off C++ trolls (that’s what I think those answers are, honnestly) and then in private state they are tired by the attitude and won’t post anymore. (PS: ihmo people should be taught about std::vector just as well as they should be taught about C arrays, there’s no one solution to all problems. Game developers deal with performances requirements that makes most of modern C++ impracticable.)
It is _style_ you said it. There are many ways to program and just because you think “most” (= most like minded people in your internet vicinity) agree with your style you shouldn’t push it down the throat of everyone who didn’t ask and clearly aren’t a newbie. Any software that compiles in a C++17 compiler is C++17. I can be using printf() and it is still C++17. Stop enforcing your truth to everyone please.
Fine. This library is an interesting curiosity, but I would not allow it anywhere near my codebase. Is that better?
That’s not where he posted! 
That’s better yes. Although probably better just keeping that thought to yourself. I don’t comment on every thread stating I don’t care/need/like a software. It’s unfortunate that C++ coding style are so fragmented. My multi-billion industry programs very differently from what StackOverflow or Reddit suggests people should program, and newcomers in the industry are often struggling to unlearn the bad habits they got from the internet..
I know this is a C++ subreddit, so I will give you a discount. But I think you're missing the point. The only one reason why this is not pure C is exactly because of C++17 filesystem support. I thank C++ for finally being able to ship it, but at the same time I'm very frustrated with it since they dropped this in C++11 and then again in C++14. And that is not modern, it is practical.
Ah, yes. Perhaps you can teach us more about how your multi-billion industry programs. 
If you don't know, the debugger will break anyway. You can inspect, do your magic and let it continue. Fix your code and go on. This is the reason why this exist. Yes, it can cause problems or not, in my experience and using it in practice it is so rare that it pays of its existence. Thank you, have a good day!
&gt; people choose to program in C not because they don't have a compiler capable of compiling C++17 but because they want to program in C. C++ community should stop catering to people who want to program in C. 
This should really be 1 instead of -1? void release_ref() { if (internal_counter.fetch_add(1) == -1) destroy(); } 
For my part (since you replied to my comment) I make liberally licensed code for people to use; I don't care if they use it in C++ or any other language. Additionally some of the most prevalent open source code around is written in C, all usable by C++ programmers so returning the favour should be seen as a good thing. 
Basically because there is already RCC++ and all my new hobby projects are mostly C (or kind of orthodox c++). This works with C++, you just have to expect some trouble with destructors, cables changing, etc. So if this becomes an issue, RCC++ is the real solution. :) Thank you!
I don't think that this would be legal since I guess the assertion `sizeof(T) == sizeof(const T)` must always hold.
Jesus, this is a community for C++ users, newbies and experts alike. Not for delicate snowflakes like you
That last point is very stupid. I worked in game dev and all these "oh no, I can't use feature X from the STL because hurr durr" are almost all bull shit. It's just because one idiot heard it from another one, and keeps on repeating it to others. It is very much possible to correctly use the STL in game dev. And in the last team I worked in, we did. Just as much as exceptions are NOT A PROBLEM in game dev, they are actually zero-cost-unless-thrown in modern implementations. The only thing that is actually bad is RTTI.
Probably game "devs" that are still stuck in their old ways of "Everything in C++ is bad for game dev other than the C"
You do realize that you're leaking `a` and `b` when you `return SUCCESS;` right? Also your example isn't equivalent at all. You're calling destroy when it's successful and this approach doesn't let you use different error codes for each failure.
A bit late to the party, but I tried to make a attempt using SIMD: https://godbolt.org/g/xkJa6D. It wont beat the indexed version, but its probably comparable to the other proposals.
As I see it, the longer C++ community supports interfacing with C, the longer time it will take for people to abandon C because... "hey, it's a cool useful project written in C++, but I can still use it because it exposes a C interface". &gt; returning the favour should be seen as a good thing. Favor? C++ is designed to be backwards-compatible with C and has many warts because of it. If people using C don't want their code to be used in C++, they should choose another language. On the other hand, *not* enabling people to use C++ code in C is a good thing because it will, IMO, push people to consider writing their project in C++. [If it's some kind of a killer library/framework.] 
LOL my "vtables" changing became "cables" changing due to mobile auto correct and it still looks like something that C++ would do, like noose dragons or something. 
Note to self: /u/STL is just another user. We can stop prioritizing his bugs. 
&gt;let it continue &gt;&gt; The problem I have is: he who gets SIGSEGV or some such, cannot have any confidence whatsoever that anything at all will work... Do you understand why that is? (I believe you do not).
I didn’t say STL was unusable. I said you can’t and shouldn’t rely on latest/modern C++ features because they aren’t supported by all platforms you are targetting. 
Gotebe you can also get a SIGSEGV for reading something you don't have permissions for. There were some old user level software mechanisms that relied on SIGSEGV to load distributed data (which is similar to how the kernel memory managment works). I suggest you to look for Software Distributed Shared Memory (although it is not used any more).
Great, let’s harass people with offtopic pedantic stylistic commentary everytime they have something to offer, this is surely a way to build a great community! Enjoy!
Yes. And I believe you're not understanding why this is useful and this is not an issue at all. Try to understand the context where live reload is useful. Also try to be a bit flexible, it will be healthier to you. Thank you and have a good day.
Well that’s not the case. But some of the things are bad and newcomers to programming have a tendency to see silver bullets everywhere and adopt technology and complex ideas (because it is motivating/exciting) while losing track of the end product and the people behind it. 
Awesome!
Read the hate, but got bored and read the post. Actually not quite bad, although like some people said from description of the problem it is not clear to me if you can cut the relationship between instances. Also since you are FP fan and it is popular in C++ I understand the free function choice, but IMHO I think making everything OOP may be better in this case. Although I guess there is a lot of hate for OOP in r/cpp.
I think you again miss the point that sometimes it *is* fine to continue like this. I made my own implementation for my game engine, so that I can hack on the code and see the changes (almost real time). It is a great tool for reducing iteration times, but of course it has limitations (you'll not recover from every crash), and I wouldn't do it in a live system. But again, the downsides in my particular scenario (and I am guessing for other people using these techniques) are small compared to the advantages. (btw: I think you could make your point without the ad hominem too.)
I don't hate RAII as a concept, I don't like the implementation of it through destructor. Because it is an intrusive language feature, it encourage you to code in a certain OOP style with object lifetime tied to scope, it puts limitation on how you design your data structures. Sometime when C++ people criticizing lack of RAII they are really saying they don't like the way procedure C code looks. If all I want is ensure some cleanup code happen no matter what, something like *scope_exit(code)* is cleaner way to do it.
Acting as if C++ only libraries have a hope at killing C. C, for better or worse, is not going to die any time soon. Same with CPP
Explain why you can't have any confidence in reloading? You say you do understand, let's see what you think? I know why trying to continue after an UB is bad, do you?
I don't think anyone is discussing that old software. I certainly am not. **By a long far**, the most often seen reason to get SIGSEGV, is UB. There is hardly ever a point in continuing when that happens. Even if it's a clean one, e.g. dereferencing NULL, because I can't dereference it, and I can hardly magically materialize data when there is none. SIGILL is even worse. Once I get one SIGILL, what follows is garbage, too and modifying CPU state to go elsewhere is fraught with danger, too.
Oh my. Seriously. The most simple example would be a memory corruption somewhere else causing another unrelated code be executing an illegal instruction our whatever, at the moment the crash is handler is activated, anything following its execution may be in an unknown state like invalid memory or anything and may cause more issues, and so on. But In practice in the real life when doing real things instead bitching on the internet, things are not that problematic. Do you know what happens? the reload fails! and the application crashes. So what? Relaunch, and continue with your live. This is a development tool, and instead needing to rebuild and relaunch and get back at the point where I want to tweak, like something to be placed at an exact pixel position, I don't need do this because live reloading I will see my code changes, well, LIVE. And each time I avoided re-executing and getting back to the place where I need is avoided and is time spent fixing details that matter. If the crashing handling fails to deal for some unlucky alignment of planets, so be it, what is the deal with it? In the real life, in practice, 95% of the time (in DEBUG) this just works without ANY issues! Everything else is or theoretical or insignificant for anybody trying to achieve something. I know what is to do a real application is, do you? 
The commenter below disagrees with you, do you have a proof?
It wouldn't really take much resources IMO. You can just set it up to format whenever you type '}' or ';', and maybe some other keys. This is what Visual Studio does...
https://stackoverflow.com/questions/27466642/what-kind-of-optimization-does-const-offer-in-c-c-if-any Although `const` is more about compile-time conformance rather optimizartions. It isn't as strong as SOO or EBO.
Can you point exactly where on that page there is a talk about that std::string optimization?
&gt; I would blame `memcmp`. I heard, with better compilers and better standard library implementation it might get properly inlined and optimized contextually, but with my GCC it only gets called twice which is, in such a tight piece of code, simply too expensive. The length is fixed so it just becomes two simple reads. If you make that 9 into an 8 with a small bit of optimisation (as I showed [elsewhere](https://www.reddit.com/r/programming/comments/7e9ty4/challenge_your_performance_intuition_with_c_magic/dq4drer/) and is similar to other people's) it turns into a single 64 bit load. Seriously, though, you need better benchmarks. You're still iterating in order. "Shifts vs. no shifts" still has the confounder with the condition changed. You're causing UB. You'll learn much more from measuring the right thing than you will by prodding the wrong thing more frequently. 
Didn't you guys argue that this feature is useful to hot reload and thereby "patch" the stuff? Because you just said "reload fails and the app crashes". My wife says two lines suffice here :-).
&gt; I would blame `memcmp`. I heard, with better compilers and better standard library implementation it might get properly inlined and optimized contextually, but with my GCC it only gets called twice which is, in such a tight piece of code, simply too expensive. The length is fixed so it should just become two simple reads. It does on Godbolt, maybe your compiler is just too old or something. If you make that 9 into an 8 with a small bit of optimisation (as I showed [elsewhere](https://www.reddit.com/r/programming/comments/7e9ty4/challenge_your_performance_intuition_with_c_magic/dq4drer/) and is similar to other people's) it turns into a single 64 bit load. Seriously, though, you need better benchmarks. You're still iterating in order. "Shifts vs. no shifts" still has the confounder with the condition changed. You're causing UB. You'll learn much more from measuring the right thing than you will by prodding the wrong thing more frequently. 
95% of the time it works. One line suffice here.
How do you plan to use a header-only C++ library with C? This is the part that I found most confusing. The library appears to be intended to for usage in C, but is written in C++. These things will not work together unless a linker is involved.
It's not about the fascia, it's about the function. Not utilizing RAII in C++ is not writing C++. If you don't need the features C++ offers, then another language may be a better fit. This is a header-only C++17 library, so it cannot be used from within C. This compounds my confusion about the author's choice of implementation.
&gt;Exposing a C interface is a great way to increase the usefulness of a project I agree, but this is a header-only library using C++17 features. It cannot be used from within C. This was the root of my confusion which I didn't articulate very well.
I just haved it as a possible example. Haven't really searched for it.
It looks like the header can be included from C, to define a few macros and C functions. You compile your C application as a dynamic library. You also compile a main C++ host executable which loads and runs the C library. The C++ part is only for the main executable, guarded by `#ifdef __cplusplus`.
do you remember the "retry" button when there was a crash on windows 3.1 ? it just skipped instructions until it started working ; I remember MS guys saying that this wa
In retrospect, I see that I didn't articulate the root of my concern. The project is a header-only C++17 library, so it has to be used from within C++ (specifically, it cannot be used from within C). As a C++ programmer who is using your library, I anticipate that the provided types utilize the essential features of the language (e.g., RAII) and don't pollute the global namespace (e.g., unscoped enums outside of a namespace). This is why I decided to post. I apologize for the lack of clarity.
Great article, but I would have loved to see a formal proof on why this datastructure is actually thread safe.
I’ve been wondering about that myself...could someone elaborate as to how that works?
By defining CR_HOST, as in the example code, you get the C++ part of the library. This means that the example code is C++, but doesn't use any C++ features. For the client code that doesn't define CR_HOST, you just get two macros that control the linkage via CR_EXPORT. The only place I found where __cplusplus was used (unless my browser's search feature isn't working correctly), is inside of the `#ifndef CR_HOST` preprocessor branch where there is no explicit C++ code.
&gt; CR_HOST Yes it can on the guest implementation by just no having the CR_HOST define, so in practice. It is C by default and C++ to implement the host (a thin app).
Read the doc, read the code and read the sample basic_guest.C. You may understand.
CR_HOST itself gate all C++ only code. So if you don't define it you get a C header to use in a C application. In the README, check the second part where it says: &gt; While the guest (real application), would be like: That is for the "real application" part, and that can be 100% C without issues, and be generated by a C compiler (C11). It is not hard if you know a bit C or C++.
I see it can be confusing, my fault. But people should try to read and understand how and why.
The software is just an example of a legitimate use of an asynchronous signal. SIGILL is used by some tools as a way of using software traps for hardware simulation or emulation. This is not a particularly production platform, but it is indeed a common use case in some fields.
I think there are 2 issues at play: - some people can't let go of doing things manually, even if it's impossible to refactor automatically cleanly afterwards - sometime, you do need to align stuff, the 4x4 OpenGL matrix is a good example When you need manual formatting, I resort to 2 methods: 1. use comments to force-break some statements float m33[] = { 1.0f, 0.0f, 0.0f, // 0.0f, 1.0f, 0.0f, // 0.0f, 0.0f, 1.0f, // }; I suspect these comments could look weird to some people when they aren't aware, but this is my favorite method as it still let clang-format do its thing. 2. turn off formatting // clang-format off float m33[] = { 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, }; // clang-format on I'd like this method to be less verboses, I like yapf for Python, which provides a way to disable formatting for a statement: - https://github.com/google/yapf#why-does-yapf-destroy-my-awesome-formatting IMHO, if you accept to let go of manually formatting things, you open the door to other automated tool in the future. For example, refactoring with clang-tidy, could reformat your code properly and you will have a consistent codebase. If you manually aligned all your functions in your project, and you run a refactoring tool which replace an argument type to many functions, then it will take a huge amount of time to just reformat everything. You usually have 2 options: 1. reformat everything manually, slow and painful 2. don't refactor automatically Anyway, I think it's difficult to change people's mentality on the matter, and a middle ground is to warn about suspicious formatting, only for the line you changed. For example locally with git-clang-format, you can ignore the places where you disagree.
I 'll try to benchmark this later (don't have time to do it now), but using a switch statement instead of a lookup table generates binary searches (with slightly difference implementations) on both GCC and Clang: https://godbolt.org/g/VbWghs The generated Clang code seems to be a bit more verbose in that it uses compares and jumps with intermediate values (such as 3977867258728887858 and 4122543197735040048, which are both one less than actual magic square values) to jump to different places in the tree, whereas the GCC version seems to reuse the results of an equality test on a magic number to check if equal and to move to the next place in the tree if not (ie a ```je``` directly followed by a ```jbe```). All in all the Clang version has 11 ```cmp``` instructions while the GCC version has 8.
Is it better than clion?
Imho, most functions of clang format could be triggered at the end of a line and/or end of a scope (including namespace comments). &gt; Noise where? A lot of coding happens in preexisting files, that might not be formated with clang format at all or not with the exact version of CF or an older version of the config file. Just because I'm adding or modifying a single function, I don't necessarily want to have whitespace changes across the whole file.
Try it out yourself and check whether it suits your workflow? KDevelop is free-to-use and does not require a sign up or any juggling with licenses.
CERN, I believe, took it as part of their standard library, and using it to design new geometry subsystem, for example
Why do you think, that code is more "minimal" than the RAII version? And even, if you really want to introduce the additional scopes, the RAII version is still less code than this.
RAII isn't tired to exceptions at all. It happens to be very useful, when you use exceptions but just the fact that you don't have to write `delete` already is a benefit of RAII which is completely independent of exceptions.
Are you deliberately leaking a and b on success?
You perfectly demonstrate, why an API that doesn't use RAII is usually (of course there are always exceptions) inferior to an API that uses RAII. Contrary to what you keep repeating, using RAII and relieving the user (to some degree) of the need for manual resource management has value on its own and is not just a means to an end.
I really don't follow your argument: scope_exit uses RAII.
i'm only an ametaur, but while i prefer clion, the licencing fee keeps me away at least until i have a job. I usually code in vim, have been trying to use qtcreator but it annoys the shit out of me for some reason. so when I want an IDE I do actually use kdevelop and like it. but again this is an ametaur perspective.
QtCreator is a decent IDE once you get used to it and learn how to configure it properly. I do wish that Visual Studio Code's C++ support was better, as the actual text editor is far superior to Qt Creator. I have never tried KDevelop but now I'm intrigued!
If you're a student JetBrains offers free student licenses. That's what I'm currently using.
I would love to hear what makes you prefer CLion over KDevelop. Could you elaborate please?
Even if nothing is referencing to the data structure? Aren't most C++ compilers handle that kind of stuff like quantum physic, e.g. they optimize it away except if you are looking. But in that case const or not const should make no difference, too.
I am saying limited use of RAII is fine and `scope_exit` does the job. When you design all your code around it you will encounter something like `vector&lt;fstream&gt;`, now you need to think about copy/move constructors and next thing you know you are reading the C++ standard, it quickly goes out of hand for more complicate data structure. That is journey of most C++ turned C programmers I know.
sadly not a student.
thats a good question, and honestly I cant come up with a good answer. It might come down to what I tried first which was clion. Ihave a thought that perhaps clion's refactoring was better, but i don't have it installed to verify. I remember that the interface feels very well integrated and simple to navigate, whereas with kdevelop i struggle to see the trees for the forest. being an ametaur i sort of need discoverability, and some interfaces are rather opaque to look into. most of the time i use an IDE its because i'm in a bright environment and i need the white background. if i' at home at night i use vim still which seems like an oxymoron because vim is extremely undiscoverable. i'm just weird.
Jon, there are no c++ meetups in Atlanta area, sorry
Yes, I remember that. That was, what, 20 years ago? There's a reason why this is not done anymore, and the reason is what I am talking about.
Yes, sure. We are discussing hot-reloading a module upon an error though.
96.93% cases of a preference for x over y is a bigger *familiarity* with x.
I'm going to assume you don't work in a visual field if you can't understand the utility of something like this during development. Hot reloading of assets, shaders, textures, and even code is an absolute necessity for iteration time and for working with artists / designers who need visual feedback even if your application or engine isn't complete.
With all warnings enabled, the if on line 69 has issues (on MSVC 15.4.4). Because N==39 is always true when given a string with the correct length, it warns that the expression is always true, and suggests using if constexpr instead. The indexing of str doesn't want to work in "if constexpr", although I'm not sure why. I had to split it up to make it compile clean: &gt; if constexpr ( N == 39 ) &gt; { &gt; if ( str[ 0 ] != '{' || str[ 37 ] != '}' ) &gt; { &gt; throw std::domain_error{ "Missing opening and closing brace" }; &gt; } &gt; }
Still worth checking in the 0.07% to see if they have a point.
This is probably a stupid question, but why can't a future object be passed to the second thread? What exactly does the promise help with? Trying to learn C++, sorry
&gt; Acting as if C++ only libraries have a hope at killing C. Not hoping to kill, but we don't need to help it survive. :p
promise and future objects are linked and contain shared data. When some value is set in promise then it will be available in future object. In above example we want to retrieve data from thread, therefore we passed promise object to thread. So that when thread sets value in promise object, it will be available in linked future object. If we want to pass the value inside thread at later stage then we can do vice versa i.e. pass future object to thread. 
I am not disputing hot reloading but attempts to continue execution after an UB has been hit.
Ah. What about the remaining 3%? 😁
Futures are still useless until get() has a non-blocking version. 
how can anything be platform independent? it isn't, the implementation isn't, the interface is
Yeah, I don't understand why the only interface is blocking. Maybe I am not appreciating the difficulties of making a sane non-blocking API in C++.
If you don't wanna to get blocked on get() , use wait_for() member function of std::future&lt;&gt;. It's non blocking and will return on timeout.
That function also blocks. The only difference is it has a timeout.
Give it a 0 second timeout.
They are the ones claiming that it isn't based on what they are used to, but their reasoning is do convoluted that I'd rather gauge my eyes out than read it. That or I didn't notice that you wrote 96.97% and thought it was 99.97%. You pick which story to believe.
IMO the abomination is how easy it is to accidentally run into undefined behavior when it comes to proxy references. If instead of compiling and breaking, the code above would fail to compile, and I, as a user of the language, would need to write: auto&amp; b = v[0]; instead, then I would be more ok with it. 
I don’t understand. Can you give me an example of what you mean?
What's that "orthodox C++"? I never heard this name
Are you talking about a continuation like `then` or a `try_get`?
Why wouldn't you just use `std::future::valid()`?
AFAIK, valid() does not refer to if it has a value or not. 
Right, completely forgot that.
Apparently, we have had very different experiences. Imho 9 times out of 10, RAII simplifies writing of complicated data structures. Also, "scope_exit does the job" is completely backwards: most of the time it is the more complicated and more error prone alternative, because it still requires you to write manual cleanup code. It should only be used if there is no specialized RAII class to do the job (e.g., you should have very good reasons to use scope_exit to unlock a mutex or release memory instead of a lock_guard or a unique pointer). Your statements would be much more convincing, if you would actually show an example, where RAII makes the code more complicated instead of making some vague statements about it.
Mainly a try_get, but even that would require some sort of polling. I don't see how futures/promises are better than a callback.
"Two examples of cases where backwards compatibility constraints have been a drag on the language that were brought up were the keywords used for coroutines" whoever did this thank you x1000 sick and tired of antique codebases whose owners are too lazy/cheap to refactor but demand that they should just work with C++20 are damaging language... FWIW I would wish a more radical approach where: for each major language version: if there is a clang refactor tool that can modernize your code from human readable old C++ to human readable new C++ backward compatibility gets no vote wrt feature adoption. So only backward compatibility problems are those that can not be automated.
BTW wrt concepts, I imagine u/andralex reading [p0800r0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0800r0.html) and LOLing at all the denial and hand waving in that paper. :D
An callback will run on the thread that did the work thus the thread is not isolated from your code. If this thread is part of some pool you have now exposed that to outside code. An future/promise pair cleanly isolates the threads and code. As an library writer you remain in control of you thread model.
I'm not sure what you're getting at by saying threads should be isolated from code. Futures don't give you any control over your thread model; you either have to block one thread until the async op completes (which is a waste of threads), or you have one thread dedicated to polling a container of futures, which is a waste of CPU time. 
As you like VIM, have you tried the fakeVIM mode in QtCreator?
This doesn't solve the polling problem though
On SO somebody claimed that it is impossible to write standard-compliant vector in standard C++. For example you cannot implement `data`, because it would require `vector&lt;T&gt;::data() + vector&lt;T&gt;::size()` be valid, and this requires that `data()` returns pointer to actual array of T, and not some uninitialized buffer with Ts `placement new`ed here.
Well I indeed didn't write 96.97 😁
It's a total embracement of C-with-classes: https://gist.github.com/bkaradzic/2e39896bc7d8c34e042b Because apparently neutering C++ is better than just using modern C properly. ^/s
A `promise` represents an object whose value/error can be set. A `future` represents the result of a `promise`. In other words, the creator of the future value/error will first create a `promise` and return one or more `future`s from it. Then the creator will either set a value or error on the `promise` - at this point, all `future`s can check to see how the `promise` got resolved or rejected. If you're coming from JS, then an `std::promise` is like a `Promise.defer()` and an `std::future` is like a `Promise`. A bit confusing, but there you are.
Yeah, I also wanted to use `static_assert` / `if constexpr` there, but apparently not all constexpr bugs are fixed in MSVC yet, so compiler fails to treat `str[0]` as constant expression. Your suggestion looks like a good workaround until the compiler can handle that. The definition of GUID was taken directly from Windows SDK because this is my primary target platform. According to Wikipedia, there are different notations in representing GUIDs on different platforms and the code may be easily updated to match the required representation. I was originally going to remove dependency on ATL in my COM-related code and was looking at C++/WinRT project for ideas. ATL uses MS-specific non-standard attribute which allows specifying string GUIDs in source code and immediately get access to their binary form at compile-time: ```c++ struct __declspec(uuid("{BD1ED2F7-5B93-478D-9ABD-718CFB6D2FD2}")) ISomeInterface {}; constexpr const GUID iid = __uuidof(ISomeInterface); ``` I noticed that C++/WinRT stopped using this attribute (most likely due to their support of clang), but ended up with direct `struct` initialization and was wondering if it would be possible to keep string GUIDs in source code and convert them to binary at compile time. 
Oh, that makes sense. So the promise keeps the setter in one place so noone else can set it, but passes the getter to everyone else?
What is a "polling problem"?
Having to continually check if an async op has completed or not
Yeah, it works to bork the state of the process even more, or to sweep the UB under the carpet. Good job!
Everyone should watch one of harmut kaiser's talks from cppcon. It explains why blocking futures are bad and why .then continuations are beautiful. 2014 https://www.youtube.com/watch?v=5xyztU__yys 2017 https://www.youtube.com/watch?v=js-e8xAMd1s 
Prepare for downvotes
The answer to that is simple: the Core Language’s rules as written are too pedantic and should be fixed someday. When implementing the STL, we don’t worry about that.
This looks pretty nice actually! Definitely going to give it a spin sometime.
If you want to invoke code when promise is set - use `then`, if you want to poll - poll. You can combine promises, pass them around, store in fields and apply callbacks only if you need it. It's a nicer abstraction than callbacks. Also promises are a nice step towards await, that is coming to C++ soon. 
This doesn't make sense, you don't like the blocking function, you don't like the function that has a timeout (including 0) either because it polls. What do you want, magic?
I have no idea what it is you want: you don't like blocking, polling, or continuations. What is the solution according to you?
And spin a thread? That's no better than blocking it.
yeah, it's not as good as just using vim, and the vim emulator mode in clion is annoying and breaks refactoring. I cant stop typing ':w' when using any other editor anymore, the habit is too hard to break.
Thats ok. People can downvote what they want. I just think that programming style is nice. I think its worth exploring anyway.
I just finished some performance improvements to PcapPlusPlus and numbers look much better! You can take a look at: http://seladb.github.io/PcapPlusPlus-Doc/benchmark.html
static_asserts can also help a lot. I try to put anything not for overload resolution in static asserts so that I get a contextual string for an error message.
just a callback to notify me when something happens
A continuation (`then`, like e.g. Facebook Folly Futures) is exactly that.
callbacks outperform everything else though
what happens the thread that calls then()?
current std lib doesn't solve the communication problem. Promise/then is not elegant. You need something like asio::io_service to post handle/event between threads.
Then takes a lambda which executes when the promise is ready asynchronously. I suggest you google Facebook folly futures and read their intro, it's great. 
std::future is nice but It didn't solve big problem: How to easily code to getting return value without blocking . (I've used boost::promise/future recently with thread pool + boost::asio (C++03 project)). If we have a coroutine, std::future will be much useful.
Simplifying implicit lambda capture. This is a language-lawyer-y change that’s probably not of much interest to the average user, but it does fix the so-called “lambda capture paradox” where the type of generic lambda could depend on what variables it captures, but whether or not it captures a particular variable could depend on its type. https://botondballo.wordpress.com/2017/11/20/trip-report-c-standards-meeting-in-albuquerque-november-2017/
Why would it wait?
So what are you afraid might happen? That your car is getting pregnant? 9 times out of 10 it works as expected, 1 out of 10 it leads to further problems that might bring down the whole application a bit later. That already gives you a significant boost in productivity compared to the scenario where you directly abort and your application crashes 10 out of 10 times immediately.
As a work around you can go `v = v` in the capture braces so that the compilers know you are talking about the captured `v`. The only problem with this is that only gcc (correctly) includes the constness of `v`, so you have to make the lambda mutable to get the same non-const type on all three compilers. https://godbolt.org/g/XXCq77
&gt; That already gives you a significant boost in productivity compared to the scenario where you directly abort and your application crashes 10 out of 10 times immediately. Unless your goal is to locate and fix the bug — and why wouldn't it be..?
First off, unless you can show some stats about what percentage of sigsegv, sigill and such (especially sigill; you should try it sometime) can be "continued", you invented 9 out of 10. Second, your "works as expected" is completely and utterly meaningless because once your system tells you that you have hit an UB, all expectations are *off*. Third, if my application can crash 10 out if 10 times immediately, **I need to fix it immediately**. Fourth, people like you, and whoever agrees about using this, are guilty of creating a breeding ground for security bugs.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7f77aa/suggestion_regarding_project_configuration/dqcslpv/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
What do you miss in the QtCreator text editor? Just curious.
I'd like to see examples that are meaningful. The situation discribed in the post, with "thread 1" and "thread 2" is meaningless in a GUI situation for instance, nor is it likely that you'll launch a worker thread and then wait for it when serving requests in a server application.
&gt; An id-expression that is not an odr-use refers to the original entity, never to a member of the closure type. So rvalue ref is the correct return type?
QtCreator's text editor is clunky and slow on large products. Some times keystrokes take a long time to register. Also, scrolling is poor in large file. Though, this may be a feature of Visual Studio Code's. I believe the VSC's scrolling speed has acceleration, where the more you scroll, the faster it gets... to a point. QtC's (like most other editors) is just static. So if you're down on line 3,000 and want to scroll up line 20, it take a lot more effort. This has been my experience on multiple Macs. 
Huh. Im using creator on a 6 million line codebase, never experienced slow keystroke problems. I almost never scroll, I ctrl+f my way through a file, or alt left/right, so cannot comment on that.
Could be the way the project is configured and loaded. We have a CMake-based product with a root CMake file on a project at about 1m lines. Working on it always makes QtC sluggish. But when I switch to smaller project, it's fine. As for scrolling, sometimes it's just easier to scroll to find what I'm looking for when my hand is already on the mouse. 
I just remembered another thing that drives me nuts about QtC. So much so I wrote a bug about it: https://bugreports.qt.io/browse/QTCREATORBUG-17810 But is illustrated here: http://i.imgur.com/V01zKhk.gif
Aha, I never collapse functions either :p
Sounds similar in setup. Have about 8 projects open, of which 2 or 3 big (1M+) ones, also cmake.
If everyone worked like you the QtC would be a great IDE! :P
:p
At that point the compiler could possibly do it without getting the "const" as hint? 
It seems so. On https://godbolt.org/g/w8nszD yes. On https://godbolt.org/g/uQCyAg, lvalue ref.
It allows new attributes to be added by vendors or the language, and people to use attributes that your current compiler may or may not understand, and the code to be correct and compile regardless. So you can [[noreturn]] your code. Even if the current compiler doesn't understand [[noreturn]], it can compile the code and *it is guaranteed to generate correct results*. Compilers that understand [[noreturn]] can modify the semantics of your code (and, say, make it UB if you actually return) and generate better code. But because of the guarantee that ignoring a `[[` `]]` attribute doesn't make your code incorrect, compilers are free to ignore them without harm. So if you have cross-compiler code, you can mark it up with MSVC, gcc and clang attributes, and expect it to compile in all 3 platforms correctly and without (forced) warnings. 
N4659 [\[expr.prim.lambda.capture\]/14](https://timsong-cpp.github.io/cppwp/n4659/expr.prim.lambda.capture#14): &gt; Every occurrence of `decltype((x))` where `x` is a possibly parenthesized _id-expression_ that names an entity of automatic storage duration is treated as if `x` were transformed into an access to a corresponding data member of the closure type that would have been declared if `x` were an odr-use of the denoted entity. P0588R1 changes the wording into [\[expr.prim.id.unqual\]/2](https://timsong-cpp.github.io/cppwp/expr.prim.id.unqual#2), but I don't think the meaning is changed, except that the new wording seems to solve [CWG 1913](http://wg21.link/CWG1913).
This is a C++ forum, and this looks like spam to me.
I have a question why the template instantiation returns `int&amp;&amp; (*)()`, specifically - why `&amp;&amp;`? Isn't `auto` supposed to drop any cv and reference qualifications? I would expect `&amp;&amp;` only for `decltype(auto)`.
There isn't `auto` being used on the return _of the function pointer type_, just `decltype(v)`.
&gt; On https://godbolt.org/g/uQCyAg, just lvalue ref Or no, by taking [cpp_learner's comment into account](https://www.reddit.com/r/cpp/comments/7fl6zl/compilers_cant_agree_on_capture_type/dqd1i01/).
Wish there was an OSX build of this.
Thread 0 : Your main tread that "runs" your application Thread 1-5 : lives in an library. If you call an function in an library that returns an future, your T0 will never enter "deeper" then your function call. Any T1-T5 in the library will take your asynchronous call and execute them and set the promise and the go back to the pool. The library KNOWS what threads runs where and how. If we use an callback T1 from the library will "transfer" over to your code where it may do ANYTHING! Locking forever, picking up exceptions god knows what you send in to the callback. The library loses control. And you will probably need to do some shenanigans to get an message to the GUI thread anyway. Future - Promise separates the two "domains". 
Cystom deleters are also a bad idea then? Any STL function that takes a lambda? Your example, as I understand it, doesn't cover the real issue which is what happens in the time between the future being returned and the promise being set. 
&gt; use std::shared_ptr for objects that genuinely have indeterminate lifetimes This should be used as a captcha before allowing the reader to read the rest of the article. i.e. With a checkbox to confirm you read and understood that sentence. And even then...
**Company:** [ASV Global](http://asvglobal.com) **Type:** Full Time **Description:** ASV Global is a fast paced, global leader in the field of unmanned vessels. We're looking for talented software developers to help us develop everything from our mission control software to advanced autonomy features. Looking for candidates of all experience levels, though a formal education in computer science is highly desirable. **Location:** Broussard/Lafayette, Louisiana **Remote:** No. On site only. **Visa Sponsorship:** No. Further, this position requires use of information which is subject to the International Traffic in Arms Regulations (ITAR). Applicants must be a U.S. Person as per 22 CFR 120.15 in order to satisfy export compliance requirements. **Technologies:** Our codebase is written with C++11 and Qt5. **Contact:** More details and application instructions can be found [here](https://www.asvglobal.com/career-opportunity-autonomous-systems-software-engineer/).
Not sure why, I saw the 2017 talk and I thought it was great.
But there are other ways to get the value, and you can poll to check if it's done or not.
There is still the UB with the unaligned store though. Did you try putting the first 8 values in a uint64_t instead? You can add an additional if clause for the switch that is taken so rarely that it doesn't matter.
&gt; Because the first data member is a pointer to the object, a std::shared_ptr will decay into a pointer of the base type. This means there is zero overhead when accessing an object through a std::shared_ptr, which is pretty cool. "decay" isn't correct here, although the zero overhead part is correct. &gt; The implementation of std::weak_ptr works exactly the same way. It’s also a pointer to the object and a pointer to the control block, and decays to the base pointer type the same way. "decay" is even more incorrect here, as weak_ptr doesn't directly expose `.get()` (you have to `.lock()` to a shared_ptr first). &gt; Normally after creating a std::shared_ptr, the object will have a reference count of 1 and no weak references. However, if the class inherits from std::enable_shared_from_this, it will instead have a reference count of 1 as well as a weak count of 1. This is correct conceptually, but not correct implementation-wise. I'm not sure how libstdc++ manipulates its refcounts, but it's likely that they do what MSVC's STL does - the strong refcount is represented directly, while the weak refcount is represented as the number of weak_ptrs (including the one within enable_shared_from_this) plus 1 if any shared_ptrs are alive. This count is essentially the number of smart pointers that own the control block (as an optimization, all shared_ptrs are said to collectively own the control block). This optimization is invisible to users, but visible when you start inspecting data members in the debugger. (MSVC's visualizers decode this trick.)
This does seem to be the case with libstdc++, where the weak count is decremented by one when the use count drops to 0 (from https://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-api-4.6/a01034_source.html, I've removed the thread synchronization stuff) void _M_release() // nothrow { if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, -1) == 1) { if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, -1) == 1) { _M_destroy(); } }
I'd be interested to see this compared to C# .Then and asynch functionality. If I understand correctly C# async is like the co-routines mentioned here?
promise and future doesn't cover that scenario. For that scenario, why not simply pass a std::function&lt;&gt; and in the end of your thread function call that. template &lt;typename T&gt; struct Wrapper { std::function&lt; T ()&gt; mFunc; std::function&lt; void (T)&gt; mOnDone; Wrapper(std::function&lt; void ()&gt; func, std::function&lt; void ()&gt; onDone) : mFunc(func), mOnDone(onDone) {} void operator()() { T result = mFunc(); mOnDone(result); } }; future and promise comes handy when one thread is returning value and other thread is using that. In case of callback, it will run in same thread, its a different scenario ;-)
That's right. Promise is the "in" end if the pipe, future is the "out" end of the pipe.
I would love to read an article containing a list of situations where `shared_ptr` is often (ab) used and the actual solution with clear ownership design. Part of my own growing as a developer was to understand that sharing is not caring, you can almost always get around using `shared_ptr`s, which will benefit readability and often fixes hardly reproducible bugs. Also, I'd like to see a list of cases were you do need shared ownership, such as in asynchronous code, when after closing a connection you can't destruct the the connection object yet, because some stray callbacks might still be executed. Or when implementing copy on write, but that's a shared pointer to const, which is not so problematic. Are there any more?
Correct me if I'm wrong, but my understanding is that io_service solves the concurrency problem, not the parallelism problem. future, as presently specified in the standard, is solving the parallelism problem (as there is no way to make the future ready in response to I/O).
Coroutines are syntactic sugar to make it easier to write continuations; they depend on some form of continuation support provided by the library in order to compose. `std::future` lacks that kind of ability and the addition of coroutines does not change that.
If you give it a 0 second timeout, the work might never happen (at least if you got the future from std::async).
`std::async` is literally the opposite of "you remain in control of your thread model".
Because it's really bad to be constantly creating threads all the time. Your application won't scale. The future/promise pattern is broken for anything other than the most basic of apps.
&gt;set the promise and the go back to the pool. Some kind of thead pool was implied in my comment.
Strawman 
The article describes how one _can_ use the std future / promise API. But it does not cover at all the sever problem why the current API is broken. There are many who think the same way and because of that, there are several proposals on the way to try to improve the situation. Take a look into Sean Parent's presentation on this here: https://www.youtube.com/watch?v=QIHy8pXbneI There are libraries out there that don't have all these kind of problems: http://stellar-group.org/libraries/hpx/ http://stlab.cc/libraries/concurrency/index.html 
Well, in some graph line structures it may or may not be the most elegant solution.
I find it a bit annoying, that shared_ptr doesn't offer a direct way to create a weak_ptr (the counterpart to `std::weak_ptr::lock()`). Is this to prevent cyclic dependencies between the classes or is there another reason for it?
Since you are targeting C++17, you might want to consider this idiom: void capture_weak_by_value(uvw::Loop &amp;loop) { auto conn = loop.resource&lt;uvw::TcpHandle&gt;(); auto timer = loop.resource&lt;uvw::TimerHandle&gt;(); conn-&gt;on&lt;uvw::CloseEvent&gt;( [w_conn = conn-&gt;weak_from_this()](const auto &amp;, auto &amp;) { if (auto t = w_timer.lock()) t-&gt;close(); }); timer-&gt;on&lt;uvw::CloseEvent&gt;( [w_timer = timer-&gt;weak_from_this()](const auto &amp;, auto &amp;) { if (auto c = w_conn.lock()) c-&gt;close(); }); }); this saves you the two unnecessary variables holding the two `weak_ptr`s, which require extra ctor/dtor calls and copies when constructing the lambdas. Due to the presence of synchronization around the refcount, those operations are not free and the compiler might not optimize them away.
Now that we have deduction guides in the language, obtaining a `weak_ptr` from a `shared_ptr` `p` is as easy as `weak_ptr(p)`.
No fundamental reason. Note that `weak_ptr(sp)` works in C++17 thanks to class template argument deduction, available in Clang/LLVM 5 with MSVC 2017’s STL as of the upcoming third toolset update (15.3 and 15.5 are the first two).
&gt; Now that we have deduction guides Right, I keep forgetting about them. I still would prefer a `get_weak()` member, but now that's only a style issue anymore.
Thanks.
&gt; [w_timer = timer-&gt;weak_from_this()] No `[auto w_timer = timer-&gt;weak_from_this()]`?
No. `auto` is implicit and not allowed there.
Agreed. And genuinely indeterminate lifetimes appear only in multithreading, when objects flow from one thread to another. Everything else? Nah... `shared_ptr` is an overkill.
The most common situation where I use a shared_ptr is when I need to write a cache (that is accessed concurrently).
I have to say that I'm confused by the code in the function `capture_weak_by_value` in the code sample. The way I read it, after that function returns, `conn` and `timer` have strong reference counts of 0 and weak reference counts of 1, so they will be freed immediately, and the resulting close callbacks will never go off. (Also, tiny quibble, but I'm not a fan of `if (auto c = w_conn.lock()) c-&gt;close();` as a single line. Flow of control is important - it's worth at least a new line for the if clause.)
"Indeterminate" is not a good choice of word here, as C++ already has the concept of "indeterminate behavior", and this isn't it. I have rarely had to use `std::shared_ptr` - but in those cases, I never had objects with indeterminate lifespans. I used shared pointers for objects which intrinsically were owned by multiple owners, where the lifespan was determined by the lives of its multiple owners.
The “not trivially composable” part worries me. It seems like users will often need to compose them. And it also seems like when we list problems that we’ve found with standard libraries, lack of composability is often one of them. (And non-trivial composability will mean non-composability for many.)
How good is the built-in parser and auto-complete? I'm currently on Eclipse wchich supports so far C++14 (with no user-defined literals and number separators) and still has the defect of not understanding `std::void_t` SFINAE properly.
I think one has to distinguish between standard library concepts, which will stay around for a very long time and will be used by the majority of c++ programs out there and your own add-hoc concepts, that are used only in a particular part of your program to e.g. check, if a template parameter has a certain member (of course there is a wide range in between). I hope (I haven't used them myself yet), that they will be ready enough to write/compose for an average programmer for the latter case - otherwise they would imho provide very little practical value.
nope. Labmdas and objc blocks both can be used in either way 
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/7fuy3j/can_someone_help_me_with_my_assignment/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
This seems to have a problem that is also in the original code - there is no strong reference keeping `conn` or `timer` alive once you exist this function...
I assume that those strong reference are being held by the `loop` object.
What is that specific cpp17 feature that you're using here?
You can use a requires clause without ever writing a concept. https://www.youtube.com/watch?v=n4ie7tPMXOQ 
I was just referring to something the OP wrote, regarding `weak_from_this`. Actually, _init-captures_ (that is the possibility to write `[x = value]` as a capture) have been introduced in C++14.
I really hope the adjective syntax gets in. It covers so much use cases, and fix the terse syntax problem.
yes, yes, so that's why I was curious about that C++17 feature you mention :) as far as I know in cpp17 you can have constexpr lambdas, and pass this as a value... but that capture update went into cpp14
My understanding was that a concept is essentially a named requires clause. Is that correct?
hmm interesting, for me even on big projects with a lot of template stuff, typing has never felt slow (in contrast I cannot handle Jetbrains IDEs or atom or VSCode... typing latency is crazy there). When something changes and there are a lot of templates, the colors &amp; auto-completion take a bit of time to show up, but typing itself ? always fast.
I've had `make_weak()` in my stuff for years now, one for a `shared_ptr` and another for a `T*`. `make_weak(p)` is nice. I also have a wrapper for `enable_shared_from_this` that has `weak_from_this()` in addition to `shared_from_this()`, but also templated versions of both, which are useful in hierarchies (`shared_from_this&lt;derived&gt;()`).
This is terrifying. Languages that have concepts-like functionality natively don't have problems with newcomers writing them, nor do they struggle making them composable. What seems to have happened is that the C++ committee has failed to make a usable product, and now it's called a *good* thing that they are expert only and lack composability.
 #include &lt;type_traits&gt; int main() { int x = 1; int&amp; y = x; int&amp;&amp; z = static_cast&lt;int&amp;&amp;&gt;(x); auto A1 = [ ]{ static_assert(std::is_same&lt;decltype( x ), int&gt;::value, ""); }; auto A2 = [=]{ static_assert(std::is_same&lt;decltype( x ), int&gt;::value, ""); }; auto A3 = [&amp;]{ static_assert(std::is_same&lt;decltype( x ), int&gt;::value, ""); }; auto B1 = [ ]{ static_assert(std::is_same&lt;decltype((x)), int&amp;&gt;::value, ""); }; auto B2 = [=]{ static_assert(std::is_same&lt;decltype((x)), const int&amp;&gt;::value, ""); }; auto B3 = [&amp;]{ static_assert(std::is_same&lt;decltype((x)), int&amp;&gt;::value, ""); }; auto C1 = [ ]{ static_assert(std::is_same&lt;decltype( y ), int&amp;&gt;::value, ""); }; auto C2 = [=]{ static_assert(std::is_same&lt;decltype( y ), int&amp;&gt;::value, ""); }; auto C3 = [&amp;]{ static_assert(std::is_same&lt;decltype( y ), int&amp;&gt;::value, ""); }; auto D1 = [ ]{ static_assert(std::is_same&lt;decltype((y)), int&amp;&gt;::value, ""); }; auto D2 = [=]{ static_assert(std::is_same&lt;decltype((y)), int&amp;&gt;::value, ""); }; auto D3 = [&amp;]{ static_assert(std::is_same&lt;decltype((y)), int&amp;&gt;::value, ""); }; auto E1 = [ ]{ static_assert(std::is_same&lt;decltype( z ), int&amp;&amp;&gt;::value, ""); }; auto E2 = [=]{ static_assert(std::is_same&lt;decltype( z ), int&amp;&amp;&gt;::value, ""); }; auto E3 = [&amp;]{ static_assert(std::is_same&lt;decltype( z ), int&amp;&amp;&gt;::value, ""); }; auto F1 = [ ]{ static_assert(std::is_same&lt;decltype((z)), int&amp;&gt;::value, ""); }; auto F2 = [=]{ static_assert(std::is_same&lt;decltype((z)), int&amp;&gt;::value, ""); }; auto F3 = [&amp;]{ static_assert(std::is_same&lt;decltype((z)), int&amp;&gt;::value, ""); }; } The above reflects my current understanding of what the standard says should happen. I am not surprised that no compiler i could test thinks this program is well-formed. The rules governing this are scattered throughout the standard. * [\[expr.prim.id.unqual\]](https://timsong-cpp.github.io/cppwp/expr.prim.id.unqual) * [\[expr.ref\]](https://timsong-cpp.github.io/cppwp/expr.ref#4) * [\[expr.prim.lambda.capture\]](https://timsong-cpp.github.io/cppwp/expr.prim.lambda.capture) * [\[dcl.type.simple\]](https://timsong-cpp.github.io/cppwp/dcl.type.simple#4)
Is it fair to assume there will never be an opencl backend? I've done a lot of work with cuda but the lack of portability often makes it a hard sell. And opencl itself is a horrid enough language that no part of me ever wants to write anything with it. 
Much throughout sample. I have improved it just a little bit for MSVC checking https://godbolt.org/g/LYy61E.
&gt; Languages that have concepts-like functionality natively don't have problems with newcomers writing them these languages, like Haskell for instance, don't have newcomers at all. The average haskell dev has a phd.
You are basically asking to kill the STL. The STL cannot have interface for everything. Period. even if it magically would have interface for everything, everyone would simply stop using the STL. By the way, you don't need an interface to be compatible. Simply make your class satisfy the related concept. For example, you don't *implement* a `Container`. Instead, you satisfy the `Container` concept. Then, make your class and function parameterized to the type of `Container` you want to receive / contain. Anyway, since you use stl classes on the stack (or any automatic storage) you cannot have vtable based polymorphism. Interfaces would be simply useless.
I've had a lot to say about this. See my presentation at CppCon [How to make a Boost Library](https://www.youtube.com/watch?v=ACeNgqBKL7E) The fun starts at around minute 30 of a 60 minute talk. Summary points: * Every template type parameter should have "type requirements" (aka concepts). Which describe what behavior the template expects from the types passed as parameters. * These type requirements must be carefully considered, documented and checked by code at compile time. * Sortable is a very bad example of a concept. 
I suppose you could say that a "concept" is an alias for a list of type requirements. And maybe that's not a bad way of looking it. 
I have to say that overall I tend to be skeptical whenever the top C++ brass say: the average developer does not need to know X. There are definitely some hard core edge cases and corner case in generic code I don't know and don't need to know how to deal with, but you need to know a lot to write good code in C++. Example: for a long time I've heard people say that "application writers" don't need to know rvalues or `&amp;&amp;`, at least not well. I don't buy this, there are just too many cases where it comes up, in terms of both performance and dangling references. Similarly, I really am puzzled at this idea that typical developers will not write concepts. The first concept is perhaps fair enough, there are some non-trivial aspects to Sortable as it reacts to a very generic range of containers, element comparability, assign/swap -ability, etc. But I would say that if the average developer can't easily write a concept to represent a, well, concept, in their own domain, then concepts is a failure. And part of writing domain concepts will no doubt be composing them. So I find the latter two quotes quite scary.
Note that the idea of concepts has been around a long time. There is a Boost library - BCC - Boost Concept Checker which enforces type requirements for template parameters. With C++11 this can be implemented in a much cleaner way. Still, it's uncommon to see any formally defined type requirements for template parameters in any C++ library documentation out side standards documents. It's even more uncommon for code to include compile time code to check type requirements. Some believe that this is because it hasn't been possible. That is not true. This facility has been available as a library for at least 15 years.. There is a Boost library - BCC - Boost Concept Checker which enforces type requirements for template parameters. With C++11 this can be implemented in a much cleaner way. Paul Fultz implemented the as a C++11 library. Sadly, it was rejected by boost but hasn't been re-submitted. There is huge hype for concepts, but I'm not seeing many people applying already existing facilities to define and enforce type requirements. So I'm not sure adding concepts to the language is going to provide the hoped for benefits.
I think that's true only on one (or maybe two) specific compilers. So code doing this would be non-portable.
Newcomers don't go to C++ either. I don't see how that's a valid argument. Haskell was designed around pure functional programming and, whilst functional programming is creeping through popular languages through new features, I don't see it becoming anything more than an addon. Haskell however is a well thought out language that realize well what it aims to do. That's one thing that we can't say about C++.
&gt; Newcomers don't go to C++ either. uh ? plenty of schools &amp; uni where C++ basics are taught in 1st or 2nd year
They also generally only teach c++ 98 era code and generally leave out templates. C++ at universities is C with classes and is such because these things are easy to explain, powerful to use, and clear enough for noobs to get within a reasonable amount of time. 
strcmp() returns 0 if strings are equal. so in ur if condition add ==0 .
Handles SFINAE very well, but other things have more difficulty. For example, there isn't much autocomplete (for now) with dependent types.
As well as those, that have a similar course on functional programming with Haskell as a most frequent example.
thank you for your reply. When I did that, I keep getting "Student not found" thrice. My text file contains only two lines: ellen 122a 85 A john 123s 65 B
Afaik, those objects are kept alive internally by the loop object.
Dude that is completely unreadable 
You don't need multiple threads for this. Just think of a DAG with multiple roots, or persistent data structures. There are lots of examples, where a mode has multiple parents and you don't know which one will let go first.
If already existing Concept-like facilities are as convoluted to use as that Boost library, I am not surprised they are not used very much. But Concepts as a clean and relatively simple to use first class language feature is a pretty different beast. I kinda hoped for first class variant/optional (with pattern matching) instead of a library too, but that ship has sailed...
But shouldn't "result &lt; 0" also be evaluated using '&lt;=&gt;'?
Can you please help me make it readable? I am kinda new to C++ and stuck at this part of my assignment, which is class management system. Thank you!
TL;DR: 1. SO user q-l-p did not understand a sentence in P0515R2 Consistent Camparison aka The Spaceship Operator Proposal. The question also disputed the grammar of the sentence. &gt; The expression `a &lt;=&gt; b` returns an object that **compares** `&lt;0` if `a &lt; b`, **compares** `&gt;0` if `a &gt; b`, and **compares** `==0` if a and b are equal/equivalent. 2. Some SO users said the sentence is just plain English. Others said it is C++ jargon. They debated. 3. q-l-p brought the question to other two SE sites about English. People there thought the sentence was unusual. Eventually, an SO user went over there and analyzed the grammar. 4. Finally, q-l-p started a community wiki answer.
The functionality of your code is all entwined such that everything is coupled together. The student class should not be responsible for EVERYTHING! E.g. Retrieving of data to populate the student and its related I/O should be separated out. Lets also hope no-one has a long name.
This is probably not the place for code reviews (see sidebar), but at the least, if there isn't reason to otherwise, you should use C++ features, so instead of `strcmp`, you can `string sname` and `cin &gt;&gt; sname` followed by just `sname == obj.name`. Still, is it specified that you have to use `char` arrays instead of just `string`s for the `Student` object? Unless it's meant to coexist with some database or you have strict memory requirements, you may as well just use `string` for those too.
You're never initializing the student object, so that your obj.name is empty at time of comparison while your sname variable has a string in it. 
The typical solution: start a for fun/learning/entertainment project and keep gradually improving it. Make things faster; make things easier to use via the API; make the API simpler to understand... etc
- Join the CppLang slack - https://cpplang.now.sh/ - Keep up to date with current developments, in particular C++Weekly, CppCast - Follow when a new standard comes out &amp; read up on it - Join conferences - Actually using it would of course be better. Why not C++ for your next project?
thank you for your reply! yes it is specified that the name be 32 chars and id be 15 chars.
Youtube channels like https://www.youtube.com/user/CppCon/ can be good, just watch the occasional video to keep it in mind and you'll even learn something new as you go. The trick to remaining current with a skill isn't grinding away mindlessly at it but to get some news feeds or other information sources that will on occasion spark your interest anew and encourage you to dig into the language again.
&gt; The average haskell dev has a phd. Oh, now I understand why I was not successful with Haskell.
Depending on the specification, you might need to add a char for the null terminator, i.e. if it has to be able to store 32 chars, you would need `char thing[33]`. Otherwise, definitely use `std::cin` to read to a `string`, and perform regular equality check. It'll be cleaner and safer than using raw `strcmp`.
what I am trying to imply is objects are students. So I am trying to get the details of the person (object) with the same name. How to do you suggest I solve that?
&gt; objects are students try reading the file line by line https://stackoverflow.com/questions/7868936/read-file-line-by-line parse each line for it's separate parts http://www.cplusplus.com/reference/string/string/find/ http://www.cplusplus.com/reference/string/string/substr/ then compare the student name you just read in with the name entered from console. 
The point is finding *time* to follow all the stuff.
I hate those names "promise" and "future", they are fucking retarded, there are far many other better names. 
I'm more interested in general highlight and fast symbol finding + function signature lookup.
&gt; and you don't know which one will let go ~~first~~last FTFY
work on a personal project that you have an emotional interest in. Something you are motivate to work on, not just doing it for the practice.
No, the legal return types of `result` have `&lt;`, `&gt;` and `==` defined, not `&lt;=&gt;`. And you cannot introduce new overloads into `namespace std` to give it a `&lt;=&gt;`. 
This is the `bool operator auto()` feature, so `auto b = v[0]` deduces `b` to be `bool`. 
Great piece of advice! I already practice the selective ignorance and I personally find it powerful. The reason why I want to re-learn C++ is that I've already invested my time in it, what makes a lot easier to be relevant again. AND most of my target companies/positions require C++ (Not javascript) 
&gt;Some people, when confronted with a problem, think “I know, I'll use ~~regular expressions~~shared_ptr.” Now they have two problems. Do *not* use `shared_ptr` to magically resolve "hard to fix" bugs. I know, it's the last day of your sprint. I know. But not only have you not really fixed the bug, it is now buried another layer of complexity. Other bad reasons to use `shared_ptr`, from experience: 1. Pure ignorance. C# and Java programmers who are literally unaware that stack memory is a thing. They're momentarily excused. 2. "I don't want to think about memory management". 3. "I don't want to learn how to write a copy constructor." 4. "Copying is expensive. Instead of copying this struct which contains 16 bytes of data, I'll use a `shared_ptr`. That's smart! No my code is fast and efficient because there's no copying!" Sometimes, I feel like `shared_ptr` is like `goto`. The number of developers who understand when to use it is much lower than the number of developers who *think* they understand when to use it.
reading the last stuff only takes us so far I think, that happened to me a while back too, just find a fun project that you wanna do and try to work on it at least once a week. try to set clear goals to what it is, preferably something small and go from there. 
This is definitely the crux of your bug, but i do believe that char array is uninitialized, not necessarily empty. Arguably that's worse. Consider providing a constructor for Student that takes your line variable as an argument.
For functions signature and symbol matching, in my codebase, kdevelop is powerful enough for my needs. You'll have to try to know if it suits you. In my experience, kdevelop matches symbols very well. If I have an overloaded function with sfinae, it will take me to the right one when I Ctrl+Click on it. The same goes when hovering a function usage. It will take the right function documentation and signature even when overloaded and sfinae is used. However, if your code has error in it, I find kdevelop to be not merciful enough. Since it respect sfinae and overloading so well, if no function is found, the whole highlighting for that line breaks for most cases. It won't break if clang has an autofix. For example, wrong class name or wrong variable name is usually well handled. **tl;dr** if your code is correct, hightlighting and symbols matching is almost flawless. A part of trivial errors, don't expect any meaningful highlighting if your code is incorrect. 
Yes. This was considered explicity in early papers for optional. It was discarded as overly complex (mostly), and getting in the way of other requirements. To be sensible, you'd want `std::optional&lt;T, invalid_state=std::has_invalid_state&lt;T&gt;&gt;`, where `has_invalid_state&lt;T&gt;::value` is `false` by default, and `true` in other cases. And then some means for it to write an invalid state into a chunk of memory that is aligned and for the type in question, and determine if it is in that invalid state. template&lt;class T&gt; struct has_invalid_state:std::false_type {}; template&lt;&gt; struct has_invalid_state&lt;bool&gt;: std::true_type { static bool is_invalid( std::byte const* ptr ) { return 1&lt; *reinterpret_cast&lt;std::uint8_t*&gt;(ptr); } static bool make_invalid( std::byte* ptr ) { return ::new( static_cast&lt;void*&gt;(ptr) ) std::uint8_t(2); } }; given such an augmented `optional`, we could teach `optional` how to use invalid states of the byte pattern of `T` to store null `optional&lt;T&gt;`. This would be a breaking change for `optional` as adding new template arguments is a breaking change. Quite possible for `std2`. You'd also want to write a converted to/from `std::optional&lt;T, other_invalid_state_trait&gt;` so you can have your optimized-for-storage `optional`s (that use invalid states) and ones that are not optimized for storage and have the two work together nicely. 
FWIW (and we are in the minority it seems) I completely agree with you. Sfinae is weird and ugly but it doesn't really take long to learn, and again while it can be convoluted using it for more complex things, it can solve simple things quite easily. Same is true with static asserts. I've never understood why concepts are seemingly regarded on the same level of importance as reflection and concepts. These are the most important improvements, bar none, in fundamental language expressiveness and practical language tooling respectively. I don't think concepts is in the same league.
Do current facilities enable nice overloading? Like being able to write boost::algorithm::sort(vec); boost::algorithm::sort(vec, pred); boost::algorithm::sort(vec.begin(), vec.end()); boost::algorithm::sort(vec.begin(), vec.end(), pred); 
Note to self: &gt; Check if /u/saulogt is an alt account my subconscious created. What I do is follow c++ blogs (e.g. Herb Sutter) and occasionally answer c++ stackoverflow questions. Another thing I do is come to grips with the fact that my c++ skills are getting a bit rusty... 
Solve problems on leetcode/hackerrank in C++. Beside that it is kind of tricky but you can watch cppcon videos...
same level of importance as reflection and *modules*, perhaps?
http://en.cppreference.com/w/cpp/io/ios_base/openmode *app* seek to the end of stream before each write`
Some yes, plenty no and in 1&amp;2 really little. At least in France, Universities mostly teaches java, C#, python. It might be even more likely to find a functional programming course than a C++ one. I've been in a Canadian Uni for 8 month and it didn't have a single C++ course either (only C#). French engineer schools usually teach programing quite late and most of my friends coming from such schools have only had python and java courses. Personally I had to wait for the my 2nd year to have a C++ course and it was a C++98 one. The voluntary retention of C++ is also really low. I'd say that about more that 60% of the students in my school (with around 1K/promotion) abandon C++ after the third year. I've had an extremely hard time finding any C++ enthusiasts. C++ is seen by most of the devs I know, due in part to the extreme lateness of C++11, as a legacy programming language. Something you have to put up with. 
it stands for append
Whoops, I'll fix that. Thanks!
If the loop object is the unique owner, then why all the fanciness with weak pointers in the first place? Oh, there are many possible explanations, but having to make up some whole essential part of the system in order to reason about this code indicates a flaw...
Side project
But doesn’t !q and !p imply deductively -l-? His name is redundant!
Sorry, it was a recursion joke.
IIRC think quicksort does not need RA iterators, std::sort just needs them not to be O(n^2) in worst case. https://stackoverflow.com/a/35171489/700825 Also I disagree about auto. It is problem only for juniors, most developers know they can get type of auto easily. Other than that I agree with you. I like to phrase problem a bit more differently: "free software" does not have PMs, nobody actually caring about user experience. I mean boost is still quite amazing, so I am not complaining too much, but for junior devs it is quite hard to use. Even for more experienced people like me some parts of it are scary. :)
Without watching the video why is sortable a bad example of a concept? It was in Bjarne Stroustrup's paper showing how nice and clear concepts could be. It got me really excited for how simple and clear C++ was going to become. Guess that isn't happening now.
What do you mean? You can check with wait_for with a tiny duration. If it timed out, the result is not ready yet. 
Yeah, I know the feeling, I enjoy C++ programming. If you specifically are interested in javascript at present you might find Cheerp interesting. It is a C++ to webassembly compiler letting you do whatever you would be doing in javascript but use C++ instead.
Maybe worth mentioning (since the cppref page doesn't) that "app" is an abbreviation for "append." Further worth noting that `ios::app` functions differently than the "append" mode in many other languages'/frameworks' IO utilities, which tend to work more like `ios::ate` (acronym of "At The End", I believe). 
So, 20+ years of C++ went into Java about 3 years ago to work on some pretty boring stuff (but it pays well and I didn't have to move). This has been a huge concern for me I don't want all that experience to get rusty. So, I work on a game engine in my spare time (since most of that 20+ years was in the game industry anyway). 
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7fykmr/what_iosapp_does_thanks/dqffls4/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
It is in the working paper for C++20.
concepts can make programs better. My view is that Sortable does not illustrate this. For that reason it's a bad example. first it's tautological - it defines sortable as .... doesn't say. It doesn't tell me what my type has to be able to do in order to be Sortable. I think in this case Sortable would be better replaces with RandomAccessContrainer&lt;T&gt; and LessThanComparable&lt;T::value_type&gt; This would tell me what I need to know in order to properly use a sort function. Sortable does not. There are some other problems, but this is the most obvious one.
&gt; So, after 20+ years of C++ programming, I went into Java about 3 years ago to work on some pretty boring stuff A lot like my situation, just the opposite. After not quite 20+ years I got bored with Java (after having done almost everything Java is capable of, which is *a lot*) and found myself slowly, almost naturally, drifting towards C, and in particular, embedded. I am now completely star-struck and in constant awe of C's powerful beauty, and love writing in it. I've recently come to notice that the speed and ease with which I write Java is certainly not what it used to be, and I must admit, it came as a bit of a (nasty) surprise. 
Why can't we define sortable as what you say within a concept? Also, why can't we define custom error messages when people pass something in that is missing those things?
Keep building small lunchtime projects. It's the best way the test your (new) understandings. 
Overview: https://github.com/dekimir/RamFuzz/blob/master/sci/ramfuzz.md
If a pet project seems to daunting, contribute to an open source project you enjoy.
I'm sure some people will find a way to fuck the stack with unlimited recursion anyway. I know I did a few times (unintentionally, because of overloading or override function names).
Probably most abstract classes could be replaced by Concepts.
A concept has the notion of atomic requirements. An overload with `requires a &amp;&amp; b` won't be selected over a function with `requires a` like it would with an actual concept. Having "more specific" concepts is very useful for things like iterator categories. Perhaps not as useful for application developers, but I haven't thought that through.
Interesting idea. However at the end you’ll essentially have a function telling you whether a random set of inputs will be valid to the program or not, without any guidance as to what input to generate to begin with. So you’d have like a do { input = generate(); } while (!valid(input) loop in the end, where valid() is your NN. What would be more useful is a kind of generative network (GAN/VAE) that you can train afterwards to generate more valid inputs given the examples you collect. But doing this with structured data is hard
If you were to bring up the documentation of the function, you could get a good idea of what you need (random access and a less-than operator). With `Sortable`, you'd see meaningless information and need to go to the definition of `Sortable` to get what you really need. Not worth it unless this `Sortable` concept is used throughout and it becomes easier to read the code with the small learning curve. 
Tail recursion is your friend. Then it's just an infinite loop.
There's no substitute for using the language as suggested in other comments, but you can try flash cards. If you use an app that makes use of spaced repetition (like [Anki](https://apps.ankiweb.net/), you can preserve a ton of knowledge while reviewing just a few minutes per day. For general information on making flash cards see [this page](https://www.supermemo.com/en/articles/20rules). For a head start and example of how you can collaborate on cards see [these cards](https://github.com/chrahunt/cpp_club/tree/master/flashcards) from Accelerated C++.
This is what I do...make small, complete side projects that you actually use. Do bug fixes and keep adding features over time. If you continue it as much, shelve it and build something new with that tech stack. That way you're always tinkering.
Almost there. With a concept, you name a requirement, and you can use it, and better structure your requirements on related algorithms. One of the most profound accomplishments of the STL (as originally developed by Alex Stepanov) is that Alex established a few foundational concept, and then systematically (ruthlessly?) classified algorithms based on their requirements expressed in terms of those foundational concepts. That principled approach helped the rest us understand what he was getting at -- enabling the community and WG21 trying to improve his design for the last 25 years. `requires`-clauses are basic, assembly-level, blocks necessary to define concepts, but you should avoid using them directly when constraining algorithms. I consider it poor practice to try to avoid concepts and use only `requires`-clauses. I doubt we would have "gotten it" Alex had stuck with the assembly-level expression of requirements.
New concepts (pun unintended) take time to learn and practice. Imagine 30 years ago, "classes" were reserved for the elite, and the elite couldn't even get it right. From experience, the second sentence of your post is at best an exaggeration. I believe the C++ community is doing a good job with concepts, considering everything else. Healthy criticisms are welcome, as ever -- but we have to learn to discern the wheat from the chaff.
As someone raised in the French educational system (and who also taught Computer Science at French engineering schools), I can relate to the fact that the part about programming language is usually about 5-10 years behind the fashion en vogue in the US, so maybe in 5 years they will teach modern C++ more profusely where they are teaching Java now ;-) That being said in tongue-in-cheek, I do know from first hand experience and from friends who teach at universities and industries in France that this part &gt; C++ is seen by most of the devs I know, due in part to the extreme lateness of C++11, as a legacy programming language. Something you have to put up with. is at best just a local phenomenon - not something characteristics of the situation in France. I lectured on C++ in France a couple of years ago, and the perception of the working programmers and engineers is entirely opposite to what you wrote.
This can be done currently with enable_if 
I guess I still just don't see a problem with it. If we need more focused sortable, then just name it sortableRand or sortableAll or sortableLL and define more specific variations. Or if we need something that is provable, then we step up to concepts written by teams of experts or whatever. But that isn't the reason I want to use concepts... The benefit of concepts to me is that we can eliminate types within our own programs and just define a set of required traits that we can reuse within our class for clearer and more simple syntax. What sortable or addable means in my private use is totally different than what id want to hand a client in an interface. I'd also like the ability to define the error message that hits the console when I blow the concept. Maybe my C++ knowledge is too limited though.
Only if you want to replace dynamic with static polymorphism (and/or std:: variant).
what about using boost::wait_for_any()?
I was mostly thinking about the CRTP and similar approaches that are used to replaced Concepts most of the time. Obviously runtime polymorphism will not disappear, but I believe many new patterns will emerge thanks to Concepts.
Liked look of the library but hated the name of this reddit post, progressive is an derogatory term used to refer to moronic left wingers.
Use it every second day :-P Whilst I trained as a programmer, these days I do other things and dabble in programming when I need to but I find the best way is to keep a database of reusable routines, functions, and my own documentation library. Acts as a handy reference to how I do things and makes remembering how to code something much easier. Also document your code is the single biggest learning method you can employ in my opinion.
I seem to miss something here. Is it a common pattern to enforce a certain interface by inheriting from an abstract CRTP base class? So far I've only used CRTP as a means to provide functionality - not check interfaces. Or are you relating to something else?
Even when working as a full time C++ programmer, it's hard to grasp everything that is going on!
It is as it is a standard layout! http://en.cppreference.com/w/cpp/language/data_members#Standard_layout "If a standard-layout union holds two (or more) standard-layout structs as members, and these structs have a common initial sequence of data members, it is well-defined to examine any member of that common initial sequence regardless of which member of the union is active." 
I am french myself, did an engineering school, and work at an university and I really don't agree. I don't know anyone in the grandes écoles who didn't have at least a project in C++ ; likewise unversities generally have the C++ course in L2. IUTs also have C++ classes.
Except the "debate" didn't conclude. No one offered an answer that meets the requirements of the question: - the answer should be in layman's terms - the answer should explicitly clarify if there are, or aren't, other implications. But to be fair, the asker might have edited the question after users posted their answers.
**Company**: Metrologic Group **Type:** Full-time **Description:** Metrologic Group specializes in the design and manufacture of industry reputed 3D inspection software and electronics. Its famous software Metrolog X4 (www.metrologx4.com) is a worldwide reference. Metrologic develop its own 3D engine, realistic scene simulator, Catia V5 wrapping framework, and a unique direct control to large dataset of machinery from manual 3d coordinate measuring machines to the latest cobot and 3d laser digitizer. You are sharing our values: Innovation, Performance, and Results, and you are motivated to consolidate our team (around 25 developers) to develop powerful technologies in 3D real-time, collision avoidance and strategy motion planning for complex robotic cells, datamining, virtual reality, Augmented Reality and Digital Manufacturing : join us ! **Technologies:** C++11, OpenGL, BOOST, Visual Studio, GPU **Location:** Grenoble, France. **Remote:** No **Visa Sponsorship:** No. **Contact:** If you are passionate about what you are doing, please drop us an email with a motivation letter and your CV highlighting your previous work experience to candidatures@metrologic.fr 
That's regressive.
In this case nodes dont own others. Nodes are owned by a higher entity, and nodes only point to other ones
Besides the obvious suggestion of working on some project on your own, I would also recommend to read as much as you can about it. Blogs, articles, maybe watch few videos too... Reading other people's code and following projects on GitHub can help too.
Have you seen todays left.. regressive is an polite term
Well, similar recursion is there for `operator-&gt;`
Although the idea of randomizing is good, I agree that it's harder to find new posts. Can it be randomized by default but sortable?
Unfortunately, reddit doesn’t permit that. Next quarter, I’ll try going without contest mode and see what people think.
There is a combo just under the number of comments, where the sort-type can be changed.
add codingame to the list
Exactly what I do. At work I do JavaScript, but at home all I do is C and C++.
I agree completely and even when your work with C++ there are project restrictions. Sometimes you can't practice some areas of C++ as you like or use some new C++XX feature. I try to do some small side projects.
The C++ reddit is the wrong place to express your political convictions. 
Give the left an inch and they take western civilization, any normalization of evil must be resisted.
I haven't finished reading the article yet, I will do that later. I just noticed one sentence, that may be wrong, totaly unrelated to programming: &gt; Of course there is class optional in C++14 located at std::experimental::optional. But we don't want to use it until it is experimental Doesn't until basicly mean "while not", so shouldn't that sentence be "... while it is experimental"?
I have some questions: Is there documentation on how to use the library in a multi threaded application? Is the library able to create the initial database scheme? Are fks and manually created indexes supported? Sidenote: this looks like an interesting library, but calling it "the most progressive ..." seems a bit "optimistic" 
Allow me to add my experience. In out company, we use QtCreator for development of very large project. I won't say any line numbers as that would be just lying, I would have to check that. But we have hundreds dialogs/widgets, thousand of non-form other files, some using Qt, some not. Clang autocomplete is impossible to use - very slow, errors in parsing (probably QtCreator not passing all macros defined in pro files for given configuration and us actually using MSVC for the build, not gcc/clang). Autocomplete sometimes doesn't work for templates even with clang completion model. Built-in code model is fast, but it has lot of trouble with templates. It also doesn't take typedefs into account when looking for function definitions (lets say function is declared as returning ptr&lt;MyObject&gt; (because of forward-declared MyObject) and defined as returning MyObjectPtr (now fully defined Object with MyObjectPtr being typedef ptr&lt;MyObject&gt; known), QtCreator doesn't jump to the definition). Virtual methods - almost impossible to use refactoring features. If I inherit a class, declare a virtual method, right click on it to use "implement inside cpp file", the IDE would freeze for several minutes before showing the menu (maybe looking for the method in all the files). Debugging this project - impossible in QtCreator. We must use VS for debugging. You could probably find my post about this somewhere on reddit, I won't repeat it here again. But otherwise, quite usable IDE.
The C++ reddit is _still_ the wrong place to express your political convictions.
&gt;wrong place Are you assuming the places gender! You monster! 
Like this? struct Foo { Foo* _() { return this; } }; Foo foo; foo._()-&gt;_()-&gt;_()-&gt;_() /* ... */ -&gt;_();
You can get infinitine compilation time with recursive template instantiations.
CRTP can be used to provide concepts, the only issue is you need to inherit from it.
I know for a fact that unless you change the code of gcc, it won't go very far in recursive template, since it was a limit for the TMP Turing machine some guy made for a contest. The default is usually large enough for any reasonable use, and it crashes early enough so you'll find out before it ate up all your memory.
AFAIK there is a command line argument to change default maximum depth.
Maybe that was it, I read that quite a while ago. Gcc might have changed during that time as well too.
Huh, with all that, usable means you can just about type something :p. 
Yes
But that doesn't require the CRTP to be an abstract class does it?
It's not a requirement indeed.
You're a badass rebel
No. Compiler recursively applies operator `-&gt;` until it gets a real pointer. Like: struct smart_ptr { smart_ptr operator-&gt;() { return {}; } }; int main() { smart_ptr{}-&gt;foo(); } Output: In function 'int main()': 6 : &lt;source&gt;:6:20: error: circular pointer delegation detected smart_ptr{}-&gt;foo(); ^~
&gt; This can be done currently with enable_if I was under impression that enable_if is much uglier to write and gives uglier error messages... But I did not know you can overload nicely like in the sort example i posted. I guess you were right... library writers are just lazy :P 
Author here. I agree with your big-picture summary, but keep in mind that this is just a first step, to demonstrate the framework's abilities. As I argue in the future-work section, there are several anticipated developments that could make this useful: - if we could translate valid() into human language, that's a spec - if we could classify valid()s for different programs, we may be able to spot bug-indicating patterns; imagine training another model to distinguish between valid()s of known bugs and their fixes - if we could invert valid() to tell us how to generate only valid inputs at runtime, we have an automatic test-input generator that can spot regressions; you covered this by invoking GANs, but there are other approaches one could take -- see, eg, RamFuzz/ai/solver.py, which uses a different model that lends itself to reversing the constraints using Fourier-Motzkin elimination Where I would suggest GANs, coincidentally, is to pit a code-modifying network against a bug-finding network, evolving them together until we have a bug fixer. :D
I have been keeping an eye for this kind of library lately. Unfortunately, most of them use Exceptions, which ends up being a problem for the projects I would like to integrate it with.
I might be mistaken on that, but isn't the idea of fuzzing to try all kinds of unpredictable pattern, rather then specialise on the any given sample data?
One important thing to note is that the sanitizers don't catch all errors. So no error under thread-sanitizer doesn't necessary mean that the code is thread safe
You're right that fuzzing tries unpredictable patterns, but that's because fuzzing typically works on the whole program, looking for a crash. When you operate at the unit-test levels (that is, testing individual methods), unpredictable patterns aren't really helpful. Most methods do have a pattern of what parameter values they expect. For instance, `foo(char* p, size_t len)` typically won't work correctly if you don't supply a meaningful `len` -- that's not a bug, that's just a convention in this family of languages.
I have stopped using C++ full time in 2006, nowadays I spend my time between Java, .NET, Android and Web. I keep my C++ skills up to date, by reading books, watching C++ related conferences like NDC, CppNow, CppCon, following CppCast and doing weekend projects in C++, mostly Android NDK and UWP. Sometimes that little utility that could be done in any of my daily languages, gets done in C++ instead, preferably while trying to use modern idioms.
It's not just "not a requirement" it's actually quite bad. To make it abstract, it has to have a pure virtual, but if it has a pure virtual, then it has a vtable. Now you've wasted 8 bytes of spaces in your class. I think the whole approach of "CRTP as concepts" is bad and useless. It's needlessly intrusive and a lot of boilerplate for low value. The real use of CRTP is statically injected mixins, for which they are awesome.
&gt; although the zero overhead part is correct. Going to have to disagree with you here. `shared_ptr` is twice the size of a regular pointer. Since a vector of Base* is a relatively common use case, using `shared_ptr` instead of `unique_ptr` will have a significant performance cost for iterating over the vector, and it will evict twice as much of your other data from cache.
Interesting, but first glance, the code is far less readable than a plain SQL string query (not sure why your project considers them bad). We use libzdb, it's fine apart from the author's bizarre choice to use C-style exceptions. We just wrapped it all up into a C++ interface.
Why a compiler deleting a memset call isn't a compiler bug is beyond me.
 * [Safe Clearing of Private Data](https://www.viva64.com/en/b/0388/) * [CWE-14](https://cwe.mitre.org/data/definitions/14.html): Compiler Removal of Code to Clear Buffers 
To bad that most of them don't work on WSL.
Because from the perspective of the compiler/language definition it doesn't change the functionality of the program. It should also be noted that such code , even when not optimized away, doesn't prevent leaking secrets. 
You can easily make typos in plain queries
Because it's a performance optimization. I like it TBH.
I made `memset(some_ptr, 0, sizeof(some-ptr))` mistake a couple of times. Then I made `template&lt;typename t&gt; memset(t&amp; var, int val)`. C++ &gt; C. Always.
Clang does that micro optimization. I used https://godbolt.org/ with x86-64 Clang 3.9 and -O2 
Not available with MSYS2/MinGW-w64 or even stl's MinGW-w64 distro :(
&gt; SQL, GUI, networking Not even freakin string operations.
I agree. I love C++1x and STL and Boost are super powerful, but why on earth do I need to develop my own functions, if I simply want to split my string at a semicolon? It's just super annoying that the STL provides no functions for simple stuff but focuses on being super flexible and super performant.
I tried this out looking for strings in a 16,166 line source file with 1,611 matches (10 iterations, Visual Studio 2017 Release build): std::regex: 0.141166 seconds. CTRE: 0.0246754 seconds. I make that 5.72 times faster. lexertl::memory_file mf("H:/Source/PartnerDev/4.01/Development/CaseManager.cpp"); std::string input(mf.data(), mf.data() + mf.size()); std::regex rx("[\"]([^\"\\\\]|\\\\.)*[\"]"); mf.close(); using namespace sre; using Lexer = RegExp&lt;StaticCatch&lt;0, 1, Sequence&lt; Char&lt;'"'&gt;, Star&lt;Select&lt; NegativeRange&lt;'"', '"', '\\', '\\'&gt;, Sequence&lt;Char&lt;'\\'&gt;, Anything&gt; &gt;&gt;, Char&lt;'"'&gt;, Identifier&lt;0, 1&gt;&gt;&gt;&gt;; Lexer lexer; const char *str = nullptr; const char *end = nullptr; PositionPair position{}; unsigned int ident = ~0; auto t1 = std::chrono::high_resolution_clock::now(); for (int i = 0; i &lt; 10; ++i) { std::cregex_iterator iter(input.c_str(), input.c_str() + input.size(), rx); std::cregex_iterator end; for (; iter != end; ++iter) { // std::cout &lt;&lt; (*iter)[0].str() &lt;&lt; '\n'; } } auto t2 = std::chrono::high_resolution_clock::now(); std::chrono::duration&lt;double&gt; time_span = std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(t2 - t1); std::cout &lt;&lt; "It took me " &lt;&lt; time_span.count() &lt;&lt; " seconds."; std::cout &lt;&lt; std::endl; t1 = std::chrono::high_resolution_clock::now(); for (int i = 0; i &lt; 10; ++i) { str = input.c_str(); end = str + input.size(); do { if (lexer.match(str)) { ident = lexer.getId&lt;0&gt;(); position = lexer.getCatch&lt;0&gt;()[0]; } else { ident = ~0; position.end = 1; } /* if (ident == 1) std::cout &lt;&lt; std::string(&amp;str[position.begin], &amp;str[position.end]) &lt;&lt; '\n'; */ str += position.end - position.begin; } while (str != end); } t2 = std::chrono::high_resolution_clock::now(); time_span = std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(t2 - t1); std::cout &lt;&lt; "It took me " &lt;&lt; time_span.count() &lt;&lt; " seconds."; std::cout &lt;&lt; std::endl; 
Yeah, but that's still no reason why you couldn't provide a 3 line high level API in addition for the people who just want to get a small webserver running. And I assume there are a lot more people who just need a simple web server and don't want to develop the next Apache.
The problem is that `string{"foo"}.c_str()` might be very useful, e.g. when the temporary is still around for a function invocation. Consider a C-style API expecting a `const char*`, but you need to concatenate some values first, one of them returned from a function returning a `std::string`. Something like ```cpp std::string foo(); void old_func( const char* ); int main() { old_func( ( foo() + "something" ).c_str() ); } ``` there's probably a lot of code out there that is using this, so you'd break it.
Welcome back. C++11 and its successors are a lot better than the old C++, especially in regards to memory management. I just hope for you that your new team uses a decent IDE. We just switched from Visual Studio 2010 to 2017 and the productivity boost is amazing. I just love how good intellisense and the debugger are. If you code with gcc or clang or on Linux I really recommend the Visual Studio Code editor and CMake. Eclipses CDT is just slow and buggy. I've heard also good things about CLion, but I never used it personally.
Another note against shipping sanitized binaries for production deployment: they are not designed to be secure, or to react securely if a security vulnerability is exploited to trigger them. 
someone needs to make a Boost.Metaparse DSL for SQL
Ideed, thanks for the answer ! ... And sorry for missing this
That seems like a nice way to make your api safer, but it does break correct code: char P = *string("Potato").c_str(); Here, the lifetime of string() ends after the expression is evaluated, so this call to c_str is safe but would be disallowed by your container. Presumable that's the reason the stl containers didn't adopt it.
There should be some ISO standard C api for relational operations in lieu of SQL, really. The whole passing strings back and forth to the DB engine is the essential problem. I've no interest in ORMs at all, but it would be nice to have "compile time SQL" that looks reasonable to everyone and is widely supported.
Forgive my ignorance, but why does this not suffer from he same problem? Doesn’t `(foo() + “something”)` also return a temporary and result in a dangling pointer?
A friendly reminder: Check if /u/saulogt is an alt account your subconscious created.
Wat? Sanitisers are used in the development process. You don't ship binaries compiled to be sanitised. The performance hit would be insane.
You guessed correctly, temporaries are only destroyed at the end of the full expression, hence *after* `old_func` was called.
With optimization, the performance hit can sometimes be acceptable. Some people might look at the sanitizers and see a 'bumper mode' that they could enable, not realizing that if a ball ever hits the rails the entire bowling alley explodes.
Ace. Thanks for the confirmation. 
These things inject code into your binaries so LLVM's tools can introspect your code. It makes literally no sense to deploy this. 
Would it break anything if temporaries were destroyed at the end of the containing scope instead of at the end of the expression? Such behaviour would make RAII usage easier.
To everyone saying that they don't work for Windows: get a real OS! /s You can use them on CI, they're best when done regularly.
I don't think CRTP are a good replacement to concept either, but until there are concepts it's one of the ways they end up being used. Using virtual functions obviously depends on whether you want to have polymorphism or not obviously.
Almost as good as the old [Gimpel pc-lint](http://www.drdobbs.com/a-bug-a-month-its-harder-than-you-think/199900339) ads. 
it doesn't change *the compiler's* understanding of the program
There was a proposal wanting to opt in to this by reusing the register keyword. Can't remember if it's still active, but you can look there. 
but it's incorrect
It maybe incorrect according to what you think it does, but it is within the language specification
Why is it incorrect? The c++standard doesn't require the compiler to emit any code for this, so why should it? What c and c++ imho need is a standardized, secure memset function that is guaranteed to clear the memory, but unfortunately, I'm not even sure if that is possible without redefining the concept of undefined behavior.
In all fairness, what is more likely? That the programmer just put in a useless function call or that he (falsely) expects the compiler to generate the equivalent assembly instructions, even if it doesn't make a difference according to the Compiler? Imho compilers should be smart enough to detect such patterns and not optimize away those calls (at least not without some kind of warning and a possibility to opt-out of that optimization.
Mind..blown.. I always thought this was intentional UB every time I wrote it for some quick debug output that never gets checked in
On my phone the last few characters of each line are cut off. It's super hard to read 
&gt; Even with full optimisation and link-time code gen (/Ox and /LTCG) VS2015 does not inline the call to `f`. [According to the docs](https://docs.microsoft.com/en-us/cpp/build/reference/ox-full-optimization), /Ox is not actually full optimization: &gt; In some versions of the Visual Studio IDE and the compiler help message, this is called _full optimization_, but the `/Ox` compiler option enables only a subset of the speed optimization options enabled by `/O2`.
Good to know, thanks. Regardless, it doesn't affect the results in the blog post - I get the same results with /O2 and /Ox.
What an exciting time for the language- compilers getting features implemented before the committee standardizes them. It really makes me wish I could be a compiler dev. Now we just need to get [gcc](https://gcc.gnu.org/ml/gcc/2017-08/msg00349.html) on the road to coroutines...
With GCC `main` is special-cased as a cold function, so very few optimizations are applied to code directly in it. Maybe MSVC has a similar heuristic?
It's possible. The example with main was just a toy example to demonstrate the problem, the actual code where I ran into the problem was not in main().
Just confirmed it's not a problem with main(), I get the same issue from another function: https://gist.github.com/Ono-Sendai/cd9552809431911faa14b6841306f415
clang gives quite good error messages for enable_if, it tells you exactly which constraint failed.
Inline frames imho are not very useful because sample positions tend to be imprecise and are attributed to wrong functions. Viewing the raw assembly give you a better picture. 
&gt; As you can see there is a significant performance boost from inlining the function. It's about 1%. I don't really think that this is significant enough to be an issue in most situations. There is a gain obviously, but usually too small to really matter in the end.
Maybe clang on Windows can offer you the sanitizers?
Actually that's a roughly 9% performance increase.
Sorry, I misread your post and compared the wrong values. Sure, in this case it's more significant.
I, for one, am not in it for completeness. A central goal of the sanitizers project is *no false positives, period*. Far more useful to have that than tools that play language lawyer.
You too can be a compiler dev.... you just have to want it.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7ganoc/where_do_i_go_now/dqhr2qu/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
`memset_s` though (C11). Probably the better discussion than the one us two are having is here: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=8537. MSVC agrees BTW.
The main problem is that your test have to execute a code path that exhibits a particular bug, but if they do, chances are extremely high the sanitizers will catch it. Did you have a particular example in mind?
I don't think this is a matter of OS1 being better than OS2, but that the main companies investing in clang use Linux or Mac.
&gt; If you're multi-threading, -fsanitize=thread can detect data races for you - such as one thread updating a value while another one is reading it Even if this is just an example, this is a far to narrow description of data races. Data races occur whenever to threads access the same object, at least one of them is a write and there is no synchronization between the threads. It really doesn't matter, if the access the data "at the same time" or with minutes in between
clang-tidy
If your projects compiles with clang, you should have a look at clang tidy.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/7gbc8x/need_help_creating_a_web_platform_with_c_and/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
One example that I had in mind is that TSan doesn't detect deadlocks caused by a race condition
A good fun project (well if you are into games) is to start working on a game. I started working on one when I was in a similar situation like you (OP) and had so much fun that I still continue to hack on it even though I have a C++ day job for more than a year now. Or you could contribute to some open-source project (game or other). This is especially useful as you could learn from the code of more experienced C++ programmers.
... want it more than time with family or other hobbies. Shit is time consuming. Good advice for a student though.
I personally don't think this is a good idea, as it would make things less efficient and temporaries also might block resources (other than just memory). I am, however, still thinking that extending the lifetime of some temporaries might make the language more consistent and it would allow us to explicitly select the lifetime given the recent changes in C++. Currently, when calling a function the temporaries created in the expression calling the function get destroyed at the end of the full expression. That is not true for statements, if you have if( const char* p = foo().c_str() ) { /* oops, p is a dangling pointer */ } What if we extend the lifetime of temporaries from the *last* expression of `if`, `for` (the range-based for loop), etc. just like for function calls? You could opt-out with *init-expr*s easily: if( const char* p = foo().c_str(); p ) { /* stupid example of opt-out */ } This is especially useful for range-based for-loops, just look at how adapters could easily work: for( const auto&amp; e : reverse( foo() ) ) { ... } The above `reserse` currently is either storing a dangling reference to the result from `foo()` or it is forced to move the result from `foo()` into a member variable of itself. Also, what if `foo()` returns an object that stores a container and you can get access to that container by calling `bar()`? Look at for( const auto&amp; e : foo().bar() ) { ... } and realize how this is almost guaranteed to be a bug. Even if it is not today, tomorrows maintenance might break it. Some libraries like the range-library try to avoid that by simply not allowing code with rvalue-references in some cases. But that leads to unintuitive code, as I still can't understand why `old_func( foo().bar() );` is OK while `for( const auto&amp; e : foo().bar() )` is not. Opt-opt would be easy in C++20: for( const auto tmp = foo().bar(); const auto&amp; e : tmp ) { ... } When the `init-expr`-part of the statment would, of course, *not* extend the lifetime of subsequent temporaries. Anyways, I don't have high hopes that the language will be changed... it's just my thoughts on this.
It's a good question. "Because the result is not observable so it may be left out" is one answer, but it is not true: the result is very clearly observable because you are now leaking secrets. So maybe our definition of observable is wrong? What would a compiler do with a buffer that I obtain from an OS call, and only ever write to? Perhaps a later OS call would render that buffer to the screen, implicitly, yet how would the compiler guess that this apparent write-only buffer has any observable meaning? 
Afaik, TSan only detects data races, not race conditions (logic errors).
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7gbqdc/c_parking_project/dqhy9at/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
This feature is for those of us who cannot comfortably make sense of the raw assembly and figure out where the instructions are coming from. Additionally, this feature greatly helps with scenarios where some functions get inlined in the middle of the callstack. I.e. when you are seeing something like "A &gt; D", and you are scratching your head where the call to D is coming from, when in reality it was inlined and the full call stack is "A &gt; B &gt; C &gt; D".
Clang is available on Windows but AFAIK, it's only available for either Visual Studio or through MSYS2 but still doesn't include any sanitizers.
&gt; I personally don't think this is a good idea, as it would make things less efficient and temporaries also might block resources (other than just memory). It could be made opt-out with a sort of reverse `register` keyword (where `register` is the keyword in the proposal mentioned in the sibling to your comment). If we were going with your proposal, I'd do it the other way around and extend temporaries in the `init-statement`. Opt out by not using an `init-statement`.
I saw that proposal and immediately thought it would be better the other way around. I haven't been able to find it since though.
I think that the best approach is to integrate in your CI, every static tool that you can have your hands on. Of course they should need some trimming but you can get great benefit from all. From my experience, in our company we use coverity, clang analyzer/tidy, cppcheck and in many cases they have found different interesting bugs. Static analysis is very hard as a concept and the languages doesn't offer adequate semantics for having a full analysis.
This is incredibly useful to someone like me who is starting to tread water in this topic myself; I really appreciate the cleanliness of the header that even a novice like me can understand. Thanks for sharing this; I was using Casey Muratori's technique for dealing with the PDB lock, but your approach is really slick!
Umm, how about ReSharper C++?
cppcheck might be good as well. I don't know if there are VS plug-ins (or whatever) for it, though...
Klocwork
It's were the keyword `volatile` will be used (correct me if I'm wrong, my understanding of that keyword is kinda limited) to explain to the compiler that something else may modify that variable.
&gt; auto D2 = [=]{ static_assert(std::is_same&lt;decltype((y)), int&amp;&gt;::value, ""); }; &gt; &gt; auto F2 = [=]{ static_assert(std::is_same&lt;decltype((z)), int&amp;&gt;::value, ""); }; I think `decltype((y))` and `decltype((z))` should be `const int&amp;` in these cases. [\[expr.prim.lambda.capture\]/10](http://eel.is/c++draft/expr.prim.lambda.capture#10): &gt; For each entity captured by copy, an unnamed non-static data member is declared in the closure type. The declaration order of these members is unspecified. The type of such a data member is the referenced type if the entity is a reference to an object So in both cases the corresponding data members have type `int`, and since they are in const member functions, the expressions `(y)` and `(z)` should be const.
Gimpel, at last, has just released a new tool based on CLang. I did not evaluate the new one, but the previous product was the most complete tool in the past. Though not too easy to use, because of the myriad of options. http://www.gimpel.com/html/index.htm 
Visual Studio do have [Code Analysis](https://docs.microsoft.com/en-us/visualstudio/code-quality/analyzing-c-cpp-code-quality-by-using-code-analysis) included. The C++ compiler have the [/analyze](https://docs.microsoft.com/en-us/cpp/build/reference/analyze-code-analysis) option providing static analysis of C++ code.
I recently convinced our finance people that forking out for Coverity. The hardest part was making their sales people go away after installing it.
There are plugins available on the marketplace, for Visual Studio 2012 an up. But you can easily integrate any command line tool in Visual Studio without plugins. That's how I'm using cppcheck in VS 2010.
Coverity is a professional solution, but it is also free (“Coverity Scan”) for open source projects. 
&gt; Game developers deal with performances requirements that makes most of modern C++ impracticable.) This is a non-sense statement; you have been lied to by your community. It's been going on for years. Examples of actual problems I have seen: Don't use std::sort because templates. Use qsort. Oh wait, nope std::sort is definitely faster. Don't use std vector because of quadratic growth. Oops, custom solution reallocates on every push so it's N^2. Avoid STL because of compile times. Actually, custom solution compiles much slower. Avoid templates because code bloat, we'll generate code instead. Oh shit, linker can't fold the massive amount of code we're generating so we're bloating but templates would have been fine. Many of these problems were real problems for a short period of time when the features were new. But the games industry has a problem where people become Sr and then continue to work around problems that no longer exist. 
Has that changed not too long in the past then? IIRC they do offer free Coverity scans for *some* OS projects (if the OS project is... notable or popular enough or something), but generally not for any and all OS projects...
An example, by definition, can't be "too narrow".
That isn't static analysis (and it's really slow).
If your project won't compile with Clang you should fix that too.
Not quite what you're looking for, but since your already using VS you should use the [Core Guideline checker.](https://msdn.microsoft.com/en-us/library/mt762841.aspx)
Not Tidy, but [Clang Analyzer](https://clang-analyzer.llvm.org/) works with GCC. &gt;scan-build has little or no knowledge about how you build your code. It works by overriding the CC and CXX environment variables to (hopefully) change your build to use a "fake" compiler instead of the one that would normally build your project. **This fake compiler executes either clang or gcc (depending on the platform)** to compile your code and then executes the static analyzer to analyze your code. From https://clang-analyzer.llvm.org/scan-build.html 
I don’t consider std::sort or std::vector modern c++ they are pretty basic established part of c++. There are solution for reducing the bloat of templates that don’t involve generating code. “Actually custom solutions compiles much slower”: i really can’t imagine how anything could compile slower than typical STL implementation. I feel my paragraph was awkward and misworded as I was thinking of many more things than runtime performances but: portability, simplicity, compile time, general production performances etc. Things like Boost often promote ways of programming that are hard to debug, understand, iterate, tweak. People who are eager to use features because they exists are often pushing for more _complex_ solution because they can’t accept eg: duplicating a statement two times. Simpler code imho scales better in the brain of your teams, and the brains of your team is your most valuable resources. It’s hard enough today to find skilled C++ programmers why making it harder. 
Fortify SCA should be on your list to evaluate. PVS studio is pretty good though, I don't know much that will beat it.
Excellent point. Though why you would not create a copy of a reference when capturing a reference by copy i dont know or understand.
I think you could connect your github repo to Coverity scan and run it on travis for years. But there was a limit on runs per month (so a special branch had to be set up ideally that would be rebased to master N times per month).
I thought clang analyzer was going to be merged into clang tidy. Don't know where I got that from though.
Isn't it though? https://blog.jetbrains.com/rscpp/whats-new-in-resharper-c-2017-1/#cmdline
Coverity is the best one I’ve seen for C++ in terms of analysis, with Klocwork a close second. The user interface for Coverity is superior. Coverity has some advanced features like integrating code coverage and identifying which tests need to be run for a particular code change (tests that cover the modified code as well as tests that cover code that calls into or is called from modified code). Those features are challenging to setup (you can pay their professional services folks for help) and may or may not fit your needs (I.e. if all your tests are automated and you’ll be running them all anyway. Coverity is also expensive but worth it for critical or large or aging or complex codebases. It also has good compiler support (we used with MSVC and IAR compilers mostly with a few others for various embedded targets thrown in). Basic static analysis is easy to setup. Klocwork is a close second but lacks the same usability in terms of walking developers through the explanation of its finding. That is a particular strength of Coverity. Klocwork is easy to integrate and does the same kind of static analysis as coverity. SonarQube is another one. C++support is well behind its support for C#, Java, and JavaScript (only others I have used) but it’s not without merit. It is less of the hard core static analysis where it traces complex control flow and more about finding simple style issues, but some of the rules are important to me (fail on commented out code, for example, a pet peeve of mine). Our company already had this setup so we use it for C++code, and I also have no idea what it costs, so can’t comment on whether it’s worth it. Usability is good, although I’ve had a harder time breaking builds with it in Jenkins than I would have expected. All of these require a central server to be setup, so you should plan for that. They also find different things. There is a large overlap but each of them has a few things they do better than the others, so running multiple would be best. Static analysis with these tools is SLOW for large projects, so be prepared for that. In our case it’s pretty well constrained to being a “nightly” operation and not part of our “every commit” CI/CD pipeline. That,s something I’m working to change but C++ tooling is what it is and all of these tools have more robust tooling for other languages. 
[Sonarqube](https://www.sonarqube.org) has been excellent for analysis on both java and C# projects in my experience. I haven’t used it for other languages, but it certainly supports a lot of them. 
Maybe it is now I suppose. I tried it a while ago, but cpus still only go up to dozens of cores so it may be a while before it stops lagging the UI.
There's also [clang analyzer](https://clang-analyzer.llvm.org/) which does more of the code-flow analysis and less of the linter type analysis that tidy does.
In that regard it's hard to compare it in performance, because I don't think anyone does something like running all of the CppCheck or ClangTidy checks and showing result visually for every change user made. But in its nature a lot of its code inspections are similar to the ones provided by the tools mentioned in this thread so static analysis is at least an essential part of what resharper does.
&gt; I don’t consider std::sort or std::vector modern c++ they are pretty basic established part of c++. At one point in my career, they were modern. &gt; &gt; &gt; Humble reminder that the Wii U which was a viable potential engine target one year ago didn’t have a toolchain that supporteed c++11. &gt; &gt; &gt; &gt; There are solution for reducing the bloat of templates that don’t involve generating code. “Actually custom solutions compiles much slower”: i really can’t imagine how anything could compile slower than typical STL implementation. &gt; I have worked on many big games. Most rolled their own variant of STL that "fixed" the problems. Some used STL and Boost instead. This might be anecdotal, but the home grown versions compiled slower, generated more bloat, had actual bugs, caused some bugs because their interfaces differed very slightly form the STL (for things like iterator invalidation), and we're generally slower in the runtime. Sometimes performance was on par. &gt; &gt; &gt; My paragraph was in answer to someone suggesting that std::vector is all you need to know, when I say you need to know and use C arrays as well. &gt; &gt; &gt; &gt; I feel my paragraph was also awkwardy/misleadingly written as I was thinking of many more things than runtime performances but: portability, simplicity, compile time, general production performances etc. Things like Boost often promote ways of programming that are hard to debug, understand, iterate, tweak. People who are eager to use features because they exists are often pushing for more complex solution because they can’t accept eg: duplicating a statement two times. And that's my point. Every single C++ feature was "modern" at some point in the past, and experienced people will invent all kinds of reasons to *never* use that feature, and that's just wrong. You might need to avoid it until it matures, or have some guidelines, but statements like "we can't because games have special performance requirements" are non-sense. &gt; Simpler code imho scales better in the brain of your teams, and the brains of your team is your most valuable resources. Yes, but sometimes it takes complex code to design a good interface. C++ was designed to allow building interfaces that are more akin to language extensions than just a library that does stuff and much of the STL (and by extension, Boost) was written with this mindset -- to act as a language extension. Once you're thinking of designing interfaces in terms of language extensions, the implementation can't get out of hand quickly, but the complexity at the call site reduces significantly. &gt; &gt; &gt; &gt; It’s hard enough today to find skilled C++ programmers why making it harder. The language is a mean not an end. Games are extremely complex to make, whenever we can reduce their complexity we should. Everything is a tradeoff. Sometimes it's possible to hide complexity behind an interface, sometimes it's not, sometimes it's just really hard. 
&gt; What an exciting time for the language- compilers getting features implemented before the committee standardizes them well, isn't this how it should be actually ? Standards are about standardizing existing practices. For some reason now the C++ standard drives the implementations, but really the opposite should happen.
You can run the clang analyzer checks from clang tidy. They don't work as well that way though.
True about the middle of the stack frame. It would be a good idea to display leaf functions as they are, but handle the inlining info for the intermediate ones. 
Intel vtune by the way does a really nice attribution of instructions to the c++ code, if you can use it. 
Another example is this: some_func( ::std::string_view{ foo() + "something" } ) Seems like a dangling pointer, but isn't, since temporaries are deleted after the complete expression is finished evaluating.
Nah, I've used it for newly-created projects with no issues. They just validate it first so that you don't abuse it (ie. temporarily upload some non-open-source project or something)
Using the `create` factory you're forced with the key being the string length. This is way too easy to decrypt :) Am I missing something obvious? 
There's [cuSPARSE](https://developer.nvidia.com/cusparse) and [ViennaCL](http://viennacl.sourceforge.net/).
The link works for me
It'd be much better if the string was the length of it's hash or longer when encrypted
Besides [Deaod's point](https://www.reddit.com/r/cpp/comments/7fl6zl/compilers_cant_agree_on_capture_type/dqi4fxx/), it must not go unnoticed that [clang leaves seemingly contradictory warnings behind when using explicit captures](https://godbolt.org/g/6pC74v). It basically induces the bare removal of the explicit capture, which ends up leading to a different type.
&gt; Now we just need to get gcc on the road to coroutines... yes please
Use *many* tools. Start by paying attention to the warnings from your compiler (yes, that's static analysis). Mix in CPPCHECK and other free tools. Turn on everything, then turn off problematic messages where they conflict with your project design rules. Compile your C and C++ code with Clang and GCC, turning up the warnings; yes, this is static analysis. Now pay attention to the warnings, and resolve them by attacking the root issues (not just by hacking the code so the compiler stops detecting the issue). Even if you only did that, you'd be a few miles ahead of most projects I've seen ;)
CLion does run clang-tidy after every change, ReSharper C++ will too in 2017.3
Since you are using Visual Studio, there is a couple of ways to run clang-tidy on a Visual Studio solution. Clang Power Tools (https://marketplace.visualstudio.com/items?itemName=vs-publisher-690586.ClangPowerTools) is a free extension that allows to run clang or clang-tidy on request and shows tool's output. ReSharper C++ will also have clang-tidy integration in 2017.3 - it runs clang-tidy in background after each change, shows clang diagnostics and clang-tidy checks in the editor and allows to apply clang-tidy fixes (for each diagnostic separately or in bulk).
The only explanation is because you're not _using_ it (the value), so it's to take the patch that requires the least amount of resources necessary while still behaving as-if there was an actual capture.
On one hand, the linked post says an expert "has ten or more years experience with C++, particularly with templates, including template metaprogramming", and that "even experts shouldn’t be writing concepts on their own". On the other hand, people jump into Rust from high level, dynamic languages all the time, and largely seem to be successful doing so, despite it being basically impossible to write Rust code without creating traits. I'm not expecting perfection from C++, but given I have to work with other people I feel I have more than enough reason to be worried. This "it's OK to be bad" deflection the C++ committee constantly produces is simply unhealthy for the language.
If you can't budget for a paid solution, I think cppcheck is perfectly fine. I can't speak for the paid ones. If you do go with cppcheck, I'd recommend looking into [coala](https://coala.io/#/home) for aggregating many types of analysis. When adopting static analysis, you have a problem with a backlog. Rather than trying to handle that upfront (which usually causes static analysis adoption to fail), I created an internal to minimize adding things to our backlog while working to reduce our backlog. It checks in the result of the analysis. I then looks at the current report and the previous, and any new items have a "git blame" performed and the parties are emailed, told to fix it. We can then always look in the file from time to time for backlog reduction. I'd love to get to the point where we can error on all failures.
 I've reported this issue to MS before, they said something about the new inliner in VS2017 fixing it-- but doesn't look like it actually did so. 
That's a great example of changes in the language, but I disagree with a few of the design decisions in the final version - I'd have chosen kelvin as the base, not celcius, as that's _actually_ what both the other two are defined in terms of. `water_freezing_threshold` also doesn't strike me as needing a unique implementation per scale - surely they should all be casts from the kelvin version? Also, supporting different `value_type`s is just unnecessary complexity, and is unused - how would you know if there is a bug in that code?
cppcheck now integrates clang-tidy.
IIRC that's called "codifying existing practice"... And I guess that's part of what the standardization committee does, but I think a balance needs to be struck between doing that and also thinking about where the language might need to go in the future...
I can second this, there is also C++ support available, but the documentation about commercial/open analysis modules is kind of bad...
Rust
Eigen's [tensor module](https://bitbucket.org/eigen/eigen/src/1eac3a6e99b631e263b0af6c8c4b7fde4a4d32d6/unsupported/Eigen/CXX11/src/Tensor/README.md?at=default&amp;fileviewer=file-view-default)? 
I'd love if you tried out the C++ code analysis included with VS. Microsoft has been investing pretty heavily in its C++ code analysis as of late, especially in enforcing rules that match recommended enforcements in the [C++ Core Guidelines](https://github.com/isocpp/CppCoreGuidelines). We're pretty good about blogging about our progress on the [VC++ team blog](https://blogs.msdn.microsoft.com/vcblog/)--see the [cppcorecheck tag](https://blogs.msdn.microsoft.com/vcblog/tag/cppcorecheck/) for the most recent updates. If you try the tools, please let me know how they work out for you, for better or worse. 
Thanks for reporting this. (Just a note: instead of using Connect, can you use Report a Problem at [https://aka.ms/vs-rap](https://aka.ms/vs-rap)?) We have been working on the inliner--you see the change between VS2015 and VS2017 already. Inlining is always heuristic: you need to balance between compiler throughput, generated code quality, and generated code size. In general, developers shouldn't have to use `__forceinline` (or `inline` or `__declspec(yes_I_really_mean_inline)` or any of its variants.) If you have a codebase that you can share that uses `__forceinline` heavily, please let us know so we can improve our default heuristics. 
In case you plan to use clang static analyzer and clang tidy (and possibly also integrate them into your CI) you should try [CodeChecker](https://github.com/Ericsson/codechecker/).
`/Ox` is a holdover from the olden days. It's even hard to express succinctly what it it does. (Roughly, it enables compiler optimizations, but not those optimizations that have to involve the linker.) We'd like to just get rid of `/Ox`, `/Os`, and `/Ot` but Microsoft is all about compatibility and that'd be a too-large breaking change for way too many customers :/ That said, I'd expect inlining heuristics to be the same between `/O2` and `/Ox`. 
He says in the post that VS2017 actually inlines the function. Do you have another example to share, or can you link me to that bug report?
Yeah. It looks like they changed the size threshold for inlining in VS2017, but are still not handling once-called functions as a special case.
Hey! I work in VC++, I know what's going on here. Thanks for the post. We do have a single callsite inline heuristic, but as the author here guesses it is in fact subject to growth limitations of the function. Pretty much the only thing exempt from our growth limits is __forceinline. It's also a little more complicated than the post implies. The author also needs to consider the recursive inline case, if A calls B and B is the only callsite in A, it seems like a great idea to always inline it there. But if A is itself inlined in a billion other places, then now you don't have a single callsite for B, you have a billion+1. And so on. So it seems like a less great of an idea. I guess, just consider that because inlining is a recursive operation on an entire call tree below a function, in real code there is rarely ever such a thing as a "single callsite". You have to think about more than just the single level case.
What kind of phone? Can't you just zoom out? :)
VS2017 inlines the function (f()) in that example, but not if I make the function larger. So VS2017 still suffers from the same problem, just with a changed size threshold apparently.
Tensorflow?
If you miss the user interface from clang based tools, you should try [CodeChecker](https://github.com/Ericsson/codechecker).
Thanks! paging /u/terrymah for this one as well. 
What does it cost? We evaluated Coverity, but they wouldn't tell us the price so we passed. 
[taco](http://tensor-compiler.org/)?
I have something similar, I call it [constexpr_xor_array](https://github.com/MarekKnapek/stuff/blob/master/C++/constexpr_xor_array/xor_array.hpp).
I'm not too concerned about this case, it's sort of a tiny toy example: the heuristic I describe is for the common case. They key insight is that A itself may be inlined elsewhere, which in effect creates additional callsites to B. So B is no longer a single callsite. Yes, I agree if B did truly only ever have a single callsite, and that callsite isn't in a potentially cold branch, then inlining it would be good (because then the linker could remove B). Inlining the call tree on top of that single callsite may create additional callsites for B, it's just something the heuristic has to consider. That's basically why we still leave it subject to the size restrictions. Just making B forceinline may be very, very bad for code size if A is inlined in tons of places. And the sad part of all of this is: We compile bottom up, B, then A, then A's callers. So when making these decisions about how to treat B as force inline into A, we don't yet know for sure if A will be inlined (creating more callsites for B).
Inlining size threshholds (and the rest of the heuristic) are constantly changing, every release. We get tons of reports/requests for tweaks for various cases. And as I said above, we do have special cases for one-called functions but it's not particularly aggressive because of the recursive inlining case I described. You can never be completely sure something truly is once called.
Indeed, another part of the heuristic is there is a size cap on how big of a function we apply the single callsite heuristic to. Maybe that's what you are hitting here. There are other caveats as well: we don't bother applying the single callsite heuristic at all if that single call is located in forceinline function itself. Because then it's not single callsite. Same logic as above.. gotta consider the recursive inlining case creating additional callsites. Looks like we don't apply it to when the single callsite is in an exported or address taken function.. because the linker then couldn't remove the single-called function anyway, so there is no size savings. There are some other limitations specific to WinRT. But that's about it.
&gt; They key insight is that A itself may be inlined elsewhere, which in effect creates additional callsites to B. So B is no longer a single callsite. If you inline something you need to update your callsite count statistics right :) Lets do an example: Suppose C calls A, D calls a, and A calls B. C------&gt;A------&gt;B / / D If we inline A into C and D, then we have C-----&gt;B / / D So now we have two calls to B, so the 'one-callsite' heuristic doesn't apply to B. no problem here. Ok lets take the original code and inline B into A: C-----&gt;B (with A's body inlined into the body of B) / / D At this point we have two callsites to B, and B is presumably a large function now (since it has A's body embedded in it). So B therefore probably won't be inlined into C and D. So no problem here either.
We process functions bottom up: B is compiled before A, A is compiled before C and D. So when we're making these decisions we don't yet know these values. If we compiled top down (CDAB), then we would have truly accurate info about single callsite, and could make the best decision as you describe. But we don't, because there are many other advantages to bottom up order - mostly for inlining, ironically. Outside of single callsite, it's very very nice to know a lot about the function you're about to inline (how big is it, what parameters it uses in branches, etc). Not great in this case, but overall the benefits of BU compilation order far outweigh the benefits of TD order. 
Sure, I get that it's bottom up. But if we inline B into A, this is likely to be a good thing, because we have eliminated the overhead of the call etc.. So why would it not be done?
This looks like it could be a really useful tool! If there's decent visualization tools (even just an easy way to draw an image), it could be really useful for playing around with scientific computing techniques.
At that point you're we're just talking about the regular inline heuristic. There are many many reasons by we may choose to inline B or not inline B into A. Typically there is a growth cap on A. There is a separate size score and speed score, and thresholds they have to hit. Calculating the score for speed especially is much more complicated than one would think. It looks at hundreds of different things at this point, each applying a small bonus or penalty. The single callsite thing is just one small part of it.
Maybe I missed something but it doesn't seem to support **sparse** tensor.
What about this updated version instead of the EDIT: https://godbolt.org/g/e9d8xX
I couldn't find **tensor** in the cuSPARSE [documentation](http://docs.nvidia.com/cuda/cusparse/index.html), neither in [ViennaCL's](http://viennacl.sourceforge.net/pyviennacl/doc/) :(
If B only has a single callsite (in A), then we will definitely be reducing code size by inlining B into A (in a greed algorithm sense at least), and avoiding the call overhead. (B will be able to be removed of course) I'm not sure why you would have size caps (or growth caps) (O(n^2) behaviour on function size algorithms in your optimisers?).
Ah fuck, do you really need n-dimensional sparse tensors? That sucks. I don't think you're going to find that generally available.
I'm not sure how else to explain it. B will not necessarily be able to be removed, that's the whole problem. If A is inlined into other functions, those other functions will now contain calls to B, and B will need to stay in the binary as it's referenced. We can then of course inline B into A into those other functions, but at that point you're clearly a codesize loss. Inlining is recursive, and goes through many levels - it operates on entire call trees. In addition to removing callsites, it creates additional callsites as well from the functions it inlines but we don't recurse on.
Maybe we have some kind of terminology confusion going on. If B is inlined into A, then the resulting A will *not* contain a call to B. Therefore, if the only call to B was in A, there will be *no* calls remaining to B, correct?
Correct. But if Foo calls A, and Foo inlines A, then Foo now contains a call to B. And so on, up to 10, 15, or even 20 levels. Recursive inlining.
Tensorflow is based on Eigen tensor module, which I thought doesn't support sparsity, thus I didn't look into it. But you are right: there is indeed a [sparse tensor module](https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/util/sparse) in Tensorflow. Not sure if it is optimized though. Thanks.
Ok but by the time Foo is considering inlining A, A will have had the call to B in it removed, right? Surely your inliner inlines the changed version of A that has B inlined in it, not the original A?
We inline the original A. Inline decisions in VC++ are based off of the original function, and we can make different decisions in different contexts. It's a better (but slower) way to do it.
I dont know anything about how is life in c++ side of TF, but using it from python interface worked pretty well. 
Yes I do need n-dimensional sparse tensors :(
Ah ok. This is the source of the confusion. Do you have any references or anything on why inlining the original function is better? Seems pretty weird to me.
Also I'd like to point out: what you describe is just an implementation detail. Let's say Foo/Bar/Baz all call A. And B is forced into A because of single callsite. Now if you inline A into Foo/Bar/Baz, you still have 3 copies of B... you didn't save anything on size. You still need to think about the recursive case for single callsite. It's unavoidable.
You have more options. You can always simply "redo" the decisions in the top level function, of course. So I think it's self evident that from a code quality point of view, it's at least "as good" as directly inlining the optimized functions. The idea is with additional context (what parameters are constant, primarily) perhaps you will make different/better decisions. Problem is you might end up duplicating work, which can be slower. Another problem with inlining optimized functions is that means you have to keep them around - it uses much more memory. We reread unoptimized functions back from disk, just like the first time we compiled it.
&gt; Now if you inline A into Foo/Bar/Baz, you still have 3 copies of B... you didn't save anything on size. Sure, so that's why you don't inline A into Foo/Bar/Baz.
Guess you've got a new library project now, don't you. :P
Ah, sorry, I missed sparseness requirement. 
&gt; So I think it's self evident that from a code quality point of view, it's at least "as good" as directly inlining the optimized functions. Yeah that makes sense. In theory having more choices can only be good for the resulting code perf. Still not sure I would add to my compiler, as you hinted, it could greatly increase code time, and you will miss optimisations like the one-call-site benefit of potentially removing functions if you're not careful (like VS seems to miss)
Too big for me at this time :p
Maybe I should consider switching to Python for my project. I'm not yet a Tensorflow user but I heard that its C++ API is badly documented.
That sucks though. What if inlining A into Foo/Bar/Baz would have been really awesome (perhaps some constant folding would have happened from the parameters to A into the body of A, unrelated to B) but we don't do it now because A is too big since we forced B into it? Seems like it'd kind of be nice to make different inline decisions in different contexts...
why limit yourself to one tool?
I think the answer is "it was originally written that way 30 years ago" We don't miss the one call site inlining heuristic, there are design choices made here (...recursive inlining) that have us pass on it sometimes. We are intentionally conservative because one-call-site, in reality, tends to not actually exist: and people who think it exist aren't thinking of recursive inlining.
Well in general something awesome *could* have happened. Optimal inlining is probably NP-complete (exponential time). You are always going to have to compromise, and the most reasonable compromise I think is a greedy algorithm.
But it does exist, the reason I wrote the blog post was a function with one callsite, and inlining it gave ~8% perf increase overall.
I'm looking for the most comprehensive tool to start with, then add additional tools as we go. We need to get corporate approval for large purchases (assuming at least one of the tools is a commercial solution) and with a large number of developers worldwide, if it's a license per developer that quickly gets pricey.
Well, TF (like almost all ml libs) is designed to be vastly used within wrapper. I can assure you, that TF python documentation is divine and the community is super nice and active, so you're unlikely to hate this decision:)
Yes, backlog is a problem when getting started...my eventual idea was to have a baseline output from the static analysis, then diff that with our nightly build (or maybe CI builds if done quickly enough) and generate errors for developers based on that, but that's a bit of a longer-term goal, first I just want to get the team(s) using the tool(s),
Time's out here. I'm in Poland, maybe there's a load balancing issue? What's the final server IP?
We have cppcheck and Clang-Tidy, integrated in VS and Jenkins. For Clang-Tidy there's a pretty good VS plugin I found actually in this subreddit. Both tools are pretty straightforward to integrate. Clang-Tidy has a pretty good focus on modern C++ and for many rules there's a -fix option, which fixes the issues right away. I improved with Tidy a pretty old code base, which had many, many old C constructs. We have some PCLint licenses laying around unused, because it's just such a big PITA to get it configured and running.
Even though it doesn't compile with Clang, the Clang-Tidy checks are still very useful.
Btw, I just had a peek at Clang's inliner. Some interesting tidbits: if (OnlyOneCallAndLocalLinkage) Cost += InlineConstants::LastCallToStaticBonus; and namespace InlineConstants { // Various magic constants used to adjust heuristics. const int InstrCost = 5; const int IndirectCallThreshold = 100; const int CallPenalty = 25; const int LastCallToStaticBonus = -15000; const int ColdccPenalty = 2000; const int NoreturnPenalty = 10000; /// Do not inline functions which allocate this many bytes on the stack /// when the caller is recursive. const unsigned TotalAllocaSizeRecursiveCaller = 1024; } This is from llvm 3.4 trunk in lib\Analysis\IPA\InlineCost.cpp
"Not too easy to use" is quite an understatement.
Go for the free tools and when you have fixed all the warnings you can think about buying another one ;-)
I've heard people talk about Jupiter Notebooks but never looked into them. What exactly is so great about them?
great! thanks for the link! I'm also from Poland... hmmm... what's wrong with our country? :D
I don't have a number, but: "A lot". But it is very good though.. few false positives It depends on LOC..
Jupyter is super useful for quick &amp; simple data analysis, like when you want to play with some open API. I never use any visualisation personally.
They are great for scripting prototyping. Let's say you are experimenting with some algorithms and need to load config files or large inputs before you can execute them EVERY TIME you make a slight change in the algorithm's implementation. Jupiter can be used to only re-execute the last lines you just changed, which can save a lot of time. &amp;nbsp; However, I'm very skeptical if this will ever find practical usage in the C++ community. It's like adding racing wheels to your airplane.
Thanks for the explanation. Seems like something that would be very cool with scripting languages. 
It is like mathematica You get an interpreter, but everything you type is stored as blocks you can individually execute and manipulate.
Im in the Netherlands, so its not Europe related i presume
Imho it is a very bad example though. The important part about TSAan is that it not only detects actual data corruption, but any data race according to the c++ standard. Otherwise it would be pretty useless, because in many scenarios you won't see any actual data corruption ever (for a given platform+toolchain combination) or only when you run long stress tests.
CPPCheck works well on windows and can directly open your visual studio project files. There is also a visual studio plugin for clang-tidy [here](https://marketplace.visualstudio.com/items?itemName=vs-publisher-690586.ClangPowerTools) which works well and you do not need to use clang as a compiler.
The rich display mechanism of the Jupyter protocol is supported. Also check the xwidgets and xplot projects (still at an early stage of development), the C++ backend for ipywidget and bqplot.
I don't see the problem that you're trying to solve here.
Enable std::forward&lt;T&gt;(t) without &lt;T&gt;?
&gt; would be it is Jupiter for python is a very common tool since (uhh...some) years. You can [try it online](https://try.jupyter.org/). E.g when working with tensorflow, I feel like it's a must-have for prototyping. Many tutorials use it, because you can integrate other stuff like markdown between the code.
Glad you liked, have fun with live reloading! :)
Looks interesting. How good is the diff algorithm in CodeChecker? E.g. if a function gets moved from one file to another (or to some other part of the same file), do errors in that function show up as resolved/new or does it detect them as the same error?
There isn't an industry standard, although as you've seen, there are a number of options available. I haven't really found one I like, but the one I hate the least so far is [served](https://github.com/datasift/served). It matches my criteria of actually working, fairly easy to use and to get to do what I want it to. It uses lambdas for its handlers, so it would be very easy to have a lot of copypasta in your server endpoint code if you're not careful. It doesn't include serialization, so you'll have to handle that on your own. Again, I haven't run across a serialization library I particularly like, but I can get the results I need with boost's ptrees. FWIW, you could probably instrument your server into python with boost::python. Add a server query API in the C++ python library so you can access the REST data via python. Then you can do your high performance computing in C++ threads in the background while your python code slowly ponders whatever it needs to do next. I'm doing realtime video analysis with a custom ffmpeg library and this works fantastically well.
i believe we got it for around $10k/year for 5 users/licences
Check out this repo https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python for a great example of its usefulness. It is very impressive. Basically the notebook is a step by step manual to dynamic modeling, all in Python, and all in an interactive shell.
no sure on industry standard but i have toyed with [crow](https://github.com/ipkn/crow). its simple and also header only
I'm so happy to learn about Cling++ and support for C++ in Jupyter. I've been programming in C++ for about 20 years. For data science, my go-to language is R. I'm a big fan of RMarkdown. I've been planning to learn Python because it's clearly a popular choice for data science and because of Jupyter. Although I love C++ as a language, its compiled nature, which is wonderful for performance, limited it in applications where an interpreted language like R or Python excelled. Cling++ gives C++ the best of interpreted and compiled languages.
I ran "Microsoft All Rules" on all my code and it helped me find a couple bugs. With that and /W4 it detects most stupid shit I did before it breaks anything.
OCLint is another tool not mentioned http://oclint.org/
The same offer was made to libc++.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/7gjrad/basiccompiler_issues/dqjm11g/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Have a look at [RESTinio](https://www.reddit.com/r/cpp/comments/6imm43/restinio_02_a_small_headeronly_library_for_rest/). 
Usually just making it hard to look for it in a disassembler is good enough. You're never going to get great safety with this since you need to be able to decode it anyway.
1) you shift the responsibility of forwarding the arguments to the callee instead of the caller. This would mean that before calling a function you'd need to check if it uses you thingy to know if you need of not to forward you arguments : More pain, more complexity. 2) on a syntax level it's awful and the meaning you're giving it is less than obvious. 3) We don't need more complex and backwards rules; T&amp;&amp; is an universal reference not an rvalue reference btw. 4) the future proposal forum is a better place to post such a thing. 5) replacing std::forward&lt;T&gt;(x) with std::forward(x) is a big enough gain.
How about keeping the web server in Python/flask and offload CPU intensive tasks to a C++ application with RPC - I have done something similar with gRPC
Nice.
There are really no "industry standards" when it comes to C++, other than the C++ standard itself.
And it's a link on the latest version: [restinio-0.3](https://bitbucket.org/sobjectizerteam/restinio-0.3). By the way 0.4 is on its way, also it will be released along with benchmarks comparing for most popular libs for REST.
On our embedded devices we have used [cpprestsdk](https://github.com/Microsoft/cpprestsdk) for 2-3 years and we are very pleased with the stability and the programming model they offer. The core is c++11, very modern, well designed, tested, supports many compilers and OSes, and finally they are very responsive in bugs. Some testomonials here, mention that isn't the fastest engine around, but as I mentioned, it works in a very low end processor @600MHz so we are very happy with it. 
Were you using it for http-client? or for http-server? If the latter, then did you face the issue: [http_listener default thread count - 40 threads](https://github.com/Microsoft/cpprestsdk/issues/428). 40 threads for limited hardware looks like too much.
Wow, 600MHz is "very low end" nowadays? :-).
with only L1 cache 32K :-) 
We using it for http-server implementing around ~100 REST APIs. Initally, we had the same concerns, but actual use cases proved us wrong and the stress tests revealed that the system is working very smooth. But as I mentioned the requirements are different in this low end device.
Also proposed to LLVM? So it won't be devalued with LGPL?
So it won't be devalued with LGPL?
The code is released under Apache-2.0. 
Good move by Intel. Here is hoping the next step will be to offer Intel C++ to open source developers (like build system authors) under a sane license.
I am not sure exactly why you are asserting that the "bar is placed an order of magnitude higher than other languages", with no measurable evidence.
Something similar, but a bit more sophisticated used in the cheats development community: https://github.com/qis/xorstr
Common anti-cheat engines have no problems decrypting it. You need some kind of random number. (See other comment.)
I stated the evidence in my first two paragraphs...
When will you update it to the current standard?
Does anybody knows what happens to normal license code when it gets offered to abomination license codebase?
&gt;industry standard THIS IS C++! *kicks op in to the pit* 
Bear with me: re-quote the evidence for the &gt; bar is placed an order of magnitude higher than other languages 
&gt; you'd see meaningless information and need to go to the definition of Sortable to get what you really need Such is the life of a programmer. Once you learn it though, you won't need to look it up again
Have a look at [acorn](https://github.com/includeos/acorn) from the includeos project which mimics the node express API. Great video [here](https://channel9.msdn.com/Events/CPP/CppCon-2016/CppCon-2016-Alfred-Bratterud-include-os-from-bootloader-to-REST-API-with-the-new-C) from cppcon 2016 introducing the some includeos project
This is really a fantastic tool! It could be used in scientific research, teaching and learning of C++!
I am not willing to play linguistic games with you. Either my quotes are contextually appropriate excerpts of an honest, informative assessment, or you should be telling me how either I've misunderstood the text or how the author has made an incorrect judgement. Either my analogy to my direct observations of people's use of traits in Rust to solve the same problem as I see concepts being used for is accurate and fair, or you should be telling me why I have misunderstood the goals of C++'s concepts or otherwise been inaccurate in my assessment. 
 Is there a brief guide for installation? I want to try it, but it seems to setup the environment is frustrated
Constexpr function is not guaranteed to be called at compile time unless you save it with constexpr value.
That looks awesome. I could see myself prototyping all kinds of stuff in an interactive way before pouring it into a cpp file.
As a copyright holder you can release your code under as many licenses as you want. That's why there's a lot of software that is both GPL and a (paid for) commercial license. 
Is there a reason you want to integrate both your computation and your response server into one process? This seems like a poor design choice to me. If anything, even if it was c++ all the way, you would want to separate those out and have a system of futures/async to do the processing in a background process that you then get the results for. Your server itself shouldn't be tied to that. Reasons: * What if your server isn't async? Now every request is potentially blocking. * what if your server is async but it crashes? Or what if the computation process crashes? You'd take down all other active computations and the response server in one go. * It increases your application responsibility quite a bit. Anyway, even if you stick to just c++ I'd recommend breaking those bits out. However, since you are already doing that, why not make a flask or other server in Python that calls out to a c++ process async and returns the results. It would be much easier to maintain and use imho.
Thank you. &gt; 1) you shift the responsibility of forwarding the arguments to the callee instead of the caller Well, nothing is actually being forwarded anywhere. In case of `lvrefun(c)`: although `T` is deduced as `int&amp;&amp;`, `c` is still taken by `int&amp;`, it is not being moved or forwarded. And if you try to shove `c` into `rvrefun`, you'll get an error, because `c` is not an rvalue. &gt; This would mean that before calling a function you'd need to check if it uses you thingy to know if you need of not to forward you arguments Nothing's forwarded - no need to check :), but i want to point out that we, right now, can have a functions that take their arguments by lvalue references, and then they can call `std::move` on them, so all our objects are moved somewhere and so - we can't trust any function. &gt; 2) on a syntax level it's awful and the meaning you're giving it is less than obvious. 3) We don't need more complex and backwards rules I may have over-complicated it a little. Can be simpler. Regarding obviousness - it's C++, nothing's ever simple and obvious. &gt; T&amp;&amp; is an universal reference not an rvalue reference btw. Sure, but that does not comes out inherently from some language rules. Standard explicitly says something like: "Parameter of a template function of type 'rvalue-reference to cv-unqualified T' - is a forwarding reference" and, `decltype(T&amp;&amp;)` is not a `T&amp;&amp;`. Who said that should be the same? &gt; 4) the future proposal forum is a better place to post such a thing I guess i hoped for this to not be treated as an actual proposal. Maybe someone would've got some other ideas from this. Maybe someone would've seen other use cases for such a feature, so if proposed, there'd be something else than just `std::forward` to back it up.
Unfortunately, there is no perfect solution here. In case the code is moved around in the same file or put it in another file, or you even do some whitespace changes it should detect it as the same error. If you rename a variable in the same expression, it will fail to recognize this as the same. 
I agree. The best ROI is to first fix issues found by free tools. Ask for a trial run after you no longer have interesting results from free tools to see if it is worth to invest in commercial tools.
The main issue I see with this is that theres no automated way to update the size if it does change. And what if the size is different on different platforms? E.g if the impl is platform dependent based on `_WIN32` etc preprocessor symbols
Have a look at [tntnet](http://www.tntnet.org/) which should provide everything you need on Linux. In the demo repo is and REST example for you: https://github.com/maekitalo/tntnet/tree/master/demo/
Have a look at [tntnet](http://www.tntnet.org/) which should provide everything you need on Linux. In the demo repo is and REST example for you: https://github.com/maekitalo/tntnet/tree/master/demo/
I want it to ROT13 the strings.
I love KDevelop. The autocompletion is nice, and highlighting is great. It will highlight each local variable with a different color, and desambiguate between class members and other local, even if they have the same name. However, this is an IDE. kate is the editor pay, shipped separately, but kate don't have the advanced highlighting.
vim or Sublime Text
Low quality troll/bait, try harder. Libstdc++ isn't LGPL anyway.
Of course not, that would be stupid. You don't need to be scared of imaginary monsters.
&gt; Though I know both these programs are pretty old and didn't know if there were more modern solutions for my needs. Most IDEs have a VIM-like input method if that's what you're after. e.g. QtCreator's FakeVIM.
SublimeText 3. If you like vim, you can get the Vintageous plugin that pretty much just-works with Sublime (a few control-key mappings are wonky). 
Well, Beast just landed into BOOST-1.66. AFAIK, it is considered to be a test implementation for inclusion into standard C++. Otherwise cppnetlib or Casablanca (aka cpprestsdk) might be of interest
&gt; How is this thing different? FastPimpl requires a proxy. You would have to implement all the functions in your class twice (one in MyClass, one in MyClassImpl) or clutter class code with 'm_impl-&gt;' or similar for each member access. &gt; The main issue I see with this is that theres no automated way to update the size if it does change. In practice this is not such a big problem. Whenever class type changes, you will get compilation error informing you what is the actual size of forwarded class. This is very rare case, especially if you're only using FwdMember for classes which are more or less stabilized. &gt; And what if the size is different on different platforms? You can simply give type_size&lt;&gt; a different value on each platform.
We are also looking into Beast. Does anyone have any experience with it? How easy it is to enable SSL/TLS for example?
vim or atom/sublime with vim mode
ICC is available for free to open source developers (https://software.intel.com/en-us/qualify-for-free-software/opensourcecontributor). Is there a problem with the license that I'm unaware of? The only real downside is you have to fill out a small form, but we give it out pretty freely.
Apache 2 isn't compatible with either libc++ or libstdc++'s licenses (it requires attribution in binary forms which the standard libraries can't require of their customers) so if Intel is making this offer there's probably licensing stuff going on.
The form is not a problem. These are: 1. License server (heinous flexlm) that phones home on each invocation. This makes it really cumbersome to use for CI. 2. License expires at any time (normally when the next version is release but there is no guarantees). In our case (build system) this is a deal breaker since we cannot suddenly loose the ability to test support for older compilers. 3. Only Linux. Again, in out case, we would want to support Windows as well. 4. Non-commercial clause is problematic since for many of us contributing to open source project is part of the job. Also, I've written twice to noncomsoftware@intel.com about these issues but never heard anything back.
Off-topic.
Thank you for your feedback, I'll pass this onto our marketing team (who makes the licensing decisions). FWIW, our 'long term' plans are going to fix #1 and #2. There are plans to switch to a 'support' model instead of a licensing model. That should likely fix #3 too. As for #4, I'm no lawyer, but I believe as long as the software you're developing is OSS and not being sold directly by your company, you're fine. Thank you very much for your feedback!
Why are you looking to switch? I mainly use Visual Studio for C++ and it's a great IDE. Are you on a low power machine, or looking for features that aren't in VS?
QtCreator (free), Visual Studio Code (free), Visual Studio Community (free), CLion (commercial), many others... At work VS2017 (Professional) + ReSharper++ At home - CLion by once in a while, for Qt specific (usually example) - QtCreator with all the Qt SDK installed (Windows) is the way to explore. 
Glad to hear there are plans to improve things. &gt; As for #4, I'm no lawyer, but I believe as long as the software you're developing is OSS and not being sold directly by your company, you're fine. I believe this contradicts what the FAQ says: *The Non-Commercial license allows you to use Intel(R) Software Development Products for any of your development needs as long you are not compensated in any form for the products, software and/or services developed.* In this case I take *you* to mean *qualified open source contributor*, as in me personally. And I am compensated for the development of open source software.
Again, not a lawyer :) I'll have to get back to you when I hear back from my internal email. My non-lawyer interpretation would be that your company would be the 'you'? *shrug*, I'll let you know if I hear anything.
Will this introduce additional library dependencies?
(Kate)[http://Kälte-Editor.org]
Are you sure this is legal? I always get frightened when different parts of my program see different definitions for the same entity.
We just started to use Beast and so far im very happy with it. Im a long time asio user but only recently started to use it with coroutines. Must say ive never found network programming so straight forward. I was just looking at SSL/TLS this week, haven't yet actually used it, but the examples look quite straight forward as well: https://github.com/boostorg/beast/blob/develop/example/http/client/coro-ssl/http_client_coro_ssl.cpp
Thanks, appreciate your help on this.
I have had success in using vim/neovim with the youcompleteme plugin. When writing code from scratch I very much prefer it over any IDE. You are not gonna get as many features as VS, but the features you do get works much nicer, imo. The autocomplete is much less cumbersome than VS
Thanks for your input, we've been looking at it because of it relatively "low" requirements (only C++11) to replace POCO which we have been using. I feel that using POCO in our case is a bit too much overhead and was looking for something leaner. There was a lot of hesitation because we do not have a lot of experience with boos or asio.
I suppose one could use static_assert's, but it would still be a pain in maintenance. 
emacs + rtags works pretty well except for auto completion. semantic auto completion in C++ is pretty though and rtags is not great at it. text based completion in emacs works fairly well. you might want to also look at VSCode and the recent LSP plugin which I read is pretty good.
If this violates ODR (I did not check thoroughly if this does or not, but I *suspect* it does!) this is completely illegal and will break in creative ways depending on cool "interesting" details of your compilation chain you would rather prefer not knowing anything about. This will break even more as this involves templates, which trigger the most amount of black magic e.g. under a GNU system using ELF, so that the standard is actually respected provided you *don't* violate ODR. (Not that I recommend to do that kind of trick without template either...) 
&gt; pretty much everything without a mouse What are you doing with Visual Studio with a mouse that you'd rather without a mouse?
Is CLion better than VS + Resharper++ or do you just not have the licenses outside of work?
To add another data point: I am a PhD student and paid fully by the research institute I am employed at. We only develop open source (scientific HPC) software. Our internal IT warned us that we are not covered by most non-commercial licenses, even though there is no monetary gain. We actually have institute wide licenses for ICC, but it always seemed to awkward, heavy and not worth the effort. Ideally I could just install icc with apt-get (some non-free source wold be fine) and also linuxbrew. I would be very happy to integrate ICC into our continuous integration, write documentation for our users on how to compile our software with it, benchmark it for future releases, etc.
I loved using TBB since the first time I encountered it and seeing it being used for PSTL is just a testament to how well it works.
Or have it actually work. On OSX, the Intel compiler crashes and burns on anything but the most trivial program because it relies on system headers and the intel compiler is horribly regressive.
Atom works like a charm with the right plugins. Autocomplete, type deduction, outline, even debug is possible. Check nuclide plugin.
Mine is here: https://github.com/dicroce/webbie Support ssl (via cppkit ck_ssl_socket). Check out this unit test to see how it works: https://github.com/dicroce/webbie/blob/master/ut/source/client_response_test.cpp
Thanks for your feedback, I'll pass it on as well!
Maybe whoever wrote that didn't have enough bytes to spare. &gt; The expression **a &lt;=&gt; b** returns an object **c** that can be compared against **0**. If **a &lt; b** then **c &lt; 0**, if **a &gt; b** then **c &gt; 0**, and if **a == b** then **c == 0**. 
&gt; Visual Studio for C++ and it's a great IDE I would say 'was'. Every iteration is slower and more bloated with extra lag in the interface. Crazy quirks like the linker options scroll bar always starting in the middle and the GUI file dialogs putting relative paths into places that only accept absolute paths (or vice versa) have persisted for years and years. 
There is an editor called juicpp but I have not tried it personally.
Easier than this? web_server&lt;ck_socket&gt; appServer(8080); appServer.add_route(METHOD_GET, "/foo", [&amp;cfg](const web_server&lt;ck_socket&gt;&amp; ws, ck_buffered_socket&lt;ck_socket&gt;&amp; conn, const server_request&amp; request)-&gt;server_response{ server_response r; r.set_content_type("application/json"); r.set_body("{ \"foo\": [] }"); return r; }); appServer.start();
I would like to try this!!!! How do I install?
I mean if you only need to return a simple json. But that's severely underselling the amount of stuff django/flask take care of for you, as well as all the tooling that comes with pythons stdlib vs c++ Yes it can all be done in C++ but I don't think I'd argue C++ is easier. Anyway my point to a monolithic architecture still stands
Exactly. Also, the more I program, the more I want things simple. Like a simple .bat file to build my program. In visual studio, everything is hidden away in so many different UI settings and things that it makes it difficult to make changes to your project/build environment. 
I got a first bit of feedback from the Compiler Support team, and was told the following: The compiler does not “phone home” to check licensing on each compiler invocation. We do have a Software Improvement Program that the customer opts in to participate and that does transmit data back to Intel. This article, https://software.intel.com/en-us/articles/data-collection, explains our data collection The rest is otherwise being discussed internally. Thanks!
There is actually a native, standalone version of clang-tidy for windows (although, I believe it uses the msvc standard library)
&gt; n a simple json. But that's severely underselling the amount of stuff django/flask take care of for you, as well as all the tooling that comes with pythons stdlib vs c++ &gt; Yes it can all be done in C++ but I don't think I'd argue C++ is easier. &gt; Anyway my point to a monolithic architecture still stands In my experience, the sweet spot for libs like this are not full feature webservers... its simply rest/json api's running on iot devices.
If you run into crashes, we'd love it if you could report them for us. A member of my team DOES keep an eye on the support forums, but there are other ways to let us know! https://software.intel.com/en-us/support
&lt;what&gt; &lt;are&gt; you even talking about &lt;/are&gt; &lt;/what&gt;
it sounds like intel's implementation uses tbb as a backend, but i doubt libc++/libstdc++ would ship with that
/u/playmer We've fixed the that IntelliSense issue and it should show up in a later release. I've left a comment on the Developer Community page with some info about a workaround.
Come on, the title is a troll attempt/bait. Says nothing about LLVM getting the same offer. Smells like the struggle of a hopefully dying stdlib to stay relevant.
Show me on this doll where libstdc++ touched you.
Configuration of PC-lint/FlexeLint can certainly be a daunting task for larger projects and new users not familiar with the product. PC-lint *Plus* ships with an automated configuration tool that requires virtually no knowledge of the product and generates a configuration based on information collected during your build process. If you are compiling with a relatively recent version of Visual Studio (2010 or later) or a clang or GCC derived compiler, you can have PC-lint Plus configured for your project and ready to go in a matter of minutes plus however long it takes to build your project (depending on your build system, it may not even be necessary to actually invoke the compiler so the "build" step could be a few seconds). We are also offering a fully functional 30-day evaluation for PC-lint Plus (which wasn't the case for PC-lint) so you can try it out and see how well the new configuration works for yourself.
Yes, in the linked email they promise to relicense to an appropriate license if their proposition is accepted.
Jetbrains is a great company. The amount of stuff that CLion catches that [insert tons of editors I've used over the past 7-8 years here] does not catch is unbelievable. I would pay for CLion... I _hate saying_ because I really would. I hate the subscription model for obvious reasons but the introspection it gives makes me hate going to VS2017 now... which used to not be the case.
Does CLion use it's own C++ parser or does it use something like libClang?
&gt; If you're multi-threading, -fsanitize=thread can detect data races for you Today is a good day for mankind.
If you decide to evaluate PC-lint Plus, hopefully you will find it easier to use. We improved diagnostics, added a built-in help system, removed obsolete options, and included an automated project configuration tool that generates a configuration using information from your build process (see my comment [here](https://www.reddit.com/r/cpp/comments/7gaz9j/best_static_code_analysis_tools/dqkzdw3/)).
&gt; So, I work on a game engine in my spare time This is the best trial by fire method for C++, I learned so much by doing this.
I don’t know why you prefer text editors over IDEs, but I strongly recommend you to try Qt Creator. For me it’s simply the best C++ IDE. 
Thanks. I think I’m joining the community soon :-)
Their subscription model is really interesting. You end up getting a perpetual license, but then also pay for certain updates. It’s probably the most fair I’ve seen. When you stop paying, you still get a stand-alone copy that just stops receiving updates. At least that’s what it was last I heard.
Thanks for the answers! Along these lines, I've long been interested in using the free version of ICC at home (I use it at work and like it very much). But I've long been stopped by the "Actively contribute to an open source project, such as GitHub*" line under "Qualifications" in the link you originally mentioned. Likewise, [these](https://software.intel.com/en-us/articles/open-source-contributor-faq) [pages](https://software.intel.com/en-us/parallel-studio-xe/choose-download#open-source-contributors) seem to imply a requirement that it be used for contributions to major open source projects. Most of the code that I write at home is for personal projects or for personal experimentation and learning rather than contributions to significant open source projects. The [third answer on this other FAQ](https://software.intel.com/en-us/articles/non-commercial-software-faq/#3), however, (reached from the [registration](https://registrationcenter.intel.com/en/forms/?licensetype=2&amp;programID=opensource&amp;productid=2302) link) suggests that this use would be covered. So in clicking around, there seems to be some muddiness on whether these are offered for all "non-commercial" or only "open source contributor" use. If you could get someone to clarify which one applies, I'd very much appreciate it (even better if someone updates the web pages)!
Come on now, libstdc++ if anything is [the one GNU library that goes out of its way to be usable without GPL lock-in](https://gcc.gnu.org/onlinedocs/libstdc++/manual/license.html). The language is made better by competing implementations that expose bugs in the spec, and in each other; please don't antagonize those who work on that.
if you know a little git, cmake and basic commands for your compiler, then it is relatively easy to build the whole setup. there are not a lot of examples, but it comes with 1 webgl example which compiles a c++ source file to a javascript file and you open an html file already present in the folder to see the example run. It uses clang 3.7 i believe, and comes with a cmake toolchain file to make building easier.
Sadly, I don't really see anything that applies for your situation. It seems our license agreement is wide enough to allow it, but I don't see any place where we grant non-commerical license for non-student/educator/OSS developers. Hopefully when we switch to a different sales model in the near future, you'll be covered there.
it uses an **optimizing** c++ compiler, which can statically analyze your code and make many optimizations that a human would either not think of or not want to implement in every case. Obviously this is limited by how much you can optimize javascript. I think a fair assumption is that it **can** but **not always** achieves a 1:1 with the most optimized javascript version of the same code
it uses an **optimizing** c++ compiler, which can statically analyze your code and make many optimizations that a human would either not think of or not want to implement in every case. Obviously this is limited by how much you can optimize javascript. I think a fair assumption is that it **can** but **not always** achieves a 1:1 with the most optimized javascript version of the same code
`template &lt;typename T&gt; drawable(T&amp;&amp; impl) : m_impl(new model_t&lt;T&gt;(std::forward&lt;T&gt;(impl))) {}` This doesn't look right. Given an lvalue of type `X`, it'll construct `model_t&lt;X&amp;&gt;`. The constructor and assignment operator also mishandle copy construction and copy assignment (they can outcompete the actual copy ctor/assign for modifiable lvalues).
What kind of embedded devices are you using cpprest on?
I'm just repeating what I remembered from other threads: It uses its own, because libclang isn't very good with working on many files at once.
Yeah, if I only want CLion, I probably wouldn't pay for keeping the updates coming. But I need the pro versions of intellij and pycharm plus datagrip. It's been one of the few services I don't mind keeping. 
Usually this is just to avoid making it completely trivial, you won't get anything safe unless you like query it from a server.
It seems like this is just a value handle (is that the right term?). For example: // First, ordinary runtime polymorphism // struct Drawable { virtual ~Drawable() {} virtual void draw() const = 0; virtual unique_ptr&lt;Drawable&gt; clone() const = 0; }; class Rectangle : public Drawable { public: void draw() const override { cout &lt;&lt; "Rectangle::draw\n"; } unique_ptr&lt;Drawable&gt; clone() const override { return make_unique&lt;Rectangle&gt;(*this); } }; class Circle : public Drawable { public: void draw() const override { cout &lt;&lt; "Circle::draw\n"; } unique_ptr&lt;Drawable&gt; clone() const override { return make_unique&lt;Circle&gt;(*this); } }; // Done with ordinary runtime polymorphism // Now we make a handle class that outwardly looks and behaves like a value // class Drawable_value { unique_ptr&lt;Drawable&gt; impl_; public: Drawable_value() = default; Drawable_value(const Drawable_value&amp; other) : impl_ {other.impl_-&gt;clone()} {} Drawable_value(const Drawable&amp; impl) : impl_ {impl.clone()} {} void draw() const { impl_-&gt;draw(); } }; int main() { vector&lt;Drawable_value&gt; objects; // Looks like a vector of values, but since each value has only one data member -- a // unique_ptr -- this should generate the same code as if we had a vector of unique_ptr objects.push_back(Rectangle{}); // Looks like a value copy, but under the hood calls unique_ptr -&gt; clone() objects.push_back(Circle{}); // Could also implement moves, but I got lazy; this is good enough to make my point for (const auto&amp; o : objects) { o.draw(); } } Now, don't get me wrong, getting value semantics from a polymorphic pointer is nice, and I've used this kind of trick before, but I think it's misleading to advertise this as a way to avoid the "dread" of inheritance. And although smart people do indeed caution against *implementation* inheritance, *interface* inheritance is still kosher. And as for the decoupling... it looks like you had each derived farm out its work to a free function. Which is fine, I guess, but it doesn't seem like the degree of coupling changed all that much. 
I still use emacs -- it's super-fast and my fingers already know emacs (I can get around pretty well in vi, too.) It does have a bit of a learning curve if you don't know your way around it, but at its heart it's a pretty cut-and-dried text editor. For some reason, non-emacs users always freak out when I've got two frames up editing the same file and the changes are reflected immediately in the non-active frame if it's in the same area if the file as where I'm typing. I guess sometimes the little tricks always make for the most gee-whiz factor. It doesn't take much to add tab completion and all that stuff, although honestly I personally prefer not to use it. Having that in there discourages me from remembering those APIs and makes me feel less connected to my code. Just my opinion, though.
I think this article could improve its presentation a bit. In particular, right at the beginning, I think the article should show the code this trick will enable. struct Rectangle { Rectangle(int h, int w) {} }; struct Circle { Circle(int d) {} }; struct Sprite { Sprite(const std::string&amp; path) {} }; void draw(const Rectangle&amp;) { std::cout &lt;&lt; "Drawing rectangle" &lt;&lt; std::endl; } void draw(const Circle&amp;) { std::cout &lt;&lt; "Drawing circle" &lt;&lt; std::endl; } void draw(const Sprite&amp;) { std::cout &lt;&lt; "Drawing sprite" &lt;&lt; std::endl; } int main() { std::vector&lt;drawable&gt; objects; objects.push_back(Rectangle(12, 42)); objects.push_back(Circle(10)); objects.push_back(Sprite("assets/monster.png")); for (const auto&amp; o : objects) draw(o); } Three types with no inheritance relationships. Three free functions. Yet we can push these unrelated types onto a vector seemingly polymorphically, and iterate over them and call each of their respective free functions.
Oh, I didn't realize you avoid that. That is pretty cool! But it seems like it is probably an ODR violation strictly speaking, because name lookup is occuring one way in the .cpp file, and another way for the people who include the header. &gt; If T is fully defined (with template arguments if it's a template) then FwdMemberSelect::type is simply T, otherwise it's a mockup type with same size and alignment. Afaik having a template that detects if its argument is incomplete cannot be done without violating the ODR
Kind of unrelated, but is there a tool to check for memory leaks in Windows that isn't too fiddly? 
Those updates are important. I've seen more than my fair share of "security patch" upgrades from their products, and I'd prefer to not continue running outdated stuff if there's security holes in the software. If I was guaranteed what you said _and_ security upgrades, I would just give them my money now and be done with it.
Thank you! I *do* wish there was a less involved way to report an issue, but when my frustration level gets high enough, I'm sure I'll sign in and go through the process.
There are [Google's sanitizers](https://github.com/google/sanitizers). Only problem is that the classes are implemented as [LLVM Passes](http://llvm.org/docs/WritingAnLLVMPass.html) so you might *have* to use Clang.
Long story short, I had to use IntelliJ while I worked at Google and was doing Java. First I was exposed to Eclipse, and even tried emacs + whatever java plugin there is. I wasn't doing almost any C++ there. Then I quit, but felt in love with IntelliJ products, licensed myself the whole package (all their stuff) for a year (difference between individual and package wasn't that much), and I've been using Rider, CLion on my chromebooks (running crouton), and using google's bazel as build system. Then at work, it's Windows + VS2015/VS2017 and decide to give try to Resharper C++ - the best feature so far is that it detects a lot of things while I'm typing (and I had to freshen up my knowledge of C++, because what I knew, and still to a point was pre C++11). It's not as fast as updating after build, but I give it a time. As for CLion vs Visual Studio + ReSharper - I think CLion is better, but with the bazel integration (I love bazel). But that combination is not sellable to my team-mates, or in general for a Windows oriented company (yet). Another + for CLion is that it's 64-bit app, while VStudio would be kept 32-bit possibly for a long time. So whatever plugins it loads they all need to fit in the 3-3.5GB of RAM (maybe up to 4GB). That's not too much to keep things going, or the plugin/extension must be written as external application. The integration in CLion is more smooth, and I'm used to the keybindings there. In VStudio - it's not bad, but often I have to manually adjust things. Possibly the CLion+bazel won't be good idea for people used to VisualStudio + .sln/.vcxproj files + Windows in general, and vice versa. So far I like it, and plan to buy license for one more year (and it's even cheaper). JetBrains seems to be doing things the right way. 
Qt Creator is my first choice (Linux, Windows) when I have to deal with Qt. No pun, really it's the best integration (haven't found straight solutions for Visual Studio, where .moc files are generated by copy+pasting either the script for doing it, or relying on the plugin, but it as lots of quirks (like assuming that you want to use the QT_DIR env variable, and then you have to replace it)). Since it works on all systems (QtCreator), and can work with all Qt sdks, can open right away the examples - it's my first IDE to try out things out of Qt, and then continue with Visual Studio (one of our apps is heavily using Qt). 
I love CLion! I use it only with bazel, but I can assume their default CMake integration is good! JetBrains certainly makes good products, like YouTrack for example (eat that JIRA) :) And at work I'm using ReSharperC++ + Visual Studio 2015/2017 - helps me a lot while typing :)
http://www.deleaker.com/ https://github.com/milostosic/MTuner and many others...
This is pretty cool, specially for tutorials/education it is fantastic. The only problem I see is how hard I miss vim when using the notebooks.
I just want to mention that if you are a student you get all of their products for free (as long as you have an .edu email of course) which is a sweet deal.
Thanks for the long, informative response! While I mainly use VS to build windows executables, I'm not a huge fan of sln/vcproj files. I'm going to go investigate bazel and other build systems now. Thanks again!
Can you use it with Makefile instead of CMake? Because that's the reason I've never used CLion.
I'll definitely pass that on. 
CNTK might be worth investigating. 
These anti inheritance articles are getting kinda cliche, truth to be told. Yes, Sean Parent's talks on the topic were amazing, but that was years ago. This technique is pretty well known now. Most people would just view this approach and regular inheritance as yet another set of trade-offs to be made, neither strictly superior. Some specific issues I had with the article: &gt; All of our drawable objects must inherit Drawable and implement draw(), which means each of them has to know how to draw itself (or save, or load, or compute or…) which is a clear violation of the principle of separation of concerns1. If draw is specific to that particular object, it's not obvious why this violates separation of concerns. It really depends on the context; sometimes it will violate separation of concerns, sometimes it won't. Separation of concerns is awfully vague anyhow. More concrete is to say that it forces something to be a member function when it may not required privileged access, in which case you would normally prefer a free function. &gt; We can’t have a list (or array or set or…) of our objects, we need a list of Drawable* (or a std::unique_ptr&lt;Drawable&gt;). It prevents us from using most standard algorithms which expect values and not pointers. This is a pretty big exaggeration, almost every standard algorithm takes a lambda; at most it's an extra line to specify the lambda to make it work (e.g. `find` vs `find_if`). &gt; We can’t store them by value, an owning container will have to new each one instead of putting them in a contiguous buffer or on the stack, which is terrible for modern CPUs caches. This issue is quite orthogonal to what's presented here. You can do regular inheritance naively, or you can use an allocator, and you can do Sean Parent style polymorphism naively, or with contiguous memory. I like this technique, but thinking that it's always superior doesn't acknowledge the fact that in many real codebases, often the base and derived classes are owned by the same person, and are quite tightly coupled. And it's not worth paying a bunch of boilerplate or using complex libraries to reduce that coupling, especially when (as very often is the case) the derived class' only purpose is to provide a particular implementation of some interface. The other problem is that this technique and others try to help make it seem like polymorphic objects are normal objects, and hide away these details. The problem is that in C++ at least, this doesn't really work very well, because of the lack of multiple dispatch. You want to use your polymorphic object as a key to a hash table? Okay, let's write out the equality operator, that will be a vomit inducing mixture of RTTI and visitor pattern. Etc.
Am I missing something, or have you discovered templates? (In this case, implicit) 
Wondering the same thing!
I know it's template, template is the way you implement it, I'm saying from the function perspective 
This is what I would call duck typing, arguably not the same as polimorphism, however I see your point. 
That sounds good, because configuration was really difficult and really the reason for us not to use it. Are there any options to upgrade existing licenses to pclint plus?
I'm really impressed with the new integrated Valgrind support. The ability to use it within the editor and see exactly where the problems occur right in the code is going to be immensely useful. I've used Valgrind in the past and it is an amazing tool for finding issues in your code.
Yes, that is static polymorphism (aka templates) in c++. So?
Ok, this must have changed then. My experience from a couple years ago was a noticeable delay on each compiler invocation and an indefinite hang if there is no connectivity. This was using the free license and I don't recall opting-in into any data collection program.
Not yet.
It's not hard to make a cmake file that just calls make, but why would you?
&gt; It's not hard to make a cmake file that just calls make, but why would you? Makefiles are easy, simple, and concise. The CMake stuff I see is so verbose. And it's a lot harder to debug a CMake build going awry than a Makefile build. 
How's qt Integration in clion? 
So?
I think duck typing should be dynamic and templates are structural typing, I do wonder if it's possible to do (real) duck typing in c++, RTTI is definitely not enough for it
My rule of thumb: the standard library needs to include all those bits that have different implementations from one compiler to another, i.e. things like std::atomic or std::thread. Anything else that can be built as a library on top of that should not be part of the std. Those things belong to a central library repository which also includes ratings and reviews. 
So the author set out to solve the following problems: - Each drawable object must contain a drawable function. In his final solution this is still true, but now it is a friend declaration instead of a member. What's the big difference? I'd say it is worse: instead of a single virtual dispatch he now dereferences two pointers (m_impl, and the virtual function in concept_t). - Can't copy-construct or copy-assign: still true. - Can't have arrays of drawables / can't store them by value: technically he 'solved' this, but only by hiding the pointer inside 'drawable'. The actual objects themselves are still allocated on the heap, so there is no performance benefit from having them layed out contiguously. - Code cluttered with new/make_unique: I suppose that's solved, but I have a hard time seeing how that could be a problem, rather than a personal syntactic preference. Those allocations are still there; he's just hidden them carefully. If anything, it invites a programming style in which one uses drawables as values, introducing undesired invisible allocations all over the place. It's all very clever but I have trouble seeing how the things he calls problems are really problems, or how his solution is actually a solution. If anything, all that template code turns a simple and straightforward solution into something that is much more complex, much harder to understand, and less efficient to boot. 
They are available in gcc, too
I think you mean: jucipp (https://github.com/cppit/jucipp)
It's simple and concise as long as it only runs on your machine though.
What's the advantage of obfuscating the types in the structs with the 'self' #define? Is writing the type really such hardship?
Two compilers among many. http://en.cppreference.com/w/cpp/compiler_support
personal preferences, not in the fan club of the nominal type system, I care about what the type can do, I do not care and don't want to know what the type is called 
For me it was opposite: every new version since 2010 work faster and add something useful. And now I find VS 2017 as a really great IDE for my old laptop.
Hmm, interesting. I am normally willing to pay the price of virtual and would use a Visitor instead.
For me it's the opposite. The makefiles I see are massively complex to be able to be cross platform, and are impossible to debug 
If you bothered to read the email [thread](https://gcc.gnu.org/ml/libstdc++/2017-11/msg00113.html)...
They're not available in MinGW-w64. The only distribution of clang I've seen that has them is for integration to Visual Studio :(
Tried it. Needs lots of work since it's very basic right now. Especially the completion context menu should use icons instead of verbose text. I like simple interface design.
From the email: &gt; The implementation is not specific to Intel’s hardware. For thread-level parallelism it uses TBB* (https://www.threadingbuildingblocks.org/) but abstracts it with an internal API which can be implemented on top of other threading/parallel solutions – so it is for the community to decide which ones to use. For SIMD parallelism (unseq, par_unseq) we use #pragma omp simd directives; it is vendor-neutral and does not require any OpenMP runtime support. So, no, it doesn't have to.
Oh, I did. This is why I objected to the deceiving title *here*.