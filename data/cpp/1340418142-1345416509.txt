There are a number of great online tutorial sets. I have the [book](http://www.amazon.com/OpenGL-A-Primer-3rd-Edition/dp/0321398114/ref=sr_1_22?ie=UTF8&amp;qid=1340418022&amp;sr=8-22&amp;keywords=opengl) my roommate used for college classes (inherited because the bookstore wouldn't buy it back from him). I'm a fan of having a book on the desk while I'm working on code examples...maybe I'm weird though.
Thanks, Ill have to check that out. I've been told that one of the hardest parts is just getting it to run with your system and so far that has proven true for me. I screwed around with freeglut a bit before finally giving up earlier in the month. Edit: and I was having a hard time finding a tutorial that was up to date so THANKS
I have been using code::blocks as of late and have been liking it though I started off on Visual Studio. Mainly, (for now at least) I plan to just focus on simple GUIs. After I get that down and have some experience under my belt I might consider moving to simple games.
Also, if you want some fun (I think they're fun) things to play with, search for some examples that were written by Jeff Landers when at Gamasutra. Something like this one: http://www.gamasutra.com/view/feature/3427/collision_response_bouncy_.php Most of his examples are designed for Windows, but use OpenGL. I used to have a good time playing around with them while learning different techniques.
Yeah, please do not use nehe's legacy tutorials, they are horrible. I already wrote a rant why in the reply to dotnofoolin.
I second that, do not use these. Go to /r/opengl and pick out some of the modern GL stuff from the sidebar
Now I dare you to make tuple_iterator, one that can function with standard library algorithms. Kudos if it supports some sort of polymorphism working too (eg if tuple_iterator&lt;const double&gt; could be constructed from a tuple&lt;double, float, int&gt;) 
Use qtcreator. C::B sucks in comparison and VS is not portable. qtcreator looks minimal but it packs a bunch. Also, I'd not recommend going freeglut + glew, that pretty much the old way. Learn modern opengl using the tutorial linked above and use glfw3 to go along with that. Use glew only if you really, really need it.
Recursion might come in handy here: template&lt;class tuple, class iterator&gt; void process(tuple &amp;t, iterator it) { if(it==end(t)) return; cout &lt;&lt; *it &lt;&lt; endl; process(++it); } Not sure if compilers would reliably inline it all, and they certainly wouldn't do TCO if it didn't get inlined. How would you do it in a loop, or with something that looks like the STL? I think the iterator has a different type every iteration, and the processing functions have to be polymorphic too. You'd probably need inheritance and some virtual function calls, and that'd be a pity. (The worst thing is you can't do templated lambdas. Ugh, back to old-style function objects or function pointers or...) I'm definitely going to have a play with the idea when I get time. EDIT: results of my experimentation: Algorithms [over heterogeneous tuples](https://gist.github.com/2982696), and algorithms over [homogeneous tuples](https://gist.github.com/2982976). The former is all static, no heap-allocation, no copying and no inheritance. The latter uses heap-allocation and inheritance, but is (incredibly) STL-compatible. No funny casts anywhere, everything is properly type-checked.
Whilst NeHe know OpenGL his C &amp; C++ are very 'primative'.
IIRC Clay has a "static for", but I don't think it's mature enough for real use. There are a few situations in which it comes in handy, though, the biggest of which for me is keeping vectors homogeneous. At the moment in a game I might have a vector of pointers to various things that could collide (all inheriting from some abstract base class): class Player : public Shape { ... }; class Alien : public Shape { ... }; class Missile : public Shape { ... }; vector&lt;unique_ptr&lt;Shape&gt;&gt; things; for(auto i = begin(things); i+1 != end(things); ++i) { for(auto j = i+1; j != end(things); ++j) { (*i)-&gt;collide(*j); } } But that's not really up to scratch. Every call to `collide` costs extra because of virtual dispatch, and I really want virtual dispatch on both `i` *and* `j`, not just `i`. Much better if I can go tuple&lt;vector&lt;Player&gt;, vector&lt;Alien&gt;, vector&lt;Missile&gt;&gt; things; static_for(auto i = begin(things); i+1 != end(things); ++i) { static_for(auto j = i+1; j != end(things); ++j) { static_if(i=j) { for(auto k = begin(*i); k+1 != end(*i); ++k) { for(auto l = k+1; l != end(*i); ++l) { collide(*k, *l); } } } else { for(auto k = begin(*i); k != end(*i); ++k) { for(auto l = begin(*j); l != end(*j); ++l) { collide(*k, *l); } } } } } Whoa, didn't expect that to be so verbose. Long story short, though, I get to define a specific `collide` method for every Player/Alien/Missile combination, all of my objects are stored by value, not by pointer (meaning traversal over contiguous memory), and best of all there is absolutely no virtual dispatch and no inheritance at all. It should be *a lot* faster.
He will need GLEW. On Windows, you only get functionality above OpenGL 1.2 by loading the functions explicitly with wglGetProcAddress, which can be a lot of work. In order to use the modern pipeline you need GLEW to get functions like glDrawArrays.
That said, I can't fucking find a single up-to-date tutorial. I think I found one at some point, but it was full of Visual Studio specific fuckery and worked on *nothing*.
SFML. SFML is basically an OOP OpenGL layer. You can usually mix OpenGL and SFML in 2D, 3D not so much. In 3D, you can use SFML as a way to open/configure your windows and to load textures/sounds, networking, basically everything but the 2D elements of the graphics part of it. It's cross-platform, too, so there's no platform specific fuckery in any tutorials.
Thats really unfortunate
Yes that's obvious. I'm trying to make sure he isn't using a 64-bit compiler which has *unsigned long* as 8 bytes.
if he was it would have worked edit: I think I confused you with the OP when I told you to look at my links. I want OP to look.
I know that, I'm only trying to demonstrate what we're both telling him, jesus. Edit: And I'm not trying to demonstrate it *to you* because you clearly know what you're talking about. I'm trying to demonstrate it *to the OP.*
&gt;I'm not trying to demonstrate it to you Then stop replying to me and spamming me with notifications.
Ask yourself these questions: 1. What is the largest integral number that can be stored in 32 bits? 2. For the floating point number - what happens here: 0.12345 * 10^6 + 1.0 if there's only 5 digit precision?
I would recommend reading this book: http://www.starstonesoftware.com/OpenGL/ I am exactly in the same situation as you are. This book helped me a lot to understand OpenGL.
11 is 3 in binary because 1 * 1 + 1 * 2 = 3. Edit: formatting
3\. Just don't use floats.
C89 didn't allow you to declare variables in the initialization step. I had a Microsoft compiler once upon a time that was a royal pain in the ass about this, so it's become a habit. Just like sometimes I put newlines at the end of my C# source files...
11 is 2 in unary!
Try *unsigned long long*.
My current job doesn't enforce any kind of style convention. I have a few rules that I use personally though. I kind of adopted *InitialCapsCamelCase* from my previous work with .NET, and so I use that for all publicly callable-accessible code/variables. And I like *lower_case_with_underscores* so I use that for anything private.
There is an easier way to figure out binary. Think of each column as a power of 2, like so: &gt;64 32 16 8 4 2 1 Then you can put a 1 in each column until it adds up to the number you want. So 3 would be &gt;64 32 16 8 4 2 1 &gt; 0 0 0 0 0 1 1 or if you wanted to find 42 &gt; 64 32 16 8 4 2 1 &gt; 0 1 0 1 0 1 0 Unless you were trying to troll me...then 3 is actually 010 in binary because math. =)
I mean use doubles unless you know exactly what you're doing and can guarantee you'll never need much precision or accidentally cause a loss of precision down the road. Edit: relevant reply to ISvengali [here.](http://www.reddit.com/r/cpp/comments/vhfjp/what_is_the_upper_limit_on_for_loop_iterations/c54jksa)
That so? double x = pow(2.0, 53); double y = x + 1.0; double z = y - x; What is the value of z?
Yes, you can also overflow doubles.
Does MinGW support that?
I don't know, been a while since I've used it.
Fair enough. I guess my advice stems from working with other people who may or may not grasp (or care to grasp) the implications of floating point precision. I work with a lot of awesome programmers/computer scientists, but also with a lot of awesome non-software engineers (mechanical, structural, civil, etc.) who sometimes have to write code. Also, I'll admit to being a bit snarky about it.
The WinAPI is C. Apart from that, what aspect of it do you not like?
Microsoft's WPF is a great design with some poor engineering. The things I like about it: * Ability to separate View from Model, see MVVM design pattern * Data is bindable everywhere. Build your view, bind the data model to it and everything updates when you change the model. * Controls by design are look-less. A seperate template is assigned based on the current theme. This lets you have a native theme for each platform, but if you want a custom theme, you can change it without changing the controls. * Everything can be stored in a resource so it can be reused across the design. * Dependency Properties. Nice idea, sucky implementation. Things I don't like about it are: * XAML - XML is not a programming language. However I like declarative (fluent) programming for designing the UI, it makes things much cleaner. * Value Converters - This is what you end up with when you try using XML as a programming language. * Large objects. Like every other GUI toolkit, the classes have a couple dozen fields and methods, half of which you never use. Try to keep the objects small and use traits or policies to add behaviors, not inheritance. WPF has a steep learning curve, but once you get it, it's really nice to work with. Anyone designing a new GUI toolkit should study WPF, both to see what they got right and what they got wrong. 
By the time such a big project is ready for production (and not just tinkering), you'll probably have a C++11 compiler at hand.
The problem is they don't like to give us money (it's a big contract) if "it ain't broke" and we're not adding new features :(
I think serious consideration should be given to [immediate mode GUIs](http://sol.gfxile.net/imgui/). They're not popular, and IIRC there are a few unsolved problems with them, but I'm not sure they've been given a fair go. They effectively let you own the event loop instead of handing control off to a framework. This means that your code works with multiple frameworks on the go, and it means that your code probably isn't a horrible mess of callbacks. As for the actual GUI stuff, I'm not really sure. I don't think they're as important as they used to be because it looks like most users are being prodded into touch interfaces, and visual consistency doesn't count for anything there. I think people care more about how [juicy](http://www.youtube.com/watch?v=Fy0aCDmgnxg) the gui is than how "neat" everything is. Now that desktop Qt has stopped being developed, and Microsoft has been clear that their desktop fallback in Windows 8 is a second-class citizen we're in strange times, and I'm not sure that desktop toolkits have a guaranteed future of ongoing relevance.
Oh my bad, I guess this means nothing then... [Using SDL with OpenGL 2.1](http://lazyfoo.net/SDL_tutorials/lesson36/index.php)
I generally prefer functions with less than 10 arguments.
Afaik integer literals (without suffix) are the smallest type that can hold the value. In this case the literal would 64 bits. I'm not sure if there is a suffix to denote that you want (32-bit) `int` instead. edit: http://ideone.com/l1xqx demonstrates the situation
I'd love to have something minimal (from API perspective). Something that wasn't a huge framework, but instead would just provide GUI toolkit which wouldn't require you to engineer rest of the code to fit it's architechture. Something that could capture the simplicity of just calling `MsgBox("Hello World")` to get a message box. Something that wouldn't require you to explore and extend large class hierarchies to do simple things.
How about calling "this code is now readable and no longer a nightmare of terror" a feature!
Yes, immediate mode GUIs are an interesting concept. It looks really useful for simple GUIs at least. I wonder how it scales to more complicated problems.
As with a lot of languages, the readability of Fortran greatly increases when you get over the initial shock of how strange it looks. After that it isn't too bad, readability-wise. Comments exist, variables can have reasonable names, code is still organised into functions etc. When I used Fortran (not a lot, so take this with a grain of salt) it got silly and verbose mainly when I tried to do things you shouldn't do in Fortran - passing functions to functions, that sort of thing. As long as you're using it as a straight imperative language that operates on simple structures of arrays it's not really as bad as people make out. It *is* old-fashioned, and if you're writing Fortran 77 (as I was) you'll probably have to get used to the SHOUTING, but it's not a joke and it can be maintained by humans if they can be bothered to learn the language. TL;DR: Haters gonna hate. Don't let fashionable prejudice get in the road of proper judgement.
You're hitting the overflow before the iterator reaches that number. A signed int (32-bit architecture assumed) will have a max of 2,147,483,647 and a min of -2,147,483,648. Once you go over the max, you'll flip that sign bit and start counting from the negative value up. Since your loop checks to see if the value is still less than 10,000,000,000 it'll just keep going. You can try assigning 10000000000 to a variable, but the value will be truncated at 32 bits, giving you 1,410,065,408. If you need a larger number, use a larger datatype like unsigned long long. This should give you 64-bits which has a huge max (1.8 x 10^20, or something like that)
google's [skia](https://sites.google.com/site/skiadocs/home) might be a good starting point for the actual underlying graphics framework.
Interesting; I had read that c++ win8 metro was .Net oriented. 
Fortran isn't a terrible language. The latest revision, [Fortran 2008](http://en.wikipedia.org/wiki/Fortran#Fortran_2008), is a pretty nice language actually. Now, I don't know how dakotahawkins' company is using Fortran or if their dependencies on their compiler could be resolved in another manner. But, just don't go trashing on Fortran because your opinions are based on Fortran 77 or earlier.
Well, Fortran does have its drawbacks -- see [the start of this subthread.](http://www.reddit.com/r/cpp/comments/vhm1r/what_is_your_wishlist_for_an_ideal_gui_toolkit/c54n1ai)
Can you elaborate on the scripting part? How does a common base allows you to dynamically use an object (e.g. Call its methods from a script)?
Also, standard types support move semantics, so this became largely a non-issue. Besides, I almost never see Qt code that does not use const references for parameter passing (I've been working with Qt for 3 years). And for return values, we have NRVO in almost all compilers.
As far as I recall, GCC's (as of 4.7, or so I keep reading) libstdc++ still uses COW strings.
That's good to know. What's the clause that says (or implies) so?
Ok, I know I'm missing something, so can someone please explain to me the difference between this and several overloaded example::draw functions? EDIT: Oh wait, I totally missed the "example::drawable" interface, was just concentrating on the ADL stuff. So this is, functionally, something like adding interfaces to classes without needing to inherit from the interface?
Interesting solution! Is there a benefit of using this over things like `boost::variant` or `boost::any`? Regardless, this is really close to algebraic data types as seen in functional programming, and it looks very elegant! Good job. :) EDIT: The only criticism I can come up with is this: Why append '_' to callables? It seems risky and unpredictable (from an API viewpoint).
It looks like this is indeed adding go-style interfaces.
mmm, did not know there was one (n00b ALERT!) trying that now, thanks
Consider this snipped from my GUI toolkit: window_t * window = new window_t( "Window" ); window-&gt;add( new label_t( "Hello World" ) ); And that's all. The window will get automatically deleted when it is closed, and it will delete the label too. Simple. Effective. Clean. So, tell me, **why** do you insist on overengineering this for no particular reason? This object management model works particularly well for a GUI. Every object is deleted by its parent, and if there is no parent then it deletes itself when the user closes it. You don't need to sprinkle any magic smart pointer dust on it - you *already have* automatic memory management due to the way a GUI works.
Excellent. I thought overflow was the issue but was lacking the actual details of the limits. Thanks for your help.
&gt; Pure, standard ISO C++ that compiles down to native code is 100% supported Correct me if I'm wrong, but I think that's only true if you are willing to deal with COM stuff. What Microsoft advertises as "native C++ for WinRT" today is C++/CX, which pretty much looks like C++/CLI only it does compile to native code. However, it is not ISO C++.
Sonny, no. I only ever used clang++ to compile my code. I've never used any other part of llvm.
1) Easily integration with other programming language. C++ is great but what if I want to write the logic in ruby and the GUI in c++. 2) Good GUI designer. I like NetBeens GUI builder the most. 3) Hackable I want to be able to control the keyboard reaction, shortcuts. I want to build my own components. 4) Control over the look and color of the components. Make it look more interesting. Some time the Native look and feel, get boring.
Maybe my hatred of macros is a bit irrational. But I would prefer the "by hand" maintenance. Think of it as giving you the flexibility to have a scripting API that is different from the class API. 
Yes, that's right. C++/CX is just syntactic sugar. If you don't want to use those extensions, you can fall back to standard ISO C++ and use plain old COM.
I'm really confused as to what this accomplishes. What kind of ugly code or boilerplate can this thing elegantly replace?
also you should `#include &lt;cstdio&gt;` not `#include &lt;stdio.h&gt;` the latter are the C headers, the former are the C++ headers, the elements in cstdio are wrapped up in `namespace std` too. 
&gt; Many years ago, it seemed like simply allocating with new and trusting the user to delete later will be sufficient. [...] Yet, if their programs leak, it's your library at fault. I agree, however, it doesn't apply to a GUI toolkit. How many times do I have to say this? Leaks? What leaks? If there is a widget on screen the memory is allocated, if the widget is destroyed (user clicked the big X or .close() was called) - the memory gets automatically deallocated. Clear, well defined and automatic object semantics. A parent has a std :: list of its children and deletes all of them in the destructor; in case of a manual delete by the user the child's destructor notifies the parent that it's getting deleted and gets removed from the parent's list, and notifies everyone else who subscribed to that signal. Is this really such a rocket science? Smart pointers are good, I agree. They are useful. If you have a piece of dynamically allocated memory that you don't manage and you need to return it to the user - use a smart pointer, be my quest, but, please, stop pushing them when they are completely unnecessary.
What if the library object is allocated but the window manager object is not? What if the window does not get created? For example, someone allocates "Window" object from the library and only intends to show it once the user clicks a menu item. The 1:1 relationship between your library classes and the window manager is artificial and not enforced.
&gt; Ugh, no. I think introspection and scripting like features can be gained by using the pattern of having everything inherit form a shared baseclass. I think type erasure instead of inherited base classes is much better and cleaner way of solving this.
&gt; What if the library object is allocated but the window manager object is not? Window manager object? You mean, what if your library object is allocated but the native windowing system handle is not yet allocated? And what does that have to do with anything? The library abstracts away such details from the user. &gt; What if the window does not get created? And why wouldn't it get created? &gt; For example, someone allocates "Window" object from the library and only intends to show it once the user clicks a menu item. They either allocate it beforehand and call .hide(), or they allocate when the user clicks on that menu item. If they allocate it beforehand it means that they want it to be in the memory until the program ends, and if they allocate it ad-hoc then the user closing the window will trigger destruction. &gt; The 1:1 relationship between your library classes and the window manager is artificial and not enforced. I'm not sure what are you talking about here. How is it not enforced? You call `new window_t` and it's up to the library to create that window. There is a clear, enforced relationship between the objects that are on screen and the objects in your code. When one gets destroyed the other one is destroyed too. (Unless the user called hide() beforehand.) I'm really baffled by your overly defensive position. You can allocate objects using plain old `new`; you can `delete` them safely; you can leave the object be and it will get destroyed anyway when the user closes the window. You don't have to think about memory management at all since it's all automatic. What more do you want? Anyway, let me ask you a question - have you ever tried to implement a GUI toolkit? Not a toy toolkit, but a real one - with dynamic sizing boxes, scrollboxes, listviews, editboxes, dropdown boxes, a fancy theme, multiple backends, etc.?
Looks like it lets you store "arbitrary" types and call specialised functions on them without having them inherit from a common base class. It'll do this with templates and some inheritance, I guess, like //function to call on the things in the vector template&lt;class T&gt; void print(T&amp; t) { cout &lt;&lt; t &lt;&lt; endl; } //can do template specialisations for more flexibility //abstract base class defining interface we want to use to call print class callFunc { public: virtual void func() = 0; }; //Actual stored things that know how to call print on their data template&lt;typename T&gt; class Holder : public callFunc { public: Holder(const T &amp;t) : t(t) {} void func() { print(t); } private: T t; }; //helper utility stuff typedef shared_ptr&lt;callFunc&gt; poly; template&lt;class T&gt; poly hold(const T&amp; t) { return poly(new Holder&lt;T&gt;(t)); } vector&lt;poly&gt; v; v.push_back(hold(1)); v.push_back(hold(2.1)); v.push_back(hold(string("three"))); for(auto i:v) i-&gt;func();//prints 1, 2.1, three There's a bit more magic, but you get the idea. You can store your favourite objects of whatever type in a collection that seems heterogeneous and call functions on them without having to worry about their type. It's not terribly efficient, of course, because you need some inheritance to do it at the end of the day. (Self-plug: You [don't need inheritance](https://gist.github.com/2982696) if you want to loop over the elements of a tuple.)
There is simply no reason that I am aware of not to prefer unique_ptr in this case. In your example, there could be a std::list of child unique_ptr's in the parent. Then, when the parent's destructor is called, its children are deleted automatically. No need to loop through and manually call delete. Of course it isn't rocket science to delete a bunch of raw pointers in a list within a destructor before returning; the point is, why not let unique_ptr take care of that for you, and remove another potential source of programmer error?
* it should be about GUI only, not other stuff. * it should not use external tools like the MOC. * it should use standard c++, without custom exceptions. * it should provide static safety in signals and slots. * it should only provide support for the MVC pattern, not enforce it. * it should not use message maps or other custom message passing mechanims. * it should use the native widgets, if possible. * it should not have a layout mechanism that is separate from widgets. * it should use lambdas, smart pointers, the STL. * it should provide a DSL for easy UI building using code. * absolutely not use preprocessor tricks. * any function or method should be usable as a slot. * it should use UTF8 everywhere. 
Sorry if I seem defensive, I did not mean to. Maybe it's because I'm not a native English speaker. I understand your sentiment that one should not use smart pointers just for the sake of using them. My point is that the design you described is not the only possible good design, and just like everything in engineering, has tradeoffs (what I meant in my previous comment is that tying your objects to window manager handles is manual, so trusting that relationship for object destruction is risky. Yes, the library takes care of that, but we are talking about avoiding bugs in the library). 
I really don't get your question but this works fine for me #include &lt;iostream&gt; class A { public: int a; A(int a_) : a(a_){}; }; class B : public A { public: B (int _b) : A(10) { } }; class C : public B { public: C() : B(3) { } }; int main() { C c; std::cout &lt;&lt; c.a &lt;&lt; "\n"; } Your constructor were private so bad things were going to happen,
You also only *declared* A's constructor, but didn't define it (i.e. no braces after the argument list).
C++03 21.3 [lib.basic.string]/5-6 said: "References, pointers, and iterators referring to the elements of a basic_string sequence may be invalidated by the following uses of that basic_string object: — As an argument to non-member functions swap() (21.3.7.8), operator&gt;&gt;() (21.3.7.9), and getline() (21.3.7.9). — As an argument to basic_string::swap(). — Calling data() and c_str() member functions. — Calling non-const member functions, except operator[](), at(), begin(), rbegin(), end(), and rend(). — Subsequent to any of the above uses except the forms of insert() and erase() which return iterators, the first call to non-const member functions operator[](), at(), begin(), rbegin(), end(), or rend(). [Note: These rules are formulated to allow, but not require, a reference counted implementation. A reference counted implementation must have the same semantics as a non-reference counted implementation." In C++11, this squirrely wording is gone. N3376 (the current Working Paper, but the slightly older Standard is the same) 21.4.1 [string.require]/6 simply says: "References, pointers, and iterators referring to the elements of a basic_string sequence may be invalidated by the following uses of that basic_string object: — as an argument to any standard library function taking a reference to non-const basic_string as an argument. — Calling non-const member functions, except operator[], at, front, back, begin, rbegin, end, and rend." This forbids COW (and the change was very, very intentional).
C++ is multi-paradigm, nobody is forced to use OO-style.
 class C : public C { C() : B(3) { // boom! no default constructor for base class compile error. } } class C inherits from itself?
What it MUST: * Templated-based signals &amp; slots mechanism for callbacks * Declarative language for describe interface (like Enlightenment's Edje and Qt's QML) * Native look &amp; feel where it makes sense * Powerful and fast canvas * Portable (it must support several plataforms, not several compilers, because I want to use C++11, not 20-years old tech...) * C++11 and UTF-8 * Good GUI designer * Touch interface What it MUST NOT: * MOC or any other preprocessor * Create its own object system * Create its own data types when STL already provides it * High runtime overhead (interpreted XML, string-based callbacks, ...)
What's the real world use case for using something like this? "Looks like it lets you store "arbitrary" types and call specialised functions on them without having them inherit from a common base class" Why would you ever want to do this in production code, rather than just having a solid interface that defines the methods that the classes implement? Whenever I see something with this level of "magic" I can't imagine where it would actually be used.
If you've got objects, you might as well use them. Chances are, anyone using OGL will have a use for them.
Yes, also void f (std::string&amp;); // value should read void f (std::string); // value Quite a few errors in the first few paragraphs of the article.
Fixed both. Thanks for pointing them out.
&gt; there seems to be a bug, which is that in case of an rvalue reference, it has to be deleted in the destructor I think you are right, except that we need it in the case of an implicit conversion. &gt; 1. Passing two instead of one pointer. I was actually thinking how we could fix this. My current idea is as follows: we can specialize the in class template for types with alignment 1 (minority) and those with alignment 2 or greater (majority). For the former the implementation remains the same. But for the latter we can smuggle the rvalue/lvalue flag in the last bit of the pointer. I am not 100% sure, however, about the guarantees given by the standard to unaligned access (i.e., if it is "undefined behavior", then this will work, however, if it is something like "should still work but may be slower", then this approach won't work). &gt;2. Branching on every access inside the function. Yes, I suppose if we always store the pointer to the object in the same member (regardless of lvalue/rvalue), then for functions that don't care whether it is rvalue or lvalue (e.g., get()), we can get rid of branching. &gt; passing in an rvalue reference that doesn't need any conversion triggers a superflous move I don't think it does. Can you elaborate? Otherwise, good ideas, thanks. 
GCC 4.6.1 warns about it. Are you sure you have all warnings on?
These are good questions -- but were all originally answered in Wadler's formulation of the [expression problem](http://www.daimi.au.dk/~madst/tool/papers/expression.txt) _Why not just define an \[abstract class / interface\]_? Interfaces are brittle to addition of new methods -- every implementation of the interface must be updated to include the new method. _What about the [visitor pattern](http://en.wikipedia.org/wiki/Visitor_Pattern)?_ The visitor pattern resolves the 'new method' issue, but is brittle to adding new data cases -- every visitor implementation must be updated to include the new method. Different tools call for different solutions. If users can modify source and recompile, any solution will work. If users will only add new cases and not add polymorphic functions, an interface will work. If they will only add new methods and not add cases, visitor interfaces will work. If you want both but don't need compile time verification that the function/case matrix is complete, multimethods will work. If you need separate compilation, extensible cases, extensible function sets, and static verification, then you have the expression problem. It's a fairly specific problem, so calls for a fairly specific solultion.
Reminds me of 1990's C programmers looking at C++ virtual function dispatch. "Too much magic" they would say. (I'm not saying either is wrong -- just that "magic" is relative) 
&gt;&gt; passing in an rvalue reference that doesn't need any conversion triggers a superflous move &gt; &gt; I don't think it does. Can you elaborate? Of course. Just think about the example you gave: f (std::string ("bar")); First you explicitly create the temporary string object, then implicitly call the templated constructor of in, where you move the object with a placement new and store a pointer to it in rv_. In this particular case, you could just as well store a pointer to the temporary object being passed, like this: in (T&amp;&amp; x) : lv_ (0), rv_ (&amp;x) { } Of course, you would have to distinguish the two cases, so that during destruction the destructor of rv_ is called if and only if it was constructed in the class.
To ignore the significant practical problems for a moment: what might work is having a new version (say, C++++) where every file starts with the token sequence `C++++:` (try saying that five times fast). If a file *doesn't* start with that, it's C++11. Translation units then get processed as either C++++ or C++11, with C++++ providing a way to switch to a C++11 context for a given include file. I've seriously considered something sort of comparable for a language project I worked on for a while: I wanted to adapt Clang to allow C (and much later C++) header files to be imported as foreign-language modules. But then, that would probably require a massive engineering effort *plus* the need to maintain two mostly but not quite identical compilers.
Good point. Any idea how to fix it? Copy the data to another location first? This seems like overkill and could lead to messy code. Maybe we could create a DONT_PASS_AS_REFERENCE() macro which will copy *references* to a temporary if necessary - we would like this macro to be more intelligent and simply pass through *values* without wasting time on a copy to a temporary.
A template might be a bit nicer. Something like template &lt;typename T&gt; T no_ref( const T&amp; t ) { return t; }
You could do the same before C++11, using `boost::ref` to store it in the `std::vector` (which is just a wrapper around a raw pointer, same as `std::reference_wrapper`).
*Update: I think I've messed up my l-values and r-values. I'm downvoting my own comment here, and will post another comment.* But would this be slow when faced with a value? BigStruct a = v.front(); v.push_back(no_ref(a)); I think that the above code might do an unnecessary copy. In the above code, I would like the reference to be passed through as is. What about this overload? (requires C++11) : template &lt;typename T&gt; T&amp; no_ref( const T&amp;&amp; t ) { return t; } A few months ago, I know &amp;&amp; refs quite well. But I haven't used them in a while, so maybe this is crazy! To summarize: What we want is a forwarded that will pass references through by value (i.e. take a copy of the data), but will pass values though as efficiently as possible (allowing for optimizations such as [elision](http://en.wikipedia.org/wiki/Copy_elision))
Oops, right. Well, I am used to having all constructors in the same place, so I didn't see the first two.
It's still undefined behavior according to the C++ standard, as the reference passed as an argument to `push_back()` may be invalidated by the function call.
The lazy, when dealing with a default-constructable, say `v.push_back(T()); v.back() = v.front();`.
There's been a lot of talk about *shared_ptr* recently so it's nice to see a nice in depth article about it's brother. Especially since many people are recommending to use *unique_ptr* as a first resort and only go to *shared_ptr*s when absolutely necessary.
Have a close look at this one: https://github.com/boostcon/cppnow_presentations_2012/blob/master/fri/value_semantics/value_semantics.pdf?raw=true
geometry. closed shapes sometimes may require the first vertex to be repeated at the end. it depends on what library you are using.
Good investigation, but please don't do this in production code. Undefined behavior can change with the next version or maybe even with a different compiler flag.
Yeah. I think I'm mixing this up. The method will be called in one of two ways: v.push_back(no_ref(v.front()); and v.push_back(no_ref(copy_of_front)); In the latter case, it is OK if the object is passed by reference through `no_ref` and into `push_back`. But in the former case, it must be copied at least once. `copy_of_front` is an l-value. I had thought that `v.front()` is an r-value, but I think that's incorrect. The fact that `v.front()` returns a reference means that it is an l-value also. (Correct?) How do we distinguish between the two cases? I can't see any difference between the two cases in terms of l-value-ness, or const-ness, or anything else?
Because Wt has an ORM which is fairly neat nowadays in the world of highly abstracted scripting languages. Wt isn't strictly a GUI toolkit and neither is Qt, for that matter.
Demo at 0:55:00 is interesting.
There is no point in using a template or macro like no_ref if you have already made a copy. I was imagining you would use the macro or template function in this way: v.push_back(no_ref(v.front())); Not this way: MyType tmp = v.front(); v.push_back(no_ref(tmp)); // We don't need this copy If you are already making a copy anyway all you need to do is: MyType tmp = v.front(); v.push_back(tmp); 
It's not just that it may change but that your code loses portability if you depend on undefined behavior. There are many undefined things in C++ that will reasonably work the same way across compilers, right until you try to compile to a different architecture. Compilers only promise to more or less follow the standard, nothing else, so if you want your code to be portable, your best bet is to stick to the standard.
Personally, I don't see it as a problem or a defect. Why? It is straight-forward for the implementer of the library to write efficient code that works regardless of whether or not the value passed to push_back() is within something that will be invalidated. Containers are non-intrusive data structures. Consequently the user of the library need not be concerned with worrying if something is invalidated beyond what is stated in the standard about such. With push_back() nothing is stated with respect to the argument passed to it in terms of it being directly or indirectly invalid due to a resizing of the vector. Thus, the implementer of the library must ensure there are no issues. The reason IMHO the standard doesn't say anything is because implementing it so there are no issues is straight-forward. To ensure there are no issues: (i) allocate a new vector first on the call stack, (ii) copy the last element in the last place, (iii) copy the first N elements into the new array, and (iv) and swap() it the new vector with *this. This avoids making an unnecessary extra copy of the element passed in. Items (ii) and (iii) could be done in any order. The main thing is to NOT destroy the original vector until the copies have been made. To completely avoid invoking the default constructor unnecessarily, the library writer could instead create the array as a properly-sized and aligned uninitialized array of char (e.g., this could be a special private constructor of vector for the library implementation), then placement new would be used to copy the original elements and the passed in argument into the last position., followed by the swap() with *this. This implementation would require placement delete being used in the destructor to destroy all elements. Either way there is no issue with push_back(front()), push_back(back()), etc. type of operations.
RAII and probably a book http://www.amazon.com/C-Java-Programmers-Mark-Weiss/dp/013919424X
Even though allocation of objects often looks the same in C++/Java, they are very different and you would do well to really understand this area. String s; // Java, null reference to string, no object std::string* s; // C++ similar to Java above std::string s; // actual object allocated The differences in C++, especially working with the 3rd example above in things like assignment are very different (C++ copy, Java two things pointing to the same memory). Spend some extra time learning this and it will help you greatly, IMHO.
Wow. That was quite the mouthful. I was afraid of object declaration changing up on me, but I think I can manage. This is precisely what I wanted to find, the odd differences between them I need to nail. Need to save this post.
Thanks for your reply! I did overlook that C++11 std::vector also has to work with move-only objects. (My bad.) So the code I posted is more or less fine for C++98 --not C++11. I am not surprised that C++11 really effectively mandates the use of placement new implementation due to copy, move semantics and also mixing in cv-qualifiers. I've written difficult structures warranting the use of placement new, alignment, etc. in C++11 so I know how much of a headache that can be. I must say that it is a rewarding feeling when you finish and can give it to others and it all works flawlessly --well at least until they find a bug!! :-) So I would like to personally thank you (your team and all library writers!) for all of your continued hard-work implementing, testing, debugging library code with all its nuances that we all use!!! (Compiler and library writers IMO are not thanked enough.) For non-library writers concerning find bugs in a library, I would say three things: (i) nothing is really "trivial" in a library --not even the trivial items; (ii) do report the bug with as small a program you can make to recreate it; and (ii) if the compiler library has a bug, then keep the work-around as simple as possible, e.g., use code like { T t(v.front()); v.push_back(t); } to make a copy (for example) and have correct code and make sure you tag/document it so it can be searched for later and fixed and to avoid having some other programmers say, "Why is the code making a useless copy?" and removing it before the library was fixed! 
Sure, C++ gives you two ways in fact: using pointers or using references... Example: void setIntegerToZeroTheWrongWay(int value) { value = 0; } void setIntegerToZeroUsingReference(int &amp; value) { value = 0; } void setIntegerToZeroUsingPointer(int * value) { *value = 0; } int main() { // program execution starts here int myInteger1 = 10; setIntegerToZeroTheWrongWay(myInteger1); // the integer was copied into the function parameter, so function had no effect // (myInteger1 is still 10) int myInteger2 = 10; setIntegerToZeroUsingReference(myInteger2); // the integer was passed into the function using a "reference". this is similar to how Java // works when passing in non primitive datatypes (except that a c++ reference can't ever be NULL) // (myInteger2 is now 0) int myInteger3 = 10; // define the actual integer int * pointerToMyInteger3 = &amp;myInteger3; // define a variable which "points to" the actual integer setIntegerToZeroUsingPointer(pointerToMyInteger3); // the pointer variable was passed in, so the function is able to use it to access // myInteger3 directly. // (myInteger3 is now 0) // in the last example, you could also have used: // setIntegerToZeroUsingPointer(&amp;myInteger3); // ... to achieve the same effect without needing an intermediate variable } Note that in C++ there is no distinction between "primitive types" and "objects" when passing parameters, such as there is in Java and other languages. Whatever the type of the variable is, it is either fully copied, or merely passed in as a pointer/reference (which technically only copies its address in memory), depending on how you specify the function. (There is a third sort of parameter passing that is sort of half way between these two, known as "moving", but that was only recently added in the latest standard and it's a bit advanced, so best not to worry about it for now.)
This looks so cool and I think it works best with teaching from within code. Also solves my problems of looking into the whole "pointers" thing I was getting worried about. Just a quick run down to see if I'm understanding this correctly. myInteger is the basic variable. Whenever you place a '&amp;' character in front of it, it provides you with the reference code in memory which is basically anything that is defined as a "reference". And a pointer is simply storing that reference address? Again, so cool. Now I've got a nagging question, can a pointer point to another pointer? I can't think of any real-world applications for this yet, but just an interesting thought. EDIT: Read your edit. Caused a reddedit.
For C++ questions, answers, help and advice see r/cpp_questions.
Thanks again for all your detailed responses. I've got work in 6 hours so I think sleep's the way to go for now, but tomorrow I'm gonna get started on this whole C++ thing. Last ponderance: Can you point a pointer towards a pointer that is pointing back at the first? If so and you can compile without incident, what happens when you try to access said pointer? Or would it only return "null" since it never acquired a type?
That can't be done without a type error, I think. A valid pointer pointing to an `int*` would need to be an `int**`. And for the int* to point to the `int**`, it would need to be an `int***`.
&gt;Just a quick run down to see if I'm understanding this correctly. myInteger is the basic variable. Whenever you place a '&amp;' character in front of it, it provides you with the reference code in memory which is basically anything that is defined as a "reference". And a pointer is simply storing that reference address? Pretty much. When &amp; appears before a variable, it's the address-of operator. It returns the address of the variable, which you can store in an appropriate pointer variable. Given a pointer, you can get the pointed-to value using the prefix * (dereference) operator. You can also do math on pointer addresses. This is used when dealing with C arrays (not so common in modern C++): int array[] = {1, 2, 3}; *(&amp;array[0] + 1); // will be 2 *(array + 1); //shorthand form A &amp; appearing after a type is totally different. This indicates that the type is a reference. A reference is different than a pointer. You don't have to dereference references in order to access the value, but you can't do math on references. int num = 4; int* pointer = &amp;num; //pointer to num int&amp; ref = num; //reference to num *pointer; //access pointer value ref; //access reference value
&gt; prototypical I'd use the word 'idiomatic' :) And the title is also confusing, there is just one 'SFINAE' in C++, which is a rule or mechanism of the language. You have *tools* to take advantage of it, like the sizeof operator or what the writer of the article discovered, the noexcept operator. So, yet another 'SFINAE tool'. Word nazism aside, it's a nice article. I only wish they would introduce constructs in the language that target this kind of metaprogramming without abusing existing language features. Static if and such. 
&gt; see r/cpp_questions. You should add a slash before the "r". That way, it's linkified automatically: /r/cpp_questions.
&gt; I think I'm going to have to hobgoblin all over you again with my little mind ;-) In your comment to Part 1 you said that "passing by value makes complete sense in all of the cases mentioned in the article". Seeing that you are now suggesting that we overload on const/rvalue reference, it looks like I freed you of at least some of the hobgoblins ;-). &gt; Besides the fact that you've created and inelegant and inefficient (although very clever) smart pointer you're neglecting the reason why you'd want to overload all the different permutations of operator+() in the first place... runtime optimisations. I think you meant to say "compile-time optimizations" here. That is, the compiler will be able to select the most optimal version of operator+ depending on the arguments (rvalue/lvalue). While this is true to a certain extent, you pay for it with object code bloat. And whether a few runtime branches outweigh code locality benefits is not clear (in this particular case the compiler will most likely inline all the calls so chances are good the resulting assembly code will be identical). And, probably more importantly, you pay for it with source code bloat. Here is the version of your test that uses the in class template instead: struct matrix { matrix() { } matrix(matrix const&amp;) { std::cout &lt;&lt; "copy, "; } matrix(matrix &amp;&amp;) { std::cout &lt;&lt; "move, "; } matrix&amp; operator+= (in&lt;matrix&gt; m) { std::cout &lt;&lt; (m.rvalue () ? "move+=, " : "copy+=, "); return *this; } std::array&lt;int, 65536&gt; some_big_ass_data; // could be a vector ;) }; matrix operator+ (in&lt;matrix&gt; x, in&lt;matrix&gt; y) { if (x.rvalue ()) return std::move (x.rget () += y); else if (y.rvalue ()) return std::move (y.rget () += x); else return matrix (x) += y; } It has exactly the same output as yours (if we take into account a correction to your example that I will talk in a second). And achieves this with a single implementation for operator+= and operator+ instead of 2 for operator+= and 4 for operator+ in your case. Now about that correction I mentioned. I don't think returning an rvalue reference from operator+ will work. Consider this use-case as an example: matrix&amp;&amp; m (matrix() + matrix ()); print (m); In your implementation m will reference one of the temporaries that will be gone by the time print() is called.
Correct, v.front() is an lvalue. It is impossible to distinguish the two cases.
This isn't *much* better than using pointers. If your draw() function throws an exception, which is possible because Shape&amp; could be anything, then none of the Shapes referenced by your &lt;vector&gt; get destroyed. In particular a dynamic_cast on a reference could throw std::bad_cast. In fact, I'd rather use raw pointers... no need to change a bunch of dots to -&gt; later if you move to a smart pointer.
Can you put enable_if into noexcept and enable/disable functions this way? GCC 4.7 accepts it. I remember some attempts to do it with the throw specification, but it turned out to be ill-formed. Why would you want to do that? enable_if is usually used to remove functions from the overload resolution set by modifying either the return value (as in 'typename enable_if&lt;condition, return_type&gt;::type myfunc(...)'), or by introducing a dummy parameter (as in 'void myfunc(..., typename enable_if&lt;condition&gt;::type * = 0'). Both these techniques change the prototype of the function making it somewhat harder to read and understand. With noexcept, there is no need to change the prototype, and therefore it's a cleaner way to achieve sfinae. However you need to be careful not to declare throwing functions as noexcept(true).
I was told by a few professors, friends, etc. that it would be best to understand how C works and operates to provide a better overall understanding, but to do all of my actual coding in C++. I think the large class will be a tough one to break, but it'll just take practice.
I've been told by several people I have to "clean up after myself" when using C++, so I'm assuming that they were referring to the lack of Garbage Collection.
If you code C++ like you code Java then you are doing it wrong, I would strongly recommend that you pick up a book even if the fist half of it feels a bit basic. Avoid anything like "C++ for Java programmers". Accelerated C++ is a great book and move at a good pace. Failing buying a book, many pit fall * ensure you don't over use inheritance, it great for run time polymorphism but you often do the same thing with generics (templates) in a cleaner manner with lower overhead. * If it doesn't have state (member data) then it probably doesn't need to a be class, don't fear free functions. * Don't use primitive arrays, use vectors and other containers. * don't really to much on try catch propagation, use RAII for anything that require clean up. As for an IDE I generally recommend not using one when starting off, know the link between source files, the compiler and the linker is a very useful skill to have.
I don't know specifically what you are doing, but you might want to take a look at [processing](http://processing.org/).
I personally wouldn't but don't let that stop you.
I would be interested. OpenGL or some machine learning would be great to watch while eating :D
The fact that the vector is holding references implies that it doesn't own the resources, so it wouldn't make any sense for the vector to clean up in this case.
It sounds like you're talking about [static analysis tools](http://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#C.2FC.2B.2B) of which there are many. But note that these are a different beast than formal verification, which is the only type of analysis that can actually prove anything. Formal verification is extremely difficult, because in order to prove (in the mathematical sense of the word) that software is free of defects you have to prove that the compiler used to build it did not miscompile the code, and you have to prove that the hardware that runs it does not have microcode bugs or other defects. Even if you ignore these and use an idealized model of the language running on an abstract machine, formal verification is still terrifically difficult for non-trivial programs, due to the combinatorial explosion of the number of possible states and execution routes that must be considered. We're at the point where [microkernels can be formally verified](http://ertos.nicta.com.au/research/l4.verified/), but even then this does not guarantee a lack of security vulnerabilities.
Check out [Carmack's article](http://www.altdevblogaday.com/2011/12/24/static-code-analysis/) on static code analysis.
A C/C++ programming stream would look an awful lot like reddit...
And if you don't like Java, there's a [Python-based processing equivalent](http://code.google.com/p/pyprocessing/).
What a confusing title. C++ already supports streams. Plus boost has support for asynchronous I/O. Many assume you mean videos of some sort, if that be the case you really ought to repost with a proper title. 
I was really going to pop on my own comment about running lint on your code, but his article covers that. I used to work for a place many years ago that required lint clean code for every build. It was harsh, as it's amazing how lazy you can get over time.
And replace all auto ptr items with unique then debug. 
I seriously didn't expect it to be confusing at all. OK, maybe the title is ambiguous, but the post itself? And yes I'm talking about a video stream. Me talking about C or C++ stuff.
Could do a stream on basics fo C++ with the new standard, maybe than just record them too. Its always good to have visual aids for learning.
Completely agree with all of the points, but... What is a substitute for raw pointers? Using `-std=c11` and `std::unique_ptr` may manage heap memory, but what about other situations? * When a function/method want to accept an optional argument? * When a function/method want to modify its argument that may live on the stack or static memory instead of on the heap? Using reference may be a good substitute, although some people prefer all writable arguments be passed as pointers so that the writable intent is clear at the call site. 
std::unique_ptr and std::shared_ptr replace all possible uses of raw points and are infinitely safer.
You can just pass the pointer from a std::vector std::vector v(10); recv(socket, v.data(), v.size()); You don't need c-arrays
But what about passing a writable argument that is allocated on the stack: Animal a_cat; spank_optional_cat(&amp;a_cat); Does `shared_ptr` still work here?
This is code smell. Why is the function taking an address if it only needs the value? If it needed the address, why should it accept a random pointers to something on the stack?
The assumption is that spanking does something to the cat and so requires not just the value but the actual object itself. This is not code smell: lots of functions in procedural world such as C++ manipulates (changes) its argument.
&gt; If you're passing in a stack reference, then it's never optional. The problem is that the designer of the function `spank_optional_cat` should not be concerned with where the cat lives. Its job is to spank the cat, where ever the cat may live. By declaring void spank_optional_cat(std::shared_ptr&lt;Animal&gt;); the designer of this function is explicitly imposing the unnecessary condition that the cat must live on the heap. This is an unnecessary condition on this function. Note that even the OP of this thread recommended that, "Try to get as much as possible allocated on the stack instead of the heap." So, any function you design should work on objects that live the stack as much as on the heap. Moreover, why declare two functions when one is sufficient? void spank_optional_cat(Animal *); 
Disagree. The only projects I've been on that use raw pointers and c arrays is because of legacy code, or from old school problems like 'STL is buggy'. It so easy to avoid nowadays, and I'll never write such code ever again. 
Using a heap allocation when the size is fixed is a waste of cpu resources.
What if you have to work with third party libraries written in C as part of your C++ project? Sometimes it really is unavoidable and it's worth keeping those skills sharp.
 void spank_cat(Animal &amp;); Many C++ programmers, myself included, consider passing non-const references to be a "code smell". A very common convention is that const values are passed in as references, non-const as pointers. It makes it really clear at the calling site whether you are expecting to change the item or not...
Use JavaScript. hey oh!
Really? One thing that annoyed me about programming in D was that there was really no distinction between passing an argument by reference because I want to modify it and passing an argument by reference as an optimisation. One of the (few) things I quite like about C++ is that I *can* make that distinction. I can appreciate forcing the use of `&amp;` at the call site (bit like C# requiring `ref`), but I'm not sure I like passing a pointer when the function requires an actual non-null reference. Plus, I suppose I got used to not having call site distinction from using D. Makes me wonder if using `reference_wrapper` or something similar to require call site notation *and* require passing a non-null pointer is a good idea... *ponders*
You have obviously never had to program anything where performance was critical.... Do you realize how much those nano seconds count when programming a game that is supposed to run at 30+ fps? You only have 33 milliseconds to calculate and render the frame at 30 fps. When you have to pay thousands of dollars for time on super computers every nanosecond counts, when doing scientific research every nanosecond counts, there has been a huge move away from people caring about performance and its a shame because its still very relavant. Think of the missile defense systems on warships, those nano seconds are a huge factor if you are trying to figure out a trajectory so you can shoot down a missile coming at you...
From what I have seen you have to do your own checking any time you use operator[] there is no special debug mode for it, if you can point me to a document that states otherwise I will gladly upvote you and concede defeat on this point, but from what I have seen its all on the programmer.
Heh, a couple months ago I made that mistake. 
Nah, I'm not going to practice unless I really need it. If it comes to being forced to use it, then so be it. I'd rather spend my time learning c++11. 
Charts don't usually make sense. Especially when they're called "definitive".
I see I'm a few days late, but accelerated c++ is a really good book for teaching c++ with a top down method. It might seem slow at first because of the similarities between the languages, but with a language like c++ you gotta pay attention to the little things sometimes!
Perl / Python / Ruby should basically be equal in abstractions. This is pretty much nonsense. 
I know, imagine if you had to send a billion bytes one by one, those nano seconds would add up to a 1 second delay in transferring your 1 hour download. You're being silly.
While I don't in general agree with the chart, C++ has one thing that the other languages you listed don't - an insane template system. While commonly used for the same things as Java/.Net generics, I advise everyone to check out the true power of templates - either by reading Alexandrescu's Modern C++, or opening the STL code. I guess the whole point of this chart is to say that C++ introduces a lot of abstractions on top of C without the loss in performance. Kinda true - some abstractions don't induce performance overhead (templates) while others do, but only when you use them (virtual methods, exceptions etc.) 
Haskell should be on top even if it had only one abstraction mechanism. With only one, you could achieve more abstraction than with most other PLs.
Use generic programming instead Create a templated draw_shape function that can accept ANY object that has a draw() member function. That way there is no need for heirarchies. 
The biggest difference is that you can freely choose between value and reference semantics when instantiating classes. (In Java, all class instances MUST be created dynamically; not so with C++). This simple fact has HUGE implications for how you structure your code; "modern" C++ uses new/delete sparingly. The "special" methods: constructor(s), copy-constructor, destructor, and assignment operator are there to so that you can make user-defined value types that behave as if they were built-in types. Each of these is necessary to support a feature supported by built-in types: constructor may be needed to create an instance in a well-defined state, copy-constructor may be needed to support pass-by-value, destructor is needed to undo whatever the constructor did, and assignment operator is needed to support, well, stuff like x=y. (And there's also a move-constructor in C++11). Your classes may need some or all of these (though, the rule of thumb is: if you need any of {destructor,assignment operator,copy constructor}, you need all of three). Also, free-standing functions are well-liked: unless it MUST be a member function, make it a stand-alone function.
&gt; Using reference may be a good substitute, although some people prefer all writable arguments be passed as pointers so that the writable intent is clear at the call site. I hate this hack, "let's use an obsoleted language feature as an argument annotation". If you want a hack for output parameters, have one like this: [https://gist.github.com/3028820](https://gist.github.com/3028820)
A really quick, untested hack, written as a reply to ["some people prefer all writable arguments be passed as pointers so that the writable intent is clear at the call site"](http://www.reddit.com/r/cpp/comments/vshtl/what_are_the_state_of_the_art_methodstools_for/c57ke0r). I'm almost certain I've got the forwarding in the assignment operator wrong, please feel free to fix it.
I don't think you need the std::move(newval)s, as they are already rvalue refs. Looks good though, maybe useful in an environment that doesn't tolerate errors, but doesn't care about small performance hits either. It would get annoyingly verbose, as has been mentioned.
The "hack" you linked to is exactly the same strategy promoted by unique_ptr but for pointers. Why do you say pointer is obsolete? How else can you capture the identity of an object (not just the value) without pointers?
I say it's obsolete for the same reason people say c arrays and c string functions are obsolete -- no compile-time correctness checking. Anything raw pointers can do, wrapper classes and references can do better. Capturing the identity of an object can be done with smart pointers. There are edge cases for the use of raw pointers (if only for implementing smart pointers), but they're rare and definitely shouldn't be exposed outside of the function/class/library using them.
See http://www.reddit.com/r/cpp/comments/vvrkk/pointerfree_outinout_parameters_visible_at_the/
How do you define a function that accepts optional arguments, where the argument can live on stack, heap, or static memory?
This way the caller still holds a valid handle on the foo obj, which sort of defeats the purpose.
&gt; I don't think you need the std::move(newval)s, as they are already rvalue refs. AFAIK, a named rvalue ref is an lvalue. The move is still needed.
Oh yeah...maybe I have read that. good catch
Rvalue reference variables are lvalues. Yes, it's confusing, but once you consider all the hairy edge cases it will make sense to you as it eventually did to me. 
I used Quincy 2005 for my windows c++ programs in school... it isn't the best... but it works. [Quincy 2005]( http://www.codecutter.net/tools/quincy/)
How about Virtualbox, your favorite Linux distro, and business as usual (vim, g++)? 
I also like Visual C++; good debugging capabilities, not quite as modern a compiler as gcc, but passable. If you do get MinGW, an addon called msys may give you a more familiar/powerful environment to work from: http://www.mingw.org/wiki/msys
Just get Code::Blocks IDE with the MinGW compiler (GCC).
The 2010 version is largely obsolete though. AFAIK, C++11 support is atrocious.
Instead of allocating one really big array, you could buffer your input; read into a small buffer and dynamically allocate the file in memory. I don't know that fread promisses to read until EOF given a large enough buffer, but you can entirely sidestep the issue with buffered input. 
YMMV, I suppose. I only tried VC++ Express 2008, but after being punched in the face too much time by the painful IDE, I gave up and switched to the command-line version, before switching to g++ altogether. And today, I wouldn't like to have to code in C++98. 
Er, sorry, that's correct, you can't (not easily). Option wrapper then (which, admittedly, in its implementation would likely use a raw pointer).
But what does the option wrapper buys you that a raw pointer would not? Even with an option wrapper, you would still need to write code to see if the wrapper actually contains a valid pointer or not. This is no different from using a raw pointer.
...and which operating system, libc and compiler, and how did you get a network connection bound to stdin?
1. Clear intent: You know that what you're passing/receiving is optional, as opposed to mutable. 2. Memory safety: Though you eventually have to access a value (perhaps not through a raw pointer, maybe you store the validness as a boolean...), you can't do pointer arithmetic on it (without grabbing the address first), can't dereference it accidentally, and could, for example make accessing an invalid value throw an exception (possibly only in a debug build) 3. rvalues: for a raw pointer, you have to create the optional value on the stack just so that you can grab its pointer; for an option type with an appropriate forwarding constructor, you can pass the optional parameters directly as rvalues.
+1 for QtCreator although if you're looking to program C++11 then it's syntax highlighter highlights some valid C++11 syntax as erroneous which can be a bit annoying. (It still compiles perfectly fine as QtCreator uses gcc) It also has the benefit of being cross platform so if you like it and return to linux you won't have to relearn a new tool.
For learning C++ Visual Studio really got me into bad habits, mainly because of intellisense.
&gt; after being punched in the face too much time by the painful IDE Buy using the Microsoft supplied [vcvars32.bat](http://www.zeusedit.com/zforum/viewtopic.php?t=1045) file it is quite easy to run the Microsoft *compiler/linker/maker* from inside any editor that has good support for external tools. 
But if you do that, g++ does just as well. And g++ 4.7 has reasonable C++11 support.
&gt; I do think Vim on windows looks ugly. [Zeus](http://www.zeusedit.com/) or [Zeus Lite](http://www.zeusedit.com/lite) maybe? Jussi Jumppanen Author: Zeus Editor 
2nd/4th bullets should be "immutable reference"
I really don't like changing arguments in any fashion. I find it very quickly leads to really hard-to-manage code, and there is no real advantage to it that I can see. If you need more than one return value, just return a tuple. If you need to modify an argument, return a new copy with the appropriate changes. So, basically, I'm a firm believer that every argument should be either `T` or `const T&amp;`.
With respect, I really really don't like this, silly rules like not using references for 'output' parameters is just silly. That case is EXACTLY why there is `ref` and `const ref`. Taking in a pointer does nothing to make that clearer. The only thing it does is add another place to allow segfaults and/or introduce null checking boiler plate. (references can be assumed not null by the standard) But then to add to the misery of pointer inputs, your adding a completely new "deferencer" construct. Which if you were new to the code base would give a cause you to WTF. Because you are basically going out of your way to reinvent references, just so you can avoid references, which is the feature you should be using anyway.
The amount that you ask to read is but a request to the operating system, not a mandate. The OS can return any amount it wants. Especially when the input is coming from a network socket, the requested amount may differ significantly from the actual amount, because network traffic is returned as it arrives, not all at once. You must *always* check the return value, and keep looping until there is no more to read. Note that the return value of `fread()` does not distinguish between EOF and error; you must use `feof()` and `ferror()` to determine which is the case. Also, you should not be using C string and IO functions in C++. 
pts 1 &amp; 2: darn, you're right! pt 3: For private functions, it may make sense to pass smart pointers by constant reference arguments. However, for publicly exposed methods, it's better to to use operator* or get() to pass by const reference or const poinnter. Also, passing by reference (to smart pointers) in publicly exposed functions does not indicate to the user of the interface that ownership will be transferred. Well, it doesn't really indicate much of what will happen I suppose, but that's why I don't like it; it leaves the function definition too ambiguous.
No, you are right.
There is no IDE that doesn't erroneously mark at least some of C++11 syntax as incorrect. With Qt Creator you can see the progress with almost every git commit. I compile it weekly and almost always get surprised by a feature working that hasn't before (like proper recognition of at least some lambdas)
Just to make this clear, I'm not in favour of using pointers for output parameters either, I think references/const references are mostly the way to go. Having said that, this is a very thin wrapper over references, purely designed for code-bases where it's important that it's obvious at the call site whether a parameter is modified or not. More accurately, it's a toy piece of code that I wrote as a counter-example to a "raw pointers can be useful" argument.
I should also point out that MATLAB is basically a wrapper around LAPACK which in turn built on BLAS. These are two very fast FORTRAN librarys. Unless you call them from C++ which you can, then I think MATLAB will actually be very competitive.
Not if you've got destructors that can throw exceptions (in C++11, by default destructors are marked as `noexcept` ("never throws"), and if they do, `std::terminate` gets called).
You can also get the full [Microsoft Visual Studio C++ 2012 Release Candidate](https://www.microsoft.com/visualstudio/11/en-us/downloads) for free - it will work through 15 January 2013. After that you'd have to downgrade to the free Express Edition or perhaps try DreamSpark. 2012 has better C++0x support than 2010, but if you're just getting started that's probably not be a big deal for you. I've heard great things about QtCreator and have used it a bit on Linux, but on Windows my opinion is that Visual Studio is a better integrated development environment, particularly when it comes to debugging. You'll need to shop around for good high-performance math libraries for matrix decomposition, non-linear optimization, etc. I use a bunch of different off-the-shelf and hand-crafted libraries for this, but I can't really make recommendations since I've never needed to be ultra-concerned about performance (e.g. If my implementation is 20X slower than it could be that's bad, but if it's 2X slower than it could be that's not a big deal.) 
That's the problem with MS products: slow releases.
Never use c-style arrays. ... Try to get as much as possible allocated on the stack instead of the heap. Aren't these two rules somewhat contradictory? C style arrays can be totally fine, on the stack, especially if you use strcpy_s (for instance) which infers the array size to avoid errors. I'm okay with C style arrays whenever the tradeoff of fixed-size versus performance-cost-of-vector/string is appropriate. 
That's as much a pro as it is a con. And MS isn't exactly slow with their releases... Just look at the meteoric changes in C#/.Net
 std::array&lt;char, 10&gt; v; recv(socket, v.data(), v.size());
Wow. All that verboseness and what did that buy you?
As I said, I agree with you.
So in a nutshell: if you need to make a copy, do it in the parameter list (pass by value) so you can take advantage of copy-ellision / move semantics. If you don't need to copy, pass by const lvalue reference as it will bind to both lvalues and rvalues without any extra overhead. Very nice series.
Very insightful series indeed. May be this technique picks up some wind so as to promote it to the status of a first-class C++11 idiom. Time will tell.
Yet another framework similar to Max/MSP is [vvvv](http://www.vvvv.org/) It comes with many interesting examples. You can use "boxes-and-wires", and also create or modify nodes using C#
&gt; Account alice; Account bob; Dollars amount = Dollars(100); transfer_money(alice, bob, amount); bankState = bankState.transfer(alice, bob, amount); &gt;Furthermore, some algorithms could not be implemented efficiently before move semantics, without performing them in-place (matrix multiplication is the classic example). Thank goodness for move semantics then! Though I do wish you didn't have to choose between passing by const reference and pass by value. That's really an implementation detail.
I respectfully disagree: Mine: http://ideone.com/3SiMv Yours: http://ideone.com/N8Gmi (if you kept the const reference case, the call is ambiguous and doesn't compile: http://ideone.com/lKjct) Note the difference in the x = z assignment.
No, no, a thousand times no. Rather than rehash it all anew, I'll just link. http://www.reddit.com/r/cpp/comments/nlpy2/when_and_where_do_you_prefer_pointers_over/c3a6dqv TL;DR - Write your APIs so that a reader can see the implications of calling them WITHOUT looking at your code. Non-const references are an abomination.
To clarify: the original hack is acceptable to me, but I find it to be more cumbersome overall than simply using the language properly. What is abhorrent is using non-const references to pass out or inout arguments.
Also, Scott Meyers' [Effective C++](http://www.informit.com/store/product.aspx?isbn=0133068625) is really good for learning ways around the sharp (hidden) edges in C++. The STL is pretty important too.
You should be able to tear through [Accelerated C++](http://www.acceleratedcpp.com/).
I'm assuming you are talking about passing a test rather than actually learning the ins-and-outs of the language. So I guess it depends on what type of test this is. If it's for Uni and there was a huge book with multiple assignments per week, then you are probably boned. You should have just read the book dude. Saying that, tests in school often cover the same type of non-sense found in interviews. So google C++ interview question and learn all of the answers to those. Syntactical things can be gleaned from tutorials like this [http://www.cplusplus.com/doc/tutorial/](http://www.cplusplus.com/doc/tutorial/). Make sure you actually try to write stuff. Maybe even see what it takes to convert a Java program you have written to C++.
Why? Why can't the transfer function return a new bank state with new accounts reflecting the change transaction? alice and bob are just account keys, not accounts themselves.
&gt;you don't want to end up there knowing all about templates and finding out it's an STL test. It might be worth knowing something about templates if it's a test about the standard *template* library. :-)
I made that exact mistake. I prepared for the test thinking it was going to be about C++. Instead, they tested whether you'd memorized the appropriate functions to call on an std::map and the correct syntax to do so with. Using a written test.
you won't do it. 
&gt; Instead, they tested whether you'd memorized the appropriate functions to call on an std::map Pathetic.
I feel you, bro. I need to learn how to play the violin in two weeks for some dumb concert.
I start my first C++ job in two weeks and I can you assure you I'm _not_ ready either. I do know the language though.
To be entirely honest, it was atrociously bad. Still, I didn't prepare for that kind of test and got the 5th highest score of the entire group - and I did it a year ahead of the actual classes while not being in that class. More goes to show how terrible the rest was; they had months of classes about it and got a worse score. Group of about 100 people.
Because, as I explained, the new bank state will be oblivious to other concurrent accesses to each bank account. There are many things that are inherently stateful — trying to force them into a immutable stateless mold is only going to bring you pain. Oh, and bugs. :)
Stroustrup may be out of date. The test may cover the new C++11 standard e.g. nullptr, auto, lambdas etc
Oh, of course, completely agree - state is unavoidable. The point is, you don't have to model that state with mutable arguments. Look at how output iterators work in the standard library for example - it simply returns an iterator that models the new state. Much simpler than side effects.
If you're able to get a book, there's a book that teaches very well the basics of C++, from there you can build on it by looking at [learncpp.com](www.learncpp.com ) and [www.cpluscplus.com](cpluscplus.com) The book is called C++ programming in easy steps by Mike McGrath ( [amazon link](http://www.amazon.com/Programming-Easy-Steps-Mike-McGrath/dp/1840784326/ref=sr_1_4?ie=UTF8&amp;qid=1341498172&amp;sr=8-4&amp;keywords=C%2B%2B))
The easiest way is to build a time machine, travel back around 10 years, and then start reading and programming. :)
But at least you know how to play the guitar and trombone already right? You should be fine.
Relevant reading: http://norvig.com/21-days.html
What about "Programming: principles and practices using C++"? I know it's designed more towards people who have never programmed before in their lives, but I find that the contents are layed out in a way that allows beginner C++ programmers to get up to speed with modern practices (vector, string vs. C crap).
To be honest you should be able to pass a university test, assuming that's what OP means.
A while ago I had a test on C and most of it was about using some non-standard libraries such as "dirent". Well I did okay, but I completely blanked on some the the members of the structures so what I did was put in a comment "I forgot the exact names, but I'll try to make it obvious what I'm going for, I can always use a #define to fix this later." I did quite well despite that, so if you can show that you know the basic syntax and know how to think like a programmer you should be fine for a test.
Indeed, that's one of the more readable books by him. But it, too, gets very "referency" after a few hundred pages and at over 1200 pages, it's a bit ... heavy.
&gt; With a non-const reference you simply can not know whether your arguments will be modified or not. CAN NOT KNOW. Golly, there is so much about a function that you don't know without inspecting the code. Things such as whether the function actually behaves as documentation says it should; the types of exceptions it may throw (does it throw 'int' instead of something derived from 'std::exception'?); the time it takes to execute the function; etc.... My point is that staying away from a feature just because one cannot be certain of how it may be used is silly. If you did, you wouldn't be able to use C++ at all -- or most programming languages for that matter. &gt; There is PLENTY about C++ that even the committee hates (just attend one of Herb's conferences). They make the best of what they have inherited. True... but I still have never heard one of the members of the standards committee say to avoid references to non-const data. I didn't see this recommendation in Sutter and Alexandrescu's coding standards book. I haven't seen this recommendation in any blog by well-respected C++ people. &gt; And yes, there are some things that are better expressed with non-const references (e.g. operators). Yes, operators are better expressed with references to non-const data. But beyond that there can be significant performance increases when using references to non-const data. Take the addition assignment (i.e. the equivalent of operator+=) of large sparse matrices for example. With your restrictions, I would have to allocate a new result matrix and then assign the result to one of the input matrix. That results in extra allocations and deallocations (as well as other work). RVO and rvalue references can't save you here. A significant amount of work is saved by using in-out references to non-const data. &gt; I would not advise anyone who is implementing apps to use them Now that is just plain silly. Operator overloads alone make using math libraries much easier to use. But beyond that there are performance advantages in many situations (as I pointed out above) and declaring that one cannot take advantage of those potential gains because you can't absolutely know (except by perhaps looking at documentation...) whether or not the argument will be modified or not is very silly -- especially when one of the reasons people use C++ is because of its good performance. (Before you say anything about premature optimization, please note that one should not prematurely pessimize either -- there is a rule about that in the Sutter-Alexandrescu coding standards book too.)
Easiest way to remember: If it has a name it's an lvalue. The end. :-)
Off topic but similar story. In college, I was always good at math, so I didn't really try to hard at anything I didn't find interesting. Sadly, calc 2 things started to get harder, I didn't do any of the homeworks (not collected), and was doing poorly on tests. For the first time ever, I went to a tutor, to see if he could help. He asks me how much I study before a test, I casually respond with "about 30mins". His facial expression after was priceless :) Edit: For OP, I always like to jump into languages. If you want a challenge, build a 'string' class that is as fast as reasonably possible, allows users basic operations, can be converted explicitly or implicitly to a 'const char *'. And make it 'copy on write', but do NOT look up code for any of this if you can help it, just look up more generalized concepts. Oh, and Sony will be using your string class in their games, some of which rely on multi-byte characters. Make sure it supports that, not just a list of 'chars'. You CAN use STL, but obviously not the 'string' class or anything like that. No C functions though. Oh and make sure it's exception safe and const correct.
You won't make it probably because of your attitude towards this, but here is what you need to do: 1. Get off reddit and internet in general 2. Read/learn what all the keywords do 3. Learn what basic types are available in the language 4. GET A BOOK with examples and type them all by hand and run them - do not move forward unless you understand what the example does ...
... Unless it's a macro. :-) 
Not in my language lol. Excluding #include and #ifdef guards, macros are the devil.
Unless you have daily direct access to someone who is an excellent C++ programmer to "learn" it in two weeks you WILL need a book or some thorough online document (e.g., a detailed web site). Since you're posting to Reddit we are (very likely) assuming that you don't have daily direct access to such a person, thus, you will need to devour a good book or two, e.g., "Accelerated C++" and "The C++ Standard Library: A Tutorial and Reference" --or your course text book (as you are writing a test presumably in a course) or something equivalent. It is hard to systematically go through C++ in two weeks by oneself trying to pick up as much as you can without some guidance (e.g., from course instruction, teachers/teaching assistance, a seasoned programmer, etc.). Of course, if you only have to learn a small subset, then you're much better off --but your post said "learn C++ in two weeks" --not a subset of C++.
If you would pass your smart pointers around via const reference, then you aren't going to be modifying the smart pointer -- why not just pass in a reference to the object or ,if you need something nullable, a pointer to the object? The problem with passing via const reference (in a public function) is that someone may come and want to use your function with a different type of pointer. For example, let's say your function takes a shared_ptr: void Foo(const std::shared_ptr&lt;Bar&gt;&amp; barSharedPtr); Now someone who has a unique_ptr&lt;Bar&gt; wants to use your function: void Baz() { std::unique_ptr&lt;Bar&gt; = something_returning_unique_Bar(); // ... Foo( /* errr.... how do I convert std::unique_ptr to std::shared_ptr? */) // ... } I've come across such scenarios and they are a pain in the butt to work around. Overload the function so that both shared_ptr and unique_ptr have definitions? Then someone is going to want to use boost::scoped_ptr or boost::intrusive_ptr ... or a COM-ptr ... or some other pointer you haven't thought of yet. Nailing down the type of smart pointer *for public functions* will in the future make someone curse your name -- and that person may even be the future you. Now specifying a reference to a smart pointer for private functions may make sense. It's the public functions that will cause the aforementioned problems.
You can't store that in a homogenous container though, like std::vector.
How long did this take you from concept to public ready? This is solid work.
Would be great to adapt this to include HTTPS server support in cpp-netlib [cpp-netlib](http://cpp-netlib.github.com/)
Imagine you're reading someone else's code. When you see x += y, you know that x is going to be modified. They syntax makes that clear. When you see foobar(x, y); you have no idea whether x and y are modified or not. So you look at the header. It says int foobar(int &amp;x, int &amp;y); Does it modify x and y? You still don't know. Even if it does not modify them today, are you 100% sure that the next revision of foobar() won't change? That some poor new hire doesn't screw it up? I'm not. As for Herb's take on non-const refs, I don't think I would misrepresent him to assert that he thinks the syntax is damn stupid for exactly the reasons I listed. Obviously, you can do what you want in your own code. But to put forth that non-const references are the right way in general is a disservice to legions of C++ developers who WILL get it wrong. A motto by which I have lived for a dozen years: Always code so that the next poor bastard to read your code doesn't have to hunt you down. There's a good chance that that next poor bastard will be you.
&gt; I think I misunderstood your bullet then. Yeah, it's difficult to explain with just one bullet point. ;-) &gt; I see what you meant was don't use smart pointers for public interfaces at all. To clarify a bit further: you can use smart pointers for public interfaces -- but only when you need to transfer ownership. But when you are not transferring ownership, use naked pointers or references. :)
&gt; So you look at the header. It says &gt; &gt; int foobar(int &amp;x, int &amp;y); &gt; &gt; Does it modify x and y? You still don't know. You have to assume it will modify x and y! If someone intended for the function to not change x and y, then they should have used const references. &gt; As for Herb's take on non-const refs, I don't think I would misrepresent him to assert that he thinks the syntax is damn stupid for exactly the reasons I listed. I would really like to see a citation for this. Or do you know him personally? &gt; to put forth that non-const references are the right way in general That's not what I said. I said that if you want a reference to *mutable* data, pass by reference; I do not think passing by non-const reference is a good "general-case solution". I do believe there are times where passing by non-const reference makes sense. You obviously believe otherwise.
I've been thinking about all that you wrote. The corollary to not using non-const references is to only use non-const pointers -- otherwise the caller will be confused into thinking a variable might be changed when the function signature clearly says that it can't. Am I right? Is that what you believe?
But only *after* you know C++. I know because I tried.
So we agree after all! It's a good idea to use naked pointers when you don't want to make any claim on ownership.
&gt;When you see foobar(x, y); you have no idea whether x and y are modified or not. &gt;So you look at the header. It says &gt; &gt;int foobar(int &amp;x, int &amp;y); &gt; &gt;Does it modify x and y? You still don't know. So you use pointers instead. Now the header says int foobar(int *x, int *y); Does this modify x and y? You _still_ don't know (although you know that by convention, the answer is _maybe_ -- but then again, you knew that for the reference version too).
no, std::vector supports storing boost:any
So how come you're not posting this as a response on stack overflow?
Good idea &amp; done. :-)
I was going to suggest Cygwin, but perhaps a linux virtual machine is a better idea. 
&gt;Perhaps it could be a guide for learners on what to study next. "*[L]earners*" **of what**? If you're just learning C++ -- not introducing yourself to programming in general -- then I think that "*mastering both runtime and compile-time polymorphism (and how to use them together)*" is relatively minor. If you've already learned a language like C# or Java then the kind of polymorphism you're going to encounter in C++ will be familiar to you. Granted, you will not understand the nuances, but as a Java/C# programmer who came to C++, I found that fairly minor. The most major thing as far as I'm concerned for people learning C++ **specifically** -- rather than just programming in general -- would be learning how to properly manage an object's lifetime, especially an object that wraps something from a C API (i.e. RAII, copy/move constructors/operators, destructors, etc.). Moreover: I would say that people introducing themselves to programming in general would be better suited with... ...well pretty much **any other language**. C++ is -- in my opinion -- more finicky, idiomatic, and nuanced than even C. It is unsuitable for beginners. Why so many people choose to try and learn it as a first language is beyond me.
Ok, I like the part about RAII, that is the kind of thing I want people to mention. However: &gt;[L]earners" of what? Of course I'm talking about C++! This is the cpp subreddit! I don't give a crap about other languages, or learning programming in general.
c++11 is a godsend. the stl algorithms with lambda predicate functions finally make the algorithms fun and prettier to look at.
I think that good C++ programming is founded on thinking in terms of ownership and object lifetime. There's more to the story than that, but those principles are vital and often violated.
I completely disagree. OOP is *essential* to good C++ programming. Even if C++ favours flat hierarchies, *that is still OOP*. I have never worked on a large scale C++ project that did not require a working knowledge of OOP. I would actually discourage deep hierarchies without good reason. One of the first C++ questions you get in job interviews is "What is the virtual keyword?", and there is a reason for that. Because if you don't know you are not worth hiring. EDIT: I just wanted to add that there is a reason I mentioned "runtime polymorphism" rather than OOP. 
The comments on SO (where I don't feel like creating an account) miss one of the most unforgiving aspects of undefined behaviour: it can act like you expected it to! This is particularly pernicious as often you write code and it works. For years. And then you upgrade a complier, or include it from a different file and suddenly the nose-exiting deamons appear!
And yet you just confirmed what I said and contradicted yourself, you said you need working knowledge of it, but its not the "most important aspect" as your question asks for. Just because what is a virtual is a question on an interview doesn't mean its important for someone just beginning to learn right away.
I can see a language like C++ overwhelming and turning a beginner off.
C++ was my second. With the latest revision, many things become very much easier. I think it's feasible to teach it as a first. That being said, C is much simpler and perhaps therefore more suitable
I find it always helps to not write sloppy code :-) and to make it a point (when it is relevant) to compile the code with maximum warnings on (e.g., including treating warnings as errors) and periodically test with multiple compilers/platforms. For some items, machines are so similar so they are easily missed without a careful reading of the standard or enabling some compilers' or lint tools' optional warnings about portability.
&gt; If you've already learned a language like C# or Java then the kind of polymorphism you're going to encounter in C++ will be familiar to you. The compile time polymorphism is much more powerful than that available in Java, can't speak for C#.
error handling and secure constructs. may as well not even be writing code if these aren't paramount
That's exactly the point - you can see at the call site that args are passed as mutable. You don't need to look at the called function.
This. Came here to post a comment that would have been pretty much identical. RAII is critical, STL stops you from reinventing the most common wheels, and OOP concepts are the foundation of C++. Not sure I agree that User Defined Types should be on this list but the rest is gold.
I think the most important aspect is that C++ is a multi-paradigm language. Too many people tend to pigeonhole C++ as an OOP language, and bring up too many needlessly complex ideas too soon. Using C++'s built-in objects such as vector, string, map, etc is fine. But not every bit of code that you as a user of C++ needs to be stored in an object hierarchy. Take the bits that make your life easier and use them, and keep learning, and you'll be a fantastic C++ programmer. It's only when we stop learning and assume we "know" something that we really start to fuck things up.
Without a doubt, RAII. However, you get RAII for free if you make proper use of STL containers and use appropriate smart pointers (like shared_ptr). It's also useful to know how to use custom types with STL; e.g. writing a custom iterator. Idiomatic code looks more familiar and allows you to use all of the standard STL algorithms. There are gaping holes in C++03, especially in STL, and you will drive yourself crazy reimplementing code that should be part of the language or its standard library (e.g. auto, lambda, foreach, unordered_map, multi_array, etc). Either learn to use Boost or switch to C++11, both of which solve most of the problems. The best type of code is code that you don't have to write.
Not the most important one (that would be concepts like iterators, templates or RAII) but my favourite pet peeve because it’s so often done *and taught* wrong: [**Don’t use pointers**](http://dl.dropbox.com/u/6101039/Modern%20C%2B%2B.pdf).
Do you consider the fallowing an improvement on the standard? std::pair&lt;B,A&gt; swapped = std::swap(a,b);
Not really. With swap, you don't return the swapped elements, you apply a procedure to both of them. So in a way they're not out-parameters. It's kinda fuzzy I know lol.
I use C++ for industrial engineering simulation and optimization code.
Thanks and I hope your job turns out well.
I recently left a job doing C++ for bond trading systems at Morgan Stanley.
That's awesome. I think that would be my dream job, working in the investing industry. What process did you go through to get the job?
I do functional verification on CPU components using C++ at Intel, among other things...
I work on C++ compilers and standardization. Some areas where you'll see C++ used heavily include game development, operating systems, computer graphics (e.g. modelers, renderers, etc.), high performance science (most notably recently the LHC software that detected the Higgs particle) and web browsers. In finance it's used not only for high performance trading and modeling, but also for large scale financial data management (think the stock exchanges themselves, Bloomberg, etc.). "Media" software like Photoshop, PDF renderers, etc are also C++ based. Several major C++ compilers (MSVC, Clang, ICC) are also implemented in C++ themselves. The other notable ones are mostly C based (gcc, XLC). C++ often seems to be at the bottom of the stack somewhere. JavaScript and Java virtual machines are one example of this. Another is Facebook's compilation of PHP to C++.
Many of the big internet companies write and run C++ servers, M/R frameworks, etc. There are many millions of lines of application level C++ code you interact with every day.
I worked ~4 years on silicon process modeling software that was all in c++. That language was the best choice for the project in question by a wide margin. High-powered OOP and functional features combined with asm-level where needed makes it a hard language to beat for large systems with performance-critical kernels. 
I personally don't like recruiters; they are good at promising the world, and delivering nothing. Go to the sites of individual companies, see what's available, and find something that you are a good fit for. Finance is not an easy industry to get into, so make sure you know the technologies backwards and forwards, and are up on your interview techniques. 
I've worked 12 years with C++ programming. Desktop applications at my previous jobs. Currently I work on high performance server software. Also remember most regular of the shelf software are usually written in C++. Adobe ships software written in C++, most if not all current Anti-Virus software are written in C++ and all browsers are C++ software. This is only just mentioning a couple of examples. Having your own project is really awesome, but you might be consider to contribute to some open source software also. Just to show that you can participate in a large project and not be intimidated by large legacy C++ codebases. 
UI development, visualization, now games. The jobs are out there, but you may have to work hard at landing them, which includes applying for out of town roles with the risk of relocation. I'd advise you pick an industry or company more than the language itself, and once you have experience with C++ with then you have leverage to go where you like.
Accelerated C++, by Koenig and Moo, is pretty much the reference for learning C++ if you already know a programming language. It's old, so it unfortunately doesn't talk about C++11, but it does give excellent bases. There is one very important thing in C++11 though: smart pointers. Since a Java programmer is used to let the system manage the memory automatically, smart pointers do make a good transition. ---------- One good exercise for ex-Java programmers: make a small (or mid-sized) program without using `new`. It is, IMHO, the best way to learn about the power of stack-based variables (even if, under the hood, the heap is actually used).
There was a similar topic here recently, perhaps you'll find it helpful: http://www.reddit.com/r/cpp/comments/vq3re/from_java_to_cc_any_advice/
And then learn not to (over)use them. One of the things I find my students doing often is declare-everything-as-a-pointer-call-new. Even something like int *variable; variable = new ...
This allows you to declare a class (of known size) which easily converts to and from enum values. Especially useful if you want to forward-declare an enum, or guarantee its size.
Burn your book now. It seems to be teaching you all the wrong things. You're learning either C, or C++ as it was in the late 1980s. There's no way a C++ program can leak, or have buffer issues, since you never have to free memory yourself. A good C++ book should start with the basics, std::vector and std::string. Pointers are fairly advanced topics (and come after references); dynamic allocation is an even more advanced topic. See also [this thread](http://www.reddit.com/r/cpp/comments/w7cfs/c/). ---------------------------------------------------------------- Or maybe you're trolling, and I bit? 
Wait, if you call new you don't need to delete? When did that change?
But far from all C++ applications uses smart pointers and exceptions. In embedded applications it is common to mix C and C++ and you need to have a thorough understanding of memory management. 
My impression is that in embedded applications, you don't use dynamic allocation at all. You do need to perfectly understand how the stack works though. &gt;you need to have a thorough understanding of memory management. True. But that's an advanced topic, unsuitable for a beginner.
&gt;My impression is that in embedded applications, you don't use dynamic allocation at all. You should definitely try to avoid it as much as possible but I have worked in a couple of embedded projects where a lot of new and delete calls where made for internal msgs between threads and things like that. But you are right that it is unsuitable beginner topics. 
How do threads work in embedded, BTW? Do you have multiple microcontrollers? Or a full-blown scheduler?
I did C#, then Python, then Perl and now C++. Yesterday someone joked I was making a trip back in time and I'd be doing COBOL afterwards. My impression with switching languages is this. Languages can be ranked by "complexity or discipline required to write them" in the eyes of the interviewer. It starts with Assembly and real time constraints on one extreme and moves towards Web Apps in Python or Visual Basic on the other. With hardware and performance and developing platforms at one end and simply "business logic" on the other. Once your foot is in the door somewhere making the switch seems to be like this. (I'm not much saying this for benefit more because I like to hear my own voice): - To go into lower level code demonstrate discipline (debugging, profiling), technical knowledge (undefined behaviour?) and understanding of performance (simple APIs, very reusable, Big O) - To go into higher level code demonstrate communication skills (working in a team), ability to take on doman logic (ask about the business intentions long term, Sales? Upselling?), Good OO style (long term intentions, design patterns) and a little knowledge of some (generally large) framework they use (Django, ADO.NET, Tomcat) 
Well, one use case is in [this stack over flow question](http://stackoverflow.com/questions/71416/forward-declaring-an-enum-in-c). Another is using `Enum` in function declarations, in headers. If the values of the enum change, then normally anything that includes those headers would have to be recompiled; with forward declarations, only those files which include `Enum`'s definition have to be recompiled.
At least in Sweden the word embedded is still used for such applications. Microrpocessors like ARM and integrated chips like Texas Instruments OMAP are now so cheap and powerful that they are used in mobile phones, radio transceivers, tv boxes, modems, GPS equipment etc. All those things are generally called embedded systems AFAIK. 
&gt;&gt;assumed we could safely use exceptions as we would in Java code. &gt;Actually, you can. Except in destructors. Only if you are using RAII for everything, which if you're programming like in Java you aren't.
&gt; In C++, use smart pointers and RAII. Unfortunately, as you noted, most of my teachers came from a C background. They either did not fully understand RAII, or they felt it was not worth teaching. I had to learn it myself by watching Stroustrup's lectures and reading Effective C++ years later. It's the kind of thing that, for a Java programmer, is very unfamiliar territory. :) As for smart pointers, they didn't really explain those either. I imagine that was partly because they didn't want us to wrongly assume some kind of garbage collector was running. Still, it would have been helpful to get into it after we understood memory management in C++.
I'm a game developer. We almost exclusively use C++. I personally do low-level engine and rendering stuff.
Cool. That's also a good exercise for ex-C programmers. Or even certain oldschool C++ programmers!
I work with C++ on real-time physical simulations, for research and medical applications (trainers).
Not really. A C programmer is used to stack variables. Including variable-sized arrays.
In other words, you wasted a year by learning nothing. I really wish C teachers would teach C. At least it's a language. Not my favorite, but it works.
With all due respect, this *is* marketing. While I'm sure you are genuinely interested in other programmers' opinions, you're still promoting your product by doing this.
Any chance of eventually decoupling your product from Visual Studio (and Windows)? Having to buy an OS license just to try another static analyzer always seemed irritating to me.
Saying 651 lines is too much is simply unrealistic. Just what kind of ivory tower are you living in? I checked in basic_regex_parser.hpp in boost 1.47.0 just as a random example - 2,820 lines. Now, looking for the biggest file in the root directory of the source at work, uh, 32,777 lines. Now *that* is what you call an unmaintainable mess!
In the projects I have been involved in we have used special branches of the Linux kernel that where maintained by the microprocessor manufacturer and then modified the kernels to suit our custom boards. 
Must be a new Windows release coming up -- Microsoft is parading around the latest whiz-bang, half-baked, flavor of the month developer tools. A few years ago, .NET was going to save the world from itself. Now that everybody is proficient in C#, it's time to move the shells around again. Just because you declare a "native renaissance" doesn't automatically mean you will have traction where the rubber contacts the road. I wish there was a Daily Show that called out MSDN the way the real Daily Show calls out Fox News. 
They may want to pay attention to the other Renaissance - [Objective-C overtakes c++] (http://developers.slashdot.org/story/12/07/08/2228220/objective-c-overtakes-c-but-c-is-number-one )
I haven't watched it, but I think this is what you mean: template &lt;typename T&gt; struct Identity { typedef T type; } template &lt;typename T&gt; void foo(typename Identity&lt;T&gt;::type x) { bar(x); } The `Identity` struct seems pointless, as it takes a type `T` and "returns" the same type `T`. Its entire purpose is that the compiler is not able to reverse that mapping and discover that nothing is going on. The `Identity&lt;T&gt;` in the function signature is an impenetrable wall to template argument deduction. As a result, you *must* specify the template arguments to this function `foo`; that is, you must always call `foo&lt;int&gt;(0)` or `foo&lt;double&gt;(0.0)`. This is almost never useful, but it *is* useful for things like `std::forward` that must have a template argument provided to be meaningful.
Interesting that they mentioned portability in the blurb while promoting Metro, CX, DX11, AMP and their IDE in the same sentence.
I'm not into all the marketing stuff, but I know most companies in the field have multiple products, with different features thrown in. For example, you'd see Norton Antivirus with only on access scanning, and Norton Internet Security with added parental control, website reputation, phishing detection and so on. I think it's pretty normal to encourage the users to upgrade to a version with more features, BUT more expensive. IIRC, Avira Antivirus Free has a daily (?) popup that encourages people to buy the premium version, with more features. It's not something uncommon, and it doesn't scare users, if you ask me. If you want to talk about scaring people, there are rogue software that give the impression that you're infected with hundreds of malware whenever you open My Computer, and redirect you to a webpage for some software like Antivirus Cleaner Pro 2013, advertising it can clean your computer. That's a totally different story. The AV industry is really competitive, there are a lot of companies, and none want to risk to do something stupid, such as scaring their own clients. I don't think it's even worth it, since most of their money comes from contracts with other companies/government organizations.
It's a pity, though, because it isn't even that difficult to swap out the native evented OS APIs for things like libevent.
I didn't mean to insinuate that you were indulging in unscrupulous business practices, but that more than likely your company is bordering the unethical line in the way that they market their product. Just interesting to see how the developer of said products feels about how their code could be used in such a way. 
I wonder why people complain about Microsoft's CX extensions, but Borland's C++ Builder extensions or GCC ones are fine. If the side effect of these efforts is less VMs and more native deployments, then it is all for the best.
Here's something I was playing with a few weeks ago. Works perfectly. http://pastebin.com/bNTXwdJr
Boost.Asio has rapidly become the de-facto C++ async' library. It is well worth investing your time into. You can get far, fast, by watching the Boost.Asio videos from boostcon and C++now. The are really good.
Just use boost asio.
Quite a few of the MS guys (in particular Herb Sutter) stress that 99% of your code should be pure ISO C++. The remaining 1% is for boundary stuff like talking with managed code.
Ah crappy... I can never find one that I can get into quickly and diving through github and what not generally doesn't help. All of the crap that I use is wayy too big for me and I get overwhelmed when I look into even trying to help.
Do you have any links to these videos? You know for us lazy people
You aren't doing a non-blocking socket there. What you're actually doing is polling the socket before hand to see if there's any action you need to take. That's effectively an asynchronous call to accept() because the only time you'll call it is when there's data waiting and it won't block. It works just as well.
Well if you're interested in open source but you find it hard to start contributing other projects, you can always start your own project. Create a program or library that you need and which doesn't already exist. It's better for everyone if you release it as open source. Other people can use it more easily, give feedback and even send patches and start contributing to it. Hope this help.
Ya that brings the problem of not knowing what the hell to create lol.
PMed you all the link: http://www.avkf.org/sum12_STEVENS/cs590ws/lecindex.html
That only works if you don't want to change the label_t after construction. If you want to do further modification that's not possible or convenient with the label_t constructor, you end up dealing with a raw pointer: label_t label = new label_t("Hello World"); label-&gt;setColor(255, 0, 0); // may throw and would cause a memory leak window-&gt;add(label); 
Boost.asio. 
I don't think this is correct. It is my understanding that unless you make the socket non-blocking, you can still block even if select/poll/epoll/kqueue previously said the socket was ready. There is a race condition between when select returns and when you call accept. The tcp stack could empty the listen queue between those calls and then accept will block. If you want non-blocking, use non-blocking sockets and handle EAGAIN, otherwise you're asking for trouble.
First, try this and if that is similar to your problem, read the rest. This uses c++0x. #include&lt;iostream&gt; #include&lt;vector&gt; std::vector&lt;int&gt; test(4); void dispose( int where ) { test.at(where) = -1; } void add( int what ) { test.push_back(what); } static int HP = 1; static int EMPTY = 0; int main() { test.push_back(HP); test.push_back(HP); dispose(1); test.push_back(HP); for( auto i : test ) { std::cout &lt;&lt; i &lt;&lt; std::endl; } return 0; } There is some misconception here how std::vector works. Firstly, when you do std::vector&lt;sf::Texture&gt; textureArray(4); you are creating a vector with 4 elements. If you push_back on that, it'll push in another element. Vectors aren't usually restricted in size (or rather, not like that). Secondly, whatever sf::Texture is should probably not be set to NULL, as this will likely result in some unexpected cast. The vector initialises itself, in this case to sf::Texture's default constructor. Thirdly, your disposal doesn't actually dispose of anything, it just sets some element to, essentially, an "empty"-Sprite. This doesn't change the size of the vector. To recap: * You start with a vector of size 4 * Then you set all Sf::Textures to NULL, whatever the result of that * Then you push something into it (vector size now 5) * then you dispose of something (vector size still 5), but now your vector looks like this: [ NULL, NULL, EMPTY, NULL, HP ], where "NULL" marks whatever actually happens when the compiler sees an assignment of an int to a sprite. what you want is completely different and crucially probably not a vector. Just for the sake of it, with a vector, you need something like this (There are a few assumptions about sf:: in here): std::vector&lt;sf::Texture&gt; textureArray(4); sf::Texture invEmpty; void initInv() { invEmpty.loadFromFile("invEmpty.png"); for( int i = 0; i &lt; 4; i++ ) textureArray[i] = invEmpty; } void addItem( sf::Texture item ) { for( int i = 0; i &lt; 4; i++ ) { if( textureArray[i] == invEmpty ) { textureArray[i] = item; return; } } // inv full } void delItem( int where ) { if( where &gt;= 0 &amp;&amp; where &lt; 4 ) textureArray[where] = invEmpty; } else { // error, out of range } } Also, why are you using 1-based vectors? Vectors start with index 0. You actually never do anything with the very first element.. *edit:* Misplaced init
asio is a proactor-based network library.
I was considering that, but (I guess mistakenly) threw out that idea because I was worried that it'd increase the size over 96 (more than I wanted). Perhaps I shouldn't worry about this though. I'll try changing addItem to that and see how it goes. Thank you for your suggestions.
think of saying .at as looking at something that already exists in the vector. itll throw an error if you try to look at something that doesn't exist. pushing back always increases the size of the vector. let me know how it goes.
[…and I just now realized that your initials are STL.](http://i.imgur.com/D3lON.gif)
Would be nice to write pure ISO C++ code, except for you know... the fact that MS doesn't have an even remotely standard compliant C++ compiler in either VS2010 or VS2012.
I know I know. I wish their compiler was up to par also. As a whole the ecosystem kinda sucks, but there are people there who do care and want programmers to do the right thing. I bet if it were purely up to Sutter and the guys like him, they'd have a much better toolchain.
Perhaps consider the source code repositories: http://en.wikipedia.org/wiki/Source_code_repository For instance, SourceForge.net has a Project Help Wanted board: http://sourceforge.net/people/ http://sourceforge.net/projects/alexandria/forums/forum/710 There's also been a similar question posted on stackoverflow: http://stackoverflow.com/questions/38881/how-to-find-opensource-projects-looking-for-help Suggestions given include OpenHatch, looks interesting: http://openhatch.org/search/
&gt; MS is focusing far too much effort on the proprietary extensions instead of making a C++ compiler that simply works without fighting. Once they have a standard compliant library, and they want to add extensions to the language, not only would it not be a problem, it's something that should be encouraged. New language features often start off as non-standard extensions. There I agree with you.
I think I'm gonna have to re-make the entire inventory system using classes instead. In your opinion do you think [this](http://www.dreamincode.net/forums/topic/230256-c-help-with-rpg-inventory-and-item-system-please-and-thank-you/) would be a good tutorial to follow, or do you know a better one? It's hard to find information about making a visual inventory system online.
I THINK this is a good one: http://blip.tv/boostcon/thinking-asynchronously-designing-applications-with-boost-asio-5250947 and there are newer video from cpp now event, which are great but don't explain Asio quite as well as the first video http://www.youtube.com/user/BoostCon/
Does this allude to Symbian C++ Active Objects? That really takes me back (in a bad way).
Even though it still covers only C++98 I think *Accelerated C++* by Koenig &amp; Moo is still **the resource** to teach modern C++ from the basics to very deep. Once you can comfortably apply what is laid out in that book making the switch to C++11 is not hard.
For a start, overloading operator() doesn't parallelize your application!
lots of improvements and new features: - Currently distributed communication pattern implemented are: Unicast, Broadcast, Scatter, Gather_All, FromAny, OnDemand - first distributed implementation based on ZeroMQ message library - dnode class added, minor changes to node class
You stutter?
When I first saw this post, I thought "active objects" referred to a different pattern. I'm curious, do you know the name of this other pattern? The pattern is that you want to have all calls to a given object occur within a single thread, even if the objects' methods are called from multiple threads. The idea is that you create a thread to handle all function calls in a synchronous manner (a thread pool of size 1 if you will) and then have all calls forward the work to to that worker thread. The pattern is a really nice way to create an object that is thread-safe from a library or object that cannot be executed from multiple threads. 
actually, yah, that looks good. some one mentions templates in there at some point, don't use templates, inheritance is what you want. in your case, id probably have your base class store the texture you want it to display in the inventory, then drawing it just becomes looping over the list and drawing whatever texture happens to be stored there.
The only book updated for C++11 (as far as I know) is the [C++ Standard Library: A Tutorial and Reference](http://www.josuttis.com/libbook/), which is, as it's name implies, but a good tutorial on the standard library, and a good reference book. Aside from that, until the books like Effective C++ et al get updated, your best bet is probably google or stackoverflow.
I haven't tried so many different unit testing frameworks for C++ yet, but so far my favorite in terms of use, reports and the like has been Gtest because it also allows me to use Gmock easily. 
Hi ZMeson, The pattern you are describing is exactly the semantics that cppao implements. I am curious as to what part of my description gave the impression that something else was going on? Now, as an optimisation, cppao can use its own scheduler (as opposed to the OS as a scheduler), however if you use the base class active::thread, then you are indeed dedicating an OS thread to the object.
This took about 15 minutes for me to implement and works like a charm. It does run a bit slower actually.
Why lgpl, for widespread adoption would bsd or boost not be a better bet ? 
Thanks for the tips. I might shoot you another comment if I get stuck :)
I just started reading that right now. It's not perfect, but it's a pretty comfortable introduction, coming from a C#/Java programmer. I'd recommend it. Though I am getting the vibe from the book that a more advanced book will definitely be needed afterwards.
Hmmm.... Describe "a bit slower". A couple nanoseconds overhead per call or something along the lines of microseconds? Also, for your typical application (*yours*, not someone elses -- I'm not asking you to guess someone else's code), what is the typical execution time of a function call and how much percentage wise does this additional overhead slow you down?
Another possible expansion is to consider the ability to specify a specific active-object scheduler you wish to attach a particular object to rather than just assuming all objects wish to run on the same scheduler. I'm just thinking somebody might want to have finer control -- be able to stop or pause execution of some objects while other objects continue running. But I don't have a particular use case in hand; maybe that is not really a valid use case (while I've wanted to use active objects in the past, my work doesn't really lend itself well to using them).
It was a long read but thank you. I think I'm gonna overhaul the entire thing and re-do my inventory system from scratch, using classes.
I don't understand why I'm being downvoted, when I gave a source...
Is there really a problem with the first fragment identified for PVS-Studio in Doom 3? If so, it looks like the code has been edited incorrectly for the website. As written, it looks like it checks to see if the token is "muzzle_flash", then reads a new token, then checks if the new token is also "muzzle_flash". Sounds like a bug even if that were the case, but certainly not a scenario that should be detected by a static code analysis tool. It looks like this mistake was caused by the brace (non)alignment style of the devil :)
I don't understand. Could you give an example of two objects for which x\&lt;y, y\&lt;x, and x==y are false?
That's there already.
Around 50% slower, according my my benchmark program (bench.cpp). But I think I can improve on it.
I couldn't care less about reddit votes, I came here to ask a question to people more knowledgeble than me.. not get up/down voted.. I don't think you should care either
Don't pick a school based on the languages they use... if you want to become more familiar with a language, read a book. For C++, people tend to recommend Accelerated C++ followed by Effective C++.
I do agree, I don't mind GPL for end user facing applications (IE programs) but for libraries it is just overly restrictive. MIT, BSD or boost are much better lic's for libraries.
But learning a programming language is an extremely small part of any degree. You should evaluate your options based on the quality of their C.S. program, which is not necessarily dictated by their choice of languages. And I'm not sure what kind of degree you're looking at, but anything in C.S. is not going to go very deep into any particular language. If you want to learn all the details of C++, your best bet is to read a book.
Many universities don't teach all the programming languages they use in their curriculum. You are also supposed to learn some on your own for the assignments.
&gt; Any thoughts? Well, yes, the problem is that you overload the meaning of return value: the existence of compare() gives no hint about whether 0 means "equal" or "incomparable". So the code which cares about this must now call ==, which is an additional overhead for types where 0 means "equal". (sort doesn't care about this, but other code may.)
Read the article that vegardno linked to in another reply.
Consider complex numbers: i &lt; 1 is false 1 &lt; i is false 1 == i is false
Try [r/cpp_questions](http://reddit.com/r/cpp_questions).
Not exactly sure, but I believe the reason is that dlfcn is a C library and you must provide it a C-function (there is no "new" or "delete" in C). AFAIK there is no pure C++ way to load dynamic libraries.
You can have new &amp; delete working, *if* you export a C++ ABI, instead of a C ABI. The example you link to is using "extern C", which requires C ABI linkage. This is often desirable for two reasons: 1. The C++ ABI can change between different compilers and --from time to time-- even between different versions of the same compiler and... even with different compile time flags with the exact same compiler (for example, C++11's ABI is subtly different enough from prior implementations that it often causes problems) 2. If you want the capability, dynamic linking with dlsym (so you can do plugins where you have no knowledge of the library at build time, just have a contract that all plugins should have certain functions being there) is going to provide access to functions in a way that the C++ runtime is oblivious to (for starters, there's the whole name mangling issue) without some extensive, very non-portable hackery. The big downside of course is "extern C" really can't provide you with C++-ish capabilities in its interface. If you want the "real" C++ runtime, do your shared libraries as per [the *second* answer in that question](http://stackoverflow.com/a/497067 "C++ shared library using C++ ABI"). tl;dr: if you just want shared libraries, you can keep (pretty much) all the goodness of C++. It's the "dynamically linked shared libraries" (i.e., you don't see the library if you do "ldd /path/to/executable_or_shared_library") that really doesn't work so well with C++'s ABI.
Out of curiosity, how would a Q&amp;A website using the Socratic method work? Like Project Euler?
&gt; Don't do this across libraries or you will find that the leaky abstractions in C++ will fail you: you are entirely outside what the language specifies. There are plenty of systems which already do this. Of course, they aren't dynamically loaded libraries. It can work fine across libraries as long as they share C++ compiler/runtime and have shared correct headers/class declarations with each other so the compiler can correctly determine the interface. &gt; How is something newed in one library freed in another? What about exceptions? Etc. In theory, if all the libraries share a common compiler/runtime, there need not be a problem. The problem really is only that the C++ runtime model is not sufficiently well defined that compilers/runtimes can confidently talk to each other in exactly the same "language", but I could totally see a compiler/linker/stdlib maker implementing a standard API for dynamically loading C++ modules compiled/linked the right way... if they thought it'd be worth the trouble. That last one is a pretty huge IF.
Well Go is pretty pointless overall. Does nothing nobody else doesn't.
That doesn't work in C++. &gt; I'm curious how this works in other languages I'm curious too. Are there other languages where this works? I'm know a little about Haskell, but it has a different approach to inheritance, so the question doesn't really apply in the same way. In C++ you get the same problem with the ternary operator: A a = condition ? B() : C(); and with lambdas auto x = []() { if(1) return B(); else return C(); }; The types need to be identical in order for it to work. (You can probably have different cv-qualifiers, i.e. one `const` and the there not.) You can fix the lambda by telling it the return type: auto x = []() -&gt; A { if(1) return B(); else return C(); }; I think the standard does not require that such inference work. Maybe individual compilers will allow it sometime as an extension. It can be difficult to infer a type if there is multiple inheritance - there may be multiple distinct parent types. (I'm using `g++-4.6 -std=gnu++0x`)
People who work on the C++ standard are a lot smarter than you and me (definitely smarter than me and I am pretty sure smarter than you as well). So there must be a reason why they didn't add automatic return type inference to normal (non-lambda) functions. That reason is accessible even to you and me, if we just stop to think for a second instead of rushing to "fix" the language. In this case the reason is support for separate function declaration and definition: auto adding_func(T l, T r) -&gt; auto; // What is the return type? 
It is slower, however if you don't do something like this for some problems you will get a stack overflow long before you run out of memory. Also std::stack is based a container adapter for a std::deque, this means that it doesn't actually have to allocate that frequently.
The policy in that case is obvious: the inference doesn't work unless the definition is there also :-) It works with lambdas, so it can be made to work with function/method definitions.
With all due respect, was there any need for you to say: &gt; People who work on the C++ standard are a lot smarter than you and me (definitely smarter than me and I am pretty sure smarter than you as well). My comment wasn't arrogant. Was there any error in my comment? Is the average Redditor not allowed to have any opinion on how languages could change?
I'm not a fan of recursive functions, but this solution is not very good either... It is certainly slower than the base version and that about the same amount of memory (perhaps more if the calls are optimized). Some functions can be converted to iterative versions that are much faster, but this is not the case here...
&gt; A a = condition ? B() : C(); This is actually not legal in C++, though it should be.
Cool.
Well you can use this macro(from Dave Abrahams) to reduce the code repeat: #define RETURNS(...) \ noexcept(noexcept(decltype(__VA_ARGS__)(std::move(__VA_ARGS__)))) \ -&gt; decltype(__VA_ARGS__) \ { return (__VA_ARGS__); } So you can write this: template&lt;class T, class U&gt; auto sum(T x, U y) RETURNS(x+y) However, this doesn't work with lambdas. Lambdas are almost worthless in C++, because you can't use them in polymorphic functions. I hope this get fixed really soon in C++, or at least compilers will have an extensions to make this work(much like they had `typeof` for a long time). Most compilers could easily extend functions to infer the return type like how lambdas work, like this: // Type inference that currently work with lambdas auto lambda = [](int x) { return x; } // Type inference for regular functions // This is how I would like it to work template&lt;class T&gt; auto fun(T x) { return x; } Adding polymorphic lambdas to C++ will open the door for local templates, something that could cause problems with some functions. If they limited local templates to templated functions only then this would work. Hopefully, that will be the route they take. 
My understanding is that one of Go's biggest draws -- and one of the reasons it was invented in the first place -- is being comically stupid fast to compile. And it still has C++ beat *there*. I recal reading that Google saw just how much time and energy was spent recompiling code for minor changes ( even Java! ) which technically shouldn't require large cross-module dependencies but still triggered massive rebuilds. Go was targeted at solving that problem. I think that's a very interesting thing, even though it's not enough to make me consider Go.
Dynamic linking with dlopen/dlsym() isn't that hard. The loader must first expose an API that the loadee uses to register itself. The loadee then only provides a single on_load() entry function that is extern "C". on_load() performs the appropriate registration of factory functions, callbacks, etc. Check out Boost.Python for a C++ library that does just this. The tricky part of using dlopen() is that one of the flags violates the One Definition Rule: You must specify RTLD_GLOBAL to obey the ODR, not RTLD_LOCAL. In Boost.Python this shows up as an inability to use C++ RTTI, or throw exceptions across module boundaries, since Python uses RTLD_LOCAL. Err, at least it used to...
I disagree with the article. Go and Rust are not revolutionary languages, they are *evolutionary* languages. The improvements in C++11 are great, but they don't fix what is an overly complex and often baroque language. For example, the author blows off Go's garbage collection and suggests that `shared_ptr` is an acceptable substitute. It's a substitute, to be sure, but it's an awkward one. First, you will scatter `shared_ptr` everywhere, which adds typing and duplication to your code: `func save(user User)` is more concise than `void save(shared_ptr&lt;User&gt; user)`. You could save some typing by introducing typedefs (like `UserPtr`), but that only adds a layer of indirection, and therefore complexity. When I write C++, I find that `shared_ptr` leaks in everywhere by default — it's simply the common case, my objects are always shared in some way, and the mental overhead of having to decide if a given pointer is shared or not is distracting. Plus, if I change an API and decide that a previously non-shared pointer should be shared, that's a lot of code that need to be refactored. In Go and Rust, all references are shared, which suits my common case. Plus, `shared_ptr` gets really evil when you need to send references to your own instance from a method. Boost has an `enable_shared_from_this` mixin (I don't know what C++11 specifies), but it feels like a horrible hack, and it gets ugly with inheritance. (I don't use inheritance except for interfaces and traits, but it still gets ugly.) And finally, `shared_ptr` is not fool-proof; due to the complexity of C++ itself, it introduces some surprising, hard-to-debug edge cases where you may have a pointer that is freed while you still have a reference to its underlying pointer. (I forget the exact details, but it's subtle.) Go is not a perfect language by far (I am much more impressed with Rust, which I hope to adopt over Go when the language stabilizes), but it smooths a *lot* of hard edges that make C++ so infuriating. For example: Header files. Separating C++ classes into headers and .cc files adds an insane amount of code duplication and sources of simple compilation errors during development. Not to mention include guards. Or carefully maintaining precompiled header files to avoid your compilation time blowing up. Or the ridiculousness of having to put implementation code (!) in your header file because of a template. It's 2012 and they are *still* trying to design a proper module system for C++.
It should be fine to do: A* a = condition ? (A*) new B() : (A*) new C(); You can't downcast objects of automatic storage duration because of slicing. But pointers can be (implicitly) downcast as far as you like.
I agree with everything. But I'm more interested in Go than Rust.
I've been known to have that certain problem..if I saw any object that seemed pretty huge to allocate on the stack, I'd twitch. 
I'm in the same boat as you ( well, my programming is for games, so not *really* ) -- For you and me quality of generated code outweighs cost of compilation time. But Google has different needs from us.
To c++ or `shared_ptr` As I said in the vast majority of cases a `std::unique_ptr` is far more apt. It has no overhead (shared_ptr has to maintain a ref count which can have serious issue on cache performance) and ensure that the programmer write code with a much better notion of ownership. There was a C++ panel where Bjarne Stroustrup explains that `std::shared_ptr` should be the exception not the rule.
Fine, but if you think replacing `shared_ptr` with `unique_ptr` in some way addresses the criticism I spent two paragraphs on, you totally misread my intent.
I agree that lambdas in C++ can be made better. But I disagree that they're almost worthless as-is. Lambdas make working with the STL infinitely nicer than before (and it was pretty nice before.) I don't think I've written a one-off functor in ages (one-off meaning a functor to use in one spot and only one spot in my code.)
Did you partake in any of Go's concurrency? Go may seem like a boring language because it's all things you've done previously, but well, that's *kind of* the idea. It just does them better and without much surprise. It just *works* as it's supposed to. You don't however, get templating/generics with Go. I'm not so sure I miss it, to tell you the truth. Especially with how *beautifully* interfaces work. It's almost the same thing since with templating you're generally either going to be using the value under a type or the method attached *to* the type (or you're a lazy bastard and you want to write a function once). Interfaces give me the same tools as templating did with almost no loss.
It's far more complicated than just adding some option in a Makefile, I'm afraid. For one thing, a binary is dependent on library versions, not just architecture. You can't really just compile "Linux x86" binaries, what you're really compiling is "Linux x86, glibc &gt;= 2.13, libstdc++ &gt;= 4.5, libfoo &gt;= 1.1, ...". Since the library versions can vary by distro, that means you either need to offer a binary package for every version of every distro, or you need to link against the oldest version that you want to support. Sometimes that's not even an option, for example when the library has undergone a major revision and some distros carry libfoo 1.x and others libfoo 2.x, with the two versions being binary incompatible. Somtimes you can build statically, but that's not always possible. And this hasn't even begun to address the issues of setting up a cross-toolchain. 
My point only addressed `shared_ptr`, I said I agreed with the overall opinion on the article.
The problem with writing: template&lt;typename T1, typename T2&gt; auto adding_func(T1 l, T2 r) -&gt; auto { return l + r; } is that the function prototype is useless: template&lt;typename T1, typename T2&gt; auto adding_func(T1 l, T2 r) -&gt; auto; since the return value needs to be known. The same holds for functions that are not templates: auto adding_func(int l, int r) -&gt; auto; So the return type must be computed and we are likely to never see the syntax you mentioned. (It certainly would make it easier to write.) But you never know a great idea that improves such might come along! :-)
I concur but remember that Google is able to use dynamic linking with languages like C++. Only if the ABI changes does code need to be recompiled. Google has the resources though to write and use their own ABI so that external linkage names and method invocations are under their control. But the latter is an issue in any compiled to some machine/byte code languages that permit linking.
&gt; If C++'s weaknesses compels one to pass artifacts of the objects (ID, name, etc.) instead of the objects themselves, why use C++ No, i meant that the User object could contain *less* and you could then pass it by value. If User is shared then there's obviously some shared state in there that it may be possible to factored out in to another object held by a a shared_pointer internally. I'm of the opinion that smart pointers should only appear in your public APIs rarely, that unpredictable object lifetimes are cases in the minority, and I find that I generally don't 'scatter shared_ptr everywhere' in most of my code.
I dont know much about macs but most of my software I write at work can compile in either Windows or *nix. I use [Make Project Creator](http://downloads.ociweb.com/MPC/docs/html/MakeProjectCreator.html) which takes your project definition and can create Makefiles, Visual Studio projects, Eclipse projects, etc. Maybe the eclipse option would work for macs. 
The unit testing framework in Boost is very nice and well worth using. The docs don't show it off very well --but it is actually really easy to use well and effectively. Moreover, it is really easy to write and run unit testing code (esp. for non-GUI CLI code) incl. knowing what went wrong and where. Nicest, IMO, is the unit test implementation's use: it makes total sense to any C/C++ programmer, is terse, straight-forward, and a minimum of fuss. The trick is getting to understand what you really have to do to get it work (which is not a whole lot). Then you say, "Duh! That's easy!"
wow, that's probably the only thing Gentoo ever made easy.
I thought the big attraction of Go was a nicer syntax for parallel/distributed work, and a native compiled language with garbage collection. I don't see this article talking about the distributed nature of Go, but the Google talk I saw on Go put this feature up front and center.
Any language with proper libraries to abstract OS APIs is portable.
Same happened to me. I even tried to do some contributions in the beginning. What I find specially sad is that most talks about why Go is great, are about doing concurrent web servers, in a way that can be easily achievable in many mainstream languages if you know the language and ecosystem properly. But the language just lacks too many abstractions for my taste.
Both features you can get in other more established mainstream languages. go func () {} vs Thread/Task/Async.Do (() =&gt; {}) or for channels ch &lt;- msg vs ch.Send(msg) Languages != Implementation, most static languages do have compilers with native code generation, even the JVM and .NET based ones have them. 
Actually, *both* are trivial compared to the issues around the free store. I just was mentioning the one that everyone knows about in hopes that there would be no debate. Boy, do I feel dumb. ;-)
Maybe take a look at Scons. We use it extensively in work and it abstracts away a lot of the pain or cross platform development.
Linux is a developer nightmare. Windows has DLL Hell but Linux is SO Armageddon since static linking is nearly impossible.
Not that I know of. C++ is such a beast I can only imagine it'd be a yellow pages sized monster ...
I'm writing a *very* math-intensive sidescrolling 2d game right now, in C++, and while I don't know how much longer it will take (I still have to write a level editor and a sound system...), I'm already contemplating my next project. Long ago I used to do simple amateur robotics -- in hardware and in simulation (which got me into game programming) -- and I would very much like to go back to it. I also would like to get some experience writing a large, complex and concurrent system in a language other than C++ since I feel I spend too much time in C-family languages. Like I said earlier, D has appeal (though I'm very aware it's C-family). But hey, maybe I'll give Go a shot. Honestly though, I'm more inclined towards Rust :) 
Used it for computer vision &amp; interactivity.
Well, I thought "Expert C Programming" was a decent read but titled somewhat poorly. 'Collection of thoughts from a C compiler writer' would have been more fitting :p "Ruminations on C++" although it of course misses the recent evolution, there is still some decent knowledge there in similar bite sized spirit.
Out of curiosity, do Rust have slices (like python, Go, or D) where one can say: vector1 = vector2[5:9]. And things like that? I read the entire official Rust tutorial but could not find any reference to slices... And I couldn't find it in the manual either. Edited: Someone in the Irc pointed to me the function "view", who does slices. But it would be nice to have a "sugared" syntax like other languages slices.
Im currently usiing *A Complete Guide to Programmingg in C++ (2002)* because the section are organized neatly and generally pleasing to look at. Should I switch books? (intermediate java background)
This is an interesting project! Sure you can use NMake or a cross platform build system like SCons but this is a much better user experience since it can support correct incremental builds and also editing the project from VS directly. Also since all GCC/Clang versions have similar command line syntax, it should be easy to extend this to support cross compilers for Linux for example
Alternatively just write something that scans the .vcproj and .sln and builds a SCons/CMake file. I have a deep distaste of bloated IDE's and find Visual Studio is only really any use as a (quite good) debugger IMHO. I find the fact it does not respect the file system and has to have a separate file / folder structure maintained by hand intensely annoying and laborious and error-prone but I can appreciate you are hemmed in by cultural restrictions.
It seems to me, that writing a tool for generating project for other build system from MSVC soulution and project files will take comparable amount of work with the thing I try to do... or may be I just like my idea more :) (although, in some sense solution proposed by you is more usable, as I would be able to use same Scons project for building my solution under nix system). It looks for me that further discussion is just exchange of preferences :). Anyway I highly appreciate your opinion and advise. Thanks.
+1. Thanks a lot for mentioning these products... They seem to do anything I need. And even lots more... I think, I'll give them a try. Though, I think, I will continue development. Just for fun. And may be to save 100 dollars :)
Essentially, you mean something which can replace MSBuild like the Intel compiler can? Sounds like an excellent idea to me.
You shouldn't use auto_ptr in a container like a vector. The way auto_ptr handles pointer ownership for some operations is incompatible with STL containers. You can use boost::shared_ptr (or std::shared_ptr in C++11) safely in a container. For better performance use boost pointer containers: http://www.boost.org/doc/libs/1_50_0/libs/ptr_container/doc/ptr_container.html
...and unless your OBJECT type is really small, if you use vector&lt;OBJECT&gt; you're going to be doing more copying than you probably want to especially if the vector changes a lot. Another alternative would be to size an array to the maximum size you'll ever use if that size is small and you know the maximum. boost::array or std::array are generally preferred in this case because they perform as well as plain arrays but have convenience methods that make using them a little less error-prone. 
auto_ptr&lt;int&gt; is not a good idea. The compiler will be able to optimise operation on a plain int member but won't be able to to the same thing with a pointer to an int. I can't think of a compelling reason to do this. 
I can't think of a particularly compelling reason, but it was just an example. OP says their really going to do it with a custom class.
All of the comparison operators evaluate to a boolean value (`true` or `false`.) When converted to an integer, `true` is 1 and `false` is 0. 
Ha..but you are right, it does come down to preferences - it's your project and I hope it goes well. Although I'm amazed to be downvoted for trying to steer people away from proprietary, platform - specific solutions.
Actually, it is not replacement for MSBuild. But the comparison with Intel compiler is right. Yes, finally I want to achieve same integration of MinGW into VS as Intel compiler have.
oops, not sure where that comma came from in the title!
ncurses seems simpler and it is already installed on most Unix like systems.
Very nice.
GCC 4.7 compiles everywhere and has regexes, so you can just cross compile with it to get the functionality anywhere you need it.
I haven't tried building it on Windows yet, only OSX and Debian. But on those, I can link against &lt;regex&gt; fine with std=C++11. I used this sample: #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;regex&gt; int main() { std::string fnames[] = {"foo.txt", "bar.txt", "zoidberg"}; std::regex txt_regex("[a-z]+\\.txt"); for (const auto &amp;fname : fnames) std::cout &lt;&lt; fname &lt;&lt; ": " &lt;&lt; std::regex_match(fname, txt_regex) &lt;&lt; '\n'; return 0; } You might need to compile a custom libstdc++ for it to link properly, using whatever the post 4.7 versioning was. It is bundled with G++ though, so I don't see why it would be missing.
I have implemented a 'SortedArray' for the [D-LAN](http://www.d-lan.net) project, it may interest you: http://git.euphorik.ch/index.cgi?p=D-LAN.git;a=blob;f=application/Common/SortedArray.h;h=a1fd0413a30eed7647926667b81dabf8608d2fbb;hb=refs/heads/chat ;)
I'll add some more. * Shared pointer is not warranted, and the documentation doesn't mention it at all. I expect it to behave like standard containers, which copy or move the contents. This one may surprise me as changes to the original will mutate my copies. * Need iterator traits. * Copy constructor doesn't seem necessary. * `T` requires a default constructor. * Can template on comparator, otherwise you always have to drag `std::function` around. * Initialising raw pointers with `new` in the initialisation list is a no-no (`SortedArrayData::root`). **TL; DR** Use `std::multiset`.
Likewise I am the author of http://www.benhanson.net/lexertl.html and believe it to be well coded.
&gt; From the class user's point of view this is a sorted array. He shouldn't care about the implementation apart the complexity of each methods maybe. Being contiguous is more than an implementation detail. If the storage is continuous I'd be able to shove a raw pointer to the first element in a C function, which expects an array of struct, as I could do with `std::vector`.
&gt;Shared pointer is not warranted, and the documentation doesn't mention it at all. I expect it to behave like standard containers, which copy or move the contents. This one may surprise me as changes to the original will mutate my copies. Yes, it should be mentioned in the comment header. &gt; Need iterator traits. I currently use it only in this project and I wrote only what I needed. But it's a good idea, yes. &gt; Copy constructor doesn't seem necessary. That's right. &gt; T requires a default constructor. Yes, as all the Qt containers. &gt; Can template on comparator, otherwise you always have to drag std::function around. The comparator function may be switched at runtime. If I use a template parameter I can't do that. It isn't? &gt; Initialising raw pointers with new in the initialisation list is a no-no (SortedArrayData::root). Why? Because of exceptions in the constructor? &gt; TL; DR Use std::multiset. How can I access the n'th element of a multiset? 
&gt; Here: https://github.com/Ummon/D-LAN/blob/chat%23214/application/Common/TestsCommon/Tests.cpp#L203 ;) Faith in humanity partially restored. I really didn't expect you to actually have made any, which was the main point behind my comment :-)
To quote my self: &gt; but it is written in C, and that's OK. I felt even my C++ skills strenthened by having such an example to pull from. Don't just skip to the link.
i like [libpoco](http://pocoproject.org/)'s code. i understand why many would disagree (especially boost users :-)
I started writing a [lightweight wrapper around the Raptor C library for parsing RDF documents in C++](https://github.com/bstamour/Raptor-plus-plus) last year for a course I was taking in semantic web. I haven't had time to come back to this code and clean it up or complete it, but you're of course free to look at it. Some highlights: * Utilizes a few boost libraries (namely, fusion and variant) * Uses C++11 concepts such as variadic templates and rvalue references, and not just for toy examples * Decently tossed together (for the most part lol) Lowlights: * Needs to be completed, currently a very small subset of Raptor was wrapped (enough to get my project finished) and the rest is built on top of that * The code I write nowadays is cleaner, so looking back on this is kinda blah * Needs better comments * I used shared_ptr inside of some objects where I should have used unique_ptr instead. Man I can tell this is old code 
Try Chromium.
If you are looking for C++, checkout the source code for Qt. Having to keep binary compatibility in C++ for long stretches you will find that the source code API to be significantly above average. Most classes have matching unit tests, manual tests and they all have docs. A ton of effort was put into API design (http://chaos.troll.no/~shausman/api-design/api-design.pdf was born out of this) resulting in code that is more maintainable and easier to read. Like any project there are warts, but as a whole if you are looking for nicely written code Qt (or the above pdf) wouldn't be a bad place to start.
You could search for projects that publish some sort of coding guidelines and then look at the code that meets guidelines you like. You didn't specify any criteria for "nicely written".
I would have to disagree about Qt (not QT) code being like Java, but either way he asked for "nicely written code" which Qt is and I still stand by it as something to checkout. Of course checkout those other libraries too, there is nothing wrong with seeing the different ways that people write code. Some is readable, some is a horrible horrible mess.
The Google Style Guide [claims](http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=C++11#C++11) that they do not use C++11 yet. How come it is used in LevelDB?
Is it? Could be but it also contains some nifty code that I found interesting. On the other hand, I consider opening parenthesis on the same line as conditional expression ugly :). Anyway, I guess that great deal of the programmers are more exposed to ugly than pretty code. In that regard, I'd reckon it's better to be able to identify ugly code and find/create/compare with better solution than just look at magnificent code and not knowing where and how it came about.
I dont even consider Qt to be real C++ because of MOC. Enough said. 
You seem to have all your function definitions in the .hpp file. I haven't coded in C++ for a while, but I seem to recall that this practice has the tendency to lead to multiple definition errors (at least it does in C). Also, I found a bunch of gotos in lookup.hpp. Eeeep! Though to be fair, they seemed like legitimate uses for a goto... I still don't like them though.
So good that it is repeatedly held up as a good example in [Game Engine Architecture](http://www.amazon.com/Game-Engine-Architecture-Jason-Gregory/dp/1568814135/ref=la_B0024JGKJK_1_1?ie=UTF8&amp;qid=1342661336&amp;sr=1-1).
Yeah, this shouldn't be done for local variables. The underscore suffix was a response to programmers using "underscore prefix" for member variables. The "underscore prefix" phenomenon stemmed from programmers shortening the Hungarian notation of member variables being prefixed with "m_". But depending on the flavor of Hungarian notation (Apps or System) the underscore was followed by a prefix indicating some semantic hints, or the variables type, respectively. So what emerged next was a trend of C++ programmers to omit the "m" from "m_" because, it only takes a one character prefix to distinguish between local variables and something that might be instance or class static, right? The problem with this is that the C++ standard reserves variable names starting with an underscore to C++ implementation developers. As a result, people started to suggest the underscore suffix for member variables. I think it was something from Sutter or Meyers, but if anyone reads this comment, I am sure I will be corrected. I have a sneaking suspicion that lobster_johnson knows all this, and he is correct--there is no sane reason to suffix a local variable with an underscore.
If you ever want to look at an OS's source code...Haiku is pretty terrific compared to the alternatives. It's written in C++, and although it has some quirks from BeOS's design that are arguable in their benefit, you'll see that on a whole it works out and is written pretty logically.
You can compile gcc with most versions of it, I think since 4.0.
[OSL](http://code.google.com/p/openshadinglanguage/) has C++ implementations of [Perlin noise](https://github.com/imageworks/OpenShadingLanguage/blob/master/src/liboslexec/noiseimpl.h) and [Gabor noise](https://github.com/imageworks/OpenShadingLanguage/blob/master/src/liboslexec/gabornoise.cpp), along with cell noise, etc. 
The point is not aesthetics, it's that Chromium isn't exactly a bastion of modern C++ style.
I would definitely like to write a complementary parser generator. I'm currently converting http://www.codeproject.com/Articles/3854/An-introduction-to-lex-and-yacc-part-2 to use lexertl and it would be really nice to have a bison-like tool for the grammar. I'm not sure what AG or burg is. There is a simple code generator included with lexertl though. EDIT: http://www.benhanson.net/parsertl.html
What do you mean? If you use it you will see that it is Java like, everything is an object descended from QObject, right there is enough - that is the essence of Java. And then absolutely everything has be allocated directly onto the heap, no smart pointer, no clever RAII based stack type which can be "moved" Because of this they have gone and reinvented the STL with there own more "Object Orientated" (rather than templated) containers and string classes. A lesser point (but still 'culturally' valid) is that they use Camel Case Java style. So when you have written some "standard C++" using the common lower_case_underscores method it becomes inconstant. The fact is, if boost where to make a GUI library (how I wish they would) it would look NOTHING like Qt. I accept that they had technical limitation "back in the day" but that unfortunatly for them does mean that their code is still good now.
I thought github is written in Ruby?
You don't *need* SDL, but it makes your life easier. You might want to check out SFML instead, since it is C++ where SDL is C, but they do basically the same thing. There are a *lot* of opengl tutorials, but I'd warn you about following the old ones, like NeHe, since they often use outdated techniques like display lists and immediate mode rendering, which is easier to do at first, but totally useless for anything more advanced than a spinning cube. This one seems good: http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.3:-Rendering.html
Go to /r/gamedev and look at the side bar. Have fun.
&gt; everything is an object descended from QObject This is only true for Qt classes. That's quite reasonable for a framework I guess, and wouldn't call that that essence of Java. &gt; And then absolutely everything has be allocated directly onto the heap, no smart pointer, no clever RAII based stack type which can be "moved" Do *you* use it? Because you are not forced to allocate on the heap in any way. &gt; no smart pointer There is a wider variety of smart pointers in Qt than in the standard or Boost. [here](http://qt-project.org/wiki/Smart_Pointers). &gt; Because of this No, they reimplemented the STL because Qt dates back to the dawn of C++, and many, many compilers had shaky support for the STL and templates. &gt; with there own more "Object Orientated" (rather than templated) containers and string classes You either used only a very old version where this was true (reason is not to be "more OO" but the above-mentioned lack of support) or you haven't used it at all. Qt containers are templates, and can be used with STL algorithms if you want to.
I used GLFW to get an OpenGL window up and running. Pretty good library :)
I second SFML. It's quite good. I really like the direction 2.0 is going in, as well. 
What do you already know, Do you know C++ already? Do you have any prior games development experience...?
I briefly looked at the sourcecode for Irrlicht for work (that file included, actually). I don't know if it performs well but stuff like: 163 for (u32 i=0; i&lt;6; ++i) 164 { 165 if (i == 1) 166 { 167 if (Params.Stencilbuffer) 168 { 169 os::Printer::log("Cannot create a GL device with stencil buffer, disabling stencil shadows.", ELL_WARNING); 170 Params.Stencilbuffer = false; 171 pfd.cStencilBits = 0; 172 } 173 else 174 continue; 175 } 176 else 177 if (i == 2) 178 { 179 pfd.cDepthBits = 24; 180 } 181 else 182 if (i == 3) 183 { 184 if (Params.Bits!=16) 185 pfd.cDepthBits = 16; 186 else 187 continue; 188 } 189 else 190 if (i == 4) 191 { 192 // try single buffer 193 if (Params.Doublebuffer) 194 pfd.dwFlags &amp;= ~PFD_DOUBLEBUFFER; 195 else 196 continue; 197 } 198 else 199 if (i == 5) 200 { 201 os::Printer::log("Cannot create a GL device context", "No suitable format for temporary window.", ELL_ERROR); 202 ReleaseDC(temporary_wnd, HDc); 203 DestroyWindow(temporary_wnd); 204 UnregisterClass(ClassName, lhInstance); 205 return false; 206 } 207 208 // choose pixelformat 209 PixelFormat = ChoosePixelFormat(HDc, &amp;pfd); 210 if (PixelFormat) 211 break; 212 } Made me lose confidence in it
http://www.arcsynthesis.org/gltut/index.html Probably the best tutorial you're gonna find.
Well, it's people trying to be clever. I couldn't come up with another way of doing *exactly* the same thing without code-duplication or function calls within 5 minutes.
`-std=c++0x -Wextra -Weffc++`
Ah I didn't notice the "else"s, which goes to show how unreadable that code is (especially since it's not documented at all)
Nah GLFW is better. I started with glut and then realised halfway through that it was shit.. and then had to go through and replace it all. I mean glut is ok for a very simple window but GLFW is just better in every way as far as I know with more nifty features.
Not that I know of! Accelerated C++ is your best bet at the moment, it is a very good and quick introduction to C++. However fair warning I expect to see texts of various qualities released in the near future to support C++11. It will take awhile for the community to accept which are the better texts. That being said if I was to learn C++ now I'd definitely concentrate on the 11 version, done right you will be set up for ten years or more. 
Well it is transition time for C++, as such I'd recommend concentrating on the new C++11 version of the standard. Further I'd recommend dropping Visual Studio like a rock and concentrate on the use of either GCC or LLVM/Clang. Do so on Linux or Mac OS/X. For learning on the cheap use Linux, that is a distro supporting the latest bleeding edge GCC or Clang. The main problem with Visual C++ is all the proprietary stuff that comes with it. Now I will be the first to admit that they have tried to address that from the last time I used VC. However if you really want to learn to build software and use compilers I'd suggest starting out with command line tools and here either GCC or LLVM/Clang win hands down. Plus you can use the same tools from a number of IDEs. At this point no compiler is perfect as far as C++11 support so that really should concern you and as a beginner probably isn't a big issue anyways. That being said I'm left with the impression that your issue isn't simple mechanics of writing software but rather how to structure an app in the greater sense. This may be a problem that you might not pick up on in independent study though you certainly can try. Things like arrays, lists, stacks and other data structures are fairly simple to understand, the real challenge in programming is putting these components (the right ones) together in an application. I'm not sure if you have grasped the power of the standard library yet but before you go on to building big apps you really need to become proficient in and understand the concepts in the standard library. Frankly I'd spend a few months getting to know the standard library inside out before even considering writing your on classes or objects if you will. Sometimes the way to make real progress is to sit in a class where the concepts are thrown at you with a bit of creativity. The teacher and class mates can often set you back on track faster than we can here because of the immediacy of conversation and real time interaction. Yeah I know I'm not ready to go back to school either. The other option is C++ specific web sites or stack over flow. Finally if you are to DIY this education don't underestimate the importance of good texts. Search the Internet a bit for lists of generally accepted texts. Just remember that almost all of them are outdated. This means careful reading on the Internet is required to deduce what will become accepted practice with C++11. 
It looks like you're modifying "inc", when you might be trying to modify "brightness". I'm assuming you meant to do something like void transition() { if (brightness &gt; maxbrightness) brightness -= inc; else if (brightness &lt; minbrightness) brightness+=inc; }
I've changed the names of the variables so many times that this was bound to happen. I'll change that and see what happens. In regards to your comment on void transition() - yes. That is essentially what I'm trying to do. I have minimal experience with Python so that was my best guess. Thanks for responding! I'll let you know how it goes.
The problems are a lot more complicated at work. It's nice to see something easier come along sometimes. Wanna know a cool trick? Get something with a face (stuffed animal, rubber duck, whatever). Put it on your desk. When you're stuck on a problem, explain the problem to the duck. Go through the code line-by-line and explain what each line does. Doing that forces you to rethink how the program works, and it's easier to find your mistakes.
Visual studio's support for c++11 features is abysmal. gcc 4.7 is pretty good, 4.8 is better, but won't have the nice debugging available in VC++.
It means that you're putting an expression where it's expecting a name to be. Think something like: brightness - 6 = maxbrightness; It's backwards, and kind of meaningless. If that doesn't help, can you post the current state of the code?
Your problem is that brightness is a defined value. This means that before the compiling occurs brightness will be replaced with 1, thus your code looks like this void transition() { if (brightness &gt;= maxbrightness) 1 = -5; else if (brightness &lt;= minbrightness) 1 = 5; } Which obviously isn't going to work. So change #define brightness 1 to int brightness = 1;
"if" and "else" (and "for", "while", etc) statements do not end with a semi-colon if (bActive == true); // Wrong! { ... } if (bActive == true) // Right { ... } Also...better to never blame the compiler. It is sooooooo rarely the fault of the compiler, that it's best to simply assume the compiler is correct and try to find your mistake. (assuming you are using traditional C++ features with a modern compiler; using an outdated compiler or bleeding edge C++11 features may not yield correct results in some compilers)
This is a bug in the design of the article. We fix article. Thank you for your comment.
Thanks for the explanation, but I think I got that. I wanted to have my own pragmas and go through the AST to do a "similar" thing like ODB, i.e. not for an ORM but for my own type of serialization that did not have anything to do with databases (embedded project, saving objects to FLASH files,etc). Although maybe I missed something again :-)
That's great. Out of interest have you looked at XNA and the like (if you haven't I aren't suggesting you should but it would be a good base). I don't know how much C++ you know but so long as you don't program in C++ like you do in Java then I would recommend aim to learn a framework like SFML. However a part of me also thinks it would be useful for you to quickly whip up a a quick 2d game in something like freeGlut or glfw you so you have a quick play with the lower more primitive libraries. Best of luck
[Generic Colouriser](http://kassiopeia.juls.savba.sk/~garabik/software/grc.html) can produce coloured output for any shell program, not just gcc.
&gt; Finally don't forget optimisations -O4 and -flto to get the the link time optimisations. Afaik highest `-O` level GCC/g++ supports is `-O3`, and even it is not often recommended. Do you have link for `-O4`? [GCC Manual](http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html) doesn't mention it. 
&gt; highest -O level GCC/g++ supports is -O3 Nope, it's -Ofast
I hear the "you shouldn't use -O3" arguement a fair bit, and I am not sure I agree. Compile you program at -O3 and -O2 are both the binary sizes acceptable? If so run them both and choose the fastest. Comparison is much better than general rules. I personally like aggressive optimisations because I use a lot of templates and they respond well to optimisations. O4 works but I believe ins't officially supported, i was under the impression it brought in some link time stuff.
It's a numeric value -- you can use `-O99` if you want and it won't complain, but there aren't currently any optimizations higher than 3, so it's kind of silly to do so. 
I think it would be great is there was an actual all warning, it would be interesting to see what is generated.
Since your brightness value starts at 1 it will never increase or decrease as the if statement below is incorrect. &gt; if (brightness &gt;= maxbrightness); &gt; brightness += inc; &gt; else if (brightness &amp;lt;= minbrightness); &gt; brightness -= inc; At the moment you're only increasing the brightness when it is greater than the max brightness and only decreasing it when it is smaller than the minimum brightness, which is the opposite of what you actually want to do.
&gt; No why get rid of unused parameter warning, that warning is so easy to fix That style of fixing does not work across compilers, so while GCC might shut up, other compilers will still complain. Getting that fixed across all compiler is not quite that easy and adds additional noise to the source code. Also removing variable names does nothing other then reduce the readability of your source code, why would want to do that? Warnings are there to help, if you use them to make your code worse, then obviously that's not quite the right way to do things. And finally, I have never ever have seen a single bug caused by an unused parameter, note once. But I have wasted counterless hours trying to clean up "unused parameter" warnings, all just a big waste of time with no benefit, switching off those warnings globally is far easy then mangling the source code for no good reason. 
[SCons](http://www.scons.org/) instead of gnu autotools.
It scales poorly to large projects. 
&gt; having nameless variables floating around that give no clue as to what data they might hold? You know that the data is of no importance. That's exactly why you don't use the variable in your function. It's even worse with your example of the postfix ++: not only isn't the parameter meaningful, but it doesn't even have a value.
hmm, works fine under VS 2011. maybe its the compiler version? try under gcc 4.7 also .get() already blocks waiting for the result, so why use both? you could just: auto result = the_answer.get(); std::cout &lt;&lt; "The answer to life, the universe and everything is " &lt;&lt; result &lt;&lt;std::endl; sorry if i wasnt a big help, but looks like compiler issue to me.
Yes, I know it works under VS2011. This was only the test. Of course if result is not ready there will be invisible call for wait. I've called wait earlier just to verify if problem is somwere there. In the meantime i've found this: http://stackoverflow.com/questions/8408677/stdasync-in-clang-3-0-libc-doesnt-work Low level libs are still not ported to ubuntu. Ech...
Actually yes that is true, but I don't mention that because technically if an optimisation breaks program semantics then the compiler is bugged, these sorts of things can happen at any level of optimisation. (these bugs are usually most prevalent in FP arithmetic where reordering and vector packing can have an impact on the result. In such cases that is exactly what automated tests are for. 
Yes, your right! Thank you very much. 
Also please note current version of gcc;s library are very pessimistic about doing this asynchronously (rather they just do it when you call get or wait), so you can use the second param in async to force it to be asynchronous (bear in mind in you test cases the will be slower than doing it on the master thread).
&gt; then the compiler is bugged Sure. But since I'm not about to fix such subtle bugs in g++, that doesn't help. If -O3 is less safe, I feel like using it is akin to rendering your code more complicated for the sake of optimisation: Don't do it prematurely; do it when your profiling tools actually tell you that you need the performance boost.
Make sure you have the new GDB which has Python-powered pretty printing of STL structures (you can also write custom ones for your own classes). [Stlfilt](http://www.bdsoft.com/tools/stlfilt.html) makes horrible compiler errors somewhat less horrible. When I open an empty C++ file, say foo.cpp, I've got vim set up so it will make the first line: //bin/sh -c "rm -rf ./foo; set -x; g++ -g -Wall --std=c++0x -o ./foo foo.cpp -lpthread &amp;&amp; ./foo $*" "$@"; exit $? That // causes g++ to treat it as a comment, but also allows me to run the .cpp file as a shell script which compiles and runs itself. It's handy for testing little things. Vim also inserts a skeleton program with main() and some standard #includes.
The obvious thing has worked for me for as long as I can remember. You can set the compile-command to "cd $TOPLEVEL/build/;make -k". The search-path for source-files in case of errors is configurable as well.
http://clang.llvm.org/
I agree completely, but I usually recommend the environments fitted to the platform. I've not been successful getting gcc working on Windows, and the command line and Powershell can eat a bag of sweaty dicks. DJGPP is also a pile of bullshit. If I were to recommend gcc, I would say run Linux Ubuntu or Mint, as, if I recall, op eluded to being native to the Windows platform. Unfortnately, learning the Linux environment is out of scope of this discussion. ANYWAY, /u/rollie82, Eclipse or Vim as an editor. Vim is going to have a learning curve if you're not experienced with a modal editor. But then you will also have to learn make and optionally automake; I don't know if Eclipse will generate makefiles for you. I would further recommend Qt, but then you'll also have to learn qmake.
You can always do the following: void foo(Bar /*bar*/) { //... } That way should you ever want to add 'bar' back in, you can. But when looking at the function, you can tell easily that the parameter isn't used either.
No OpenMP. :-(
You should try out [premake4](http://industriousone.com/premake) it is based on lua scripting and very easy to start with.
You just have to find the option that sucks less for you. At my job, even though everything we do deploys on Linux, the legacy build system is based around Visual Studio 2005 (!) Solutions: on the Linux side we have a custom Ant task that groks the solutions and turns them into appropriate Ant tasks to do the builds. As a Unix developer it drives me batshit crazy, but it's ingrained here. I'd rather just maintain Makefiles and let the few developers that prefer Visual Studio cope... but that won't happen. When it comes down to it trivial projects can use a trivial makefile. Beyond that cross-platform builds are complex and the tools you list manage that complexity in one way or another. No tool is going to take that complexity away: if it could, it would have been done already. 
I cannot comment on Visual C++, but as an alternative, you could install the [Qt class library](http://qt-project.org/downloads), it is a cross platform UI &amp; utility class collection, which has nice [tutorials](http://qt-project.org/doc/qt-4.8/tutorials.html) and [example code](http://qt-project.org/doc/qt-4.8/all-examples.html) (I am personally not sold yet on the Qt Quick/QML technology, which is a mix of Javascript, declarative description language and C++) I think that starting with the [layout examples](http://qt-project.org/doc/qt-4.8/examples-layouts.html) might be rewarding, as you learn how to create a GUI. It is probably also a good idea to stick as close as possible to the standard library, so check out this nice [cpp reference](http://en.cppreference.com/w/). BTW, in order to enable C++11 in your Qt projects, you need to add the following line in your .pro file: &gt; QMAKE_CXXFLAGS += -std=c++0x
I actually set my compile command to check for the existence of a makefile. If one exists the compile command defaults to `make`, but if it doesn't exist, it defaults to a call to g++ with my preferred flags. This way I can still compile one-off files when I'm just playing around. Furthermore down the road I can easily bake in support for CMake.
I have the problem that I'm spoilt. I'm a java developer professionally, using maven mostly but gradle more and more. Building a java project with gradle is embarrassingly easy - if you have no dependencies and only one jar then a single line in the build script achieves this, for arbitrary number of source files and unit tests. Dependencies are then a couple of lines of boilerplate plus 1 line per dependency. What I've not worked out is why things aren't this easy in other languages. With things like pkg-config, there's no reason why c/c++ can't be this easy but it isn't... 
oh how I wish there was a good maven clone for C/C++
I'd also like to hear other people's experience with BJam. While complex projects will stay complex, if a given tool can make life easier compared to its alternatives for most common projects, I'd want to know about it
At the very least, Linux, but being able to use the same build system eventually to build on Windows and Mac would be a great benefit I suspect.
Write a makefile in JavaScript? No, thank you.
My current preference is Waf. I've used CMake a lot at work but I hate it with a passion...
My main complaint is how complicated the C/C++ build systems are *compared to other language alternatives*. Using Gradle, I can build a trivial Java project from a single line build script that incorporates compiling every single source file automatically, compiling and running unit test files automatically, and support for packaging the output. To achieve this in CMake will take me a dozen lines or more **at least**. Unless I've missed something, there's really very little rocket science needed for writing a simple build system for these things. All of the complexity is in the platform specific stuff, which the build system should hide away from you anyway. What I would absolutely love is to be able to have a project with the following filesystem (For example): / &lt;build script&gt; /src &lt;source files&gt; /test &lt;unit tests&gt; Where the build script simply says that we're building an executable, and what it's called. Finding the source files to compile is easy - it's all of the files under /src. Finding the unit test files to compile is easy - it's all of the files under /test. (We'd need some more knowledge of how to actually build a unit test program itself from the source file - such as linking to GoogleTest, or generating and linking against a CppUnit main file. That's Harder but still not Hard.) Knowing how to compile the files is easy - if it's a .cpp file then run g++, if it's a .c file then run gcc. Linking the object files together is easy - run ld. Going even further, I can say in my build script that I depend on zlib. Then we pass in to the compiler the output of *"pkg-config --cflags zlib"* and we pass in to the linker the output of *"pkg-config --libs zlib"*. I do understand that for some projects you need more control over how things work, but I suspect for the majority of them you really don't. The biggest problems will - I suspect - come from dependencies that aren't in a standard setup - not in pkg-config, not in standard filesystem locations, etc - so some way of managing that will be needed. Am I missing something here? Is there really some reason that C/C++ build systems need to be so complicated? Or is it just that nobody has written a trivially simple one yet?
Visual Studio files, and hand-edited makefiles.
Not the source code of github, but the source code github holds. As in, within the git repositories. Lots of them are publically visible, and some of those are C++.
This is my complaint right here. In a C/C++ project that's normal or even good. In java, I can do similar in maybe 20-30 lines in the main build file and a half dozen lines per subproject. And most of those are dependencies... and what's more, in my experience I have more complicated dependencies in java that c/C++ projects...
I know what you mean. I do think that my main file is more complicated than it needs to be so I'm working on reducing it. I could probably remove 50 lines if all my dependencies supported pkg-config... 
I like CMake. It's not a perfect solution, but it's a decent answer to a very hard problem.
I've actually found that recent trunk versions of clang 3.2 produce binaries that are better than gcc 4.7.1 for some of my code.
First time i hear about distcc. Next time I have a huge project to compile, I will try it! But right now, just using the -j option of make is way enough for me. Is it practical? I mean, can you easily retrieve the compilation errors or you have to go on each node to look at the logs?
I really like CMake. But ultimately - it's about what YOU prefer, because the CAPABILITIES are almost the same between all the major ones.
I posted about it before and will do so again - I use [MakeProjectCreator](http://www.ociweb.com/products/MPC) and its awesome. It kinda falls under the 'write your own Makefile' category - it will generate Makefiles from project definition files you give it. It will also create Eclipse projects, Visual Studio solutions and tons of other ones. You do need to learn its project definition syntax but its pretty simple.
Do you guys recommend learning OpenGL in depth or just using something like OGRE or Irrlicht?
That effort has now been done. Version 0.2 has now been released which I think is a massive improvement as it doesn't use macros and is much more elegant. In the end I don't think the lambda solution is the ideal, but you can see the results here: http://code.google.com/p/cppao/wiki/Samples
distcc is completely transparent, I just run `make -j40 -l6` or something on my work node from vim and errors appear as if I was running locally. It works by sending preprocessed output to the "worker" and retrieving the compiler output(s). But it can shine best when compiling something big and new, otherwise ccache spoils the party ...
What's your definition of 'large'? We've used it for console games that I would consider to be large.
I used bjam for a smallish (~10k lines over tens of files) C++ project. Would not recommend; I found bjam to be not very well documented and to have several bugs.
Our main library SConstruct is 213 lines. Each sub-library then has an SConscript of between 20 and 50 lines. Our template project SConstruct (used as the basis for all projects) is 292 lines. The project subfolders also have SConscripts so that we can compile each folder into a separate temporary library for linking (this is so that the link command doesn't get too large and exceed the shell maximum). We then have a common site_tools folder (used by all SConstructs) that contains the platform-specific compiler options and extra builders (such as lua and Cg compilers). These range from around 50 lines (linux) to 123 lines (iOS). We also have one other file that contains utility methods and custom scons options. The scripts run through all source files and ignore any that contain a platform name that doesn't match the platform being built. It can also build any custom formats using the builders mentioned above. We also have another SConstruct file that we use for building all of our art data. We can build for PC, X360, PS3, Linux, Mac, iPhone and Android.
I don't understand where your claim that premake4 does not need to be installed when building projects using it comes from. The build trees are a function of the build environment, which includes both the locations of dependencies and the type of build tool (Xcode, make, Visual Studio, etc.), and the configuration, i.e. debug versus release and so on. Thus, since this information differs between the various people who will want to build the package, premake4 will need to be run on each user's and developer's machine and so will need to be installed.
I'd like to hear about anyone's experience w/ DJB's (*) redo. * DJB = [Daniel J. Bernstein](http://en.wikipedia.org/wiki/Daniel_J._Bernstein)
https://wiki.archlinux.org/index.php/Creating_Packages Not at all. The format's pretty similar for most distros: a text file describing the package (name, dependencies, version), and a shell script to copy the package's files into a chroot-ish environment. The whole thing takes a half-hour, by modifying an example.
I just want to state for the record a dissenting opinion on the autotools. Whenever I unpack an unfamiliar source code tarball I am very relieved when it uses autotools, because I know how to work with it and I know what it supports. If they used the full autotools stack correctly, it will support things like a staging install directory (DESTDIR), `uninstall` targets, proper shared library support on a wide array of platforms, cross-compilation support, VPATH builds, and a number of other features. On the other hand, whenever I get somebody's homemade pile of shit my heart sinks, because I can almost guarantee that they did not account for something that I will want to do that the autotools give for free. I know it's not particularly popular to openly say that you like autotools, but here I am, out of the closet. 
CMake. I mostly code in C++ for personal projects, but was doing C and C++ on the job for many years and CMake is great compared with the Makefile universe I used to deal with.
So in other words you need to distribute at least three versions with your code in practice to cover Linux, OSX, and Windows.
Yes, that's exactly the point I made in my other reply about the ODB build system. Autotools is the canonical way to build things on Linux/UNIX so if you use anything else, there will be friction. The same goes for Windows -- anything other than the standard VC++ project/solutions will make things a lot less straightforward to build for the end-user. On the other hand, using and maintaining these build systems during development is a major pain in the butt.
Hang on..that sounds weirdly like a setup I coded for a studio in Liverpool....who do you work for? 
A few hundred lines. Its a FORTRAN code that we distribute with optional proprietary components. Between then multitude of Fortran compilers that we support and conditionally linking libraries, having the full power of python in the build script makes it so much easier.
Actually one per OS, since there much more than the ones you list. I am sold to CMake, though.
I think autotools is a deployment system (just like apt-get is), not a development system.
I wish there was a pretty way to do this. I've often found myself wanting to do exactly this, when multiple cases in a switch statement share code in non-incremental ways. Probably not using this trick in anything resembling production code anytime soon, though, but it's pretty clever.
Please don't ever use this in real code.
If you're really intent on doing this you might as well just use a `goto` instead of `if(false)`. At least then you could give it a label like `case_0_and_1_common:` and future maintenance programmers would have some hope of figuring out what in the hell you're doing. 
Clever. Clever is bad.
Note: This is my first post of my own new blog to Reddit, so I feel only I can get the ball rolling. Please feel to browse some of my other articles as well :-)
http://code.google.com/p/elemental/ is excellent.
I'm just sick enough in the head to love this. I can even think of times I would have been tempted to use it. But then again, I use ?: a lot to. But switch and #include both show how primitive C++ is in its heart of hearts, with a lot of wizz bang neato bolted on top of it.
...without good reason. But I concur, in so far as I can imagine no good reason.
As a maintainer, you can generate all target build tool build trees and these will work for developers as they were hand-maintained. For simple projects, its a no-brainer. For more complex projects which need dependency packages etc, it becomes a bit more complicated, but its entirely possible to avoid hardcoded local settings in the generated project files. 
Agreed, but that still doesn't make cleverness bad. 
As noted,it's a variant of Duff's Device and similar tricks used to fake up coroutines, these predate C++ and hark back to late 70s / early 80s C (pre ANSI C even).
I always get confused with the ternary operator in C... which way does it associate? (I'm assuming that it's right-associative based on what you've written, along with s/fibonacci/factorial/ and changing the second 0 to a 1)
Yeah, it's right associative in C, C++, C#, D, EcmaScript (aka JavaScript), Java, and Python, though the syntax in Python is different. It's unfortunately *left* associative in PHP, but that's a discussion to be had on a [different subreddit](http://reddit.com/r/lolphp/). 
woah, that subreddit doesn't seem to display anything on the lines where usernames usually go... interesting.
Why don't use the preprocessor to generate C++ code, so an extra build step is not needed? You could provide both options.
So in other words, the idea is that you assume that nearly all developers and users will only need a *subset* of the possible platforms and build tools, so you only run premake4 to generate the build trees for each platform+build tool in the subset. It still isn't clear to me, though, how you avoid hard-coded settings for things like library dependencies.
https://github.com/toffaletti/libten is a library of C++11 code I've been working on. I think it has a few good examples of how to use modern C++ features.
&gt; in the worst case, create and then throw away an instance of class A I'm pretty sure it's this, unless the compiler can be absolutely certain that the constructor and destructor won't have side effects.
Either that, or there should be a `brightness += inc;` somewhere. Style tip - an `if` with an `else` should probably have braces around the code, even if it is just one statement each. As with all style tips, I'm sure some people will disagree though. 
&gt; you can NOT call a constructor (except from another constructor in c++11) Not true: [placement `new`](http://www.parashift.com/c++-faq-lite/placement-new.html).
I wouldn't say you are calling the constructor with placement new, so much as creating a new object with the default (or whatever) constructor and telling the compiler where in memory the new object should be created.
I really wish ODB didn't have #pragma based API. I hate the fact it requires a specific tool to get this all to work.
I use c++ for GUIs and for the analysis of integrated-circuit simulation results.
I think they do, but C++ is C++, so you should be able to get it to compile with any C++ compiler (correct me if I'm wrong). I'd personally try to get it to build with Clang++ first (even if I can't run it... I'm not sure what the state of LLVM's AVR backend is at this point) if only for the error messages and static analysis.
I don't have any hints for 2.0, no. However, that's fucking weird. It's all based on very simple OpenGL, nothing fancy. What doesn't work?
It worked fine with mine. What specifically doesn't work? Did it fail at build or what?
A newbie C++ here, I've tried write Makefiles, but its quite hard. Any good tutorial or generator out there? or maybe should I quit and go straight to cmake?
Someone has to know! :D
That's basically it, except online and searchable haha. :D
cppreference.com perhaps?
There seem to be valid arguments on both sides. I would think the only real rule should be "make sure you really understand what likely does before using it". Also, it's not just nuclear reactors - if I have a trading system that checks a queue for incoming trades to be pushed out to an exchange, I know that 99% of the time there won't be a trade there, but when there IS a trade, it needs to be processed as fast as possible. I'm sure other industries have similar critical sections.
[cplusplus.com?](http://www.cplusplus.com)
That has nothing to do with the graphics card. What does it actually say?
One thing I don't understand: We're talking about tight loops here, right? So, if some code is "`likely`", it means it's executed often. Which, in a tight loop, means it was executed a very short time ago. Then, shouldn't it already be in the cache anyway? 
Those are runtime issues, not build issues. Secondly, the problem is quite clearly solved in the first thread you linked. Statically link it. Always worked for me.
Aw, damn. Well thank you. Ill have to try that. I think it may go without saying that I have no idea what I'm doing.
Especially because `likely` and `unlikely` aren't the general names used by gcc. They are the macro names used by the kernel, presumably because the kernel actually does always want to expect the likely branch, unlike the apocryphal nuclear reactor.
You're not actually reading the values from the user anywhere.
Lol yeah I realized that after I posted. I decided to use only one function in the end, and I got it running. That's my first program outside of the Youtube tutorials I'm following. 
I think the article is referring to a technique called devirtualization. [0] stackoverflow question may offer some information on how the compiler is able to do it. Copy paste: struct A { virtual void func() {std::cout &lt;&lt; "A";}; } struct B : A { virtual void func() {std::cout &lt;&lt; "B";} } int main() { B b; b.func(); //this will inline in optimized builds. } [0] http://stackoverflow.com/questions/7046739/lto-devirtualization-and-virtual-tables
It seems more likely that this was done to avoid the costs and complexity associated with managing many small differently sized objects. If code is operating on these pointers polymorphically the virtual call isn't going anywhere. This is definitely an issue on a console, where you have a limited memory budget and are probably working with a large memory page size if you're relying on virtual memory at all.
Since `b` is not a pointer or reference won't this always devirtualize since a concerete object is not polymorphic?
Unless I'm confused, these objects aren't on the heap at all. They're in the data segment, or on the stack if this is done within a function. Putting is as a global makes sense since you're sure the compiler will know its concrete type, even if its analysis isn't very clever. Otherwise you run the risk that it "forgets" the concrete type between functions.
The "trick" here is the compiler is *hopefully* remembering that common is actually a pointer to commonLocal, and therefore it already knows how to resolve the lookups. It's not really a "trick" though. You could/should just manipulate the object through commonLocal. Even when you make the API calls to gamex86.dll, you can simply pass commonLocal with "&amp;commonLocal" at the time of the call. The id code is actually inefficient in that it makes Init an abstract method because it is OS dependent. Since the OS is a build target known at compile time (which is exactly why they can happily create commonLocal without using a factory of some kind), you could use some form of compile time polymorphism (templates, or more simply: just having different definitions for each platform, and selecting which to buid accordingly). That would save you a lot of overhead.
Why did stl start wearing a eye patch? Was he stabbed in the eye lol
He mentions in one video, he has always had a prosthetic eye, and just began wearing the glasses that way.
For me it was just a surprise because I used to develop Silverlight apps and back in the days when there was some SL hype Microsoft put his Silverlight player on every fricking website they had. Just shows that they kinda give up on this. Not bad in my opinion even if I like C# :)
Protip: Place 4 spaces in front of text at the beginning of the line to make your text show in courier: #include &lt;iostream&gt; using namespace std; int addNumbers(int x, int y){ int answer = x + y; return answer; } int main() { int x; int y; cout &lt;&lt; "Enter two numbers to add together."; cout &lt;&lt; "The sum of those two numbers is " &lt;&lt; addNumbers(x, y); return 0; } [Here](http://www.reddit.com/r/reddit.com/comments/6ewgt/reddit_markdown_primer_or_how_do_you_do_all_that/) is a Markdown primer (Markdown is the markup language used by reddit) I used Notepad++ to add the spaces: 1. copy paste your code into Notepad++ 2. place cursor on the first line 3. hold alt+shift and press the down arrow to block select the first column (or hold alt and click drag with the mouse) 4. press space 4 times 5. copy it back
But what do you gain in using an interface if you're striping out the virtual calls? It seems to me that if you're only interested in using that implementation you could probably use the variable foo directly and this would make sure that the compiler would not use the vtable. 
I get the same feeling. A maven-C++ that can inspect code, detect include dependencies, manage what parts need compilation based on changes, build libraries, and distribute them and include them as part of the normal build cycle. I just don't get it. :-/ Convention over configuration, right? 
Doom 3 was late 2004. Actually the same year that HL2 with the Source engine came out. Neither company used this pattern in previous games (largely due to the fact that they were using C rather than C++ before this point in time.) Both games were compiled with VS2003 at the time of release.
The primary point is to have compile time polymorphism. So you could just swap out an impl at compile time with #ifdefs for example.
This makes more sense, but the same efect could be achieved by this : template &lt;class FooType&gt; inline void UseFoo(FooType&amp; foo) { foo.Bar(); } Foo foo; UseFoo(foo);
The most important thing to take from this is to write decent unit tests. Unit test coverage should catch all sorts of things like this that you might not expect, and especially should catch them when you make changes elsewhere that introduce them unexpectedly...
Only on a modern operating system. Windows doesn't come with sed unless you install it from somewhere...
&gt;`A a();` In this code, `a` is a function that takes no argument, and returns a `A`. You meant to write: A a; 
Why are STL's lectures so good? Very enjoyable.
Agreed. It's amazing how simply this can be done. I've even done it simply by having the platform specific code in headers, grouped in directories for each platform, and then simply tweak the include path. Makes builds trivial (you don't even need autoconf).
Man. I'm surprised. When are people going to figure out they don't need to do this (particularly when they don't even need runtime polymorphism!)?
Unless that is you Ric? this pattern is quite common in the games industry.
&gt; Unless I'm confused, these objects aren't on the heap at all. They're in the data segment, or on the stack if this is done within a function. I thought exactly the same thing, I'm sure it's just a mistake otherwise who ever wrote that comment doesn't quite fully understand memory management.
 &gt; by a redditor You say that like it actually matters.
&gt; by a redittor I suppose there's no point in reading that, then, since I'm not programming Reddit?
in case anybody has questions about his library he can PM the author instead of shooting emails.
Oh, and in the future, ask on /r/cpp_questions.
I will go through this lecture. Once I understand the concept it will be easier for me. Looks like an excellent resource.
Thanks. I will do that next time.
It was already set to that :(
Something else is wrong. What print function are you using to display the characters? If you are able to, copy+paste the exact line doing the printing as well as the line where you allocate storage and assign the string a value.
It's just a cout being looped through a character array. It may be a problem with a conversion of a int to a char, is this improper? vis_board[y_pos][x_pos] = char(nearby_mines[y_pos][x_pos]); vis_board is a char array, and nearby_mines is an int array (yes this is minesweeper).
Ok, we're definitely getting somewhere now. First, a quick lesson on the difference between Multi-byte and Unicode. Multi-byte is, basically, the old school version of chars. Multi-byte strings are made up of 1-byte 'char' types. That is, 1-byte per character you see on the screen printed. 1-byte per character input. Unicode represents each printed character as *2-bytes* This causes all kinds of confusion when trying to co-mingle types (which i suspect is happening in your case here) In microsoft land, **char** type is the multi-byte representation, **WCHAR** is the unicode representation. If you mix these types without going through a converter routine, you're gonna have a bad time. Back to your problem. I highly suspect that is whats going on here. What is adding to the confusion here is that you said nearby_mines is of int type. **int** type is actually 4-bytes in all but very very old versions of MS. I can tell you for certain that you are going to get truncated data doing that assignment based on type alone. What I suspect is that you have unicoded data in nearby_mines and its slicing 3-bytes off each assignment, taking away the upper 1-byte of the unicode char. Without seeing everything thats going on, its going to be a little work troubleshooting this with you. What I would recommend is looking through your types, keeping in mind what I said before and see if you can get all the types to be the same. One practical things you can try is to convert **vis_board** from type char to WCHAR. If the assignment is slicing the data, as I suspect, then this should preserve the data. If you do this, be sure to change the line you c+p'd to this: vis_board[y_pos][x_pos] = **WCHAR**(nearby_mines[y_pos][x_pos]); Give that a shot, let me know how it goes before I get too far into this drink. 
It seems like you have a better answer than mine above, but to answer your question, the compiler does not compile comments. [They are removed even before the preprocessor sees the code](http://stackoverflow.com/a/1510919/1084754) (for VC++ and g++ anyways).
http://stackoverflow.com/questions/860339/difference-between-private-public-and-protected-inheritance-in-c And http://stackoverflow.com/questions/860339/difference-between-private-public-and-protected-inheritance-in-c May help.
Why did you write the same link twice? And how does it help? There's no protected or private inheritance in `makubesu`'s question.
http://stackoverflow.com/questions/656224/when-should-i-use-c-private-inheritance I accidentally a link on my iPad. You need to realize the difference between what your trying to do and what inheritance model your using. Edit: and I fucked that up too. They really need to switch cancel and send in alien blue... Also I thought you were op. ops code uses public inheritance. By definition he can't see private and I always forget the rules for protected because I never use it. Edit 2: and he's instantiating an object of base inside his child after deriving from base. Wtf is this code even attempting to accomplish?
You can only access protected members of classes from inside the class itself, or from inside a deriving class directly. In this case, you're creating a new local Base object, base_class, and calling DoSomething() from it. Since DoSomething() is defined as protected in Base, you cannot access it. The only way to access DoSomething() from Derived is to call its own inherited version from Base, which is probably what you're trying to do. You would do that by calling DoSomething() or Base::DoSomething() directly from Derived::Test(). Edit: Nevermind, see tgockel's reply.
&gt; You would do that by calling DoSomething() or Base::DoSomething() directly from Derived::Test() `this-&gt;DoSomething()` might be a nice explicit way to do that. Or even `this-&gt;Base::DoSomething()`.
Yeah, it's a bit weird to instantiate a "Base" object within your Derived class...
This problem is more pronounced when we're dealing with data. I've added a new example to my post. I definitely understand that I can't do what I'm trying to do, but I'm trying to understand what software engineering principle is behind it.
Try converting your source files to utf-8.
I'm not convinced that reinterpret_cast is portably safe. In particular, I'm concerned about multiple inheritance (including pure interfaces).
 class Base { protected: double number; }; You should read [GotW #70](http://www.gotw.ca/gotw/070.htm). Is there any reason why you didn't write it like this? class Base { public: double GetNumber() const { return number; } private: double number; }; 
I agree with tgockel's explanation. For the workaround: If Base class is not used by anyone else, write an accessor function in Base as Fabien4 suggested. That will protect number from being accidentally modified but still provide read access. However, if Base class is used in some other places and you want Derived to have exclusive access to the "number" member then you need to create another version of the Base specifically for Derived. The reason is you want the Base to behave in two different ways - one has access to number and the other not. Derived uses the second version and everyone else uses the original version of the Base: class Base { protected: double number; }; class BaseSpy: public Base { public: double getNumber() const {return number;} //OK to access Base::number via inheritance }; class Derived : public Base { public: void Test(const BaseSpy&amp; base) { double value = base.getNumber(); //utilize number somehow } }; PS: Is this for unit testing?
Don't use reinterpret_cast for downcasting. Use static_cast which works and does what you'd expect unlike reinterpret_cast which might fuck up everything if you derive from many bases.
If it is for unit testing, just `#define protected public` and be on your merry way :-)
Because "double number" or "void DoSomething() {}" are actually private to Base and therefore inaccessible for every other class including derived classes, where Base doesn`t belong to. Here an example: You have two cars. A car and a mercedes derived from car. Sure the mercedes knows its protected components from his own car. But he can`t know the other cars components. Hence they are private to car, but not private to mercedes. 
&gt; Unicode represents each printed character as 2-bytes This is at best an oversimplification, but it is incorrect for all Unicode encodings except UCS-2, which has been obsolete since 1996 and is incapable of representing characters outside the Basic Multilingual Plane. Unicode is not itself an encoding and is not associated with any number of bytes per printed character. Unicode is a standard that maps characters to *code points* in the range 0 - 0x10FFFF. Different encodings can be used to represent sequences of code points; the most common are UTF-8 and UTF-16. Within an encoding, a *code unit* is the smallest sequence of bits used to represent a separable piece of the string in that encoding. In all encodings except UCS-2 and UTF-32, a single character might have to consist of multiple code points. For example, UTF-8 uses 8-bit code units, so an array of 8-bit chars is a natural vehicle for storing UTF-8 text. But there are far more than 256 Unicode characters: a single character in UTF-8 can be anywhere from 1 to 4 bytes long. A lot of people mistakenly assume that in UTF-16 every character is 2 bytes long, but that's not the case. Any character that does not fall within the Basic Multilingual Plane will be encoded as a surrogate pair in UTF-16, taking up two code units, or four bytes. (And this doesn't even get into how a single printed "character" can be made up of more than one Unicode code point!) 
This one? http://www.cplusplus.com/reference/
Whereas I'd say you're calling the constructor whenever you use `new`, placement or otherwise, and in several other cases such as the `(*this) = A();` from the OPs question. Even if the type doesn't have a constructor defined, there's still formally the standard one provided by the compiler. Obviously those calls for `new` (and for initializers in variable declarations and so on) are mostly indirect, but I'm not even sure what to call the `A()` in `(*this) = A();` other than creating a temporary by directly calling a constructor. Anyway, whether the constructor call is direct or indirect, the fact that it's doing something else as well doesn't change the fact that it's also calling the constructor. **EDIT** This has gone badly, so let me clarify. I believe rollie82 has a valid point, but the way it's expressed is potentially confusing. I'm probably being overly pedantic and expressing things at least as badly, but there's plenty of fallacies in programming that started as not-so-pedantic descriptions that were misunderstood. What I would say is that an object cannot call **it's own** constructor, except in the sense of calling base-class constructors or (as is often the case in C++) subverting the system. Using `this` and placement `new` is a way to subvert the system, with a possible risk of undefined behaviour (will the compiler notice if you've changed the vtable pointer, for example, and go on to call a virtual method). But an object can certainly call it's constructor on another object of the same class. **EDIT** - hmmm - "cannot call **it's own** constructor, except..." ... "can certainly call it's constructor" ... it seems I'm tying myself in knots, and not being any more precise despite being more wordy. I give up, and confess to being an idiot. 
Personally, that "If you really need to reset..." looks to me like someone has classified this as a smell then, realizing that there's a genuine use for it, ~~started suggesting smellier alternatives rather than admit that~~. The lifetime of an object is not necessarily (or even normally) the lifetime of the value of that object, because C++ is not a pure functional language. `reset` is just a method that changes the value of an object, the same as many other methods do. For me, the most common case for a `reset` is at the top of a loop. I could construct and destruct the object with each iteration, but I find the `reset` to be an effective visual reminder that the object returns to a default state each time through anyway, at least as clear as defining the variable within the loop. This can still be important for optimization reasons, too. For example, with std::vector, the cost of freeing the memory then reallocating may be significant in inner loops, whereas that's avoided by using defining the lifetime of the vector to include all iterations of the loop and using `reset` with each iteration. This shouldn't be a concern most of the time for premature-optimization-is-evil reasons, but I've dealt with enough cases that it's just my habitual idiom. And as I've already stated, there's no readability or maintainability cost (it's still perfectly clear) so why not just use the same idiom all the time? **EDIT** I just realised you probably mean assigning from a temporary rather than calling `reset`. Until relatively recently, that could have been a performance issue, though of course premature optimisation yada yada, and merge semantics now removes that issue anyway. I still prefer `reset` anyway, for the same reason I prefer a named method in general - it directly states the intent. No big deal when assigning from a default-constructed value - more a matter of personal preference and old habit - but I still don't believe `reset` is a smell.
It's funny, I sort of predicted this kind of reply to my post. I actually thought about putting a huge disclaimer up about it. If you're looking for a PhD in character encoding then, as you said, my explaination *is* an obvious oversimplification. However, for the purposes of the OPs question, I gave him enough information to understand what the problem is that he is encountering by mixing types. It's actually funny that you would post this without taking any of the other context of the reply into consideration. There was no misinformation to correct within the context of the post. We are very clearly talking about MS representation of unicode and WCHAR type. It makes you look like nothing more than an unhelpful pedant, no offense.
Agreed, though I didn't try that many before sticking with cmake. I rejected premake because I didn't like Lua, though it eventually turned out I may have been suffering from a misunderstanding and a minor Lua documentation issue rather than the Lua language. One thing about cmake is getting started. The book is probably a good idea, though I made do without it, partly by asking questions on StackOverflow. One big issue is that although cmake officially supports the conventions of the tools you're building for, to some level it has it's own conventions too. A key one is that the build is separate from the source (different folders). This is a good thing when you have multiple builds of the same source, of course, but I wasn't expecting it, and despite the general convention it's still possible to keep the source and build in the same folder, so at first I asked the wrong questions and put a fair amount of effort into doing the wrong thing.
Well, as a very newbie programmer, I understood nothing. So I just used a very armature workaround with a bunch of if statements, soo, works now!
Although if you don't ,mind, I'm having two more problems, one with the users input detecting flags, and the other with revealing all neighboring 0 squares when a 0 square is selected. If you don't mind looking at my code, [here it is](http://www.mediafire.com/?3f24t5iaj90b57e) (since its pretty long and in two files (a .cpp and a .h), thought it would be better to just include the whole project file). The user input is in the main.cpp file, and the zero square revealing function is in the minesweeper.h, in the display_near_zeros() function.
Make sure that lua51.lib (or whatever you're linking in during release builds) actually exists. Other than that,all I can reccomend is doing a full clean rebuild, of both lua and your project.
I'm not building using a .lib link or a dynamic link, the lua .c files are part of my project and build with it. EDIT: worth it to note I tried linking to the .lib and to the .dll and it didn't work.
Yeah that's my thought. It's nothing obvious unless I'm really dumb, which I don't think I am. I posted on stack overflow, even more elaborate post than this, and the first response was "You didn't specficy your compiler or how you're linking lua." etc etc .. Umm, yeah, I did. Thanks anyways, man.
That file you sent is the solution file for your project. It doesn't contain either the .cpp or the .h information. :(
If you want an example of a smaller project using gyp, take a look at [skia](http://code.google.com/p/skia/source/browse/#svn%2Ftrunk%2Fgyp). Trying to get a handle on how to use gyp by looking at how chromium uses it is like trying to drink from a fire hydrant.
Just curious, are there .obj files for Lua in your intermediate output directory? If you do "objdump -t ${some lua file} &gt; objsyms.txt &amp;&amp; notepad objsyms.txt" from a Visual Studio command prompt and search for Lua symbols, do you see any? How are the Lua symbol names formatted? What are your preprocessor defines?
I have enough headaches at work dealing with the output of "professional" programmers who don't understand Unicode. This isn't academic pedantry; it just bothers me when I see anyone propagating harmful misconceptions. And I think you need to check your sources if you think that even Microsoft is still crazy enough to call 2-bytes-per-character "Unicode" in this day and age. I'm sorry if you think I'm being pedantic, but I certainly wasn't trying to be unhelpful. If you pretend that two bytes means a character when working with UTF-16, you will be bitten eventually. No offense.
Add /VERBOSE to the linker command line options. You will then see a blow-by-blow description of everything the linker does. It's a lot of output, but I find it the quickest way to track down these situations as anything else involves quite a bit of guess - work.
See my above comment about diffing the last-found-working and first-found-not-working revisions to find the exact answer. There is no other way to figure it out otherwise.
Then you need to copy both the laptop &amp; desktop folders for Visual Studio, all the include library folders, and your development folders onto a drive where you can diff them to find out what is not the same. You also will want to check your environment settings, *and* whichever service packs and hotfixes you have deployed on both. What I do with my systems is that I use rsync to keep a copy of ALL of my desktop stuff imaged daily on a shared folder my laptop can get to, and if I start to have weird-ass shit happen, I can rsync those files over to my laptop. I know some other developers create a big-ass-huge source control tree of their development environment in order to track changes, which will also work. I only do this with the libraries - USB, opencv, sqlite, Qt, ssl stuff, etc. Another thought: the next time you set up a laptop, buy a copy of Acronis True Image with Plus Pack; this allows to you to image your working dev system over using Universal Restore, which otherwise you could not. This makes cloning desk &amp; lap systems trivial and has made my life so much easier. Finally, get an SSD for your laptop and bump the ram to max cap. It will help the build speeds.
manpages are a giant database that can be searched with apropos.
Great post, this specifically helps me out with my current roguelike project :-)
You're testing on Linux I presume, and you're getting that function through glibc which has had it since [2009-03-08](http://sourceware.org/git/?p=glibc.git;a=commit;h=610e67ed5af7e1acf2f96bb964cc2131af570a3d) and version 2.10. If you try gcc on a non-glibc platform (OS X, BSD, Windows, commercial UNIX, embedded system, etc.) it will not work. The gcc page is correct in saying that gcc does not support the feature, because it doesn't. In order to remain portable to several dozen platforms, gcc does not include a libc and its associated runtime support routines, since the details of how that's implemented vary greatly from platform to platform. And this is, I suspect, a case where implementing this feature requires doing it in libc, since the C runtime is responsible for process initialization and termination, and related things like `atexit()`. It's likely that it's not possible to implement this in gcc -- the feature will be available if implemented in a given platform's libc, but that's outside of gcc's control.
Just in case you have not heard of it before: [libc++](http://libcxx.llvm.org/). I'm using it with the latest Clang version, and I'm totally satisfied, so far.
Clang miss one important feature (though not from C++11) that make it a unusable for me: OpenMP support. I suppose I am not the only one in scientific/HP computing that relay on OMP for concurrency management. Though the fast pace of development of clang/libstc++ make me envy I could not use it
Anyone else wish that typename and function name choices were something more descriptive than A, B, C, N, Z, S?
Neither is intended to be an introduction to C++11 *as an update.* Both (I've read some of both) address C++ as a language. These books are very different in their approach. One is a tutorial (or "primer") and the other is a reference book. Josuttis talks a little bit about language (you need it to understand the library), but it is focused on the library. Get both books. Learn the new language from Moo and keep Josuttis next to you as you write code.
Just some advice: always assign new variables the value of zero so that they don't take garbage values (and you can spot a bug much easier without your variables being flooded by garbage values). Example: Int x = 0; int y = 0; Also, the answer you were looking for was to get user input. cin works well. cout &lt;&lt; "Enter the first number to be added: "; cin &gt;&gt; x; cout &lt;&lt; endl &lt;&lt; "Enter the second number to be added: "; cin &gt;&gt; y; cout &lt;&lt; endl &lt;&lt; The sum of those two numbers is: " &lt;&lt; addNumbers(x, y);
I'm extremely happy with my copy of "The C++ Standard Library: A Tutorial and Reference (2nd Edition)", I'm probably one of the few people whose copy is becoming worn from use already. If you're the kind of person who can read an article on cppreference.com and not have any trouble putting it into practice, then I think you'll benefit greatly from it. However as a general introduction to the language, you may want to grab another book, though I wouldn't know where to start recommending one. I came into C++ from C, so my learning approach probably wouldn't suit most people.
I have a background in C and C++, with an emphasis on C. It's been a while since I did anything in C++, and thought this C++11 update would be an excellent opportunity to familiarize myself with the language again. I have the following C++ texts on my shelves: * [Problem Solving, Abstraction, &amp; Design Using C++](http://www.amazon.com/Problem-Solving-Abstraction-Design-Edition/dp/0201612771/) by Friedman and Koffman (college text used about 7 or 8 years ago) * [Data Structures and other Objects Using C++](http://www.amazon.com/Data-Structures-Other-Objects-Using/dp/0201702975/) by Main and Savitch (college text used 7 years ago) * [The Complete C++ Primer](http://www.amazon.com/The-Complete-Primer-Keith-Weiskamp/dp/0127426884/) by Weiskamp and Flamig (picked it up second hand more recently, '06-'07, haven't read it) * [C++ Weekend Crash Course](http://www.amazon.com/Weekend-Crash-Course-Stephen-Davis/dp/0764546899/) by Davis (bought in 2000 before starting a CS degree — "I should probably learn how to program *before I start this Major in programming* — school taught Java instead, haven't read it; changed schools, incidentally) I'm thinking about buying a more updated C++ book to replace the aforementioned texts (donating them to my local library), hence the self.post. I never knew about [cppreference.com](http://cppreference.com/), it looks great and has a very clean layout. Thanks for that. I'm always on the look out for excellent freely available online learning resources, especially for programming languages: /r/Programming has an excellent [faq](http://www.reddit.com/r/programming/faq) in that regard. I wanted to ask for opinions on the quality of the C++ tutorial at cplusplus.com, especially as a companion to the cppreference.com site you provided, but it seems to be down at the moment. I find I'm torn regarding dead-tree media for CS texts: on the one hand, I enjoy sitting down with a good book; on the other, digital media lends itself so well to the world of programming-language textbooks: especially considering the potential for automatic update availability (like erratas). \* Awesome, cppreference.com even has an [Archive for Offline viewing](http://en.cppreference.com/w/Cppreference:Archives)!
Because I have code written with OpenMP :) More: I do like OpenMP because basically you write your code as sequential code. Then debug it (it is always easier to debug non-threaded code). Then just add some #pragma omp parallel where you want to parallelize the computation. Eventually you have to add some #pragma omp critical if you need to lock some data. That's it and you can turn on/off all parallelism with a compiler flag. I have written pthreads code it C/C++ and I am not afraid of it but in compute intensive code I prefer OpenMP for its simplicity. 
Well, you're certainly doing a lot of unnecessary work here: - There's no need to check if even numbers are prime. - You only have to check up to sqrt(n) for a prime factor. - Since you're finding primes in order, you should save a list of the ones found so far and use it as a source of test divisors -- using composite numbers as test divisors is a waste of time. For instance, if you want to test if 41 is prime, then you only need to check if it's divisible by 2, 3, or 5, and you can skip 2 because you should be ignoring even numbers altogether. There's no need to check 4, because if it's divisible by 4 then it's also divisible by 2, i.e. it's even, and similarly for 6. The next prime in the list, 7, is already greater than sqrt(41), so if you haven't found a divisor by the time you reach 7, it doesn't exist. And in general, you might want to switch to a sieve-type algorithm, such as the Sieve of Eratosthenes or the Sieve of Atkin. djb's [primegen](http://cr.yp.to/primegen.html) uses the latter. Just to give you a feel for what's possible, on my machine that code can find the first million primes in 0.005 seconds, or about 0.070 seconds if it has to actually print them out instead of just computing them. 
A lot of TMP is useless, but it's still fun to explore it! If nobody had bothered to explore the power of templates, utilities such as enable_if and the entire type_traits library probably would not exist. As for this article: yeah this kind of stuff isn't too useful, but it is a fun learning experience for the author :-)
Have you looked into the `std::async` and atomic primitives, and whether they could potentially fulfill the same needs in your case? I'm interested to know because while OpenMP is fine, I personally tend to prefer a more library-oriented approach. :)
&gt; The issue with this is the lack of control over the types we're producing. In this particular case, we want to prevent (at compile time) the creation of types corresponding to negative integers. I wonder why not: template &lt;int i&gt; struct Integer { static_assert(i&gt;=0,""); };
Well put. As another author had written this week, "when did learning become a bad thing?" 
Use &lt;=, otherwise it won't work for squares of primes.
Thanks for your responses, and for encouraging me to use my brain!
Do you know how I can install that on Ubuntu? I've used it previously on Arch (in fact, that was the only way I could use clang, libstdc++ didn't work with it), but now having switched to Ubuntu I can't find a straightforward way to do it.
&gt; for(int n2 = 2; n2 &lt; sqrt(n); n2++){ You are checking all even numbers beyond 2. Check 2 first, then start your loop at 3 and use n2 += 2. Also, you have the sqrt method call in your for loop. Think to yourself how the for loop works and answer this: will sqrt be called one time due to the declaration of the for loop, or will sqrt be called for every iteration of the loop?
I'm definitely not comfortable using a command-line compiler at this point. If at all possible, I'd like something GUI based (if at all possible) for now. 
www.codepad.org is nice for small things, but I'm not sure it's exactly what you're looking for. Maybe it will help.
This shaved another 10-25 seconds off. Thank you!
You know he's married to Barbara Moo, don't you?
Get the 5th edition of C++ Primer mentioned in the title (not the "C++ Primer Plus, 6th ed." by Prata).
Yeah, if you were interested in doing this in a practical fashion there are easier ways to. If you don't want an integer template parameter to be able to take negative values you should probably just use an unsigned type. Similarly with things like `ToInt` and so on, most of the problems would be solved better like template&lt;unsigned n&gt; struct Integer { static const unsigned to_int=n; }; Rather more efficient than recursive instantiations. (To transform a value into a type you don't even need that - just say `Integer&lt;n&gt;` and you're done.) As for folds on "linked lists" at compile time, that stuff is pretty amateurish as well. The author has invented a homogeneous tuple type. The heterogeneous tuples in the standard are implemented rather similarly, and it's [not hard](https://gist.github.com/2982696) (though not exactly straightforward) to write generic algorithms for those. I've written a `static_map`, a `static_foreach` and a `static_fold` for the heterogeneous `std::tuple`, if anyone's curious, but that stuff really isn't as interesting as TFA pretends. (If you're wondering, the fold was the most difficult - I tried to make it so that the intermediate types of the folded return value could vary between iterations. Fun fun.)
Oh fuck off.
&gt; might fuck up everything If you're writing code like that example, everything's already fucked up.
If you're not mutating the value inside of Base from Derived, why not add an accessor for it?
There's a [portable launcher](http://forums.codeblocks.org/index.php?topic=10360.75) for Code::Blocks. I'm not sure how well it will work with Dropbox, but it works pretty well on a USB drive. Just put the launcher in the same folder you have C::B in, and run it.
I wouldn't bother adding the const to the return value. The coding mistake it would help prevent isn't common, in my experience (worked in c and c++ for 20 years and never seen it, actually). It looks superfluous and wordy to qualify temporary return values with const. If the return value is a reference or an address, then worry about const. 
Inadvertent assignments in conditionals is really low on the list of things that I worry about. This seems like a horrible price to pay to reduce a really minor risk. 
What price is being paid, though? Just having to type `const`? It doesn't disallow you from doing anything that you would like to do, does it? I agree it's probably not necessary, I just don't see what the horrible price involved is.
Don't return by const value - that would inhibit move semantics.
I hope you don't return reference to function-local automatic objects in real code! Also, consider this item to be deprecated. In C++11 you can avoid the same mistake -- not that I consider this a mistake that's often made! -- by using a ref-qualifier for the assignment operator WITHOUT returning const objects. Returning const objects is a really bad idea because it will disable move semantics. You can expect a C++11-aware version of Meyers' book (if/when it comes out) not to include this item anymore.
I will disable move semantics for the returned rvalue. That's really bad.
&gt; a horrible price to pay to reduce a really minor risk. Horrible? I hate to guess how you react when the dentist finds a cavity! ;-) It isn't just assignments in conditionals, though... consider this code: extern Foo getFoo(); getFoo().setBar("bar"); I've seen this error before, though not in my code. Originally, getFoo() had returned a Foo&amp;, but then someone changed it to return a copy... However, the issue isn't the cost of writing "const", it's disabling the move semantics. So probably better not to do it. If you make sure that you only either return Foo* or const Foo&amp; or Foo, then you know that getFoo().setBar("bar"); is always wrong.
Thumb drives are absolutely not allowed where I work, but I'll give it a shot anyways. Thanks!
Definitely Qt Creator. It doesn't require you to install anything, (at least if you build it on your own) and it works with both MinGW and msvc.
are you referring to returning by reference from operator*? I don't think I returned by reference anywhere else. I am reading what move semantics are right now, thanks for the input. EDIT: Oh I see, in effective c++ he doesn't return by reference. He does have const though.
Kind of tangential to what the article is about, but i found that compile_in_place.cpp files for various boost libraries is really nifty. It simplifies build process quite a bit if you dont like to depend on external libraries.
This is (unsurprisingly) the best answer.
I'm kind of a cpp n00b and just reading this out of sheer curiosity. Can one of you explain this a bit more because I'm not understanding the issue or the answer. Thanks!
I was mistaken on what was written in the book. I updated my post to fix that. I am wondering though, is Item 3 "Use const whenever possible" of Effective C++ completely out of date? Is this book still worth reading, or is there a lot of things in there that are just not right anymore?
Ah yeah of course, thanks. That makes a lot more sense that "muddying the interface." :)
Won't this depend on optimization implementation and flags sent to the compiler though? Or is doing that part of a specification?
My first attempt at using templates to perform computations. Any suggestions or criticism?
&gt; Move semantics is more general and can be applied in a lot more scenarios That, and even though optimizations such as (N)RVO are almost the same thing, with move semantics you have a guarantee.
Right, it's not guaranteed to happen. However, if you're talking about performance and you're not compiling with optimization enabled, then whatever conclusions you come to are pretty much irrelevant anyway, because it's like talking about the performance of a car with a wheel missing.
What compiler / flags did you use. Here is the errors from clang++ -std=c++11 -stdlib=libc++ ~ [master] $ vim turing.cc /home/dirvine/turing.cc:49:20: error: expected a qualified name after 'typename' typedef typename cons&lt;Left::head, Right&gt; right; ^ /home/dirvine/turing.cc:88:10: error: explicit specialization of 'transition_table' in class scope struct transition_table&lt;0, A&gt; ^ /home/dirvine/turing.cc:96:10: error: explicit specialization of 'transition_table' in class scope struct transition_table&lt;0, B&gt; ^ /home/dirvine/turing.cc:104:10: error: explicit specialization of 'transition_table' in class scope struct transition_table&lt;1, A&gt; ^ /home/dirvine/turing.cc:112:10: error: explicit specialization of 'transition_table' in class scope struct transition_table&lt;1, B&gt; ^ /home/dirvine/turing.cc:63:28: error: no member named 'direction' in 'busy_beaver::transition_table&lt;0, busy_beaver::A&gt;' typedef step&lt;transition::direction, Left, cons&lt;transition::symbol, typename Right::tail&gt;&gt; step; ~~~~~~~~~~~~^ /home/dirvine/turing.cc:129:18: note: in instantiation of template class 'turing_machine&lt;busy_beaver, repeat&lt;0&gt;, repeat&lt;0&gt;, busy_beaver::A&gt;' requested here cout &lt;&lt; typeid(tm::next).name() &lt;&lt; endl; ^ /home/dirvine/turing.cc:130:22: error: expected a class or namespace cout &lt;&lt; typeid(tm::next::next).name() &lt;&lt; endl; ~~~~^ /home/dirvine/turing.cc:131:22: error: expected a class or namespace cout &lt;&lt; typeid(tm::next::next::next).name() &lt;&lt; endl; ~~~~^ /home/dirvine/turing.cc:132:22: error: expected a class or namespace cout &lt;&lt; typeid(tm::next::next::next::next).name() &lt;&lt; endl; ~~~~^ /home/dirvine/turing.cc:133:22: error: expected a class or namespace cout &lt;&lt; typeid(tm::next::next::next::next::next).name() &lt;&lt; endl; ~~~~^ /home/dirvine/turing.cc:134:22: error: expected a class or namespace cout &lt;&lt; typeid(tm::next::next::next::next::next::next).name() &lt;&lt; endl; ~~~~^ 11 errors generated. 
I would take advice from Effective C++ with a grain of salt. One thing the author advocates is putting all your private stuff first, for some reason. I actually did that for a while before I realized it was ridiculous and stupid. I suspect he likes to do things a little differently because otherwise he wouldn't have any content in his book. edit: wups, the book I have is *efficient* c++.
thumb drives not allowed, but dropbox is? sounds like a hole in the security policy to me. be wary of exploiting it.
C++11 is already out. It would have to be for the next C++ update (C++21?)...either that or it's a way to get more people to come to his talk?
Hopefully it wont be those crappy facebook libraries recently revealed.
So a special announcement for only 120 people that is massive and groundbreaking... Somehow I see this as less than important.
Maybe so, but wouldn't it have to go through the standardization process (and wouldn't that take several years just as it did for C++11 itself)?
Makes you wonder what they think about at night. 
Well .. the article didnt say much more than cmake --help-module-list | egrep -i boost does
At the Next conference, he and others made the case that at this point, having the library was more important than the library being perfect (it's really serving a totally different role from STL). IIRC, reference was made to the wealth of libraries that were already out there (I think POCO was cited specifically, and possibly Qt as well), and that it was just a matter of integration and maybe polishing some rough edges.
I have not come across that part of the book, but it looks like he frequently puts his private data on the bottom in Effective C++. Are you sure you are referring to the same book? I was under the impression that Effective C++ was considered a must read, at least up to a few years ago.
&gt; It would have to be for the next C++ update (C++21?). It is supposed to be C++17, but who knows.
This certainly looks like spam. 
I was working on the impression that there would be a "minor" standard around C++15 to tweak a few of the bug bares of C++11. Things like missing "make_unique" etc... Either way I hope there isn't going to be any large new additions until at least 2017.
The primitives cater to a very different use case than OpenMP, they simply allow for concurrency (doing two things at once). Where as OpenMP is really aimed at doing the same thing two different chunks of data. The closest thing to OpenMP that doesn't require extra compiler support is Intel's TBB library. However there is a noticeable overhead for TBB over OpenMP. Numerical computing is very different to application computing, the 3% overhead you get from "modern C++ style" is not acceptable. 
`std::async` doesn't meet the use case for OpenMP at all. The closest "pure C++" solution is Intel's TBB but that has a large overhead (in respects to numerical computing).
I had on my mind 2017, but you might be right. It is true that the plan is to speedup standardization anyway.
Yeah no problem. C++11 adds two new concurrency primitives that meets two different use cases. The first is a basic thread construct, that is `std::thread`, which simply spawns a thread and execute the work in the form of a callable (`operator()`) you give it. `std::thread` is suitable for building more complex concurrent constructs (such as perhaps a `parallel_for_each`) or doing simple concurrency, ie "I need UI thread and I need a background thread". It is not however an out-of-the-box paralleliser. I can not say here is a loop, carve up the iterations and schedule them effectively across the cores. The second C++11 primitive is `std::async` this primitive allows for a level of abstraction from `std::thread` you are simply say, here is some work, it going to take a while so you take care of it and when I call `.get()` on the produced `std::future` then I expect it to return the value. Again this really is not suitable for parallel processing of the same operations across a large range of data. (this is more so true, when you consider that the standard leaves how the parallelism is scheduled up to the implementation) So OpenMP on the other hand, whilst having a horribly inelegant API, is very effective at taking a serial loop and parallelising it. So you might have: #pragma omp parallel for for(size_t i=0; i&lt;n; ++i) a[i]=z[i]+x[n-i]; This is done ALOT in numerical programming. It is also worth noting that if the compiler doesn't support OpenMP then it will skip the pragma and produce a serial version which produces the same result. (ie the loop is still valid). To do the same with the C++11 primitives you would have to (non standardly) query the OS for how many cores the system has, then create a thread pool giving each thread a copy of the work to do (probably using a lambda) then manually carve up the values of `i` so that each core has it's own non conflicting range. the closest you get to OpenMP without requiring separate tools is Intel's TBB, where you can have something like //This is even worse without C++11!!! tbb::parallel_for(tbb::blocked_range&lt;std::size_t&gt;(0,n) [&amp;, =n](const tbb::block_range&lt;std::size_t&gt;&amp; range) { for(std::size_t i=range.begin(); i!=range.end(); ++i) { a[i]=z[i]+x[n-i]; } }); which as you can see is a lot more complex and is slower (due to TBB's overhead and indirection), this is fine and perferable to OpenMP if you only have 1 or 2 parallelised loops, however when you have something like a Linear Algebra routine which reliant on parallelism then it is far to messy.
Basically parallelism isn't free there is a spawn and scheduling overhead, and the time involved in doing this for TBB is much higher than that of OpenMP. I don't know what the numbers are for OpenMP, but for TBB the point where it becomes worth parallelising with TBB is 500micro seconds which is actually quite a lot. For my thesis I had semantically identical code with TBB and OpenMP, they both had the same performance profile however OpenMP consistently noticeabley faster, had a value threshold (when it becomes worth using over the sequential code) and typically require less code to get working. That all said I don't recommend OpenMP for many use cases TBB for example interacts much better with containers and like and doesn't require a specialised compiler.
Well, I don't have Ubuntu here, but I suppose you should be able to compile it from source. I sent you a PM with details inside.
I'm glad I don't have to maintain their code. Ugh.
And a comment about intentional fall-through, please! 
We use something like this at the game company where I work, albeit a bit more complicated. A large amount of our disk and network serialization code, as well as UI code, works because of this kind of stuff. The serialization case is pretty obvious, and the UI stuff basically enables us to write a http://msdn.microsoft.com/en-us/library/system.windows.forms.propertygrid.aspx - like control in our editors, in C++. I don't think i could imagine living without this kind of thing.
I have read the wikipedia article on reflection, and I don't think I understand exactly what this is talking about or what I would want this - in any language.
Yea, I don't understand this either. Wish I did.
The biggest use of reflection is for serialization. The routines to read from/write to a database/json/xml are completely separate from the class definition. If you need to add a field, you just add it to the class, and you don't touch the serialization routine. The other use of reflection is for data-driven development. A lot of times people use external formats such as json or xml, but with reflection you can use C++ classes, which has the extra benefit of providing checks and type safety at compile time.
Actually, this problem doesn't need reflection. It can already be solved by using a templated function that casts the `void*` pointer back to the right type, and invokes the function.
Very useful to know.
Blog posts on reflection in C++ by Don Williamson, game developer who has worked on the Splinter Cell : Conviction among other games. http://www.altdevblogaday.com/2011/09/25/reflection-in-c-part-1-introduction/ http://www.altdevblogaday.com/2012/01/03/reflection-in-c-part-2-the-simple-implementation-of-splinter-cell/
TIL that Nokia still works on Qt. I thought they gave the baby to another company a while ago.
A total fuckwit wrote that headline. 
Fuck you Nokia. Your death is well deserved.
i am doing a UI with QML for desktop, its actually really nice so far, and version 5 will be even better.
Qt is open governed like other open source projects, nokia gave it away to "the community" some year ago.
This appears to be only the Australia office; I don't know how this will impact the rest of the Qt team(s). If this is the same pattern that game publisher follow, then we can expect a release of Qt5 shortly (other than the alpha/beta/git it yourself).
I'm getting a 404 from that link.
If you want to be really clever then you can print out the probability that the number is a prime once it becomes computationally unfeasible.
I'm also in the same boat as you but I rather plan to move from WinForms to Qt5 since MS can't really decide what technology you should use these days (MFC,WinForms,WPF,Silverlight and now html for Win8). I would guess it does hamper the progress of Qt a bit but as they have shown more and more people are contributing to Qt that are outside of Nokia. It's also used in some [large project](http://en.wikipedia.org/wiki/Category:Software_that_uses_Qt) that I have a hard time seeing that they switch to something else.
Also Qt is an open project now that anyone can develop, Jolla is going to have a Qt based interface and they just got a big Chinese contract so it is in thier interests that QML is still developed and the KDE project has been useing QML and some devs from their could help develop Qt as well. Digia is selling comercial Qt and it is in their interest that Qt is developed as well. 
It is indeed very tricky to deal with system resources that aren't automatically handled by the OS. This is another one of those places where UNIX shines: Almost every imaginable resource, including pipes for IPC, is a file descriptor, and file descriptors are always automatically closed when a process terminates. With this in mind, all resource servers can react to unexpected termination of a client at the other end of a pipe and free the occupied resources accordingly.
GTK+ and wxWidgets were always community-backed projects. Qt is moving to that except it's still backed by several companies. I don't see how can its future possibly be in danger (any more than for every other framework).
Will you report back with your impressions once you've gotten through it?
There are several companies that are all using Qt: Jolla, RIM, Google. Not to mention the full KDE community. QML has made a very compelling develpment framework allowing for designers to make the prototypes and seperating the Logic from the UI allowing for better and faster UI's and all the benefits of C++ speed wise with the ease of coding with a scripting language. The ability to easily tie C++ code to the QML leads to fast exicution if there is anything that is computationally intensive. Now whether the full libs of Qt will be needed like Qt3D or QtMultimedia(expecially since phonon has matured) and with KDE restructuring their frameworks to be more modular and only relly on Qt and not interdependent on other KDElibs makes KDE's libs more compelling. All ready there is a wide range of vested interests with Qt and whether more of the extras get absorbed into KDE is another thing. Qt 5 is showing to be even quicker and has great wayland support, the lighthouse project has made it easier to port Qt to even more platforms even Android. 
That is all great, but it doesn't mean any of those companies actually want to buy QT. QT is great so long as someone else is picking up the bill.
If Nokia drops the ball it falls under the BSD license. Also right now there is a public git repo that anyone can contribute to so even now 3rd parties can help pick up the slack. 
I don't think this is at all useful, if you are creating any sort of serious application, exit by uncaught exception is not at all acceptable. All you have to do, is whack try{ } catch(const std::exception&amp; e){ std::cerr &lt;&lt; e.what() &lt;&lt; '\n'; } around main, and so long as you used RAII properly resource management should be handled.
Correction: [looks like Nokia is selling off Qt](http://www.phoronix.com/scan.php?page=news_item&amp;px=MTE1MTc).
Nobody going to mention that calling delete on an ~~class~~ polymorphic object without a virtual destructor is undefined? :p
The initial plan was to move to WPF. However then Microsoft came out and said that that html5 and javascript is the way forward for Win8. They also couldn't say what they saw the future for WinForms or WPF was. So my choice was to recreate the gui in a technology with a very uncertain future while learning something that I can only use with that technology (XAML) and that is closed source or go with Qt5 that is open, multiplatform, uses a technology I know and can have use for in other project (javascript in QML). Do note that my project is a bit special since its a visualizer created in C++ but currently uses a managed gui.
Metro is WPF, HTML5 and JavaScript are just another option among many. So choice is good in Open Source, but in closed source world it is bad? If you plan to go cross platform, then yeah, Qt is the best available. 
Use whatever you want that works for you. In my experience with working on games, exceptions are never the best option and I would recommend people don't use them. I'm not looking to get into a fundamental debate on a language feature. By not using exceptions, you can avoid the RAII problem that OP talked about.
" and it's not like there's many options anyways." Well actually there are options. One in particular is this [wxWidgets] (http://www.wxwidgets.org/). The code is not pretty but produces native looking apps on supported platforms. Has liberal license ( free for open source and commercial, including static linking in commercial apps), and very actively developed. Apparently even Google uses it (https://drive.google.com/start?authuser=0#home)
Perhaps this is a more significant development if it turns out to be true.
I am aware of wxWidgets but it is by no means fully comparable to Qt (which is far more than just a GUI), especially in API design. It would probably be easier to use Java at that point.
It's showing its age, like he said. Qt needs to be stripped down to strictly the gui stuff (no QMap or networking/xml crap), MOC needs to be ripped out, and it needs to be a boost project. Also, the whole thing should be easily statically linkable. If the stuff to draw cross-platform widgets is not isolated out from the other junk and put in a boost-style highly generic framework, I don't see where it goes from here. Might as well use gtkmm or Wx (both of which also need to strip down).
I don't entirely disagree, but the C++11 committee presumably felt it important to maintain as much API compatibility with std::map as possible. What would be the alternative? If you were to overwrite the first insertion you'd have basically the same bug depending on your use-case. I suppose they could have added a second boolean parameter to indicate whether overwriting was allowed, but that would make operator[] redundant. There's always the issue of language as well. "insert" implies a non-destructive operation.
Can I also link to Boost libraries without a Boost specific CMake module?
1: the meme unnecessarily obscured your point, which could have stood entirely in the title. 2: this is a highly sophomoric complaint. Lastly, sage.
What if it falls back into GPL? 
No library can "do everything". Qt needs to strip down and do one thing well: cross-platform UI.
&gt; Almost every imaginable resource, including pipes for IPC, is a file descriptor, and file descriptors are always automatically closed when a process terminates. Um, SYSV IPC (shared memory, semaphores, queues) as well as POSIX IPC objects have kernel persistence. (Some of POSIX ones can be created with process persistence, but POSIX IPC is in general less capable than SYSV IPC)
Kicking a dying man in the head. Classy. 
use [premake4](http://industriousone.com/premake), it's the easiest system to use and it actually generates makefiles. So you can check out the generated files and learn from them if you want to level up your makefile knowledge.
Interesting to a degree but this article OS either poorly written or this library is a major failure on boost part. It just seems excessively noisy and doesn't offer much over other methods. 
I looked at your project `cli`. It is a clean interface, but require an additional compilation step makes it entirely unattractive to use. :(
I entirely agree with this, it has been shown to be possible by the WTL (which unfortunately isn't cross platform) QT needs to shed weight fast.
But who the hell would want to voluntarily contribute a project that uses an antiquated style of programming, is so big your contribution will make no difference in "steering the ship". Maybe other companies will do some of the work, but that will only whilst they are looking of alternatives, or waiting for QT to drastically change direction.
When you have more than a handful of options to document and maintain, an additional compilation step won't seem like such a bad idea. And also, what's wrong with an additional compilation step? All modern build systems/IDEs have support for this (autotools, CMAKE, VC++, etc). But even if you don't want to bother, you can always write a shell script/batch file that you run manually after adding a new option. If you expect your users to build your project from source, then simply package the generated code with the distribution and they will never know you used a clever tool to handle the command line.
It's just not a very "C++" thing to do. If Boost can make a parser generator without an additional step, I don't see why I should need one for something as trivial as this. I have no problem with a step that generate doc' from valid code, just not this way round. Perchance are you related to the ODB project, that is a another project I won't use for similar reasons. The fact of the matter is, if I am presented with a PURE C++ and "C++ + more" option, I am always going to select the pure option.
A good chunk of that is the article authors coding style, it is overly verbose, for example having difference exit vals in an anon' namespace just isn't necessary for a blog post example and damn 1 curly brace per line :S The meat an potatoes of the boost.program options is: namespace po = boost::program_options; po::options_description desc("Options"); desc.add_options() ("help", "Print help messages") ("add", "additional options") ("like", "this"); po::variables_map vm; po::store( po::parse_command_line(argc, argv, desc), vm ); //then on in use vm...
Then there would be two Qt projects the comercial and the freesoftware fork.
That is very rarely the case, repetition can almost always be removed with Templates and as a last resort Pre-Proc macros. Generalised attributes are a way of making non standard "more standard". If you rely on external tools it is still not pure C++. Which as all sorts of implications on portability and longevity and licensing...
Worse, not being exception-safe in this day and age is a show-stopper to me.
I didn't say it wasn't, I said that writing C++ in a Java style is worse than writing it in the Modern C++ style, which is a style I wish it was written in. when I come around to revamping my only GUI project I will consider both the JS front end to QT, GKTmm but hopefully something better will have come along by then (something like WTL but cross platform).`
Looks like it still doesn't support renaming the [generic ARG text in the --help output](https://svn.boost.org/trac/boost/ticket/3330) into something more useful. 
I didn't downvote you, but I'm pretty sure those who did were because of your unnecessarily sarcastic tone. It's not like the standards committee sits down and goes "how can we implement this to screw people up?" there are legitimate reasons for most everything C++/STL does, they're just not always trivial. You wanted to explain this gotcha to others, great thanks, but the &gt; "our lovely wrack of a language" and &gt; "this is C++, so life here isn't so easy and intuitive" is unnecessary.
&gt; I imagine the reason you're getting downvoted is because you're using the library in an obviously impropper way and blaming it on the library rather than the use of impropper code. I'm a firm believer in the principle of least surprise - if there are more-or-less two (or more) possible ways of doing things then one should select one that **can't** surprise the user and lead to bugs. In this case those two possible ways are: 1) Make insert always replace the current value and return nothing. 2) Make insert not replace the current value and return bool whenever the operation succeeded. Now which one has a bigger probability to surprise the user and lead to bugs? The 1) variant that *always* does the same thing and doesn't need need any documentation to understand, or the 2) variant that requires you to read the documentation to properly use? And I don't remember ever seeing a piece of code that actually checks the return value of insert(), so basically everyone that didn't read its reference page are a potential source of bugs. Also, I've just typed `std map tutorial` in Google and checked the first page results; for those sites that actually include the insert() method in their tutorials **none** of them (except the cppreference page) mention that insert() doesn't replace values. These are potential landmines waiting to be stepped on. I understand that I'm not entirely faultless for not reading the documentation, however, I think that a broken library design is broken.
Actually, C++ is doing something really subtle, trading of a little ease of use for better performance. Suppose you want to say "insert only if the key doesn't exist" -- in most other languages, you have to make *2* probes into the dictionary, wasting cycles. In C++, insert does this in one. "But Aaron, aha I've got you! In those other languages, I can replace in one probe. Surely C++ can't do that too?" Actually, you can, that's why insert returns you the iterator, giving you access to modify that element you just found via a call to insert(). Or, if the value is default constructable, use the \[ \] operator. So yeah, subtle, but flexible. 
The problem is that it makes the common use case potentially dangerous to make a rare use case... err... I don't know, marginally faster? The speed gain is so minuscule that is close to irrelevant.
I found [hello-gyp]( https://github.com/springmeyer/hello-gyp) while looking for other introductory resources.
&gt; I'm a firm believer in the principle of least surprise Me too. I do not find it surprising that you cannot insert two items into one space. &gt; Now which one has a bigger probability to surprise the user and lead to bugs? The 1) variant that always does the same thing and doesn't need need any documentation to understand, or the 2) variant that requires you to read the documentation to properly use? Having to read documentation before using a library is a standard practice. I do not know a single library in a single language in which i wrote working code without reading *some* sort of credible text. &gt; And I don't remember ever seeing a piece of code that actually checks the return value of insert(), so basically everyone that didn't read its reference page are a potential source of bugs. Calling insert the first time does not require checking whether it was inserted--you know it was. It's the second time that's troublesome, which is the purpose of the map[...] operator. // Instead of map.insert( ... ); map[...] = ... The problem with people not reading the documentation is that associative containers do not work the same way as the rest of the STL containers and anyone who comes down this road soon finds "there be dragons". Even if the designers had chose the 1) variant, it would still violate the principle of least surprise by opperating unlike containers with similar interfaces. Instead, they chose one function for inserting values (definition), and another for general access which allows for assignment. I do not find this surprising. &gt; I understand that I'm not entirely faultless for not reading the documentation, however, I think that a broken library design is broken. It works, but there's a logic to it that can only be obtained by familiarization, just as with everything else. You're right that a lot of tutorials don't mention everything, but a tutorial isn't a teaching device, but a learning one. You can't do a tutorial on calculus but you can work through one that solves a simple differential equasion and use that experience to learn more and understand other sources. I dislike that tutorials have become the main source of learning for many people, however. Whenever i pick up a library or language, i start with a tutorial and move onto the documentation.
No, that's what QtGui needs to do. :P It's hardly impossible to produce highly featureful software, that's what the Linux kernel is after all.
I am curious as to why C++11 still does not have a static_if. It is such an important feature, and yet it is missing.
The answer is yes but with varying degrees of inconvenience. You could always specify all the paths yourself. I believe the Boost module is included in CMake by default however.
I dont understand why static_if is such a big issue. You can already solve most the problems with enable_if quite nicely. No doubt, it can sometimes be cleaner with static_if, but is no way a defect. The biggest issue that needs to be fixed with C++11 is lambdas and type deduction. They can't be used inside a templated function(see [here](https://github.com/pfultz2/Linq/wiki/Linq-inside-polymorphic-function) for a more detailed explanation). The easiest solution is to just remove the need for a trailing return type when there is only one return statement(just like it is for lambdas) So you can just write this: template&lt;class T, class U&gt; auto sum(T x, U y) { return x+y; } Ultimately, it would be nice to have polymorphic lambdas, but there is more issues that need to be resolved with that and it treads on uncharted territory(such as local templates). Removing the need for trailing return types is simpler and easier for compilers to implement.(It already implements it for lambdas). This defect with lambdas is very important. It prevents so many powerful constructs in C++. Not having, static_if doesn't prevent that many powerful constructs, it just makes it look cleaner sometimes than enable_if(and later when c++ supports polymorphic lambdas, then a library solution for static_if would be possible). So while static_if is a nice to have, I believe improving type deduction for lambdas and polymorphic lambdas are a must to have.
I suppose you implied that `declspec` cannot be used for return type?
I've used boost::asio for networking stuff, but it is not usable in gui applications, because network and gui notifications don't mix. You can't wait for user and network input in the same main loop. Try for example write gui chat application (i. e. IRC client) using asio and not using threads.
It's like they're taking the piss even more not using name spaces. QQuick? Why on earth they don't just have Qt::quick:: or even QQuick:: is beyond me. Also there choice not to expose the new element as a C++ API is rather disappointing, more so given the fact they are written in C++.
I think it is coming... The "problem" is that templates are a language in their own right, they just somewhat functional language, this however requires change of mind set rather than a change of tools. But regardless of that, I think static_if will come around soon or later.
I would ask why the standard didn't add more safety to the move semantics. Now we have situations where we could do this without any complaint from the compiler : std::unique_ptr&lt;Whatever&gt; p1 = new Whatever(); std::unique_ptr&lt;Whatever&gt; p2 = std::move(p1); p1-&gt;WhateverMethod(); It would be so great if we could say to the compiler that once an object of a given class has been moved, it becomes an illegal state, and it makes no sense to use it, or at least if you dont use first any construction sentence to fix that illegal state. Of course this is not applying to every moved object, i.e. a moved std::string, doesn't become any illegal state after being mvoed, just it becomes an empty std::string, which is perfectly legal. Thus, the decision of wether an object takes an illegal state or not after a move, would rely to the class designer, if he would have a way to say it. I think this could cause many bugs when the people begin to use the move operator for optimizing everything, producing such buggy code as this one: std::unique_ptr&lt;Whatever&gt; p1 = new Whatever(); this-&gt;invokeTwoPointers(std::move(p1),std::move(p1));
&gt;Example 1: Correct me if I'm wrong, but while it can be done with enable_if, it would be muhc more less straightforward. &gt; &gt;Example 2: Just imagine the clarity of the error message if the condition is violated. I agree it can be nicer, but this is why its a nice to have. Type deduction for lambdas and polymorphic lambdas are a must have. I considered it even a defect in the language. They give us a feature yet we really can't fully use it. 
&gt;This actually is quite interesting but because of the functionality the library provides but as a precedent. A precedent set two years ago.
&gt; Of course this is not applying to every moved object, i.e. a moved std::string, doesn't become any illegal state after being mvoed, just it becomes an empty std::string, which is perfectly legal. Actually, that's backwards. The general rule is N3376 17.6.5.15 [lib.types.movedfrom]/1: "Unless otherwise specified, such moved-from objects shall be placed in a valid but unspecified state." unique_ptr is one of the very few STL objects that provides a stronger guarantee that moved-from objects are empty. 20.7.1 [unique.ptr]/4: "Additionally, u can, upon request, transfer ownership to another unique pointer u2. Upon completion of such a transfer, the following postconditions hold: — u2.p is equal to the pre-transfer u.p, — u.p is equal to nullptr" and 20.7.1.2.1 [unique.ptr.single.ctor]/16: "unique_ptr(unique_ptr&amp;&amp; u) noexcept; Effects: Constructs a unique_ptr by transferring ownership from u to *this." basic_string does *NOT* strengthen the default guarantee, and goes out of its way to say 21.4.2 [string.cons]/2: "basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str); basic_string(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; str) noexcept; Effects: Constructs an object of class basic_string as indicated in Table 64. In the second form, str is left in a valid state with an unspecified value." You might object, "But surely, basic_string has to physically copy a pointer and empty out the source, so we can rely on such a guarantee in practice, right?" The answer is no. Consider a Small String Optimization implementation (like VC's). When the SSO is active, the destination has to (effectively) memcpy the source buffer, set the destination pointer to point-to-self, and copy the size. It doesn't have to do anything to the source, and indeed might leave it unchanged because emptying it out would require further instructions. Or perhaps it will set the source to "MEOW". I am tempted to do that now, because I don't want users assuming things that the Standard doesn't guarantee. :-&gt;
it hasn't been updated for a while because developers left Adobe for some reason. but it still has many good things in it, even after a couple of years.
Left? All signs point to them still working for adobe. 
The author of the post asked for disadvantages not a totally unbiased review of spirit. And the author of the accepted reply (the only real reply with detail) said that he only has experience with Spirit Classic, rather than Boost.Spirit V2. Further more the author misses out the main problem with Spirit, the learning curve. Anyway that said, I use Spirit in a number of my project and am very happy with it for a number of reason. * Boost is almost always a dependency * No reliance on external tool (yacc, bison, ANTLR...), non of which are really designed to work with C++, this is a pretty big deal for open source projects * Size with basic optimisations on, Boost spirit actually creates very compact binaries. * C++ templates are inlined by default, and this is the source of the Spirit speed, it is very fast. * Support, I have had Very good experience getting support from boost, mainly through their IRC channel. * For small grammars like config files, the grammar can live in line (as in the source and the binary) in the code, this is pretty useful for those doing code reviews, they don't need to open up a separate grammar file or anything like that. * There isn't anything better * recompile times can be mimized using by wanging your parser in it's own translation unit (which it almost always is anyway) and making sure you have a two stage `make clean` process, ie `make clean` and `make cleansome`. * Has a Parser, lexer and generate (karma) My disagreement with you is not that I believe Boost.Spirit is perfect, but that you believe that it isn't useful, I have found the opposite. EDIT: This is hardly scienctific but on the first page of google I only found comments regarding Boost Spirit being faster than alternatives: http://alexott.blogspot.co.uk/2010/01/boostspirit2-vs-atoi.html http://www.boost.org/doc/libs/1_50_0/libs/spirit/doc/html/spirit/karma/performance_measurements/numeric_performance/double_performance.html http://www.boost.org/doc/libs/1_50_0/libs/spirit/doc/html/spirit/karma/performance_measurements/numeric_performance/format_performance.html
I hardly would call it a "wrack of a language" --and it does NOT get silently dropped! Maps don't allow duplicates and the definition of insert() in all documentation I have ever seen clearly explains the RETURNED VALUE which implies that an entry is NOT created when insert() is called with a duplicate key. As other posted, if you want duplicate keys then use multimap --as that is what it is for. Notice that the return value of insert() for a multimap no longer has or needs a boolean --it is just an iterator. With utmost respect, please read the documentation for the functions you call and handle all returned values. Far too often, I see people write code and then claim they are good, little errors can be (ahem!) safely ignored, etc. and fail to adequately/properly handle return values, exceptions, and errors. Writing code that handles all return values/errors/exceptions is what makes a program robust and its programmers, in the end, excellent. P.S. On this note, a pet peeve of mine is the far too common usage of scanf() in C courses WITHOUT ALWAYS checking the returned value of scanf() and writing code in accordance with those returned values. (Clearly, I exclude the first week of a programming in C course for non-programmers is excluded. Once the if statement is covered however there is absolutely no excuse.) Usually the response when I bring this up is, "scanf() returns a value??" Sigh.
Useful to know that one should ALWAYS catch any and all exceptions in any serious program (in any language supporting exceptions). If not, all of those languages just shut down too (if they care about meaningful program state) --at least C++ calls terminate() first allowing the programming to do/note something before the program dies!
&gt; When enable_if code doesn't work, either because of library error or user error, the results can be completely incomprehensible, because overloads just go missing. Most of the compilers will show each of the overloads that fail, so you just look at the `enable_if` clauses to see how you are giving it the wrong type. Furthermore if you use `enable_if` with `static_assert` you can provide an even nicer error messages to the user. 
What happens if you have a segfault, sigabrt, get OOM killed or any other number of other things that aren't covered by exceptions? 
Whenever I've seen "STL" as a reddit user name I've wondered, "Is that Stephan?" This post settled the question. "Meow." 
boost asio has both synchronous and asynchronous operations. Like: async_write(your data, your callback when finished); Best of all your callback can be anything. You dont need to define a slot. Pass a function, or a function object, for example boost::bind to all the callback with specific arguments.
And again, a good example for the fact that c++ is simply not the kind of programming language which cares for "pretty" code... 
Don't do that. If you're going to take the hit of a read from memory (even cache) then it is better just to always assign. In any case there are better things to think about than micro-optimisations (that aren't) at this level.
It's true that some of the C++11 features are kind of overwhelming when you first see them. I'm waiting for the raft of new books in the "C++ In-Depth Series" as well as new books from Scott Meyers. There is a strong argument that we could generally do with a syntax overhaul and produce a new language with C++ semantics but improved and more up to date syntax. Meta-programming needs explicit support. Constexpr is good, but needs to go much further - see the D Programming Language.
I disagree. I think variadic templates will be hugely successful once people are used to them. I do like writing software library functions, so maybe I'm a little biased, but why wouldn't you use them? C# has params and dynamic already and that's a mainstream language: public static String Sprintf(String format, params dynamic[] args) { List&lt;ArgPair&gt; strArgs = new List&lt;ArgPair&gt;(); foreach (dynamic arg in args) { strArgs.Add(Format(arg)); } return Helper(format, strArgs); } 
I wouldn't want to give up my C libraries and functions that I can use seamlessly (more or less) with C++. A new language threatens this . C++11 is going in the right direction, from an engineering point of view.
D seems to work well with C libraries, although it's not the most painless interop (default GC means mindset shifts when dealing with non-GC'ed libraries).
D seems to be exactly that, I'd love to see more support for it.
http://www.mail-archive.com/adobe-source-devel@lists.sourceforge.net/msg00265.html
I thought this was the point of [inheriting constructors](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2540.htm). Granted, no compiler has them implemented yet.
He went back to Adobe, I don't know how much he contributes to ASL... but he's there. "In 2009 Sean spent a year at Google working on Chrome OS before returning to Adobe." http://cppnow.org/about-sean-parent/ 
Like the article says, catch(...) { std::cerr &lt;&lt; "Unexpected exception caught.\n"; } If you put this after the std::exception handler, it will only be executed when the exception isn't std::exception or a subclass.
Nope, it works even if the type has no constructor at all. I believe that was the primary purpose for std::declval.
Nothing will save you from a kill -9 or the moral equivalent. Similarly, nothing will save you when your program's executable sections are corrupted by cosmic rays. There are some conditions and bugs that are impossible to properly handle.
There is more to variadic templates than params, but OK, maybe that's not the best example. BTW, I don't think there is any point to using `dynamic` there, `object` would work fine and be faster, too.
Type safe printf is the example given in the variadic template proposal, but I'm sure there are other uses! ;-) The reason for dynamic is so that Format() can overload by type (i.e. imagine a slightly different version for C++ using variadic templates - I tried it with gcc and it worked fine).
There are a few typos in the code samples, like: &gt; MemoryPage&amp; MemoryPage(const MemoryPage&amp;); This was suposed to be operator= Also, more idiomatic way to implement move-ctor/op= would probalby be to just swap internals of the objects (at least in this case, but probably also in general). &gt;if (this!=&amp;other) Im not sure this is sensible, but then again i didnt spend much time thinking about rvalue refs yet. &gt;Danny Kalev is a certified system analyst By whom, may i ask?
Don't forget that C++11 is relatively recent, and people are still experimenting with various features and constructs. After a while, some of them will start to seem familiar, and some of them will more or less disappear, for lack of real use.
If you don't have the this!=&amp;other condition, you copy all of the members of other to another reference to the same object (harmless) then zero out other (not harmless).
Im not very imaginative so im at a loss here. Can you construct legal code where parameter of op=(T&amp;&amp;) is *this? How? This is of course only academic, since just swaping the state makes the check useless.
Does that mean the swap() idiom does not work any more for some reason?
What you say sounds right. Though, according to the article you can static cast an lvalue to an rvalue, so you'd need the check. Can you really do this?
The classical copy/swap idiom should still be fine because you are making a copy beforehand, so you won't ever blow away the object you're assigning into. However with move assignment / constructing you generally just swap without the copy, so just in case you decide to do Obj a; a = std::move(a); you should probably check *this.
8&gt;db.cs(29,29): error CS1502: The best overloaded method match for 'tfbWPFToolkit_CS.db.Format(string)' has some invalid arguments 8&gt;db.cs(29,36): error CS1503: Argument 1: cannot convert from 'object' to 'string' 
ToString is virtual, but alright, I won't have sleepless nights over it.
It's already reasonably high level, but there is libten which integrates it in to a Node.js-like C++ framework: https://github.com/toffaletti/libten
People are going to write functions that take entire parameter groups instead of thinking about what makes sense for the class they're writing. Then, later, they're going to have an awful time trying to figure out why something is not behaving the way the expect, where previously it would just cause a compiler error.
Not really. Let me give a simple example: You have a database program which creates a virtual IP when it is acting as the primary server (simple failover without clients noticing). The virtual interface is managed by the OS and there is no way to tell Linux something like: if this process dies, unbind the interface. Having two servers with the same VIPs on a single network is very bad, especially if the server process has died on one of the machines that thinks it is hosting the VIP. So clearly, we need a way to unbind the interface if/when the process dies (no matter what). A simple solution is to create a watchdog process which monitors the server application and unbinds the interface for you. If the watchdog process is simple and small enough, it can be completely verified for correctness, which solves the `kill -9` or moral equivalent. As far as the "cosmic rays" example goes: that isn't something you generally have to worry about, ECC RAM solves most corruption issues...it depends on the implementation, but even if a single event upset exceeds the error threshold of your hardware, it will be delivered to your application as a fault of some kind, like a seg fault. If you really don't trust your memory, you can checksum segments if you're ready to take the performance hit (non-trivial, but if the application requires it, so be it). Of course, you can get into situations where a cosmic ray corrupts memory in such a way that ECC doesn't detect it and it matches the checksum, but the chances are really low. Then there are whole machine failures, network partitioning issues, data center explosions, technicians relocating your machines across network infrastructure in ways that invalidates the load balancing and fault-tolerance...but now we're totally off-topic :-)
would c++11 make boost redundant?
Plus, its more portable then C++11 right now.
Indeed, which is why I personally don't use any C++11 features at all right now for projects that I really care about. I really wish that I could, but doing so would box myself into only being able to use the latest compilers.
Look a bit closer. libten uses Boost.Context. Also, the code is pretty portable. It's just the use case the author is using it for is x86_64 Linux.
Oops, actually the real problem is that when I read the parent to your earlier comment I dropped the words "that's built on top of [Boost.Context]" and thought you were offering libten as a proposed alternative. Your response makes a lot more sense now. :-)
boost is massive compared to the C++11 additions. I do think they should deprecate the duplication.
Thanks for the info, wasn't aware of that. I have some parts in my code where I used this assumption, now I will have to: std::string s1; std::string s2 = std::move(s1); s1 = ""; It's just other proof of this bad side of the move semantics, hope the static analyzers will see this at least.
Vector's *emplace_back()* function will be even faster than *push_back(/*move*/)*, it will construct MemoryPage object directly inside the vector and eliminate even the move operation. #include &lt;vector&gt; using namespace std; int main() { vector&lt;MemoryPage&gt; vm; vm.emplace_back(1024); vm.emplace_back(2048); }
I wouldn't draw too many conclusions from something that is said at the moment of acquisition. At this point the message is targeted at the stock exchange to keep them calm and potentially raise the value of the shares.
Git repo: git://djvu.git.sourceforge.net/gitroot/djvu/djvu
Does this mean the license will change, say to BSD? Or will it still be LGPL?
I can't see any reason why it would. Moving to a BSD licence would completely remove the market for Qt Commercial which is the main way Qt development is funded. The only way I can see Qt ever going to a BSD licence is if Digia decides to stop releasing an open source version of Qt and the [KDE Free Qt agreement](http://www.kde.org/community/whatiskde/kdefreeqtfoundation.php) kicks in.
Is development currently halted? Will this transition delay the release of the next version of QtCreator?
Yeah I noticed that users can press anything else from 4 to 1million and it still passes not sure how to solve that ill check how a default thingy works :) thanks
g++ -g -o game game.cpp gdb game run Program received signal EXC_ARITHMETIC, Arithmetic exception. 0x0000000100002bf2 in main () at test.cpp:312 312 cout &lt;&lt; "Opponent Swings for " &lt;&lt; rand()%OPPDMG &lt;&lt; " Points of damage + " &lt;&lt; OPPWD &lt;&lt; " Points of damage from " &lt;&lt; " his " &lt;&lt; " weapon" &lt;&lt; endl; (gdb) print OPPDMG $1 = 0 http://en.wikipedia.org/wiki/Modulo_operation &gt; n mod 0 is undefined
R u 4 serial about those variable names?
That's what everyone always says. Get in the habit of writing them well from the beginning now. It's a hard habit to break, and one that will haunt you later if you don't.
 while(OPPHP &gt;= 1 &amp; PHP &gt;= 1){ While this will work, I think you intended to use a logical AND rather than bitwise. There is a difference.
Thank you. I read this and basically thought "TLDR: Don't use exceptions unless you know how to fucking use them."
There are [videos of the 2011 event](http://channel9.msdn.com/Tags/cppbeyond) on Channel 9, but if you look at the timestamps it was about two weeks after it ended before the first one was posted and later ones took several weeks/months to be posted. So we might be in for a bit of wait. 
The fact that they give no indication as to what they are used for - what they "mean". Examples of bad variable names: OCHP, SBWD, OCLV. Example of a good variable name that he used: EndRoundEnergyGain
Ok thank god. I've found myself over describing my variables for the most part, haha. I was afraid you were going to say the opposite. I have a hard time keeping track of my variables when I make them stuff like XOFC and what not. It takes longer, but it makes it much easier to manage. Thanks for the reply.
Probably not, djvu documents tend to be image-like and seldom contain plain text data.
Mike is being a jackass, you point was valid, most people who ask for an IDE haven't seriously considered a Editor and compiler option, and at the end of the day they can ignore your advice.
Well it is no surprise that is MS. But you would *think* that the large commercial company would be at least competitive then what is a volunteer effort (I know that is gross generalisation and many people are paid by companies to work on gcc). Also you would hope with Herb Sutter on board that they would step up their game too.
1). Yes 2). Did you read my post I said it was a gross generalisation, and that there are many paid workers for gcc. in fact: &gt; (I know that is gross generalisation and many people are paid by companies to work on gcc). That said, there is still a big difference between developing in house and gcc's approach.
My point is that the people who work on gcc (or the companies that pay people to work on it) have a motivation: they need the software. Microsoft, OTOH, doesn't have that motivation. They merely do the bare minimum needed to sell VS.
oh right, you should of just said that :) That said, I think MS does need the software, that's how they sell new versions of MSVC and stifle competition from other compilers on their platform (IE: if they had 0 c++11 people would start using icc). 
MSVC's standard library is almost certainly the most complete out of the three. MSVC has the entire C++11 standard library implemented, except the bits and pieces that require language features that they're missing (like initializer list constructors on the various containers). But there was this little bizarre gem in the article: &gt; Please note I didn’t detail the non-language concurrency changes. Generally, support for those remains limited. Well, yeah... MSVC is the only one to have implemented the full C++11 concurrency library, which is a pretty hefty chunk of the additions to the standard. GCC and Clang are the ones who haven't. I'm not sure what the reasoning was for leaving that out of the chart. Unsurprisingly, if you leave out the parts of C++11 that GCC and Clang don't support (but MSVC does), it's going to skew the chart further in favor of GCC and clang.
Sure. I've collated these from the [gcc support matrix](http://gcc.gnu.org/projects/cxx0x.html), the [clang support matrix](http://clang.llvm.org/cxx_status.html), and [this MSDN blog post](http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx). There is also [this matrix](http://wiki.apache.org/stdcxx/C++0xCompilerSupport) but it seems to leave out concurrency aspects as well. | Feature | GCC | Clang | Visual Studio | | :-- | :--: | :--: | :--: | | Sequence points | No | No | No | | Atomic operations | 4.4 | 3.1 | 11 | | Strong compare and exchange | No | 3.1 | 11 | | Bidirectional fences | No | 3.1 | 11 | | Memory model | No | No | No | | Data dependency ordering | No | No | 11 (no function annotation) | | Propagating exceptions | 4.4 | 2.9 | 10 | | Abandoning a process; `at_quick_exit` | No | No | No | | Atomics in signal handlers | No | 3.1 | No | | Thread-local storage | No | No |10 (Partial) | | Dynamic initialization and destruction with concurrency | No | No | No |
I think you need to look at more than just a check box in a feature list. VS11 may be behind in check boxes, but I've also encountered far fewer bugs in VS11 (the compiler at least) than I have in Clang. I don't have as much experience with GCC as I do with VS11 and Clang so I can't comment there. I think Clang is taking more of a shoot first, ask questions later approach than VS11. 
Well, Clang is not really a mature project. It's only recently been out of the "experimental" phase.
That is exactly my point. I like Clang a lot and I really want to see it succeed, but C++11 support is only part of a compiler being ready and Clang isn't quite there yet in my experience. 
I think the only thing to save QT would be a BSD or similar license, Digia's model really requires they sell QT. Just try asking about static linking etc. nightmare situation and makes embedded development and non native platform development much trickier. Unless digia can create an ecosystem where QT can be funded in a manner that allows QT to be used like clang/opensssl etc. then I fear their need for profit will kill QT. I know now I will try every opportunity to not use QT now unless it either goes bsd or adds a static linking clause to their lgpl license, otherwise the ease of use is diminished a lot IMHO. Even better, boost license the GUI parts and integrate it in boost as a pure GUI toolkit. Unless they take all QT developers (which they imply they won't) then the huger range of API's will suffer worse than the low morals are already affecting development. 
Note that lambdas were originally implemented in VC10.
What is it about inherited constructors that is so difficult to implement?
A sales article in ACM? No mention of the outrageous price? Posted by their competitor? SHOCKED.
TBB is intel.
While definitely interesting, these are not the videos. I meant the videos from the C++ and Beyond 2012 conference. The talks given are listed [here](http://cppandbeyond.com/cb2012-schedule/).
they checked in some changes this year, so I think yes.
https://wiki.apache.org/stdcxx/C++0xCompilerSupport
&gt; The hard one that took 188.79 seconds by Python was solved in 160.42 seconds by the C++ code. I just don't get how C++ code can be so slow. Does Python bring so little overhead? 
It's also important to note he made a copy of everything he looped through with the "auto _a : a" style construction, because he didn't do it with a reference. It should be "auto&amp; _a : a", and will definitely speed up the program. I'm just curious how much.
Damn - some Sudoku puzzles require guessing? That's not a very nice puzzle. =( I wonder if this program's going to be ported to JavaScript. =)
A compiled language isn't a silver bullet for performance. If you don't know what you're doing (or even if you do), it's very easy to accidentally write C++ that is slower than what you would write in a language like python. For instance, a common C++ mistake that this code makes is making a lot of unnecessary copies. This mistake is much harder to make in python because it uses reference semantics.
5) I also noticed &lt;thread&gt; - I guess that thread scheduling cost isn't worth for such small and "simple" problem (even someone says it is NP complete) 6) std::shared_ptr&lt;T&gt; ?? - always try to build acyclic graph of ownership if possible, std::unique_ptr&lt;T&gt; and boost::scoped_ptr&lt;T&gt; have no overhead 7) Move semantics usable somewhere? 8) Maybe writing Sudoku solver program in C++11 from scratch and thinking in C++11 from start would give better result than rewriting program from another language. 9) Yes, I know I have full mouth of advises but no program to show. Shame on me :-(
OP here : I was a bit sloppy with the original experiments. I updated the post with new numbers. Python : 72.27 seconds, C++ : 45.34 seconds. I noticed that auto const&amp; did help, but not by much. The time when using auto const&amp; everywhere was 49.29 seconds. 
This is cool!
there are a family of open source C++ projects.
Doing what? Not a single README file in any of the packages. Found a single Microsoft Word document called "What is it.doc" (that's right with spaces). Bozo.
It is indeed silly! It was also [invented](http://www.open-std.org/jtc1/sc22/WG21/docs/papers/2009/n2980.pdf) by Robert Klarer, **Bjarne Stroustrup**, Dan Tsafrir, and Michael Wong.
Or, if in Boost, how does this compare?
from author of LibCat
Not good. Among other things, using a mutex is completely unnecessary. It's easy to find much better alternatives, [for example on Stack Overflow](http://stackoverflow.com/questions/1008019/c-singleton-design-pattern). 
Why would you do this over just putting a bunch of free functions in a namespace and an implementation in another file? With free functions you don't have to keep track of initialization, you don't need to use a bunch of macros, and you don't have to recompile all your client code every time there's an implementation change.
Your implementation may still be a singleton as it's one way to ensure at compile time that your system is initialized. But.. yeah.. mostly c# has rotted people's minds.
Meh. I use these. Yes, you're technically correct. But I'm always in both class and namespace scope when I do it, and most standard library implementations I've seen use double underscores for anything that may effect me (macros/globals). I've been doing this for roughly ten years compiling the same code on various platforms without issue. It's definitely more helpful than it is hurtful - underscores at the beginning help very much to distinguish private members. I do catch a lot of heat for this from various people, but luckily I run the show where I work. Worst case scenario, I'll change it if my code won't compile where I want it to. It's definitely no worse than macro hell (stupid MSVC and MIN/MAX macros). 
Yeah, I'm going to say that, for example, [Loki's Singleton](http://loki-lib.svn.sourceforge.net/viewvc/loki-lib/trunk/include/loki/Singleton.h?revision=1183&amp;view=markup) is a level above this one.
Nope: &gt; Each name that contains a double underscore _ _ **or begins with an underscore followed by an uppercase letter** is reserved to the implementation for any use. and (although not relevant here) &gt; Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace. 
&gt; but I'm sure there are other uses Delegates or signals/slots implementations that do not use the preprocessor. 
Is this safe? Is it guaranteed to work? buffer[-1] = offset;
Herb Sutter has hinted tht they will have an interim relese before the next version with c++11 support
Is Qt even relevant any more? I had a look today to GWT and its libraries (SmartGWT and GXT). They are a lot richer than Qt when it comes to GUI, they cover everything one wants, they are client/server, they use HTML5+JS+CSS, and the Eclipse GWT designer is top-notch. And you only have to learn Java. 
TIL. Must have missed that in the standards doc.
Can you explain how a mutex is not necessary? In the example I saw from your link it looks like the user makes this a static object in the getInstance method. This alone does not prevent double creation and initialization of the object. I'm hoping there is something I have missed and you can point it out to me.
What's the framework? It may not support VC++ 2010 (Is that what you used on your old laptop?) You shouldn't need to do more than configure the projects or solution for the framework correctly to get it to build. If you've resorted to trying to download random header files from the internet and move them around your disk, you've gone too far and it probably won't ever work. Delete everything you downloaded and start over, but make sure the framework you're downloading supports being built by VC++ 2010.
It was actually specifically made for 2010. Also, they aren't random headers, a lot of them I actually recognize despite my limited knowledge, some of them are fairly common. I believe I was actually somehow missing stdlib.h. If by start over you mean re-install from scratch, I've done that twice. For some reason, the header files aren't downloading. I'm not sure if they dont download with VS 2010 and I'm re-installing the wrong thing, but im always missing the same ones. 
I thought that might be the problem, but I already manually set up the pathing to work. Also, stdlib.h wasn't there until I downloaded it, which I was quite surprised about. It seems pretty clear there was an error downloading the headers. 
How are you downloading these header files?
so if scary iterators are allowed, are SCARY assignments &amp; constructions? std::list&lt;int, my_alloc&gt; l2 { 1, 2, 3, 4 }; std::list&lt;int&gt; l2 { l1 }; Also the Y of that acronym boarders insane.
No, although I suppose that could be proposed as a further addition. You can always write list&lt;int&gt; l2(l1.begin(), l1.end()).
yeah that is the syntax I currently use, as well as the .assign functions. That said, I guess that by allowing SCARY construction, one could argue that you extending the Algorithm/Iterator interfaces to work on whole containers. And then there should be: std::transform(my_container, ...); std::equal(contianer1, container2,. bin_pred); .... Thanks
Thank you for finding that. You don't know how many times this has come up in code reviews where I work. New grads will often use static and claim "thread-safe" behavior. While it *seems like* it should behave this way, prior to C++11, there was no concept of threads in the spec. It's pretty cool and I'm happy to see that this has made it into the new standard. With regard to singleton mutex protection. As of August 2012, working for a company that uses dozens of different C++ compilers, I would 10 out of 10 times ask a developer to resource protect his singleton object variable. While what you said is true about GCC, I can tell you for certain it is not true for many compilers. 
Is it me or did they just got into a fight? 
Yes, it is. Is that good or bad? Also, I've been google-ing it for hours, and I've tried things that don't even make any logical sense. Nothing has worked so far :(
What is the full lib path you used (to the DX SDK)? In Lib there is x86 and x64, you have to use the appropriate one and not Lib only.
Ended up being that he had no path separator between the different library folders so instead of having PathA;PathB he had PathAPathB.
Typically releasing resources, which is one of the major uses of destructors, will not throw, but there are other things that you might want to do in a destructor, like logging a message, which might throw. Having the application terminate because logging failed seems drastic to me.
Why do you say it is lucky that you run that show were you work? That just means that this code is less likely to be fixed. Some day some one is going to have to fix it and they won't feel lucky.
&gt; Having the application terminate because logging failed seems drastic to me. But so is throwing an exception if you fail to log.
my thoughts exactly; especially a dying tech from adobe
Seems like they're somehow trying to revive it a bit.
McKayla is not impressed with your closed source fork of LLVM.
Because it'll probably take a pretty long time to die.
About that sandboxing... check adobe's security history if you care.
Nothing in the article makes a good case for pointers. The only reason to use a pointer is when you need a mutable and nullable reference, and that almost always means interfacing with C code. Then again, you're not a veteran until you've seen this: struct Foo { Foo&amp; operator-&gt;() { return *this; } }; 
When I read the title I thought this was about compiling flash to c++, the other way around sounds kind of stupid. Anyway it sounds pretty impressive that they manage to interpret directx and OpenGL calls.
&gt; Foo&amp; operator-&gt;() { return *this; } That's like wearing a condom all the time, even when you're not getting any.... just to be "safe".
&gt;and also deploy it to iOS/Android with Air Can't you already deploy C++ games to iOS and Andriod?
Is it a dying technology? I know its dying in the webpage/web application aspect but is it dying as far as browser-based gaming is concerned? 
Not without a lot of work in either case. Though the supposed advantage depends how easy it is to setup the Adobe air app in the first place. 
This comes up every month or two. The article is wrong for exactly the wrong reason. Less syntax is not better when you have two very different semantics being covered. http://www.reddit.com/r/cpp/comments/nlpy2/when_and_where_do_you_prefer_pointers_over/c3a6dqv
Yes they can. It's trivial to do by accident. http://www.reddit.com/r/cpp/comments/nlpy2/when_and_where_do_you_prefer_pointers_over/c3a6dqv
No references are not allowed to refer to any invalid object --ever. If you have a reference to a null or otherwise invalid object, the entire program is not well-defined according to the C++ standard. See section 8.3.2 paragraph 5.
in next Qt the syntax can be macro-free if you want http://qt-project.org/wiki/New_Signal_Slot_Syntax
Well after I cleared the blood from my eyes bleeding, I tracked down at least one bug... ScruffyBanditLevel = rand()%ScruffyBanditLevel; will eventually cause a floating-point exception because ScruffyBanditLevel will be 0 and you can't take the modulus of 0. I think you probably meant to do something like ScruffyBanditLevel = rand()%MaxScruffyBanditLevel; Similarly for OrcChiefLevel = rand()%OrcChiefLevel; OrcLevel = rand()%OrcLevel; Good luck. 
Oh boy. I really hate to say this, but this program makes the hair on my neck stand up. I'll try and give you some pointers what to improve: First off, decompose the program into functions, if not classes. You have one huge main function, with many repetitions. This is hard to read and harder to debug. For example, write short functions like "askGender", "askPlayerName", etc. that print the appropriate message, ask for user input and return the result as an appropriate type. You have many while-expressions that look like this: while (variable = 1) That's wrong. You are assigning 1 to the variable, not testing whether it is still equal to 1. What you want is while (variable == 1) or, even shorter while(variable) Since every integer except 0 evaluates to true. You can also declare them as booleans instead of integers, since you never use values except 0 and 1. Next up, you have many [magic numbers](http://en.wikipedia.org/wiki/Magic_number_\(programming\)#Unnamed_numerical_constants) in your code. Replace them with enumerations. For example, the gender could be expressed like this: enum Gender { GENDER_MALE, GENDER_FEMALE, GENDER_UNSPECIFIED }; then instead of 1,2,3 for the three options, you can use those constants. Much more expressive, readable and safer for future extensions. In the process of improving your code with the above suggestions, you might already discover some of the bugs that plague you. If you still have problems, go over to /r/cpp_questions or /r/learnprogramming and ask there. Those two are the most appropriate subreddits for questions like yours. I can also recommend the [codereview stackexchange](http://codereview.stackexchange.com/), but only for short snippets, not complete programs.
A short list: - functions/methods bigger than one screen; - functions/methods that perform more than one task; - lots of duplicated code via copy-paste; - confusing code due to premature optimizations, not yet validated; - code that does not take advantage of existing libraries, and re-invents everything; - lots and lots of abstraction layers just to make the architecture "look better"
Bad code is any of the following (and this is hardly a complete list): - Code that works for most cases, but not all cases. - Code that wastes a lot of resources (time, memory, ...) when it is trivial to avoid wasting resources. - Code that is difficult to maintain. That last category is the most common one, and maybe the biggest waster of programmer time. To avoid bad code: - Always make sure you correctly handle all documented input. Preferably, include tests for the "edge cases" as well as the common cases. Common cases are what everyone does; edge cases are the uncommon requests that your code is still expected to fulfill (does it work if n = 0? what if n = max? what if you pass it a null list instead of an empty list?). - Write things as straightforward as possible. Write logic as trivially as possible. Write concise, cleanly-spaced code. Use meaningful variable names, method names, class names, etc. INCLUDE CLEAR, CONCISE COMMENTS.
You could write entire books about what makes code good and bad, and people have in fact done that. Programming is a craft with an aesthetic, and it's something that takes years of practice to really learn and develop, which is why all beginner programmers as rule write just dreadful, terrible code. There's nothing wrong with that per se; we don't expect students of music to compose like Mozart, or beginning sculptors to churn out Michaelangelos. As you gain experience you start to get an idea of what good and bad actually mean. This is not an objective measure, it will mean something different to each person. There are broad areas of general agreement, yes, but there are different styles, approaches, and priorities, especially with a language like C++ that is so multi-paradigm.
code that is hard to debug
If a somewhat crappy programmer (that still understands normal syntax) cannot read and understand the code without difficulty then it is bad. If a normal reading of the code leads to an understanding of it that is not correct then it is bad. If the code was written by someone with both a neckbeard and a phd then it is bad.
Although it isn't the ONLY example my biggest personal peeve is the way some people choose to name functions, methods and variables. A basic rule that I try to follow is this: writing code comments should feel redundant, (but it should still be done) if you ever feel that you have to clear up what a function does or a variable for someone to understand it and know what is does then you should consider renaming it.
Beyond handling documented input, your code needs to be defensive against all input. Invalid input is incredibly common, especially when you are working in distributed systems and APIs are invoked between cooperating services. And, don't silently accept invalid input and drop the call. Log the error so you can easily identify the other component that needs to be fixed. After 20+ years of doing this stuff, this is, IMO, the most common failing of developers. 
Bad code is like obscenity, [I know it when I see it](http://en.wikipedia.org/wiki/I_know_it_when_I_see_it).
Thanks for clearing that up
Good point, and one I forgot to mention. I would consider this alternative, though: always document what your code does for any input. You should document what happens on different kinds of invalid input (exception? error logged? returns negative values? etc).
To give an example of bad code I've been dealing with lately, I have had to deal with a *single function* (of several hundred lines) which: * Read a file into memory * Loaded it as XML * Read data from the XML into an object * Set a bunch of options, dependent on the object that had been read in, compared to a set of configuration data * Generated a PDF from the object * Either printed, emailed, or faxed the generated PDF, depending on the config settings, and the loaded object Protip: I used a refactoring tool to split that behemoth into fifteen smaller functions so that I could *read it*. If I'd wanted to refactor it properly, I'd probably have refactored it into more functions.
I think it takes some experience to spot bad code. Focus on writing good code. Do a Google search for "Clean Code".
&gt; zlib is an example of a library that is rather good. The documentation could be better organized, but the library focuses on compression, is easy to integrate, and platform independent. Actually, I think this is a really good example. Zlib breaks a lot of the novice "good software" rules like short functions, long and descriptive variable names, and so on. Heck, deflate() is &gt; 300 lines long and littered with preprocessor directives. It's still fairly readable, though. It hits a lot of other, more important points, too: the library does one thing, API is good, it has good platform independence, etc.
Agreed. Maybe a blurb on passing non-QT data types via signals &amp; slots.
I have have the experience of working with the other end of the spectrum of that kind of code. Specially from people that have just got out from various programming courses. It's that they like to break down everything into so many classes and functions that its impossible to actually understand what the code finally does. It can even go as far down into that they have created functions like "AddNumber(int value1, int value2)" or functions that just contains one line of code that calls another function. Probably because they have been told "no function should be over X lines".
And if it really is a one off, use a lambda function so the next person reading the code doesn't have to go looking for every trivial one use function call.
I've always hated omnibus 'documentation' via full programs. People need cookbooks for your API, not one program explaining one very narrow example.
I did say that. It doesn't stop it from ACTUALLY HAPPENING. You can wave the "but the spec says so" wand at it all you like, but the fact of the matter is this can (and does) happen. In real code. In production. References are not magic bugs-be-gone powder. It irks me when people sell them as such. They have their uses, but "eliminating a whole class of problems" is not one.
Here is are actual code samples that I have actually found somewhere. I don't make this up: // Always returns true bool isGood() { return false; } and my all time favorite: int calcLength(std::vector&lt;int&gt; v) { int a=0; for (int i=0; i&lt;v.size(); ++i) { a = a + 1; } return a; } I think the software metric "[WTF's per minute](http://davidlongstreet.wordpress.com/2009/04/29/new-software-metric-wtfs-per-minute/)" is quite good. The more WTF's the worse is your code.
Just started learning programming yesterday. Made my first program that wasn't guided by tutorials and is a few hundred lines long. If you have the time, can you check *(just look around quickly no need to spent an afternoon reading it)* if the code seems messy or how many rookie mistakes I have made in that? The game TicTacToe works pretty much and accepts wrong input without breaking (I hope), the only thing I can't seem to figure out is how to ask the player to input a turn again if he selects an already filled out "box", while keeping the **box1 = (box1 == '7') ? 'X' : box1;** style and not use any if statements. Using **box7 = (box7 == ('X' || 'O')) ? playerTurn(1):'X';** should work, but it doesn't for whatever reason. *If box7 is already filled with an X or Y, repeat player1's turn again, if not then fill the box7 with an X.* [Code](http://pastebin.com/z0bPvNUh)
Humans can store 5-9 elements in their short term memory (http://en.wikipedia.org/wiki/Short-term_memory). Bad code fills more of these slots with pointless information. Which means more time needs to be spent summarising elements down or committing them to long term memory. For example modularisation: if a module has a well defined interface then a programmer only has to remember the interface, not the implementation. Whereas a poorly modularised system will require a programmer to remember the interface and the implementation