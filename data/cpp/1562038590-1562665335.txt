You shouldn't pick a language you should let your application pick the language. A good programmer can write in any language.
With respect to your path, in the order of enumeration: 1. Get a good mentor. It is invaluable. OR 2. Get a degree. OR 3. Code, make mistakes, ask for help and REPEAT. Or, you can have all these three at the same time...
You think the media cares about CS degrees? You know what would be a PR disaster? Having you critical software fails and kill people. No one is going to care whether everyone knows how to parse infix to postfix.
Don't know why you're getting all pissy at me dude, I'm just telling you the rationale, I'm not the one that came up with it, nor am I the one that enforces it.
A college degree can open doors, sure. Maybe even a CS degree in particular. But there's plenty of people out there in the industry without a CS degree. There's others without any college degree, too.
But that isn't the reality, it's just your company that doesn't know how to hire people. Also people not having a CS degree being a 'PR nightmare's is total nonsense. Ironically sourcing statements and not making them up is touched on in college. Somewhere else you equate out sourcing to not having a CS degree. Maybe you didn't take a logic class either.
I can definitely confirm it first-hand in the case of both Amazon and Google. I personally know many examples.
Pointing out the outsourcing is providing example of how media will clamp on to any abnormality and run with it to drive outrage, at no point did I say they are equivalent. Sorry, didn't realize I have to feed everything to you on a silver spoon. Also, my company successfully ships hard realtime, safety-critical software multiple times a year without incident, so claiming we don't know how to hire people is hilarious.
Cool, reminds me a bit of ReClass but for static data
I think that u/Ekizel's point is that this is anecdotal. It doesn't seem like you've suffered from not having a degree but this is only one person's experience which depends on many factors that are unique to you i.e. your own aptitude, the jobs you are applying for, where you are working etc. u/Ekizel was aiming to give generalizable advice and just because it conflicts with your anecdotes doesn't mean that it is not valid.
Right but I interpreted OP's question as "what is the best strategy in general?" rather than "is it possible without a degree?".
Anthony Williams' book, Concurrency in Action, is a great go-to book. If you are more the MOOC type, Rainer Grimm's course does a great job of going into the memory model and the meat of the API as well. If you need a quick YouTube series to just know the basic terms and catchphrases, Bo Qian's lectures are good.
in /r/cpp_questions
&gt;I also work in safety (life) critical systems and I fail to see any relevance between formal credentials and ensuring product safety and/or quality and/or dealing with fallout from a defect. Unfortunately lawyers and PR folks would though
You would assume that the media would react rationally? I could absolutely see them doing something like that. The media has done much crazier things.
At the very least a university degree demonstrates that you are committed and it also shows that you passed certain classes. If you don't have a degree then you will have to convince employers of this in other ways. There is also the potential for knowledge gaps if you didn't learn from a curriculum. It is difficult to self-teach yourself subjects that you are not really interested in but still should know. A university is good at forcing you to do this because they actually hold you accountable.
Yes, and I didn't try to paint it as anything else but anecdotal. I only talked about my own experience. It was him who suggested that my comment is "invalid" because it's anecdotal. But imo his comment is just as anecdotal. Which is fine, this is a discussion forum in the end.
Just make 1 function that does the processing of 1 image sequentially and than use the parallel version of [`std::for_each`](https://en.cppreference.com/w/cpp/algorithm/for_each) on your collection of images, **no need to read a book**. Use constructor number (2) with `std::execution::par_unseq` as the first parameter. Dont' forget too include `&lt;execution&gt;`.
awesome. Thx
No need for a lib, structured bindings and tuple do [almost] literally what the go-code does: auto const [ result, error ] = some_function(param); // returns a tuple of the return value and the error code. if( error != errors::nil()){ //oops error }
It seemed like you were disagreeing based on your own personal experience. But fair enough if you weren't.
Payment for software-devs is pretty low in germany (compared to the USA), which might explain why we have a lot more mech./elect. engineers...
Perhaps you could go through concurrency chapter of Scott Meyers "Effective Modern C++" which recommends using task based concurrency instead of std::thread. That might give you some headway.
thx
Before you go into deep usage of low synchronization primitives (mutex, etc.) I strongly recommend to watch Sean Parent's [https://sean-parent.stlab.cc/papers-and-presentations/#better-code-concurrency](https://sean-parent.stlab.cc/papers-and-presentations/#better-code-concurrency) talks and Kevlin Henney's [https://www.youtube.com/watch?v=UJrmee7o68A](https://www.youtube.com/watch?v=UJrmee7o68A)
`stlab` implements the Concurrency TS, notably async continuations, which is concurrency the way it needs to/should work.
Nothing normative, sorry; I've just seen it mentioned a few times in trip reports and in comments here e.g. [this one](https://www.reddit.com/r/cpp/comments/9w9h79/vote_for_the_next_standard_library_component_you/e9jts3s/?context=1).
Search for reddiquette. You’re posting only your own stuff, and not otherwise participating.
It was like that, but this leads to more lines of code, remember you have to declare the value and error above, so made a container class to keep that in check. Also I guess std::tuple can invoke exceptions, though I might be wrong.
&gt;I also work in safety (life) critical systems and I fail to see any relevance between formal credentials and ensuring product safety and/or quality and/or dealing with fallout from a defect. Boeing was literally all over the news because they used outsourced developers. I'm not the one you have to convince, its the jury at a trial for negligence that you have to be worried about. &amp;#x200B; \&gt;&gt; I'd assert that the whole point of having a QA process and regulatory oversight appropriate for a safety critical system is that you've already done due diligence with documented proof thereof such that negligence is impossible by definition. What seems to have happened w/ Boeing is that the process failed at multiple levels. Why that happened and what can be improved to prevent it from happening again is the next step. Assigning legal blame and liability ... well... I'm just not familiar enough with who bares responsibility when everything was done "by the book", but the book per-se was broken. My casual belief is that the FAA is as much to blame as Boeing in this instance. \&gt; I fully admit I don't know what to make of the outsourced developers fitting into the puzzle other than it certainly muddies the waters. &gt;Similarly I've worked with folks that are self taught in C/C++ and have years of experience and I'd trust my life to their code. I've had these experiences too. I've also had developers with college degrees that blew my mind with their quality and productivity. Conversely, I've had a 'senior' developer with no formal education ask me what 'static' in C# meant. We can sit here pulling anecdotes out of a hat all day, it won't actually mean anything. The person who made this thread is neither experienced nor has a degree. To a hiring manager for an entry-level position, they will easily get overlooked for people with work experience or a degree. You may not like it, but that's reality. \&gt; Agreed. Sometimes it's tough to break in. How do you feel about coding academies? &gt;With your company the failing seems to be assuming a strict causal relationship between credentials and ability. That is one hell of an assumption. For one, this discussion is in the context of an entry level job, not an experienced position, and for another, you're implying we just see the college degree and immediately hire them without vetting their actual ability. \&gt; We talked past each other a bit there. My phrasing on second look implies more of a leap than I wanted to make. Let's just agree that all candidates need vetting at all levels.
I recommend this book, I think there is an newer version out already. It covers beginner knowledge and also advanced high performance stuff like atomics and the memory models. https://www.amazon.com/C-Concurrency-Action-Practical-Multithreading/dp/1933988770
There is this little detail of making sure the iterations don't step on each other's toes. E.g. the results of each iteration can't be stored in a shared datastructure (unless of course each item already has its own preallocated slot in that datastructure)
Isn’t this only supported by 1 compiler atm?
There are some concurrent data structures (e.g. Microsoft's concurrent_unordered_map and co.) that I believe are designed for that type of operation.
Gcc, and it needs tbb
&gt; ... remember you have to declare the value and error above ... You'll have to define your errors-enum-class, sure, that's gonna be unavoidable. The `value` is just the return value of the function, I presume you have to have that also well. But the `std::tuple` can be created [and moved into] on the fly with curly braces and created in situ with RVO. std::tuple does nothing with exceptions, the contained types do of course do whatever they do with regard to exceptions.
This is incorrect. MSVC had the first implementation, which they are shipping. GCC, ICPC and PGI also have implementations.
Pretty sure they are not usable with `par_unsequ`. Although in practice it probably does the same as `par`. I'm not saying this is particularly hard, just that "just copy the body of your sequential for loop" doesn't quite cut it.
I interpreted OP's mention of 'processing' as a transformative process, i.e. no copies produced, in which case the parallel loop does cut it. Otherwise a container of un-processed-processed-pairs is probably the simplest and will solve your objections elegantly, without having to revert to something like concurrent data structures.
No, it's a reference to this joke: https://www.reddit.com/r/ProgrammerHumor/comments/2pzv2e/in_c14_you_just_write_auto_autoauto_auto_auto_the/
I believe I read that Clang will also use tbb, like gcc. I don't know where they are with it, because although I use Clang, it [clang-cl] uses the MSVC STL.
Love Factorio. Heard you guys were using Allegro some time ago. That was my first library, big love. Good luck with the finish!
&gt; I interpreted OP's mention of 'processing' as a transformative process, i.e. no copies produced, in which case the parallel loop does cut it. That might very well be the case, but image processing can mean a lot of different things and in particular considering the following part: &gt; I might need to sync them up to do other processing on their results every so many elements. I'd not just assume that there is no communication necessary beyond "the for loop has been completed" As always in c++: You need at least to have a basic understanding of what you are doing, if you don't want to shoot yourself in the foot. ;)
Agree, I up-voted you back to 0. I do think, though, that the `C++17` parallel algorithms need a push/promotion, therefor this 'question' is not bad here as on /r/cpp_questions, no-one, bar a few, would read [about] it.
&gt; As always in c++: You need at least to have a basic understanding of what you are doing, if you don't want to shoot yourself in the foot. ;) Amen.
Where I work in finance there are several things we look for: 1- good knowledge of C++ itself and the syntax, classes, templates, integers, floats, etc. 2- good knowledge of the standard library, esp. the containers and algorithm 3- good knowledge of how the computer works, the different arenas of memory (heap and stack, but also caches) 4- familiarity with assembly language is a bonus since you'll have to debug at this level and check what the compiler does 5- and of course business knowledge of the field you're targeting can't hurt
**Company:** [Gritworld](https://www.gritworld.com/) **Type:** Full time **Description:** Gritworld pushes the boundaries of real-time graphics and computer vision and develops key technologies in graphic visualisation applications for the industry. Our focus is to improve the productivity of our clients in real-time Film and TV production, as much as real-time industry data simulation and visualization. We strongly believe in creating a work environment where people, ideas and results are more important than regulations and time sheets. Every human ticks a bit different, but we still share our laughs together. If you want to learn, create and grow with us, join us today. As a growing start-up Gritworld offers excellent opportunities for personal career development. *What you need for this position:* * You have 4 or more years of experience as developer in at least one professional environment * You finished a degree in computer science, programming or similar * You have a passion for clean coding and creative thinking * You have solid English language skills, both verbal and written *Required skills:* * Strong programming skills in C++ and modern standards 11/14/17 * Data-driven design and software architecture * Excellent debugging and optimization skills * Knowledge about common game engine systems, such as asset pipelines, entity component systems * Good understanding of multithreaded software architecture * Ability to work with an existing codebase, and eager to further improve it **Location:** Frankfurt am Main, Germany **Remote:** No **Visa Sponsorship:** Yes **Technologies:** Modern C++ (11/14/17) **Contact:** Apply [here](https://gritworldhr.bamboohr.co.uk/jobs/view.php?id=48)
&gt; Also I guess std::tuple can invoke exceptions Why would it? It doesn't allocate, so what occasion would it have to throw? The same goes for optional and variant, which you said similar things about – the standard library documents every occasion in which it might throw, there's no reason to be dogmatic about it. ;-]
A college degree is form of demonstration. It's not the ultimate or the only one. If you have an active github page, I am pretty sure that works too.
So you don't care about a degree in finance?
* Type: Freelance / Part-time, Mid-Level * Location: based in Switzerland. Available only for remote work. * Description: 3 years of experience working with Java / C++ / Python / JS. Worked on a few IT-Sec projects for a couple of Swiss banks and fin-tech companies. Currently working on IoT monitoring software for solar panels placed on residential buildings. * Tech: C++11/14, GCC, CMake, Docker, Linux, Git, Python2/3, Java7+, Angular, Android, Cmake... * Contact: DM for email/website/portfolio/Linkedin/CV ecc...
Support for building dynamic exists, but not in windows yet. Just pass -D BUILD_SHARED_LIBS=ON to cmake.
&gt; The same goes for ... variant ... Does it, we have now so many variants of variant, that I've lost track. A variant that provides a strong exception guarantee (boost::variant2) could throw, no?
Sorry, I thought it was apparent that I was talking about std::variant, which is never permitted to allocate (hence the `valueless_by_exception` fiasco). I've edited my previous comment to clarify.
Just venting my frustration with [the naming of] the `boost::variant2` fiasco. The whole variant [std or other] thing is a fiasco, if you ask me.
Why don't you post to cfe-dev@lists.llvm.org, file a bug at https://bugs.llvm.org/ or put a question on /r/cpp_questions/? All of these options seem to be more appropriate than /r/cpp/.
You probably need to link `-lstdc++fs`
I just started building stuff and selling it online. But heavy contributors to open source projects get headhunted all the time. I know we try to contact the devs of cool projects to hire them.
&gt;no need to read a book It's one thing to jump in and start using parallel constructs just to get your feet wet, but for the love of $SUPERNATURAL\_ENTITY, read at least one book about concurrent programming at some point. I say this as someone who has spent thousands of hours untangling concurrent code built by people who didn't want to learn about race conditions, mutexes, and other "boring theory stuff." They somehow ended up thinking the concurrency mechanisms in their favorite language and/or library would magically handle all the thorny details for them no matter what they built.
Damn, I missed it by 5 days :(
**Type:** Full time, contract **Description:** 5 years of experience working with C++/C#/Java. Worked on AR/VR startup, work on joint projects with HTC, Intel, Qualcomm. **Location:** Ufa, Russian Federation, but willing to relocate for the right job. Remote would be doable too. **Technologies:** C++11/14/17, VR/AR, ML, Mobile. **Contact:** DM for e-mail
**Company:** [neXenio](https://www.nexenio.com/en/jobs-and-vacancies/) **Type:** Full time **Description:** neXenio develops a highly secure cloud storage solution for end users. We are looking for C++ engineers with a passion for secure software, as well as UX engineers (Qt/QML) with a love for great user interfaces. We're hiring for all seniority levels. **Location:** Berlin, Germany. Speaking German is not required. **Remote:** No **Visa Sponsorship:** No **Technologies:** C++17. Our stack involves Qt, Botan, Conan, Jenkins. We target Linux, MacOS, and Windows; you're free to choose the tools you work with. **Contact:** Send an email to [jobs@nexenio.com](mailto:jobs@nexenio.com)
Possibly because, I don't quite have a great understanding of the subject, XD
Honestly speaking, I am yet to use both std::tuple and std::move, so I have pretty much no idea of their workings, :D
I'm not on the llvm lists, bugs.llvm.org is locked for new accounts, and this isn't really a question about how to use c++ (which seems to be what /r/cpp_questions is more about). so it's 75% laziness on my part, 20% wondering if actually noone has seen this before (I don't think -O3 is that uncommon, and I thought std::filesystem was starting to get more widely used), and 5% expecting an answer or solution (I don't really expect that until I man up and send some mails).
Here's some feedback: your post should have an introduction, a body and a conslusion. You should coherently identify and address a problem instead of enumerating some "rules" with a million subheadings.
&gt; I'm not on the llvm lists ... No problem to subscribe. &gt; bugs.llvm.org is locked for new accounts ... You'll have to ask on the mailing list, it's due to abuse no longer automated. &gt; ... and this isn't really a question about how to use c++ ... So you do think that what you are posting falls in the category: "Discussions, articles, and news about the C++ programming language or programming in C++"? I don't know, but it [your post] doesn't look like something like that.
&gt; IIRC, with par_unseq you can't even use mutexes for synchronizing access. You are thinking about the problem the wrong way. You should try to slot in the parallelism at the 'correct' level [in the overall algo], and set up data-structures in a way that syncing is not required.
Can you give me an example of a company hiring people without CS degrees being a PR problem?
What is up with your eye btw? I've always wondered but it seemed rude to ask, but since you brought it up...
You can't do this directly. First, construct a `std::wstring` from the `uint16_t`, then use `std::codecvt` to convert to UTF-8.
`You can't do this directly.` Nope, if it was that easy I would have done it. `First, construct a std::wstring from the uint16\_t` I can do that directly. `then use std::codecvt to convert to UTF-8.` But I can't work out how to do that directly, would you mind helping me further please? Your help is appreciated.
uint16_t* can be converted to char16_t* by using reinterpret_cast. Then, you can use the char16_t* to UTF-8 code converter as mentioned in the other comment. Code conversion examples are available on encpp.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Take https://en.cppreference.com/w/cpp/locale/codecvt as a starting point and go from there.
Proving yourself is necessary to get hired, but not sufficient. Some hiring managers are impossible to win over too.
Doubtful.
I agree with /u/futurefapstronaut123. I'd also suggest a different organization for your article. You reference Meyers, so I'd suggest something similar to how he laid out "Effective C++". If I were writing it, I'd start with the problem(s) you're trying to solve, then introduce the common cause(s) for them, and only then mention the rule(s) that can help mitigate them. Some rules help mitigate multiple problems, so it could be that mentioning the rule in the problem section is adequate, followed by a section with rule headings. The reason I'd choose such an approach is that people who would benefit from your articles aren't going to think "I've got a problem that the rule of three may help with". Instead they'll be thinking "I've got a problem where objects are being copied and I don't want that". So having the problem headings will make it easier for prospective readers to encounter your article when they google for an issue, and then once they're in your article, the other problem // rule relationships can help them learn a few other useful tips.
&gt;You can't even get into these roles unless your demonstrated mastery of theoretical and applied computer science is far deeper than your average CS degree holder. Having a degree, or a relevant degree, is not part of the selection criteria. I disagree. Degrees totally are part of the FAANG selection criteria. They just aren't *required*... I bet being employed isn't a requirement to get a loan from a bank either, but go try to get one! &gt;Teaching yourself CS basics is trivial by comparison; anyone that has demonstrably mastered advanced theory relevant to the project is presumed to have mastered the basics. In my experience, some of the basics are actually orthogonal to the more advanced stuff. You don't need to know all the basics in great detail to be able to work on advanced stuff, but the advanced stuff will likely be at least as difficult as the basics to master. &gt;I've been designing bleeding edge systems for many years at Big Tech and I've never taken a CS course in my life (science background). My extensive theoretical and applied CS work and experience speaks for itself. Everyone else I work with has a similar type of resume, degrees don't enter into it. I think this is very much a quirk of your team. At most places, even at FAANG companies, I see that a degree is de facto required. I have no reason to believe that a random person who claims to be self-taught knows more than someone with a degree. Not that it's impossible, but that's part of the point of a degree, so that I don't have to do the equivalent of 4 years of interrogation to gauge someone's basic ability.
Sure.
Yes, some people don't know any better, that doesn't mean that someone competent can't show that they know what they are doing. The idea that a degree is necessary is usually the naive view of young and inexperienced people getting their degrees or their first jobs.
i like this guy
Can you produce a small main.cpp file that exhibits this behavior and post it here?
You keep attributing getting jobs to luck, when just about anyone who has an ass that can warm a seat should be able to get a job somewhere. Most people out there are exceptionally incompetent. Someone just has to prove they are slightly above that level.
I disagree, but I don't have time to get into it. Besides it would apparently degrade into us saying "nope" to each other over and over.
I refer you back to my comment. It is generally necessary to be competent and show it, but not sufficient.
Eclipse underlines calls to templates where something goes bad inside and it works even if the function has multiple SFINAE overloads.
This will work fine until OP decides they need to use some kind of shared cache, or increment a global counter, or just declare something static or something, and then the **best** case scenario is that they get an immediate crash somewhere in \_fast\_memcpy() with 600 inscrutable stack traces, and the worst case scenario is that nothing crashes and the code silently produces incorrect results, and the *worst* worst case scenario is that nothing crashes and the code silently produces *correct* results right up until there's an opt build in production/on a client's computer/in QA for iOS, and at that point OP finally reads a book and realizes that every line of concurrent code they've written is actively conspiring with Satan to produce data races and silent corruption and hatred, but it didn't matter until now because on x86 MOV instructions are *kind* of thread safe, and all TSAN can do at that point is print a big "\*\*\*\* YOU DONE MESSED UP \*\*\*\*" banner, and everything needs to be rewritten, except that OP doesn't need to even introduce a cache or anything because code they/the knuckleheads they work with have ALREADY DONE IT in some obscure corner of a file called "util.cpp". &amp;#x200B; TL;DR: Read a book.
On linux I can compile with `-O3` with either libstdc++ or libc++. The only thing that fails to link is `clang++ -O1 -std=c++17 -stdlib=libstdc++ -lstdc++fs`. Note that, for `clang++`, `-O1` and `-Og` are the same. Also, linking works for `-O0`.
You said that already.
I had found a bug in Boost Spirit X3 that was due to some const correctness issue. The bug was only visible at linking time - some very long instantiation did not match actually compiled function template. I demangled the object file to search for the actual instantiation, took the linker undefined reference error for expected name and ... copy pasted both to Notepad++, find-replaced every `&lt;` to `{` and `&gt;` to `}` then used online JavaScript formatter to format the type name. Searching `const` differences in that beautiful tree was the easiest part.
The difference is that I'm not guessing out of frustration.
&gt; until you make an error with the standard library copy the error, ctrl+F "required from here" and you have the file + line number of your code which triggered STL
So what are you saying?
Any home-made project is good to showcase during an interview. There is nothing better to showcase your skills that your own, self-made program/library. Even better if it has tests, documentation, etc.
Concurrency is hard.
But my point is with the `C++17` STL it's a lot easier, so I tend to see the glass half-full. There are many ways to f'it up, but that does not mean that the tools are not great.
Yeah, good primitives are really helpful.
The tools are great, but you still need to understand them thoroughly to use them safely. There's considerable ease of use here, but there's also considerable ease of fucking it up.
compiler bugs are off topic. Report them on the appropriate bug tracker, not here.
So? python suites many people. What would you like? No tools, or tools you can fuck up. Or would you rather work through that horrible "Concurrency in Action". I've read both the first and the second edition, it's not a very instructive book, it does not tell you 'what to do in what situation', it's just a sequence of std explanation [without coherence].
&gt; What would you like? No tools, or tools you can mess up. I'd like to participate in a thread without having words put in my mouth..? I advocated nothing except understanding one's tools. &gt; Or would you rather work through that horrible "Concurrency in Action". I have, and would recommend it, yes. If you're just posting to rant, it would be nice to know that before attempting to engage with you.
&gt;If you're just posting to rant ... I'm posting my opinion, you don't have to agree, at all, ever.
Interesting topic, but unfortunately not really C++ and doesn't really even describe the algorithm with words. I think there are also a number of mistakes in the pictures, such as the partially opaque triangle looking fully opaque when it supposedly used sorted transparency.
#include &lt;teenie/weenie.hpp&gt;
&gt; I can not stress enough how incorrect this is. Sure, there are a few shady companies that gate on degrees, but not a significant amount. Maybe 10%? This is just nonsense. I can't comment about every industry, but for instance if you are looking at good finance companies (which is actually one of, maybe even the, largest single industry for C++), I can tell you that typically HR does an initial level of filtering which would rarely pass through someone without a degree. And never somebody with neither degree nor experience. In fact, if you don't have work experience, even going to a mediocre college means you probably won't get interviews at at least some of the best places.
You can use a [buffered channel](https://www.boost.org/doc/libs/1_70_0/libs/fiber/doc/html/fiber/synchronization/channels/buffered_channel.html) with the size set to the number of threads of the cpu. On the receiving end of the channel, just spawn a thread with std::thread and do the work on that thread. A buffered channel will block sending when it's full, which is perfect for this.
&gt;I fail to see any relevance between formal credentials and ensuring product safety This is sad. Normally if you are going to be responsible for people lives you would need to receive a relevant training, so you don't just fuck around hoping that everything is going to be alright, but you know what to do to prevent irreversible damage. This is not necessarily related to C++ or college, but it is strongly related to undergoing relevant training.
Cool, if you get it working I bet people would be interested in the process. About your name, is it 1. monkey-wife fight or 2. monkey wife-fight I could see #1 `monkey-wife` being either a) a wife of a monkey, or b) a monkey who is your wife But also #2 `monkey wife-fight` c) Like a cat-fight, except with monkeys. But then does a cat fight require cats? Have you seen an actual cat fight? Holy, moley it's screaming and scary. d) or a monkey who is fighting their wife?
**Type**: Full time **Description**: Experience with embedded firmware development and ML research. Hoping to work with high-performance or constrained systems (embedded systems, video games, HFT, etc). Have contributed to libc++ and have a number of projects on [my github](https://www.github.com/tvanslyke). **Location**: Cambridge, MA. Will not relocate but will gladly work remotely. **Technologies**: C++17, Python, C, C#, Debian Linux, GCC, Clang, Git, GDB, CMake, Qt. **Contact**: DM for email
the interface using unions and swizzlers is very nice. The problem I'm having with it is that I think the array trick with unions is UB (albeit all major compilers will work). Plus you also need anonymous structs, which are not c++ (which, again, all major compilers support). That's the reason glm hides them behind a macro. Would be awesome to see that standardised.
Generic concurrency principles - The Art of Multiprocessor Programming C++ - already suggested couple decent books
I don't do the message decoding myself. It's handled by AVT Vimba. I just get a memory range with the image contents from the library which I write to the file as it is.
My post to the rust group: [https://www.reddit.com/r/rust/comments/c8c9ce/crossplattform\_application\_logic\_development\_as\_a/](https://www.reddit.com/r/rust/comments/c8c9ce/crossplattform_application_logic_development_as_a/)
&gt; That may be sample bias. FAANG has a lot of high-end C++ software engineers without CS degrees or any degree at all. I think, a lot more of the former than the latter. IME these companies don't particularly discriminate between a CS degree or an e.g. physics degree (I'm an ex physicist); the education is used more to filter for smart-ness than knowing CS. That they simple test in the interview. And in the current context, the person is considering between doing a CS degree, and not doing any degree at all, in order to achieve a career in C++. So I don't think it's really relevant to the original post, how much CS degrees vs other STEM degrees help with employment.
It probably comes down to industry then. Most of my knowledge is applicable to tech and game companies. For them, gating on a degree is generally considered rather silly, and AFAIK none of the big players do it. Perhaps other industries like finance haven't caught up yet.
Why not just use GL_SAMPLE_ALPHA_TO_COVERAGE if you already use MSAA?
C++ is a decent cross platform language and you'll have access to the 'native' platform toolset for most things (except of course Linux doesn't have a single native UI framework or even display mode, but rather a handful of options, although tbh users there probably aren't too fussed about "native" looks for this reason either). TBH though it sounds to me like you're just building Qt. Which already exists, which is sort of the flaw in this plan. Qt isn't perfect, there's lots of things about it I don't like, but it exists and it works well and it already does all the things you're describing here.
You may also discover HaXe for writing portable applications' logic.
Yeah, you're guessing out of smugness.
Yeah I repeated it because you clearly didn't understand.
It's pretty condescending to say finance hasn't "caught up" yet. Nobody's cracked the interviewing problem, and I don't think that any company operating at scale has even made a half decent case for having an especially good process. Also, keep in mind, we're talking about someone without experience here. How exactly do you do an initial round of filtering, if you accept candidates without either experience or a degree? Do you just phone screen every single person who applies? That's a ton of valuable hours from your current devs devoted to interviewing people with a relatively low probability of being successful. You could HackerRank of course, but then other people won't like that, it's pretty easy to find answers online when writing the test at home, etc, in which case tons of people ace the HackerRank, and you're back to the previous problem...
Birth defect, microphthalmia. Used to wear a prosthesis, got tired of it (world’s most irritating contact lens).
IRC, they are already using it. It's just disabled by default, while for GCC it's enabled by default.
And say which version of libstdc++fs you're using (i.e. the GCC release it comes from). It's not very helpful just saying the Clang version when you're using GCC headers and libraries.
It depends on the field, but generally, yes. A degree with programming experience will get your foot in the door.
Not OP, but `#include &lt;filesystem&gt;` `int main()` `{` `for (const std::filesystem::directory_entry &amp;entry` `: std::filesystem::directory_iterator("test"))` `{` `}` `return 0;` `}` only GCC 9.1 (not 8.3) and MSVC can create executable, clang 8.0 can not. GCC 8.3 and clang 8.0 only compile, not link. [https://godbolt.org/z/GoKd1r](https://godbolt.org/z/GoKd1r)
What if you are writing an emulator and need to read a value from memory?
**Company**: [**Summitto**](https://summitto.com/) **Type**: Full time **Description**: Summitto is an award-winning startup building the largest invoice registration network of the world. The purpose? Helping EU tax authorities to **eliminate 50 billion EUR in annual invoicing fraud**. If you’re excited to build and design **open-source** software which will be used by **millions of companies**, we are looking for you! We're hiring junior ánd senior developers at the moment. Experience with cryptography is a plus, but not required! **Here’s a little taste of your challenges to help** [**stop vat fraud**](https://stopvatfraud.com)**:** * a distributed systems consensus algorithm * blockchain data structures * fraud identification algorithms * secure interfaces and integrations **Location**: Amsterdam **Remote**: No **Visa Sponsorship**: yes **Technologies**: C++11/14/17, Python. **Contact**: [**careers@summitto.com**](mailto:careers@summitto.com) questions are always welcome!
If you define a destructor, you really should be looking into all the other 4 special member functions.
Because you didn't use `-lstdc++fs` as required for the `std::filesystem` implementation in GCC 8.
My contra contra would be to get rid of all of that allocator rebinding business, let there just be a single canonical polymorphic_allocator (the one the paper calls polymorphic_allocator&lt;std::byte&gt;) and you're done. The main pain point of allocators in STL are the rebinding fact which is very unnecessary which the paper wants to fix. The fix is very reasonable, but it introduces friction because of all the cruft around allocators that already exist. Just remove the cruft for this new interface.
\&gt; Remote: Not for this particular role So what are the remote roles?
I'm not guessing, I built a lot of teams and hired a lot of people.
My eyes are kinda fucked up too, I've got an astigmatism and one is near sighted and the other far sighted, and ocassionally they don't wanna line up it makes me self conscious sometimes ngl.
You should start in several places at once. :-)
Relevant training does not always come in the form of "formal credentials", which was a degree (presumably from an accredited university) in the context of the discussion. AFAIK training is a mandatory part of being ISO certified (9001, 13485, 62304, etc), which is pretty much required for safety critical work. So if you like "formal credentials" can be extended to include this mandatory training. Our training program for anyone producing software includes things like coding standards and development processes and the leads will often defer to MISRA C/C++, JSF and other well-known and well-tested approaches.
That's literally what P0339 proposes.
For a second I thought this was the most radical Contra Points video yet.
Another example of byte order fallacy, still don't need to know, because your memory value is not based on the host system its just a collection of bytes le32 = (data[0]&lt;&lt;0) | (data[1]&lt;&lt;8) | (data[2]&lt;&lt;16) | (data[3]&lt;&lt;24);
If you have bytes then you can turn bytes into any integer you want big endian or little endian, in a platform independent way. le32 = (data[0]&lt;&lt;0) | (data[1]&lt;&lt;8) | (data[2]&lt;&lt;16) | (data[3]&lt;&lt;24); be32 = (data[3]&lt;&lt;0) | (data[2]&lt;&lt;8) | (data[1]&lt;&lt;16) | (data[0]&lt;&lt;24);
It sounds like you are trying to maximize the amount of portable, library code. I've been trying to minimize the amount of library code that users have to download/build/maintain. I'm not able to completely dodge portability warts with my approach. You will probably wind up with a lot of those imo.
With GCC 9 headers and libstdc++, clang 8 can't link the following code: #include &lt;filesystem&gt; int main() { std::filesystem::directory_iterator{}; } But only with `-Og`. Should this be reported on the GCC or clang bug tracker?
Does it make a difference to move `-lstdc++fs` to the end of the commandline?
They work fine with ELF and Mach-O binary formats. You can write a library using all of them in its public API and exported ABI without any trouble. The don't work on Windows with PE-COFF. It's too limited. If we want a standard ABI, or at least the possibility of using standard C++ language features in libraries, then Windows is the platform which needs to be fixed. Annoyingly, with WSL, they now include a native ELF loader, but which can't be used by Win32.
GCC's. I need to export another symbol from the shared lib.
It really depends on the role, and team. I'll add some links after I confirm with a couple teams I work with. Feel free to send me a direct message, and we can talk further.
Checked the comments for this
So have I. Prove me wrong!
I must partially disagree on Qt. Although it's probably the best option out there to build C++ multiplatform stuff, it doesn't have the "native look and feel" that OP is after.
It depends, like... Sure, Qt is close enough to the native UI of the system on Windows and Mac, but on mobile it fells VERY off. I think that using a c++ library to share code between a qt/gtk version, an android version and an ios version is a much better approach. I don't know how hard this would be on ios sincr I never developed for that platform, but passing data from C++ to java/kotlin and vice versa can be be a pain in the ass and even then I still think that it's absolutely worth it considering the amount of rewriting you can save.
&gt;The amount of time and effort we spend developing, maintaining, refreshing and tracking our training and compliance and associated documentation is substantial. Sure, no doubt a company involved into safety would care a lot about training. In the lands from where i am, a legal entity obliged to have a confirmation that their staff was actually subjected to formal training before even allowing anyone to do "safety-related" work. This is normal for anyone who works with dangerous materials. If what rubs you is "formality", think of it as of your driver license. Everyone knows how to drive a car, right? But before you are allowed to drive a car on public road you need to have a "formal credentials". No offence, but it doesn't matter what is your opinion on this topic, what matters is public security around someone pushing 300km/h under influence. In case of emergency it won't help if a team lead had explained to a driver how to drive a car and reviewed their driving skills. What would legally matter is if they had driver license and who had issued it.
It's not mocking degrees, it's pointing out that, if you are very self-motivated, you can learn all the same stuff on your own. And it's silly to say that you aren't going to get interviews. You will if you are experienced and good at it. The tech industry, or a lot of it, is very entrepreneurial. Many of these companies are not huge, and the people who founded them are often the kind of people that you say couldn't get a job. They aren't about to turn away really talented people. I only have a high school degree, but I promise you I wouldn't have any problems getting interviews. Doesn't mean that my particular experience is going to end up being what they need. That's always a possibility no matter what. But I wouldn't have any issues getting in the door, as long as any senior technical person in the company gets to see my resume.
For starters you think getting a job is luck. That isn't something someone would say if they were in charge of hiring decisions. You told someone who works for Nvidia and chairs two groups of the C++ standard that 'times change and it's hard to get a programming job without a degree'. I get that you are desperate to blame something other than yourself for not getting jobs, but don't give other people nonsense advice.
If Google or Facebook jumped off a bridge, would you do it too? (Only slightly /s.)
I concur wrt AW book - very good
&gt; IIRC, with par_unseq you can't even use mutexes for synchronizing access. Really? That's interesting. Care to elaborate?
As the other comments have said, as far as desktop goes, Qt gives the most consistent results. I'm not sure about iOS, but on Android, with Java, you can use JNI to run native code, to where you could reuse the C++ code. My personal favorite OSS project, [Dolphin Emulator](https://github.com/dolphin-emu/dolphin), is split up into a [C++ core](https://github.com/dolphin-emu/dolphin/tree/master/Source/Core/Core), a [Qt frontend](https://github.com/dolphin-emu/dolphin/tree/master/Source/Core/DolphinQt), and then the separate [Android frontend](https://github.com/dolphin-emu/dolphin/tree/master/Source/Android) which uses core. Additionally, things like the [https://github.com/dolphin-emu/dolphin/tree/master/Source/Core/VideoBackends](video backends) are shared between the frontends.
It's not nonsense advice, it's facts. You need a degree in today's market if you're trying to get by on merit without incredible difficulty. If you want an unusually rough ride, and you're the gambling type, then sure, try to start a career without a degree. I have seen people manage it but they often have more going for them than technical skills. I think you and others trying to gaslight me and my pessimistic bretheren are desperate to believe that you have a bright future ahead of you, and that you 100% deserve what you got, and that anyone who didn't get what they bargained for is a lame motherfucker rather than just unlucky and unconnected. In some way this is understandable, I mean we all have biases shaped by our experiences. I've witnessed a ton of unfair stuff out there and rough conditions in the job market, so I'm a serious cynic and pessimist. I will also add, I was not always pessimistic. I used to think you could never keep a good man down. But that is provably false. As far as me arguing against authority... I don't necessarily believe that any random Joe on the net is honest about their credentials. Even if I believed the dude 100%, his experience does not invalidate mine. I have been around, seen things, and reached my own conclusions over many years. I know engineers at Google, Nvidia, Oracle, and other respectable tech firms, and have worked with them. They're pretty talented but I don't look up to them particularly, and I never got any useful career advice from any of them. I'm done talking about this with you. If you don't think it's hard to get a job without a degree, try it! Make a fake identity, and a fake resume with no degree or cert whatsoever and no experience and see if it is in fact hard to get a regular programming job. Your results may vary depending on where you live, but I bet trying that will change your mind...
I miss Bo Qian's tutorials 😭
Developers from Dropbox have given several talks about doing this kind of architecture. Seems to work pretty well. Here is an example [https://www.youtube.com/watch?v=ssqhz\_1pPI4](https://www.youtube.com/watch?v=ssqhz_1pPI4) &amp;#x200B; I would recommend C++ for this is because it is the only high-level language that has first party vendor support across all the major platforms.
I can only speak for myself...YMMV. I ignore degrees &amp; certifications when interviewing candidates. I’ve interviewed too many people whose degrees &amp; certifications didn’t help them answer a simple question returning a pointer to a local variable. I look for things like: - Do you know how to use pointers? - Do you know the standard data structures and their pros &amp; cons? - Can you correctly analyze the time &amp; space complexity of an algorithm? - Do you ask questions to clarify requirements? - How do you handle it when you come up against the limits of your knowledge? - Do you know the risks of concurrency &amp; how to properly mitigate them? Do you know where your knowledge ends? - Do you understand the issues with floating point? Do you know where your knowledge ends? - When you can’t answer a question, do you _need_ to know the answer? - Do you have a grasp of both the theoretical &amp; the pragmatic? You may note that almost none of this is C++ specific. C++ knowledge will be a bonus. A thorough grounding in C++ will almost guarantee that you will know some of the stuff above. But if you nail all that stuff, I trust you’ll be able to learn the C++ you’ll need.
&gt; his experience does not invalidate mine Yes it does actually, since you are saying something is an absolute. I've seen entire industries that don't care. Maybe if you spent more time honing your skills and less time whining about how it isn't your fault you wouldn't have this problem. No one wants to hire someone full of excuses.
How does this compare to LZ4-1.9.1 [https://github.com/lz4/lz4/releases](https://github.com/lz4/lz4/releases), which gets a 12-18% decompression speed improvement? &amp;#x200B; The optimization in 1.9.1 [https://github.com/lz4/lz4/pull/645](https://github.com/lz4/lz4/pull/645) gets speed by widening LZ4\_wildCopy() to 32 bytes when possible, which targets the same speed win.
One Thing to consider is: How much business code is actually in your app? - Large parts of mobile applications are often in the GUI layer and all the related quirks to make that slim. Most parts of the actual business logic are on a server and what the app is doing is some form of validation and rendering, some caching and then taking changes back. Depending on the project having a common library can lead to more constraints, than benefits from reduced duplication. Mileage of course varies, independent implementation leads to risk of divergence and the project might grow to a level where there is too much duplication, but no sensible path for unification left. Still I think it's worth thinking about it.
I'm not full of excuses... I am just explaining the reality of things in general as I see it. I have seen enough for that determination to be meaningful. Getting hung up on the pedantry of whether my generalizing statement was absolute or not is dodging the issue... As a general and somewhat subjective view (what is "difficult"?), it admits exceptions and interpretations. The fact that you think you can learn more about a person's ability in 15 minutes than institutions dedicated to making that determination over a period of years says it all.
 &gt; I am just explaining the reality of things in general as I see it I know, but your reality is myopic and shaped by your own frustrations yet you won't admit to yourself that you don't have a handle on the programming market at large.
Hi 'just explaining the reality of things in general as I see it I know', im DAD.
For the record - [bug reported](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91067).
&gt; In addition, about a month ago, the original implementation accelerated decompression by the same 12-15% by copying 32 bytes instead of 16, as discussed above. We tried the 32-byte option ourselves and the results were not that great, but they were still faster.
If you can, don't make something that requires sharing memory between your threads. In case of OP's problem, I assume each image processing outputs to a different buffer, so there will be no issue at all. Only share data if you have no other option, especially for writeable data.
libc++ (Clang) and libstdc++ (GCC) will use a shared implementation with a configurable backend. TBB is the only backend implemented today, but we expect others in the future. For example, something GCD based for Mac.
&gt;I know, but your reality is myopic and shaped by your own frustrations yet you won't admit to yourself that you don't have a handle on the programming market at large. Oh, I have a good enough handle on the market all right. I've just seen more shit than you have apparently. I certainly wish things to be as you seem to think they are, but I don't believe it. It took years for me to realize that there is a lot of gaslighting, humblebragging, and general bullshit in this industry. &gt;Schools aren't judging a person's ability to create software, they give grades for passing their classes. Grades in computer science aren't judgements of programming ability. The vast majority of my CS classes required programming. Furthermore, if I did not know how to program, I could not have gotten a CS degree at my school. Most schools, especially accredited ones, are like that. So yes, a CS degree is a judgement of programming ability. Did I have a lot to learn after graduation? Yes. Did I learn a lot on the side while I was in school? Yes. But school absolutely did judge me on programming ability. If a run of the mill school like mine has such requirements, I imagine that most accredited universities are similar.
Yes, C++ is a reasonable language for it and the reason for that is because C++ is one of the languages that can call C directly. Moreover, most operating systems are written in C and expose their API in a C library that encapsulates the OS system calls. Mac OSX, Linux and Android are Unix-like operating systems with TPC/IP stack based on BSD sockets API, in addition they have a common POSIX C API which make things easier, however Windows has its own TCP/IP stack which is not fully compatible with BSD sockets API. Android uses a Linux Kernel too, but it uses a different C library based on BSD one and does not have XServer/X11 like most Linux distros. &amp;#x200B; \&gt; This should be as easy as possible for them, regardless of which language they use. That is not going to be so easy as a C++ library needs a C wrapper (extern "C") to be callable from other languages via foreign function interface FFI or native C API wrapper. But SWIG can generate binding code for many programming languages. &amp;#x200B; QT Framework already provides a common API for the graphical interface of many operating systems and also socket, database, data structures and file system libraries.
Not exactly CS degree, most of folks that design control systems and safety critical embedded systems have electronic engineering background.
You can do this pretty well with GDB. Although I don't know a way of doing it in an IDE
I am late in this party, but what sucks about C++ is the lack of standard tooling such as dependency manager and building systems. According to a Jetbrain's survey no C++ building system has more than 50% of the market share, not even GNU auto tools and CMake that is becoming the most popular one. So there are no standard way of managing dependencies, the most common approaches I have seen are: * Use the Linux's distribution package manager to install dependencies. * Download the library source, compile and install in the system which is common for lots of libraries with GNU auto tools. ./configure --prefix=path &amp;&amp; make &amp;&amp; make install * If the library uses CMake as build system, you can add copy the source to your project and edit the root CMakeLists.txt adding the line add\_subdirectory(./LibraryPath). However if the library is not packed with CMake, you are going to have hard time. * The approach with most sanity is to use CMake with a package manager that can download and build the sources. There are lots of them, but the most mature ones are Coanan and Vcpkg. Conan is the best deal because it is distributed, packages can be fetched from remote repositories, local cache and local network. TL;DR no standard way; no standard tools; no standard building system; very fragmented environment.
Is there any way to use it with some GUI library such as QT or GTK?
As someone who works on a C++ library shipping product to nine platforms, I would encourage you to implement MVC controller interfaces for all business logic, as a backend which the platform specific UI can call to as abstract as possible in terms of input devices. Spell out in advance how you as a team will version and deprecate interfaces. Keep a strong boundary of what is interface and what is internal code. Even if the front end teams have access to internal source code, they should not “reach inside” to make something easier. Make sure you document your interfaces in a way that is clear and builds a good SDK. Write tests at that interface level and consider those strong contracts you will provide for the front end to rely on. Leverage modern C++ algorithms and containers, let them use iterators and operators in a consistent way on items and groups.
Best I can do is quote cppreference.com: &gt; Unsequenced execution policies are the only case where function calls are unsequenced with respect to each other, meaning they can be interleaved. In all other situations in C++, they are indeterminately-sequenced (cannot interleave). Because of that, users are not allowed to allocate or deallocate memory, acquire mutexes, use non-lockfree std::atomic specializations, or, in general, perform any vectorization-unsafe operations when using these policies (vectorization-unsafe functions are the ones that synchronize-with another function, e.g. std::mutex::unlocksynchronizes-with the next std::mutex::lock) I'm not claiming to understand all this
Hey, I think they meant to reply to you, but [they replied to their own comment](https://www.reddit.com/r/cpp/comments/c7wnkd/c_jobs_q3_2019/esiv3cf/?context=10000) instead.
Welcome to the "home owner, married with two kids" of programming languages.
Probably, but it's nothing I've tried. I've used it for a webserver application at a client so far, which is completely different. If I were to need a Gui for it I'd probably go with an immediate mode one, like ImGui. Know that works well in these types of architectures.
I would say that it is an "implementation detail vocabulary type". Something like that: when you need allocation, and many apps need it, use this. But it is not a top-level, commonly user-facing vocabulary type. Anyway, it is useful and should be added. It is a unifying alternative worth the inclusion.
One alternative to explore is wxWidgets, an open source cross platform C++ GUI framework. It’s much more limited than Qt, but also totally open source and uses native controls for most platforms it supports.
This. ^^ Ignore all the posts that mention Qt; it's clearly not the right solution here.
Glad to see such a question :) Basically there 3 (stable) compilers you can try coroutine now. * MSVC: Visual Studio 2017(v141) 15.7.3 or later * AppleClang: 10.1 or later will be fine * Clang on Linux: recommend 6.0 or later The last one requires libc++ installation. I usually recommend to start with the MSVC since it supports the simplest way. You need to specify the compiler option like the image in the link. `/await` (and `/std:c++latest` is optional, but I also recommend you to set this flag) https://luncliff.github.io/posts/Exploring-MSVC-Coroutine.html#caution For clang family, you have to order the compiler to use libc++. Of course you can also specify c++ standard here like the following. https://github.com/luncliff/coroutine/blob/master/modules/darwin.cmake#L22 ``` -std=c++2a -stdlib=libc++ -fcoroutines-ts ``` If you want to try the feature on the fly, start with the this link to WandBox.org https://wandbox.org/permlink/6FGKZjuzjNYoSmI1 If you need more materials, please visit the MattPD's collection. https://gist.github.com/MattPD/9b55db49537a90545a90447392ad3aeb
For mobile you can try QtQuick2. I never used it on mobile but it is supposedly mobile friendly (not sure about native though). Using QtQuick2 would allow you to have an easy integration with a C++ (Qt) core library.
It is still a linker error: https://godbolt.org/z/xQx8rY There also people who manage to link, but the code crashes: https://stackoverflow.com/questions/56615841/passing-stdfilesystempath-to-a-function-segfaults
I admit I haven't played with qtquick that much, but from my experience even though it is indeed touch friendly it still doesn't feel anything like a native app. This would be totally ok for apps that are only going to be used internally or things like that, but that's about it for me. And also, let's not forget that qt on mobile would require a paid licence unless op is ok with open sourcing his app ~~(is the app store even compatible with LGPL?)~~. This probably isn't that big of a deal but still something to take into consideration.
Android does not support POSIX as official API, rather what ISO C and ISO C++ require. https://developer.android.com/ndk/guides/stable_apis
I've started reading Williams' book myself last week and I find it incredibly useful: well written, structured, with great examples.
This is [an Ubuntu bug](https://bugs.launchpad.net/ubuntu/+source/gcc-8/+bug/1824721), caused by them mixing GCC versions. It's not a bug in GCC, and it's not related to the OP's problem.
It is aimed at hardware with fewer instruction pointers than stack frames, like GPUs. In it, two tasks could deadlock if they both grab the same mutex, because tbeir instruction pointer locations are tied.
Big thanks for following up, especially the SO problem: I ran into people running into this, and so far the only recommendation was to upgrade to GCC 9.
Did you mean "the standard library" rather than "STL"? I'm not aware of anywhere the STL throws exceptions. Even if you do mean the standard library, it's an exaggeration to say it uses exceptions in most places when the STL is a huge counterexample. (Another is streams if you don't specifically ask for exceptions.)
`std::remove(string_that_needs_its_nulls_removed_for_a_c_api.begin(), string_that_needs_its_nulls_removed_for_a_c_api.end(), 0)`
Great article
null-terminated strings were a huge mistake...
This is the first time that I heard that the binary format poses a problem when wanting to write libraries (e.g. shared libraries) with STD types in the API. Could you elaborate why this is a problem? (Unrelated but the "traditional" WSL is actually being superseded now by "WSL 2", which is a very lightweight, containerized VM that starts transparently and in under a second. So, no more "native".)
I don't know. Other than Desktop/Server linux I rarely have to code against the real, native OS-API and more often than not there seem to be much better bindings for higher level languages. I would even go so far as to say, that the native c-compatibility is sometimes a hinderence, as many libs and interfaces may provide bindings for e.g. java or python, with an idiomatic interface, but c++ programmers are left to the c-Interface. I shudder when I think at using wint from ISO c++ before c++/WinRT came around.
Ahh now that I see it, my bad, it should have been the standard library, also I don't have any clear idea of which thing uses exceptions, which not. And it is easy to assume that something uses exceptions, instead of going through the documentation to look where it does and where it doesn't. TBH seems like I have phrased it entirely wrong, XD
To avoid being overwhelmed with errors, compile your project (or file) with \`-Wfatal-errors\`. This will cause the compiler to print a single error and stop compiling immediately, hence you are not overwhelmed by 100 error messages that possible have a single common cause. Note that this flag is only recognized by \`gcc\` and \`clang\`, I have no idea what is the VSC++ equivalent.
wxWidgets is to the best of my knowledge a desktop gui framework where porting to mobile phones is a work in progress. Thus it is not an option.
**Company:** [InstaLOD](https://instalod.com/) **Type:** Full-time **Description**: InstaLOD is a technology company that builds software that enables enterprise and entertainment companies to create magical 3D experiences. Our award-winning tech helps 3D artists working on massive productions to focus on the creative part instead of spending most time with tedious technical tasks. From military companies building next-generation simulations and data analysis to leading automotive and fashion brands such as NIO or Deckers and the biggest entertainment franchises created by gaming companies like 2K Games, Wargaming or Sony London: our technology plays a vital part in delivering their project. We're searching for **passionate C++ software developers** experienced with the **Qt and 3D frameworks**. We're not just looking for coworkers but for stakeholders and adventurers – driven people that want to make a difference through their work. Whether your passion is researching new algorithms, creating beautiful UIs or writing complex real-time shaders, you’re guaranteed to find something that keeps you motivated! **The kind of people we’re looking for:** * *Self-starter with a getting-things-done attitude*: You have a solid C++ background (4+ years) and you’re not scared of big code-bases and tricky tasks. Your work methods are well-structured and self-organized and you love moving tasks from the backlog to done. You also understand the project, and create tasks for epics that need to be worked on next. Effectivity when working is important to you, so you rely on software such as Slack, GIT, Sourcetree, Sublime, Trello and JIRA. * *You love to improve and always seek to learn*: You’re not only part of a team that’s just working on the code base. You’re part of a team that makes sure everybody’s skills and the quality of our code base continuously improves. * *Collaborative and Self-Aware*: You understand what’s necessary to create a collaborative engineering culture. You help build understanding and empathy within your team, and actively work to bring people into the conversation and understand their viewpoint. **Bonus Skills:** * You have shipped titles in the AAA games industry. * You have work experience at major companies or competitors in our space. * Familiar with 3D engine development. **Location**: Stuttgart, Germany **Remote**: Yes **Visa Sponsorship**: Yes **Technologies**: C++, Qt, QML, OpenGL, Vulkan, DirectX, GLSL, HLSL **Contact:** If you have any questions you can PM me, or send an up-to-date resume including sample code of previous work that you can share to [Michael@theabstract.co](mailto:Michael@theabstract.co) or you can visit our careers section and apply directly at [https://instalod.com/career/](https://instalod.com/career/)
It, as I understand it, comes down to what I wrote [above](https://www.reddit.com/r/cpp/comments/c84wa6/concurrency_where_should_i_start/eskri51/), code should work regardless of order, and therefor without syncing, TLS can help.
Just remove any allocator information from the type.
&gt; ... two tasks could deadlock if they both grab the same mutex ... Yes, I would agree with that, but isn't it more likely that it is because no memory barriers are applied, i.e. different cores see the [same] world (potentially) differently [un-synced], so a mutex can be grabbed twice.
We use ZMQ quite a bit too, but its future is unclear. There seemed to have been a falling out of sorts between the project's owner and a dev. The dev then went off and started a rival project (the name escapes me). Then ZMQ's owner unfortunately died a few years ago.
if you use c++ for less than 5 years, it may be surprising.
It was news to me.
If I recall correctly, this happens because type conversion has higher precedence over constructors.
&gt; The Art of Multiprocessor Programming ... No, these guys actually applied for software patents [and got them granted], so no.
Wow, I didn't know that, no one has taken the maintenance of the library yet?
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
I'm not sure what the state of it is. The rival project is nanomsg: [https://nanomsg.org/documentation.html](https://nanomsg.org/documentation.html)
It's always surprising, it just becomes less of a surprise that it is surprising.
How problematic would special casing string literals be?
Our business code is the biggest part. The UI will be only very few activities/views. Also a reason for this architecture is, that we want to ship the logic as an SDK to other applications.
And nanomsg was superceded by nng (same author): https://nanomsg.github.io/nng/
It wouldn't help for cases like `std::variant&lt;bool, BigNum&gt; v(1.23e45);` because that would still prefer the standard conversion from `double` to `bool` over the user-defined conversion from `double` to `BigNum`. So you could special case one type, but it doesn't solve the general problem. The post explains the fix that has already been applied to the spec, and implemented in GCC. It's not a special case for string literals.
Note that it seems that zmq still appears actively developped currently: https://github.com/zeromq/libzmq/graphs/contributors
Mhh, so maybe switching from ZMQ to NNG would be a good call. Does your company think about doing it?
Because they are multi billion dollar companies with incredibly extensive hiring processes. Not every company can or wants to afford that.
this is introductory shit wtf
I use \`std::is\_same\_v&lt;int, decltype(/\*whatever\*)&gt;\` in a static assert to see types.
Get real
I have to agree &amp;#x200B; I use the membervariable naming convention for patterns like: using index_t=std::size_t; struct Foo{ index_t index() const{return index_;}; private: index_t index_; }; So I would rather have autocomplete populate my `index*` variants.
Oh, god, please no. Not again.
Get real about what? You think a college degree matters to a company when they are looking at people who are going to have to have 10+ years of experience? For most it just isn't, because anything they might have learned in college will have been utterly dwarfed by what they've learned since then. It will be totally irrelevant in terms of what such a senior person will be expected to do. No one comes out of college and gets hired for those types of positions, because it requires long years of real work experience. I have 30 years of experience, a huge and publicly available body of work for anyone to examine, plus a very large commercial product that anyone can evaluate. Any company who would care whether I had a college degree is doing so purely out of dogma or to a CYA sort of thing because they are doing work for the government or some such thing. Most companies wouldn't care in the slightest, because my experience so far surpasses anything that a college degree would provide that it just doesn't matter.
&gt; 10+ years of experience How would you get any experience in the first place? You are not gonna get interviews at the entry level, the point where you need to break into the industry (as OP wants to). Without a college degree, you aren't gonna make it past ATS and recruiters, let alone getting a chance to explain yourself to engineers in the actual interview. Maybe things were different 30 years back when you started (so I've heard), and maybe that was a better way. Once you break into the industry and accrue few years of experience, it's somewhat smooth sailing from there. Thereon, college degree means little, to which I agree with you. But for someone wanting to break into this industry in today's day, they can forget about it without a college degree. Maybe data entry or QA, but not core development jobs, especially C++.
Well, it's called self learning and bootstrapping. I got my first job after spending a number of years teaching myself. It was a job doing tape backups. I used that time to teach myself even more. Then I got my first real development job at a small company that couldn't have cared less whether I had a degree. And the same will still be true of most smaller companies and startups, particularly in tech-heavy areas. They are very entrepreneurial and just want to get it done. When there's 25 people in a company, there's no buck passing and 10 layers of CYA management. Even at some place like Amazon, they have an automated evaluation test. If you can pass that, then you get a chance to prove your experience by moving to phone interviews and then on-site. If you have a degree, but you can't pass the automated test, you aren't going anywhere.
Sure. A good way of finding out about why sharing memory is problematic, and how to avoid doing it is to read a book on the subject! Concurrency is enormously complex, and "just throw &lt;fancy threading primitive&gt; at it" is going to end in tears if one doesn't have an understanding of the pitfalls and problems that one can run into, particularly if you're adding threading to an existing project where nobody thought about concurrency before.
Can't we just fix the language instead? I.e. prefer non-narrowing user-defined conversion over standard-defined narrowing conversion? &amp;#x200B; Such a change would of course require a deprecation period. &amp;#x200B; We could even go further with fixing similar problems and disallow all implicit bool conversions (except for contextual conversions, like if (ptr))
Starred on GitHub. Wonderful repo.
Just glossed over your NVI-article. There is a serious flaw in the example code: `process` is still `virtual`!
Once again, I am not disputing that you can learn without college - there's tons of resources for self-learning. I am telling you that you cannot break into the industry at entry level without a college degree. I am saying this from experience as someone who started in the industry few years back (as opposed to 30) and continues to interview and look around at small, mid, big ..all kinds of companies. YMMV.
This seems like the kind of thing that would be a no-brainer if the language were rewritten but will never happen because it would break old code in subtle ways.
ZeroMQ has been stable for a while. Works great for my projects. I'm a one trick pony and its my one trick. NanoMsg and likely NNG seems to have turn over / churn and low adoption. I suspect it is for a reason.
Lol, thanks a lot. I will fix that this evening.
There is always MQTT, which has a similar philosophy of design.
The language does not need to be rewritten, if we introduce such change in steps: 1) deprecate old behavior in C++ version N (i.e. force compilers to generate warnings for such cases) 2) let users get rid of deprecation warnings by forcing them to perform the casts explicitly 3) remove deprecated behavior from language in C++ version N+1 or N+2 &amp;#x200B; This way no code gets broken between each step, and what is more adding all these explicit casts could be automated e.g. with compiler fix-its or clang-tidy.
I don't follow your point. Are you objecting to me using the term "devirtualization" to also apply to converting indirect calls to (inlinable) direct calls? I typically use and see the term used kind of liberally (since virtual calls are, at their core, just indirect calls through a vtable - it all looks the same to the compiler) but if it's causing confusion I'll try to use more precise language in the future.
man, it's a shame nvidia gets so much shit for RTX considering they developed such a neat approach to rendering. and people are only just now realizing this??
Beautiful!
Dunno what unique hardware aspects Nvidia developed, but raytracing as a technique has been around before (now) traditional 3D rendering.
NVidia developed specialized hardware that's fast enough to enable real-time raytracing.
Cool project tho, but why use blocking IO for brand new lib vs libaio (i know recent but also, io\_uring) or using other async frameworks. &amp;#x200B; \`\`\`cpp auto \[response, status\] = client.Get("[https://github.com](https://github.com)"); \`\`\`
I think they have only gotten push back to the extent that ray tracing isn't going to be a big factor in game graphics for now, even with special hardware. Cone tracing voxel techniques add much more for the computational power. Ray tracing is likely to be more useful at accelerating certain effects and physics than being a workhorse of real-time rendering for now.
It's a waiter around libcurl. Does libcurl support async? That aside: I think there are enough arinc frameworks out there. On the client side, you sometimes really just want to have a quick and simple way of making an http request or downloading something.
Why would you label this a library when it is a libcurl wrapper?
wow impressive, i have to read all of that, thank you!
Yeah completely agreed. Seems great for some quick and dirty operations. Being a curl wrapper means the performance can never compete with native libraries anyways.
I'm well aware how to use those tools. I'm just pointing out that you can't just take a serial loop which may or may not share state across several iterations and put it into a parallel algorithm without puttung some thought into it.
Please submit links as links, not text posts.
https://www.youtube.com/premium
Thank you! I suppose this means they're not going to be made available elsewhere for direct download.
You can just google "youtube video download" and get a thousand websites that do just that.
It would be interesting to see the benchmarks across multiple architectures / CPU : https://max0x7ba.github.io/atomic_queue/html/benchmarks.html
To feel more proud.
math is cool :). simple raytracers are even cooler :)
It's not hard to download youtube movies. Just google it.
I'd prefer not to violate their TOS :)
I'm very new at C++. I tried compiling the code in Codeblocks, but my code stops because it can't read the "geometry.h" header file. Can somebody help me?
See [these pages](https://duckduckgo.com/?q=windows+dll+export+c%2B%2B+template+standard+library+types&amp;t=canonical&amp;ia=web) for starters.
It was only about a month ago that I was half joking with a friend about compilers eventually treating compile-time code more like runtime code and reaping benefits like debugging compile-time evaluation with a normal debugger, ability to run the optimizer on it, and even persisting optimized compile-time code for faster future compile-time evaluation on every compile. Little did I know work supporting that direction was already being done.
And fixed - thanks!
Haha, same, only I wasn't joking and actually expected this to be the future... but to a larger degree. e.g., complex templates could hypothetically do the same thing to give us much better TMP performance as well. The bytecode/interpreter approach also makes it a lot easier to reason about inputs and reproducable outputs, meaning results could be reliably cached and reused across TUs or build nodes for expensive cases. Couple that with WASI build modes and we hypothetically could start developing C++ projects with similar iteration speed to what we have with C# or the like.
I dunno if I agree with this conclusion. Real time raytracing has been possible for a long time, on both AMD and Nvidia. **But** the quality and fidelity has been lacking. Very simple *effects* and/or low frame rates. Some may interject with "but that was for simple scenes"; sure, but they were raytracing. I'm sure RTX helps, but the latest demo's I've seen is still quite far from what's ultimately possible with raytracing in terms of realism. Check out Octane Render or Redshift if you want to see what's possible when the real time requirement is taken away. Gotta give massive props to Nvidias marketing though. A lot of people seem to think you need an RTX card to have GPU raytracing.
Doing this for templates is pretty much not possible. This only works because constexpr is runtime C++. We never mess with the AST during evaluation.
You can download the ones up until CppCon 2017 from Channel 9: [https://channel9.msdn.com/Events/CPP/](https://channel9.msdn.com/Events/CPP/) &amp;#x200B; Unfortunately, Channel 9 will not be hosting CppCon videos after 2017. This is disappointing, but I appreciate the support they've given us which has allowed for downloading and also for reaching programmers in countries where YouTube is banned, such as China and Iran. &amp;#x200B; I'd love to find a host that would allow us to reach counties where YouTube is banned, but we've not yet identified an appropriate host.
Title is misleading. It's about using constant multibyte character literals, not about using multicharacter constants.
You don't submit link post titles in Markdown format (i.e., this leads to a 404 when you click on it).
Can NOT confirm, using without problem on a much less powerful machine (both win 10 and Linux, with Linux minwg linker work soooooo much faster, we talk from minute to tens of seconds)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/qt5] [Qt Quick (QML) seems to suit my needs perfectly. What downsides does it have compared to QT Widgets?](https://www.reddit.com/r/Qt5/comments/c8ul5j/qt_quick_qml_seems_to_suit_my_needs_perfectly/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Is this the first step to making the compiler a complete virtual machine to run arbitrary code in? That's the eventual state of C++, IMHO
It's funny, people's first reaction to compile-time networking, file I/O, and other things is that it doesn't make sense. Then thinking about it more, all of them are doable to get the compiler to execute on the host system during compilation. One big problem with pretty much all of these things, though, is that working out dependencies becomes basically impossible. A file might need to be recompiled because of new network data, but a build system would never know that out of the box. One other big thing for people is that executing arbitrary code on your machine just by compiling a program is considered very scary.
Not yet as ZMQ works fine for our needs but it's definite tely on our minds.
&gt; To me, creating 100 threads should be a no-brainer, especially if one limits the stack size appropriately. I’m used to be able to create thousands of threads without concern. As I said, I’ve been spoiled. If your system falls over at a mere 200 threads I consider it a toy implementation of threading. Unfortunately most of the mainstream operating systems are therefore toy implementations Ugh, This doesn't inspire confidence in nng which seems to be nothing more than a port to Go?
I am aware of these issues but none of the first five hits mentions anything about PE-COFF or gives any idea what it has to do with binary formats PE-COFF/ELF/Mach-O.
Checkout the tinyrenderer series also, well worth the read.
Thank you for answering! I love cppcon videos so it's a shame Channel 9 isn't carrying them anymore; youtube-links to my favorites will have to do :)
It's a different ui framework (you can combine widgets and qml but probably you shouldn't). it has different controls available out of the box . QML is targeted towards the smartphone, apps do not have a native UI feel to them. QML apps can have styles ( [material, universal, etc.](https://doc.qt.io/qt-5/qtquickcontrols2-styles.html) ) but none of them look like they belong on the desktop. To interact with a QML control from C++ there is a bit of a song and dance that one has to perform. Nothing too complicated but is not as straightforward as QtWidgets. Other than that ... no downsides really. And even those are only downsides for certain developers/apps/audiences. One can certainly develop a QML app instead of a widgets one.
I honestly just don't believe that, at all, in the general context. :) Perhaps it's practically infeasible _in Clang_ (and most other extent C++ compiler architectures) but that's not what I'm talking about. `constexpr` will soon be growing features to consume and manipulate types, which turns out to basically be what (class) templates do, so much of the mechanism is going to have to be there _anyway_ before too long. If a constexpr interpreter is possible, the machinery necessary for "interpreting" templates is not going to be all that far behind. Aside from that, the concept of what a template does is just a program: it consumes inputs (template parameters) and produces outputs (instantiations). There is not any reason in the entire world to think that can't be executed via an interpreter, albeit one that would be crafted to handle the intricacies of the C++ type models rather than traditional value types. Again, that might be a very difficult and improbable transition for Clang to make, but that has no bearing on some other future C++ compiler treating templates as programs rather than as semantic trees.
btw: r/EntityComponentSystem/
Oof
&gt; One other big thing for people is that executing arbitrary code on your machine just by compiling a program is considered very scary. You can probably already do that today with every C++ compiler.
Instantiating a template requires most of phase 7 of C++. Sure you could turn (or duplicate) your entire frontend after parsing into an interpreter, but that's still not going to buy you much. You're not saving anything as you can't do type specialization, as you only have one "type" (which represents all possible C++ types). You'll just end up doing the exact same work, just driven by an interpreter. I don't really see how an interpreter would help here. Also, the constexpr interpreter won't need to do any of this to support any of the upcoming reflection proposals. It just needs to be able to call into the compiler's existing machinery to manipulate types. Reification of types happens outside of constant evaluation.
Would be nice if they recorded the slides more instead of just following the speaker
https://godbolt.org/z/KEilEU ``` int x = 'G\x48\x49\x4A'; int y = 'JIGH'; ``` Confirmed. MSVC, child, what are you doing? `JIHG` wouldn't be too surprising, maybe, possibly. `JIGH`, though — that's the craziest f#?king thing I've ever heard!
It's newer, and doesn't support the same widgets as QtWidgets. Until recently there were no QML controls suitable for building desktop applications. The documentation has been improving but it can still be hard to figure out how to do stuff that needs to be exposed across the language gap.
&gt; Until recently there were no QML controls suitable for building desktop applications. Are the controls suitable now? And for when I want to build stuff, is the styling more flexible &amp; efficient to render than widgets?
libcurl does support async (curl_multi_*).
The C standard (and C++) essentially say multicharacter literals are allowed, and will be an `int`. Other than that they could be anything. Don't use em.
It's been a while, but yes I think they are better now. And styling should be easier than with Widgets (although I've never really done styling with Qt).
IMO one big usecase for networking at compile time is ORM. You could connect to a database and ask it for it's schema, using that to generate various classes. FWIW rust pretty much lets you do this because of how their proc macros work.
moreover you are presumably going to be executing the code you're compiling at some point :D.
Sorry but the "for humans" bit is just really smarmy. All libraries are intended for humans obviously so by putting this in your title you're basically implicitly putting down libcurl or other such libraries that apparently are so bad that they're not for humans motivating you to write this. The modern c++17 bit is factual and already attractive enough for many of us!
I'd assume it's inspired by the python requests library which labels itself "http for humans" (https://2.python-requests.org/en/master/).
What's "the mmap trick", and is it portable?
it's not c++, less portable, no native style.
What exactly is the use for this tool?
Good to know where it comes from, but still not great to copy a bad idea.
Using memory mapping APIs to map the same physical memory at two different virtual addresses, such that a change to one memory window will be reflected in the other. This allows contiguous virtual addressing while wrapping from the end to the beginning of the memory block. It's also used by JIT engines for W^X restrictions on some systems, where a different address window is needed for writing code than executing it. AFAIK this is generally supported on mainstream OSes and CPUs, though the block size differs since it is dependent upon address space alignment requirements, not page size. This is 64K on Windows and 16K on some other platforms despite a 4K physical page size. This trick also has potential implications for the optimizer, since it means that x[i] and x[i+j] aren't guaranteed to be different objects for j != 0.
I'll be honest, I still don't believe it - it sounds like you're taking more about Clang specifics and their limits than anything actually imposed by the standard's semantics, though I'm not sure I follow the bit about requiring most of Phase 7 for instantiation (instantiation occurs separately and "cleanly" in Phase 8, and it was only MSC non-two-phase compat that muddled that, no?). You're also clearly more the expert in this area than I by a long shot, so I accept that my disbelief may very well be in heinous error. :)
&gt; it's not c++ Even though we're in the C++ subreddit, I see that as an advantage. C++ is not a good language to describe user interfaces. QML's declarative approach is much more useful for that. &gt; less portable Then what? Portable in what sense? &gt; No native style. Agreed. Also, its performance can be suboptimal in some cases.
In addition to what others have stated: * Support for a lot more architectures. Rust supports a lot, but C++ still wins in this area. * Huge community support. * Lots of tooling support. * Ease of integrating existing C and C++ libraries. * Wider pool of people to work on the codebase.
How is `curl` not a native library?
CPR library claims to the same. I am using it for a project, it's been pretty good. Could use less dependencies though, and a default installation target in the CMakeLists.txt would be wonderful, but overall very good: [https://github.com/whoshuu/cpr](https://github.com/whoshuu/cpr)
less portable than QtWidget, since use of opengl
So helpful
Thank you :) we will try to follow that. Do you have more points that we should pay special attention to or that you consider to be mistakes that you would make differently now?
We would like to provide almost all our functionality as SDK in other applications for Integration. It should be as easy as possible for the others to integrate us.
&gt;HaXe Sounds really interesting and may try it out on a small, private project, we want to avoid dependencies as much as possible, we have crashed with a framework in the past. The fear it is going to be discontinued is too high.
Ahh Dolphin emulator, used that as a kid :D. &amp;#x200B; Did you expirienced points that we should pay special attention to or that you consider to be mistakes that you would make differently now?
We will do the UI at first native, mayber switch later to flutter and integrate our library. Direct C/C++ calls are at least on Googles Roadmap ( [https://github.com/flutter/flutter/wiki/Roadmap#ecosystem](https://github.com/flutter/flutter/wiki/Roadmap#ecosystem) )
Isn't a code generator more suited for this kind of work? I mean, if you want to run arbitrary code at build time, why not just put that code into a different program entirely?
Thanks for the many replies. At the moment C++ is our favourite (only Rust is still in the race). Do you have any points that we should look at carefully? Or mistakes you made in your implementations that we should avoid?
&gt; QML apps can have styles ( material, universal, etc. ) but none of them look like they belong on the desktop. There are two desktop styles : - https://doc.qt.io/qt-5/qtquickcontrols2-fusion.html - https://github.com/KDE/qqc2-desktop-style the second is very very close of the "widgets" looks.
it has a software renderer which works on friggin microcontrollers (https://doc.qt.io/qt-5/qtquick-visualcanvas-adaptations-software.html#)
&gt; mmap trick Um. And then I want to do some I/O with the ringbuffer which happens to span the mirror boundary. What happens next is, um, well, dunno. As long as the kernel _copies_ the data between its buffers and the process's buffers it should work. If you arrange direct DMA... heh.
I think it is much more reasonable to just make it ambiguous and let the user pick the desired type explicitly instead of replacing one fragile rule (which leads to the desired result 90% of the time) with a slightly better fragile rule (which leads to the desired result 95%) of the time. Now, if we actually were to break the language (which is not going to happen) I'd be all in favor of a) giving string litterals their own type and upgrading arrays to behave just like std::array without any "decaying".
Use your words
Honestly I wouldn't say QML is targeted to smartphone, maybe to fluid (and touch) interface. Anyway with the QtQuick Controls 1/2 is more than adequate for desktop.
It's a pain to do on Windows.
You're not familiar with page mapping, are you?
Disappointing that there wasn't a benchmark comparison to dvyukov's bounded MPMC queue since that's probably the closest in class of atomic queues.
This looks interesting, are you planning to add other data structures? E.g. a sorted map?
The value is implementation-defined, so it's legal. And those who use such constructs in their code should suffer anyway, so it's fair.
&gt; I'm just pointing out that you can't just take a serial loop which may or may not share state across several iterations and put it into a parallel algorithm without puttung some thought into it. I'll generalize that for you: "You cannot write C++-code without putting thought into it".
My own use-case was for a simple non-blocking TLS terminator inside a larger C++ application, i.e. I had a TLS socket and a normal socket and was copying data into the buffer using `SSL_read()` when the TLS socket was ready for reading, and then from the buffer using `send()` when the regular socket was ready for writing. (plus a second ringbuffer for the reverse direction) I initially tried making it work with `boost::circular_buffer&lt;char&gt;`, but the API mismatch is just too big: When inserting into it, one needs another temporary array because `insert()` wants to be given a range, and when getting data out of the buffer one needs to mess around with `array_one()`/`array_two()` or `linearize()`, and as far as I can tell afterwards it would require one call to `pop_front()` for every byte written. I looked around for existing ringbuffer implementations using the mmap trick but only found C libraries, so I decided to write my own.
You may want to try Kirigami, it's a QML framework https://kde.org/products/kirigami/
Not everything works in the software renderer though.
is coroutine ready for production use?
Just do learncpp.com it contains stuff from c and c++ (mostly). Then just read through C++ primer. You will be well be well versed with the modern stuff of c++ and how stuff kinda works in C.
This post was crossposted to /r/Qt5 and I wrote the same comment there... I've previously written a blog post covering the main differences (as far as I know) between Quick and Widgets which you can find here [https://www.cleanqt.io/blog/crash-course-in-qt-for-c%2B%2B-developers,-part-6](https://www.cleanqt.io/blog/crash-course-in-qt-for-c%2B%2B-developers,-part-6) . Sorry for the shameless plug, but you mind find it useful!
Because of trying to get adjacent addresses? It's been simplified in Windows 10, you can now reserve a block of address space for subsequent map calls.
Learning embeddeed system such as microcontroller is more than learning C or C++. Because while programming MCU your goal is to utilize hardware peripherals as much as possible, this requires good knowledge of architecture you are targeting. &amp;#x200B; While using higher abstraction libraries like arduino's is a good thing for productivity, I don't think it is a good thing for learning microcontrollers in general. &amp;#x200B; If your goal is to become Embedded Engineer I would start with C.
Why did you decide to write for(auto&amp;&amp; x : y) I’m interested in this “pattern” for work and so far the conclusion has been that it is probably harmful. It has been called “confuscation” https://stackoverflow.com/questions/13130708/what-is-the-advantage-of-using-forwarding-references-in-range-based-for-loops/13130795#comment17857496_13130795 so I’m curious if there is an actual valid use case here or if it is just to be hipster.
Great content, but your website is really freaking annoying on mobile (it scrolls left and right for no discernible reason).
As the post mentions, it is more "consistent" in some regards because it always works, but you lose the opportunity to put a `const` there. So you have to choose whether you want to be consistent with your `const` placement or your range-for loops. Either way, chasing absolute consistency in C++ is a fool's errand.
Sure, but the initial post that started the whole discussion sounded (to me) as if you'd advertise the parallel algorithms (in particular the parallel version of `std::for_each`) as a means to do just that. And especially with the recommended `std::execution::par_unseq` policy you have to be very careful about what you are doing inside the body (To quote cppreference.com: "users are **not allowed to allocate or deallocate memory**, acquire mutexes, [...]" ). With `std::execution::par`, at least the intuition for execution on a "normal thread pool" applies.
Thanks for the hint, I will see what I can do about that.
Do you already know any programming language? If not, it doesn't really matter, learning programming comes first, then you can worry about individual programming languages (you'll need to learn some sort of programming language for that but it doesn't matter which really). C is simple enough that learning it won't be a big problem once you're an OK programmer regardless of what you learnt previously. C++ is more complicated, but it's still OK as long as you stick to the basics. In any case, most programming languages are fairly easy to learn (even with something as notorious as C++ you can get like 90% of the way with fairly little effort), so I wouldn't get too hung up on that.
C and C++ are different languages, albeit related to each other. Arduino is actually a C++ environment as well.
Do you rate primer over PPP? I’m going through the PPP book at the minute, it’s both great and annoying, like the header file you have to include for one, why not just use the actual headers we’re going to need for each example, sometimes i find it’s not overly clear but maybe i’m just not understanding it properly
 void test() { // page size is 4096 on my machine // bev::linear_ringbuffer f{4096 * 1}; // fails on my machine for some reason bev::linear_ringbuffer f{4096 * 2}; std::fill_n(f.end(), f.free_size(), 'x'); f.commit(f.free_size()); f.consume(1); std::cout &lt;&lt; f.end() - f.begin() &lt;&lt; std::endl; // -1 for (auto c : f) { std::cout &lt;&lt; c; // segmentation fault } std::cout &lt;&lt; std::endl; if (f.size() &gt; 0) { std::cout &lt;&lt; *(f.end() - 1); // segmentation fault } std::cout &lt;&lt; std::endl; *f.end() = 'y'; f.commit(1); // works as intended but undefined behaviour: reading uninitialized variable std::cout &lt;&lt; f.begin()[f.size() - 1]; std::cout &lt;&lt; std::endl; }
 void test() { // page size is 4096 on my machine // bev::linear_ringbuffer f{4096 * 1}; // fails on my machine for some reason bev::linear_ringbuffer f{4096 * 2}; std::fill_n(f.end(), f.free_size(), 'x'); f.commit(f.free_size()); f.consume(1); std::cout &lt;&lt; f.end() - f.begin() &lt;&lt; std::endl; // -1 for (auto c : f) { std::cout &lt;&lt; c; // segmentation fault } std::cout &lt;&lt; std::endl; if (f.size() &gt; 0) { std::cout &lt;&lt; *(f.end() - 1); // segmentation fault } std::cout &lt;&lt; std::endl; *f.end() = 'y'; f.commit(1); // works as intended but undefined behaviour: reading uninitialized variable std::cout &lt;&lt; f.begin()[f.size() - 1]; std::cout &lt;&lt; std::endl; }
TLDR: Use an interface library. Nice that the install part is also covered.
\*\*Company:\*\* \[Quick Base (formerly Intuit) \]([https://www.quickbase.com](https://www.quickbase.com)) \*\*Type:\*\* Full time \*\*Description:\*\* Our core engine is pretty much an proprietary in-memory db engine written in C++. We help folks who may not know coding and relational theory to build apps to automate their business process. We have a lot of opportunities for a C++/engineers to mentor and collaborate in order to scale and modernize our core engine. Lot of exciting projects in the pipeline for example, improve evaluation of our formula language, speed up of imports of large data, fix critical security issues, improve tool chains (whatever your interests could be). \*\*Location:\*\* Cambridge,MA and Salt Lake city are our headquarters. But we have engineers working from all across the country. \*\*Remote:\*\* Yes. NO restrictions on timezones. \*\*Visa Sponsorship:\*\* Yes \[Does your company sponsor visas?\] \*\*Technologies:\*\* C++11 +. Windows. \*\*Contact:\*\* reddit PM.
Modern C++ and C should be studied as completely different languages. Even though they have a huge overlap, they require a different mindset. Example: in C, `malloc` is the normal, default, vanilla, usual etc. way to allocate memory. That's how it's done. In C++, `malloc` allocates memory the same, but it's certainly a [WTF](https://i2.wp.com/commadot.com/wp-content/uploads/2009/02/wtf.png?resize=550%2C433) in almost all situations. In modern C++, even `new` is a code smell. There are many aspects like that, in language construct, library functions or conceptional where the C way and the C++ way are different. Not all of them are as clear cut a above example - but as a whole, you are not doing yourself a favor.
Neat. Wasn't aware that they added an API for that. They always had an API call to perform physical page mapping, but it required administrator access.
Both are excellent, PPP is a little more up to date.
Hm, good point: it's true that `[begin(), end()]` is not necessarily a valid range, probably they should be renamed to `read_head()` and `write_head()` and begin/end should adjust the pointers such that always begin &lt; end. On the other hand, `bev::linear_ringbuffer f{4096 * 1}` certainly should work, it's one of the unit tests actually. Maybe you can post an issue? I'm not completely sure why you think the last one should be undefined behaviour?
fopen is not STL
Is ppp by bjarne starstroup? It has a pretty big jump in chapter 6 where he starts the calculator classm I couldn't understand what was happening.
C+99 maybe, but no. If you want to learn modern C++ learn it. If you want to learn C, just learn C instead. Learning either or will help you with the other but learning C will help you better understand fundamentals that drive modern C++. Learning modern (by modern I mean, C++14 or higher) will not help as much with learning C. Think of it as a layered foundation. At the very bottom, is the architecture, from there you have high level languages like C that help write code for that architecture. Because of this, a lot of concepts in C mimic computer architecture. C++ was to take C and try to make it a more modern language, with C++99 I think it's ok to think of it as basically C with classes. C++11 was the beginning of the end of that era imho, and now C++17 (? forget how high it gets now) you have C++ attempting to evovle into higher level languages in terms of feature sets, like Python but their still rooted in C. So you can learn C++ and leverage high level concepts but to understand why/how those work and have any sort of appreciation for the syntax instead of just hating it (which is absolutely fair) then you would likely need to understand it's roots, which is C and further, the architecture.
There are a few topics in CS that are hard. I call them hard because people learning CS are fine with bunches.of stuff, then fall over and fail with this new subtopic. They are things like "scope", "loops", "functions", "conditions", "mutability", "lifetime", "pointers/indirection", "objects/inheritance", "purity". By this point you probably get most of these. But I suspect you'll remember or know people who just didn't get it at one point. Concurrency is another one. Worse, most of our languages (imcludong C++) where not designed with concurrency in mind. So what we have is some decent libraries (like TBB) and some retrofitted low level.primitives (std). TBB will make solving the limited set of things it was designed to make easy, easy. So if you are doing on-CPU image processing, or similar separable grid/array tasks, booya. Want to do something like process changes asynchronously from input? It won't help much. You'll first have to (re)design the entire application with that in mind. Patching it is possible, but then everything is dangerous because standard concurrency techniques to make single thread correct code run concurrently (mutexes guarding data, say) don't compose; locally "correct" code can interact with other locally "correct" code and generate deadlocks or UB. All of those "just write this framework" are attempting to provide an application that isn't songle-threaded-with-patches. You cannot, outside of really narrow cases, patch a single threaded design and add in concurrency using std/tbb. Those narrow cases basically involve taking some pure data processing task (like, "flood fill this bitmap") and throw extra threads at it. So if you want that, then TBB/STD is useful. And there are plenty of tutorials, even in the TBB docs. But it fundamentally won't scale.
Check the blog archive - two posts from December last: [https://quuxplusone.github.io/blog/2018/12/15/autorefref-always-works/](https://quuxplusone.github.io/blog/2018/12/15/autorefref-always-works/)[https://quuxplusone.github.io/blog/2018/12/27/autorefref-still-always-works/](https://quuxplusone.github.io/blog/2018/12/27/autorefref-still-always-works/)
Familiarity. Back then the only things re: DOS C++ development that I was familiar with were Borland C++ and DJGPP. And I wasn’t sure how to install DJGPP, considering that DOSBox does not have long filename support which c++ really requires.
Excellent work.
I guess you hit on my point there - designing code / applications from the start in the way you're talking about, rather than trying to slap TBB or similar in somewhere later. The analogy before to design patterns was more that for general code design, there are some building blocks (but which you don't want to force either!), and plenty of general advice about eg interface design, ownership, coding to avoid mistakes. Where's the same level and tone for concurrency? It'd be like starting an answer to the question in my analogy with "You want to get some advice on how to tackle code design? Great, let's start with operators!" :D
There are new MEM_RESERVE_PLACEHOLDER / MEM_REPLACE_PLACEHOLDER flags for VirtualAlloc2. But available only since RS4/1803/17134 build.
They have improved vastly over the last few versions, so with Qt 5.12, there's not much missing anymore. Still, there are some shortcomings: - The list control is not very flexible, and the dependency on the Flickable base type sometimes creates headaches. It's already a candidate for a reimplementation, as is the ScrollView, so expect some improvements in the mid-term. - OS-specific stuff is mostly unavailable, like MacOS menu and dock integration. You still need to use QWidgets for that. - Passing data between C++ and QML is okay, but requires some practice and isn't well documented.
[https://stackoverflow.com/q/35852493](https://stackoverflow.com/q/35852493)
Interoperability with redux when compiled as WebAssembly would be awesome.
Do you already know C and have a good grasp programming with pointers? If not, then I highly suggest at some point that you study C. But—as others have said—when it comes to learning C++, it is best to not think of it as an improved version of C. C++ programming is its own style.
&gt; It's also used by JIT engines for W\^X restrictions on some systems, where a different address window is needed for writing code than executing it. that seems like hardcore abuse of W\^X terminology if you're leaving persistent write access through a different page. if an attacker gets hold of a pointer in that page...
I do C++ professionally but have done a number of arduino projects too. My advice is to go for C right away. As others have pointed out, it's very different from modern C++ and you won't need C++ at all. C all the way. HTH, Moose
&gt; "A pointer to b" is not the same as "a pointer to T", both might share the same address They _will_ share the same address, that's the definition of pointer interconvertible.
Reusing fixed size buffers without complex arithmetic to figure out if you are near the end and if so to do other stuff.
I'm an embedded software developer who used to use C and now primarily works with C++. Learning C is relatively easier when you start off and gives you a better appreciation of memory handling and it's complexities than C++ does in my opinion. The C knowledge will also transfer well to C++. C++ is definitely a much more powerful language and you can get your tasks done quicker with it. There are a lot of things to learn in C++, but you can get them with time. A lot of embedded processors, particularly the ARM based ones, support C++ as well, so that is not a problem Like someone else mentioned though, embedded development relies on a good knowledge of programming as well as a good understanding of computer architecture. Here's a nice book I've read which is useful for new embedded developers - Making Embedded Systems: Design Patterns for Great Software https://www.amazon.com/dp/1449302149/ref=cm_sw_r_cp_apa_i_MuFhDb1WWXK3W
&gt; "users are not allowed to allocate or deallocate memory, acquire mutexes, [...]" The problem is that you make it sound like 'rocket-science', while in reality is does not have to be so hard and given the right design it just works.
I recommend you watching youtube video from cpp confetence. Kate Gregory (which has some great pluralsight courses on cpp) presents her attitude towards teaching C++ in context of C. https://m.youtube.com/watch?v=YnWhqhNdYyk
Now I want to invoke the compiler at compile time, so C++ could bootstrap itself without any build systems.
Interesting, but I completely disagree haha. In a context where you do not know the type (templated container) it makes sense, but when you want to iterate over a vector you are using const auto&amp; to signal that you will not change the elements and auto&amp; to signal you will modify the elements and auto to signal you want a copy. When using auto&amp;&amp; you are not signaling anything but confusion.
STL is a maintainer of MSVC's implementation of the C++ Standard Library.
As others state they are fundamentally different languages that have some common syntax. If the goal is to learn C++, start by studying C++.
And we are always grateful for all the effort put in.
&gt; The problem is that you make it sound like 'rocket-science' Not sure, why you got that impression, but can we at least agree on that you can't just take random sequential loop code an put it into a parallel for_each, let alone a par_unseq one? In fact, if we can't agree it probably doesn't matter anyway. I just wanted to put an asterisk/warning sign under your comment and I did.
I don't know the answer either but I think this page will help you more than somebody telling you which function to use: http://www.informit.com/articles/article.aspx?p=1881386&amp;seqNum=2
STL is subset of standard library containing templates. Superset includes "C standard library" too.
Holy smokes you've been busy! Your docs are awesome.
By now I have to say: I really don't care about the difference, and I have yet to have a discussion, where using the term STL incorrectly leads to any misunderstanding.
Regarding the SO link: this was written in 2012, when rvalue references were a new thing and `auto&amp;&amp;` was weird and mysterious. I'd argue that 7 years later, `for (auto&amp;&amp;...` is the widely-recognised way of saying "just grab things from `y`, I don't care what they are" -- just as Howard presciently predicted in his comment. In other words, `for (auto&amp;&amp;...` *is* the simple way of doing it these days. (Indeed, I seem to recall that /u/STL had a proposal that you'd be able to omit the type and just say `for (elem : range)`, which would mean exactly `for (auto&amp;&amp; elem : range)`. IIRC it was rejected because it was felt that it wasn't sufficiently obvious that a new variable was being declared.)
It's still consistent: if you need to modify the elements of the range, use `auto&amp;&amp;`. If you don't, use `const auto&amp;`. For C++, that's actually pretty simple.
&gt; ... but can we at least agree ... Yes, we can, but no reason to create another 'never do this'-meme [particularly on new stuff], we have enough of those already and it's not helpful.
I share your astonishment. What struck me before, is that many of the higher-level ways of working with concurrency and (both task- and data-) parallelism are underrepresented in literature. More specifically, I am aware of the following things that no book I've seen (not for C++ nor concurrency-centric books in other contexts) talks about: - the Actor Model - Software Transactional Memory - Optimistic locking They are really worthwhile to investigate. All three are very different, but all three are powerful, higher-level abstractions of concurrency and parallelism that allow you to tackle your problem at hand in a way that is less prone to race-conditions and deadlocks.
Which one would you say is easier to read/understand?
I would also suggest passing into this library via dependency injection any platform specific functions (e.g. networking, filesystem access), so that it can remain as platform independent as possible.
Yay, this again. Look, the original HP Standard Template Library is a quarter of a century old now, and literally nobody is using it for anything other than legacy code these days. Can we all just agree that in 2019, "STL" means "**ST**andard **L**ibrary"(*) and just move on with our lives? The pedants who turn up to "correct" people who use the term "STL" are even worse than the ones who tell you that "there's no such language as C/C++"... *: When it doesn't mean Stephan T. Lavevej of course
This should be in /r/cpp_questions Look into using &lt;chrono&gt;
Yeah it is, i’m going through it now but not as far as that yet, i’m going to re-read the last 2 chapters as i’m still a little hazy with some things, one of my gripes with the book is that he gives drills at the end of each chapter but no example of that drill being done in its entirety so you can do the drill as you see fit but there’s no way to find out if you interpreted it correctly and done it the best way as there’s no example for you to check yours against, bit annoying really, i may buy primer and compare the two and see which suits me best
For questions there's r/cpp_questions. By the way, I would simply use division/modulo and calculate the data I need. Let's make a smaller example. - time is measured in seconds - epoch is 00:00:00 of today Let's say we have these data: - 86,400 - 15,300 - 79,073 - 262,800 Now, we need to convert it into the `dd hh:mm:ss` format. We first set the constants used for calculations: minute = 60 hour = 60*minute day = 24*hour Calculate data: dd = data / day; hh = (data % day) / hour mm = (data % day % hour) / minutes ss = data % day % hour % minutes With data = 86,400 1 00:00:00 (1 day since epoch) With data = 15,300 0 04:15:00 (4 hours and 15 min since epoch) With data = 79,073 0 21:57:53 (21 hours, 57 min, 53 sec since epoch) With data = 262,800 3 01:00:00 (3 days and 1 hour since epoch) This can be extended to any precision, milliseconds, nanoseconds, days, hours etc. For instance, you want to calculate from milliseconds to years? You'll need these: 1. Milliseconds 2. Seconds 3. Minutes 3. Hours 4. Days 5. Months 6. Years It's really simple. To make it efficient, as you can clearly see, you might want to save the partial modulo calculations.
The STL is now part of the standard library, but it can still be used to refer to the design of containers/iterators/algorithms. This split allowed generic algorithms to be written to operate on any container that provided the correct type of iterators. Ranges provide a continued abstraction on this idea, but with some added flexibility and ease of use.
STL is the standard template library. Hardly anyone uses it anymore but you can still get it via STLPort. The standard library is the standard library. It comes with most C++ compilers (not ones like avr-gcc). It includes some standardized components taken from the STL. Generally when someone says STL today they mean those parts of the standard library that come from that project. They are different from the STL itself because they've been standardized (STL is "just" a library). Then you have the occasional butt-plug that has to correct everyone for using the term in really the only way that's relevant today: to refer to those aspects of the standard library. They are technically correct but I still want to punch one in the face.
To be fair I still pedantically tell people "there's no such language as C/C++ ". Most of the time when people have a question about C/C++ it is because they understand neither of those two languages.
IMO the best option is to start with actual C and then move to C++ when you think you're understandings it somewhat well.
If you want to know C then learn C. They are different languages entirely. Forget all the "superset" bullshit...even typing strength is different between them. Learning one to learn the other is just going to mess you up.
Thanks a lot! &lt;3
Interesting :) We are actually using this in a WebAssembly project, but the UI is also done in C++. What kind of interoperability are you envisioning?
&gt;Arduino is actually a C++ environment as well. &amp;#x200B; Sort of. It's very C with classes style. You could write entire arduino programs and never know you were in C++ instead of C. The only part of the library that's C++ is the stepper class and it's shit. I was working on a modern library for that but I'm bipolar/schitzo so it's gathering cobwebs at the moment.
It is a serious violation of the C++ abstract machine for the same object to have more than one memory location. Unlike a lot of UB which usually works anyway, you need to be very, very careful with writing the state of objects using multiple addresses, because the optimiser hard-assumes that it and only it can update the storage of objects.
 He is an **anthropomorphic personification** of the Standard Template Library
Heh, what does this post even mean? Its exactly the same thing!
&gt;C++17 (? forget how high it gets now) C++17 is the latest published standard, C++20 is currently being drafted and prototype implementations of some of its features exist in major compilers.
But that is what those frameworks are about. Creating a system that lets you pipeline tasks in a dependency graph? That is a design to get around concurrency scaling. Having immutable application state centrally.located with updates, merges and the like? Again, attempt to get around concurrency scaling. Both of those require writing libraries and tools to work with a fundamentally different application design than C++ assumed by default (which is procedural). You have to write the kinds of services that C++ provides procedural programs for free. Things like "call function", "return value from function", "loop", "pass arguments", "recurse" - these are all things that languages prior to C++ did not provide, and people wrote languages that made those things easy, thus resulting in the current generation of structured procedural programming languages. And people who think that is how you write programs. For a concurrent application, the equivalent services are not built into C++, nor provided by std or TBB. What you get is procedural tools that let you reach that functionality in the turing tar pit sense. What I think you are experiencing is a machine code programmer asking how to build a structured program in the new sense being annoyed because the people she asks are telling her about how to handle stack frames and do function calls. It is true that this does not directly address the problem, it is the only way forward, because it isn't plausible to write a modern procedural program without stack frames and function calls.
&gt;The only part of the library that's C++ is the stepper class There's a difference between not being object-oriented and not being C++... That said, the Serial class is also "C++" style, and so are a lot of 3rd-party libraries.
You're doing a nice service for the community to provide a nice bite size example of CMake usage. That said, I had some nit-picks. These are intended as constructive feedback and an extended discussion for those who come across this reddit post later on. As described, I don't believe your headers in the project definition for IDE tools such as visual studio and Xcode. That's (arguably) not an issue for downstream consumers via `find_package`, but is a bummer for folk using those tools that might otherwise want to contribute. In your install statement, you specify an `INCLUDE DESTINATION`. I believe this is redundant with the `INSTALL_INTERFACE` generator expression you use in the `target_include_directories` statement. The `BUILD_INTERFACE` generator expression is still useful though. Despite being a header-only library, you specify destinations for installing `ARCHIVE`, `RUNTIME`, and `LIBRARY` build artifacts. While that doesn't hurt anything, it's unnecessary and I imagine that might lead to some misunderstandings. You hard code the installation directories, e.g. `lib`, `bin`, `include`. While it's not a huge issue, for most cases, the path variables (and default values) provided by the `GNUInstallDirs` module shipped with CMake are preferable. This allows a downstream software packager to customize the installation structure to the conventions of their package manager without requiring them to edit your `CMakeLists.txt` files. For instance, on many Linux platforms, `lib64` or `lib/x86_64-linux-gnu` might be the appropriate place for installation of library files compiled for 64-bit architectures. The default values for `GNUInstallDirs` variables is based on the system being compiled and will usually be the most common convention for that system. You install your export set to the `lib/cmake/&lt;PROJECT_NAME&gt;` directory. While that works and might (arguably) make sense for a project which installs binary artifacts to the `lib` directory (plus or minus the library installation convention for the platform), but we're describing a header-only library and that's not really what the `lib` directory is for. CMake configuration file are (usually platform-independent) text-based data files. The [Filesystem Hierarchy Standard](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard) would probably prefer these files be installed to the `share` directory. Note that this is supported by CMake's `find_package` out of the box for the following conventions: + `&lt;prefix&gt;/share/cmake/&lt;name&gt;*/` + `&lt;prefix&gt;/share/&lt;name&gt;*/` + `&lt;prefix&gt;/share/&lt;name&gt;*/(cmake|CMake)/` where `prefix` is any path in the `CMAKE_PREFIX_PATH` environment variable and `name*` is the case-insensitive package name. If you have any interest in supporting macOS beyond Unix-convention tools homebrew and macports, you may consider adding a discussion of + CMake's support and integration apple's Frameworks + the `CMAKE_MACOSX_FRAMEWORK` variable + `PUBLIC_HEADERS`, `PRIVATE_HEADERS`, `MACOSX_FRAMEWORK` target properties + how it impacts the installation paths for headers, binary artifacts, and CMake configuration files
I didn't dig much into this project so I cannot know for sure. But it would be for a given redux store, bind its value to a C++ store when calling a function that needs one as parameter. Or maybe the contrary. I have some C++ code and would like to dispatch to a redux store. Maybe the binding can already be done with embind? I have a project and it would be interesting to try migrate some code using this.
Object orientation is the only part of C++ they use. I don't think there's even any templates and of course they can't use exceptions. It's a very C style library and if it uses C++ features its as an afterthought or accident.
&gt;STL is a maintainer of ~~MSVC's implementation of the C++ Standard Library~~ STLSTL. FTFY.
The actor model is not always referred to by name, though there is the demarcation problem of what should be called the actor model. If the actor model is broadly defined as message passing semantics, then loads of books talk about it. If you restrict it to books that use the phrase actor model, which I argue is too restrictive, then yeah, there aren’t that many. But here are two titles: * [Coordinating Distributed Objects An Actor-Based Approach to Synchronization By Svend Frolund](https://mitpress.mit.edu/books/coordinating-distributed-objects) * [Actors: A Model of Concurrent Computation in Distributed Systems](https://apps.dtic.mil/dtic/tr/fulltext/u2/a157917.pdf) by Gul Agha. Software transactional memory and optimistic locking are hard to separate as distinct. They fall more on the side of applications than concurrency primitives, which I think is why you tend to not see them discussed in concurrency books. On the other hand, Most database books cover transactions and concurrency. There do exist a few concurrency books that cover them. Here are a few that are about them exclusively: * Maurice Herlihy and Nir Shavit, [The art of multiprocessor programming.](https://www.e-reading.club/bookreader.php/134637/Herlihy,_Shavit_-_The_art_of_multiprocessor_programming.pdf) * James R. Larus and Ravi Rajwar, [Transactional Memory. ](https://www.morganclaypool.com/doi/abs/10.2200/S00070ED1V01Y200611CAC002) * Jim Gray and Andreas Reuter, [Transaction Processing: Concepts and Techniques](https://www.elsevier.com/books/transaction-processing/gray/978-0-08-051955-5)
Just say "Stepanov's STL" when you mean the original. That said, I understand those who get very emotional about terminology and, as someone remarked else-thread, wants to punch someone in the face for even providing facts about it. After all, shared terminology is one aspect that binds a group together, and criticizing someone's terminology is akin to excluding that person from the group. That's vile, social exclusion. May those bastards with facts never be invited to the daily feast on Sæhrímnir.
OwO
I’d argue that when you see &amp;&amp; you have to pay attention because it is there for a reason (performance or to make the code compile in the first place). With for(auto&amp;&amp;) it is almost never there for a reason, but by doing it per default you are hiding if something tricky is going on. Additionally you lose the ability to talk about const so it makes code harder to read (you actually have to read all the code in the loop to figure out if the element is modified or not). The proposal to make the auto&amp;&amp; is good because that’s the only valid thing to put there in all cases, but that’s not the reality we are dealing with when reading code, so it’s quite irrelevant.
The are also non-template functions in the C++ standard library that do not come from the C standard library, such as [set\_new\_handler](https://en.cppreference.com/w/cpp/memory/new/set_new_handler).
C has features of its own that they don't use either - things like implicit cast from void\*, "implicit int", `_Generic` macros, designated initializers (finally coming to C++ woot!), complex numbers, ... C is not what you get if you shun templates and classes from C++.
Yeah. It is like the "third-world country" thing. We know it's original use but today around the world it is used for developing and underdeveloped countries in a derogatory way. STL meant something originally but now in most of its uses it is just an alias for the standard library.
Thank you for the constructive feedback, I appreciate it very much. I will try to integrate your suggestions as soon as I find the time to check them in the project the example is derived from
&gt; 'never do this'-meme OK, I'm lost - maybe my English or my internet foo is failing me - did I ever recommend not to use the parallel algorithms? I've been using them to great effect since they where first available on MSVC. I'll edit my first post to make sure no one understands it that way.
I think personification already implies an aspect of anthropomorphism
&gt; Generally when someone says STL today they mean those parts of the standard library that come from that project. They are different from the STL itself because they've been standardized (STL is "just" a library). &amp;#x200B; I'm not even sure, if that is still true nower days (I certainly don't) but maybe I'm just living in a bubble.
no, f.e. there might be a feilne personification of the Standard Template Library
If he's so anthropomorphic, why is he always making cat noises?
&gt; Things like "call function", "return value from function", "loop", "pass arguments", "recurse" - these are all things that languages prior to C++ did not provide, and people wrote languages that made those things easy, thus resulting in the current generation of structured procedural programming languages. Your general point that structured programming did not always exist is correct, but it isn't something that C++ invented; if nothing else, there was C which is what C++ built on (as implied by the name), and several decades before that (1960) there was [Algol](https://en.wikipedia.org/wiki/ALGOL).
I have designed massively parallel codes for ordinary and exotic hardware across a wide range of applications. There are many "rules" that apply to specific applications and hardware but over time I realized that these are just applied versions of a single, more general rule: parallelism is effected by making the topology of your software architecture match the topology of your hardware architecture. In real systems, this can be usefully re-stated as "minimize data motion" at the level of the physical silicon. Everyone knows that shared, mutable data architectures scale poorly. Many people address this by making data non-mutable but this tacitly violates the "minimize data motion" heuristic. The alternative is to make data non-shared, which is how many highly parallel systems work in practice. If you limit yourself to ordinary CPUs there are general software architectures that scale extremely well for almost all applications but it is at a higher level of abstraction than concurrent algorithms: no shared data and single thread per core. To the extent inter-thread communication happens, it is via SPSC queues. Most software engineers are not used to writing code like this but it is idiomatic in some scale/performance sensitive domains. It also has the benefit that virtually all of the code is explicitly single-threaded. This still leaves you with the challenge of designing code to optimally use the considerable parallelism \*within\* a single core but that is amenable to library implementation. Implied in this is that your software architecture must be pervasively non-blocking and you'll be using some form of lightweight context switching (e.g. coroutines) but this is ordinary library-provided functionality. The trickiest part of parallelizing code this way is balancing load across cores but in many cases this is not needed at all and there are effective solutions for it when required (e.g. database engines architected this way).
In Scott Meyer's Effective C++, he breaks C++ down pretty well. In Item 1, he suggests to "View C++ as a federation of languages" which include: C, Object-Oriented C++, Template C++, and the STL. If you focus on the C and Object-Oriented aspects of C++, I think switching to C is rather trivial as you'll understand all the concepts necessary for the switch. A few specifics might be different like using 'new' vs 'malloc', but it's something you'll be able to quickly pick up on. Arguably you can't really use Template C++ until you understand the basics of C and C++. Getting lightly accustomed with the STL will give you an appreciation for effective abstractions that wrap your basic C features.
I heard that MSVC and Clang have support for coroutines but that the performance, especially with MSVC, isn't great. I think if you use Gcc or another compiler, the answer is 'no'. [https://www.reddit.com/r/cpp\_questions/comments/c6mbls/coroutines/](https://www.reddit.com/r/cpp_questions/comments/c6mbls/coroutines/)
&gt; Most of the time when people have a question about C/C++ it is because they understand neither of those two languages. Lol wat. Even though they're not identical, there's significant enough overlap between the two to justify using that term in a lot of situations.
I think it's still useful to refer to the containers/iterators/algorithms part of the standard library as "STL" since it has a nice consistant design that can be expanded. Something that cannot be said of some other parts of the standard library.
That's not clear enough. Do you know how many Stepanov's there are in the world? The more accurate terminology should be: **STL's S+L's STL, not to be confused with MS's STL's STL** Or the long form: **Software Technology Laboratory's Stepanov and Lee's Standard Template Library, not to be confused with Microsoft's Stephan T. Lavavej's Standard Template Library**
&gt; I am telling you that you cannot break into the industry at entry level without a college degree. Well no, but it's very hard since you'll need to self learn everything (and that's not easy) and then convince a company to take you on when you're good enough, since you'll be missing real world experience. It's not impossible, but pretty rare. It's waaayyy easier with a degree.
Just about my favourite video ever.
&gt; Whatever makes Rust so good, the C++ language could also implement. actually not. Rusts key difference is the ownership model. In order to provide its safety guarantees Rust has to (for example) forbid structs which hold references to themselves or their members. Such constraints would break a lot of C++ code. Once you would break (almost) all existing code in one language you may just as well create a new one. I do not think C++ can ever catch up to Rust in Terms of safety. However there is still hope for your cause. There are things you can do in C++ right now, that are at the very least a lot more akward to do in Rust: * Rust does not support const generics * Rust does not have support for higher kinded types (think `template&lt;template ...&gt;&gt;`). * Rust generics have a fixed number of arguments, there is now equivalent to typelists.
The majority of furries are in IT. Do with that what you want. Source: Am just that. Also https://www.reddit.com/r/furry/comments/5mapxj/what_do_furries_do_for_jobs_these_days
The majority of furries are in IT. Do with that information what you want. Source: Me ;). Also, https://www.reddit.com/r/furry/comments/5mapxj/what_do_furries_do_for_jobs_these_days
I'm willing to help someone on a project if we use [my code generator](https://github.com/Ebenezer-group/onwards) as part of the project. DM me for more info.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
&gt; Hardly anyone uses it anymore My understanding was that it was a subset of the standard library, encompassing standard containers and container algorithms. The mantra nowadays seems to be to use it as much as you possibly can. You almost shouldn’t even have naked loops (for, while, do).
In 99% of the situations in which the term *is* used that's simply not the case! — At least that's true on Stack Overflow and in recruitment/job ads. Four other purposes fell free to use “C/C++” but honestly they're few and far between, and I prefer being explicit in these cases, via “C and C++”.
Is it not the PJPSTL anymore? (Semi-genuine question, I don't know the relationship between MS and Dinkumware these days.)
It's been reported by the author that Coroutines run on a large number of instances at Microsoft, and Facebook is plowing full stream ahead in putting them everywhere for internal use. Of course there's a difference between the design being ready, the design being closed, and all implementations being ready.
If I interpret that correctly, the standard views every byte in both copies of the buffer as a separate object, by definition. The issue is that some of them change behind the compilers back, so to speak. It sounds like changing the internal buffer to type `volatile char*` would actually make this fine, but of course that would also defeat the purpose since basically no C API is accepting a `volatile` pointer. It *might* be fine to have a `volatile char*` internally and cast away the volatility before passing it to the outside, since for any correct usage of the buffer we are guaranteed that the portion that is currently read/written will not change under the user, but I'm not sure yet.
:) LoL
The Standard Template Library includes containers, algorithms, and various header-only and header + implementation. So your containers, &lt;algorithm&gt;, &lt;type_traits&gt;, etc. The C++ standard library includes the STL as well as various implementation details like running constructors on static members, exceptions, memory management, RTTI, etc. It is useful to call out as distinct from the C standard library in constrained environments where you may not have the memory (or potentially even the flash storage!) available to accommodate the C++ standard library, but can fit in the C standard library or a subset of it (e.g. omitting printf's implementation). This leads to C++ that uses the header-only parts of the STL (e.g. &lt;array&gt;, &lt;type_traits&gt;, &lt;algorithm&gt;, &lt;complex&gt;) plus the C standard library implementation. In this mode of development most containers and i/o are off limits, and you may or may not have access to generics like std::function. It's a niche environment, but one where the distinction is important.
In constrained environments, there is a very large distinction between the header-only subset of the STL and the C++ standard library due to the memory footprint of requiring the C++ standard library. Not something most people have to care about, granted.
Correct. It's in a standardized form in the standard library. This makes it different from the STL library itself, which is not standardized even though it has that in the title.
Might? I'd be severely disappointed if there weren't.
http://memes.ucoz.com/_nw/32/10201233.png
AFAIK, you can install FreeDOS (or even MS-DOS 7.x) in DOSBox and boot it. You get LFN support that way. In fact, you can install Windows 95/98 in some forks of DOSBox.
Yes. If only you were there with your advise eight years ago when this video was made.
&gt; Most of the time when people have a question about C/C++ it is because they understand neither of those two languages. Indeed, or even worse if they have that written on their CV. Also, if a company is looking for a C/C++ developer I automatically assume that they have a horribly old badly maintained code base that is mostly written as "C with classes" that no one is really able to figure out. I think pointing out that there is no such language as C/C++ is indeed relevant.
I disagree with the Stack Overflow answer. I’m sure the history is correct, but it’s never correct to refer to the STL as “the standard library”. [The **S**tandard **T**emplate **L**ibrary is a *part* of the standard library](https://en.wikipedia.org/wiki/Standard_Template_Library#History), covering standard containers, iterators, and the standard algorithms. These all use templates. But, as an example, it doesn’t encompass something like output to the console (printf, cout, cerr), or std::string—string has taken influence from and has compatibility with the STL, with its iterators, but using the STL doesn’t make code *part* of the STL.
Actually I think this is still pretty verbose, but maybe that's a matter of trading off some flexibility. Does your library also support controls, or are you always supposed to do all the event handling on the window level?
I believe this buffer fill your needs: https://www.boost.org/doc/libs/1_67_0/libs/beast/doc/html/beast/ref/boost__beast__flat_static_buffer.html
It does support controls. And part of the verbosity here is because we aren't doing that sort of thing. In this case we doing a custom window so that we can do our own drawing and user input and such. None of that would be involved for just the average dialog'y type window. In that case you'd just be responding to clicks and whatnot from controls. This is maybe a bit more like creating your own control or your own custom editor window or something like that. I can do another one that demonstrates the other type of thing easily enough. Maybe later today.
Thing is: There is no guarantee what part of the standard library is in the "header-only subset" e.g. even templates can rely on non-header only functions in their implementation and a large body of code that does not belong to what most people consider the "STL"-part may still be completely/mostly header only. Here we are entering very vendor specific territory anyway, so attributing a special meaning to "STL" is imho of limited use. The standard distinguishes hosted vs free-standing of course, but I didn't have the impression that vendors of embedded toolchains care too much about what part of the standard library is officially declared what (There is some work to make this distinction more relevant in practice). Also, when linking statically, the linker can remove unused parts just as well from the compiled parts of the standard library, so there is not really a need to go all header only anyway. "Works without an OS, exceptions, rtti and the heap seems" seems to me a more relevant distinction in practice than STL vs the rest when we talk about constraint environments.
 there is always a feline personification of the Standard Template Library nearby
Just make the buffer volatile.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c95ecd/compiling_in_notepad/est6vee/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Agreed. In the terms of the C++ abstract machine and for ring buffer usage, it wouldn't be so much one object having two different memory locations as two different objects with non-overlapping lifetimes having the same location. Doesn't seem very different from just unmapping and remapping a page to a new address. Not sure about the exact incantation required to bless, but it might just need a barrier to enforce ordering between implicit destruction at tail and implicit construction at head.
I think its actually super helpful to study both to understand just how much of modern c++ is just the compiler generating boilerplate code for you. New is a pretty good example -- it can be seen as a typed malloc + calling a ctor on the new memory chunk. There is almost (exceptions come to mind but not much else) nothing you can't do with c that you can with c++ although it can get much more verbose and error prone. Understanding the connection there empowers you to do more in C and understand more in c++.
Do learncpp has exercises and answers as well.
Yep, official position of Qt developers is that Qt Quick (including Controls) is targeted mainly for mobile/touch/embedded interfaces or interfaces with rich animations and no stong need for native look (for example, AMD's Radeon Settings uses Qt Quick). Qt Widgets is for people who need classic desktop interfaces. Also Qt Quick Controls 1 is deprecated.
Spelling correction: Lavavej. The last name, like the floor, is lava. (Pronounced lah-wah-wade: lah like you're singing, wah like you're a baby crying, wade like you're wading in the water.)
What advantage does that have over overloading operator\[\] and the ++ operation for iterators? Can you give me a use case where that isn't sufficient?
Plans are in the works for supporting mapping and unmapping memory. That's doable. But nothing I can imagine possible could support objects having more than one memory location in the C memory model. That's a core assumption, most optimisation becomes impossible without that.
I AM THE `begin` AND THE `end`. I AM `all_of` AND `none_of`. I AM THE `lower_bound` AND THE `upper_bound`, THE `min_element` AND THE `max_element`. ALL THESE TEMPLATES ARE YOURS, EXCEPT `vector&lt;bool&gt;`. ATTEMPT NO SPECIALIZATIONS THERE.
I also "invented" something similar, I tried to make it ~100 lines of code. Take a look https://github.com/eyalz800/maybe
If you need something extremely simple I would take a look at this: https://github.com/eyalz800/maybe
cool stuff
Thanks for this
No problem. The SFINAE explanation from Bendersky's the real gold, though...
And non-template classes, such as std::thread and std::locale, and template classes that do not come from the STL, such as std::basic_string and std::basic_iostream.
Apologies! Fixed.
This seems to explain the rationale for LTO in terms of multiple TUs, yet with a single TU I at least get smaller executables. I had the impression before watching this that LTO would only be helpful if you had multipe TUs and only tried using flto after someone here suggested it. I think this talk would be better if he mentioned that LTO can be helpful when you have just one TU and why. I'm not sure why if someone knows?
C cares nothing for your fancy operators
This isn't a C subreddit
This looks interesting. Most interesting and challenging would be to get a proper UI framework working as well. Lately with SwiftUI and Flutter declarative UI frameworks seem popular again (they might as well be inspired by QML). It would be great if we could have something similar in C++ (I mean, QML requires a JS engine). Or maybe we should have something similar to Svelte, which a JS project that has a compiler pass s.t. it does not require diffing.
I could write a lengthy comment about the STL's history, but I want to spend part of this holiday playing video games instead of posting on Reddit, so here's a quick summary. MS's STL is still derived from Dinkumware's codebase, but MS is now implementing all features and bugfixes by itself. Although "STLSTL" is slightly amusing, I didn't originate that joke, and I would prefer it to vanish. (I prefer "Microsoft's STL", "MSVC's STL", or just "the STL" when the platform context is known.) While I'm the MS FTE who's worked on the STL the longest (since 2007), and I review all changes to the codebase, it's not "mine". As C++ Standardization has accelerated, MS has dedicated more devs to working on the STL (this is a strong signal of its strategic importance to the company). The exact number varies, as the library team has other projects, but these days there are approximately 3 to 5 devs working on the STL at any given time, and I want the rest of the team to receive proper credit. I'm grateful to PJP, the world expert at STL (and CRT) implementation, for teaching me how to be a library developer. While our codebases are evolving separately now, we're continuing to build upon his decades of work.
This was discussed here a month ago: https://www.reddit.com/r/cpp/comments/bv0r1z/lockfree_c_queues/
My usual answers are: 1. [Metonymy](https://en.wikipedia.org/wiki/Metonymy) is powerful. If "the crown" can refer to a government, "the STL" can refer to the C++ Standard Library. It's not even a big stretch! It's a Standard Library that's full of Templates, what more do you want? (People have differing opinions on how encompassing the term should be. Almost everyone agrees that later additions following the same philosophy should count, like `shuffle()` and `unordered_map`. Some think that it's okay to use "STL" to encompass iostreams. Very few think that the STL encompasses the CRT.) When precision is important, feel free to spend more words, but most of the time, brevity is valuable, and "STL" gets the point across while remaining short and recognizable. There is no confusion in practice: everyone knows what Scott Meyers' book Effective STL is about, everyone knows what Electronic Arts' EASTL was trying to accomplish. 2. As an STL maintainer, I have the sovereign right to declare such usage valid. Now, go spend your energy on something that makes the world a better place, don't waste it on terminology.
I'm going to rule that this is off-topic here. This sub-thread is meant for people who want to exchange work for money.
Yes, it was [N3853](https://wg21.link/n3853). It was rejected for syntax reasons, but the semantic problem remains unsolved. I welcome further attempts to solve it, but I'm not going to spend any more time on that.
It is indeed a universal/forwarding reference; same for `auto&amp;&amp; var = thingy;` as a variable definition.
Please submit links as links, not text posts. You can add a comment with a summary, if you like.
ok. did you delete this post? should I resubmit it?
The point of this library is to interface with c libraries
[Boost.Fibers](https://www.boost.org/doc/libs/1_70_0/libs/fiber/doc/html/index.html) are great for writing asynchronous code. In this blog post I explain what's the difference between fibers and threads. I also compare fibers based asynchronous code to continuation style programming and claim that fibers are friendlier to C++.
RAII alone makes them massively different
I wholeheartedly half-agree! For the agreement: yes, the second language is always an eye-opener (at least if you started early): telling apart features of a programming language and programming concepts, strting to form a mental image of computers that is not tied to a particular languageetc. I certainly also see the synergy between C and C++ w.r.t. understanding the babylonian bootstrapping we have going on. As for the disagreeing part: For decades, we've tried to teach C++ "from the bottom up", i.e. learn malloc, pointer-arrays, learn constructors, learn new, write your own array class, and exceptions and and now you are ready for the wonders of `std::vector`. This process has its charms, but requires a lot of motivation for comparedly little effect. I am convinced that this has played its role in painting C++ as "elitist", "hard", and others, and has hampered adoption. I'd love to shy away from that for a while, so If I was to set the course, `new` would appear only in the last 3^rd of the book, under "Advanced and low level topics". I'd let you consume templates before I tell you the secret of creating them, you'd have to throw exceptions before you'd ever see a "return false", and you'd swing std::string and std::vector and unique_ptr and shared_ptr long before I'd let you see a puny raw pointer. This is the extreme end of the different mindset I mentioned. Look at it from another angle: Newbies have to learn an awful lot: they are, in a way, learning to communicate in a foreign language, with a completely foreign culture, and they also have to learn libraries and debuggers and IDE's and oh my! They come with expectations: they want to create a game, or do a fancy simulation .... It's hard to keep students motivated, and it's hard for students to assimilate so much at once. That's why I would like to move the "how it's built", the layer upon layer, to some later point: to reduce the overload somewhat.
Yes. If you don't have much programming experience, or much experienced with a compiled language like C or C++, then experience in C will help you a lot when it comes to C++ and you can avoid the complexities of C++ for the time being. No. C and C++ are so different now that most of what you learn with C will not be applicable to C++. It's best to just skip C and, if C++'s complexity is a problem, just use a subset of C++ and expand on it later. There's no reason you need to start with C. Pick your answer. There's no "right" way to move forward.
I didn't remove it. It's OK to leave as-is, but you can delete and resubmit if you want.
&gt; There is almost (exceptions come to mind but not much else) nothing you can't do with c that you can with c++ although it can get much more verbose and error prone. I can't think of any C++ constructs that you can't translate into C in a simple, mechanical way. You can replace namespaces by renaming everything to include its full path (`std::vector` becomes `std_vector`), you can replace inheritance by manually putting a vtable in your structs, you can replace templates by duplicating the class/function once for each type/value that the program uses, and like you said you can replace new/delete with malloc/free and a constructor call.
You just need to make it use `overflow: scroll` for the elements that are misbehaving in your css
Thank you very much for sharing these titles with us! :-)
I never understood why fibers get so little attention.
I'm not completely sure I understand the API of that buffer. As far as I can tell, the intended usage is like beast::flat_static_buffer&lt;5000&gt; fsb; auto buffers = fsb.prepare(100); for (buffer : buffers) { [.. write data into buffer ..] } fsb.commit(n); // n is total number of bytes written So it sounds like this works basically like a regular ringbuffer in terms of API, i.e. you have to write extra code to handle the case where you wrap around the edges. However, in the documentation for `mutable_buffers_type` it says ` This buffer sequence is guaranteed to have length 1. `, so I'm a bit confused how this is supposed to be used?
That's also /u/stl
Personally I never understood the advantage over coroutines glued together via futures.
Eventually I want to exchange work for money, but this is an unproven code generation service. Skeptics abound. I could understand their skepticism when I launched the service in 2002, but I think they should change their tune now. They just have the same song stuck in their head. Another entrepreneur out there and I will prove them wrong. Venture capitalists (sharks) often want a large percentage of a company in exchange for investing. I'll invest time in someone's company if they help me by using my software. They don't have to give me a percentage of their company.
Maybe because there almost no examples and methodologies how to use them efficiently. I've open sourced a framework that combines asio and fibers but i did not find any other open source library that makes serious attempt to use fibers for backend development.
Did I miss how you configured the \`.cmake.in\` file? Could you go into greater detail how to do that?
They are synonymous
Company: Akuna Capital Type: Full time, Internships Description: Akuna Capital is a young and booming trading firm with a strong focus on collaboration, cutting-edge technology, data driven solutions and automation. We specialize in providing liquidity as an options market-maker – meaning we are committed to providing competitive quotes that we are willing to both buy and sell. To do this successfully we design and implement our own low latency technologies, trading strategies and mathematical models. Our Founding Partners, Andrew Killion and Mitchell Skinner, first conceptualized Akuna in their hometown of Sydney. They opened the firm’s first office in 2011 in the heart of the derivatives industry and the options capital of the world – Chicago. Today, Akuna is proud to operate from additional offices in Sydney, Shanghai, and Boston. Our Developers are motivated by challenging technical problems in the trading industry and endless opportunities for innovation. Working in the nano-second space of our custom low latency trading platform, we are finding creative ways to use the latest tech while building new tools and implementing advanced solutions that meet the needs of a competitive trading environment. As a technology driven company, our talented Developers advance beyond typical Software Engineers by working on a range of greenfield problems. We do not sell our software and our collaborative vetting and peer-review processes give us the ability to achieve daily software releases. Location: We are hiring in Chicago, Boston, Shanghai, and Sydney. Akuna is looking for C++ Developers in all of our office locations and at all levels, including interns, juniors, and experienced candidates. Remote: No Visa Sponsorship: Akuna offers sponsorship to future employees on a case-by-case basis. Technologies: At Akuna, our development teams use the language(s) best suited to their work. Our C++ development teams work primarily with modern C++ (i.e. C++ 14, C++ 17 and beyond) on Linux. Akuna’s C++ teams work on applications where C++ is used for computational heavy-lifting and for applications that have timing-critical, low-latency processes such as trading strategies. C++ provides the flexibility and ow-level control that our developers need to get maximum performance out of multi-core, super-scalar, processors. Contact: Please apply directly to the roles you are interested in being considered for on our website. Below are some direct links to our open C++ roles: C++ Senior Developer - Chicago C++ Developer - Chicago Performance Engineer - Chicago Quant – Market Microstructure/ Low Latency Strategies - Chicago Quantitative Developer - Chicago Junior Quantitative Developer - Chicago C++ Senior Developer &amp; Team Lead - Boston C++ Developer - Sydney Junior Developer – C++ - Sydney Development Internship – C++ - Sydney Quantitative Developer - Sydney Junior Quantitative Developer - Sydney Quantitative Development Intern - Sydney C++ Developer - Shanghai Junior Developer – C++ - Shanghai Development Internship – C++ - Shanghai Quantitative Developer - Shanghai Junior Quantitative Developer - Shanghai
**Company**: Akuna Capital **Type:** Full time, Internships **Description:** Akuna Capital is a young and booming trading firm with a strong focus on collaboration, cutting-edge technology, data driven solutions and automation. We specialize in providing liquidity as an options market-maker – meaning we are committed to providing competitive quotes that we are willing to both buy and sell. To do this successfully we design and implement our own low latency technologies, trading strategies and mathematical models. Our Founding Partners, Andrew Killion and Mitchell Skinner, first conceptualized Akuna in their hometown of Sydney. They opened the firm’s first office in 2011 in the heart of the derivatives industry and the options capital of the world – Chicago. Today, Akuna is proud to operate from additional offices in Sydney, Shanghai, and Boston. Our Developers are motivated by challenging technical problems in the trading industry and endless opportunities for innovation. Working in the nano-second space of our custom low latency trading platform, we are finding creative ways to use the latest tech while building new tools and implementing advanced solutions that meet the needs of a competitive trading environment. As a technology driven company, our talented Developers advance beyond typical Software Engineers by working on a range of greenfield problems. We do not sell our software and our collaborative vetting and peer-review processes give us the ability to achieve daily software releases. **Location:** We are hiring in Chicago, Boston, Shanghai, and Sydney. Akuna is looking for C++ Developers in all of our office locations and at all levels, including interns, juniors, and experienced candidates. **Remote:** No **Visa Sponsorship:** Akuna offers sponsorship to future employees on a case-by-case basis. **Technologies:** At Akuna, our development teams use the language(s) best suited to their work. Our C++ development teams work primarily with modern C++ (i.e. C++ 14, C++ 17 and beyond) on Linux. Akuna’s C++ teams work on applications where C++ is used for computational heavy-lifting and for applications that have timing-critical, low-latency processes such as trading strategies. C++ provides the flexibility and ow-level control that our developers need to get maximum performance out of multi-core, super-scalar, processors. **Contact:** Please apply directly to the roles you are interested in being considered for on our [website](https://akunacapital.com/careers). Below are some direct links to our open C++ roles: * [C++ Senior Developer ](https://grnh.se/9e43fa031)\- Chicago * [C++ Developer ](https://grnh.se/fwy0pb1)\- Chicago * [Performance Engineer ](https://grnh.se/293c1fea1)\- Chicago * [Quant – Market Microstructure/ Low Latency Strategies ](https://grnh.se/b708ed5f1)\- Chicago * [Quantitative Developer ](https://grnh.se/2ddae6751)\- Chicago * [Junior Quantitative Developer ](https://grnh.se/00d2c8c71)\- Chicago * [C++ Senior Developer &amp; Team Lead ](https://grnh.se/251fd9f71)\- Boston * [C++ Developer ](https://grnh.se/9cc92d341)\- Sydney * [Junior Developer – C++](https://grnh.se/cbb5822a1) \- Sydney * [Development Internship – C++ ](https://grnh.se/65a80d271)\- Sydney * [Quantitative Developer ](https://grnh.se/47343e141)\- Sydney * [Junior Quantitative Developer ](https://grnh.se/51d714621)\- Sydney * [Quantitative Development Intern ](https://grnh.se/5f6b45681)\- Sydney * [C++ Developer ](https://grnh.se/a5264c601)\- Shanghai * [Junior Developer – C++ ](https://grnh.se/cb21a1aa1)\- Shanghai * [Development Internship – C++ -](https://grnh.se/0f2f2d151) Shanghai * [Quantitative Developer ](https://grnh.se/ed5000461)\- Shanghai * [Junior Quantitative Developer ](https://grnh.se/2f47f1e71)\- Shanghai
OK, here is another one. In this one, I've made the little editor window a control type window, and it's outside of the application. So this is what the actual application would be. Here is a screen shot: [https://www.charmedquark.com/Web2/PostImages/Samples/Window3Sample.png](https://www.charmedquark.com/Web2/PostImages/Samples/Window3Sample.png) &amp;#x200B; In this case, it uses an external dialog definition to load the content. This is created with the resource editor, and in this case it creates a resource file with a single dialog description and the loadable text file, which has text ids that the dialog definition refers to. Doing it this way keeps all that detail out of the program, and it also keeps everything font relative because the editor works in terms of font size, and the sizes of everything are adjusted for the default font when loaded. We have to have a facility object in order to load resources associated with it, so I do the minimal thing to create a generic one. It creates a generic client window, then it loads the dialog description, and then asks the client window to populate itself from that. The controls have anchor attributes which indicate how they should move, and the generic client window will adjust all their positions automatically to keep them relative to whatever they are anchored to. I have to look up typed pointers to the ones that I need to interact with, which are two buttons, the editor guy himself, and a little static text control that shows how many points are currently active. Then I install notification handlers to have those guys send me notifications. There's a click handler that handles the close and discard buttons being clicked. And there's one for the editor which sends a notification when the number of points changes, so the counter can be updated. Since the editor window is a custom control, I put a place holder window in the dialog layout, and just update it with the correct C++ class name to make the right window get created. I need to update the dialog editor to support doing that in place. The rest at the bottom is minimal application entry point and main window creation stuff just like before. There's not a lot to the actual application, since it's just responding to notifications from child controls. #include "Window3.hpp" tCIDLib::EExitCodes eMainThreadFunc(TThread&amp;, tCIDLib::TVoid*); CIDLib_CtrlsModule(TThread(L"Window2MainThread", eMainThreadFunc)) static TGUIFacility facWindow3 ( L"Window3" , tCIDLib::EModTypes::Exe , kCIDLib::c4MajVersion , kCIDLib::c4MinVersion , kCIDLib::c4Revision , tCIDLib::EModFlags::HasMsgsAndRes ); class TW3FrameWnd : public TFrameWnd { public : TW3FrameWnd() = default; TW3FrameWnd(const TW3FrameWnd&amp;) = delete; ~TW3FrameWnd() = default; protected : tCIDLib::TBoolean bCreated() override { // Call our parent first TFrameWnd::bCreated(); // Tell our parent we want to use a generic window as a client TGenericWnd* pwndClient = pwndInstallGenericClientWnd(widNext()); // Load up our dialog description. TDlgDesc dlgdChildren; facWindow3.bCreateDlgDesc(kWindow3::ridMain, dlgdChildren); dlgdChildren.SetCppType(kWindow3::ridMain_Points, L"TWindow3Ed"); // Tell our client window to populate itself from the dialog info. tCIDCtrls::TWndId widInitFocus; pwndClient-&gt;PopulateFromDlg(dlgdChildren, widInitFocus, kCIDLib::True); // Get typed pointers to the important controls m_pwndClose = pwndClient-&gt;pwndChildAs&lt;TPushButton&gt;(kWindow3::ridMain_Close); m_pwndCount = pwndClient-&gt;pwndChildAs&lt;TStaticText&gt;(kWindow3::ridMain_Count); m_pwndDiscard = pwndClient-&gt;pwndChildAs&lt;TPushButton&gt;(kWindow3::ridMain_Discard); m_pwndEditor = pwndClient-&gt;pwndChildAs&lt;TWindow3Ed&gt;(kWindow3::ridMain_Points); // Set up click handlers for our two buttons and editor m_pwndClose-&gt;pnothRegisterHandler(this, &amp;TW3FrameWnd::eClickHandler); m_pwndDiscard-&gt;pnothRegisterHandler(this, &amp;TW3FrameWnd::eClickHandler); m_pwndEditor-&gt;pnothRegisterHandler(this, &amp;TW3FrameWnd::eEditorHandler); return kCIDLib::True; } private : tCIDCtrls::EEvResponses eClickHandler(TButtClickInfo&amp; wnotEvent) { if (wnotEvent.widSource() == kWindow3::ridMain_Close) facCIDCtrls().ExitLoop(0); else if (wnotEvent.widSource() == kWindow3::ridMain_Discard) m_pwndEditor-&gt;DiscardPoints(); return tCIDCtrls::EEvResponses::Handled; } tCIDCtrls::EEvResponses eEditorHandler(TWindow3EdNot&amp; wnotEvent) { TString strCount(8UL); strCount.SetFormatted(wnotEvent.m_c4Count); m_pwndCount-&gt;strWndText(strCount); return tCIDCtrls::EEvResponses::Handled; } TPushButton* m_pwndClose; TStaticText* m_pwndCount; TPushButton* m_pwndDiscard; TWindow3Ed* m_pwndEditor; }; // ---------------------------------------------------------------------------- // We start up the main thread here // ---------------------------------------------------------------------------- tCIDLib::EExitCodes eMainThreadFunc(TThread&amp; thrThis, tCIDLib::TVoid*) { // We have to let our calling thread go first thrThis.Sync(); try { // Create a frame window, let the system decide on placement TW3FrameWnd wndMain; wndMain.CreateFrame ( nullptr , facCIDCtrls().areaDefWnd() , L"Window 3 Sample (Click Me)" , tCIDCtrls::EWndStyles::StdFrame , tCIDCtrls::EExWndStyles::None , tCIDCtrls::EFrameStyles::StdFrame , kCIDLib::False ); // Now just process msgs until the user closes us facCIDCtrls().uMainMsgLoop(wndMain); } catch(TError&amp; errToCatch) { // Use the desktop as owner, since our frame window may not have worked TErrBox msgbErr(L"Window 3 Sample", errToCatch.strErrText()); msgbErr.ShowIt(TWindow::wndDesktop()); } return tCIDLib::EExitCodes::Normal; }
If you are interested, here is the dialog definition generated by the resource editor: DIALOG= INFO= SYMBOL=ridMain, 1000 AREA=0,0,214,135 THEME=DialogBox FLAGS=Sizeable END INFO GENERICWND= AREA=5,4,204,101 SYMBOL=ridMain_Points, 1000 ANCHOR=SizeBottomRight END GENERICWND STATICTEXT= AREA=6,106,96,7 TEXTSYM=midDlg_Instruct HINTS=FinePrint ANCHOR=MoveBottom END STATICTEXT STATICTEXT= AREA=10,120,29,8 TEXTSYM=midDlg_Count HINTS=Prefix ANCHOR=MoveBottom END STATICTEXT STATICTEXT= AREA=41,120,18,8 SYMBOL=ridMain_Count, 1004 TEXTSYM=midDlg_Zero ANCHOR=MoveBottom END STATICTEXT PUSHBUTTON= AREA=117,118,45,14 SYMBOL=ridMain_Discard, 1005 TEXTSYM=[Discard] HINTS=DefButton Group ANCHOR=MoveBottomRight END PUSHBUTTON PUSHBUTTON= AREA=164,118,45,14 SYMBOL=ridMain_Close, 2 TEXTSYM=[Close] ANCHOR=MoveBottomRight END PUSHBUTTON END DIALOG
Ideally writing "C++" as requirement would be enough, however in many areas you need good C knowledge as well. Not only for using libraries exporting a C API, but also since designing and exporting a C API is an important part for libraries which are supposed to provide a stable ABI or FFI compatibility for other languages. However many people indeed don't know what they are talking about when using this (but that's a generic issue with recruiting ....)
Sitting here at 2:30 am, enjoying to read a TMP-related article.. Well played
Class templates, not template classes. This is the language lawyer thread.
The GP mentioned one thing: Exceptions. Sure, C has `longjmp` however that won't call destructors. Thus jumping from `qsort`'s callback won't neccisarily clean up qsort's state. (Doubt qsort has muchs state which needs cleaning, but you can't know and it's just one example of a C function with callback) For many other things the question is whether doing the same things in C would be practical. And we'll, you could do all that in Assembler was well :)
I did not say **all** languages prior to C++, although I can see how you could read that in. I simply meant that in (some) languages prior to C++, procedural programming as we know it today did not exist, and primitive operations many consider "just what a language does" where missing.
\`\`\` if(s\[i\] &gt; 0){ continue; } \`\`\` This assumes the \`char\` is signed and thus not portable. &amp;#x200B; Not sure how does this handle emojis constructed from many scalar values such as skin tone modifier, gender modifier, hair color, orientation, family emojis, etc.
There is a future where you're code will never have a real fiber R we there already?
I think this question can be rethink as follow, how game engines of previous generation and this generation are design, so they can take advantage of all CPU power from Xbox 360, PS3, PS4, Xbox One, etc. I remember reading a little bit in Game Engine Architecture by Gregory Sandor. One of the chapters, explained about creating workers threads and dividing subsystems work, such as draw to screen, detect collision, etc. For that, you create a task that contains locks to subsystems you interact with. This task is later push to the workers' queue for later processing.
I’m very interested in fibers in part because boost coroutines is deprecated and asio doesn’t work with coroutines2 yet. The asio developers don’t seem to care about making it work.
Wroking on it
&gt; EXCEPT vector&lt;bool&gt; Yeah, I mean, that obviously belongs to /u/vector-of-bool.
It's a very useful information as you can expect very old style C++, with abuse of classes when it is not required, getters and setters that do literally nothing (could at least check the `enum` value is valid or use `enum class`), nothing functional and functions that are over 200 lines long. So many red flags in such a short sentence.
No, learn C++ first and then C, it will make you a better [good even] C-Programmer [and hopefully C++ as well of course]. Learning C first will make learning C++ harder.
IMO, unless you have to use GCC, you can use it. I've suffered from both Clang and MSVC, but they work quite well for now. [Build for mobile(Android and iOS) is also available](https://travis-ci.org/luncliff/coroutine). Well, I know some patterns that compiler crashes with its internal error, or fails to generate code, but simple usage of `co_await` operator won't that matter on their latest versions. https://www.reddit.com/r/cpp/comments/c6ag3l/how_to_try_the_new_coroutines_ts/esnjqil?utm_source=share&amp;utm_medium=web2x
The function \`prepare\` returns continuous memory of requested size or throw exception in case of overflow. &amp;#x200B; Implementation details here: [https://www.boost.org/doc/libs/1\_67\_0/boost/beast/core/flat\_static\_buffer.hpp](https://www.boost.org/doc/libs/1_67_0/boost/beast/core/flat_static_buffer.hpp) [https://www.boost.org/doc/libs/1\_67\_0/boost/beast/core/impl/flat\_static\_buffer.ipp](https://www.boost.org/doc/libs/1_67_0/boost/beast/core/impl/flat_static_buffer.ipp)
Glad to meet a new generator :) I have 2 questions, each for the `unique_generator` and the `shared_generator`. I wish I can review the others soon. #### unique_generator Isn't `hasValue_` redundant? [I'm following the generator of VC++](https://github.com/luncliff/coroutine/blob/master/interface/coroutine/yield.hpp#L78)(it's a bit changed in latest VC++. I'm using the old one.) and the pointer itself was enough to debug and check of existing value from co_yield. #### shared_generator I think the idea is cool that multiple coroutines can share 1 generator since it can help Fan-In use-cases. But what I realized was keeping safe **in** the generator is a bit complicated. Do you think that the users have to control **locking** for the [yield](https://github.com/Quuxplusone/coro/blob/master/include/coro/shared_generator.h#L117)?
I don't have experience from doing this myself, no.
Sorry if it was obvious but where is this open source library that combines boost.asio and boost.fibers that you speak of?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/c9brks/whats_the_main_reason_behind_college_professors/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
For async programming, coroutine is clearly better fitted, both simpler and faster.
&gt;chitectures / here is my variation of Vyukov's queue that supports move semantics and correctly destructs objects with non-trivial destructors. [https://github.com/romange/gaia/blob/master/base/mpmc\_bounded\_queue.h](https://github.com/romange/gaia/blob/master/base/mpmc_bounded_queue.h)
[Gaia](https://github.com/romange/gaia)
It's not so clear to me :) What's the architecture that you use for writing c++ backends with coroutines? Is it a thread per connection? Per request? Per cpu core?
Even ISO members refer to them as C/C++, are they clueless then?
It is used quite frequently in ISO C++ papers.
&gt; Fibers can not move between system threads and they are usually pinned to a specific thread. That's contradictory in itself ("cannot move" and "usually pinned"), but fibers definitely can move across OS threads. E.g., work-stealing schedulers.
you can totally use templates in arduino code.
I've always considered fibers and coroutines without language support to be a hack. MSVC is the only compiler I know of to support fiber-safe optimizations (and Windows has first-class fibers API). Otherwise switching the stack without the compiler knowing about it... it may work on current compilers, but when is it going to break? It's technically UB. Then, there are also problems with exceptions. You must also be careful to not switch contexts during stack unwinding otherwise all hell breaks loose. Then there are asynchronous callbacks from the OS itself (or signal handlers on unix) -- must not switch stacks there either. You cannot use TLS (because the fiber may be migrated); you have to resort to fiber local storage. IIRC, Microsoft published a paper that discussed problems with fibers when used in the context of SQLServer and they nudge users towards using user mode thread scheduling (https://docs.microsoft.com/en-us/windows/win32/procthread/user-mode-scheduling) TLDR: too many problems that surface rather late. Many unices began with M:N threading model and walked away from it eventually. AFAIK, Rust did the same.
Quite right, thanks for the correction.
you may check this [paper](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf).
I know what fibers are. I wrote a blog post about them. I did not see in that paper anything concluding that "coroutine is clearly better fitted, both simpler and faster". These are different creatures doing different things. With coroutines, you can not easily increase the parallelism of your program, you can only pass the execution somewhere else. They are a more low level than fibers or actor-based frameworks.
Involving user defined comparison operators in the the use of values of user defined types as template arguments, doesn't sound good. If one absolutely must provide support, one way is to require a mapping from user defined type value to tuple of fundamental values where each can be used as template value parameter. For a simple enough class such mapping can be provided automatically.
`std::thread` is not part of the language in c++ and it's fine. `pthread_yield()` is well defined and is part of the POSIX spec even though it might switch stacks. I do not think that fibers must be part of the language though there is definitely a room for improvement for Boost.Fibers to be debug friendly. It's possible to write exception-safe code with fibers and their context-switching does not interfere with OS async functions. In fact, fibers work great with async callbacks by preserving synchronous coding style and allowing asynchronicity of the execution. This is the beauty of fibers: you just write a fully synchronous high level code without breaking the flow but underneath the scheduler switches the execution from "stalled" fibers to the active/awaken ones.
&gt; They will share the same address, that's the definition/implication of pointer interconverti They share the same address, but they are not the same value, due to provenance.
Thanks! Finally, someone commented on the blog post itself. You are right, I assumed that fibers run with a default scheduler but it does not have to be. I personally made a design choice to not pursue work-stealing and thread migration in [GAIA scheduler](https://github.com/romange/gaia/blob/master/util/asio/io_context.cc#L34) so that a user could use thread-locals safely. Anyway, I will change the wording.
Can't the compiler just catch this at the point where it is used? I don't see why strong structural equality needs to be set in stone after the type is complete.
Same here, though it is only 1:30 am ;)
re: &gt; When is the best time to catch bugs: while the product is in development, or after it has been released to customers? well ideally during a beta-test phase but it does not work in a world where the standard is set in stone 2 years before all mainstream compilers implement it fully.
Maybe you should ask the same question in /r/C_Programming too?
I don't understand this. Can you elaborate? I know about provenance for C, but I thought this is not relevant for C++, i.e. that all accesses of the same address and through the same pointer type are either all valid or all invalid. (In C this is not the case)
 A great use case for fibers is presented in this [talk](https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine).
Yeah, I agree. I mention that in the `views` section of the documentation actually. From a pragmatic point of view actually immediate mode apis do not work too bad in practice. QML is nice, and it requires a JS engine but it is a very lightweight one. But in spite of its "declarativeness", its semantics are very objecty, definitelly much more than React. Some of the issues when working with widget trees also apply there (in particular manual diffing). In November I will do a couple of talks though on an approach that helps a little bit with that situation. I have also looked at Svelte before, but I do not think you need a compilation pass in C++ to get a React like API, because of static polymorphism. I have notes in some of my notebooks on how a concrete API could look like but never got myself into actually implementing something. I am also very inspired by Reagent, the React wrapper for ClojureScript. I have not dared to implement something yet... no time :) And also such project is valuable enough that I would like to find someone to finance the development :)
It's a great talk! This talk is, in fact, persuaded me to learn fibers at the first place.
From the github repo on the master branch: [version.txt](https://github.com/oktal/pistache/blob/master/version.txt) Hope it's what you're looking for.
Anyone else getting this error: `Websites prove their identity via certificates, which are valid for a set time period. The certificate for` [`cppcast.com`](https://cppcast.com) `appears to be expired. Error code: SEC_ERROR_EXPIRED_CERTIFICATE` ?
Ah, I understand, the buffer will copy its contents to the beginning of the buffer every time you call `prepare()`, this way you get the whole capacity as a continous memory region. This should work as well. Mine has the advantage of not requiring any copying, at the cost of having double the memory footprint.
Well I can access the site, but yes, they have a problem with their HTTPS certificate and should fix it.
Well fair enough, and in these contexts the expression is sufficiently well-defined, but this is explicitly not what we’re talking about here. Nobody goes around telling compiler writers that “there’s no such language as C/C++” — OP explicitly talked about people asking questions online.
I don't understand what this is supposed to prove. All of the equality/inequality operators in the examples give the wrong answers. If you write broken equality operators, then you get broken equality semantics - why is this supposed to be surprising?
&gt; std::thread is not part of the language in c++ and it's fine. C++ definitely has a memory model. The compiler/optimizer should also have some understanding of mutexes so as to not move writes to memory across the mutex barrier. Without some special rules the compiler would be free to reorder the two assignments here as it sees fit: a = 1; std::unique_lock lk(some_mutex); b = 2; Which rules make the compiler respect the mutex barrier.. I honestly have no idea. Without the mutex the two writes could even be coalesced in a single machine instruction. &gt; pthread_yield() is well defined and is part of the POSIX spec even though it might switch stacks. `pthread_yield()` does not switch stacks *within the same thread of execution*. Yes, the OS may schedule another thread on the cpu, but this is invisible to the program itself.
&gt; The pedants ... are even worse than the ones who tell you that "there's no such language as C/C++" &amp;#x200B; [As one pedant once said](https://youtu.be/ltCgzYcpFUI?t=895): &gt;The relationship between C and C++ is so strong even now that in a lot of places people talk about C/C++ like it's one language. Which is kind of surprising because the C++ programmers look at C and go *"****that*** *is* ***not*** *my language!",* and the C programmers go *"****that*** *is* ***not*** *my language!".* But to the outside world, you know, it's all kind of the same thing.
Old timers will remember "The C/C++ User's Journal" as one of the official ways to get news about C and C++ worlds, full of articles that used such expression. How is a begginer supposed to know that is wrong to use such expression?
Long before coroutines started becoming a thing for C++ I wrote a web server using fibers, one fiber per request. I suspended the fibers at blocking IO and resumed them on IO events coming in on an IO completion port with multiple worker threads, so the fibers were constantly switching threads each time they blocked on IO. It actually worked really well - the code for dealing with a request looked like normal linear blocking IO, but it automatically suspended and resumed at each IO block so it could handle a large number of concurrent requests, without needing to have thousands of threads in flight. Coroutines fulfil much the same role.
I agree, the article is confusing. Bad operator overloads leads to bad results? That seems OK. I can probably make the code even less sensible with a few minutes of scrambling. Boolean output aside. (I am mostly commenting here so I can come back and see if there is an actual answer to why this matters later in the day.)
Actually 'prepare' will copy buffer only in case requested size greater than remaining capacity at the edge of memory region. Also 'consume' reset cursor position to start in case of consume whole buffer. I believe in network i/o in most cases u will never reach buffer end.
A long time ago I used the old GNU Pth fiber/green thread library for something similar. It's a nice model; I prefer it over the callback based event loops that are more common these days.
You misspelled "this program is ill formed no diagnostic required"? struct A { enum E { RED = 1, BLUE = 2 }; }; static_assert(std::has_strong_structural_equality_v&lt;A::E&gt;); constexpr bool operator==(A::E, A::E) { return true; } constexpr bool operator!=(A::E, A::E) { return true; } // The value of `has_strong_structural_equality` doesn't change after the type is complete. static_assert(std::has_strong_structural_equality_v&lt;A::E&gt;); modifying the result of a trait class and relying on memoization of templates to not notice doesn't mean "it doesn't change", it means your program is ill-formed.
I don't see the issue. You could write the "Boom" program today without wrapping the enum in a class and it would behave exactly the same way. Since spaceship on enums looks at the underlying value, not at any user defined equality operator, it will be consistent with the current behavior of the template machinery.
So, your fix to a bad situation is to inject heap allocation into the core language?
When I read that part my immediate reaction was that this is an violation of the ODR rule. Is that a correct interpretation?
Take a look at the last example again. I think the early examples (with broken equality) were described to help the reader follow *exactly why* correct equality breaks with `Rational`. Specifically, if `one_half == three_sixths` (correct)... then, used as a NTTP, `denom_of&lt;one_half&gt; == denom_of&lt;three_sixths&gt;` (clearly incorrect)
A coroutine is just a mechanism. You can power it with anything suitable, like threads, fibers, or, better, thread pools. I like how it is done in C++ WinRT: a very little boilerplate code and now your I/O is powered by Windows Thread Pool and you have a nice coroutine-style interface to it. Windows Thread Pool (a so-called "new API", which appeared in Vista) is "fibers on steroids". In the nutshell it is a bunch of threads that take jobs from a queue and execute them. However, the kernel is fully aware of a thread pool and can push I/O completions, waitable objects and timers completions as well as some other events directly as jobs to the pool.
Yes, GAIA does a similar thing but with fiber per connection. The thing is that with fibers I can spawn background workers that not necessarily fit the reactive model of a web server and they still will fit nicely with other fibers. In addition, with coroutines, I need to adapt my interfaces for "co_await" requirements. With fibers I write code that looks synchronous without compromising my interfaces. In fact, my [FiberSyncSocket](https://github.com/romange/gaia/blob/master/util/asio/fiber_socket.h) is fully compatible with [SyncWriteStream](https://www.boost.org/doc/libs/1_69_0/doc/html/boost_asio/reference/SyncWriteStream.html) and SyncReadStream concepts which allows me to use Boost.Beast with this socket and get fiber-friendly synchronous http connections for free.
I am sorry, my OS is linux/posix ;)
What?
I liked the simplicity of usage. Also documentation needs details, thank you.
Nope, still not getting it. The author describes how he expects equality to work, then implements an equality operator that doesn't work that way, then acts surprised when it doesn't work the way he wants. WTF?
&gt; This new observation seriously shakes the foundation of C++2a’s support for non-type template parameters (NTTPs) of user-defined type. No it doesn't.
You asked for dynamically sized value semantics data. Maybe you didn't mean to. Maybe you didn't know what that means. But that means heap allocation without calling `new`.
Very good catch! You can force the same in current C++ versions with something like `struct Foo{};` `static_assert(!is_comparable&lt;Foo&gt;::value);` `constexpr bool operator==(Foo, Foo) { return true; }` `static_assert(!is_comparable&lt;Foo&gt;::value); // UPS!` &amp;#x200B; See [https://godbolt.org/z/4UV3WS](https://godbolt.org/z/4UV3WS)
Well, that's because C++ doesn't really have a proper parametrised type system, templates are not much more then fancy macros and operators don't have standardised semantics. I don't think it makes much sense to contemplate deep relations between type with such a fundament. So I too don't think its an issue. C++ will never have a sound type system, to do so would require a complete overhaul of the language.
I still don't agree. "strong structural equality" means that all used `==` operators are defaulted. This is obviously not the case for `Rational` or types with broken (hence defined) equals-operators. I do agree that this class is an example on WHY getting NTTP right is hard, but this only proves the point on why the committee did choose the conservative approach. So on topic: What is this article trying to show? Why does it claim C++2a should be delayed? To me it looks like all things are considered.
And it is. "strong structural equality", which is the requirement for NTTP, means defaulted equality. A mapping can be provided automatically: `auto &lt;=&gt;operator() = default;`
Where did I say anything about dynamically sized anything?
Which part of the standard library would you consider not expandable?
I think the word I wanted is "extendable" (sorry, not native English speaker). All the parts that predates STL, including the whole C standard library, don't have the nice composability of STL. For example, there is a lot of the member functions of std::string that could be useful with other containers but they only work with strings. By contrast, STL algorithms can be applied to many STL containers, including new ones that fulfill the iterator requirements.
P0732: &gt; At the core of the issue with allowing class types in non-type template parameters is the question whether of two template instantiations are the same, i.e. given `template&lt;auto&gt; int i;` and two values `a` and `b` of the same type, does the invariant that `&amp;i&lt;a&gt; == &amp;i&lt;b&gt;` if and only if `a == b` holds? Current language rules ensure that it does, and maintaining this invariant seems desirable for the simplicity and teachability of the language. &gt; Current language rules require both the compiler and the linker must be able to tell whether two template instantiations are the same or not, and so they must both be able to tell whether two values used as an argument to the same non-type template parameter are the same. This is typically achieved by including the values of all non-type template arguments in the mangled symbol name for the template instantiation, such that equality of the resulting string can be used as a proxy for equality of all of the template arguments. When we write code, we expect that if the template arguments compare equal, it will be the same instantiation. Richard showed that this is not always true in C++17. That code was made to demonstrate a point, not to expect a crappy equality operator to play nicely. In fact, the proposal is what said it would play nicely. That said, it's unclear to me how this renders P0732 unusable for NTTPs. It anticipates this problem and uses `(a &lt;=&gt; b) == 0` given an appropriate definition of `&lt;=&gt;`. I can live with enums not being uniform with every other type to avoid breaking code such that two instantiations with "custom-equivalent" enum values become the same instantiation. In order to understand the last example, you have to understand that there's been a large focus on making NTTPs *safe* and *doable with current technologies*. P0732 doesn't even let you implement your own spaceship operator and promise the compiler that it does strong structural equality. Per the above quotation, the compiler still needs the *value* so that it can mangle that value into the name; equality is not enough. In addition, comparing the mangled form of this value must be equivalent to comparing two objects of that class for equality. The last example discusses a more general notion of requirements on NTTPs. The author is saying that proposals going this direction need to be aware that they need to figure out a way of continuing to ensure that `&amp;foo&lt;A&gt; == &amp;foo&lt;B&gt;` iff `A (whatever equality comparsion they use) B`. The `Rational` class has a very reasonable equality operator. If a proposal is general enough that this equality operator makes `Rational` usable as a NTTP, that proposal needs to figure out how to avoid `denom_of` breaking this fundamental equivalence between instantiations and object equality.
The author explicitly brought up the `Rational` example in reference to alternatives that are less conservative than P0732. The reason given for talking about said alternatives in the first place was P0732 not being as conservative as we thought.
What would be the downside to using threads instead? E.g. with a mutex on any IO resource.
As I read the comment, the point is that we have the ability to allow `Rational` as a NTTP, but not per P0732. One way you could allow it is to provide an explicit mapping that turns the rational value into a (num, denom) tuple represented in lowest terms. The compiler would use this tuple for both name mangling and strong structural equality, which allows us to not rely on a user-defined `operator==` for NTTP purposes. This would handle complex cases like `Rational` as a more generalized form of P0732, where said tuple is exactly the bases and members of the class.
The first part of this was said in the article: &gt; But for enum types, Richard observes, we don’t have that assurance even today.
I can totally see where you're coming from and I would heavily agree that the STLs' design has stood the test of time (arguably better than any OOP-style design would have). I wouldn't go as far as declaring pre-STL parts of the standard library to be unextendable. The oldest non-C-stdlib library in the standard library by far is IOstreams and even it has been described as an "extendible framework"...
Indeed, the docs are fantastic and explain the concepts behind the library really well. They also look great -- can I ask what you used to create them?
Interesting work building upon (among others) the following earlier research: Christopher Jonathan, Umar Farooq Minhas, James Hunter, Justin Levandoski, and Gor Nishanov Exploiting Coroutines to Attack the "Killer Nanoseconds". PVLDB 11, 11 (July 2018), https://doi.org/10.14778/3236187.3236216 One example (from Section 3, Interleaving with coroutines): ``` // Listing 1: Binary search as a C ++ 20 coroutine. template &lt;bool suspend&gt; task&lt;int&gt; binary_search( vector &lt;int&gt;&amp; array, int value ) { int low = 0; int size = array.size(); while(size &gt; 1) { int probe = low + size/2; int v = co_await load&lt;suspend&gt;(array[probe]); if(v &lt; value){ low = probe; } size -= size/2; } if(size == 1 &amp;&amp; array[low] &lt; value){ low++; } if(array[low] == value) co_return low; else co_return -1; } ``` // Listing 2: Interleaving binary searches. template &lt;bool suspend&gt; vector &lt;int&gt; multiple_binary_searches( int G, vector &lt;int&gt;&amp; array, vector &lt;int&gt;&amp; values ) { vector &lt;int&gt; positions; for_each &lt;suspend &gt;(G, values.begin(), values.end(), [&amp;] (int value) -&gt; root_task { int position = co_await binary_search &lt;suspend &gt;(array, value); if(position != -1) positions.push_back(low); }); // assuming output in the paper should be positions return positions; } ```
Putting \`static\` functions in a header is a terrible idea... [https://github.com/Taymindis/wfqueue/blob/master/wfqueue.h#L399](https://github.com/Taymindis/wfqueue/blob/master/wfqueue.h#L399) This is UB, because you never call the constructor of \`std::atomic\` (Before C++2a, you still need to call the constructor, even if it's trivial and does nothing!). &amp;#x200B; I have not done a thorough review of the code, but [https://github.com/Taymindis/wfqueue/blob/master/wfqueue.h#L436](https://github.com/Taymindis/wfqueue/blob/master/wfqueue.h#L436) is definitely not wait-free...
Thanks for pointing this out. Got a new certificate last month but forgot to update the binding. Fixed now.
Ah, yeah. Then what's the problem? We're not introducing any new inconsistencies into the language, `tuple&lt;E&gt;` works exactly the same as `E` as a template parameter. Maybe the rationale needs a little tweaking, but that's hardly worth holding up C++20 over.
Interested for the allocation management. I can't read it now but I'd like to spend time on the paper. +) Without reading your comment I thought it looks familiar, and indeed the talk was related! :o
&gt; Putting `static` functions in a header is a terrible idea... Would you mind elaborating on more general examples of why this is bad?
I'm sorry I'm out of context. I still don't get why `&amp;foo&lt;A&gt; == &amp;foo&lt;B&gt;` should be true ever. These two instantiations are different objects they should be guaranteed to have different addresses?
From my other comment: &gt; That said, it's unclear to me how this renders P0732 unusable for NTTPs. It anticipates this problem and uses `(a &lt;=&gt; b) == 0` given an appropriate definition of `&lt;=&gt;`. I can live with enums not being uniform with every other type to avoid breaking code such that two instantiations with "custom-equivalent" enum values become the same instantiation. As for holding up C++20, that part is more of an addendum. The author has been including this sentiment in more recent articles. It's likely that the main purpose of the blurb is to make more people aware of his seemingly strong opinion on that matter and the basics of why he holds that opinion. I'm fairly sure it started with [this article](https://quuxplusone.github.io/blog/2019/06/26/pro-p1485/): &gt; Not just because one of the flagship features (Coroutines) is still undergoing major revisions; but also because the other flagship features (Concepts, operator&lt;=&gt;) are undergoing major revisions; other major features (Modules and constexpr new) are completely unimplemented; nobody can even agree on what one major feature (Contracts) means… &gt; Setting realistic deadlines is maybe an art, maybe a science, but regardless, the timetable must match the amount of work to be done. C++2a has a very big amount of work to be done, and work items of the form “implement and get user feedback on _____” aren’t necessarily parallelizable. &gt; When is the best time to catch bugs: while the product is in development, or after it has been released to customers? Either way, the gist of his argument is that there's still a lot of work remaining to resolve outstanding problems (in addition to things like zero implementations) with currently-accepted C++20 features, and he wants that work to finish *before* it ships because it's unlikely the results will be nearly as good if it's finished afterward. It's certainly not only this feature in particular that he's basing that on.
Only use the pointers if the chunks exist somewhere else. Prefer the first one if it will work for you.
Depends on many other things, including the typical size of the data vectors, the relatively static or dynamic nature of the data, and, more importantly, how you are intending to use them and the chunk groups. You might also consider storing them in lists, or vector&lt;unique\_ptr&lt;Chunk&gt;&gt; 's. On the whole I would steer away from the first method, with \`direct references'--which they are not, really, but that's another story.
``` static void foo() {} ``` If you put this in a header file, this function will be defined in all TUs (cpp files) that include the header, similar to C++ `inline` functions. The primary difference is that `static` requires that each definition is different, so the resulting binary will contain N copies of this function, where N is the number of TUs that use that function. Note that `static` member functions are fine, because `static` has a different meaning there.
The idea is that when `A` is equal to `B`, these should be the same instantiation and thus have the same address. One example given is `foo&lt;1 + 1&gt;` vs. `foo&lt;2&gt;`—different arguments, but equal ones. The `A` and `B` are meant to be different, but equal, objects. This is almost always true, but we know now that some enum types are an exception. In the cases P0732 covers, preserving this identity is really straightforward—Your type's value must be exactly the tuple of its bases and data members. For example, given a `struct Point { int x, y; };` and an appropriate `&lt;=&gt;`, you can have `constexpr Point a{2, 3};` and `constexpr Point b{2, 3};`. In this case, `&amp;foo&lt;a&gt; == &amp;foo&lt;b&gt;` and `a == b`. Despite `a` and `b` being different objects, they have the same value. The `Rational` example isn't allowed by P0732 because it defines its value as something other than the (num, denom) tuple, specifically a lowest-terms equivalent of said tuple. Working within this proposal, the compiler has no way to determine that it needs to transform the object in this way before it can mangle or NTTP-compare it. Another comment has suggested that it's not unreasonable to support these types as well; one way to do that is to *give* the compiler the transformation to this tuple representing the value and default it to what P0732 does now. In the case of `Rational`, that would be something that says "To convert `Rational` to a tuple representing its value, the result is `(num / gcd(num, denom), denom / gcd(num, denom))`." The compiler would invoke this transformation when it needs to perform name mangling on an instantiation or when it needs to figure out whether two instantiations are the same.
Generally speaking there's always more than 1 TU, even if you only bring one.
RE: "I tried linking different versions with an earlier linker and it worked" 1. Debug information might not have gotten handled correctly but you won't see that until debugging. 2. Nothing must have been using `/GL` / `/LTCG` because the IR between the FE and the BE is not stabilized.
So basically this is a constexpr optimization? this kind of violates a lot of my assumptions about objects.
It's worth mentioning in your blog post that if you want a native look when using QtQuicControls2, you should use [Qqc2-desktop-style](https://api.kde.org/frameworks/qqc2-desktop-style/html/index.html). Note that this works on Windows and macOS too, not just in KDE. (KDE Frameworks is not tied to KDE, it only has "KDE" in its name because they maintain it.)
Well, it's kind of an apples/oranges comparison to some extent because Rust is different enough that importing a certain feature from C++ might not make much sense. But compared to what you can do in C++ and what I would say Rust needs to "fully" compete with C++ are: * *const generics*: allowing integer constants as generic parameters. The implementation is partially done and usable already to some extent. * *impl specialization*: which allows a kind of overload resolution for trait implementations. This is also is partially done and usable to some extent. On top of that, I'm excited about: * *async/await*: Important for allowing async code to be written as easy as sync code. This feature is not only about syntax sugar (transforming sequential code into a state machine) but also lifts some API restrictions that are otherwise impossible to avoid (unless you open up the `unsafe` hatch, get your hands dirty and potentially add memory safety bugs). See \[1\] nad \[2\]. As for async/await/coroutines/generators, I know that this is being worked on for C++20, too. But last time I checked, one of the big differences was that the C++ approach forces a level of indirection onto the users because a `std::future` incurs the usual overhead for type erasure. Microsoft claims to be able to optimize this away but I don't really understand what's going on there. Apparently, this is also still a topic of debate. I remember seeing a paper that criticised this abstraction penalty. But I'm not up-to-date on this topic. In Rust, a function that returns some concrete type that implements the `Future` trait is already enough to be used and awaited on in async code. No type erasing wrapper needed. This allows composing futures in a way that the resulting future still has a flat memory layout for its combined state and there is a lot of optimization potential w.r.t. inlining. To me, this sounds more "zero cost" than the current C++ approach. I should refresh my C++ coroutine understanding again... :-) \[1\] [Async/Await I: Self-Referential Structs](https://boats.gitlab.io/blog/post/2018-01-25-async-i-self-referential-structs/) \[2\] [Async/Await II: Narrowing the Scope of the Problem](https://boats.gitlab.io/blog/post/2018-01-30-async-ii-narrowing-the-scope/)
Indeed, and personally it's something I really don't want to see in a build in general. Failing compilation because the database is unavailable, or because the schema changed since the last time the code was committed, is a cardinal sin in my eyes: I should be able to check-out a 6 months-old version of the code and compile it. This does not mean I am completely against ORMs, I just prefer a two steps process: 1. A step that connects to the database and writes down the schema. 2. A step that compiles the code against the written down schema. The important part of writing the schema down being that it can be checked in, and that I can compile against a 6-months old schema to do a git bisect if I have to.
I am curious at the handling of pointers. One of the issue with compile-time compilation is that compile-time functions are generally expected to be pure; you wouldn't want a program to fail to compile 2 out of 3 times because the `constexpr` function `roll_dice()` didn't return the "right" result. With that said, pointers are easily a source of "randomness" if handled incorrectly. For example, imagine that the "pointer" of an object is the pointer of its representation in the VM, different executions would yield different pointers. One solution could be to create a "in-VM" implementation of `malloc` which is entirely deterministic, but this is a maintenance nightmare: the result of any sequence of allocation requests must forever remain the same.
If we had sane (not intrinsically type-erased) coroutines, they wouldn't have needed to write a custom allocator... they could have just used an automatically-managed array of the coroutine's Voldemort type.
&gt; nower days nowadays? /r/BoneAppleTea ;)
I wouldn't call this an optimization in the slightest. It's the basis for correctness in determining how templates behave. I have a feeling you're conflating the address of the `A` or `B` argument itself with the address of the result of the instantiation. Looking at it from a different angle, suppose you have overloads: void foo(Bar&lt;2&gt;); void foo(Bar&lt;1+1&gt;); I would fully expect these to be the same overload. In addition, I would expect `constexpr int a = 2; foo(Bar&lt;a&gt;{});` to call this overload. The rest of it is applying this to user-defined classes and picking a required form of equality that behaves the same way.
 int x = 0; int y = 1; int* x_ptr = &amp;x; x_ptr += 1; // now x_ptr _might_ point to y1 // this is an UB free way to check: assert((uintptr_t)(x_ptr) == (uintptr_t)(&amp;y)); // If we are here, the addresses of x_ptr and y // are equal: assert(x_ptr == &amp;y); // UB 1 *x_ptr = 3; // UB 2 assert(y == 3); // UB 3 In UB 0, the pointers to two different disjoint allocations are being compared, that's UB, and the compiler can assume that it never happens, and optimize that to false since they can't ever be equal. The compiler is allowed to assume that, because UB2 is an access out-of-bounds of x, it cannot happen. In UB 3, the compiler is allowed to optimize that to false, because no pointer to y was created, and so its value is still 1 - unmodified. That is, a pointer value is more than the memory address it points to. Part of a pointer value, is to which allocation it points to, and C++ rules give compilers a lot of optimization leeway to assume in many cases, these two pointers cannot alias, therefore ... many optimizations become available (e.g. vectorization and what not).
Address of the _function_ for a function-template instantiation, for that example. :)
No I get it I think
Now I get it! sorry for being thick. Thanks!
With the unix command `strings`.
Thanks. Fixed
Eh. When you're on a release cadence you ship what you got. If anyone is allowed to hold up the release for their pet feature you end up getting more and more scared of the eventual release and it gets further and further away. If a feature isn't ready it's up to those who are pushing it to withdraw it. 2023 isn't so far away.
/r/cpp_questions
D user there.
Pointers in \`constexpr\` are very restricted compared to what you can generally do in C++. You can't observe their value right now, and I don't see this being loosened over time. They're effectively "handles" at \`constexpr\`-time. &amp;#x200B; What's tricky about handling pointers in \`constexpr\` is what they point at, and the associated lifetime management.
Ah, that makes perfect sense. Thank you!
Cool, works just fine again now. I think you should consider making https the default protocol. When one enters "[cppcast.com](https://cppcast.com)" into Chrome, it gets youto the http site. It would be good practice to in that case land on the https site by default. Also I think Google might prioritize websites higher that do this (but not 100% sure, not a SEO specialist!)
Also read this: https://stackoverflow.com/questions/47819719/static-inline-functions-in-a-header-file
A raw pointer in C++11 onwards basically means that it doesn't own the data it points to, so there's no reason to use it here unless your ChunkGroup structure is not responsible for it's chunks' lifetime and is merely a \`view\`.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c9h97c/nested_structures_and_pointers/esz4j53/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Its in the line &gt;!configure_package_config_file( "${PROJECT_SOURCE_DIR}/cmake/${PROJECT_NAME}Config.cmake.in" "${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake" INSTALL_DESTINATION lib/cmake/${PROJECT_NAME}) !&lt; I'm using the ${PROJECT_NAME} variable to find the file
Given: T t(u); // #1 T t = u; // #2 I can understand 1 compiling but not 2 and I can understand 1 and 2 both compiling and having the same meaning. Is there actually a motivating example for having 1 and 2 both compile but have different meanings?
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c9iysy/reading_string_from_binary_files/eszfhr3/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Thread creation and context switching are both much more expensive than fiber equivalents.
I get that, but how do you know what to fill the .in file with?
hindsight is 20/20
Had updated to removed static :)
So you're saying you're unhappy with the name STLSTL because it fails to give your collegues credit. This is laudable Have you considered co_STLSTL as a solution?
No one is going to care if your system failed under your "engineers" or your "developers". Not like news sites will check the degrees or care about accurate reporting.
OP. Getting a degree is great but the main thing is to do things and to care about what you do. Train both hard and soft skills. Work is not a technical vacuum.
Lol. If you provide value to an employer you're going to find work degree or no degree. There's so many people like that out there.
Maybe you have a terrible attitude.
There's a myriad of people with his "personal experience", though. And those of us who aldo have been on the other side and employed people didn't care either. It's a plus, the degree, but it's no filter and no guarantee.
Do you even work in a safety-critical industry? They absolutely would.
I don't care how many goal posts you guys try to move and I'm not about to dox myself but the arrogance and ignorance is staggering. Your assertions about being unable to get a good job in c++ for not having a degree are demonstrably false. Pervasively false around the world. Which is not to say it can't close some doors if you go about it the conventional way. Sure. But apt people are also apt at selling themselves and their value to employers and the relationship works great. Would I recommend a degree? If you can, sure, go for it. Is it going to be a stopper or put you behind? Nah. Not if you work hard enough and provide enough value (and know how to prove that).
What goalposts? My original statement was SOME jobs become unavailable, not all of them. And that isn't my opinion, that is a fact. Get over it.
No. You said a lot and the implication is that it's necessary which is BS. That's a fact. You're thinking your anecdote is better than everyone else's and extrapolating like mad. Get over it.
It's necessary where I work, which is a C++ dev shop. Thus my statement that doors will close if you don't have a degree becomes an objective observation, not anecdotal. I made that statement, and everyone with an axe to grind about hiring processes replied (including you) that they know of themselves, or others, who have gotten jobs without a degree. That's nice, I'm happy for you, doesn't change the FACT that there are jobs at companies, including the teams I've worked on, where you couldn't without a degree. It also doesn't change the rationale (which I didn't author, hence where I literally say "I'm not saying its justified...") by which my managers made that decision. Ironically, reading comprehension is something that you get tested on in college, who knew? Feel free to keep flailing in your replies, though.
The fact that you keep trying to insult the intelligence of anyone who refutes your points while ignoring that you're moving the goal posts with every response is staggering. Since you're basically a grade A jerk I'll just move on.
You literally called me both ignorant and arrogant like two replies ago, but ok.
d dose it better?
I actually liked your code, but I did funny a variation your theme with web C++ (what I call C++ SpartaScript). My app have a few bugs in library code (so much to do - so little time), but it should worked with current IE/Edge (if links to github pages works). \[teroxGuick single page application\]([https://teroxzer.github.io/guick/teroxGuick.html](https://teroxzer.github.io/guick/teroxGuick.html)) ///////////////////////////////////////////////////////////////////////////// #include &lt;webui/spartaWebUi.hxx&gt; namespace terox::guick { ///////////////////////////////////////////////////////////////////////////// class Guick final { public: Guick(); private: auto updateBoard(UiPoint) -&gt; void; struct Self final { UiFrame frame {}; UiLabel title { "teroxGuick" }; UiLine hline {}; UiGraph board {}; UiLabel help { "Click to add or toggle a point" }; UiLine fline {}; UiLabel count {}; UiButton discard { "Discard" }; UiButton close { "Close" }; Vector&lt;UiCircle&gt; circles {}; } self; }; ///////////////////////////////////////////////////////////////////////////// Guick::Guick() { self.frame = { self.title .geometry( 1, 3, 4, -3 ), self.hline .geometry( 4, 3, 4, -3 ), self.board .geometry( 5, 3, -4, -3 ), self.help .geometry( -4, 3, -3, -3 ), self.fline .geometry( -3, 3, -2, -3 ), self.count .geometry( -2, 3, -1, -17 ), self.discard .geometry( -2, -16, -1, -10 ), self.close .geometry( -2, -9, -1, -3 ), }; self.title.onClick = [] { UiApplication::toggleFullScreen(); }; self.close.onClick = [] { UiApplication::exit(); }; self.board.backColor (kUiColorCornFlowerBlue); self.board.color (kUiColorLightSkyBlue); self.board.onPoint = [this](UiPoint point) { self.board.begin(), updateBoard(point), self.board.end(); }; self.discard.onClick = [this] { ~self.circles; self.board.clear(); self.count.clear(); }; } ///////////////////////////////////////////////////////////////////////////// auto Guick::updateBoard(UiPoint point) -&gt; void { auto constexpr radius = 8; auto const size = self.circles.size(); for(auto i = 0; i &lt; self.circles.size(); i++) { if(self.circles[i].contains(point)) { self.circles.remove(i--); continue; } self.board.draw(self.circles[i]); } if(self.circles.size() == size) { auto circle = circleOf(point, radius); self.circles += circle; self.board.draw(circle); } self.count = format("Count: %", self.circles.size()); } ///////////////////////////////////////////////////////////////////////////// } // namespace terox::guick ///////////////////////////////////////////////////////////////////////////// auto webMain() -&gt; void { UiApplication::run&lt;terox::guick::Guick&gt;(); } /////////////////////////////////////////////////////////////////////////////
I think this "transformation", if exists, is a good footgun. Consider constexpr Rational one_half{1,2}; constexpr Rational three_sixths{3,6}; constexpr auto denom_of_one_half = one_half.denominator; constexpr auto denom_of_three_sixths = three_sixths.denominator; template&lt;Rational X&gt; int denom_of = X.denominator; it seems reasonable to expect - `denom_of_one_half == denom_of&lt;one_half&gt;`, and - `denom_of_three_sixths == denom_of&lt;three_sixths&gt;` , but if `denom_of&lt;one_half&gt;` is the same variable as `denom_of&lt;three_sixths&gt;`, then how can this work? The right way, I believe, is to **fix `Rational` so that equality really implies substitutability**: if `a` is equal to `b`, then `a.denominator` must be equal to `b.denominator`.
&gt;The STL is now part of the standard library This is similar to saying that boost and {fmt} is part of the standard just because some parts of the standard library is heavily influenced by those libraries.
Thank you for the link and insights!
... but use `filesystem` instead.
Ranges will be in c++20, and in a similar fashion I suspect people will still refer to it as ranges. Most of the libraries from boost that make it in to the standard are smaller in scope (eg variant, optional, etc), and their name roughly maps to the classes they add.
&gt; You can't observe their value right now, and I don't see this being loosened over time. Good to know! And I agree, for the reasons enunciated above it seems hard to ever lift this restriction. Well... theoretically, it would be possible to only make *some* bits unobservable. Specifically, it would be reasonable to assume the N lowest bits are 0 when the alignment of the type is 2^N . Encoding *that* in the type system would be a tad complicated, but could allow code which uses said N bits to stash values: for example `optional&lt;T*&gt;` having the same size as `T*` by stashing its discriminant in the lowest bits whenever T has an alignment of 2 or more.
I don't know if there is, but I don't exactly see your point arising from this blog post.
&gt; iostream.h
Why do Indians like writing guides/tutorials so much even when they are barely novices themselves in the field?
One thing I just realized that we both got wrong. It's supposed to remove the one that's clicked. But, if there's overlap, since we both search from the bottom forward, we would remove the bottom-most one that was intersected, not the top-most one which is what should happen.
&gt;I suspect people will still refer to it as ranges. I think so too, but it's a bit different because it's a name that the standard itself uses. The section that talks about it is titled **"Ranges library"**, the header you include is **&lt;ranges&gt;**, and all the functionality is inside the **std::ranges​** namespace.
candidates with tech blog and opensouce project could have more chance in IT recruitment nowadays. Although, the recruiters probably don't even read the blog.
As far as I know, Windows has macros for these functions to allow utf8: `DeleteFile(...)` will be expanded to `DeleteFileA(...)` for ASCII and `DeleteFileW(...)` for `wide char`. ---- &gt; If the directory is successfully deleted the function returns a TRUE or else FALSE. First of all, we are speaking about files, not directories. And even if it says `BOOL`, it's actually an number. It returns 0 on failure and non zero on success. &gt; `IpFileName` variable is given address of the file to be deleted. I think you wanted to say that it has the address of a null terminated string that represents a path to the file. &gt; You may have noticed that when you copy an address in Windows, By default we get Z:\ for Z drive Uh? You just get the absolute path. If it's on the Z: disk, then you get Z:, otherwise you get the letter of that specific drive.
In the end, I think your solution does pretty much the same thing as far as the user is concerned. That is, if a compile-time `denom_of&lt;R&gt;` is going to transform it to lowest terms, I would also expect that a runtime `R.denom()` accessor would do the same. The decision is whether to reduce fractions as they're created or as needed later on. Which you choose can be important for different use cases, but it's a choice that's encapsulated by the class so the user needs to read the documentation. It's a funny situation, though. It does seem logical to have `Rational{3, 6}.denom() == 6`. At the same time, it also seems logical to base equality on the mathematical rational value regardless of individual numerator and denominator. So it makes sense to me that a regular `denom_of(Rational)` function would both always produce the same result for equal rationals and also not necessarily do that. I don't know which ultimately feels more right. Perhaps the real solution is to not access the denominator at all from outside the class. Is it really necessary? However, applying that logic to another example, the characters of a case-insensitive string, seems harder. If you use a case-insensitive string, are you ever concerned about its particular value representation, or are you always going to use its value as a whole? I'd be really interested in hearing from people with more mathematical background and/or experience. I know John Lakos gave a huge talk about values, and I'm 99% sure he's run into an equivalence-based class where there's more than one representation of the same value.
It's a very interesting blog, they even talk about Spiderman, Tea, Landscapes, Arduino, C, Android etc. Maybe haven't had the pleasure to find a post of some arab kid that copy/pasted the repository of another fellow r/cpp user and simply posted it here by telling he created it. Not a fork uh, he downloaded the repo as zip, removed all the License/Author stuff from the file, then created his own repo and committed *his* work.
&gt;think you wanted to say that it has the address of a null terminated string that represents a path to the file The last line was copied from my older post, I made a mistake, didn't change the function name and what it does. It's just a blog run by me and my friends which documents everything we experience and learn , I am just learning these things so forgive my way of writing and mistakes. Thank you for pointing out my mistakes . It really is a big thing you read my post, I promise you I will improve my writing.
What you said was 100% right, I am new to this windows programming. I am creating my own documentation of things I am learning and experiencing . But someone somewhere will find it helpful for sure, may be a beginner like me. Reddit users really helps me with the mistakes I make in my writing and lack of knowledge, Sometimes it's by advices and sometimes by criticizing and teasing. But I like at least they bother to look and correct me in some way. The sole reason why I am blogging is, I get good grasp what I just learned about and Why I post it on good groups like this because, Most of the people care to look it and appreciate or correct my mistakes most of the times.
No dude recruiters don't give a shit about your blog. Good contributions to open source would have a chance. I don't know about all the Indians but for me this is a great hobby and posting it on reddit will correct my mistakes so I can learn more. In my college there is a community for coders and developers and what I learned from there are most people who are excellent coders there are so humble, They will give you any information about the topics they knew, they help in projects and they contribute and help more. I like the way they do things and their giving mentality. So I think blogging/document is really a nice habit .Even if I make mistake while blogging there are people to correct me, That's awesome right.
http://www.cs.technion.ac.il/~erez/Papers/wfquque-ppopp.pdf &gt; A highly desired property of any concurrent data structure implementation, and queues in particular, is to ensure that a process (or a thread) completes its operations in a bounded number of steps, regardless of what other processes (or threads) are doing. This property is known in the literature as (bounded) wait-freedom[.] If i understand correctly, a CAS loop can be influenced by what other threads are doing, so how is this a wait-free implementation? My understanding is that wait-freedom guarantees that a single thread will successfully complete its operation in a fixed number of steps, regardless of what other threads are doing. Aborting after a given number of tries on the CAS operation is not successful completion, even though it guarantees an upper bound. If one of the participating threads gets suspended and because of that other threads cant complete their operation, the whole algorithm is not wait-free either (i disagree with the claim that the queue presented in the paper i linked to is wait-free). Moving the loop into silicon also doesnt make an algorithm wait-free. Just because you see only a single instruction in the generated assembly doesnt mean that the instruction will not take an arbitrary amount of time to finish.
Forwarding explicitness only matters for types like `A` (from blog post), where explicit and implicit construction do different things.
It might just be a function of when someone first starts using c++, but the STL was around for a decent amount of time before becoming part of the standard, so for many people there’s a clear division. Also, by argument, if they named STL differently, you would be okay referring to it as an entity within the standard. While that is true for std::algorithms, most likely because they are free functions, we never got a std::containers namespace or std::iterators.
Example input file?
Maybe I take this too seriously, but I have hot fix now: auto Guick::updateBoard(UiPoint point) -&gt; void { auto constexpr radius = 8; auto const size = self.circles.size(); for(auto i = self.circles.size(); --i &gt;= 0; ) { if(self.circles[i].contains(point)) { self.circles.remove(i); break; } } for(auto const&amp; circle : self.circles) { self.board.draw(circle); } if(self.circles.size() == size) { auto circle = circleOf(point, radius); self.circles += circle; self.board.draw(circle); } self.count = format("Count: %", self.circles.size()); }
Someone found an embarrassing mistake lol. Account deleted.
ASCII -&gt; ANSI, it’s a pretty important distinction (for example DeleteFileA works fine on Japanese systems with Japanese file names when the codepage is set correctly, with ASCII that wouldn’t work).
I actually feel that coroutines are more unneeded complexity, since they seem to mostly be a substitute for just making a few threads that pick up state and a function to run. It seems to be more being packed into the language when it doesn't need to be a language level solution.
yeah my dumbass did I was reading line with getline then remove the tabulated space between a letter and it is morse representation. So basically I screwed up the indexing... [https://i.redd.it/a7nt1vculh431.png](https://i.redd.it/a7nt1vculh431.png)
This is an interesting use case that I don't encounter much in my day-to-day coding. Does this use the *MBCS* character set project setting (the other two being *Not set* and *Unicode*)? Is the string passed to **DeleteFileA** UTF-8 encoded or is it some Windows-specific encoding?
No, D's [Fibers](https://dlang.org/phobos/core_thread.html#.Fiber) are stackful, and so not really comparable to C++ coroutines. I was thinking more of Rust's [Generators](https://doc.rust-lang.org/std/ops/trait.Generator.html), which are stackless (like C++ coroutines) but aren't inherently type-erased, so they each have their own type and don't have virtual call overhead (unlike C++ coroutines, but just like C++ lambdas).
&gt; `--i &gt;= 0` Good way to blow up with an unsigned index type – maybe you want `i-- &gt; 0`.
Also stuff like `static constexpr auto MY_CONSTANT = 5` is fine as well, because it's evaluated at compile time.
Agreed.
Oh thanks, I forgot the meaning of A and just used intuition 😅
It is encoded in whatever code page you set (utf8 was added as a semi-possibility in Windows 10).
Always nice to see ways to get machines to do the grunt work so we aren't wasting dev time and energy on it.
You would need to look into ELF weak linkage, which is one of the key things which DLLs can't provide. Static class members for regular compiled classes, are typically defined in a single translation unit and are exported as symbols alongside the class methods. However, for header-only static class members, particularly templated header-only classes in the context of the STL, this ends up with their being multiple instances in multiple translation units, as well as within multiple libraries making use of the same template specialisations in their public interfaces. The same also applies to the method functions as well, but the statics are particularly problematic. ELF weak symbols allow only one instance to be used by all libraries and the main executable, even if the symbol is exported by multiple libraries. This allows the ODR (one definition rule) to be satisfied. DLLs end up with one copy per DLL, so each DLL is essentially its own world with no ability to see what other DLLs see. This is problematic for other symbol types too, including typeinfo objects and comparisons, which can cause problems with e.g. catching exceptions and dynamic casting.
That is a generic file that includes the generated target-file and calls Check_required_components (privided by cmake itself) for the project. See here: https://github.com/bernedom/SI/blob/master/cmake/SIConfig.cmake.in
Where is mastermind.cpp coming from? Why not compile in one go?
Why did you use a string vector instead of int? Using int would’ve wasted less space, -1 representing empty cells. Also std::find is not the best way to go.
The type in the blog post is silly. Generally it doesn't make sense to disallow implicit conversions from one type, but allow them from a second type which the first type is implicitly convertible to. For the reason you show: it makes those two initializations behave differently. If construction from int is explicit, construction from long should be too, and vice versa.
Why would I review your source when you didn't even double check your title?
Oops sorry this had started in a small folder with a few basic projects and then i decided it warranted its own folder. And I copied my readme from a mastermind game I did
I used String because I wanted to store all possible options that were available, but to do that I would’ve needed a vector to represent that and it added complexity over just using a string (I tried). I had been using ints for it when it was just the game, but for the actual solver I decided that strings were easiest, especially since I was basing my plan off of python code.
Hi, not exactly, but tks.
You should compile with warnings enabled. That would warn you that your \`dfs\` function returns the local variable \`state\` by non-const reference. So when the function exits \`state\` is destroyed and you get a dangling reference.
Thank you that’s very helpful!
/r/cpp_questions
Because there is Windows. That's where client applications live.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c9wnkc/i_built_a_sudoku_solver_using_depth_first/et55sjc/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
your benchmarks are not as good as MoodyCamel's: http://moodycamel.com/blog/2014/a-fast-general-purpose-lock-free-queue-for-c++#benchmarks Even his benchmarks don't include latency numbers, which are not satisfactory.
What happens when you try it?
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/ca3y2g/answer_please_what_does_f5_evaluates_to/et5ofcn/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/ca3rgw/how_can_i_display_the_cout_of_total_sales_after_i/et5om6e/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
* Ask this question in the proper place. E.g. /r/cpp_questions * Always post your code. Screenshots are useless. * Give a quick explanation of your code. What it is supposed to do, what it actually does, etc.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/ca52iq/c_tutorial_for_beginners_any_recommendations/et5vkjb/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Buckys C++ Tutorials. They are a little bit old, from 2011 or something, but the clips are short and compact and they give you a really good introduction into the language itself. He uses CodeBlocks as the IDE for the tutorial clips, I would recommend going for something more up to date like QtCreator, NetBeans or VisualStudio.
What error messages are you getting? Also for the if statements, R and P need single quotes because they’re chars. Sorry but I’m on the phone app so I can’t give you the best answer.
I’m actually not getting an error message but the only thing that shows up after compiling is just the introduction but I believe the single quotes might fix that so I’ll try that again tomorrow. Thank you for your feedback!
You're not initialising your R, P, S characters -- they're not going to be "R", "P" and "S", they're going to be indeterminate. The R and P in your main() are also going to be different from your R and P in computerChoice(). To be honest, you don't need to use a character at all - I'd use an enum instead. Try something like #pragma once #include &lt;iostream&gt; enum class Option { Rock = 0, Paper, Scissors }; void introduction(const std::string&amp; objective, const std::string&amp; directions); Option computerChoice(); int main() { string objective = "template for C++ programs and to test code"; string directions = ""; introduction(objective, directions); switch (computerChoice()) { case Option::Rock: cout &lt;&lt; "rock"; break; case Option::Paper: cout &lt;&lt; "paper"; break; case Option::Scissors: cout &lt;&lt; "scissors"; break; default: cout &lt;&lt; "unknown option"; return 1; } } Option computerChoice() { srand(time(0)); //initialize random number generator return static_cast&lt;Option&gt;(rand() % 3); } The " = 0 " in the enum ensures that Rock is 0; the others count up from there. Then the static\_cast in computerChoice will automatically map across without you having to mess around.
char R,P,S are all not initialized. But you can do something like this. ``` int main() { //Data string objective = "template for C++ programs and to test code"; string directions = ""; //program introduction introduction(objective, directions); //random number generator if (computerChoice() == 'R') { cout &lt;&lt; "rock"; } else if (computerChoice() == 'P') { cout &lt;&lt; "paper"; } else { cout &lt;&lt; "scissors"; } }//main char computerChoice() { //data srand(time(0)); //initialize random number generator int compPlay = rand() % 3; //random number generated if (compPlay == 0) { return 'R'; } else if (compPlay == 1) { return 'P'; } else if (compPlay ==2) { return 'S'; } } ```
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/ca59rc/i_am_new_to_coding_and_i_been_trying_to_get_this/et5xa91/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Refactoring becomes danger thing. After for example renaming method that called from QML, you can not just compile and make sure that all works fine. You need open and run all windows/dialogues.
You mostly right, the main difference is that for do/while you know for sure it’s body is executed at least once, while/do can be totally skipped
Ohhhh. That makes much more sense to me know. Thanks
You are partially correct. They are mostly the same thing, but do while loop is guaranteed to run at least once, regardless of its condition. On the other hand while loops may never run if their condition is initially evaluates to `false`
C++ is just a modern more responsive version of C which is one of the first programming languages created and yes if you learn C++ then it will be extremely easy for you to learn C. C++ is a object oriented language meaning that it can be used for graphics and games. While on the other hand C is not making it almost impossible to actually program a 3D game or graphics.
Same thing as a while loop, except it forces the loop to execute its first iteration. After that, it goes back to the traditional while loop based on the loop's condition.
There really aren't any concrete situations where you would always use `do while`. It's more of an on the fly decision. For example, i use one in a program i wrote for parsing csv files. Normally if you are looping through lines in a file you do something like: while (std::getline(inputStream, line)) { /* do stuff */ } But in my csv parser, i want to do some pre processing on the first line which i expect to act like a header. Then, i parse that line like the others. So use a `do while` like this: if (std::getline(inputStream, line)) { /* process header */ } else { /* handle error */ } /* now, the first line has already been read */ do { /* process current line */ } while(std::getline(inputStream, line));
I'll try simplify it. While: if condition is true, execute the code in the loop, repeat. Do while: execute the code in the loop, if the condition is true, do it again, repeat. Basically with do while, condition checking happens at the end, so you are guaranteed at least one iteration. E.g. while(false) {} won't be executed a single time, since the condition fails,l. Meanwhile do {} while(false) will execute once.
Looks like the other replies adequately resolve this. If you have more questions feel free to post on /r/cpp_questions. Happy learning!
Do...while loops are always used when it's body is needed to compute value featuring in the condition block. For example, if you need to generate unique value that doesn't exist in DB yet (but there is a reasonable chance for potential collision).
They have a strange use for large codebases that use macros heavily. #define MACRO_NAME(Var) \ do { \ // macro body is in its own scope \ } while (false) Very useful, since just opening and closing curly braces aren't valid syntax in as many places as a do while, but the do while is valid in all places the opening/closing braves are.
As an aside, in practice, whenever I start by writing a `do`\-`while` loop I almost always end up rewriting it as something else. It usually helps me to write it as: while (true) { statements; if (!condition) break; } and then figure out what is going on with the exit cases, and what needs to be done before and after them. Part of the problem is scope. Code like: do { bool condition = evaluate_condition(); do_something(); } while (condition); won't compile because `condition` is destroyed before the condition is tested. As I am comfortable using `break` statements and early `returns`, if `do`\-`while` were removed from the language I wouldn't miss it.
Oh yeah I've seen that before. That probably sees a bit more use in C, but great example.
Usually when writing a loop you have a setup step above it. // Setup code while (/* condition */) { // Loop code } Every once in a blue moon I find the setup code and the loop code are identical, but the first condition check still needs to be after the setup. Avoid code duplication by changing over to a do while in these cases. do { // Loop = Setup code } while ( /* condition */);
Why was the question by op deleted?
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
I see! This is one particular aspect of the shared library "problem" that I didn't or rarely found mentioned in online material. Thanks a lot for the explanation and pointers.
It's even worse than that: If an `inline` or template function in that TU refers to that function then it's an ODR violation waiting to happen (since the meaning of the function will not be consistent across TUs since it'll refer to different functions as `static` causes a new version to be emitted per TU).
Switch to Linux or use conan...
To be honest, I tried. I know benefits of linux, cmake's install mechanism seems a little bit broken for windows (it works, but not fully as it can). I tried, but... Seems like I get addicted to Visual Studio and its autocomplete too much... :( Conan, if I understand correctly, always needs a python. Well, for hobby projects it seems to be okay, but if I will share my project via github I think it is not good idea to force others install python and use conan. Usage of hunter is much simpler in my opinion, cmake can download everything automatically + users can disable hunter if they want. In other hand, conan's dependency database is much bigger...
That looks like a problem related to your specific "dependency soup", and is not really c++ specific. If you use the same libraries often, you should probably install them globally on your machine. That should be good enough for proof of concepts. If the program turns into something more serious, then you can fix the dependencies properly.
The simplest way would be to make one template project that has most of the stuff you use for anything you're interested in using. Unfortunately, some libraries you want to use might be huge or incompatible, so you might make separate template projects for those. As far as pulling in and integrating random crap from github or wherever, that is often difficult in any language. C++ may have some of the highest average startup overhead due to the diverse ways people write it and build it. If you want to use a project that depends on other projects built from source, you've got even more potential problems. I have just come to accept that when I want to use something new, I have to allocate considerable time to figuring it out.
That's true. I decided to post into cpp, cause other languages like C# and python has big centralized dependency managers so they don't suffer because of such problems... I think, dependency management is still the biggest problem of C/C++?
Setup one catch-all repo with a single build system, and just add new proof of concept projects to it.
I use cmake in my current project. There are a few ways to handle dependencies. &amp;#x200B; For Google Test, I have cmake download it and build it. &amp;#x200B; But for Boost, that would be nuts since it's so big! So, I installed Boost via homebrew and tell cmake just to find it. &amp;#x200B; Some people also like to use git submodules. I don't, but it's an option.
Try vcpkg &amp; Visual Studio.
Qt Creator has excellent auto complete support. It uses clang code model now, so it is pretty much perfect...
&gt;Seems like I get addicted to Visual Studio and its autocomplete too much... QtCreator and CLion both have really good auto-completion and work natively on linux (and they're cross platform, so you can still use them on windows). I know switching IDE's is a pain, but it might be worthwhile if you end up needing a good cross-platform IDE.
And also vscode...
I don't have a much better solution for Windows, it's still a pain after all these years I've dealt with it. Package managers on Windows is just another level of Hell for me.
If your using Visual C++, you may want to look at nuget. I haven't used it personally, but it was Microsoft's answers to dependency management in .Net. Looks like it's an Apache project now.
I used CLion when I was a student. As I remember, this IDE eats RAM like crazy and trying to regenerate the whole project after every change in CMakeLists.txt (and sometimes this process took too long). But yeah, I loved how good its autocompletion
The way I usually do this is to include third party libraries with my project and statically compile them. This is easier to do for some projects than others, but I've definitely done it for assimp hundreds of times. Glew is easy because they include pre-built binaries for Windows, and it's included with pretty much all package managers on Linux. glm and stb_image are just headers, so just throw those into your source directory and your good. I don't know why you would use Gli if you're already using stb_image. Don't know anything about OpenCV. As for a build system, I just use basic Makefiles most of the time. I find that most people don't actually know how to use them properly. When you do learn, they can be incredibly powerful and portable. Sure, they can become unwieldy after a certain point, but 99% of the time they're fine so long as you keep your project structure organized (which you should be doing anyways). Setting up a project from scratch like this takes far far less than an hour. If you really want to maximize efficiency, then you can just create a template after you set it up the first time. If you opt to statically compile all dependencies, then you won't have to worry about things breaking 10 months later.
I tried once porting out CPP simulator to windows. After 20gb of downloads and after trying cygwin, msys, visual studio, I gave up after a week. Couldn't muster the courage to try again. Fortunately, I just tell people to use WSL. Not that packaging for various flavours for Linux was a pleasing experience but open build service came to rescue.
You don't have to live with broken dependencies or, god forbid, install them for every single project. Someone already suggested managing them globally so this doesn't happen. I don't get why you spend 1-2 hours repeating "old code for initialization" when you can just copy-paste it.
/u/wfdctrl, thank you for your answer. Conan indeed a good solution for test projects, so I will take a look at it once again
I found a problem in this, but I'm also not able to copy code off your site. That is annoying as hell. I copied this from the comments: ``` constexpr bool operator==(A::E, A::E) { return true; } constexpr bool operator!=(A::E, A::E) { return true; } ``` Do you not see the problem? You have defined `operator!=(A::RED,A::RED)==true` which will never trip that `static_assert` in `Boom`. So it's not "Surprise! This is OK!" at all...
I never thought about this in such way, for some reason I was thinking about creating one custom framework and then attaching it for every "test project"... Your solution to the problem is much smarter than mine idea, it will get rid of the installation phase of dependencies (cause they will be already installed) Thank you very much for the answer, I will try to make a "Sandbox" solution with everything I need. It will consist of tiny test projects AND custom wrappers to reduce code repeating
I install the -dev from the package repository, through my distro's package manager. The few times I've done much dev on Windows, I've end up with my own mini-repo of 3rd party libraries, added to as needed. On the Windows side of the product I used to work on, anything that was part of a Windows SDK was just locally installed on the dev machine, and all the 3rd party stuff was checked into the source repo (CVS, then transitioned to Perforce).
And that’s why the whole monorepo thing is still alive and kicking in 2019. There seems to be no simpler way to reuse C++ code.
Vcpkg might be an option to handle dependencies if all your libraries are present.
It's gotten faster, but it'll still take some time "indexing" sometimes, and it does require a (partial) re-index after any change to a `CMakeLists.txt`. I personally don't like Visual Studio as too much of the build is configured via checkboxes and menus. But I admit CLion has more "wait a minute" kind of interruptions.
If you're familiar with CMake then CLion is an IDE that works really well on Linux. AFAIK it only supports CMake as a build system tho (last time I used it was in 2016)
I can recommend haxe for making something quickly.
Another proof C++ dependency managers all suck. Just avoid them.
The problem you're describing is one of C++'s primary weaknesses as a language/ecosystem. It's both "under specified" in the sense that you need additional information outside of the C++ source code to compile it (include directories, linker arguments, etc.) and "over specified" in the sense that it's easy to accidentally make code 32/64 bit specific despite the algorithms and language theoretically being able to compile to either. Everything from the long build times to the compilation model to the lack of unified packaging and module systems goes against it being easy to spin up cheap prototype projects. &amp;#x200B; You can look at a lot of the innovations of Java (particularly early Java) as a counter-reaction to this. Jar files, bytecode vm, etc. Now, Java has it's own problems and I still prefer C++, but I think it's instructive to compare and contrast the two and ask why each took different design decisions.
On vscode, the autocompletion is fragile with official [Microsoft cpptools extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools) and it occasionally stops working for me. I have switched to [clangd extension](https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd) and it is way more smoother and smart.
Don't submodule. Use Google repo or similar
Learn modern C++ first, it's easier
With cpp tools the biggest problem i had was related to symlink. Anyway I'll try clangd...
Docker + CMake + Vcpkg I have a little template I put together here precisely to setup a new project quickly. I really should update it to include the Windows builds. Unfortunately Microsoft do not offer out of the box Docker containers for Build Tools but you can set one up without too much trouble. https://github.com/londey/cpp-lib-template
I'd go further and recommend that you use one of the production-ready monorepo build systems such as Google's bazel or Facebook's buck. There's no versioning because everything - including external dependencies - are fetched from within the monorepo. It's some effort to set up, but once done, there's no simpler way to create a new project and reuse code.
Boost Beast is too low level for application development. You need to build a high level library around it and that will take you ages.
I'm not sure I see the purpose. Where is such ```do { } while(false)``` better than simply ```{ }```?
Vinnie Falco, the author of Boost.Beast, said that Beast is designed for libraries developers. Consider something more high-level.
This project, indeed, nice But it is not a good idea to pass data by copy when you can pass it by reference. I made a pull request, please check: [https://github.com/mrtkp9993/AnomalyDetectionCpp/pull/2](https://github.com/mrtkp9993/AnomalyDetectionCpp/pull/2) Also "-Wextra" flag won't work on Visual Studio and will cause a compilation error
Yes, I'm well aware that I need to build a high level library over it, and it will take ages but the time it would take seems imposed instead of a choice. Like, if I care about performance then I would drop HTTP altogether and use plain Asio sockets and/or change protocols to UDP and use raw data, if I wanted to build a critical environment application then I would add more physical redundancy and run time checks, if I wanted only to care about high level business logic then I would switch languages, but let's settle for "general use" as a web service, some bigger than others but for that purpose it ask too much and I don't know if is worth it. And that's why the third final question: &gt;• Which are the uses cases of Beast? It feels to simple for anything “high level” as a web service, and too complex for low level performance. Because I don't see where is the "real life application".
I’ve been building up a “new project template”. I’ve been wary of putting it in a git repo, which is incredibly stupid—I could just delete the git stuff if I want a fresh history. Lots of commented-out code you *might* want to use, but can delete if you don’t. This, at least, is a great solution anyone can semi-quickly implement. Eventually, I want to create a project generator using simple hierarchical text substitution as delineated in YAML files. Hopefully, I can make it compatible with [Ultisnips](https://github.com/SirVer/ultisnips) snippets. If I get it working, I’ll add even more ambitious features.
I suggest the following which is hosted as opensource: [CPP-Data-Structures-and-Algorithms](https://github.com/PacktPublishing/CPP-Data-Structures-and-Algorithms) [Open data structures](https://opendatastructures.org/ods-cpp/)
What do you mean with "libraries developers"? What kind of developer would need this? and what would they wanted to build? I'm really curious, I don't want to sound mean, but between handling the message and the business logic shouldn't be a process so complicated that I would need to build a high level library too big for me to handle, even if is highly specialized for one task.
This might be too Linux specific but consider distro only installs when at all possible. When not possible instal globally as somebody above suggested. For personal projects I really don’t care what the rest of the world is doing nor do I care about their install issues. If I want to use Python I use python. If the project ever makes it to the outside world refining it for a distro is now much easier. If it doesn’t my support effort is minimized.
Leveraging the distro is certainly the way to go on Linux. These days with large “drives” it is fairly easy to install the developer packages and even the documentation with out a huge storage burden.
A library developer is a developer that develops libraries for other developers to use. Beast is primarily a websocket library, with only as much HTTP handling implemented as is required for that.
If you can afford to roll your own stuff, Beast is absolutely worth it
libCURL
Use the `-o my_command` compiler flag to give your executable file a name.
Boost beast really does have terrible compile times, but generally what you want to do is wrap it in a higher level api Contain it all to one file which wraps whatever functionality you need, and then ensure that you never ever need to modify it to do your actual application logic
It is not as easy as it sounds because of the way C++ works. To make the type concrete, you need to make decisions very early in the compiler. That means you lose the ability to do a lot of optimisations - for example, you can't inline one coroutine frame into its parent, which means that at the point where you do have to heap allocate, you don't have a size for the nested coroutine you are allocating. Type erased coroutines are optimal in most cost that we're aware of, but fall down in cases where knowing the type in advance would be beneficial. Concretely typed coroutines would solve a different set of use cases well. With current compiler design, nobody is sure how to make coroutines optimisable and concretely typed.
Just a quick question - does this work with `cpack`? I tried with my project to implement similar, and while it works for `make install` and `cmake --target install` etc, I cannot figure out how to get it packed into the packages generated by `cpack`.
I never programmed on Windows, but what you describe is the expected behavior on Mac, Linux and everything that exists. If you don't provide compile options by default the binary name is a.out and to run a program that is not in the PATH you have to type a relative or absolute path to it. If you program is in the current folder: ./a.out If it's in a subfolder named bin: bin/a.out Usually one would compile with at least "-o myprogram" to specify the binary name. And probably "-std=c++17" to pick the C++ version you work with.
It's specifically more useful if you need to return out of a macro; with just `{}`, you don't know what the right syntax will be to stop execution within the macro. With `do{ } while (false)`, `break` is your answer always.
Although C++ is my favorite language, I still choose Golang if it involves the development of HTTP Rest services. Boost.Beast This library is very powerful, but not easy to develop, and still does not support HTTP 2.0. You need to deal with some other problems yourself, such as when you want to get data from the database, using Asio to establish an asynchronous connection with MySQL is a bit cumbersome, different library non-blocking models are inconsistent, these database connectors either use libuv, or use libevent or native Poll, but there is very little support for Boost.Asio, which requires your own careful handling. (hiredis asynchronous support libuv libevent does not support Boost.Asio)
Maybe just use M$'s LSP server for C/C++?
Curious as to why you develop C++ on Windows? Seems Linux is superior in every way for it, hell even *nix.
I've used cquery and ccls. I've had the most success with ccls. Basically, I found its documentation was more detailed.
Sorry but M$ stands for?
Micro$oft... VS/VSC 😒
[Penny Arcade - M$](https://www.penny-arcade.com/comic/2002/07/22)
I use ccls, I haven't tried others so I can't really comment on their merits. (first I tried and it worked, so I didn't bother)
Hi, I'm aware of this, I started this project yesterday, so there are a lot of things to do. Thank you.
So ccls is the continuation of cquery, iirc the cquery author stopped working on the project. I used clangd as well, found that cquery gives me better completions
If I'm just tinkering with c++ libs, I use this: https://github.com/flipcoder/c99sh It's a shebang script for executable .cpp files, (I didn't make it, but my fork includes lib support). If you're like me and you like experimenting and learning with different one-off small projects, this is really decent since it doesn't require a build system or anything. You can have a directory full of single file c++ programs with different purposes and execute them directly on the command line.
Big fan of libcurl. Although it is not easy to get into, it is easier than boost, and has excellent performance. But can you use it as part of a web server?
I'vd tried ccls and clangd with neovim, clangd sometimes works abnormally. As for cquery, it seems dead now. So, I recommend ccls, it's works perfectly for me.
- cquery is the first and oldest. - ccls is the sequel to cquery, created by one of its creators who wanted to try a different vision after learning lessons from the first system. - clangd is built by the team surrounding Clang and LLVM. I use this one just based on the paid manpower backing it.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cacssw/fout/et8migv/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
ccls with coc.nvim is being great for me.
The example provided does not work with `cpack`. But thanks for the hint, I might add it later To make it work add the following line to the CMakeList.txt `include(CPack)` and run `$&gt; cmake ..` `$&gt; make package`
I'm think C++ is a better choice. Why? You'll know what's going on under the hood. And it's not too hard to learn... but mastering is a different story. But still you can learn new things whenever you want. And change from C++ to Python is a way easier than Python to C++.
At least in the projects I've seen, the web server is implemented by other libraries (mongoose or civetweb).
beast boost is a good sweeping ability
C and C++ will put you in a better place for doing embedded programming, which it sounds like your aiming for. That said, many of the core concepts of all imperative languages are the same. So learn what you're comfortable with and then branch out. Syntax and structure change between languages, but the core logic doesn't.
Why are you posting here?
I wouldn't aim for mastery of C++ or Python if you're studying electronics engineering. You have more important things to do, like passing all your classes with As. If you have a programming class, then learn the language the class uses. If, somehow, you have free time as an undergraduate engineer, then... I won't even give this advice because you won't have free time. source: me, electrical engineer
I have tried all three. Clangd I do not consider feature complete enough and cquery lacks stability. I am currently using ccls via emacs lsp-mode and emacs-ccls. I've also used it with neovim, but I prefer emacs + evil (vim emulation) because I find scripting in lisp preferable.
r/techsupport would be a better place to ask.
Install linux
&gt; You need to build a high level library around it and that will take you ages. I wouldn't say ages. I was able to build a good high level library in a few days for a server.
Looks like we have preferences (Emacs evil lover here!), except for C programming I'm using eglot instead of lsp-mode. You should take a look at eglot if you haven't heard of it, it basically works out of the box with zero configuration and no additional packages (which is one thing I didn't like about lsp-mode). &amp;#x200B; However, for Java I'm using lsp-java and company-lsp.
I highly recommend https://github.com/yhirose/cpp-httplib if you want to do a quick REST API. It’s header only without dependencies and very easy to use. Performance wise it might not be the best possible, but it works great for me 👍🏻
Master C++ but use python. C++ is a great place to finish a project. But you wanna do engineering so you will need first-class graphics for drawing plots (e.g, physical paths for robotics movements, or just torque and whatnot) when you develop and to keep track things. Since plotting is not possible in C++, it is a fairly useless language to make anything new in for engineers dealing with the physical world.
Raspberry pi runs c++ just fine, not limited to python. Infact theres a big performance advantage
"plotting is not possible in C++" Hmm... I'm just learning C++ myself... But are you saying that the language used for the absolute best graphics in the best selling computer games of all times isn't capable of simple x-y-z axis graphic plots? Surely the same or similar basic graphic/plotting libraries in python are available in C++ (and likely even programmed in C++?).
`cquery` was the old one but as it is not developed anymore I would not recommend it. `ccls` is a fork of cquery and it is actively developed by one person. The author force push on his repository. `clangd` is developed by contributors and one of them is the author of `ccls`. I started with `cquery`, switched to `ccls` and now I use `clangd-9` which is directly integrated with LSP.
Well, writing your own bootloader is something/r/cpp may help with, but ...
If you focus your free time learning, living, and breathing C++, then Python will be a cake-walk to learn after that! Put it this way: I've seen, for example, organizations hire advanced C++ programmers to come in and solve enterprise level problems with their software written in Java, even though the expert C++ programmers had no experience ever working with Java! Why? Because they knew firstly the C++ programmers would pick up the Java programming language easily, and secondly C++ programmers has a strong reputation and knack for solving programming problems in any language. Even if you decide to work mostly in Python in your future career, at some point your Python programs are going to need a speed boost for certain algorithms. And for that you're going to need something like C++. As well the most advanced robotics, AI, and aerospace projects in the world today rely heavily on C++ at the core. For example: the most impressive robotics/AI feat in recent years in my opinion has got to be the SpaceX Falcon 9 rockets that land themselves--these things are the size of multi-story buildings... multi-story buildings that just come flying down from space, plunging through the sky at insane speeds, and automatically land themselves on a barge out in the middle of the wavy ocean! And what programming language do you think is running onboard the rocket's computers that let's it do all that? That's right: C++ it is!
I'm switching back and forth between ccls and clangd. Clangd has had some big improvements in terms of performance lately (mostly due to a new symbol index. You can read the design document here: [https://docs.google.com/document/d/1C-A6PGT6TynyaX4PXyExNMiGmJ2jL1UwV91Kyx11gOI/edit](https://docs.google.com/document/d/1C-A6PGT6TynyaX4PXyExNMiGmJ2jL1UwV91Kyx11gOI/edit)) and since I work on a really big codebase, this is important for me. Google seems to be quite heavily supporting clangd and want to replace libclang-based completion. Internally, clangd is now the default at Google (source: [https://github.com/ycm-core/ycmd/issues/1114#issuecomment-425840431](https://github.com/ycm-core/ycmd/issues/1114#issuecomment-425840431)). cquery seems to be pretty dead.
This is also my observation - C++ is very fragmented\*, if you want to have few different functionalities you need to really stitch everything manually. You are changing project? Consider re-learning everything because there is no standard way in handling db asynchronously. Even ASIO as networking\_ts is used rarely on projects I've been dealing with. &amp;#x200B; But don't get me wrong C++ still kick ass, and it's my favorite. &amp;#x200B; \*- Qt framework has it all, if you can use it, but that's not always the best option.
No, I am just saying that it is effort to get plotting working in C++ and that this effort is wasted because it is incomparably easy elsewhere. Plotting x versus y is a technique from the 17-hundreds, so any effort on your part as a user of a language means you are using the wrong tool.
\&gt; P0732 not being as conservative as we thought. &amp;#x200B; Where does this come from? The author only showed invalid C++ code to make this claim, so I don't see where this is founded on.
\`Rational\` is tricky because of the meaning of "equal" which is not clear there. A way to make this right is to have a meta-\`Rational\` which is lowers \`num/denum\` pair to a POD struct. Like: \`Rational&lt;5,10&gt; = Rational\_t&lt;1,2&gt;\` via template-using. This would allow to use Rational as NTTP under P0732 &amp;#x200B; If this mechanism was meant by "mapping" then here you have it: Do it explicitly or use a type with defaulted comparison (which would be the only automatic "mapping" reasonably possible). I think \`std::ratio\` works like this.
For me it's CCLS with Neovim or VS Code and it just work
You did the right thing by asking the same in /r/Python. We're all biased, there's nothing wrong with that. It's up to you to make the best judgement from what you gather. Unfortunately, they have this two weeks rule so you're not getting any answers from there anytime soon. I work mostly in C++ but Python is my "brain bicycle". When I heed to do something quick and dirty just to see how it goes, I always start in Python. But ultimately I'm not paid for quick and dirty, I'm paid for fast and reliable, so it either ends up in C++ or dies early. Nevertheless, from the economical stand point, I would not advise anyone who's not aiming at the career in software engineering to invest in C++. Most of the time Python will get you close enough to beet the competitors and when you really-really need this last bit of difference, you can hire someone like me to do the last bit of engineering for you. The first bits are much more important anyway.
Well, it's great to know both. But if you want to master one then go with C++. Once you are done with that Python will be simple and easy (and I don't mean this in a *"Python is rubbish"* way, I actually like it a lot).
Well, if I have to say that's a bit discouraging news, because one of the primary features I want to use C++ for in the future will involve rather simple 2 dimensional graphics x-y plotting. So it's a bit shocking to me to hear that there's no simple graphics library for C++? I mean you would certainly know better than me, based upon your own experience. Hopefully if someone else in this forum has found a relatively straightforward solution to basic graphics, they can chime in.
I'm going to go against the grain and not claim that one language is harder than the other and that *therefore* you should learn the harder language first as it will make the rest easy. When people make that claim, I feel that they are reducing programming languages to their syntax. In my experience, doing that is a mistake. I've been programming in C++ for 20 years and I'm still "learning it". You'd think I'd be done learning its syntax a long time ago right? Yes, you're right. Learning `if/else` and `for` loops takes a few days of school assignments to internalize and then you're done for the rest of your life. But I'm still learning C++. That's because programming "languages" are actually programming "universes" and you're never done exploring universes. You've picked a destination. The robotics galaxy. The good spaceship captain will do what needs to be done in the most efficient and simplest way. I think C++ is more complex than python and carries with it so many more idiosyncrasies that would slow you down. If you do not need the power efficiency of C++ and can reach your destination with python, then use python. I think reaching goals is more satisfying and motivating than having mastered complexity for its own sake.
Well, I have to say that's a bit of discouraging news, because one of the primary features I want to use C++ for in the future will involve rather simple 2 dimensional graphics x-y plotting, along with circular/elliptical trajectory plotting. So it's a bit shocking to me to hear that there's no simple 2-D or 3-D graphics library for C++ at the very least? :( I mean you would certainly know better than me, based upon your own experience compared to mine. Hopefully if someone else in this forum has found a relatively straightforward solution to basic graphics, they can chime in? I don't mind spending an extra month or two learning a new library if there is one like that out there. All of that said, it would be really nice if C++ could somehow add a basic GUI and graphics handling capability to the language. I could be wrong, but personally I've always felt that's one of the missing key features that may be slowing down further C++ growth and language adoption, especially against the recent rise of other languages such as Python, in comparison.
Async io is necessary for today's high performance web service. For c++, that's network ts(asio) and coroutine ts. Asio now has experimental coroutine support. Beast should support that automatically. I don't think there are better choices other than asio or beast now.
[removed]
I am a long time user of `cquery`, and recently switched to `ccls` since `cquery` is no longer maintained. Out of the three, `ccls` is the clear winner imo.
Yeah, the article is excellent, so I just gave this a try too for the BloscLZ codec ([https://github.com/Blosc/c-blosc2/commit/ca1c86e4d91c9931f6a4d35024ee2742eca21f05](https://github.com/Blosc/c-blosc2/commit/ca1c86e4d91c9931f6a4d35024ee2742eca21f05)), but I am unable to see any advantage on a variety of compilers (clang, gcc, icc) over the existing methods. But the blog author is claiming some speedups in modern hardware, so worth a try in LZ4 itself?
Both. Don't get pigeon-holed into a specific line of thinking. If you want to be a good programmer, its not enough to know the libraries and common coding patterns, you need to understand why these patterns exist and what are their straights and weaknesses. Which means that you need to constantly expand your horizons and challenge yourself to try new things.
When you know C++ every other programming language is a piece of cake. Except for those functional languages... yikes.
My expertise is not orbital dynamics, so I just wanna have 2D representations of these things most of the time when I need to check that the overarching code is working. For orbital dynamics graphics, the plotting is not always simple so maybe you need more complicated stuff from the get-go, no? There is an ESA package meant to simplify the Cosmographia SPICE-toolkit for drawing pre-computed planetary orbits and observation geometries (I have heard people talk about the new tool but only ever used the former). I presume the same exists for molecular drawings to visualize the more complicated molecular Wigner-vectors/'geometry', but I have only ever dabbled in these in cases where anything other than 2D would baffle me more than even the mathematical formalism.
There's a number of them out there, just need to pick one and run with it. There isn't a graphics standard out of the box, but it isn't hard to use a library. Last time I needed to plot something I mostly just stuffed it on a file and forked off gnuplot and fed the plot data through that because it was easy and met my needs. There's wrappers of matplotlib for c++ or write your own. Python has the advantage of having some of those things packaged for easy install and use.
wOw YoU mU$t bE a M$ $hiLL11!!!11!!!!11
Sorry to bother you again, but on a semi-related topic... Do you know if there are some programmers that code in a C++/Python combination? Is it relatively easy to reference C++ programs with Python, and pass data between the two? If so, then I could utilize the simpler to use libraries and eco-system of Python, and then call on C++ for some of the more demanding calculations. It also seems to me that Python has other easier to use features that I'm going to need to use in the future, including back end web hosting, and machine learning libraries. I really wish it was much simpler to implement graphics, web services, and other libraries in C++, that way it is in Python, because I'd rather use C++ than Python in the long run. But anyways, maybe the best of combination for the future, is to just simply learn/master BOTH C++ and Python, and take advantage of the best of both languages?
Is there a list anywhere of these libraries? (I'm not being facetious, serious question).
Clion has switched to clangd as well.
"Akuna offers sponsorship to future employees on a case-by-case basis" Is there any possibility of getting a visa as an intern?
I do C++ and python as a combination. I never call python functions from within C++. Some people on the project I work on set it up so that some functions export a clean enough C-API that can be used. All that was necessary after that was to be able to read-and-write files of all C++-classes in python and use that to pass complicated data (via RAM-located temporary files, so it is quite fast). Some python objects, like numpy-arrays, have pure C-arrays in the background so our own Vector-class (it is older than std::vector, and has at least some linear algebra) can just point at the other data instead. It is a bit of a mess but it essentially works. I tend to use python for prototyping. I then move the prototype to C++ because python is slow. Since the results still require plotting, I end up calling the C++ C-API function that is generated via python to draw these results. I tried setting up a C-API myself once, and it was quite easy with pure old C-code so you could try it out. "ctypes" is the python package.
Fluentcpp has a very nice post about separating text using a delimiter/white space. It will be easy from then on to get the position of third word. https://www.fluentcpp.com/2017/04/21/how-to-split-a-string-in-c/
I agree, this mythical 'python is easy for beginners' is just that, mythical. To me, it looks all like gobbledygook [python], and trying to work through the scoping, based on indentation is just horrible.
Untrue, centralized dependency isn't the right thing. Also you can't compare interpreted language like Python with compile to binary nor to native binary.
things should have the same name iff they have the same meaning lock/join/push don't have the same meaning at all there are more generic abstractions but they don't start at all like this (as far as I've seen). usually they are motivated by using the core functionality of a platform (eg distributed file system) to quickly and simply give an extra function (eg locking)
why?
in English only?
Why what?
??? what makes you think this
Let me clear what's open source is, redistributing binaries is completely wrong, every attempt to that also. Getting the source of language that generated native binaries gives you a power to specify exclusive compile options these are not inter-compatible between. That's Linux distro repositories stand for, to eliminate compile time options incompatibles. So the right approach is find the library at system wide, find\_package which provides an atomic algorithm to do it, also you can append directories where can be found a prebuild ones too. That's done via cmake file distributed by project (package) or self written by someone and added to local directory. In Linux you can install the system wide package, when you don't have that library system wide next step is to add external project to you cmake. To specify which are the compile options and to compile itself the depend. Since redistributing is not an option you should add it as static depend, also not a quite good option since you should update your binary on depends change. That's why Linux distro's have repositories, that's why none of package manager that you use don't make things right and never will.
&gt; Wouldn't it be better to have just one function supporting all cases? Is there some situation (in a generic program?) where this is true? I usually know if I want to try lock or lock.... it's completely different at the call site
Seems sensible for a C-style API (no expressive types, no overloading &amp;rarr; expressive function names ar required) For the C++ API, you could make the lock policy and explicit type (instead of your optional std::chrono::milliseconds) - which seems prudent if it occurs in so many API functions: bool lock(lock_policy const &amp; lp = {}); where lock_policy can be constructed as e.g. lock_policy::nolock lock_policy::lock (default) lock_policy::try lock_policy::try_for(std::chrono::millisecond) I would separate `try` and `try_for`, since some low level API's make subtle distinctions between a `try_lock()` and `try_lock_for(0ms)` Certainly, there should be only one write and read overload - typically, you need the overload dimension for something else, like data types to be written. I would nto guarantee anythign about the `nolock` etc. except their fucntion in this context. If they are distinct types, it would allow specific overloads (e.g. for operations where an explicit nolock would allow a more efficient algorithm or ordering to be used). --- **The main issue** I see with this design is that it eats up the return value, even for a no-try lock. Consider `x = i2c.read_int()` - can't be safely done with this API. Multiple solutions, no good one: - overload / specialize for the no-fail `lock` policy, which takes you back to square one - ref-out: `bool read_int(int &amp; result, lock_policy const &amp; = {})` - `optional` or a similar type that throws on invalid access: `optional&lt;int&gt; read_int(lock_policy const &amp; = {}) { ... }` `x = *i2c.read_int();` - throw on lock failure, which 100% defeats the purpose of try_lock
I don't see, how cramping the same functionality into a single function instead of 3 different ones would make implementation any easier. It may still be beneficial for the user, but on the other hand, being explicit about what is a blocking and non-blocking call can be very useful too.
Than maybe generic programming is the wrong word. The I2C example should make it clear what I really mean.
\&gt; Why is this regarded as some of the best libraries for HTTP Regarded by whom. If you are measuring by most recommended on the internet, this is probably because boost in general and asio in particular are very well known and beast has been advertised a lot. I'm not sure how many recommendations are really based on in-depth comparison. That is not to say that beast hasn't earned its popularity, I'm just saying don't confuse popularity on the internet with library quality or even just market share.
The three methods, write, try write, and try write for, are for very very different purposes. I mean they all are related to writing, but I don't think I'd ever have a use at a location that would transparently swap between the 3 unless I was doing a noop forward. If I had code that was doing something more complex than dumb forwarding, like writing to multiple spots, the try/do/duration code would differ at more than the call site. An API that takes 3 different operations and provides 1 function that does onebof the three depending on arguments is not a better API. For a concrete practical problem: The return value on try functions should be `[[nodiscard]]`, while the return value on write should be discarded.
Just personal experience.
that example didn't make much sense to me. you don't want to use default parameters? I also don't like them but it seems pretty much exactly what you want and usually your function to XXXX calls your function to try_XXXX unless you have a good alternative
Been using ccls on a codebase with a few million lines of code, and it works flawlessly for me (clang70, older versions of libclang had bugs that would get triggered on some obscure C++ features that we used). Haven't tried clangd. cquery with clang40 used to work fine too, but slightly slower. ccls isn't available for clang earlier than 60.
I meant that I can get everything bundled into the package aside from the header-only directory. But if you have tested it with `cpack` then I know to look for an error in my config.
there are so many completely different languages out there... the mainstream general purpose ones steal from each other constantly (which is good) so it's easy ish to go between them. but there are so many others where a c++ style of thinking will be a total disservice. really functional languages are somewhat different, but you can get really far away. even in languages where you can try to replicate imperative/oop code like lisp/Perl, that kind of code is usually not the best option in those ecosystems
I do the same, just with CMake. If you manually link prebuilt libraries as you do, it's a few minutes of work. But I do agree, keeping it simple is best. I use dependency managers for java and node, and the projects are in fucking shambles every time there are version updates.
Any idea why boost::split is the fastest by far? What kind of magic is going on there?
It's a state machine (DFA), go char by char and do stuff in transitions.
Awk, perl et al are all designed for text processing. C++, not so much. The traditional way would be to bust out Lex and Yacc to build a parser. Actually a lot of the time you don't even need yacc, unless you're trying to build and actual language. These days people would try to to do stuff like this all in regexps, but they really are a very awkward tool that make it far too easy to miss out on corner cases. I also see boost::spirit suggested for tokenizing strings in C++, but I tend to find the syntax awkward and clunky compared to lex. Funnily enough I got a programming challenge to count lines of C code some years ago. They said to use any tool I felt comfortable with, so I opted to do it in C with Lex. After I turned it in, they told me I was the only one whose program returned the correct value in all their test cases, and that I was probably overqualified for the position they were advertising. So I suppose YMMV.
The paper has been published as P1689R0: https://isocpp.org/files/papers/P1689R0.html
Honestly probably as a freshman in EE you'll need both (I'm an EE too, and did lots of robotics). My suggestion is to try to improve a little bit in both (and some other), no need to become master at beginning and then just became master in the one you'll need (or the one you like more). You have plenty of time !
**Type**: Full time, C++ developer / embedded systems programmer. Junior-Mid level. **Description**: Have Master's (and Bachelor’s) degree in Electronics engineering. 3 years of C# development (WinForms/DevExpress WinForms, MSSQL, MVVC, TFS) Nearly 1 year of C/C++11 development (Linux(Ubuntu), Git, CMake, Jenkins, uTests, GoogleTests) **Location**: Vilnius, Lithuania. Willing to relocate, remote would be doable too. **Contact**: DM for more info or LinkedIn
Is "LSP" becoming a buzzword now? I've started hearing it a lot more frequently lately, even on Twitter which is usually a sign of the birth of a buzzword.
You should edit your comment and put 4 spaces in front of the code examples, otherwise reddit markup eats your newlines (making both code formats look the same)
I'm trying clangd-extension... so far I'm very satisfied. Thank you !
\*\*Company:\*\* Glodon USA, graphics research group. [https://glodon-usa.breezy.hr/](https://glodon-usa.breezy.hr/) \*\*Type:\*\* Full time. \*\*Description:\*\* This particular group does R&amp;D in 3D graphics. You will be researching graphics toolkits, creating prototypes, eventually grow successful prototypes into products. You should be comfortable with basic math - calculus, linear algebra, etc. ; familiar or willing to learn computational geometry. This position is entry level, however we are fairly flexible - if you feel you are a strong fit, we will consider creating a senior position for you. \*\*Location:\*\* Princeton, NJ \*\*Remote:\*\* Not at this time, sorry \*\*Visa Sponsorship:\*\* Not at this time, sorry \*\*Technologies:\*\* C++ 14+, STL, Boost, CMake, testing frameworks. \*\*Contact:\*\* low-intensity gravitational waves preferred. Applying [here](https://glodon-usa.breezy.hr/) is ok, too. Alternatively, PM me on reddit.
I know both of them. And I can advise you to study both. C++ can be used in developing apps with Qt framework e.g. you can create web browser. Using python you can write algorithms, scripts really fast. I think the best way to study both of them
done!
Are you allowed to use the standard library?
This was drawn from Richard's enum code at the very beginning demonstrating that the paper was wrong in saying its substitutability identity holds for everything today.
yes I am allowed to use it
For the for each case you need to specify the option "ForEachMacros", otherwise clang-format doesn't know what kind of block follows after for_each. Once you specify, for_each should be formatted the same as a normal for loop. I don't think the second style is supported by clang-format. Braced initializers are parsed the same as function calls.
99% of my development time is on Linux. It’s bliss compared to the windows. I still develop on Windows for game-dev. It’s not terrible once I have everything configured.
**Company:** QTF **Type:** Full time **Description:** QTF is building a institutional grade broker-dealer with banking license into the crypto currency market. QTF's technology will allow institutional investors to trade crypto currencies professionally at lowest latency and highly through put optimized. We are looking for a lead engineer / CTO with: \- strong Background in latency optimized systems, experience in HF-Trading a plus \- Experience in with designing and implementing against APIs, especially FIX, websockets and REST \- Experience in designing and maintaining fault tolreant 24x7 systems with minimal/no downtime. Highly competitive salary and additional perks around freedom to develop and deploy own trading strategies. &amp;#x200B; **Location:** Berlin, Germany. Speaking German is not required. **Remote:** No **Visa Sponsorship:** Yes **Technologies:** C++17. The current infrastructure was built in Python and Cython but major parts are revamped into C++. Target is a highly scalable, low latency and through put optimized product. Stack to be determined. **Contact:** Send an email to [m](mailto:mi@quanttradingfactory.com)i@quanttradingfactory or PM
**Company:** Stevens Capital Management LP ([https://www.scm-lp.com](https://www.scm-lp.com)) &amp;#x200B; **Type:** Full-time &amp;#x200B; **Description:** Stevens Capital Management LP (“SCM”) is a registered investment adviser that manages a multi-billion dollar hedge fund that has been in business for 30+ years. SCM specializes in the rigorous development and disciplined implementation of empirically based quantitative trading strategies. Our highly productive team works in a fast-paced collegial environment, utilizing extensive data sets, technology and the scientific method to devise and employ trading strategies throughout the world’s most liquid financial markets. &amp;#x200B; **C++ Developer** **Primary Responsibilities:** * Develop new software and enhance existing systems in C++ on a linux platform. * Create tools to process, store and analyze quote, order and financial data. * Work closely with our quantitative research analysts, engineers and other groups to provide software solutions. &amp;#x200B; **Requirements of the Candidate include:** * Undergraduate or graduate level degree in Computer Science or Mathematics. * C++ programming experience in a Linux environment. * Excellent academic record. * Strong problem solving skills. * Knowledge of shell scripts and other languages including Perl, Bash or CSH is a plus. * Knowledge of relational databases including Sybase, SQL Server and Oracle is a plus. &amp;#x200B; **Locations:** Philadelphia, USA &amp;#x200B; **Remote:** On-site &amp;#x200B; **Visa Sponsorship:** Yes &amp;#x200B; **Technologies:** C++, Linux &amp;#x200B; **Contact:** Please apply directly to ([https://grnh.se/f330a6f81](https://grnh.se/f330a6f81))
std::getline with delimiter in combination with a counter.
Hi. I'm a maintainer of YCM/ycmd. That comment is pretty outdated by now. A few days ago we have merged `.ycm_extra_conf.py` support for the clangd completer. The only big feature missing in clangd is discussed [here](https://github.com/clangd/clangd#45).
nope
Ok I've wrote `ForEachMacros: [ 'for_each' ]` but it solves the problem only partially, by putting the right spaces where they need to be, but not the curly bracket on a new line...
If you want to get stuff done and solve problems quickly, learn Python. If you want to deeply understand the entire system, make conscious trade-offs related to the performance of your system and bit-level accuracy of how data is flowing through your robotics system, learn C++.
&amp;#x200B; yep, both on web and Android app
It sounds like it would be easy and efficient to write your API in terms of the standard one, but not vice-versa (because it would create, then test, a spurious `optional`). That said, I'm not sure if you intend the `nullopt` input to mean `write()` or `try_write()`. Do you pass a duration of 0, or maybe -1, to mean no waiting? Or maybe `nullopt` means no waiting, and you pass `INT_MAX` to get the effect of `write()`. These kinds of questions are why your API is problematic.
I am not sure if rtags uses LSP, but, IMO, it is the best C++ indexer out there.
[nope](https://i.imgur.com/TY79tIp.png)
IMHO FastBuild is a lot more than any of those - it supports precompiled headers, unity builds, compiler cache, distributed builds, project file generation, multiplatform... all out of the box without the use of other third-party tools
This is what it looks like on old Reddit right now: https://i.imgur.com/FCzq0MS.png Clearly there are still backticks instead of spaces.
[That depends on what you mean by "word."](https://unicode.org/reports/tr29/#Word_Boundaries)
We use Fastbuild to build on Windows and have no complaints. I can't compare it to anything except manual management of solution files (which is terrible). We use it to generate the solution files, unity builds, and have it use headers. Distributed builds was never worth it due to it dropping our debug build time to 35-45 seconds at longest. Sending stuff over the network just isn't fast enough when it's already that fast.
Second that. The Rtags/Emacs tandem worked well for me in the last couple of years and it looks quite stable now.
Statistical data generation to add to that. Hopefully someone has tried it, to get some feedback before i tackle this project. Oh yes that would be nice, but i doubt, i think i saw a thread that requests this feature in cmake but the thread just got silent, probably not gonna push through.
Oh thats promising hmmmm, so this is nice to know that fastbuild is nice to work with.
I added support (and a test) for cpack in the original library: https://github.com/bernedom/SI There is a brief description in the readme.md on how to use it. I will probably not cover it in the tutorial for the sake of simplicity.
I can't speak for \`FastBuild\` but have you considered keeping the \`cmake/make/ninja\` but enabling the distributed build? That is extraordinary easy to accomplish with [icecream](https://github.com/icecc/icecream). It is a zero-configuration service with a built-in load-balancing scheduler. \`distcc\` OTOH does not feature the load-balancing scheduler which makes it a pitta in my environment.
Thanks again for the feedback. I have updated the CMakeLists.txt of the project äand will update the blog article accordingly in the next few days. https://github.com/bernedom/SI
You are using new reddit format style. The format is broken in old.reddit.com, but OK in new.reddit.com
Why not both?
Yes before considering fastbuild i have tried to improve on our current build system. I tried distcc (but with only one VM for now), I can see the gains if many people are using one workstations but right now the workstation is all for myself so distributed compilation has no vig impact right now. Oh automatic load balancing sounds nice Ill give icecream a shot! :)
It would be interesting to see if FastBuild can keep the promises without distributed build. Personally, I am a little bit hesitant to believe in figures they present. Due to the lack of load-balancing, `distcc` does not scale almost at all when your master machine (where you trigger the compilation from) is of comparable speed to the slave nodes. In my case, it was unable to saturate slave nodes almost at all. OTOH `icecream` got it perfectly working for my setup (6-core PC + 4-core laptop + 4-core laptop). Literally, what I had to do to get it working without changing anything in the build system is: 1. Connect those machines into a LAN (either through a switch or directly connecting them). 2. `icecc-scheduler -d` on one of the machines (*) 3. `iceccd -d` on each machine you want to use for distributed build (e.g. all 3 in my case). (*) You can run the scheduler on each machine and is actually an anticipated use-case for `icecream`. You can read the docs to understand why.
I don't really know what can be simpler than that. I have dependencies that use very uncommon build systems like premake. It's much easier to write short CMake script and \`add\_subdirectory()\` on such dependency than dive into premake internals and find out how do you cross-compile for Windows with premake. Monorepo is a pretty great way to manage dependencies.
The formatting when you wrap multiple lines in ``` doesn't work on old reddit or some mobile apps. If you start each line with four spaces then it will work on everything.
There have been significant improvements since 1.69, especially with (optional) separate compilation. There are still problems, but they're worked on. Note that, for the most part, the "terrible compile times" are a product of it having a lot of low-cost features and not making too many design decisions for the user of the library.
&gt; Is it worth having Boost Beast as the HTTP library of a project? Short answer, yes. Boost.Beast will take care of the low-level details of the HTTP protocol, so that you don't have to worry about it. It will also take care of WebSocket for you, if it is appropriate for your use-case. &gt; ...it came with a lot of annoyances that I don’t know if appeared because of something I don’t know or can’t handle yet, or it is the library as it is. Most likely it is because you are unfamiliar with Asio / Networking TS. Boost.Beast does require a good understanding of Asio, as it builds on top of Asio (instead of reinventing the wheel). &gt; ...as soon as I introduce it to my code base the compilation times increased a lot, like 30 seconds on my Ryzen 5 1600 at 6 threads with CLion Boost.Beast has the same compile characteristics as any other heavily templated library, which is to say that it requires the user to apply a little bit more care with how they structure the header files, source files, and include statements in the project. There is a macro, `BOOST_BEAST_SEPARATE_COMPILATION` which lets you compile a significant chunk of Beast as a separate static library (it functions much like `BOOST_ASIO_SEPARATE_COMPILATION`). This will help reduce your compile time. However, you still have to intelligently structure your includes. You don't want to include &lt;boost/beast.hpp&gt; in every single source file for example, that would bring in far too much header material. John Lakos has a book "Large-Scale C++ Software Design" which provides tips on how to organize the physical structure of your program's source files to reduce compile times. Part of that includes writing your classes intelligently. I'm working on a new project which is a massively multi-player Blackjack server. Among other things it demonstrates how to write code that uses Beast which minimizes the compile-time impact. It is quite fast to build (except for the one file which does all the websocket work, that takes about 5 seconds). That project is here: https://github.com/vinniefalco/BeastLounge Anyone with questions about the code feel free to open an issue. &gt; ...a patch over Asio that makes me care about Asio and Beast at the same time like it were a single library instead of one managing the non-relevant parts for me. Yes, that is somewhat accurate. Beast handles the HTTP and WebSocket protocol for you, but you still need to use Asio to create and connect the sockets, and to establish secure connections (e.g. with OpenSSL). Beast doesn't reinvent the wheel here, duplicating Asio's interfaces for this would be wasteful. &gt; Is there something I should know before using Boost Beast to make it more enjoyable? It really helps to know Asio first. Besides that, you should take one of the examples and use that as a starting point for writing your REST service. I would suggest *http-server-coro*: https://github.com/boostorg/beast/tree/develop/example/http/server/coro &gt; Why is this regarded as some of the best libraries for HTTP Beast is popular because of its hands-off, "layered" approach. It gives you all the tools, and doesn't force you to use them in a particular way. You can see this in the examples, which provide MANY different ways to achieve the same results - pick the one you like the best.
&gt; Consider something more high-level. Yes, that's good advice - the problem is that there are few good high-level choices. Although this is starting to change.
&gt; Beast is primarily a websocket library, with only as much HTTP handling implemented as is required for that I don't think that's accurate. The HTTP support is quite robust. It handles chunked encoding for you (not necessary for websocket). And it has powerful customization features that let you do most anything with the protocol.
&gt; Boost beast really does have terrible compile times Beast is not unique, it shares the same compile-time characteristics as most heavily templated libraries. &gt; ...what you want to do is wrap it in a higher level api. Contain it all to one file which wraps whatever functionality you need, and then ensure that you never ever need to modify it to do your actual application logic Right. And this is precisely how Beast Lounge is organized: https://github.com/vinniefalco/BeastLounge/blob/2b6d5b271e4bf55530d1a16478915f53a855091a/server/ws_user.cpp#L17
&gt; I highly recommend https://github.com/yhirose/cpp-httplib if you want to do a quick REST API This is a great example of a higher-level library. Unfortunately it is not portable, it uses platform-specific implementations for the few platforms that it supports (won't work on most game consoles for example). If this library has a enough API to do what you need, then it can be a reasonable solution. But if anything is missing there will be little recourse - since it is high level, it is not possible to rearrange the constituent parts to suit your needs. As an example, cpp-httplib reinvents a portable socket abstraction (`Stream`), but one that is less powerful than Asio / Networking TS' _ReadStream_ and _WriteStream_ concepts. If you want scatter/gather I/O, you are out of luck. There are other examples.
Sounds linke unnecessary overcomplication to me.
You're welcome! Clang-based tools seems to be really good at parsing C++! While clang-tools package and clangd extension are still under development, they seems to be more reliable and feature rich than other solutions.
Yes I know! We have adopted one at work a year ago and have not regretted it ever since!
Yes, but it doesn't have the easy interface you need to write an HTTP application. A library extending it might for instance be an HTTP routing framework, which looks at HTTP requests, decides URLs and parameters in there and clals appropriate handling routines.
That is true - and hopefully someone will write that easy interface using Beast!!
Well, since you have no deadlines what so ever then and if you haven't programmed in any other language. You can try Beast for your API but my guess would be either you would become frustrated in middle because development is taking long (at-least I would have some months before) or you won't be able to make your REST API as you wanted, As others have mentioned beast is not suited to do application level tasks like developing REST API Development . Its best suited to make libraries or to create infrastructure to built things upon. There are far more things to do in good rest api development . For example input checking/validation and having your app in consistent state are one of the most important things and if you use relational database in your app then most probably your app is gonna be I/O bound. As of now given the current state of c++ in networking and lack of higher level abstractions if you want to be better engineer in c++ try something in which c++ really shines. like maybe try CUDA/thrust stuff or Pytorch C++ API (its really cool stuff) If you wanna start with Http and networking i guess you can start with node.js (i would recommend Type Script because i am not a fan of dynamically typed languages) or Go is a great choice we use it very frequently in our low latency Http Client side implementations and has great ecosystem with really great. These are just my opinion and I am not even close to being an expert in C++ so I may very well be wrong.
For different locking primitives (if you had more than just mutexes) I do think something like this is a good idea. This is one of the (few...) areas the Windows API got much better than POSIX, for example `WaitForMultipleObjects` can wait on all kinds of things at once. In general, though, some of these functions have very different semantics and merging them obscures that. For example, in a high-performance, or especially realtime context, `lock` and `try_lock` are wildly different (in a lot of cases you simply _can't_ lock, but you can `try_lock`, so having them be the same function makes auditing even harder). Similarly, unconditional push, and a push that could possible fail, have quite different semantics that heavily influence the surrounding code. I guess the theme there is that generic in terms of _type_ is good, but for semantics of the operation itself, not so much. If I want to wait on _something_ indefinitely, having many different functions for the various types of things I might want to wait on is just annoying. However, "pushing" and "maybe pushing" have different semantics, i.e., they are different operations, so too much overloading just obscures things.
I guess, it would make it awkward if you want to add another feature which requires a new function parameter. Having two parameters with default values can start to make the function awkward to use.
Yes, it is definitely not a catch all solution, but the small cost of including a single header is very appealing if you just want to do a simple REST API :)
compared to what?
not a fan of Go's error handling, it could have been way better with monadic interface and rust like ? operator.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/caj6j0/a_way_to_get_every_third_word_of_a_sentence/et9vegd/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/caj49x/c_clang_format_bracewrapping_after_equals/et9vwbw/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cao0m9/how_to_link_tbb_library_using_boostbuild/et9wpoj/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
compared to three functions :D
I think there is a fine line in the sand between a framework, game engine and this idea of a walled garden of libraries with some kind of project wizard or package manager. Cinder has tinderbox which lets you easily add third party libs to the framework. There is definitely an open prospect to shake up creative and game dev by defining this walled garden where every lib is a checkbox away. Maybe it has no centre, no one ring to rule them all or message queue etc. Just a big compatibility matrix somehow and no perfection. Just having a starting point you can recursively clone and build easily and then brute force all the possibilities. What we need is a community that gives a seal of approval to a starting point project so it gets a special icon on github.
For three functions, of course. But OP already has 15 functions (3 each for lock, join, push, read. write). I suggetsed this solution to - scale to any number of functions with an implicit lock - scale to any number of locking strategies - lift the locking strategy from "part of the method name" to a parameter (Imagine a sequence where you need to configure the locking strategy from the outside.)
The idea is that the current proposal is supposed to only allow NTTP for types such that the equality operator essentially models a member-wise comparison, in order to avoid confusion between 'equality of template instantiations according to the compiler' (which is based off name-mangling according to the actual value) and equality of values according to a user defined equality operator. The author is asserting that c style enums are able to circumvent the proposed restrictions to ensure this is the case
Hi, clangd developer here. Can I ask what are the most important features you're missing? We're about to cut the clangd-9 branch (which will have project indexing, clang-tidy checks, and a bunch of other stuff), and are thinking about what to prioritize for clangd-10.
&gt; and that will take you ages. Why?
Hi, clangd developer here. We're wrapping up the clangd-9 release, which has a bunch of new things (project-wide indexing, clang-tidy suggestions, better and faster code completion, quickfix for missing includes ...). If you haven't tried it in a while, please do! clangd-8 should be available on most distributions and via [llvm.org](http://releases.llvm.org/download.html). There are [nightly builds](http://apt.llvm.org/) available for debian/ubuntu, the [windows snapshots](https://llvm.org/builds/) are a little older. Also very interested in what you like/hate/want next. (Or put your ideas on our [bug list](https://github.com/clangd/clangd/issues) which will help us keep track of them)
To be clear for any beginners, the performance of c++ will be greater than python in almost all cases. It's a question of balancing ease of use/development speed (python, subjectively) and runtime speed (c++).
OP here, with a wikipedia link on [Alicia Boole Stott](https://en.wikipedia.org/wiki/Alicia_Boole_Stott).
The example is to show that if you want to build an API _on top of_ the std API, you need to repeat things. You need 3 versions of read(), which each call the right version of lock, etc. With a merged API, I2C would have a single version of read(), and would just pass along the args to lock(). Somewhat like "perfect forwarding" of the do/try/try_for pattern. And I think the answer is: yes, it would make the I2C API easier to implement, but it would _not_ make it easier to use. It would make it harder to use (because, as people mentioned, the surrounding code will be different for try_read() vs read(), and it is best to make different semantics look different). In general, favour ease of use over ease of implementation.
go to godbolt, find out, then report back
I still use ccls because when I open a .h/.hpp file, it immediately prioritizes indexing the .cpp file with the same name. Clangd does not do this which makes it hard to use (until indexing is complete).
Haven't we already had a few articles on the detection idiom recently? This one doesn't mention is_detected
Under no circumstances give in to windows.h Don't do it. It is awful. Use C++14 (or higher) for threads with latest [GLFW](https://www.glfw.org) to bypass many cross-platform problems seamlessly while retaining whatever templates and libraries you like. GLFW will abstract mos of the differences for input/output away.
I used Sphinx, using Breathe+Doxygen to bring bits from the code comments. It takes a bit of work to set up but it is the best I've seen so far specially for the "narrative" part of the documentation. For the reference part it has some drawbacks too...
The obvious feature that expected from clangd is integration with clang. I mean if I compile code with ninja+clang can clangd does not reparse source code and just get all information from compiler?
You'll most likely need both.
Same article was posted here: https://www.reddit.com/r/cpp/comments/cajipf/how_to_detect_function_overloads_in_c17_stdfrom/?utm_source=share&amp;utm_medium=ios_app
Is there any particular advantage of enums over constexpr constants, constexpr constants in a class, or the same in a namespace? Not saying one is better than the other, but that the have similar functionality in my eyes.
If you are on Windows exclusively and want something that is install and forget, you could check out Stashed (https://stashed.io).
You are right, i-- &gt; 0 is still generally better, despite I use a signed int type for vectors index/size in my C++ SpartaScript library. I even 'beauty bug' fixed my perfectly useless example code - and by the way, it is now even almost flawless in desktop browsers (IE/Edge/Chrome/Firefox) - almost because UiApplication::exit() can't always really exit, if browser's security settings prevent it ([https://teroxzer.github.io/guick/](https://teroxzer.github.io/guick/)) - and I'm sorry there is no my library code yet, but in some rainy day I will put also it to the github.
May I ask why you are not a fan of that? (Cause I am, XD) Also, I have zero ideas of either monads or rust's error handling.
I would rather do this work in the build system than in the code itself. Divide and conquer and all that.
Not constexpr related, but you might be interested in this: https://reviews.llvm.org/D64128
**Type:** Full time, Mid level **Description:** 2 years of work experience with C++ (global retail industry). Worked on legacy systems solving defects, modernizing code to C++03 (I know...) and implementing CI infrastructure. I want to work with software that requires modern C++, not closed to any kind of projects but maintaining legacy systems (Modernizing a legacy code base it's OK). I want to be a C++ guru in the future so any project that helps me to improve my skills is fine for me. I believe that collaboration between teammates it's the fastest way to improve my skills. Bachelor's degree in Mechatronics Engineering **Location:** Mexico, willing to relocate, no remote right now **Technologies:** C++17/14, Python 2/3, Java 8, Jenkins **Contact:** PM for email or more info.
Lets see, a great distributed compilation system sounds nice, and I will try icecream soon. Local build performance is my main concern right now.
sad to say we are purely linux dev environment.
We use cmake + ninja + [BuildCache](https://github.com/mbitsnbites/buildcache) (if our build system wasn't so convoluted we'd use meson instead of cmake). The centralized L2 cache of BuildCache is great for CI (we have ~20 build slaves that share the same cache) and also helps for developers (when they pull changes they are likely to already have been built by CI).
Well, distcc and ccache are great options. I miss them every time I have to do strictly Windows C++ development :) The admin overhead is a pain. I try to steer clear of other tech that requires retooling a build pipeline. If you have an existing setup with something like cmake, or even traditional make, you can automate away some of the admin overhead for ccache and distcc.
 \*\*Company:\*\* \[[IMC Trading](https://www.imc.com/ap/)\] &amp;#x200B; \*\*Type:\*\* \[Full time, permanent\] &amp;#x200B; \*\*Description:\*\* \[IMC is an international trading firm and market maker, providing liquidity to financial markets across a range of products. IMC’s trading model is highly automated, and the success of the firm heavily depends on the quality of its software. Our C++ devs are responsible for building low-latency, multi-threaded trading platforms, and optimising our trading performance. Our software makes millions of trading decisions daily. As a \[software developer\] ([https://careers.imc.com/ap/en/job/REQ-00556/Software-Engineer](https://careers.imc.com/ap/en/job/REQ-00556/Software-Engineer)) you’ll be working alongside traders to implement strategies which will challenge you to be creative with your implementation. You’ll need to produce solutions which compete in the extremely latency-sensitive environment, whilst managing complexity. You’ll be working in a highly motivated team, controlling end-to-end product development. You’ll be placed in an environment consisting primarily of C++ and Java. Our build chain has been designed around the concept of daily production releases. A variety of systems and technologies keeps life interesting. We are hiring developers at all levels from graduates through to senior. We believe in fostering a truly flat environment in which great ideas can be recognised as well as put into practice from anybody within our organisation. If you’re an experienced C++ dev looking for hands-on projects, a short feedback loop, and the freedom to create, we’d love to hear from you.\] &amp;#x200B; \*\*Location:\*\* \[Sydney CBD\] &amp;#x200B; \*\*Remote:\*\* \[No\] &amp;#x200B; \*\*Visa Sponsorship:\*\* \[Yes\] &amp;#x200B; \*\*Technologies:\*\* \[You’ll mainly use C++17. Java and Python skills are also advantageous.\] &amp;#x200B; \*\*Contact:\*\* \[For more information, reach out to Toby Tank, on the hiring team at IMC: [toby.tank@imc.com](mailto:toby.tank@imc.com). Head over to our [careers site](https://careers.imc.com/ap/en) to hear more about our process, culture and perks, and access the job advert [here](https://careers.imc.com/ap/en/job/REQ-00556/Software-Engineer).\]
Very nice! I like it. Keep it up.
Yep we have an already working build system. I agree that a change in the build system will break everything in our CI process. But I am willing to change this whole process if FastBuild delivers on its claims.
Do you know what it is? People are mentioning it more frequently because it's useful and tools for it are improving and stabilizing.
No your code is buggy, sorry :) [basic.scope.class]p2 &gt; A name N used in a class S shall refer to the same declaration in its context and when re-evaluated in the completed scope of S. No diagnostic is required for a violation of this rule.
oh I didnt know a centralize cache solution exists, will be considering that route, once i get my answer to my question.
C++ ostream ist so slow compared to fopen/fprintf. In my benchmarks depending on the platform it's a factor between 20 and 100. It's like the worst part of C++.
&gt; Is there any particular advantage of enums over constexpr constants, constexpr constants in a class, or the same in a namespace? The `-Wswitch-enum` warning. Reference: https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html
I agree with you, but it's the standard and so I have to teach it.
Thank you!
probably it's because syncd with the C I/O Stdio use std::ios_base::sync_with_stdio(false); and you will notice the difference
Please fix your formatting.
Are you assuming that the only difference between a try_read and a read is the locking strategy? I doubt that.
!remove
OP, A human moderator (u/STL) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/cawvpp/is_this_a_gcc_bug/etbodtr/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Class enums are type safe.
My goodness this was painful to read. You really tried to get through to him, and he didn't even respond to your points on cache or timing attacks. I haven't looked at his crypto code myself yet, does it go beyond "textbook" implementation at all? As an aside, that article about memset looks pretty interesting. Thanks for sharing it!
Apart from build system changes, everything I have heard about them has been pretty much spot on. No tool is perfect, of course. I have not used it myself, but know the devs and they are good.
I think it's desynced by default, no?
it's syncd by default as i have read in the documentation , you need to set it to false to desync. for more information http://www.cplusplus.com/reference/ios/ios_base/sync_with_stdio/
On the contrary, synchronised by default.
IMO the problem is the virtual function dispatch and crazy inheritance trees associated with all the various i/o stream classes.
Well, OP apparently does multithread... The use case I have in mind is communicatign with a HW device attached to a host PC. In this case, you can lock on the host with a device-specific mutex - which works perfectly as long as only one host can see the decice. Typically, you have commands implemented directly by the device, and then construct higher level commands from that (e.g. a read may be 3 or more i2c transfers) - in all cases you want a single outer lock, and this may be a try-lock or a lock, depending on the caller.
`&lt;&lt; std::endl;`? &gt;Use of std::endl in place of '\n', encouraged by some sources, may significantly degrade output performance. https://en.cppreference.com/w/cpp/io/manip/endl
In the case of outputting to standard output, there is probably no performance penalty as it probably already forces a buffer flush when `\n` is printed.
If python runs something fast it's because the library it uses is written in C++ ;-)
I also default to it. But in several occasions I have written small RAII wrappers around fopen/fclose when performance mastered. One issue I have found is the amount of function calls caused by the formatting interface. Using sprintf for formatting and just outputting the result is way faster.
Ok so this applies to P0732R0 which (probably) did allow user-defined comparison in strong structural equality. Is this correct? If so, then this has been fixed in P0732R1 which only allows defaulted comparison which is conservative enough. The counter-example shows with the words "So the following is a valid program according to the C++2a Working Draft right now" is not true. If you remove the first static\_assert the 2nd will fire as the issue shown is caused by template memoization. It is a nice base for test-cases however...
For robotics i'd say C++, but learning curve is a good point. I personally wouldn't start any new project in Python because of the ugly situation with Python 2, it's also very hard to work with binary in Python 3. In my experience, if you work with binary then it's easier to do that in C++ than in Python 3. But there is a point on learning curve again. Check out C, it's much simpler than C++, for a lot of people it's a gateway to C++ and you can write Python extensions in it too. As of Python, i'd say check out Go, it has smaller learning curve, strongly typed and compiles into native code. IMO Go is more closely related to C-family if you're interested in it.
Does it need RelWithDebugInfo builds for all these stats/infos? I'd guess so? &gt; GammaRay 2.11 is available as part of the just released Qt Automotive Suite 5.13 including QtCreator integration and professional support, or GPL-licensed on Github. This is a bit ambiguous. Does the GPL-licensed version on GitHub also has QtCreator integration? Looks like an amazing debugger!