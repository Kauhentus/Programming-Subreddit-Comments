The problem with looking at assembly produced for specific and rather trivial snippet of code is that you can't be sure that those optimizations happen in general, or whether those optimizations are really specific to the trivial example and will either disappear or change dramatically when using a more 'real world' scenario. That's why I prefer an answer like STLs because it provides insight into how a compiler optimizes. That insight can be generalized a lot more easily than checking the output of a very specific code snippet. It's also a problem with writing benchmarks too, you write a benchmark for a small function or algorithm and the results of that benchmark end up having no relevance to how it will perform in the context of an actual real world use case. You can easily end up deceiving yourself that way.
I didn't mean it as a replacement to STL's answer, but as a complementary view of the world. You really need both approaches. You can wring hands all day about what a compiler might do, but if you want real answers you need to look at actual output of actual code. Likewise, you can't make sense of what the code is doing and why it might be able to inline one thing and not another without having some knowledge of what a compiler is and isn't capable of reasoning about. But testcases are a good way to refine that knowledge. For example, you could start obfuscating the function pointer (e.g. by assigning it to a variable or passing it through multiple levels of function calls) and see where you hit the limits of what the compiler is able to deduce. 
 while (!(gameIsOver)) { // your game code goes here if (loseCondition) gameIsOver = true; }
PostMessage(WM_CLOSE); exit(EXIT_SUCCESS); terminate(); 
What does (!(gameisover)) do?
let me be more specific. lets say i have a program set to pick a random number between 1 and 10. i want to make it so if it brings back a 10, it will close the application. how would that look?
 #include &lt;cstdlib&gt; // for exit #include &lt;random&gt; // for all the random stuff int main() { std::random_device rd; // hardware generated random seed std::mt19937 gen( rd() ); // the random number generator std::uniform_int_distribution&lt;&gt; dis( 1, 10 ); // the range over which to return random numbers if( dis( gen ) == 10 ) // if we get 10 from the random number generator std::exit( 0 ); // quit the program } You can look up what all of these std functions do [here](http://en.cppreference.com/w/). Basically all of the code above is just the necessary boilerplate to generate a random number, then a simple test to see if we got 10, and a call to exit the program. The program will exit by itself if it reaches the end of main() normally, so this would likely only make sense in the context of some kind of loop.
could you please give me a program that shows what im trying to do in its fullest? im trying to type these thngs in, and im just getting error messages
post up your code here and i'll take a look at it
#include &lt;iostream&gt; #include &lt;time.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;cstdlib&gt; using namespace std; int main() { int random_integer; while (!(random_integer)); srand((unsigned)time(0)); for(int index=0; index&lt;20; index++){ random_integer = (rand()%10)+1; cout &lt;&lt; random_integer &lt;&lt; endl; while (!(random_integer)) if (random_integer == 10) terminate(); return 0; }}
this is about right, but im looking for a way so that, if i guess the wrong number, the program will close itself.
its not doing it for me.
You should also have a look at C++ compilers in the commercial UNIX and embedded vendors space. Microsoft is not the only lazy one.
This is slightly off-topic here. C++ doesnt forbid taking address of register variable and register keyword itself is 'deprecated' in it (and doesnt do anything as far as i can tell). Edit: &gt;Even if you think that you yourself would never do this, once you pass a pointer (even with a const attribute) to some other function, you can never be sure that this might be **malicious** and change the variable under your feet. And this is a symptom of some more serious problems.
Thanks for the insight. =)
I have a question related to std::bind (and possibly to std::function); context: &lt;random&gt;. Is there any run-time performance difference between repeatedly calling distribution(engine) compared to calling auto rnd = std::bind(distribution, engine); once and then repeatedly calling rnd() ? An example here [http://en.cppreference.com/w/cpp/utility/functional/bind](http://en.cppreference.com/w/cpp/utility/functional/bind), using std::function as follows std::function&lt;int()&gt; rnd = std::bind(distribution, engine); made me think of this. OTOH, a forwarding call wrapper (returned by std::bind) doesn't necessarily have to be a std::function, so perhaps (if there are performance / inline-ability concerns), the following is a better choice auto rnd = std::bind(distribution, engine); or, should I also prefer using lambdas for "binding" here, e.g., as follows auto rnd = [&amp;] { return distribution(engine); }; and then repeatedly call rnd()?
So "register"-ing stuff eliminates aliasing problems? I think I would have heard about it by now, if this was the case... 
&gt; Is there any run-time performance difference between repeatedly calling distribution(engine) compared to calling auto rnd = std::bind(distribution, engine); once and then repeatedly calling rnd()? Unlikely, for three reasons: 1. The bind-functor is an ordinary class, so its function call operator is eligible for usual as inlining. The stored engine and distribution are also ordinary classes (as opposed to function pointers), so the fact that they're stored as data members won't interfere with the inlining of their function call operators. (They are, however, sufficiently hefty that their inlining is far from guaranteed.) 2. The engine's state and distribution's state are already being stored as data members within those classes, so wrapping them in the bind-functor doesn't further affect them. (In constrast, something like bind(less&lt;int&gt;(), _1, 1729) stores 1729 in a data member, and the compiler may not be able to propagate that all the way to the op&lt; invocation - whereas [](int n) { return n &lt; 1729; } puts the constant right there.) 3. Even if bind() has performance effects, the engine and distribution are relatively costly, so the effects would be swamped. For things like less-than that are cheap to begin with, additional costs are more noticeable. The major cost here would be copying the distribution and especially the engine's state into the bind-functor. (Move semantics won't help, since a Mersenne Twister contains lots of POD state.) However, this should be a one-time cost, as engines should not be repeatedly constructed in the first place. &gt; std::function&lt;int()&gt; rnd = std::bind(distribution, engine); This is more expensive, since the std::function will dynamically allocate memory (an engine plus a distribution is way too big for the Small Functor Optimization), plus you've got the virtual call. &gt; OTOH, a forwarding call wrapper (returned by std::bind) doesn't necessarily have to be a std::function It would be crazy for bind() to return std::function. That would impose an unnecessary cost on all of its users. (It would be permitted by the Standard, but still crazy.) &gt; auto rnd = std::bind(distribution, engine); &gt; auto rnd = [&amp;] { return distribution(engine); }; These are fine (no dynamic memory allocation, no virtuals), except that the [&amp;] lambda requires the engine and distribution to stay alive. The bind() call copies them, so the originals can be destroyed. &gt; and then repeatedly call rnd()? If you're not passing this to another function (e.g. generate()), I'd just invoke dist(eng) directly.
Yeah. To be clear, he is talking about C, not C++. In C++ you can take the address of a register-storage-class variable. The only real hint to that effect is §7.1.1/3: "A register specifier is a hint to the implementation that the variable so declared will be heavily used. [ Note: The hint can be ignored and in most implementations it will be ignored **if the address of the variable is taken**. This use is deprecated (see D.2). —end note ]" But in The C standard, §6.7.1/12: "...**the address** of any part of an object declared with storage-class specifier register **cannot be computed**,..."
TL;DR The author's investigative due diligence didn't materialize... Pop tech articles don't belong on Dr. Dobb's.
Warning: extreme Standardese nerdery ahead. &gt; The only real hint to that effect is §7.1.1/3 The Standard consists of normative text (the stuff that is actually responsible for requirements and guarantees) and informative text (which may provide examples, point out logical implications, or provide suggestions for implementers and users). Notes are informative. In this case, the normative text that says that you can take the address of a register variable is "nothing forbids it". That is, when N3485 5.3.1 [expr.unary.op] explains how the address-of operator works, it specifically rules out bitfields (/5), but says nothing about register variables, or variables named "meow". Therefore, aside from the specific exceptions like bitfields, you can take the address of register variables, or variables named "meow". "It is permitted because nothing forbids it" and "It is forbidden because nothing permits it" are by far my least favorite ways for the Standard to specify stuff, but in this case it is fairly straightforward.
You know, I was just reading through some of your posts, STL. And I saw "normative" and thought "I need to look that up once I'm done reading through these." I'm glad you helped me out. :D Thank you
Can you imagine the compile times for checking every one if it is or not?
Presumably this is because, if register weren't ignored, the following would have to be valid overload. void foo(register int v); void foo(int v); which would be a major PITA just for the sake of an optimisation hint.
If MS VC++ fell behind you could theoretically build Clang using Mingw (on Linux or Windows) or via some equivalent Clang cross-compilation project.
Is that just for indexing into arrays? I searched the comments there and that's what they were talking about. Anyway, Cppcheck seems to ignore integer postfix increments and warns instead for "complex" types (I forget the exact wording of the error).
Mailing lists are a complete mess. Why do people still use them?
( ͡° ͜ʖ ͡°)
What would you replace them with? Edit: oh I see it's not mailing lists you're complaining about, it's Pipermail. There are two useful things to know about it: formatting is so minimal that keyboard navigation is super simple (the only links on the page are interesting links), and a 10 line script can fetch and concatenate all the text archives into an mbox for perusal in mutt, or copying into Gmail via another utility (and snap, now you can search and reply to threads as if you were always subscribed). Try doing that with any of the crappy forums/Google Groups/etc around
&gt; What would you replace them with? Something that looks like Reddit would be a good start. I have a half-written site that turns pipermail/hypermail/mhonarc lists into nice reddit-style threaded comment pages, but I lost the code down the back of the couch. Will try to dig it up and finish it off some day.
Coincidentally, I've just spent the last few days studying Jeffrey Yasskin's exploratory implementation. It just went into LLD, the LLVM linker, in r172512-172513. http://llvm.org/viewvc/llvm-project?rev=172512&amp;view=rev
I really enjoy dfeed in this regard. See [example](http://forum.dlang.org/post/kce4oa$2jkk$1@digitalmars.com).
Thanks for the explanation! A sigh of relief on std::bind not returning std::function :-) // BTW, I guess right now it's correct to assume there's no (possibly compile-time polymorphic) type one can use to create variables being able to hold objects such as forwarding call wrappers returned by std::bind? We have to use auto for lambdas, and it seems best practice to use auto for the results of std::bind anyway. Yeah, I'm thinking of having distribution &amp; engine bound for DRY purposes. That being said, good point on lambda w/ capture-by-reference trade-offs, I guess that in a multi-threaded context I'd use either lambda w/ capture-by-value or std::bind anyway (to have each value copied per thread, seeds adjusted).
There is Adobe's [ASL](http://stlab.adobe.com/). Look, for instance, at the range-based interface of the [copy](http://stlab.adobe.com/group__copy.html) algorithm. I've never used it, so I can't comment on how it differs from Boost.
Short version, for those too lazy to RTFA: this vulnerability, no; others, yes. Security is hard, regardless of the language you use. Get off yer high horse and review some code.
&gt;Some other exploits have indeed used vulnerabilities in Java’s native C code implementation I don't know if that's as simple as "other vulnerabilities are actually C vulnerabilities," it sounds to me more like "other vulnerabilities were caused by bad C code." C will let you shoot yourself in the foot with a nuclear warhead but I don't think it's fair to call a Java VM bug (which is what that snippet sounds like) a "C vulnerability." Perhaps I'm misunderstanding
&gt; We have to use auto for lambdas, and it seems best practice to use auto for the results of std::bind anyway. Correct. Except for auto (and decltype, if anyone wants to be pointlessly pedantic), there's no way to create a local variable of bind's unspeakable return type. &gt; Yeah, I'm thinking of having distribution &amp; engine bound for DRY purposes. I suppose accidentally saying engine() instead of dist(engine) is a minor concern.
Yeah, because the ISO wouldn't have any readers if they didn't bait Reddit. /s
Gmane.org has a great interface for mailing list subscriptions.
The crucial difference between C, C++ and Java is that C and C++ are unsafe languages. Any undefined behaviour in C or C++ is therefore the fault of the code, not the fault in C and C++. (Unless there are compiler or standards bugs but I've never seen these exploited.) Java does however claim to be a safe language, so therefore any flaws are in its implementation.
It is a C vulnerability because they make use of the typical C errors of buffer overruns and dangling pointers. They mostly relate to code exposed via native methods.
[Betteridge's Law of Headlines](http://en.wikipedia.org/wiki/Betteridge's_law_of_headlines): &gt; Any headline which ends in a question mark can be answered by the word *no*.
By that logic all C / C++ vulnerabilities are machine code vulnerabilities and not the fault of C / C++. Great, then I don't have to take the blame for my own coding bugs. I'll just blame the machine code.
Frankly, if it was for visits, they'd posted a Java kitten in a major subreddit. 
Answer from the article itself: &gt; The answer is no, these particular exploits are pure Java. Some other exploits have indeed used vulnerabilities in Java’s native C code implementation, but the major vulnerabilities in the news lately are in Java itself.
My C++ is a bit rusty, but if I remember right, if you have a char[10] then char[0] should give you the ascii value of the letter at this position say 97 if it's an 'a' 98 for 'b' etc. What exactly would you mean with converting words into numbers? There must be some rules. ASCII values? Or the string '12345' should be converted into an int 12345? Or words like 'one' should become 1, two become 2 etc?
Well if I start the programm and write "abc" then it should simply say "123". I'll try out the char[0], I guess. Edit: Didn't work, the char must be longer than 0
Please for the love of all that is good, DO NOT use char[] to store strings, if that's what you want to do go learn C. Store strings in wells strings. std::string str="hello"; I don't actually know what you mean by convert to numbers, that's very ambiguous. If you mean parse a string into a number than the easiest is: std::string str="1234"; int i=std::stoi(str); // i == 1234 and back again std::string str=std::to_string(i); If what you meant is you want to output the charactors integer value then something like this will work std::string str="hello world"; for(char c : str) { std::cout &lt;&lt; static_cast&lt;int&gt;(c); }
having read a bit more of you're post you seem to want a-&gt;1, b-&gt;2 ... z-&gt;26. std::string str { 26, 'a' }; std::iota(str.begin(), str.end(), 'a'); //(a...z); //for each element for(char c : str) { std::cout &lt;&lt; c - 'a'; } std::cout &lt;&lt; '\n'; see working example here: http://ideone.com/8wAERJ
char numbers[10] = {'1','2','3',...} for(int i = 0; i &lt; 10; i ++) cout &lt;&lt; (int)('0' - numbers[i]); fin
for (char * i = str.begin(); i != str.end(); ++i) { printf("%u", *i - 'a' + 1); }
`std::string::begin` does not return a `char*` even if it compiles it is not standard, and I am pretty sure passing a `char` into `printf` expect an unsigned integer is UB.
not entirely sure what you're trying to do but there's a few ways to do this there's the [ascii table of values of alphanumeric characters](http://www.asciitable.com/index/asciifull.gif) or you could write your own algorithm defining a=1, b=2, etc. to get you started, here's what you'd probably want to do std::string somestring = "somestring"; for (int i = 0; i &lt; somestring.length(); i++) { cout &lt;&lt; somestring[i] + 0; } that `somestring[i] + 0` will output the numerical ascii value of the letter of the string at position `i`. If you want to use your own values for letters you'll have to write your own algorithm and pass in the string, or probably easier, stick with the `for` loop from above and just pass into your algo the individual chars. Not too difficult. int charToNum(char c) { if (c == 'a') return 1; if (c == 'b') return 2; ....etc } An inelegant algorithm and a bit tedious to be sure, but it'll get the job done. Then, in the above `for` loop, instead of `cout &lt;&lt; somestring[i] + 0;` you'd just do `cout &lt;&lt; charToNum(somestring[i]);`
Agreed. Here's a version that actually compiles. std::string str = "abc"; for (size_t i=0;i&lt;str.size();++i) { printf("%u", *(str.c_str() + i) - 'a' + 1); } 
It's on github too: https://github.com/sumeetchhetri/ffead-cpp
You are confusing template specialization with assignment(actually construction in this case). You do not need to specialize std::function (nor should you ever (unless you are writing your own standard library)). You are just trying to construct an instance of std::function in which case the template &lt;&gt; is illegal
Oh ok interesting, I thought there was something I wasn't understanding. Although I'm curious why on gcc it tells me I'm missing the `template&lt;&gt;` and not using proper syntax for specialization? [Here's the code with the error](http://liveworkspace.org/code/3KngJo$2) on live workspace. Clang also refuses without the `template&lt;&gt;` but clang 3.2 will compile and run it with the `template&lt;&gt;`, gcc complains about template specialization of a non-template type, which I've found is reported as a bug in their tracker. Or maybe I'm just not understanding quite what you mean, this is my first time trying out the std::function stuff, and I wouldn't say that I'm too experienced with templates either.
Yea, this is the fix /u/Rhomboid mentioned which I've put in for now. I may just stick with using this since it works on all compilers. Thanks!
Very interesting, but lack of documentation == not going to be used very much.
Looks like someone tried to make the jump from java to c++ and missed. throw new InvalidMessageException("No message Tag\n"); Oh my.
Joke's on you, he uses libgc.
What's the point of creating an exception object on the heap, regardless of whether it is deallocated properly at some point? There is absolutely no need to do so.
whoosh
Sorry. Irony detector is malfunctioning. +1
Can't you just add the files to the project and then set them all to 'Compile As' C++?
Tools-&gt;Options-&gt;Text Editor-&gt;File Extension
Also, your professor is an idiot.
There is plenty of documentation. See http://code.google.com/p/ffead-cpp/w/list
Great. I have been thinking why there is no spring/ajax framework in C++ but this seem to be good project. Now we can have good comparison between C++ vs Java frameworks :)
Is anyone using it in production?
Hmmm I could have sworn that would have worked. I can't look now, but when I get home on my personal machine I will definitely check. I know there are ways to do this in Xcode (althogh i know you are on 2012) so it seems to me it should be possible. Sit tight for a few hours and I'll post here.
Not only that, look at things like this: static int charArrayToInt(char l[]) { int t = 0; int ind = sizeof l; for (int i = 0; i &lt; ind; i++) { int offset = (ind -1 - i) * 8; t += (l[i] &amp; 0x000000FF) &lt;&lt; offset; } return t; } 
&gt;I understand that I could just change the file names before submitting Do this, and then also use a bunch of weird unicode characters in the file name. 
Untrue. If you did `string s; cin &gt;&gt; str;` and it caused a buffer overflow, that would be a C++ vulnerability. It wouldn't be caused by your bad coding.
OK, I created a sample project here and figured it out. First, let me reiterate... don't do this outside of class. .cpp is the way to go. Feel free to tell your professor /u/ctartamella said he's an idiot. (I take no responsibility for the effect on your grade.) For the important part: Right click on your source file (already named .c++) and go to properties. Under General -&gt; Item Type select C/C++ compiler. This directs msbuild to treat this as C/C++ source. Now for the bad news. I was unable to get syntax highlighting working with the new extension. The link [here](http://www.gmtdev.com/blog/2010/10/17/adding-a-file-type-to-visual-studio/) suggests a solution, but it didn't work for me. Maybe you will have better luck. Or, tell your professor his requirements are a bit nuts. :) Good luck!
FAT16 doesn't allow '+' in filenames. 
If nothing else, write a script. e.g: * copy all .cpp files to .c++ * remove all .cpp files * git add . * git commit * git push * copy all .c++ files to .cpp You should probably just demand your money back at this point. 
I thought about what filesystems wouldn't allow it. FAT16 hadn't occurred to me lol.
The language itself does not provide support for dealing with raw audio, but there are third party libraries that provide that functionality. A quick search leads me to PortMIDI/PortAudio, Juce, and OpenFrameworks. I have not used any of them, so here ends my usefulness to you.
Sounds like Java or C# might be better for the job. Maybe even Python. There are specific reasons for choosing C++ these days such as when you really need to squeeze every last bit of performance. What lead you to C++?
For real-time audio C++ would make more sense for performance (especially if you want to avoid latency spikes caused by GC). Afaik real-time audio is very sensitive for latency.
Yes, I think C++ would be the right tool because the VST SDK is based on C++. Sure there are some wrappers for other languages, but imho using the "official" stuff has its benefits.
You still need a library that can work with data formatted for audio, otherwise you're left using a filestream to parse the data yourself. If you know how the data is formatted then you can do that, otherwise you'll need a third party library. From what I glimpsed when I searched around, PortMIDI/PortAudio has audio editing tools. Were I attempting this but I wanted to avoid third party software, then I'd follow the following procedure: 1. Create a MIDI file, and load its data byte for byte using a filestream. 2. Create an identical MIDI file and do the same. Compare them. 3. I'd then know how the file's meta data is stored. 4. Create the same file with a different name, repeat the comparison. 5. I'd then know if the filename is noted in the file itself. 6. Create a file for each note, and repeat the parsing and comparison. 7. The bytes that differ denote note changes. 8. Repeat 5 and 6 for note of twice the length, look for a byte that is numerically twice the bytes in the previous files. 9. I'd then know how note duration is stored. Armed with all this information, I could then use an input file stream to load a file, and then locate and alter the notes I want to change before using an outstream to save the file. It would probably be a lot easier to just use a third party library.
Yes it works. I would recommend something more managed for this however, unless you are planning on using it against numerous files or if speed is a concern. As someone who has been using c++ for a while I generally find audio slightly rougher to deal with than other common things. I would recommend you use something like python for this is you want to complete it quickly (and I don't mean the normal c++ takes longer quickly, I mean orders of magnitude more quickly). If you can give a more detailed explanation of what you are creating it would be easier to say.
Have a look over at http://kvraudio.com. There's loads of info there, for both users of DAWs and plugins, as well as for developers. Browse the forum. It's an awesome resource. C++ can certainly handle what you want, but C++ is an awful language...
Such as?
look for Juce. it's a nice library for creating cross platform VSTs. you can also use it to create a midi data processing plugin. it's written in c++. 
Link for the lazy: [JUCE.com](http://juce.com) JUCE is very easy to get started with and has nice abstractions for audio processing and lots of other areas that makes is possible to create entire cross platform GUI applications using only JUCE. The downside is that its maintained by one guy (Jules) and once you do some serious work with JUCE you will run into limitations and bugs. Luckily Jules is quite active on his own forum and responds quickly to issues. You can also see in the [JUCE Github Commit History](https://github.com/julianstorer/JUCE/commits/master) that JUCE is quite actively maintained, both i terms of new features and bug fixes.
You realize that the OP is working with a DAW, and as such there is likely no files involved and most of your points become moot?
If you have friends who already have experience in this stuff, then their knowledge is already quite good reason to use whatever they have used.
Nope! I didn't realize that. However, doesn't that just further highlight the need for third party software? 
No, but a vibrant community of which not everybody may has a job or is looking for a change ?
Yes C++ is good for that. As a side-note, you will probably be dealing with bytes. If you ever need to read multiple bytes into an 8-byte chunk for example, do not use reinterpret_cast - it's outcome is platform dependent. Prefer bit shifting which is platform independent: https://github.com/matthewaveryusa/averyws/blob/master/lib/ws_frame.h#L162-169
If you're brand new to C++ I'd _really_ not recommend throwing yourself into it on a project you care about. I'd personally probably just use Python since the data rate is probably relatively low. I encourage you to learn C++ but throwing yourself right in is asking for frustration and difficulty.
Most file formats are published somewhere, you don't have to beautiful mind them.
Consider using a language like PureData (free) or MaxMSP (commercial) for this. They already have built-in MIDI functionality, and can be used from a relatively simple interface. They are designed for projects exactly like this.
&gt; We are looking for a *recent college graduate* with *good C++ knowledge* That's a tall order. It takes many years of experience with C++ to get good at it (and you're also looking for other skills you list there which tend to come with industry experience) . Why are you limiting your search to a recent college grad? 
Usually better documentation, in my experience.
I know there's a python library which is just a wrapper around a c library that does the job. So I would say either python or c++. Python is fast too! Sometimes even faster than c++ in certain things.
C++ is definitely overkill for this. Writing a VST is not something you should start with but it is a good way to do it. Pretty much every language has MIDI through some library, so you can write a program in any language looking at virtualized ports (like LoopBe1). Personally I would recommend doing this is puredata or max/msp (later if you have ableton).
&gt; but C++ is an awful language... why are you on /r/cpp then? 
converting with a union is UB.
This may seem alien to many people today, but some people enjoy the cognitive exercise of figuring things out for themselves wherever possible if for no other reason than to maintain a capacity to do so. I'd rather beautiful mind anything I can because practice makes perfect.
I hear you, but some people prefer not to run to Wikipedia for every answer. I'd rather rely on my own brain than a website whenever possible. Of course, if OP asked this question for a paid project then it would probably be best to find required information quickly. But then if OP took on a paid project with no idea of where to start, squabbles about minutiae or best practices have already lost out to a lapse of work ethic. 
multiprecision looks pretty cool. This is the first C++ multiprecision library I've heard of. I like that it has fixed-precision types like uint256_t.
And somewhere deep down there is - at least for me - an interesting listing: &gt; Boost's primary test compilers are: &gt; [...] &gt; LLVM Clang, with libc++: 3.2 Cheers for that!
Well.. I was at a talk once where Bjarne argued that c++ was 'at least' the second best language for doing almost all things, so you are probably fine. Just find a good library for what you are trying to do and go from there. edit: are you trying to do something that's near real time or is this a post processing step of some sort that you are building? One of the cinder devs built a midi input handler but never finished it: https://github.com/hecspc/Cinder-MIDI Also there are some other midi handler libraries like: https://github.com/jdkoftinoff/jdksmidi However that deals with midi files and now output from a DAW. You could probably just use it for the processing part and provide your own input however.
Putting aside the issue of `abs(INT_MIN)` which is undefined behavior, it seems to me that `abs()` does in fact implement a strict weak ordering, so that's a valid predicate. 
It's good to be aware of this (even if you don't have it memorized.) See a "strange" looking crash in a std::sort (map, whatever)? Check that the ordering satisfies the required properties. (As STL mentions you seldom have to actually think about the properties rigorously, I find that usually 30 seconds thinking about the unordered elements is enough.) Often someone will let an "or equal" slip in to the comparison operator by accident and not have problems for years. When it does finally start crashing knowing this can save much hassle. (I solved a bug a coworker had been stuck on for hours in 30 seconds like that.)
This is pretty cool (like every time a new Boost release comes along). What I personally am really looking forward to playing with and using this time is [Boost.Lockfree](http://www.boost.org/doc/libs/1_53_0_beta1/doc/html/lockfree.html). Having a cross-platform library for that is great, especially considering how simple it has become to blow your legs off in plain C++ with C++11's `async` and `thread`. Good thing there is a safe and efficient way to work with e.g. queues.
Post some code?
Without looking too carefully at it, try going through and verifying that each of your numerical values are actually floats, and that nothing is getting converted into an int. E.g., float z = ((2 * pi * (ff * 10) * (t); rewrite that float z = ((2.0f * pi * (ff * 10.0f) * (t); I would also debug at runtime to see what the values of those variables are, and to see if they are getting truncated as ints. It's a very easy mistake.
If it does work let us know what change specifically made the difference. I am curious to see that (but too lazy to look this over myself). 
Unless the program needs to run somewhere where memory consumption is an issue, there's little reason to use floats over doubles. Your distortion issues might be caused by the limited accuracy of floats.
You're missing quite a few definitions, what's fWaveform, fDepth, fGain, fFrequency and counter? One thing I notice is you seem to be trying to clamp a sin wave to a square wave by thresholding it, but you're using .5 as the threshold, where you'd want to use &gt; and &lt; 0. Using .5 you'll be limiting your square wave to between +30 and +150 degrees which is only 33% duty cycle. Can you clarify the nature of the distortion you're seeing? There's a lot of ways to distort a signal. Another thing I notice is you're multiply frequency by 10 above the start of the loop, why is that? You're also not updating the z value inside your for loop, so it's going to multiply every sample by the same, constant, value. There's a number of clarity/style changes I'd make too if you'd like me to comment on those, anything you can do to clear away the cruft for things like this will help you find bugs.
For future reference, it really helps to have well written titles. "C++ help needed" is vague. A better title would've been something like, "Writing a VST plugin, modulating input by sine wave causes distortion."
I've seen posts like this on here before, and it's a shame we have to hammer these points into programmers. The sad truth is that people leaving my university's CS program have almost no concept of memory management. We show them `malloc` and `free` in one class, but don't require they even *call* `free` in their code. Every other class uses Java. When I learned C++, they still didn't teach RAII (I had to learn it on my own). They taught a very "C With Classes" style, emphasizing pointers and arrays. The thought was that we had to learn how it works before we move to more advanced topics. In my mind this is like requiring someone learn how a gearbox works before letting them drive a car. I think this does a great deal of harm to the reputation of C and C++. By only showing students the most basic (and oldest) features of these languages, they leave with the notion that C and C++ are horrible old beasts that they should pray they never have to use. They don't get to see the usefulness of a modern STL, let alone C++11 features.
Hui, had you used some cautious C++ features like `std::string` or bounds checks on containers (e.g. of `vector` or `array`) and less pointers (at least until profiling tells you they are bottlenecks) you now could actually be sure you are not just reading garbage somewhere -- I hope you are at least running something like valgrind or static analysis to see if that's an issue. And since you are at it, can you post the definitions of the class as well?
I think -1 and 1 for the square wave is just fine, it won't have a DC bias in that event. Is your input real or complex? I think the issue with the sin wave is that you're not updating modulatorsin inside your inner loop, so each time through you're just multiplying by a constant. Depending on the rate this function is called, it's going to be equivalent to multiplying by a square-wave train and that might cause your rumbling. For the record, if I were to write this code, here's how it would look (not compiled or tested, just an example.) You'll want to make sure processingReplace is called frequently enough that you don't accrue significant round-off error in your phase doing it this way. void ampmod::processReplacing(float **inputs, float **outputs, VstInt32 sampleFrames){ float *inp1 = inputs[0], *inp2 = inputs[1]; float *out1 = outputs[0], *out2 = outputs[1]; const double sampleRate = updateSampleRate(); double dphase = 2*M_PI * (fFrequency * 10.0) / (double)sampleRate; double phase = dphase * counter; //DSP loop while (--sampleFrames &gt;=0) { double modulatorsin = sin(phase); double modulatorsquare = (modulatorsin &lt; 0) ? -1 : 1; counter = (counter+1) % ((1/fFrequency * 10) * sampleRate); // Apply modulation to input double modfunc = (fWaveform &lt; 0.5) ? modulatorsin : modulatorsquare; *out1 = (*inp1 * ((1.0 - fDepth) + fDepth * modfunc)) * fGain; *out2 = (*inp2 * ((1.0 - fDepth) + fDepth * modfunc)) * fGain; inp1++; inp2++; out1++; out2++; // Increment sin phase phase += dphase; } }
Skipped through briefly (I'm tired) and was disappointed to not see Allman style.
I wasn't aware that creation of a pointer without assigning a value to it is a UB.
The only operation you may perform on a pointer that that has not been assigned to a valid pointer value is assignment. Nothing else. Doing so much as a copy of it is invalid, for example this is undefined behavior: int* x; int* y; y = x; It also follows that taking an invalid pointer value and simply passing it as an argument to a function is also undefined behavior.
Your advice is poor. Often times I upgrade my compiler specifically so I can have more stability. For example take Visual Studio 2012 vs. 2010. Valid C++ code that crashes in 2010 won't crash in 2012, especially with regard to lambda expressions. GCC is no different either, newer versions have bug fixes or better standard compliance.
I see four programming styles, basically determined by two binary ideas. The first bit is fast programming, which favors productivity, versus careful programming that more favors engineering. The other bit is described by the perspectives that whatever gets software working and doesn't damage the machine is permissible versus the idea that if undefined behavior (as per the ISO standard) is used, that's a bad thing. I've seen a ton of discussion on all four combinations of these perspectives, and for the most part it seems that which is used depends on who is doing the selecting and what it is being used for -- though each programmer seems to have their favorite approach that they think is the "only" or "right" way. This is confusing for a budding coder because people don't often rationally support their ideas. Instead, they simply state what they think is best, insult anybody who questions it, proclaim their unquestionable authority, and go about their merry way. That accomplishes nothing at all except to troll somebody trying to learn. The part of the article that I quote changes that for me in regard to one of those four philosophies. Rather than declare that hackish tricks that are undefined under the standard are "bad" and leave it at that, the author gives us an actual *reason* for the idea. Namely, that an implementation may change thus leading to the failure of a program that once compiled under an older version of it. From what I see, as I try to continue to evolve my grasp on what kind of coders are out there (and consequently, what kinds of coding), this doesn't immediately negate the idea of using ISO standard undefined behavior to accomplish something. On this very page, somebody advises that one simply avoid upgrading their compiler. Personally, as I see that each of the four styles under these two binaries is widespread, fiercely defended, and constantly attacked, I still think that none is universally "better" than any other. Instead, it still appears to me that each is appropriate under its best circumstances, but I understand better why one of those four is not so often lauded as the other three.
The rules for what constitutes a valid pointer value are defined formally in the C and C++ standards. Yes, the so called "one-past-the end" pointers are valid pointer values. It's not an exception it's just part of the definition of a valid pointer value.
Can you give an example of undefined behavior that someone has tried to exploit for productivity? I honestly can't think of anything. Usually undefined behavior is very, very hard to statically verify in source code, so it's neither practical or worth the effort to go over every line of code trying to get rid of it, but I can't think of any reason one would substitute well defined behavior for undefined behavior and claim that there is some kind of improvement in the code, regardless of practical vs. ideological considerations. We should keep in mind there is a world of difference between undefined behavior, which I think should universally be regarded as incorrect and something to avoid, versus unspecified behavior, where the standard basically leaves the behavior up to the compiler, but the compiler is required to produce well defined behavior.
&gt; The rules for what constitutes a valid pointer value are defined formally in the C and C++ standards. I figured. I asked where?
I've been told that C/C++ were doomed since 10+ years. First there was Java, then C#, afterwards Python and Ruby. And guess what? Both, C and C++ are still around and (in my field of research) standing stronger than ever. 
I wonder if I'm conflating unspecified and undefined behavior a bit. It's possible because wherever I read, whenever there's an example of either, I don't read it. Instead, my focus goes immediately to the counterexample with well defined behavior. My reasoning for this is that it's my hope (and not at all expectation) that people will one day use the code I'm writing now. It seems better to approach this with the assumption that others will use my code and have it one day sit neglected by all but me on Github than assume nobody will and then cause problems for people by failing to plan ahead. I'd feel horrible if another programmer had a headache due to my shortcomings. The only undefined behavior I've come across that I very vaguely remember, was posted by me and after taking much slack from Redditors, I edited it out and made myself forget it. This had something to do with a way to take the address of a const method parameter and break the contract with the compiler that it's read-only so a literal could be treated as just another variable. That would allow arguments passed as literals to also represent memory used to store a resultant, for example, but I only wrote it experimentally and it was meant as an example of what probably shouldn't be done. My statement that some defend using undefined behavior is an inference. It's not often, but at times when I see undefined behavior pointed out (which others may conflate with unspecified too), I see a third party step in and point out such and such case where it's useful. Usually that seems to be followed by pitchforks, but this tells me that some programmers approach their problems in that way so it must be useful to somebody. Thank you very much for explaining the difference between unspecified and undefined though. It may be nearing time that I start studying the open versions of the standard.
As if the standard couldn't evolve.
One reason is that the default implementations for Java and C# are JITed environments instead of native compilers. There are native compilers for those languages, but most developers seem to be unaware of them, or unwilling to pay the requested price. Then there is the fact that most developers use what they know, or the languages that interoperate better with the libraries that they need to use.
N3485 5.7 [expr.add]/5: "Moreover, if the expression P points to the last element of an array object, the expression (P)+1 points one past the last element of the array object, and if the expression Q points one past the last element of an array object, the expression (Q)-1 points to the last element of the array object."
There are ready to go repositories withing the project for all popular deb and rpm distributions and all supported versions.
See: &lt;http://blog.cppcms.com/post/107&gt; CppCMS has built in support of SSE which is much more reliable Comet architecture than web sockets today.
Could someone explain how compilers exploit undefined behavior to generate faster code for a beginner?
That comment neglects to mention the very significant downsides to that approach, namely that the new string type is by itself on a deserted island, inaccessible from the rest of the standard library. For example, `std::cin` is an instance of `std::istream` which is really `std::basic_istream&lt;char&gt;` which is really `std::basic_istream&lt;char, std::char_traits&lt;char&gt;&gt;`. The traits template parameter has to match in order for two types to be usable together, which means you can't do this: CaseInsensitiveString cistr; std::cin &gt;&gt; cistr; // nope! or this: CaseInsensitiveString cistr("foobar"); std::cout &lt;&lt; cistr; // nope! or this: CaseInsensitiveString cistr; std::getline(std::cin, cistr); // nope! You can't copy construct one from the other using the normal means: std::string str; std::getline(std::cin, str); CaseInsensitiveString cistr(str); // nope! Or assign: std::string str; std::getline(std::cin, str); CaseInsensitiveString cistr; cistr = str; // nope! You can copy construct by treating one as a C string: std::string str("foobar"); CaseInsensitiveString cistr(str.c_str()); // OK or if you need to support strings containing NUL bytes: std::string str("foobar"); CaseInsensitiveString cistr(str.data(), str.size()); // OK However, you lose optimizations that the library might be able to perform, such as the shared string copy-on-write trick that allows both instances to share the same allocation until one of them needs to modify the data. I believe that MSVC gave up on this one because of the overhead of required atomicity in the reference counting, but gcc/libstdc++ still does it. (MSVC does the small string optimization instead, iirc.) Anyway, the point is that it's not all nirvana and you essentially create a string type that is not compatible with all the usual ways that you're used to using strings. They can be smuggled in and out with care, but it's extra mental load. Compare and contrast this to just implementing a non-member function such as: int case_insensitive_compare(const std::string &amp;lhs, const std::string &amp;rhs); You give up the nice property of equality and sorting automatically becoming case insensitive, but you don't have to deal with two different incompatible string types. With C++11 it's easy to just pass a lambda if you need to sort case insensitively, so that's not really a big blow these days. 
http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html
The simplest example is signed integer overflow. Causing a signed integer to wrap in C is undefined behavior. GCC exploits this by optimizing out checks which would old be true for wrapping. (It does this when enough compile-time constants are involved.) Here's an example. Technically this should print "less than zero", but it doesn't on most (all?) version of gcc 4. #include &lt;stdio.h&gt; #include &lt;limits.h&gt; main() { signed int si = INT_MAX; if (si+1 &lt; 0) printf("Less than zero\n"); else printf("Greater than or equal to than zero\n"); return 0; } When wrapping is 'undefined', that means that adding one to a variable can never result in that variable being less than 0. GCC exploits that "Fact" to optimize this code... even though it breaks it from what we would expect based on our understanding of the hardware. 
Along with purevirtual's example, there's the check for NULL issue which I think bit the Linux kernel recently. The compiler can elide a check for a pointer being null if that pointer has already been deferenced as if the pointer were null undefined behaviour had been invoked. e.g. int do_a_thing(foo_t *foo) { if (!foo-&gt;is_valid) { return 0; } if (foo == NULL) { // This block will be removed /* ... handle null case ... */ } /* ... do stuff with foo ... */ } While this may look weird, the check for null could be in a macro or inlined function so the programmer won't necessarily know it's there. This can be an issue in kernel or embedded development as the NULL pointer (i.e. memory address 0) may be referencing actual data in those cases, but the standard says it can't.
&gt; … the new string type is by itself on a deserted island, inaccessible from the rest of the standard library. Nonsense. That’s why the standard library is parametrised. The whole point is that you *can* use it with custom types like this one. There are very few exceptions to this; by necessity, `std:cin` is one of them. But even that’s not true: you can trivially copy from `std::cin` to your case insensitive string using `std::copy`. You can copy between different string (or, indeed, any container) types by using the appropriate constructors – those accepting iterators. Incidentally, you *can* use `std::getline` (since it’s parametrised), you simply cannot use it with mismatching character types in the stream and the receiving string. If you don’t like that, you can write a pretty simple wrapper around `std::istream` to translate between different character traits.
Sure, just wrap this and adapt that and do things differently all throughout the code. All because you maybe wanted to compare strings case-insensitively in one place.
The title is kind of misleading. Writing C/C++ code (or in any language) that relies on undefined behaviour might and probably will break. Big whoop. Don't rely on undefined behaviour, then! I'd say no code is entirely future proof and stuff is bound to break, and will have to be fixed. That's simply the nature of software.
&gt; Then there is the fact that most developers use what they know, or the languages that interoperate better with the libraries that they need to use. All these reasons should make Java/C#/Ruby grow much faster than C/C++.
This. Just write standard-conforming C++ code, I don't understand what the big deal is. It's not like you don't have enough compiler flags to enable warnings (or even errors) when you're doing something that is undefined. 
Not if the people keep on using the default implementations, which still loose in performance against C and C++. Microsoft already recognized this, by compiling C# directly to native code when targeting Windows Phone 8 systems.
As a teacher I routinely see students who use the full VS IDE learn quicker than those who preferred sticking with the editor &amp; commandline setup they had been taught the year before. Sure that's not conclusive proof, but it's more than you offer for your argument.
In this case, the compiler knows that si started out positive.
You’ve missed the point: you do **not** do anything different all throughout the code. In your case, you use `std::istream&amp;` everywhere. I’m assuming that this is what you’re doing anyway because surely you don’t want to tell me that you write general-purpose code that accesses a hard-coded global singleton.
They *might* learn the language quicker, but there is a shed load of stuff they are not learning, * command line competence * How C++ program are actually built * the toolchain (compiler, linker, editor, debugger) * how to strucure a source directory * make files * how to find and read doc!!!!!! Note these skills are highly transferable to other operating systems, other languages, and even IDEs. And all of the bove skill I know for sure I couldn't do my job without. (In fact I know at least where I work, we wish more teachers would teach this stuff!) Instead they learn how to use a proprietary IDE that works on 1 operating system for a handful of languages. Also my argument was NOT that you shouldn't use VS, but that you hardly need VS to learn modern C++, in fact I find it slightly rich given how far behind MSVC is in implementing C++11 in comparison to clang and gcc. My guess is that you probably don't teach the command line way very well.
&gt; The only operation you may perform on a pointer that that has not been assigned to a valid pointer value is assignment. Nothing else. What about taking an address of such pointer?
The audio quality is horrible. Why bother to put a video online in so low quality?
Which optimization isn't allowed? COW or the small-string optimization? It was my understanding that "everyone" has decided that COW isn't worth the effort; I just want to know if I am misremembering.
This does not change the fact that your statement is plain wrong: &gt; When wrapping is 'undefined', that means that adding one to a variable can never result in that variable being less than 0.
That's just `std::bind(&amp;SomeClass::some_method, some_object)`.
**Technically** it should do whatever the compiler pleases, because it's undefined behaviour. That's the very definition of what undefined behaviour is. I know this seems trivial, but it's a very important distinction. New (and old) programmers need to recognize that just because some compilers may give you some convenient functionality doesn't mean that's what it should or must do.
Doesn't VS2010 not support c++11, and lambdas are c++11, right? That would mean you're adding functionality (support for c++11), not stability. I agree that his advice is poor (for example, "don't rely on undefined behavior" would be far better advice.) I'm just confused by your example and not sure if it means I am forgetting/confused about something or it just wasn't a perfect example.
There are also these cases where something is technically illegal, but in reality is required to work and works (because platform makes it like that). Like casting of void pointer to pointer to function. If i read std correctly this isnt allowed anywhere, so should just not compile. In reality this is required to work as both Windows api (GetProcAddress) and unices (dlsym) expose functionality of dynamic symbol (whatever it is) loading by returning void*.
I don't understand. string_ref extends string interface with methods like starts_with. Why do not add these methods in the string itself and make string_ref just a way to reference part of the string without make a copy? 
change `0&gt;age` to `age&gt;0`, and same for the 30, 60 cases. `0&gt;age` means the condition only holds if age is negative.
I did this and everthing is ok, except that after my answer I still get the **"You don't exist,don't you?"**... I am saying that is I write, for example 15 I get **"You are a little rascal!"** **"You don't exist,don't you?"** Not only the desired **"You are a little rascal!"** Wat do now?
`return EXIT_SUCCESS;`
Not exactly. With std::bind you have to insert placeholders for unbound arguments. This example assumes a member function with five arguments (from [here](https://groups.google.com/a/isocpp.org/forum/?fromgroups=#!topic/std-proposals/cYKftpr8D7k)): auto delegate1 = bind(&amp;A::f1, &amp;a1, _1,_2,_3,_4,_5); auto delegate2 = create_delegate(&amp;a1, &amp;A::f1);
The problem is coming from the use of else. When you fail the last if statement the "You don't exist..." always comes through. You should have an "else if" for all except the first options.
You don't need a `return 0;` at the end of `main`, and the cplusplus.com forum is hardly a good place to ask questions.
absolutely, i was trying to put a more ELI5 spin on it. different standards do allow for different return codes, which are a cross-language construct as well. C99 allows for the 3 return codes you specified to be platform-independant, but you can return other codes as well, depending on the platform. Windows, for example, has quite a few well-defined exit codes: http://www.hiteksoftware.com/knowledge/articles/049.htm
It doesn't sound like hes teaching his students how to use the command line, it sounds like hes teaching his students how to write some basic C++.
There's /r/cpp_questions and /r/learnprogramming that both offer good advice. The problem with the cplusplus.com forum is that it tends to be full of people using the cplusplus.com tutorial.
this is about return statements generally. returning from main is slightly counterintuitive, because in non-main functions, return usually means "return control to wherever I was (with this value)". the main function is a special case of that, because the "wherever I was" is not within your program, it's actually the OS.
It says that in the first sentence.
This really isn't different from the generalized currying that was originally intended when C++11 added variadic templates and std::move/std::forward for.
You do for this main.
listen to EMC0n if(age &gt; 0 &amp;&amp; age &lt;= 30) {} else if(age &gt; 30 &amp;&amp; age &lt;= 60) {} else if(age &gt; 60 &amp;&amp; age &lt;= 100) {} else {} you should also test that their input is a number. 
That is actually an excellent example and I fully agree that in that case one can reasonably ignore the standard. Interestingly, C++11 added new language to accommodate dlsym, basically allowing for conversions between void* and function pointers in certain cases.
I'm still trying to understand why he is using a \n on the first output statement and then using endl every where else. I'm just picking but it's kinda driving me crazy. You guys definitely have answered this for him already. Happy coding :)
http://www.learncpp.com/cpp-tutorial/52-if-statements/ Great place for learning or reviewing the basics. 
Yes, but if a person just wants to check some syntax or see the parameters to a function then it makes a lot more sense to look on cplusplus.com, rather than asking on reddit and waiting for an answer.
C++ has 'and' and 'or' as keywords. I don't see a lot of people preferring these over their C counterparts. I use them exclusively in new code, and advise our junior developers to do the same. I'm not aware of any downsides of using these over the C versions - does anyone have an opinion on this?
&gt; Technically only EXIT_SUCCESS, 0 and EXIT_FAILURE are strictly conforming, returning anything else is undefined behavior. Really? Undefined behavior? For instance the man page for GNU make says: "A status of one will be returned if the -q flag was used and make determines that a target needs to be rebuilt. A status of two will be returned if any errors were encountered." That's not the only program were I remember the documentation saying that it could return some other, well defined, values. Not that I don't believe you though, I might have just learned something, I just find it very surprising if some standard GNU tools would rely on undefined behavior. And of course I do know that e.g. GNU make is not written in C++, so is this a thing specific to the C++ standard? 
Not an answer, because others have provided that. But check r/learnprogramming it's much more suited to things like this.
Note that after you fix the &amp; to &amp;&amp; you still don't have the "else if" statements right so you'll end up printing "You are a little rascal" and "You don't exist, do you". You need to use "else if" instead of "if" in the second and third clauses.
It's actually implementation-defined, not undefined. So the behavior needs to be documented somewhere. The behavior is not always obvious, though. On Linux, for example, returning 256 from main will actually result in an exit status of 0 (*success*) because exit status codes are restricted to 8 bits.
So, what actually happened is that purevirtual messed up and doesn't want to admit it. The example that he probably wanted to show was (note the condition in if): signed int si = INT_MAX; if (si+1 &lt; si) printf("Less than zero\n"); else printf("Greater than or equal to than zero\n"); return 0; This holds, because adding one to a number can never be less than that number (if wrapping is turned off). However, purevirtual messed up, got the example wrong, and he doesn't want to admit he was wrong. I find that kind of sad really. And the downvotes come, I guess, from people who don't really understand the issue here.
OK, thanks. That makes a lot more sense. 
I like `auto` when implementing stuff, but this overuse is just obnoxious and obscures too much.
Kind of ironic that their example doesn't have a return statement in main either...
Care to provide a quote (or just paragraph number)?
One of the problems with using delegates in C++ is that you need to define the lifetime/ownership of the delegate in relation to the object on which the method is called. The delegate must not outlive the object, in other words, and this relationship is likely to be highly domain-specific. This is the *real* trouble with pointers. Any generic delegate implementation will force the user into a specific usage model — this one uses raw pointers, which are notoriously risky, another could use shared pointers, which are too slow for some use cases, and yet another could use some other type of pointer (for example one that enables automatic garbage collection or similar). This is why I believe that any project that benefits from the use of delegates will necessarily end up implementing its own set of classes for it. Example: In my most recent game engine, there's a signal/slot system for world entity communication that's implemented in terms of delegates — each one holds an `ObjectPtr&lt;Foo&gt;`, which has clearly defined lifetime characteristics (i.e. an `ObjectPtr` cannot outlive the currently loaded level).
Nope, their book is better for checking syntax, and http://cppreference.com is generally better as a standard library reference.
If main is given by the signature `int main()` as it is in this case then the compiler expects the function to return an int. If omitted then you'll get a compile warning, perhaps an error, and undefined behaviour (but I expect that the program would return `0` anyway). If main was given by the signature `void main()` then you would be totally right and `return;` could be used to exit from the program at any point. Who knows what the OS will get as a program return value, probably `0` again. I don't know what the current C and C++ standards say about the signature of main. C probably says that `void main()` and `int main()` are both acceptable, C++ probably says that only `int main()` is allowed. But either way I think it's good to tell the OS, and the caller, about the status of the program on exit.
EDIT: removed spoiler.
Irony detection has been greatly improved in version 4.1
False on all counts. The C++ standard states (C++03, 3.6.1.5): &gt; A return statement in `main` has the effect of leaving the main function (destroying any objects with automatic storage duration) and calling `exit` with the return value as the argument. If control reaches the end of `main` without encountering a `return` statement, the effect is that of executing `return 0;`. Furthermore, the standard states (again C++03, 3.6.1.2): &gt; An implementation shall not predefine the `main` function. This function shall not be overloaded. It shall have a return type of type `int`, but its type is otherwise implementation-defined. `void main` thus ill-formed (and has been since ANSI C, where only `int main(void)` and `int main(int argc, char *argv[])` were allowed). The same is true, with slightly different wording, for C++11 and for the current latest draft (N3485).
Didn't read, here is my guess: call function pointer.
&gt; But some people consider it a superior style. So that's how I'm going to look at it: It's just like bracing and tabs/spaces. So you say there is not objective reason to call somebody who is willing to do extra typing which doesn't add any flexibility and only makes reading the API harder a plain old idiot? I hadn't realized I was such a bikesheder ...
Ok, I'll admit I was wrong about omitting `return 0;` resulting in undefined behaviour but I was correct about the assumed return value, and about which signatures are acceptable. I don't think I'm going to stop putting `return EXIT_SUCCESS;` at the end of my `main` functions however, mostly because it looks terrible to have a function defined to return and `int` and then to not explicitly do so.
&gt; So you say there is not objective reason to call somebody who is willing to do extra typing which doesn't add any flexibility and only makes reading the API harder a plain old idiot? That wasn't what I ever said, but now that you put it that way, I can say that no, there is not an objective reason to call the author an idiot. At all. But it does add flexibility in terms of the simple fact that the alternative syntax allows the compiler to make type deductions with expressions like `decltype` that are otherwise not legal in the traditional syntax. Using the alternative syntax for consistency adds some small amount of clarity in that case. But calling him an idiot for it is inappropriate, since it is clearly a matter of style.
No, the downvotes come from people like me who can see you're plainly right, but think you're being a bit of an arsehole about it. Your vindictive tone is unnecessary. It's possible to communicate technical details and still be polite. Besides, modern compilers (GCC included) are often able to reason about code like purevirtual's example, and realise that `si` is a positive value (regardless of the fact that it isn't const). I would fully expect a static analysis to catch these types of mistakes.
&gt; It's possible to communicate technical details and still be polite. Please quote which part of my comment was not polite: http://www.reddit.com/r/cpp/comments/16ysbr/c_and_c_arent_future_proof/c80sxbo &gt; Besides, modern compilers (GCC included) are often able to reason about code like purevirtual's example Again, I never said they are not. I just pointed out that his statement about adding one to the variable is wrong. Why is this so hard to grasp?
&gt; However, purevirtual messed up, got the example wrong, and he doesn't want to admit he was wrong. The above line is deeply patronizing and conflict-seeking.
It doesn't even have to be a different object: int main(void) { Puzzle r1(1); r1.change_x(r1, 2); printf("%d\n", r1.get_x()); } 
I can't see how a function pointer can be used for this (remember, casts that for example change Puzzle* to void* are forbbidden).
Some pretty weird restrictions. I would have guessed the solution was to cast to another type with the same memory layout. Since you're able to change the class definition though, there's lots of other ways too. 1. Friend class/function 2. Constructor w/ placement new 3. Copy constructor 4. Just make x public!
If it's in memory, it can always change, that's what we have pointers and casts for after all. And even when you don't want to make muck around with pointers and casts, you can always do: #define private public `private` is not a security feature, it's simply a way to mark the programmers intend. It's a "Don't touch this" sign so to speak, not a bank vault. Also the solution to the puzzle is really contrived. If you want `x` to remain `const`, you declare it `const`, you don't `const` all the method, which has a completely different purpose, namely making those method callable on `const Puzzle`. Also having a member function that does nothing with member variables is really bad style, it should either be a static method or not be part of `Puzzle` to begin with. 
But the point of a puzzle is to solve it with given restrictions ;) Constructors do not change the value of x after an object is created, but create a new object. x must be private. Friends are not explicitly ruled out, so this is indeed a valid solution (although not the one I had in mind).
With `bind` in c++ you can use different pointers types. You can write this `bind(&amp;SomeClass::some_method, this)` or this `bind(&amp;SomeClass::some_method, shared_from_this())`, or you can use a custom pointer type as well, as long as override the `get_pointer()` function. This is the way it works boost, and I believe it works this way in C++11 as well(maybe even in TR1, too) So the lifetime management and delegation part can be separated.
I think you missed the point of the puzzle. It was not an excercise in nice design practices, but an ilustration of a C++ feature that is counter intuitive to many (even some experienced programmers are not aware that private works on a class, not an object level).
That was not the original reply I had for purevirtual and is not the one that was most downvoted. I gave you a link to my comment, yet you take a sentence out of another comment, made *after* the downvotes.
`change_x()` can also be declared `static` (in which case it obviously doesn't need the `const` qualifier anymore) and it still works.
Right. I'd advocate `std::bind` as well, although I have to say that it does come with some overhead (often you'll rely on `std::function`, which heap-allocates in some implementations). In my case, though, the only reason I'm not using `std::bind` is that I need a greater amount of flexibility, mostly due to metaprogramming and marshalling.
One reason it’s a good thing: copy assignment and copy construction are vastly simplified in cases where implementation doesn’t quite match actual interface. The language designers want it to be fast. It’d be annoying to know the private data is *right there*, but have to add overhead to make copying work. Or something.
The idea is nice but they are not supported on Visual C++.
That’s simply not up for discussion. Calling a constructor via placement-new doesn’t change the object’s `x`, it creates a new object, with a new `x`. This is well defined in the C++ standard.
&gt;The proposal is based on the Boost Any Library (see www.boost.org/libs/any). The Boost version of Seriously, all library extension proposals should go through boost.
They sure do.
Write well written working programs. 
Not sure what your question is [but is this close](http://ideone.com/9AjqQk)? The way I see it I see no reason to use any inheritance at all in your proposed case.
Work on your own projects or open source projects in your spare time, go back to school, start your own company, or have sex with the boss. I recommend the first two options. Seriously though, there's no magic bullet.
My general advice for you: don't blindly follow design patterns - you are bound to fail if you do so. In your case you have Fruit interface - fine. You can provide part of implementation in Fruit_PI - still fine, by all means do so, this will save you copypasting in concrete classes (copypasting is bad;). This should leave you with following hierarhy: class Fruit; //abstract class Fruit_PI : public Fruit; //abstract class Apple : public Fruit_PI; //concrete Dont go the path of multiple inheritance (especially used in OO manner with virtual inheritance) just for the benefit of implementation details. You dont need it, and in your sample it made a mess - nobody is gonna understand what you ment there using it. Above (linear) inheritance chain is _much_ clearer and does the same thing. &gt;I feel that I have been unsuccessful in achieving separation of interface and implementation. Clients of Apple will manage them through Fruit interface. You provided separation there - its fine. If you ask yourself a question 'why did i do that' and answer with some abstract shit like 'its best practice'/'because design pattern' then you probably did that wrong. What to do in general? Nobody knows, if someone claims he does, its probably wise to take him with a grain of salt (or call bullshit). Also, as a side note. If you have member functions that use only public interface of the class it _may_ be a sign that something is amis there. 
True, if we want to be as pedantic as possible :) According to the standard, object lifetime ends ends when the object storage is released or reused (as it is with placement new). I'll still happily argue it's a fine enough solution to the problem as stated since, effectively, all that has changed is the value of X. Even if the class had other members.
I love teaching others to develop my skills. Nothing makes you learn things better. Perhaps hang out on ##c++ or ##c++-basic on IRC (freenode). Perhaps go on stack overflow, or /r/cpp_questions. Also, get other people to comment on your code. Post some snippets to /r/codereview. 
&gt; I've been looking for some kind of entry level work to switch from what I'm doing (help desk) into programming, but a lot of the job postings I find are asking for experience. Depends on the type of job. I personally look for experience in understanding how to write code in general, less so for a specific language. Up until 2012, I hadn't used C++ for ~5 years. Suffice to say I forgot 60% of the language. But I knew how to organize and design software, which is the important part. So learn C++, it is a powerful language, but learn why things are done the way they are done. That is the most important lesson you can learn, one that will stay with your throughout your career. As for how to get a job, well, it depends. If the job post is specifically for someone skilled in a particular language then the interviews will be a mix of language questions and design questions. Sure you have to know how to declare a class. But when should you use a class? When should you use inheritance versus some other technique? A lot of that you pick up over the years, but going in with some idea is important. If you subscribe to the various programming subreddits and read through the links, you'll begin to get an idea. The c2 wiki is also valuable, though very dense and hard to understand at first. (I started reading it ~10 years ago I think, initially it made next to no sense!) Now as for what to do, well, make something. Pick some stupid arbitrary task. Start off with simple home projects like a maze generator and then move on to things you can actually show off. If you have a constant annoyance when using a computer, something you want automated, go and solve that annoyance!
The thing that makes you a "C++" programmer over many of the other languages is stuff like memory management, familiarity with lots of different libraries, etc. Most of the time employers don't (or shouldn't) care about your preferred language as long as you know how to write code, but if I was looking at a Java developer for a C++ position I'd want to make sure they understand how to manage memory
Yea, I was wondering about that too...
Needless to say, productivity went down?
As mentioned by Herb Sutter (in Exceptional C++ and More Exceptional C++) and Scott Meyers (Effective C++ and More Effective C++) private inheritance is useful instead of membership in cases when you need to override virtual members (which you do as Fruit is an abstract class) or you need access to protected members (not relevant in this case). So, yes, private inheritance (given the code you've given) is usefully applicable here. FYI, you can also use it to "join" different classes from independent object-oriented hierarchies as a sort of compatibility layer (see The C++ Programming Language, Part IV: Design --Stroustrup). My guess is that your code is analogous to something else so I say just this: it very probably should (assuming you are the author of it all) be reworked to a much better design.
To be honest, I don't really like this use of OOP &amp; dynamic polymorphism -- it's hard to see a justification for it in this case (perhaps there are some additional, unstated assumption you haven't shared with us?). Unless you *really* need dynamic polymorphism, I'd suggest GP &amp; static polymorphism instead. In this case, it results in shorter and easier-to-reason-about program (once it compiles it's guaranteed that Apple and Orange model the (implicit) Fruit concept); compare: OOP: http://ideone.com/NEHyQv GP: http://ideone.com/thtyjD In case you're wondering, the verification of the existence of the respective member functions is done by the compiler (compile-time duck typing) -- if you attempt to use "print_net_profit" function passing an argument of type which doesn't model the (implicit) Fruit concept, the program won't compile (and thus your end-users will never face an error at run-time, an additional benefit). If you *do* need some extra structure (I can't see why, given the provided information, but will give an example just for the sake of completeness) compared to the above compile-time duck typing, feel free to use CRTP, for instance (quick and ugly): GP w/ CRTP: http://ideone.com/BiVB56 // or even http://ideone.com/C0ApEK Explanation: http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Curiously_Recurring_Template_Pattern
If the goal was to write some very abstract code using abstract interfaces, then having virtual functions only use the public virtual member function interface --as a "default" maybe might make sense. However every single (virtual) function call is realistically via two pointers (i.e., 1 for the vtable and 1 for the function pointer), i.e., it is very costly so the abstraction better be worth it! EDIT: Use templates (i.e., generic programming). It is *much* faster and likely totally sufficient for your objectives.
Good old c++. Doesn't stand on ceremony when you're really keen on breaking encapsulation.
mttd: Thanks so much for illustrating your answer with code. I am carefully reading the four code examples you have provided. I am guessing that dynamic polymorphism was popular at the time the book was published (1994) which is why the book emphasizes it. 
Thanks for your insight. I agree on not following the design patterns blindly part. However, there are many ways to solve a problem in programming, some right, many wrong. I dont yet have a feel for what makes code good (extendible, maintainable, readable etc). Lacking this understanding, design patterns are a great way to orient myself in this landscape.
I am just starting to wrap my head around some of these concepts. I know my design is really far from ideal. So any hint as to how this design can be reworked would be much appreciated. 
This isn't really a case of breaking encapsulation, not is this a unique feature of C++. Heck, unlike a lot of other languages, at least you can specify the field as being const and having value semantics to provide clearer encapsulation.
 #define and &amp;&amp;
Find an open source C++ project. I used to work on ITK and while it is difficult to grasp if you put in the time, follow the developers guide in the software guide (http://www.itk.org/ItkSoftwareGuide.pdf) and communicate with the community you can earn a good reputation. And if you put in some time to learning the basics you should be able to find a mentor to help you. But I guess the same would go for any project that has an existing community. 
This is a great idea. I've been wanting to get myself a 68k and development board for years - my first real introduction to programming, at college, was in assembly on these. I might just have to do it now. But I might have too many personal projects in at the minute. Maybe when I've finished a few. It can be, like, a reward :D
It's not a bad idea, the question is, why not use a reference in these cases? A reference has the same implied "it's managed elsewhere and we know about it" meaning. 
nor can the target of the reference be modified.
That is merely a consequence of references not being assignable after initialization. Your two code samples are not even doing the same thing (never mind that you're using **a** in your asserts rather than **r**). The correct way would be either: #include &lt;memory&gt; #include &lt;cassert&gt; struct A { virtual char getN() { return 'A'; } }; struct B : public A { virtual char getN() { return 'B'; } }; int main() { A a; B b; A&amp; r = a; assert(r.getN()=='A'); r = b; assert(r.getN()=='A'); //////////////////// std::unique_ptr&lt;A&gt; ap(new A); std::unique_ptr&lt;B&gt; bp(new B); A* rp = ap.get(); assert(rp-&gt;getN()=='A'); *rp = *bp; assert(rp-&gt;getN()=='A'); } or #include &lt;memory&gt; #include &lt;cassert&gt; struct A { virtual char getN() { return 'A'; } }; struct B : public A { virtual char getN() { return 'B'; } }; template &lt;typename T&gt; struct ref { T&amp; pointee; T* operator-&gt;() const { return &amp;pointee; } operator T&amp;() const { return pointee; } ref&amp; operator=(T&amp; pointee) { return *new (this) ref{pointee}; } }; int main() { A a; B b; ref&lt;A&gt; r{a}; assert(r-&gt;getN()=='A'); r = b; assert(r-&gt;getN()=='B'); //////////////////// std::unique_ptr&lt;A&gt; ap(new A); std::unique_ptr&lt;B&gt; bp(new B); A* rp = ap.get(); assert(rp-&gt;getN()=='A'); rp = bp.get(); assert(rp-&gt;getN()=='B'); } The reason you can't get the address of a reference is simply because references are allowed to be elided by the compiler and allowing their address to be taken would force them to occupy a memory location in many cases where the compiler can't prove you're not taking its address.
I agree. It's vitally important that anything that the C++ standard library is going to be lumbered with forever is properly tested in the real world first.
And often, that's *exactly* why you want to use them - because then you (and the compiler) know for a fact that you will never have a null value, you can design things better (and the compiler can optimize more, etc).
version 4.1 has associated new license fee and terms
Polymorphism. References are also a problem if the class should support assignment, or changing the object after construction.
Hopefully anyone who uses this in production gets thrown in the river with cement booties by their bosses henchmen
So we are proposing something that acts like a raw pointer, but has a different template-based declaration because ... raw pointers are difficult to grep and some coding standards discourage the use of raw pointers?
I guess you could clarify: You can't change which target a reference refers to. Your statement could also be read as if you cannot change an object through a reference to it, which is of course false. :)
This looks interesting. Which compiler actually supports that? ideone.com did not... I'm guessing clang or g++
&gt;So we are proposing something that acts like a raw pointer Something that acts like a sub-set of raw pointers that eliminates many classes of undefined behavior.
Yeah, I actually took a few attempts in phrasing that and it was still ambiguous. But I think the point has been made.
It is most likely code specific. There are too many differences between debug and release executables to help you with the information you've posted.
One source of such problems in gcc at least is that a function that should return something doesnt. int foo() { blah; bloo; } Another source is that variables get initialized in the debug builds but they just use whatever random ram was around at that position in release build, so make sure all your data gets initialized correctly. 
The issue is that a rand() call is returning the same value every single time when normally executed, while actually returning different values when debugging. What the hell. I'm seeding it with srand(time(NULL)), if that matters
Without a sample of the code, it's hard to say. Most of the times I've seen stuff like this was when people didn't initialize their memory correctly, or they walked off the edge of a data structure. (or they fucked their stack, or a hundred other memory issues) see also: load-bearing printfs
Try seeding with the PID of the process, or the combination of time(NULL) and the PID and see what happens.
Are you seeding it once at the start of program execution, or every time you call it? Because if it's the latter it will be called many times per second with the same seed, so will return the same value. But if you step through the debugger it will probably be seeded with a different value each time because it will take more than one second between calls
After seeing this I am convinced you are seeding every time you call rand 
It's pretty obvious from what they say that they aren't seeding once, they are seeding every time they call rand(), with predictable results
For C++, I think you'd need at least a 42" monitor to read it properly. :)
Here is the CLOSEST you will EVER get to a cheat sheet http://goldns.ru/cppmap-2012.png
Yes, and the authors even give the reason for it : if you are reading a header and you see the following code T foobar(S* s); you do no know what the ownership is of the parameter in question. Are you supposed to delete _s_ after calling _foobar_, or will it be stored as a member of the return object which will delete it in its destructor? In contrast with T foobar(std::exempt_ptr&lt;S&gt; s); it is made explicit in the header that s doesn't change ownership over this function and that the caller is still responsible for deleting it later.
Ah, the infamous [Heisenbug](http://en.wikipedia.org/wiki/Heisenbug).
Dynamic polymorphism itself works correctly with references on initialization: http://ideone.com/iMikIz It will also work correctly on pass-by-reference (there's no reason to use pointers for arguments passing just to achieve dynamic polymorphism). Arguably, unchangeable &amp; non-nullable binding is a plus (programs are easier to reason about) -- that being said, I see a case for pointers when you really do need changeable binding (and possibly only then, use references otherwise).
http://www.reddit.com/r/cpp/comments/166uje/is_there_a_complete_and_concise_c_and_stl_summary/ In particular, for standard library: STL Quick Reference: http://www.medini.org/stl/stl.html Versions 1.33 and above moved to http://code.google.com/p/stlqr/ // Unfortunately, as of version 1.33, no C++11 update yet For the core language (with occasional mentions of the standard library), perhaps one of these: - http://www.ifi.uzh.ch/vmml/teaching/lectuces/systems-hs12/C_plus_plusRef_Card.pdf - http://www.pd.infn.it/~bertolin/Cpp.pdf - http://laurel.datsi.fi.upm.es/_media/docencia/cursos/cplusplus/cpp_reference.pdf - http://www.hoomanb.com/cs/QuickRef/CppQuickRef.pdf I really hope you mean wallpaper as in a bunch of printed out *papers* to be posted on the *wall* -- otherwise, good luck stretching the monitor ;-) 
This is a good advice. OP, see also "How Non-Member Functions Improve Encapsulation" by Scott Meyers: http://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197 It's also used in, for instance, C++11's std::begin &amp; std::end -- which allow the user-defined types to be non-intrusively (i.e., *without* modifying the original class definition!) adapted (e.g., by providing the appropriate overloaded functions) to the algorithms expecting a type modeling a Range concept (i.e., relying on the presence of the "begin" and "end" functions) -- like the range-based for loop. It's funny how GP actually allows one to realize the open/closed principle /* http://en.wikipedia.org/wiki/Open/closed_principle */ better than OOP (IMO) ever did (note how "both ways use inheritance" mentioned in a Wikipedia article is a limitation of OOP languages, not a general limitation, and doesn't apply to C++).
I've ran across it a few years ago, it's a very interesting library. That being said, this seems somewhat worrying: http://www.ohloh.net/p/stxxl/commits/summary
Ideone.com's GCC is ancient, unfortunately they don't seem to care. Try one of these: - http://liveworkspace.org/code/2nXwzu$0 - http://stacked-crooked.com/view?id=be4d008b2604c168c917f2d777e4cc0b Interestingly, Clang 3.2 (available @ liveworkspace.org) refuses to compile -- any ideas why?
Yeah I fucked up, I had accidentally put srand in a for loop instead of right before it.
Checkout the TPIE project for a more active maintained project that's been around for more than a decade. It has similar (but not identical) goals to STXXL http://www.madalgo.au.dk/tpie/ http://www.ohloh.net/p/tpie
Interesting! What are the main differences?
You're right no one should ever visit any reddit that they aren't bias towards so we can all live in our little glass houses.
*STXXL* * Based on the consept of an external vector, disk data is indexed with iterators into this external vector. * Good multidisk support. * Requires seperate scrach partitions, and is generaly hard to use. * The user is in charge of all memory managment. *TPIE* * Data is accessed by file streams, with read, write and seek methods. * No multidisk support * Does not require any special partitions and is generaly easyer to integrate into a usable product. * Most of the memory accounting done by the framework. In a test on a fast multidisk system, where tpie was just run ontop of a striped raid, and stxxl was tuned for optimal performace over this pacitular array. stxxl was almost twice as fast at sorting a substantion amount of data. (This test was done by one of the stxxl developers)
Thanks! 
Maybe you should be using the C++ random number stuff instead of the C. That might help improve it.
If you're referring to UNIX pipes then there's a fair difference - one is interprocess, asynchronous communication and the other is in-process and (I assume) fully synchronous. The latter is more like composing operations/computations using lazy sequences and generic algorithms. Data are processed as completely as possible before more are generated.
&gt; The latter is more like composing operations/computations using lazy sequences and generic algorithms. Obligatory mention of monads here.
A little late to the party, I can't see how searching in a vector of unsigned chars for 255 and finding the -1 item is a bug, that is the correct presentation of the bits. I'm really afraid about the change they made, it'll break code.
No g++4.7 support? 
the umbrella term of both sse and comet is sever push.
All of the arguments for using C++-style casts apply here. Easier to grep, less error-prone, and the programmer's intention is more explicit.
Thanks for the Sutter reference. I'll check it out. 
One general advice (if you follow it you're much more likely to get help): "If you are having a problem with some code and seeking help, preparing a Short, Self Contained, Correct Example (SSCCE) is very useful." http://sscce.org/ See also: http://www.parashift.com/c++-faq/posting-code.html StackOverflow is pretty good. Yahoo! Answers is not so good, no moderation (plenty of duplicate questions), the answerers often even more clueless than the OP, often suggesting solutions using some horrible C-with-classes compiling only on Turbo C++ from the 1990s. Avoid. IRC: ##c++-basic, ##c++ on irc.freenode.net // http://www.jonatkins.org/fncpp/ Usenet: - alt.comp.lang.learn.c-c++ http://www.faqs.org/faqs/C-faq/learn/ http://groups.google.com/group/alt.comp.lang.learn.c-c++/ - comp.lang.c++.moderated http://www.gotw.ca/resources/clcm.htm http://groups.google.com/group/comp.lang.c++.moderated/ - comp.lang.c++ http://www.parashift.com/c++-faq/how-to-post.html http://groups.google.com/group/comp.lang.c++/ Last but not least, http://www.reddit.com/r/cpp_questions :-) // BTW, if you need to ask a compiler-specific question, there are also compiler-specific communities (easy to find via any good search engine) -- but it's always best to write portable code :-)
I've yet to meet a competent C++ programmer that didn't find undefined behavior in their or their peers' code now and then. Once ever 1kloc sounds about right in my limited experience.
&gt; I see a third party step in and point out such and such case where it's useful. Yep. This happens a lot, it's not just you. Just one example, from my experience: Fresh out of school, a couple months into my first job, a senior developer launched into a long lecture on why we are very careful to evaluate upgrades to our compiler. See, everyone told him it was just a better, faster, compiler, but a bunch of their code broke all over the case. They even found the bugs, and reported them to the compiler vendor, but the vendor refused to fix the bugs! For example, they had some code that did "f(i++)+g(i++)", which used to increment "i" by 2 every time, but they "broke" it and it started incrementing "i" only by 1, causing massive failures elsewhere -- buffer overruns, underuns, dangling pointers, you name it. I didn't realize it at the time, but it's obvious now... multiple increments to the same location between sequence points constitute undefined behavior. The compiler team had added a [common subexpression elimination](http://en.wikipedia.org/wiki/Common_subexpression_elimination), and it worked fine save for changing undefined code like this. And since the compiler is permitted to do whatever it wants here, it is certainly permitted to do something *else* it wants. And it did. It was always undefined behavior, but this developer didn't know it was undefined because it "worked" for what they wanted it to do... up until it stopped working. So mostly I learned from this that even "experts" can be very wrong, and this developer was an expert in how people commonly wrote C code and not an expert in the C language itself. *tl;dr* Undefined behavior can often "hide" for a while by doing exactly what you think it ought to do. Don't believe everything you're told -- think critically and dig deeper.
Yes, if the private field is mutable it can be modified from const methods. Is there a reason to prefer the approach prevalent in this thread over mutable (which appears to be geared specifically for this purpose)?
This is just a puzzle, you wouldn't ever do this, because it doesn't circumvent anything (Using this method, you can't change x if your object is const.)
Perhaps it will be useful: [Lesson 24. Phantom 64-bit errors](http://www.viva64.com/en/l/0024/).
It's not very common in practice. I've seen the one with linear inheritance Fruit-&gt;AbstractFruit (with partial implementation)-&gt;IFruit a lot though, but it tends to lead to huge balls of spaghetti with a derived class calling its parent which calls the derived which calls the parent of the parent etc. If you can, use inheritance for interfaces only, and use composition instead to abstract functionality. In this case you could have a class ProfitCalculator, which would take qty/sellPrice/costPrice and return the profit. Apples and oranges would use it, but it wouldn't be part of the base classes. The benefit is that you split more functionality into a separate class. A common problem in practice is that as you add common functionalities in Fruit_PI, it becomes massive. I've seen an equivalent class with 1000 lines, with a derived class of 3000 lines. By composing other objects you reduce what's inside the Fruit classes and make it easier to test. It's also easier to work with the class because what you see in the class definition is what you get: when maintaining later you don't have to dig up the hierarchy to find the members and guess what you're supposed to use. I've seen people make the members "reusable" by putting them in a separate class like HasQuantity, HasPrice (and use multiple inheritance), or use CRTP, etc., but it gets hard to follow when you maintain it later. If you have a lot of common variables between classes you'll probably be better off putting them in a new class, rather than stuffing them in the base class. For example if all fruits have a qty, color, and size, you could make a new class e.g. FruitCharacteristics and just have an instance of it in each derived class. If your fruits need timer functions to calculate how ripe they are, instead of stuffing timer functions in the base class, make a separate class which takes a callback. And so on. I highly recommend "Working Effectively with Legacy Code" if you're interested in this kind of thing, it's a good "real-world" complement to the fancier patterns in other books :)
I probably use cppreference.com, cplusplus.com, and msdn more than I care to admit.
a "number" in a traditional computer is represented as a series of high and low bits, for a signed integer type this usually means two complement, you can read about that here: http://en.wikipedia.org/wiki/Two's_complement the easiest way to count those bits would be: std::size_t count_set(std::uint32_t i) { std::bitset&lt;32&gt; bs(i); return bs.count(); } Working example http://ideone.com/eF9Srp bitset doc http://en.cppreference.com/w/cpp/utility/bitset/bitset I think your employer were probably however asking for the caveman bit bashing approach though which can be done like so: unsigned count_set(std::int32_t val) { unsigned sum=0u; for(unsigned i=0u; i!=32u; ++i) { sum+=0x1 &amp; val; val&gt;&gt;=1; } return sum; } working example http://ideone.com/IwIicO In honesty I vastly prefer the bitset solution, it can be treat like a black box and there is less to go wrong. Also most enviroments/platforms will provide a function to do this. These could also be templatized to count the number of bits set in any POD. In fact I have written such a generic version here: template&lt;typename T&gt; std::size_t count_set(T in) { std::size_t sum=0; for(std::size_t j=0u; j!=sizeof(T); ++j) { char val=reinterpret_cast&lt;char*&gt;(&amp;in)[j]; for(unsigned i=0u; i!=CHAR_BIT; ++i) { sum+=0x1 &amp; val; val&gt;&gt;=1; } } return sum; } http://ideone.com/rrq4B2
In your second and third code the order of statements `val&gt;&gt;=1;` and `sum+=1&amp;val;` is incorrect. Now the functions ignore the lowest bit of val as it is shifted before you read it.
Good catch (amended), exactly why I prefer the bitset approach! Also serves me right for copy and pasting the middle second in the 2nd and 3rd example.
Your inner loop is needlessly linear, counting can be trivially parallelized. A better version is this: std::uint8_t popcnt(std::uint8_t value) { value = ((value &amp; 0xaa /* 10101010 */) &gt;&gt; 1) + (value &amp; 0x55 /* 01010101 */); // 4 2-bit counters value = ((value &amp; 0xcc /* 11001100 */) &gt;&gt; 2) + (value &amp; 0x33 /* 00110011 */); // 2 4-bit counters return ((value &amp; 0xf0 /* 11110000 */) &gt;&gt; 4) + (value &amp; 0x0f /* 00001111 */); // 1 8-bit counter } Or the general solution for any unsigned integer: template &lt;typename T&gt; typename std::enable_if&lt;/* T is unsigned integer */, T&gt;::type popcnt(T value) { constexpr std::size_t bits = sizeof(T) * 8; for(std::size_t x = 1; x &lt; bits; x *= 2) { // Lower x bits set, next x bits unset T mask = (T(1) &lt;&lt; x) - 1; // Repeat pattern to fill the available bits for(std::size_t y = x + 1; y &lt; bits; y *= 2) { mask |= (mask &lt;&lt; y); } value = ((value &gt;&gt; x) &amp; mask) + (value &amp; mask); } return value; } Of course, if the CPU has a `popcnt` instruction for the desired type, then that will usually be better.
Many ways to solve this (as you can see from the answers you've already received, some better than others). Another simple &amp; straightforward approach is to use a lookup table with 256 entries. Each entry is a value between 0 and 8, representing the number of set bits. LookUpTable[0] would hold 0, LookUpTable[127] would hold 7, etc. Just 4 lookups and 3 shifts. This is a hybrid approach that is faster than iterating over all 32 bits, but slower than a non-portable inline assembly routine. Of course, you could also use nibbles (4 bits) or 16 bits at a time if you've got the space. It can also be implemented in C (I see you're an EE like me, chances are you spend a lot of time in C land as well...) (Too lazy to write the code, but I hope you get the idea...) Edit: BTW, check out [this answer](http://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer/109025#109025), seems to be pretty handy...
Lua is MIT licensed, so if I learn it and get good at it and at interfacing with my existing c++ code, I can use it for all my projects both closed and open source. Jx9 is basically GPL licensed. I do not see enough differential benefit to switching to something less flexible in terms of licensing.
isn't Thrust the same thing? you can use it with omp or cuda back end
Regarding the last code snippet, consider: Thing t1 = { 1, 0 }; Thing t2 = { 1, 2 }; Thing t3 = { 2, 1 }; compare(t1, t2); // returns false compare(t2, t1); // returns false compare(t2, t3); // returns false compare(t3, t2); // returns false So t1 and t2 are unordered, t2 and t3 are unordered. Assuming compare is a strict weak ordering, by transitivity, t1 and t3 are unordered compare(t1, t3); // returns true So the compare function is not a strict weak ordering. Correct implementation is: bool compare(const Thing &amp; t1, const Thing &amp; t2) { return t1.a &lt; t2.a || (t1.a == t2.a &amp;&amp; t1.b &lt; t2.b); } EDIT: try writing a compare function for struct Thing2 { int a, b, c}; EDIT2: the answer on drdobbs.com seems wrong as t1.a*t1.a can overflow.
Jx9 is licensed under the Spleepycat (BerkeleyDB) license not GPL.
Thank dmor for your response. Although I worded my question in an abstract way, my main concern was indeed maintainability and extensibility. Although I am relatively new to coding, there already have been too many occasions where I have had to go back and tweak the code or add something. That is when OO finally started 'clicking' for me. Few other people, like you, have suggested the route of composition, which I will consider henceforth in such situations. Inheritance, however, is put on such a high pedestal that it makes n00bs (like me) think that if we arent using inheritance, we arent using C++ the 'correct' way. 
That's not what they said. &gt;Jx9 is **basically** GPL licensed. Which it is - http://opensource.org/licenses/sleepycat for the license itself. If you use it, you have to make the rest of the application open-source as well, just like the GPL. Note this bit in the license: &gt; Redistributions in any form must be accompanied by information on how to obtain complete source code for the DB software **and any accompanying software that uses the DB software**. This means that I find it too restrictive in possible uses and I'm with jbandela and moswald. If this is what a developer *wants* with their project, absolutely all the more power to them, but it's not something I want to deal with. Edit: From JX9's own web page: &gt; The Symisc Public License permits you to use the Jx9 engine at no charge under the condition that if you use the engine in a host application, **the complete source code for your application must be available and freely redistributable** under reasonable conditions.
This is awesome, but I must ask, if it's basically Lua with a more javascript like syntax, why not just use javascript (V8, etc)? Or Metalua? 
Jx9 is far easier to embed than V8 or Mozilla SpiderMonkey. Jx9 is a huge 1.3 MB single C file without dependency while moz SpiderMonkey is 50 C++ files with a lot of dependency.
More likely: the main people in charge of that got their PhDs and left the university.
&gt; try writing a compare function for struct Thing2 { int a, b, c}; #include &lt;tuple&gt; using namespace std; struct Thingy { int a; int b; int c; }; bool operator&lt;(const Thingy&amp; l, const Thingy&amp; r) { return tie(l.a, l.b, l.c) &lt; tie(r.a, r.b, r.c); } Updated note: just like using a calculator is not "cheating" for an engineer, this is not "cheating" for a programmer who already knows how to write comparators. It is efficient in the sense that it will not create additional copies (important if the data members are strings/vectors/etc.) and that most of the invoked machinery will inline away. However, it may not be perfectly efficient if the optimizer cannot see through reference data members, so a handwritten comparator may be faster. Comparators are one of the most likely candidates for micro-optimization in ordinary code.
Is there any summary on licenses that basically follow that guideline? LGPL, MIT, Apache, BSD, ... haven't really come across any others yet.
No, Thrust is different. Thrust provides a series of containers and algorithms that (roughly correspond to those in the standard library) which are parallelized. This library is for concurrent containers (i.e. the containers are accessed and modified concurrently by different threads). For example, if you wanted an algorithm to perform an efficient parallel reduction on a bunch of data, you'd use Thrust, but if you wanted a map that you could update concurrently from a bunch of different threads, you'd use something like this.
At least one of the Microsoft licenses works that way, too.
Boost.Lockfree looks really interesting for concurrent structures. The lockfree queue looks very useful for a general work stealing thread queue. Also, I'm using TBB in a current project and it's great so far.
My C++ Quiz is a series of simple questions related to the C++ language and its use.
Wow, you're serving a tremendous amount of ads - clickety click click.
Some of your questions are ill-formed. For example, in question #13 you're asking one thing, and expect answer to the code snippet.
Those were really poorly worded.
 I want to use it, but I can't due to this. I'm afraid Jx9 is never going to be more than a niche thing until this changes. Even Microsoft's C# has a less restrictive license. 
Perhaps something like the following to better clarify: "In namespace foo, can the function bar access the variable x?"
What would possess somebody to write such a large file and call it a benefit ?
Nobody wrote it like that (unless they are insane). They probably just have scripts that can concatenate all the sources into single c file (iirc sqlite can be compiled like that too). The benefits of having this in single file would be simplified inclusion in your project (probably doesnt really matter in anything big enough to want to embed a language), and some performance gain (probably on par with link time code generation). 
I think we just did, "My C++ Quiz".
Exactly, Jx9 follows the SQLite3 coding style which everybody know is an astonishing piece of work. At the end of build, a tiny script is invoked which concatenate all C source files of Jx9 into a single file (The amalgamation).
Not so restrictive. If your code is open, use Jx9 for any purposes even for commercial stuff. http://en.wikipedia.org/wiki/Sleepycat_License
But what about as the scripting language in my commercial, closed source game engine? Can I use it in that case? Or is this when the commercial license takes over? I played with it a bit and like it a lot. I want it to succeed. I really think you should change it to LGPL or BSD, possibly abandon the commercial license, and try to make the money on tooling instead. It probably won't happen but maybe something to think about. A GPL-like license doesn't make sense for something whos main feature is embedding, due to the nature of how copyright is interpreted. 
http://cplusplus.com is pretty good, especially for reference to specific function uses/params.
Oh please stop saying that "correctness is more important than performance." I've heard that enough but still have performance problem everywhere.
Will think of that. We got more and more requests for a BSD like license and probably this will change in the next public release of Jx9. For now, closed source apps have to acquire a commercial license to use Jx9.
Everyone seems to be assuming you're parsing the midi, outputting music etc. But I think you're actually reading ex: midi message x, mapping to y. Then this stream is used as input in an external program. Check out puredata. However you probably can do it fine in python or c++. Just depends on what library you can find.
To be fair, he could have said something more useful. Perhaps: parsing logic for MIDI would be more readable in language X.
1. what is `c'tor`? (*Trouble googling it.*) 1. How does this differ than `boost::weak_ptr` ? ( Because it references something that **does** manage ownership ; and it allows more than just observing? ) 
Stack overflow is great. http://stackoverflow.com/questions/tagged/c%2b%2b
It's not c++, it's c++/cx. 
It's c++ with Microsoft extensions. Embrace and extend, once more. Vendor lock-in, again. 
It is simply something to help interact with the .net stuff, not used outside of that.
Apple extensions: http://clang.llvm.org/docs/LanguageExtensions.html GCC extensions: http://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html http://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Extensions.html#C_002b_002b-Extensions Embarcadero Extensions: http://docwiki.embarcadero.com/RADStudio/XE3/en/C%2B%2BBuilder_Developer%27s_Guide#Language_Support_for_the_VCL_.28C.2B.2B.29 Intel Extensions: http://software.intel.com/en-us/intel-composer-xe/#pid-5124-864 Oracle Extensions: http://docs.oracle.com/cd/E24457_01/html/E21991/bkaed.html#scrolltoc IBM Extensions: http://pic.dhe.ibm.com/infocenter/comphelp/v121v141/index.jsp?topic=%2Fcom.ibm.xlcpp121.aix.doc%2Flanguage_ref%2Fibm_lang_extensions.html HP Extensions: http://h21007.www2.hp.com/portal/download/files/unprot/aCxx/HTML_Online_Help/options.htm#xlang All the above compiler vendors make use of C++ extensions and they are just a subset of all the ones that do the same, why should Microsoft be the only one to blame?! 
Who said Microsoft is the only one to blame?
Yes, they do. Learning c++ requires creating projects with it. Start with games based on Allegro 5 or SDL libraries. Usually fast moving games require attention to details like performance, so you'll learn data structures.
I assumed you were, because usually I only see people complaining about Microsoft extensions, *"forgeting"* that every compiler vendor does it. Personally I also would rather have C++/CX built on top of standard C++11, instead of having shortcuts with extensions.
Given the fact that the code uses type name based lookup I seriously doubt the “up to 20 times faster” claim. `dynamic_cast` can be implemented without string comparisons, purely via O(1) lookup of a unique numeric identifier (in the easiest case, a vtable pointer). It’s a nice pet project but it gets several details wrong and it’s not a particularly good implementation.
Could you expand on that O(1) bound? If you have the following code: //File 1 class Base {...}; class Derived1 : public Base {...}; class Derived2 : public Derived1 {...}; class Derived3 : public Derived2 {...}; Base *foo() {return new Derived3;} //File 2 class Base {...}; class Derived1 : public Base {...}; class Derived2 : public Derived1 {...}; class Derived4 : public Derived2 {...}; class Derived5 : public Derived4 {...}; Base *foo(); void bar() { Base *b=foo(); Derived1 *d1=dynamic_cast&lt;Derived1 *&gt;(b); Derived2 *d2=dynamic_cast&lt;Derived2 *&gt;(b); Derived4 *d4=dynamic_cast&lt;Derived4 *&gt;(b); Derived5 *d5=dynamic_cast&lt;Derived5 *&gt;(b); } how do you do the lookups in constant time? 
File1::Base and File2::Base have to be the same object, otherwise you couldn't define classes in headers and use them in multiple implementation files. It would be impossible to declare a `std::string` in one file and pass it to a function in another file.
Anyone else reading this and thinking "you're doing it wrong"? This feels like and hand crafted dynamic type system built on top of C++, and it seems like the problem that is being solved here could be better addressed with simple use of double-dispatch.
I see your point; thanks. But they don't **have** to be the same object, right? // file1.cc #include &lt;iostream&gt; class Base { public: double d_x; Base() : d_x(3.14) {}; }; Base foo(); int main() { Base b = foo(); std::cout &lt;&lt; b.d_x &lt;&lt; '\n'; } // file2.cc class Base { public: int d_x; Base() : d_x(42) {}; }; Base foo() { return Base(); } The same name does not automatically mean they are the same object. In your case, I'm not sure as to what goes. Do you know if and (possibly) where this behaviour is formalised? I'm curious now. Edit: found [this](http://stackoverflow.com/questions/10671956/same-class-name-in-different-c-files) which seems to answer it. Sorry for distracting from your original question, which need not have this problem at all. :)
Thank you for the response. I made seferal fixes in the article based on your first two paragraphs, I hope now it is okay. Regarding your third paragraph, I just wanted to introduce a way of replacing dynamic_cast for those who are courious or don't want to rely on built-in RTTI for some reason. And yes, at least in MSVC, this implementation (based on hashes instead of strings) is 20x faster in the release build.
Thank you
You are correct that it's possible, however, it's undefined behavior. Paraphrasing from the C++ standard, section 3.2.5: * There can be more than one definition of a class type in a program provided that each definition appears in a different translation unit and that each definition consist of the same sequence of tokens. So we can (and should) assume that both definitions of `Base` are identical, otherwise we can't say anything about the behavior of the program at all since undefined behavior applies retroactively, and that's not helpful.
Regarding the perfornance: [it's not exactly good](http://tinodidriksen.com/2010/04/14/cpp-dynamic-cast-performance/) And I readily assumed that this is the reason. 
It seems I forgot this was a contest of quick hacks... the scoreboard leader for the first problem used a std::map to keep track of alpha character frequencies and restrained himself to 1 letter variable names. I used a std::array&lt;int, 26&gt;, exploited the ASCII table for indexes, used std::iota and std::inner_product to calculate the string beauty, and all I got was a lousy t-shirt and a 3 digit ranking ;)
This has a huge cost now that every instance of Object requires a map with an entry + memory allocation for each base. Even MFC's implementation uses a static table per type.
&gt; 20x faster Can you provide the benchmark program you used to test this?
My Facebook login is acting up, so I can't view the page. Can you explain how 1-letter variable names would improve his score?
It didn't! The code isn't factored in to the scoring at all. It's presumably just so you can't cheat, and submitting and publishing the code helps other programmers learn and reflect. The scoreboard is fascinating... you can see the code from thousands of programmers working on the same problems independently, which is a rare treat indeed. I just found it surprising that the 5 quickest correct solutions were all C++.
You cannot make garbage-collected code portable to platforms without garbage collection via the preprocessor, nor it is acceptable to replace things like gc pointers with macros, for many reasons that have to do with syntax. 
a follow-up: http://scottmeyers.blogspot.com/2013/01/effective-c11-content-and-status.html
Oh ok, though I did try a search for it but nothing came up on cpp and programming. 
http://pastebin.com/vFr3TZux on my machine, the first one writes "982" and the second one "98". Well, 10 times faster, I'm sorry, I don't know where did i get those "20".
`dynamic_cast` requires objects to have virtual functions. Most implementations solve this by having a virtual function table for each class. You can thus identify each class in a hierarchy by a pointer to its virtual function table. Now it’s absolutely no problem to maintain a map (implemented in terms of a hash table) of those pointers to the required offset for the dynamic cast – because under the hood that’s all that `dynamic_cast` has to do (for single inheritance; multiple inheritance is more complicated). That map has to be built by the linker across all object files to make your particular code work.
I got 250000 1010000 On Linux x64, g++ 4.7. Could be a formatting error for either of us, because if I recall correctly, the %i might not print the unsigned long (which clock_t most likely is) correctly. I changed it to %u though and I got the same thing. Can someone shed light on this difference? My printf skills are rusty.
I’m surprised then that the first few solutions are faster than yours. Have you tried analysing the cause? From the description alone, and skimming the first few (atrocious!) code snippets, it sounds like your code should leave them in the dust …
This may be caused by an unoptimized std::map. Also, as I stated in the article - I provided only "skeleton" of the project, many of things can be programmed in better way. I used the std::map along with std::string because of the simplicity.
I've also gotten the reversed results. g++ 4.7.0 (32 bit, MinGW) on Win7 x64 gives: O0: 630 / 1959 O1: 7 / 194 O2: 0 / 78 O3: 0 / 89 I suspected the compiler maybe was cutting some corners with aggressive optimalisation, so I changed the for loops like so: unsigned long long total = 0; for (int i = 0; i &lt; 100000000; ++i) { d = dynamic_cast&lt;MostDerived*&gt;(o); total += d-&gt;GetClassNameHashStatic(); } New results were: O0: 7106 / 19215 O1: 98 / 2421 O2: 101 / 990 O3: 99 / 1071 Do you have different optimalisation flags with MSVC? It's not that strange we get different results, but a factor 100 difference is quite something.The compiler also warned for not having a virtual destructor.
TL;DR for us unsocial people without a Facebook account?
Is the g++ std::map known to be unoptimized? BTW, I tried with -O2 and -O3, and got 0 40000 In both cases. However, with clang++ 3.2, I get the following: 1. No optimization: 270000 790000 2. -O2 240000 60000 3. -O3 240000 70000
1. Find the best known algorithm to solve the problem. 2. Implement it using the standard library. 3. Win.
I meant there may be several time-consuming checks in std::map find method. But I'm not familiar with g++ and its STL enough to be sure with this. Or maybe it has really optimised dynamic_cast. :)
You're right about the virtual destructor, I removed it somehow when I was shrinking my project for the article purposes. I will fix the article. Thanks for pointing that out. And no, I wasn't set any flags additionaly. I left it as it was.
Measuring time to write the code, not time the code takes to run. The code just needs to run in under 6 minutes to qualify.
Ah. What a stunningly idiotic metric. But I’m speaking as someone who’s completely ignorant about the goals of this competition.
Seems to be yeah. Google have a similar competition starting in 40 days called [Codejam](https://code.google.com/codejam/) if you missed the FBHC.
Anyone knows why some submission have a red X instead of a checkmark. One of my submission has one and I don't understand why.
Note that NuGet [is working on](http://nuget.codeplex.com/discussions/280649) integrating with C++ projects soon. They [claim NuGet 2.3](http://nuget.codeplex.com/workitem/868), which is slated for release in March. I haven't tried it yet, but there's a [prototype here](http://nuget.codeplex.com/discussions/412012).
And pollute the objects with one/several visit methods. The visitor pattern is an ugly workaround for missing double dispatch in C++.
Why is it pollution, and how is it ugly?
maybe they should have waited another 2 months with the announcement... :-)
Looks like a nice way to kill few hundred (thousand?) hours of your life. I am sure there is nothing better to do in the 21st century then to implement crazy C++ standard from scratch. If you have a compiler itch why not go and help with some actual open source compiler. Commits to gcc will definately look better on a resume then some ceriticate.
seriously, fuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuck that
Practical or not, this looks like a lot of fun.
It was posted to the [ISO C++ Standard Discussion](https://groups.google.com/a/isocpp.org/forum/?fromgroups#!forum/std-discussion) mailing list
Hmm Herb Sutter's concurrent&lt;T&gt; [video, [beginning at 0:52:10](http://channel9.msdn.com/Shows/Going+Deep/C-and-Beyond-2012-Herb-Sutter-Concurrency-and-Parallelism)] should be perfect for something like this, shouldn't it?
I also use codepad.org for quick stuff. Usually to test weird stl behavior or demonstrate something to somebody else.
This is fucking insane... I love it! =D
Given that there is yet a full ANSI C++ to be made available, this can only be a joke.
Isn't that just because C++03 had export and C++11 is new?
I already signed up. SWEET.
It's not about making something useful, it's about honing your skills.
I'd love to do this but far from able currently (for many varied reasons). I interpret the milestones as being a deadline, but seems they will definitely continue to run it (implied in FAQ, at least).
yeah jeesh this is intense, even llvm and gcc aren't C++11 compliant yet!
C++11 is a year and a half old, and entire teams of people have been working on compilers for it since before it was even finalized, and there still isn't a fully compliant compiler. It's clearly either a joke or a delusion.
Who exactly is the "CPPGM Foundation"? What are their credentials? Before deciding to dedicate such a huge amount of time to such a thing, I would think students would want to be sure the instructors are qualified to teach the material. Particularly if you are supposed to keep the code you write to yourself - otherwise, how would anyone be able to evaluate the value of their "certification"?
Fuck it, I've been inventing my own logging since 2001.
Thank god we have this online course, there will be plenty of usable compilers after people finish it.
C++11 is wonderful. The horrible suffering necessary to implement its syntax and features, not so much. I shudder at the thoughts of trying to make a C++11 compliant compiler.
I see what you did there. 
 A few things to note: 1)The ISO C++ standard came out in 1998 (C++98) and the first fully conformant compiler came out in 2002. 2) Take a look at the Standards Involvement link on the left - clearly these are people who wrote a large part of the standard especially tricky stuff like overload resolution) 3) This is a front-end only 4) This does not include the standard library
Very cool. If only it did not invalidate active iterators upon insertion or deletion!! But given the algorithm, I guess there is no alternative. Is there? Does anyone of the fine minds out there have a solution?
Your horrible suffering is my daily dose of fun.
No. Many people on forums tend to think only about gcc, clang and msvc, but there are many more compiler vendors out there. All the commercial UNIX systems, embedded platforms, game consoles, and even other vendors targeting Windows. Not all have the same language support. You really discover the joy of writing portable C and C++ code, when you need to target multiple OS and compilers outside the typical BSD/Linux/MacOS X/Windows world.
First respectful no-nonsense language certification!
It means your program didn't solve the problem correctly. Your program is probably failing in some edge cases.
Would you care to post your solutions? I'd be interested in seeing them :)
Is that not because no one has (moral) authority changes Knuths code!
From [google-opensource.blogspot.com](http://google-opensource.blogspot.com/2013/01/c-containers-that-save-memory-and-time.html): &gt; These templates are nearly drop-in compatible with the STL map, set, multimap, and multiset types, with one significant exception. Unlike the standard container types, insertions and deletions invalidate outstanding iterators (we provide “safe” [alternatives](https://code.google.com/p/cpp-btree/wiki/UsageInstructions#Safe_B-Tree_maps_and_sets) to handle this case). 
Finally. They were stuck in 2010 for some years now...
Exactly, this "certification" doesn't seem credible at all. What's more, whoever takes on the "C++ Grandmaster" title should take a bite of humility imo. That title is just ridiculous.
he is talking about this thread. http://www.reddit.com/r/cpp/comments/17n92d/c_grandmaster_certification/
I prefer liveworkspace, it uses a newer version of gcc, and therefore I can actually test C++11 code, which is what I normally use online compilers for nowadays.
I have yet to see a fully conformant compiler for C++98 even to this day.
I'm used to using vectors where erasing and insertion also invalidates iterators, so I think I'd be cool with it.
You are asking if you can use vector without including it? ... wat?
This is a very strangely worded question. Are you trying to _recreate_ the vector class? Yes, that's very possible. He probably just wants you to make a class with an array, then member functions that allow you to add(push), remove (pop), and access the data randomly. Then he probably wants you dynamically resize the array when you try to push in more things than the array can hold. You don't need include &lt;vector&gt; to do this.
I suspect your English instructor may have been inept also. Your question makes almost no sense.
I can't tell what you're asking. Is he asking for you to reimplement std::vector using a stack? It's definitely been done before, but I'd question just how much of the [std::vector interface](http://en.cppreference.com/w/cpp/container/vector) you really need -- I'd say you really only need operator[] and push_back with the ability to resize dynamically. 
&gt; Can you make a vector without a the #include &lt;vector&gt; directive? I think I understand what you need. You're instructor isn't inept, you can make a vector w/o #include &lt;vector&gt;, you make your own vector! If he/she want's it modeled on a stack you already made, then clearly he/she want's you to implement your own vector object, not just use the standard one. Just asking this question, it sounds to me like you're the one unfamiliar w/ C++.
Have you learned anything here? It totally looks like a sham to me. And as the other commenter here noted, the "title" is so ridiculous that I wouldn't want it anywhere near my resume.
I haven't heard anything yet. I considered emailing them and suggesting they add it to the FAQ at least, but I haven't done so. I'm not sure if they know about this thread.
Why post a new link only to comment on an other? The original post has a "reply" option, you know.
FYIW, my work firewall blocks it as 'fraud/scam'. Not sure I trust the firewall, but I found that amusing.
The biggest thing nobody supports is the export keyword, which EDG implemented for the sole purpose of being the only one who did. It was apparently a huge undertaking for little benefit.
I'm only seeing a timeline, not any information about how hard it actually is. Don't get me wrong, everything I know suggests it would be terrifying. But starting and releasing a c++ frontend in the same year doesn't inspire fear.
No offence, but this is like saying I can never teach you to create a fully functional game engine in a 2 month course, because AAA game companies take YEARS and THOUSANDS of man hours to do it... If the course said they would be creating a FULLY FUNCTIONAL compiler that is able to compete with the other compilers out there, I'd call it bogus. But trying to teach something by trying to create your own while keeping your ambition realistic, I see no problem with that
The problem (or at least verbose annoyance) is when you have a, b, c, and d fields. Is there a cute template/macro solution out there to simplify lexicographical comparison in that case? Maybe some cute trick involving c++11 bitsets and reinterpret_cast is possible.
Interestingly Qt ditched Skip Lists for QMap in Qt 5.x and went back to a red-black tree.
Except they do. &gt; Compliant with the latest 2011 standard (C++11)
They ams says it ams not optimizes anything, it ams not like it wills performs significant analysis of code or code paths, just ams makes them works. Compliant with a standards doesn't mean really good, or vice versas.
Compliant with ams standard, in ams case, already means enough to ams "not doable alone in an amstime".
A lot of people say that C++ is too verbose and that you can't develop things quickly. I think the major flaw in this argument is two-fold. The verbosity itself can be resolved with typedefs and snippets (snipMate with vim for example.) with C++11's auto the verbosity is cut to a minimum once the structures are set. The second point is really an opinion, but languages that aren't as verbose are able to be "prettier and shorter" because they sacrifice the scope of programs you can develop with them. Python is beautiful, and the list comprehension syntax is really powerful, but you run into issues when you reach the language's limits (global interpreter lock is such a painful concern for example.)
I wish the Visual Studio team would get its shit together, because the initialization syntax looks nifty and I want to try it. EDIT: I take that back, I can't believe I missed the November update. Progress!
&gt; Perhaps the standard committee wanted a means of creating a method that would be useful when using type identifier as keys in containers such as map. type_info::hash_code() exists so you can put a type_index in an unordered_map. type_info::before() exists so you can put a type_index in a map. &gt; It requires RTTI to be enabled RTTI is a mandatory part of Standard C++. When you ask a compiler to disable RTTI, you are explicitly putting it in a non-Standard mode, meaning that you are bad and you should feel bad. &gt; It is not guaranteed to be unique, so type_info has to be checked to prevent collisions. unordered_map has to check for collisions anyways. &gt; The following code will generate a unique id per type I haven't deeply analyzed this code, but it appears to be vulnerable to the Static Initialization Order Fiasco. RTTI was put into the language in order to avoid users constantly implementing it themselves badly.
I created the subreddit to collect and highlight issues specifically related to c++11. Not whoring at all. Too little karma to worry about that. :) 
Code::Blocks is another IDE that comes packaged with a newer version of MinGW than Dev-C++ does. If you really want to, you can use whichever editor you want and drive the MinGW compiler via command-line; it's basically GCC ported over to Windows.
&gt; Visual C++ 2012 Express, didn't like them at all. Visual C++ comes with a GUI whose main goal is to make your life miserable. However, you can ignore the IDE completely, and use the command-line compiler. The other two compilers are Clang and g++. [You can find Windows binaries here.](http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/rubenvb/)
I SEE EVERYTHING (except stereograms).
&gt; It still seems to be lacking when used in an ordered map. There is an extra comparison in there that shouldn't be necessary. map&lt;type_index, V&gt; invokes type_index::operator&lt;() invokes type_info::before() which returns true or false depending on "the implementation's collation order" which is unspecified. Where is the "extra comparison"? &gt; Regarding disabling RTTI, I never really considered that to be a non-standard mode It is non-Standard *by definition*. &gt; The value of the identity is not required to be portable across executions, the same guarantee as hash_code()... You complained, "3.) It is not guaranteed to be compatible across compilers."
Unless 2012 Express is very different from 2010 Professional, I find it difficult to believe that it's really that bad (as opposed to unfamiliar).
&gt;map&lt;type_index, V&gt; invokes type_index::operator&lt;() invokes type_info::before() which returns true or false depending on "the implementation's collation order" which is unspecified. Where is the "extra comparison"? Ah, you're right. It's still not guaranteed to be unique, though. Mine is. &gt;You complained, "3.) It is not guaranteed to be compatible across compilers." Both implementations are not guaranteed to return the same results across executions, but my implementation will work across compiler versions. 
Visual Studio's interface is very much a hit-or-miss: some love it, some loathe it.
&gt; Ah, you're right. It's still not guaranteed to be unique, though. Mine is. I think you are confusing before() which is for map, with hash_code() which is for unordered_map. before() compares two type_info objects for "less than", returning true or false according to some ordering. When x and y represent the same type, x.before(y) will always be false. (This is just like for ints - when x == y is true, then x &lt; y is always false.) This is what std::map consumes (through op&lt;). hash_code() returns a size_t for a single type_info object. The Standard suggests collision avoidance, but does not require uniqueness. When x and y represent different types, it is possible for x.hash_code() == y.hash_code(). But that's okay! unordered_map is specified to tolerate hash collisions (it doesn't like them in terms of performance, but it doesn't affect correctness). This is because it will compare objects for equality, which type_info (and type_index) also support. In practice, what VC does is apply its string hash algorithm to the type_info's name. In VC11, this is very collision-resistant (we just throw FNV-1a at it, which is good unless an attacker is trying to provoke collisions). In earlier versions we used a worse algorithm which actually could create collisions for certain strings/type names (as I recall, Derived1 and Derived2 would collide; I can tell you the whole story if you want). &gt; but my implementation will work across compiler versions. So will Standard RTTI, I don't see how that's any different.
install visual studio and use the command prompt compiler
This makes sense. I might have been assuming that before(.) was relying on hash_code(.) to make it's determination. Thanks for the detailed reply! This makes me very happy -- I felt dirty creating that code. Happy to know I don't have to!
Yeah, it would be nonconformant for an implementation to implement before() by comparing hash_code() with op&lt;. Even with 64-bit size_t and a crypto hash, the chance of a collision is nonzero - if x and y represent different types, either x.before(y) or y.before(x) must be true, they cannot "collide". (Historical note: C++98/03 had before(), while hash_code() was added in C++11 to support unordered_map.)
[That what I said, yes.](http://www.reddit.com/r/cpp/comments/17u0ns/windows_and_compilers/c88tzk6) Is VC++2012 as advanced as g++ 4.7 though?
not really sure but you can do most of the interesting C++11 stuff with VC++2012. note that g++ on debian stable is still stuck below 4.5 so no lambdas. I use a debian wheezy on a VM to do all my programming. It's a very usable option.
&gt; I use a debian wheezy on a VM to do all my programming. I just downloaded the source code and compiled g++ 4.7 myself. There are a couple gotchas, but it works quite well.
To be fair, there's nothing intrinsic that should make C++ harder on Windows or easier on Linux. (Other than that Linux distros can ship with GCC, I suppose.) It's more a reflection on the state of library distribution than anything else. I agree, it's frustrating when libraries don't ship proper builds for Windows!
This is awesome and very helpful, thanks!
&gt; MinGW You'll have to be more precise than that. MinGW is only the shell; both Clang 3.2 and g++ 4.7 (as well as 4.8) are available for it.
you need scott meyers of bjarne for this kind of shit
I use code::blocks, VS 2010 Ultimate and VS 2012 Ultimate as a student. I like code::blocks because it feels more lightweight than VS. VS, however has a lot of nice little bells and whistles that I like. But of course I'm talking about the IDEs, I don't use command line compiling unless I'm using Linux. 
Oh holy cow, STL. That cracked me up. :D
I really appreciate all of your help, I managed to install Borlands Turbo C++ on windows 7. It feels great to go back to my roots, all does days spent programming in highschool. Let's hope it'll work on Win 8 as well!
You do realise that Turbo C++ is totally outdated and hasn’t got a lot to do with modern C++? Going back to the roots is fine and all that but I advise against ignoring decades of progress in programming language development; even the most recent version of Turbo C++ is from 2006 and lacks critical new developments of the C++ language.
The thing is that right now I just want to get back playing with it since I'm kind of rusty in C. When things get better I'll probably move to a more "adequate" version of C. 
Out of interest, is there any reason you have to use Windows, for playing around with (as well as serious dev') I find linux far more user friendly. Which ever OS, I would recommend you use a separate text editor and compiler, ideally one that works across platforms (like vim + gcc).
CodeBlocks. User friendly, dead easy to install, and it just works. EDIT: Oh, you were asking for a compiler. MinGW, which is included with CodeBlocks!
When the return type is not fully known and depends on other things. I think the slides did a nice step-by-step of this, so long as you try to figure out what each slide is changing and why. I will try to explain. template&lt;class T, class U&gt; ??? add(T x, U y){ return x+y; } We don't know what the return type will be, here. template&lt;class T, class U&gt; decltype(x+y) add(T x, U y) x and y are not known yet, they come a few characters later in the parse. (Note here: If only that "decltype(x+y)" could come after x and y are defined!!) template&lt;class T, class U&gt; decltype(*(T*)(0)+*(U*)(0)) add(T x, U y) Make null pointers of types T and U, then dereference them, and get the type of the addition's result. This works...we finally get the type we need to return. But look how ugly it is. template&lt;class T, class U&gt; auto add(T x, U y) -&gt; decltype(x+y) There we go. Now x and y are known, so the type of their addition's result can be found.
Oh sorry, I may have misread your question. The old: Link* LinkedList::erase(Link* p) will not compile. The original code was: LinkedList::Link* LinkedList::erase(Link* p) The key here is that the Link struct is inside the LinkedList namespace. Once we know we're in that namespace we can reference things inside it without having to name it. For example, the Link* parameter happens after the function is declared to be inside the LinkedList namespace. But the return value being on the left happens before we are inside the function declaration (as far as parsing is concerned). Having to type that namespace every time is a bit annoying, right? So if you put the return type to the right (later in the parse) then we know what namespace we are in. That means we can return the type Link* without having to type LinkedList::Link*. It can benefit from the same thing the parameter benefited from.
You where right, now I'm using Notepad++ and MinGW. Oh well, it seems like it works.
&gt; I'm kind of rusty in C O…kay. First order of business: are you talking about C or C++? Those two are *fundamentally different*, nowadays more so than ever before. You should not try to treat them as similar, this will lead you to either learn invalid C or bad C++.
Ooo the initialization syntax is very useful. I can't wait to simplify some of my projects that have to loop over lists for initialization of some STL objects.
I know how to program in both languages, C and C++ . Anyway I ment C++.
The GPU results don't include memory transfer times, so frankly I don't think this is an accurate benchmark for the GPU. There should at least be some statement on the memory transfer times, because those are often a significant portion of a GPU algorithm's runtime. I'd also like to see an implementation of bitonic sort compared against these, since (to my knowledge) mergesort is very rarely used outside of a classroom.
Merge sort appears to be pretty popular for parallel sorting because it's easy to write and scales well. It would have been nice to see a comparison of a normal parallel merge and his one using std functions though.
i dont know anything about cuda or thrust, never had the pleasure to work with it since time is scarce but seeing the relevant piece of code from the GPU benchmark: V.resize(i); rnd_fill(V, 0.0, 1.0, seed); d_V = V; cudaEvent_t start, stop; cudaEventCreate(&amp;start); cudaEventCreate(&amp;stop); //Start recording cudaEventRecord(start,0); thrust::stable_sort(d_V.begin(), d_V.end()); now i have a question: d_V = V; is where it copies from an std::vector into a thrust::vector, does the = operator from the thurst::vector copies the data immediately into the GPU or does it wait until an operation (like thrust::stable_sort) is called to copy it? if its the second then the benchmark is fine, but if its the first option, then changing the d_V = V; line into after cudaEventRecord() could solve it unless i'm mistaken of how cuda and thurst work. anyway good stuff, i wish i had more time to play with this.
For data-parallel CPU code you really don't want to be spawning raw threads, ideally you want to be using task-based parallelism with a work-stealing scheduler. You can try using std::async but there is no guarantee that a particular implementation will use thread-pools or tasks with work stealing queues. Apparently MS Concert does in VC++2012. I'd suggest doing this test again using Intel TBB or Microsoft Concurrency run-time or if you're feeling up for it roll your own task system with std::thread. 
The author seems to think that I32LP64 is the only 64-bit data model...
Oh I see, that makes sense if Link is a nested struct. 
waaaaaaaaaaaat coroutine library is sick
No hash_map / hash_set? I still haven't yet found anything that beats RDESTL http://msinilo.pl/blog/?p=675
PVS-Studio has been working with Visual C++ for a quite some time and VC uses LLP64/IL32P64 model. According to PVS-Studio's home page, it supports both LP64 and LLP64 models, which covers most of the cases in use today.
Nice to see string_ref implemented already. Hopefully everything that can be will be switched over to using it relatively promptly.
This seems to break all the inheritance advice I've ever read. Things like "use public inheritance for a is-a relationship", "prefer composition to limit code coupling" and "don't use inheritance purely for code reuse". It may be that these things were considered by the author and ignored for good reasons, but as a reader I'd quite like to know those reasons so I can make the consideration myself in the future. It's a nice read though and I like the concept, even though I'd be *very* hesitant to use it.
The state of library and software distribution on Windows is Microsoft's fault. I run Gentoo at home and the library distribution is better because the folks that run my distro **made** it better.
The point is that neither A nor B really "is-a" printable. They both just happen to be "can-print" but otherwise have nothing in common. The print interface is ancilary to their purpose and you never want them interpreted as sharing a base class. Of course the example is contrived and silly because you'd just define stream operators for the types. Quick, somebody come up with a better example.
Multiprecision library will be great as the "Bignum" library of c++!
Yea, I think the large number library looks great as a standard &amp; modern C++ implementation of big and arbitrary precision numeric types. 
try lisp :3
OpenMP is severely restricted. It's basically only useful if you're looking for a quick and dirty way of taking a particular kind of sequential algorithm and making it run a bit faster through parallelizing it. Anything outside of its basic model and you're in for a world of pain and not particularly good performance. The reason OpenMP is so popular is that the particular kinds of sequential algorithms where it doesn't suck are precisely those commonly used in computational physics.
Why the Phoronix-blogspam? Anyway, there's a stark lack of detail as to what precise features are provided by this static analysis tool. Namely: What does it detect that `clang -analyze` doesn't?
&gt; prefer composition to limit code coupling Composition is a form of coupling. By using composition, the degree of coupling is not lower versus using inheritance. 
Try Haskell. Much better than c++.
Most people seem to disagree with you, e.g. [this](http://stackoverflow.com/questions/49002/prefer-composition-over-inheritance). There's more if you look. Why would you say inheritance isn't a stronger coupling?
Ah, Java in /r/cpp. You obviously like living on the edge. ;) I can see from your example you can achieve the same result with both methods. That's nice (and my point too) but not a measure of code coupling. When we want to change code, that's when we see how tightly coupled things are. Imagine you add a new public method to Base. If you inherit, then you automatically also have that method in Derived. Unless the classes are Liskov-related, this isn't what you want. Or imagine you want to add to the functionalty of foo() in the Derived class. You can't easily do this if you inherit (as overloading public inherited methods is a very good way to confuse the hell out of people), whereas with composition it's easy to do and obvious to any reader. These are just two examples of why the inheritance method is more tightly coupled. So the question remains: you showed you can achieve the same thing with both methods, but why do you think inheritance isn't stronger coupling?
Your example code doesn't give the same results. In the first case, if you derive from Base, you've two public methods in Derived, foo() and bar(). In the second case, you have only one, foo(). If you read the above reply, that's my point exactly. &gt; In both cases, the contract of the class Derived is not maintained. I don't understand what you mean by this. &gt; Nope. Inheritance is controlled with constructs offered by the language: 'virtual' in c++/c#, 'final' in Java. So you would change the base class to include virtual functions just because you want to use its functionalty in an unrelated class? Now that's a beautiful example of tight coupling. Of course, if the base class already had virtual functions, it was written with the purpose of being a base class and every derived class is *an instance of* the base class. That's fine and proper use of inhertance, but also obviously an example of extremely tight coupling.
&gt; In the second case, you have only one, foo(). If you read the above reply, that's my point exactly. &gt; I don't understand what you mean by this. In both cases, the method that breaks the invariant is called. The Liskov substitution principle is not maintained in the case of composition as well. &gt; So you would change the base class to include virtual functions just because you want to use its functionalty in an unrelated class? Now that's a beautiful example of tight coupling. I think there is a misunderstanding here. Did you simply want to use Base::foo() in Derived? then no change should be made. Did you want to extend Base::foo()? then it should be made virtual. In either case, I did not propose any more changes that you did. 
Wow thanks, I would have missed that gem if it weren't for your comment. Boost must find a way how to ... educate developers on "what can you find in the library". Yes this is written in the "what's new" of the version but there are ~52 versions releases to read.
Sorry, but I'm fed up with pointing out the obvious. You can believe there's no difference in the strength of the coupling. Just know: [Herb Sutter &amp; Andrei Alexandrescu](http://www.artima.com/cppsource/codestandards3.html) disagree with you. [Barbara Liskov](http://dl.acm.org/citation.cfm?id=62141) (MIT Professor, C++ Standards Committee) doesn't agree with you. [Scott Meyers](http://www.amazon.com/Effective-Specific-Improve-Programs-Designs/dp/0321334876) (Effective C++) doesn't agree with you. And for Java, [Erich Gamma](http://www.amazon.com/exec/obidos/ASIN/0201633612/billvennersA/) (Eclipse, JUnit) doesn't agree with you. And most importantly, I disagree with you.
Who cares if all these people disagree with me, including you? you can't beat logic. And logic says that derived.base_method(); is the same as derived.base.base_method(); 
Well, I didn't give any advice, I wanted to show some C++ possibilities and template patterns. As usual, it's up to the designer/programmer choosing the correct design depending on the case (private inheritance, composition vs. inheritance,etc...). 
If they all derive from IUnknown, the classes are not unrelated, right? Isn't the case you're describing a textbook example for using a (pure) virtual base class? Any common methods these derived classes have, can be implemented in the base and any remaining methods can be made pure virtual. To be clear, I really am curious why you chose this pattern. I've never worked on a large project and only know these principles from reading about them and playing with them, so I wouldn't dare claim I know things better, but from your article I don't understand why (or: in which cases) you would go this way compared to more conventional options.
First: proof by example is fraud Second: Derived classes have access to protected members of base. -&gt; case solved.
Derived classes could also have access to protected members of encapsulated component if they have been declared as friends. 
Yes, but if there is no friend-relationship, derivation introduces the higher coupling. That aside technically derivation and composition (of a single object) are the same, former can be seen as just an unnamed member. Semantically however it's a totally different story.. LSP, just to begin with...
If you go beyond the boundaries of any integer type in any language you're going to have a bad time.
As I said to another commenter, these two are the same: derived.base.base_method(); derived.base_method(); There is no difference when it comes to LSP. 
What do you mean 'so what'? calling a base class symbol is available both in inheritance and composition, which proves that composition provides the same coupling inheritance does.
Yes it's the same in your example. But that does not proof that coupling in general is the same. Wikipedia seems to have answers for everything: http://en.wikipedia.org/wiki/Proof_by_example
No shit.
I don't understand; does that change anything? Even a public member object would not introduce any internals directly into the holders namespace. Therefor anyone wanting to do use the member object would have to go through the member object itself, thus respecting it as a stand-alone thing. Adding a new method to the member object would not conflict with anything in the derived class and other way 'round, for example. I agree a public member object is a pretty strong coupling, but still it's easier to maintain and less tightly coupled than inheritance. Right?
The reason for the confusion is that he didn't go beyond the boundary of the type, at least not obviously. 
I've used TBB a bit, and it's definitely worth looking into. Some of the parallel containers are a bit restricted. For instance, parallel_vector: there's no way to remove an item, once added, without creating an entirely new instance without the element and swapping. But, the algorithms, such as parallel_for_each, parallel_reduce and parellel_sort are very handy. Nice thing is, too, it's a library, so there's no pragmas like with OpenMP. If you've access to C++11 lambdas, the algos are even easier to use.
Related: Boost Pre-Built Binaries for Visual Studio: http://boost.teeks99.com/
&gt; Try casting *Derived to *Base in the second case. Casting in both cases: Base *b = &amp;derived-&gt;base; Base *b = derived; So, casting works in both cases. 
Well think about it from this way: You're the creator of a widely-used class and have two alternative designs, public inheritance and public member object. No matter what alternative you present to your users, they will use any of those, be it directly or indirectly over the public object in order to get their job done. So in this sense they are equivalent with respect to the actual outcome. But this is as you already acknowledged only half of the story. Scott Meyers likes to distinguish between what is "legal" and what is "moral" in C++. Going trough a public object is legal but not moral. My argumentation above is only in "legal" terms, meaning coupling is defined as "to what degree would my clients be affected if I made a change to my class". For real code this is naturally an insufficient consideration - moral aspects like what do I represent with my design (LSP) are probably more important. But for this fun discussion about what has the higher coupling we should concentrate on the "legal" aspects - else it will be very hard (impossible?) to make a logical argument about whether two designs are equal from a coupling perspective. From a "legal" perspective it's easy: (pub/prot/priv) inheritence = (pub/prot/priv) unnamed member (except inheritance class has access to prot. base parts). BTW: we're rediscussing *exactly* one of Effective C++'s items here. Maybe we have too much time... hehe
So, where do you see using string_ref in boost (as opposed to using string_ref with boost)?
shouldn't this generate an error ?
Please explain why this question deserves a `no shit' answer. The number is a valid 32 bit integer that doesn't incur overflow (usually). I don't think this is worthy of a `no shit', since the answers on stackoverflow are quite wordy.
C++ is mostly an extension of C, however C++ adds so many things that using C++ the "way it's supposed to be" means writing completely different code compared to writing idiomatic C. Of course one could write books about this subject... 
How would `const` have helped in this situation?
No. Overflow/underflow is undefined for signed and valid in unsigned types (iirc).
You can say C++ and C has a common origin (lets say "old C"). But it was 30 years ago. Now, C++ has evolved and C too. In many cases they are similar but the idioms (typical o recommended way to do things) are quite different. 
Recompile in C++11. Should help. Edit: ok, for less cryptic answer: The left hand side doesnt fit in 32bit signed int (the literal itself is unsigned). C++11 introduced 'long long int' type which (most of the times, on interesting platforms, etc ...) is 64bit. Decimal integer literals in C++11 without any sufix attempt to fit 'int', 'long int' and 'long long int' in turn. C++98 lacking 'long long int', is stuck with 'long int' which overflows. C++11 gets up to 'long long int' and the expression is nothing special - 0 gets promoted to lli and everything is well. This simplistic reasoning skips extended integer types (which may apply).
It would be nice to at least get a warning on it.
I don't think you understand the problem here. The top voted answer in the link explains it well: &gt; -2147483648 is not a "number". C++ language does not support negative literal values. &gt; -2147483648 is actually an expression: a positive literal value 2147483648 with unary - operator in front of it. It doesn't matter if the expression -2147483648 is used in an if condition, or if it's used in a variable initialization, it's not going to do what you expect. Avoiding the use of a magic numbers or making a const variable do not help here. 
Please note that there are no negative literals in C++ '-' is unary minus operator.
It giving the right answer has nothing to do with const. See http://ideone.com/OkYIht Extrapolating from the top answer on SO, ideone says it's running gcc 4.7.2 which has support for long long int, so it is probably casting up to 64 bits before negating. If you tried this with the minimum negative 64 bit number, it would likely give the wrong answer. The use of a magic number doesn't really have anything to do with it; it could just as well have been a macro or const value. Although INT_MIN and numeric_limits already exist, so one of those should have been used to begin with.
I tried this in visual studio a few minutes ago and I indeed did get a warning. I don't know if gcc, clang or other would warn about it though. 
His closing argument regarding getting warnings in C, but an error in C++, is more an argument against not treating warnings as errors than an argument of the superiority of C++ over C.
So there was C. And then [someone](http://en.wikipedia.org/wiki/Bjarne_Stroustrup) added Object Orientation to it and came up with C with classes. And then [others](http://isocpp.org) added exceptions, namespaces, operator overloads, new types (eg bool), standardized containers, a new IO system, templates (a whole progamming language in itself) and other features. All while staying broadly C compatible. This was C++. C++'s large set of features can be a burden - it is hard to master. Good C++ programming is not just C programing using extra features, but requires a different approach to structuring a program. For the cost of the extra language complexity, however, C++ becomes very expressive for implementing higher level structure. This is very handy for writing large or complex systems.
Thanks :)
Stephan mentioned briefly that shared libraries (DLLs), modules and concepts are not part of the standard yet. I'm not able to imagine how shared libraries (C++ not C) could be possible to be standardized. For me there are so many problems to be solved: exceptions, dynamic_cast, virtual functions, inheritance, ... across library boundaries (ABI) assuming each library is produced by different compiler/toolchain. Is it even possible to have standardized C++ shared libraries? Edit: also operating system's stuff comes into play.
I think function objects would work much better at doing algorithmic composition, rather than using inheritance. I think its simpler, and there are more things available in C++ to deal with function objects(like `std::bind` or `std::function`). Composition doesn't have to be completely immutable like in functional languages, we can use mutable references to avoid copying. So instead you could compose an algorithm like this: template&lt;class F1, class F2&gt; struct algorithm { F1 phase1; F2 phase2; template&lt;class T&gt; void operator()(T&amp; data) const { fillData(data); phase1(data); phase2(data); } }; And define them as functions like this: algorithm&lt;phase1_A, phase2_A&gt; comb1 = {}; algorithm&lt;phase1_B, phase2_A&gt; comb2 = {}; algorithm&lt;phase1_A, phase2_B&gt; comb3 = {}; algorithm&lt;phase1_B, phase2_B&gt; comb4 = {}; Called like this: comb1(x.data); Or something like that. Ultimately, this will integrate better into C++. For example, say for instance the data was in a vector, we could apply the algorithm to each element, like this: std::for_each(begin(vec), end(vec), std::bind(comb1, _1)); And many more things.
I have to say when possible I use the Qt network module when tossing together little network apps and using c++ for the clean api and when portability is concerned.
It should in retrospect but C and C-derived languages have always been incredibly loose with `int` typing.
In theory you could; COM is basically just a specification of enough of the C++ ABI to make it possible to define C++ classes in other languages. In practice it's probably a few decades too late to have a unified cross platform ABI, of course. Adding shared libraries to the standard doesn't have to mean specifying every little detail about them, though. It could be more along the lines of the C++11 memory model, where it merely gives a baseline set of guarantees.
This is a bug in VC. I've filed DevDiv#609856 "We need to follow C++11's rules for integer literals" in our internal database to track this.
[Boost.Asio](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html) appears to be extremely good, but I haven't had a chance to use it yet.
There are two (almost three) issues here: 1. Specifying dynamic libraries portably, where both sides are built with the same toolchain. The Standard has already solved this case for static libraries (it speaks only of "translation units", not of object files and static libraries and linkers and archivers, but the inputs are identical, the tools behave similarly, and the results are identical). This is probably achievable, although I do not know whether it will happen. 2. Getting dynamic libraries to work across toolchains, ignoring libraries. This would require specifying a C++ ABI and getting toolchains to follow it. My vague understanding is that this was done for Itanium and that GCC follows that specification, but VC does not. 3. Getting Standard Library implementations to be link-compatible. This will never happen, ever. It is literally unimaginable for VC, libstdc++, and libc++ to all have the same representations for stuff as long as they have different code. Indeed, VC's Standard Library breaks binary compatibility between major versions, which is a right that I jealously guard (it lets us do good and useful things).
* no additional dependencies (no boost please) * If possible no code generators (although this makes sense sometimes, google protocol buffers are quite ok) * handling of denial of service attacks
What do you mean by 'network toolkit'? Web framework? I'd start by looking at what they're doing in Rails. Vibe for D and the Rust standard libraries are some other neat new efforts. C++ does have Poco, which already handles most of what you'd need for a simple web app. However, if you need it to be really fast and scalable, you want your socket stuff in an epoll/iocp wrapper. For that I think your best bet is to start with libuv. You may need more features for other stuff, too. HTTP? libcurl does that. Need SSL? Cyassl or yassl get the job done. Encryption? TaoCrypt works. Need to talk to MySQL? Poco has some tools, but they aren't perfect. You'll still have to glue all that stuff together.
&gt; no additional dependencies (no boost please) Why?
For me the answer is obvious. What do you think?
But there are many types that are not intended to be copied around: see also Herbs definition of 'polymorphic' types versus 'value' types, and these polymorphic types are usually passed around using (smart) pointers. These are also typically more complex classes and thus for these classes there is no new requirement that const = thread safe, Your making it sound more dramatic than it is ?
C++ programmers write code in C++. Lisp programmers write blog posts. [I've chosen Lisp, but you can put a lot of different languages instead.]
I'll be glad if you supply some other interesting and truthful sources.
What do you mean by "network toolkit"? Sockets? HTTP client? HTTP server? HTTPS client? At least make it modular: if I just want a raw socket, I don't want to use a library that's huge because of SSL support.
Perhaps you were right on target.
My wish list is to abstact the network to such a degree that it is not visible at all in my programs. 
Because I love being able to compile my program without having to spend a few hours in dependency hell. If your networking software depends on Google Protocol Buffers + enet + TinyRapidXMLJSONParser V0.124 and a number of other stuff then you add to the build complexity and limit yourself to the platforms supported by all your dependencies. 
I'm just as uncertain of what you mean by network toolkit but assuming you are referring to socket layer abstraction and you want to make games, I suggest looking into [RakNet](http://www.jenkinssoftware.com/). It's tried and true for several platforms.
Every day, son... Every day...
I hear you about dependency hell. However, Boost is a solid thing to take a dependency on - it's well-maintained and portable. It can be treated as a leaf dependency (it has optional bits that are dependent on zlib, bzip2, ICU, and Python to my knowledge), and (best of all) major portions of it can be used header-only. Asio itself is header-only, but it may use parts of Boost with separately compiled components - I haven't checked. Taking on a dependency is a cost, but some things are worth that cost.
There are just as many C++ coders now as there were 15 years ago.
I have used Boost.ASIO a fair bit, it is an excellent network library, but it is also undersold; it makes an very good general purpose Async/Proactor backbone too! I have used it for GUI event systems and all sorts before now.
C++ is still the powerhouse it ever was. My job involves writing C++ code every single day. Why wouldnt they?
Sorry you're getting down voted, apparently people don't try to fully understand he languages they use. ಠ_ಠ
I'd like to have some kind of NAT punch through built in, because that's something I really don't want to do myself.
The common origins thing goes so far that you can today write perfectly fine C code that does not compile with a C++ compiler. (This was not the case in the beginning of C++)
qtnetwork
I wrote such a thing on top of boost.asio. It has syntax like so: NetworkWrapper network; ... Mail mail; mail.to=PostAddress(NetworkAddress("127.0.0.1", 8067), Identifier("EnemyToenail")); mail.addCommand(Enemy::clipNailRPC(Enemy::clipNailRPC::_1("Now!"))); network.send(std::move(mail)); This sends a message that is recieved by the EnemyToenail instance of the Enemy class. The message causes the clipNail member function to be called with the argument "Now!". If the address of EnemyToenail is on another computer then the NetworkWrapper connectes to it before sending the mail. So, basically it is a type safe remote procedure call system where functions of classes automatically get reflected to be callable (via boost.preprocessor). The actuall network code is not even visible for the end programmer, the classes just get mail every once in a while that they execute, and the mail makes sure that member functions gets executed. When sending mail you just need to make sure you have the right address to send to. So the network code has been reduced to a single statement: send and it might send things across the network or it might send things to a local object in ram depending on the address.
That's generally not possible, any more than abstracting the filesystem makes it not visible. You're dealing with operations that can fail, and you need failure handling code in some form. 
Wrote a HTTP server with it. Great library.
Yes, up to that point. 
&gt;C or C++? Choose one; don't mix the two. Cannot stress this enough. As a self-taught turned professional developer, I actually ran into this so much more in professional code than in open-source code that helped me learn. It's almost cringe worthy to see people using classes in C-style ways, seeing malloc() right after new() calls, etc. Just because they work together sometimes doesn't mean they are interchangeable. Pick a damn standard and stick to it.
I agree, but NAT punching generally need an help from an outside server ... It would be great to have an helper though. I would prefer a built-in support for nat-pmp and upnp ..!
I would like to see more of the stuff showed as an example in Boost::coroutine : [look here](http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/coroutine/intro.html#coroutine.intro.example__asio__io_stream_with_std__stream). IO in async coroutine is the future, really. It gives you the expressiveness of synchronous IO with the scalability and performance of asynchronous IO. I wrote a C library doing this sort of async-coroutine with the libevent. I will surely push it on github some day.
It doesn't have to be 'the network' though. More like a remote object that can fail from time to time. 
Good article for beginners, but for programmers who already know C++, that's a lot to read to learn about a simple change.
How have you integrate it with GUI event loops? Or are you saying that you have two event loops in two threads?
what is up with the above three replies? Talk about talking out of your asses.
It's exceptionally good and Chris is a great maintainer of it. We use it for networking and timers (when needed). It's going to be interesting if it goes further down the c++11 route and possibly co-routines. Chris has a macro based co-routine header that's used internally. I think seeing this mixed with non blocking async c++1X will be an interesting future (no pun). 
Thanks, I get your point. I still find it hard to imagine a situation is which it will be useful, but if I ever find one, now I'll know what to do. ;)
Welcome aboard. I hope you have a good book to boot, you can't program C++ effectively with the same ideas and idioms as Java and VB. Furthermore, try and stick to "standard C++" rather than the Microsoft bastardisation Visual C++ (and it's cousins, C++.net, managed C++, CX....) And same for libraries, try and stick to cross platform libraries like boost, TBB, and Qt rather than MS specific and the window API. Happy Hacking.
What kind of timeout are you using? Any timeouts I use look unnatural. For example, a progress bar being updated from a thread. Edit: any any low timeouts result in 100% cpu
This isn't the most exciting thing in the world, but I'm looking forward to not having to wrap my enums in namespaces for my future c++ projects.
The highschool i learn at uses Visual Studio 2012 so i use Visual C++ but im learning through standerd libreys. Furthermore what is bad if I work with Visual C++?
See my first response. 
Slapping a graph in my face with no explanation and no source code is not helpful. I'm only left to making assumptions. I also feel that your test case is most likely too simplistic to show how well your code really scales. Try to do something more realistic, one test you can try do that should show you how bad your approach scales and has poor load balancing is doing nested (data-) parallelism with uneven work. Try a vector of vectors and in parallel do a parallel sort on each vector element. Each vector element should have different sizes from the other elements. With your approach you should spawn a thread for each vector element (or a range of elements if you wish) and use your parallel sort on each e.g.: std::vector&lt; std::vector&lt;double&gt; &gt; double_lists; // fill list of lists of doubles... std::vector&lt;std::thread&gt; thread_list; thread_list.reserve(double_lists.size()); for (size_t index = 0; index &lt; double_lists.size(); ++index) { auto&amp; doubles = double_lists[index]; thread_list.push_back(std::thread([&amp;doubles]() { custom_parallel_sort(doubles.begin(), doubles.end()); }); } std::for_each(thread_list.begin(), thread_list.end(), [](std::thread&amp; t) { t.join(); }); And the task-based parallelism approach using tbb would be: tbb::parallel_for_each(double_lists.begin(), double_lists.end(), [](std::vector&lt;double&gt;&amp; doubles) { tbb::parallel_sort(doubles.begin(), doubles.end()); }); You should also try experimenting the latter with using tbb::parallel_for instead of parallel_for_each, use cache aligned allocators to avoid false-sharing (tbb::cache_aligned_allocator), try different partitioner types like tbb::affinity_partitioner, try using different grain-sizes. All of this is trivial to change in a matter of seconds (that's how great a library like tbb is). Another test you can try do is use your parallel sort asynchronously while doing work another thread, maybe even doing something in parallel on the other thread while your parallel sort is running asynchronously. And while you're making stats please make sure you always have samples of multiple runs and not just profiling single runs per session. 
C++03 can do that. operator bool( MyEnum e) { ... } 
Everything that is network-related. Sockets (TCP-like, UDP-like, inifiniband-like, ...) &amp;&amp; HTTP &amp;&amp; RPC...
When I look to node.js examples, I believe in async I/O. When I look to your link, I start to doubt it.
yes and I agree it is unnatural, but ncurses really isn't well designed for async programming. The timeouts are in the millisecond range, the program is responsive and uses basically no CPU. There are other mechanism I could try (having the block on the io_service, this would make the ui more responsive and the input less. For now it is fine.
Here you go: [Stroustrup on C and C++](http://www.stroustrup.com/bs_faq.html#C) in his FAQ. (Also see his note about '[object oriented](http://www.stroustrup.com/bs_faq.html#Object-Oriented-language)'.)
I don't think that can compile anywhere. Where would you write this? The standard only allows for user-defined conversion operators to be written as single-arguement constructors or as member functions. 12.3.2/1: &gt; A member function of a class X having no parameters with a name of the form &gt; &gt; *conversion-function-id*: &gt; &gt; `operator` *conversion-type-id* &gt; &gt; *conversion-type-id*: &gt; &gt; *type-specifier-seq* *conversion-declarator_{opt}* &gt; &gt; *conversion-declarator*: &gt; &gt; *ptr-operator* *conversion-declarator_{opt}* &gt; &gt; specifies a conversion from X to the type specified by the conversion-type-id. There is no text for a free function conversion operator nor is there text to add one as a member of an `enum`.
Agreed. To quote the Zen of Python: &gt; Namespaces are one honking great idea -- let's do more of those! 
At 40 mins STL discusses ODR with templates but does not explicitly state these function template definitions have to appear in multiple headers (or chains) for this to be a problem. I 'think' this is what's meant but not sure as I cannot see how the example where the template took say an int or std::string would cause an issue as the instantiated code would be different and it becomes more an overloading issue, however if defined again in another header then I can see the issue clearly. Did anyone else think this ? or am I missing a crucial point (it is possible ). Sorry for the huge sentence there.
http://solarianprogrammer.com/2013/02/07/sorting-data-in-parallel-cpu-gpu-2/
I'm wondering why an ODR violation involving macros cannot be detected by the compiler for the presented example of function templates. After all, the complete implemention is available to the compiler, so it should be possible to detect an issue at link time at the latest?
I ran out of time, so I didn't get a chance to explain why the Standard says "no diagnostic required" and why linkers typically don't detect ODR violations in templates and inline functions. Due to things like optimizations, it is possible for multiple TUs with the exact same definition for a template/inline function to generate slightly different object code. If linkers did simple binary comparisons, it would suffer false positives. It *is* possible for linkers to detect ODR violations, but that's a very advanced feature, and certainly not universal (VC11 does not do this). VC10+ has #pragma detect_mismatch which allows a programmer to manually instruct the linker when a macro affects the definition of stuff.
&gt; At 40 mins STL discusses ODR with templates but does not explicitly state these function template &gt; definitions have to appear in multiple headers (or chains) for this to be a problem. My stream of consciousness must have skipped over this. I started by explaining how the ODR forbids multiple definitions in a single TU, with required diagnostics (this is because the compiler can see that you're trying to define a class or function twice). Everything afterwards is about multiple TU scenarios, where the linker is involved. &gt; I 'think' this is what's meant but not sure as I cannot see how the example where the template took say an &gt; int or std::string would cause an issue as the instantiated code would be different and it becomes more an overloading issue func&lt;int&gt; and func&lt;string&gt; are totally different and there is no potential for conflict there. &gt; however if defined again in another header then I can see the issue clearly. The problem is this: func&lt;T&gt;() is defined in a single header, included by multiple source files, and func&lt;int&gt;() is instantiated by multiple source files. However, macros have caused func&lt;T&gt;'s definition to be different in different TUs. Result: ODR violation, no diagnostic required. An effectively identical problem is where func&lt;T&gt;() is defined (not just declared) in multiple headers. This is less likely, because any attempt to drag both headers into the same TU will violate the part of the ODR that requires diagnostics (i.e. you get a guaranteed compiler error). But if you have such headers, and their definitions for func&lt;T&gt;() differ, then you have a problem.
Use a different language then. Erlang seems a good choice for you.
Also its Linux only. So .. you know.
Yeah, asio's one of the rare cases where creating a very general solution that just happens to make it easy to solve the original specific problem actually worked out well. A while back I found myself wishing that Grand Central Dispatch wasn't Apple-specific, only to realize that asio actually makes it pretty trivial to put together something very similar.
That might be a viable approach (I am not a compiler/linker dev), but you'd have to get the compiler to encode that information into the object file (or possibly debugging information).
So much this... fairly new to c++, looking at boost makes me dizzy if I try to "browse".
Why? c++ is a perfect candidate for such an abstraction.
Except Erlang already is that abstraction.
Asio has a version that doesn't depend on boost. I believe it was originally meant for a TR2 submission. It can be downloaded from the project homepage. http://think-async.com/Asio/
Agreed, Asio is awesome! and not only for networking.
Think of Boost as something similar to the JDK or .NET frameworks but with a better design. Without those f/w's Java and C# developers would be pretty useless. Modern C++ includes using the Standard library (aka STL) and Boost.
I know what boost is. The problem is that on some projects you already have the msvc stuff that has a lot of similar functionality, on others you use Qt which also has offers loads of functionality. You wouldn't add Qt to your build process just because it adds some networking stuff, right?
Thanks for clearing that up Stephan, appreciated !
Sure it is, but I don't want to use it.
I want a thin, type-safe wrapper around [libevent](http://libevent.org/). Well-tested, widespread, excellent cross-platform support. Add C++ lambdas for callbacks, abstraction away from C-style socket programming, and we'd have a winner.
You also have the free and excellent Qt Creator, with features like refactoring, adding and syncronizing methods in h/cpp files, etc etc. You can use it as stand alone IDE or with Qt library, a wonderful library (not only GUI) to create desktop and mobile applications (iOS and android etc in the future)
I fail to see how it is any different from most operating systems (BSD and Linux distributions excluded).
Package management is not a function of the kernel. So yes, if you want to get pedantic comparing Linux to Windows is not possible, because Linux does not do package management. But I name dropped Gentoo for a reason. It has a package management system and the people that maintain Gentoo make it work. Windows has the Add/Remove Software panel. There is no comparison. Every moderately sized linux distro solves this problem better than Windows has, mostly because Windows is still limping along with a solution from the early 90s. The statement: &gt;there's nothing intrinsic that should make C++ harder on Windows or easier on Linux. is technically correct, but the reality is that we're comparing Windows to actual distributions of Linux, so the statement: &gt;Other than that Linux distros can ship with GCC, I suppose. Is ridiculous. Portage makes Gentoo infinitely better than Windows for code distribution. Every substantial piece of software on my system has been compiled *on my system* from source. I know that I have the dependencies, I know those dependencies are sane and installed in a usable way, I know that those dependencies can be linked in to other programs because they are linked into other programs every time I update some piece of software. Boost is a perfect example. If I want boost to work on any IDE on my system I just say 'emerge boost'. On windows, I install some binary bullshit and start fucking with my IDE to get the includes working and linker happy. Nevermind what I have to do to actually distribute my code to someone else (Make? vcprojs? Ant build files? There is no good 'windows' solution, just a bunch of borrowed Unix solutions that can be wedged in via cygwin).
I don't understand your point at all. Windows 7 is not competing with commercial UNIX systems, embedded OS's, real time operating systems or mainframes. It's competing with other desktop operating systems, which means OS X and a bunch of Linux distros. Windows is worse than all of them. At least for OS X it's unix out of the box and you don't need Cygwin to get a makefile or configure to work.
An operating system is an operating system, regardless where it is used. Oh and Mac OS X is an UNIX just because Apple bought NeXT instead of BeOS. Try to use commercial C and C++ tooling on Mac OS X via its "package manager".
"The summary of the results is that across a test of all two billion positive floats VC++ gets the last digit wrong four times, has legitimate disagreements with g++ 6,694,304 times, but the discrepancies probably don’t matter." I think I just like writing code that scans all floats.
It's still pretty hacky, but a better solution in c++11 is probably to define a user literal that takes numbers in discrete chunks and concatenates them. The final result would look something like: int i = (123,456,789)_aNiceSuccinctLiteralNameGoesHere; Edit: It appears upon perusing cppreference.com that user literals can only take a single argument, much like regular literals. You can still do it this way, but it would need to be something like: int i = "123 456 789"_sInt; And then the _sInt literal converts the string to an int, which is fine if you write it as constexpr I guess, but still ugly.
And I like reading articles about writing code that scans all floats, so thanks for doing that and for submitting it. 
As it happens, somebody asked about this on StackOverflow a while back, and got a few different answers about how to handle it: http://stackoverflow.com/q/14220217/179910
If you want a fixed precision decimal type then why don't you write one? You won't get as good performance obviously, but then you can exactly define the precision and accuracy you need.
 { using namespace std; //Variables... string filepath; // insert code here... cout &lt;&lt; "Welcome to Evanb_24's mod porter utility for all Minecraft versions! (At least before 1.4.7)" &lt;&lt; endl &lt;&lt; "This is a beta version, and may not work." &lt;&lt; endl &lt;&lt; "The next version will have a GUI for Mac, Windows GUI support may never be released, sorry :("; //file path data cout &lt;&lt; "Enter the directory path to which the mod is located"; cin &gt;&gt; filepath; system("cd" return 0; } maybe this comment will format the code correctly
It sounds like you are trying to publish your tool to other people, once it's finished. If that is the case, you should not use the system function, as it is heavily dependant on the operation system. It might work on a Mac and crash with an error on Linux and Windows. Manipulating files is not that easy in C++, at least not with the standard library. I recommend you to install the Boost library (easily found by Google). That does not require much knowledge or effort and you will have easy functions like "copy" or "remove". Last: I am not familiar with "Cocoa", but from your description I guess it is not cross compatible. There are GUI kits which let you write the code only once, then compile it for all the major operation systems the same.
There's a lot of problems here. First of all, calling `cd` from `system()` will have absolutely no effect. The current working directory is a per-process variable. `system()` invokes the system shell to execute a command (`/bin/sh` on Unix-like systems, `cmd.exe` on Windows systems.) That is a separate process. Even if the shell process successfully changes its working directory, it's going to subsequently terminate, making that change unobservable. The current working directory of the calling process -- your program -- will remain unchanged. There is no way that you can change that by running an external program. It might be possible as part of a larger series of commands executed by the shell (e.g. `cd foo &amp;&amp; ...`), and there are system-specific APIs for changing the working directory of the current process (e.g. `chdir()`) that don't involve calling external processes. But you really don't need to change the working directory. If you need to refer to files located outside of the current working directory, use a relative or absolute filename that includes their location. Secondly, `system()` should be avoided because of [shell injection vulnerabilities](http://en.wikipedia.org/wiki/Code_injection#Shell_injection). Someone could give your program a funny filename and trick it into executing commands. To prevent that requires meticulous quoting and deep knowledge of your system's shell quoting rules. It's much easier to cut out the shell entirely and do the word splitting yourself, and call another system-specific API that invokes a subprocess without involving the shell. On a Unix-like system this generally involves one of the [`exec()` family of functions](http://pubs.opengroup.org/onlinepubs/009695399/functions/exec.html) in conjunction with `fork()`, or possibly a friendlier wrapper like `posix_spawn()`. It's also entirely possible that you don't need to run any external programs. Doing things like moving files, copying files, deleting files, etc. can all be done directly without needing to rely on external programs to do it for you. And in fact relying on external programs is fraught with issues -- both performance and security. Read the "Formatting help" link for how to post code without it being completely mangled. 
&gt;Most developers rarely need to print the exact value of a float True. When i do need that, i just print its representation as hex integer.
If all you need to do is copy files, there's no reason to use the shell. A C++ method can open, read and write files without problems if you have the path names. [Here's something](http://pastebin.com/7UQkqqC7) to get you started: this should work fine on any (C++11) compiler. If you rely heavily on other programs, consider writing a (system-specific) shell script, in which your program is only a part. Something like mv a b ./myprogram cp b c For every system you can modify the shell script and have your program as an invariant. Even a gui program could call this script (only 1 system call needed then). The advantage is you delegate the (system-specific) shell commands to something which is made for it: the systems' shell.
That C++ program, which just calls open(2), read(2), and write(2) on the file, will throw away file attributes, extended attributes, and resource forks. This is why the OS X API has a [copyfile(3)](http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man3/copyfile.3.html) library call, which preserves these. 
&gt; That C++ program, which just calls open(2), read(2), and write(2) on the file I don't think that's a given: I'd assume that's implementation dependent. I'll grant you that it's likely though. &gt; This is why the OS X API has a copyfile(3) library call, which preserves these. I don't think this helps with the issue, the comments in the code say it's supposed to be for Windows also. If this really is an issue (say you need the file-system meta information), [Boost](http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm) seems to me the way to go. OS API's are a beyond-last resort in cross-OS C++ programs.
If it's portability you're after, the code is broken in Windows too, as it doesn't preserve NTFS alternate data streams or ACLs. Which is why the Windows API has its own [CopyFile](http://msdn.microsoft.com/en-gb/library/windows/desktop/aa363851%28v=vs.85%29.aspx) API. Portability is not an excuse for wrong.
I appreciate your thoroughness and can see it's an important sidenote to the code I linked to, but personally I've never had an issue with copying files this way. If you don't need the file-system meta information, this is not a wrong way to copy the contents of a file, right? If you do, the OS-specific API's should be, as I said, a last resort. An #ifdef-hell that way lies. If it's possible to use any (reasonably portable) alternative, such as Boost, that's the better option.
https://github.com/toffaletti/libten uses boost.context to do something similar (blocking style epoll driven io). Disclaimer: I'm the author of libten.
To format code correctly indent it by four spaces. Read the “formatting help” for more information.
This sounds more like a shell script or python program than a c++ program. Right tool for the job.
if you use Qt you get [cross-platform file-handling](http://qt-project.org/doc/qt-4.8/qfile.html), as well as cross-platform UI...
Nobody seems to be answering your question, which is that the right thing to do to compose strings looks something like this: string command="cd"; command+=" "; command+=filepath; system(command.c_str()); Alternately, you can use an ostringstream #include&lt;sstream&gt; //in your includes... std::ostringstream cmdoss; cmdoss &lt;&lt; "cd " &lt;&lt; filepath; system(cmdoss.str().c_str()); 
Templates don't work here because octal.
Boost's file IO is a part of TR1, so he should already have it as part of his standard library (as long as it's a recent version of VS, g++, or clang).
Ah, nice. I never thought of that. To clarify, rabidcow means the following expression will not do as expected: std::cout &lt;&lt; num(123, 056, 789) &lt;&lt; '\n'; This will print "123**046**789" because the number 056 will be interpreted as an octal value (because of the leading zero). You could leave out the zero for a correct result, but this is counter-intuitive and would defeat the purpose of the exercise. So this solution fails. Still, it was only a demonstration of principle; I believe it's not a problem worth solving in either syntax or wrapper code.
That doesn't sound correct. I think he was referring to [Boost::Filesystem](http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm), which isn't part of TR1, but TR2 - &gt;"A proposal, N1975, to include Boost.Filesystem in Technical Report 2 has been accepted by the C++ Standards Committee. That proposal was based on version 2 of Boost.Filesystem; presumably the final TR2 form will be based on version 3." I'm not 100% sure if Wikipedia is a valid point of reference, but it also doesn't list any type of disk i/o facilities in TR1: http://en.wikipedia.org/wiki/C%2B%2B_Technical_Report_1 It does, however, point out the TR2 Boost::Filesystem proposal - http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2011/n3239.html
The reason no one is answering how to compose strings is that it's the wrong question. The problem with this type of thing is that it only works for small subset of inputs. Consider: my_program "my directory". It's going to ask the shell to do "cd my directory" which isn't valid. If you think your users are not going to have spaces in their directory names, think again. So you might think, ok I'll just do this: string command="cd"; command += " '"; command += filepath; command += "'"; system(command.c_str()); That fixes the space issue! Ok, so what about this: my_program "david's minecraft directory" Uh oh. So maybe switch to double quotes? my_program "David's \"awesome\" minecraft directory" Well crap. Now you have to shell escape stuff. At this point things are getting complicated. What if there's a $ in the name? You pretty much have to really understand shell and write a bunch of complicated string manipulation stuff in C++ (which really isn't known for its string manipulation prowess). In the end, it's *much* better to step back and take a different approach. Also, you can trick the program into doing stuff you don't expect. Consider: my_program ". &amp;&amp; rm -rf ~" Now, you might think that it doesn't matter since if someone typed that they might as well have just typed "rm -rf ~" and while that's true, it's much better to make your program do what you expect and nothing more. As it grows (as software tends to do), it will eventually come back to bite you. Also, as is pointed out elsewhere in the thread, system("cd xxx") doesn't actually do anything: it forks a subprocess and changes the working directory of that subprocess, then it quits and returns control back to the program which still has the same working directory that it did before the call.
I absolutely agree with you that he's going about this in completely the wrong way, but if he already understood how to do string composition he wouldn't have even come here.. Everyone is going out of their way to explain how what he wants to do is difficult and how his approach won't effectively solve the problem he wants to solve, but what if he listens? Will he really learn anything? I'm agreeing with you and the other posters that his approach is poor, but I'm trying to teach him how strings work as a first step. Lets say he decides to scale it back and make a small text adventure or something. Based on our advice, he'll know REALLY well that system("cd ") is a bad bad bad idea, but He still won't understand how strings work in C++.
Whenever you use a stringstream for string concatenation and nothing else, an STL maintainer cries.
Oh really? My bad :P
This is exactly what was needed. I used to read a few papers from meetings. Sometime I'd have a comment or question but no way to put it out there. Now the public can read the papers before the meetings, and their comments will be heard.
Agreed, but thats why I demonstrated both approaches. He merely needed string concatenation, but in seeing the stringstream approach he would learn and see th connection to streams and cout for formatting.
The problem with the Qt stuff is that at least the HTTP libraries are unusable because they keep changing them in major ways.
I'm going to hazard a guess that you aren't getting any replies because all Win32 C++ code is ugly and terrible and at least you can usually tell if it's working. Doesn't look particularly awful to me.
#include &lt;cstdio&gt; instead of &lt;stdio.h&gt;
Maybe it is C++, but it sure looks like it could be compile with C.
Use a proper struct initializer for wcex.
Use destructors to encapsulate cleanup of resources like the clipboard handle.
If you're gonna use constants, use constant variables. e.g. This: HWND hWnd = CreateWindow(wcex.lpszClassName, L"Color Picker", WS_TABSTOP, 0, 0, WIDTH, HEIGHT, NULL, NULL, hInstance, NULL); Should really be this this: HWND hWnd = CreateWindow(wcex.lpszClassName, TITLE, STYLE, 0, 0, WIDTH, HEIGHT, NULL, NULL, hInstance, NULL); Where TITLE is a const std::wstring, and where STYLE is a const unsigned int, especially since you the use WIDTH and HEIGHT of the window as constants; consistency is key. And, try to avoid #define, as it is [evil](http://hbfs.wordpress.com/2009/11/17/defines-are-evil/). i.e. These two lines: #define WIDTH 320 #define HEIGHT 180 Should be (as it's better practice): const unsigned int WIDTH = 320; const unsigned int HEIGHT = 180; Also, use &lt;cstdio&gt; instead of &lt;stdio.h&gt;, if you're using C++. Even better, use streams (iostream, sstream, and fstream if you want file i/o), unless you really really prefer stdio and/or require it. Another tip, is to avoid duplicating code, that's what functions are for. e.g. Instead of writing this multiple times: sprintf(color_hexa, "#%02x%02x%02x", color &amp; 0x0000ff, (color &amp; 0x00ff00) &gt;&gt; 8, (color &amp; 0xff0000) &gt;&gt; 16); Use a function, like so, to perform the task of printing a colour to a string, which is what you are doing: std::string colorToString(COLORREF color) { char color_hexa[8]; sprintf(color_hexa, "#%02x%02x%02x", color &amp; 0x0000ff, (color &amp; 0x00ff00) &gt;&gt; 8, (color &amp; 0xff0000) &gt;&gt; 16); return std::string(color_hexa); } The main reason for this is to avoid bugs, as you can easily change it in one place, and the programmer (specifically you) does not need to worry about how the function is implemented, just as long as it works. But of course, I contradict myself on that statement, as you are the one who is implementing the function and therefore must ensure that it works properly. I mainly made the first statement to imply that other people may use your functions, and therefore must do what is expected.
Looks like you used tab to indent, then again to align, should use tab to indent then space to align. Or even space to indent then again to align, otherwise some parts no longer look neat when the tab size is changed.
Just want to point out there is a sub-reddit dedicated to reviewing your code over at /r/reviewmycode!
&gt; Also, use &lt;cstdio&gt; instead of &lt;stdio.h&gt;, if you're using C++. About this point, I used to be a big believer in this, but not anymore. C++11's rules changed to reflect existing practice. N3485 D.5 [depr.c.headers]/3 has a convenient example: "Example: The header &lt;cstdlib&gt; assuredly provides its declarations and definitions within the namespace std. It may also provide these names within the global namespace. The header &lt;stdlib.h&gt; assuredly provides the same declarations and definitions within the global namespace, much as in the C Standard. It may also provide these names within the namespace std." Because &lt;cfoo&gt; isn't actually guaranteed to keep the global namespace clean (and doesn't in VC's implementation), I just include &lt;foo.h&gt; now. Namespaces are good, but we've surrendered the war to get the C Standard Library out of the global namespace.
This just reminds me how ugly Win32 code is. Qt for life.
Haha, bad memories I'm trying to block out, but I spent a year developing over ambitious indie games with not enough time or money, so I resorted to cowboy coding - no unit tests, ugly complex code. I was actually quite happy with my alpha version I made, but it was taking longer and longer to add anything because the code was so tangled. I knew I didn't have enough time to finish it so we risked making something from scratch in just 3 months (also messy). Managed to get it out the door but it was buggy and mediocre and no-one cared (even I thought it was boring!). It was a very long and expensive lesson in not being sloppy.
Oh! Thanks for this info.
Use the message crackers in windowsx.h 
Use the safe sprintf variants. use TCHAR instead of char or wchar_t (TCHAR maps to unicode or ascii depending on build type). Use either sprintf_s or wsprintf_s, but not both, or better _tsprintf_s. Use **HIBYTE, LOBYTE, HIWORD, LOWORD** etc rather than bit manipulation: sprintf(color_hexa, "#%02x%02x%02x", color &amp; 0x0000ff, (color &amp; 0x00ff00) &gt;&gt; 8, (color &amp; 0xff0000) &gt;&gt; 16); sprintf_s(color_hex, sizeof(color_hex), "#%02x%02x%02x", LOBYTE(LOBYTE(colour)), LOWORD(HIBYTE(colour)), HIWORD(LOBYTE(colour))); When string specifying array size, use the +1 notation so you know you've added enough for the \0 terminator. TCHAR color_hexa[2+2+2+1]; 
I checked the occurrence of this technique in the Chromium code base, because I was curious. [Chromium code search](http://code.google.com/p/chromium/source/search) Search for "return !!" and see for yourself. What I do not understand is the usage of this technique in the return statement of functions with return type bool. Isn't the "!!" totally unnecessary there?
It's sometimes used as a way to remove warnings, if you return a pointer from a `bool` function they compiler may complain but if you use `!` the compiler assumes you know what you're doing (since `if(!p)` is a common idiom). Other times it's used due to cargo cult programming (in our code base this is more often the case). BTW in less typed languages (e.g. JavaScript) it's used to cast the return value to `bool` so that redundant data doesn't escape the function. e.g. ` function hasElements(c) { return !! c.length; }` 
As someone with over a decade experience with C it's still pretty damn cryptic. 
Let's take off the training wheels here, OK? Anyone who understands what the ! operator does is not confused by two of them stacked back-to-back. In fact, this construct is a C programming idiom. Its behavior is well-defined, it has a specific purpose and use, and anyone who's a solid C programmer recognizes it instantly.
&gt; The correct way to do this is to use an inline function called clamp. Disagree.
&gt; arrogance You're calling out arrogance, while dictating the correct way (and the correct **names** for functions) to accomplish a simple task?
Some older Win32 APIs will have a return type of BOOL, which is defined as the following for some reason, possibly relating to 32-bit alignment? typedef int BOOL; // or: typedef long BOOL; In this case, !! becomes very handy: BOOL SomeWin32Call(); bool foo = SomeWin32Call(); // compiler warning bool foo = !!SomeWin32Call(); // No warning
yes but there's enough operators with their double doing almost completely unrelated events that knowing what the single-operator version does doesn't mean you'll know what the double does
No I just consider this a very basic idea. It reminds me of the subtlety between prefixing rather than post-fixing the increment operator; a minor confusion the first time you encounter it and quite intuitive after that word has been memorized.
I'm not saying it's a complicated idea. What I'm saying is that it is the opposite of clear. (value != 0) ? 1 : 0; Accomplishes the same goal *and* is easy for a human to read: *"If the value is not zero, then the value is 1 otherwise it is 0."* post-fix and pre-fix are a completely different issue than what we're talking about here. 
There are better libraries covering the same things as Poco, e.g. Boost, Qt, libevent, OpenSSL,... (depending on which bit you need).
Herb Sutter is a pretty cool guy.
When Herb is talking about code-gen and shows the extra guaranties of mov instruction, I remembered the Jeff Preshing's article about strong and weak architectures "[This Is Why They Call It a Weakly-Ordered CPU](http://preshing.com/20121019/this-is-why-they-call-it-a-weakly-ordered-cpu)", another load/store article by Doug Lea when working on Java's 5 memory model "[The JSR-133 Cookbook for Compiler Writers](http://gee.cs.oswego.edu/dl/jmm/cookbook.html)".
"or for something completely different... x slides to 0" while (x --\ \ \ \ &gt; 0) printf("%d ", x); That's golden.
Ill admit that I laughed way harder at that than I should have.
Please never work with me
Actually they are at least as easy to use as Poco and you need to debug fewer Poco issues. If you need something doing significant work in a day though C++ in general is a bad choice though. 
The two 'canonical' for loops are: for (unsigned i = 0; i != 10; ++i) // i from 0 to 9 inclusive for (unsigned i = 10; i--; ) // i from 9 to 0 inclusive If you really want to use a while-loop (because you don't know the number of iterations in advance), consider while (i--)
I was afraid it was going to be: http://stackoverflow.com/questions/5508110/why-is-this-program-erroneously-rejected-by-three-c-compilers but then I saw that that was C++
Woah, optimization can be weird. Wonder if this holds for other compilers.
Wouldn't while (i--) only work assuming i starts off positive? 
That depends on what you want. If i equals zero, it will fall though the loop without entering it, only decrementing i as a side effect. If i is negative, while(i--) will also work nicely. You'll just go through a lot of numbers, i.e. all the negative range below your starting point and then the full positive range of the variable type, ending with zero. :) Given that we were talking about unsigned integers, I hope you'll agree it's a fair assumption i is non-negative though. ;)
Spacing: so much more important to other programmers than people think, often less important to the compiler than people expect. I saw some Java programmers arguing about the following snippet of code way back in the day (2000AD) when the world was full of Java programmers who had never seen a line of code in another language: foo?blargh : bang The code compiled, so they "knew" they were encountering a compiler bug because it was letting them use ? in a variable name. One of them had seen a switch statement before, and he "knew" that's what the colon was for, so clearly the question mark was putting the compiler into a state where it thought it was in a switch statement. What really blew their minds was that the compiler produced output that functioned as intended in production. They had just rewritten the code to remove the "time bomb" and were arguing about the compiler "bug" to pass the time while the tests ran. 
It is at this point I realize your dislike is irrational and there will be no reasoning with you. Good day.
If you count it as irrational that i actually had to work with Poco and it produced about as many issues as all the other libraries I listed combined then sure, count that as irrational. As for C++, I do dislike it but it is alright as a tool for certain tasks. Rapid prototyping or small scripts are not among those tasks.
For some reason I can't get registered on that site. I get the e-mail and the activation always fails...
To be honest, the first thing I saw was "you're using gets()". break is not a valid keyword at that point. You're not in a loop or a switch. I think you mean 'else'.
are you sure this is a c++ course and not a C course. Nothing in that code suggests you are learning C++ when an awful lot could.
You are only allowed **break** inside for/while/do loops, or switch statements. They shouldn't be there, basically. Change the second and subsequent **if** statements to **else if**, and remove the **break** statements.
Why not `while(x-- &gt; 0)` instead of `while(x --&gt; 0)`? It's not as cute, but it's a lot more clear what it does.
Your second loop is really hard to understand and I wouldn't let it through code review. Much simpler and obvious to do for (unsigned i = 9; i &lt;= 9; i--) Though why anybody would use an unsigned for a loop counter is beyond me.
Die.
Similarly, your loop would fail a student of mine. :) You're counting on overflow behaviour and use post increment where pre increment is meant. And using an unsigned (size_t) is pretty much manditory for any loop index here, because usually an index is unsigned.
First of all post versus pre decrement is completely irrelevant. Secondly as overflow is completely standard, it means nothing to count on it. 
My favorite piece of confusing code: int Array[100]; for(int Apple = 0; Apple &lt; 100; ++Apple){ Apple[Array] = Apple; } for(int Banana = 0; Banana &lt; 100; ++Banana){ std::cout &lt;&lt; Array[Banana] &lt;&lt; std::endl; }
That's a joke right?? That has to be a joke... I hope it is a joke...
I hadn't considered the second possibility... I think I might like it better because the loop variable can be declared locally within the for statement. Now here's a harder question: can you make a single loop that can loop both up from zero and down to zero? Something like for(int i = istart; (inc &gt; 0 ? i &lt; iend : i &gt;= 0); i += inc) except with unsigned numbers. I don't believe it's possible, but I am not particularly clever.
I can understand where you're coming from; my only goal here was to show coding standards can differ. Obviously pre vs. post decrement is not "irrelevant". Your only claim here could be "*the compiler optimises for my code, so the fact I didn't write what I meant does not impact perfomance in this case*" and even that is an assumption. There is a difference and it's relevant to writing good code. Your usage is wrong because the code does not reflect the behaviour you want. The second point has more to do with taste, I'll agree. Even though *unsigned* over- and underflow is well-defined (signed is not) I'd say it's bad style relying on it. You might disagree and that's fine. I very much like the decremental for loop I gave above. It allows for neat things like: for (size_t idx = vector.size(); idx--; ) // loop through vector back to front No -1 dangling in the code, no *while* for a ranged loop, only clean, efficient and neatly initialised code which shows exactly what you want. I can understand you find it difficult to read the first time, but I fully believe it's the best alternative for a decrementing for loop. Any other option will introduce inefficiencies or other, more difficult, reading problems (like your code depending on underflow). But again, this last argument is mostly taste and you may disagree.
Yes, the decremental for loop is very neat. I'd recommend using it instead of what you're doing now with the *while*-thing. Do I understand you correctly that you want to give an arbitraty istart and iend and just have to loop go through that range? Something like unsigned istart = 0, iend = 10; // or vice versa for (unsigned idx = istart; idx != iend; istart &lt; iend ? ++idx : --idx) or something like unsigned istart = 10, iend = 15; int inc = -1; // or 1 for (unsigned idx = istart; (inc &gt; 0 &amp;&amp; idx != iend) || (inc &lt; 0 &amp;&amp; idx); idx += inc) would do it. It's not particularly efficient though, the logic checks would have to be done each iteration. Better to split the two cases up and having two seperate for-loops, which is more efficient and easier to read, I'd think.
You are obviously a complete pseud. First of all pre or post decrement in the third clause of a for loop are exactly the same. Show me a compiler that treats them differently. Secondly relying on behavior defined by the standard is not remotely bad style. That is a ridiculous claim. But finally, claiming that your code, while correct, is remotely sensible in a real world context is terrible. I have thirty years experience of C development, and while I can see that your code is correct now, it took me a few minutes to see what you were doing. Here in the real world we can't spare those minutes to see how clever you were, we expect the increment or decrement to be in the third clause of the for loop. Because that's where it is usually. Your code is just asking to be corrected. And that is why it would never get through industry code review, it is not immediately obvious because you are abusing the accepted usual loop paradigm. If it was a while loop then no problem. But putting the increment or decrement in the second clause is asking for trouble from the maintainers of your code.
Why the *fuck* would you not free unused memory?
So the application of this is for converting old Fortran code, which has loops of the form DO I = N, 1, -1 which loops from N down to 1. Converting to C++, I need to go from n-1 down to 0, but occasionally I see constructs like DO I = I1, I2, IINC because the direction of the loop is decided upon earlier. Currently, I'm forced to just make two copies of the loop; one for each case, and duplicate the loop body code, which I find very inelegant. I could simplify things by using signed integers, but I prefer to use size_t because it's semantically correct.
I'm sorry for making you angry by going against your expectations by having the decrement in the second and not the third clause of the loop. I failed to account for your feelings and for that I apologise. Any compiler will treat pre- and post incrementation differently for user-defined types (unless very strict specifications are met, in the case of gcc). Likely they will do the same for std iterators. For built-in types the compiler likely will optimise here, but it need not. My point remains: **why would you write what you obviously do not mean and then expect the compiler to fix it for you?** Isn't that a bit daft? Plus it requires more maintenance when switching to iterators or another type, an argument which must carry weight for a professional programmer. Pre and post increment are not the same, whether in the third argument of a for loop or anywhere else. I hope you also see the conflict in first claiming relying on standard-defined behaviour is not bad style and then accusing me of bad style for code which relies fully on standard behaviour. It's all about clarity here, as you surely realise. I honestly think my code is clearer because of the reasons I stated in the previous comment. I would say that you're abusing an unsigned value by checking for underflow in your example and that putting a smaller-than check in a decrementing loop is more confusing than my code. Oh, and don't forget the magic number 9 in "i &lt;= 9". Why not 10? Should we change that 9 to 8 if we want to start from 8? That's more maintenance again. I think my code is clearer. You don't agree, fair enough. I'm sorry to see that over there in "the real world", you also can't spare some cooling-off time. Try counting from ten to zero (or to UINT_MAX ;)).
Yes.
If you install reddit enhancement suite (RES) addon for your browser, it adds a button that formats code.
Hex certainly works, and is very space efficient (eight digits), but then you lose the readability of printing in text, so what's the point? I know some game developers serialize floats both in hex (to retain the exact value) and decimal (for human readability). The point of my article is to point out that it is unnecessary to do both.
the %a format is pretty nifty... best of both worlds.
Y u no mocking-framework?
Came here to pimp gMock. 
Manually writing mock objects? Using scripts to attempt to guess them? That's so old-school. Template metaprogramming to auto-create them, that's where it's at.
Link to a workable demo that approaches gMock capabilities?
https://www.assembla.com/code/hippomocks/git/nodes/master/HippoMocksTest All the tests. Let me know if there's a capability you're missing.
&gt;so what's the point? Im talking very nieche scenarios, where you actually care about every ULP of the result. You gain readability there too, just for something else. You may not know how much the value is immediately (assuming no additional decimal output), but can know error or how much are you off in much more intuitive manner. 
Using the function offsets is cute, but what do your error messages look like? gMock produces GREAT error messages because it has access to the symbol names as strings (at the cost of macro gunk and manual mock definitions). Yes, it's sort of a pain in the ass to maintain my interface class, concrete class, and mock class, but I find that I appreciate it when the compiler yells at me when the mock class fails to implement one of the (pure virtual) interface class methods.
Can someone explain the relaxed shared pointer to me? What would stop thread 1 from incrementing the count, thread 2 not seeing that increment, decrementing it to zero, and then freeing memory that thread 1 was still using?
`std::decimal` is one proposal. Meanwhile, take a look: http://sourceforge.net/p/stddecimal/code/15/tree/trunk/ Discussion on boost-devel: http://comments.gmane.org/gmane.comp.lib.boost.devel/230155
&gt;Printing with %1.8e retains every ULP. Yeah, i read the article actually ;) As an additional thing to take under consideration, if you really care about precision, and see output in %1.8e you still have to wonder whether original data is single or double precision. Giving repr makes it pretty explicit. This probably matters even more when this data is to be communicated to other people, where you cant assume everyone has actually read your proof. 
I THINK it's because it's assuming that the shared_ptr isn't itself shared among threads (although what it's pointing to may be). If you're sharing the shared_ptr itself, it's quite likely you'll need locks anyway, and a few memory barriers aren't going to save you.
&gt; whether original data is single or double precision. Fair point.
The confusion here probably stems from the definition of "relaxed." The standard says as a note in §29.3 (atomics.order): &gt; Atomic operations specifying memory_order_relaxed are relaxed with respect to memory ordering. Implementations must still guarantee that any given atomic access to a particular atomic object be indivisible with respect to all other atomic accesses to that object. *So*, what `memory_order_relaxed` means is that loads and stores *on the current thread* can be re-ordered around the atomic operation. As you say, this can never be an issue for incrementing the use count, since you will only take action when you decrement to 0 (which will only happen once). If my understanding is correct, relaxed decrementing would be equally safe -- if it wasn't for the weak counter. The standard makes no thread safety guarantee of safe access for two threads sharing a single `shared_ptr&lt;T&gt;` instance (as opposed to N `shared_ptr&lt;T&gt;`s pointing to the same memory), nor does it guarantee the safety of a thread calling `get`, not keeping a `shared_ptr&lt;T&gt;` instance around and continuing to use the pointed-to data. Nobody *can* be reading the owned object after the use count has dropped to 0 (and if they are, we've made no promises to their safety). What `std::memory_order_relaxed` does *not* do is guarantee the loads and stores of *other* variables on this thread. The weak count is the problem...take this oversimplified example of `release`: void release() { if (controlBlock-&gt;useCount.decrement() == 0) { // we were the last strong owner -- destruct the T ptr-&gt;~T(); if (controlBlock-&gt;weakCount.decrement() == 0) { // there are no more weak owners, so it is safe to delete the memory chunk the control block occupies delete controlBlock; } } } It is *not* safe to speculate the decremented value of `weakCount` before an acquiring load of `weakCount`, since a weak-owning second thread is free to alter the value between `ptr-&gt;~T()` and when this one decrements the `weakCount`. Likewise, we need to make sure there is a releasing store of `useCount`, since a second thread calling `delete controlBlock` (from a weak release) needs to have observed the effects of decrementing `useCount` (or the first thread will store the value later in memory which it no longer owns). This leads me to the conclusion that an acquire-release memory fence is needed between the destructor call and decrementing `weakCount`, but I'd be happy to get more information about this sort of thing.
pattern matching for types? not very OOPish, but according to the article its way faster, cool stuff. i imagine it uses a lot of template magic behind, things like std::enable_if and and std::is_base_of thanks for the link (i got to read that website more often)
&gt; If my understanding is correct, relaxed decrementing would be equally safe -- if it wasn't for the weak counter. This is incorrect. Ignore the existence of weak_ptr, and imagine an implementation with relaxed increments and relaxed decrements. Threads A, B, and C (holding strong refs) read bytes from the owned object. This is OK to do simultaneously. Then they're done, so they each decrement the refcount and do other stuff. Thread X also holds a strong ref, and decrements the refcount. X observes the refcount falling to 0. It says, "Awesome, I was the last one to leave the building, time to turn off the lights". It destroys the owned object and deallocates the memory, scribbling over the bytes. **However**, because all atomic operations were relaxed, it is possible for any of threads A/B/C to observe thread X scribbling over the owned object's bytes, before A/B/C decremented the refcount and walked away. &gt; Nobody can be reading the owned object after the use count has dropped to 0 Your reasoning is assuming sequential consistency. Reasoning about multithreading correctness given SC guarantees is intuitive but difficult (since you only have to imagine all possible interleavings). Reasoning with weaker-than-SC guarantees is completely non-intuitive and therefore extremely, punishingly difficult. (In VC12, we're using relaxed increments and SC decrements for both the strong and weak refcounts, and weak_ptr locking is completely SC. I'm 99% sure that this won't burn us.)
That explanation makes a lot of sense. I need to get some experience with non-x86 things...the platform is spoiling me with its ridiculously strong memory model.
Hmm...can't get it to compile with clang (xcode 4.4) on osx. Anyone?
Just complementing other users aswers... Avoid using 'gets', it's a unsave function. Try using 'scanf'. http://www.cplusplus.com/reference/cstdio/scanf/
It's something that programmers in a number of functional languages (OCaml, Nemerle, Haskell, etc.) have long enjoyed.
Modern C++ is in fact not very OOPish. This is something I've wanted for a while for dealing with boost.variant, but the EndMatch macro is kinda iffy. I think I'd prefer something like boost.functional/OverloadedFunction that just takes a lambda for each type and wraps them into a single visitor.
This is an engineering course that teaches C++ isn't it?
He uses relaxed atomics and doesn't afraid of anything.
But then we'll get gifts on Halloween!
Yeah, reminds me of the "goes to" operator, `while (x --&gt; 0)`
In file ptrtools.hpp are following functions: template &lt;typename T&gt; inline const T* addr(const T* t) { return t; } template &lt;typename T&gt; inline T* addr( T* t) { return t; } template &lt;typename T&gt; inline const T* addr(const T&amp; t) { return &amp;t; } template &lt;typename T&gt; inline T* addr( T&amp; t) { return &amp;t; } What if T has overloaded operator&amp;? I think, that [std::addressof](http://en.cppreference.com/w/cpp/memory/addressof) should be used used instead.
From the comments: &gt;Secondly, clean code is not about writing as little code as possible. It is about writing code with single responsibility, about keeping the level of abstraction within a function constant. It is about making implicit assumptions explicit, it is about not repeating yourself all the time. Writing clean code means to make things modular and easily changeable. &gt; In most situations, this means that you need to write more code. You introduce functions to abstract from bit-fiddling. You create classes to collect operations on related variables. You introduce interfaces to decouple your code and make choosing between different strategies easy. All this requires new signatures, names, declarations, and whatnot. You get more code. The good thing is that if you do it correctly, each bit of this code is easy to understand and to exchange. With clean code, you have lots of different units which are easily testable, and this will safe you lots of time. I agree completely. I don't understand how people don't get this.
&gt; not very OOPish, but according to the article its way faster, cool stuff It is, indeed, cool stuff, but I just have to clarify: It's not necessarily faster than OOP-style method dispatch in all cases. The use case it tries to solve is this: I have an object of this type — which function to I call? With OOP, this is achieved with a virtual method. Calling a virtual method is exactly equivalent to one indexed lookup and an indirect jump (i.e. fast enough that you can barely tell the difference on a modern architecture). With this type switch, it's a bit slower, but it's also more flexible: You don't have to change the interface and add the new virtual method when you want to add a function. There's a matrix of possible use cases like this: 1. Open set of types, open set of functions (-virtual,+switch). 2. Open set of types, closed set of functions (+virtual,+switch). 3. Closed set of types, open set of functions (-virtual,+switch). 4. Closed set of types, closed set of functions (+virtual,+switch). As is clear, the switch is clearly more flexible, but I'd be interested to see what the performance characteristics are for each of these use cases between the two. Virtual method dispatch is particularly effective in case 2.
Yeah, just in case anyone didn't get it: In C/C++, this holds: array[index] === index[array] This is because the index notation is actually shorthand for *(array + index) which does the right thing thanks to pointer arithmetic rules (i.e., on the CPU instruction scale it becomes `*(array + index*sizeof(ElementType)`, where `ElementType` is `int` in the above example). Pointer arithmetic addition is commutative — the order doesn't matter, so this has exactly the same result: *(index + array)
Interesting? Yes Did I understand any of it? No And now I'm sad.
&gt;Unlike its state after a “copy“, a moved-from object’s data is no longer present for further use downstream in the program. It’s like when I give you my phone. I don’t make a copy of it and hand it over to you. After I “move” it to you, I’m sh*t outta luck if I want to call my shrink – until I get a new phone. Lovely metaphor :)
We did not play with clang when we were working on it, which is why it does not compile there at the moment. We'll try to look into that soon.
Thanks a lot. I really look forward to the update.
Usually the signal notifying of the connection's closure would be owned by the connection, so the signal would be decommissioned (i.e. destroyed) with the connection right after having been fired, rendering the disconnection unnecessary (and probably more work too, since removing receivers from lists of signal handlers isn't completely free).
I agree that your solution may be appropriate given quite a few assumptions, but the general problem still remains. You often want to connect to a signal waiting for an event to trigger, and once it does you want to disconnect from future updates. The right time to perform that disconnection may very well be within the callback. Anyhow, I certainly don't want to argue in absolute terms. When I write my libraries I tend to prefer to give a degree of flexibility to my users so they can simply use my library without being told what the absolute best way to use it is. I often myself don't know all the ways my library may be used, so convenience for me trumps arguments over how things should be done in an ideal world.
yup. fixed it for the next release. thank you!
Well the real issue is that I don't know how to create a .dat file from another file. So I need to be able to take input and load it onto this simple .dat file. The file will be simply a column or so of numbers. This .dat file is used for later in my program. Thanks for the help!
You want to research "Writing text files" or something similar, you'll find things like the "open" command, and "close".
struct data { int one_info; int two_info; float[4] red_info; float[4] blue_info; }; int main( void ) { FILE* f; f = fopen( "file.dat", "wb" ); if( !f ) { printf( "Failed to open file.\n" ); return 1; } data d; fwrite( &amp;d, sizeof(data), 1, f ); fclose( f ); return 0; } i think that's all you need, plus or minus an include or a function parameter somewhere
Unfortunately it doesn't allow for deserialization directly in the constructor, making it more complicated (in the constructor you have to initialize the fields to "something") and a bit slower (the redundant initialization performed in the constructor).
That is not the same as disconnecting AND emitting signal again. Reentrancy is about calling a signal that is being currently handled (kind of recurrency). Disconnection is otoh rather ususal use-case.
Right you are. Given that the overhead for implementing this (essentially it's a matter of ensuring iterator stability during erase) is quite small, I wouldn't balk at having this feature. :)
The sad part with all this is that C++ tutorials and books teach that 'goto' is harmful but at the same time have examples with the system() call in them. system("pause")... i'm looking at you... ;-( 
Why on earth would you give the C answer on /r/cpp?
Strange to see compiler/standard library benchmark results without any mention of the compiler and version used. There is a comment in the source that hints that gcc might have been the compiler. Also, I can see that the implementation relies on its own hand written data structure utilizing new, delete and plain pointers. Would be interesting to know, if that is necessary or if a more elegant solution could perform as efficient.
We don't know what exactly you need help with. There's no standard format for a .dat file, it could contain anything in any format someone deiced to create that day. And what is your other file, and the relation to the .dat file you talk about, and what are you specifically having trouble with ? Opening the .dat file ? Opening the other file ? Reading from the other file (what do you want to read and what format does this "other" file have ?) , writing to the .dat file (what do you want to write ?). We can't help you with much unless we know what you're doing or having problems with . 
I don't understand. Is it a kind of recursion?
ah, sorry, i thought C++ was a superset of C, so the code would still work. my mistake.
You can do this with the mmap system call if you are on Linux. man 2 mmap
Interesting. So when you do an mprotect() call to mark a page as read only, how does this actually get implemented? I can't imagine that every single write call would then have to look up information in a "write protection" table. That would slow down things significantly. Is there something built into the processor that takes care of this lookup without suffering any penalty? 
Yes, the hardware checks on every write. The CPU has to find your page of virtual memory with a table lookup anyway. That same table usually has flags for write and execute permission as well. It definitely has both on x86. If you try to write to a non-writable page, execute from a non-executable page, or access any page that isn't mapped, then the kernel gets a special interrupt it can handle. Depending on what went wrong, it might just page in memory from disk, or it might kill your process (with SIGSEGV).
In addition to lambdanaut's answer, note the lookup doesn't occur on every memory access, this is what the mystical 'TLB' is in your CPU: a tiny, fast cache that holds recently accessed page table entries in order to stop processing from running like a dog
Cool. What are the columns in the TLB table for x86 CPUs? Clearly there must be a physical address, virtual address, read only flag and executable flag. Anything else? 
Yes, when you call same signal from the handler you will get your handler called recursively again (by that signal). By re-entrancy we mean ability of signal to be called again in the middle of "previous" execution.
I shudder to think what caused you to discover this......
What does this actually do? It's not clear from the article (I confess to being rusty about variadic templates and varargs).
&gt; Conceptually they're the same as C variadics but I strongly advise against saying this. Basically the only similarities between C89-style variadic arguments and C++11 variadic templates are (1) the word "variadic" in their names and (2) the ellipsis in their syntax. Thinking of them as "the same, except for type safety" is dangerous. For example, C89-style variadic arguments trigger the default argument promotions, while C++11 variadic templates don't. In C++, there are severe restrictions on the type of the last normal parameter before a C89-style variadic arguments ellipsis (because of the stack-manipulating macros), while there are no such restrictions for C++11 variadic templates. Also, it is impossible to have two C89-style variadic argument lists in a single function, but it is possible to have two C++11 variadic template function parameter packs in a single function. (Putting a function parameter pack anywhere other than the end is a non-deduced context.)
This do not seem right. There are too many problems that can happen in applications depending on this design. How can the signal handle indirect recursion? Is the correct behaviour ignore the second call, block the handler in the second call or allow the recursion?
Regardless of any protections, the hardware has to do a table lookup on every memory access anyway in order to translate virtual addresses into physical addresses. Memory protection is essentially free once that infrastructure is already in place, which it must be to support any kind of modern operating system. The overhead is pretty minimal because everything happens with the granularity of a page, which is typically 4K, although larger sizes are supported in some circumstances for better performance. This means that when considering an address that an instruction is trying to read or write, the hardware can just lop off the 12 least significant bits of the address, leaving only 20 bits of effective address in a 32 bit system. This is generally implemented as a two-level page table. The first level has 1024 entries, corresponding to the first 10 bits of the address, and then each entry points into a separate list of 1024 entries for the second 10 bits of the address. It's a two step lookup which is relatively efficient, and there is the TLB to cache the recent lookups. For PAE and long mode (x86_64) the page table is extended to 3 or 4 levels, respectively, to cover the additional address range. 
Right, but that's all minor detail ;) A whole new syntax and set of constraints doesn't really push the concept in to an alien world. From a callers perspective they let you write similar code, and overall they try to achieve the same thing.
[Slides are here](http://llvm.org/devmtg/2010-11/Hinnant-libcxx.pdf) (std::sort at slides 44-54) This is from a LLVM dev meeting a while back, and I just recently stumbled upon it. I actually had no idea that libc++'s std::sort recognizes patterns and was quite amazed about this finding.
reminds me about awesome c++11 lambdas: [](){} and we can go deeper: ([](){[](){}();}()); - a legit expression ) 
ok, 20 years as a programmer and I have yet to actually need to sort anything. do you need to work with databases to have any use for sorting?
The parentheses can be omitted if there are no arguments: auto foo = []{}; Leading to: []{}(); []{[]{}();}(); []{[]{[]{}();}();}(); []{[]{[]{[]{}();}();}();}(); 
It looks like a kind of [timsort](https://en.wikipedia.org/wiki/Timsort) but doing only swap so no need of extra memory
A computer science teacher of mine once said that sorting is one of the most fundamental problems that you will encounter over and over. I remember thinking that I couldn't imagine this being true. After I graduated realized he was right, when you have data sets that you build in non-sequential order you want to sort them to be able to search in in them efficiently. Examples: finding objects in 1D/2D/3D space (kd-tree, sweep line algorithm), merging two data sets (merge-sort), etc. Often you do not do the sorting yourself, but use data structures that are ordered, such as sets and maps (binary trees). But that still requires knowledge of sorting to be able to order your own data types properly (lexicographic sorting, not using floats for keys etc.) I would say that sorting and reducing problems to the shortest path algorithm (polynomial algorithm that finds an optimal global solution) have been the most useful and insightful things I learned while studying computer science.
The example you mention is within 3d graphics. My line of work (where I do not need to sort) is 3d graphics so I remain nonplussed. It is a rare occurrence indeed that you need an acceleration structure for the position in 3d space of something, for pathfinding and raytracing sure, but that is not something you come across over and over again. For pathfinding you write it and forget about it (and then only if you are writing a game), for raytracing, well you just dont do it. Its not the kind of thing where you go: "hey bob, can you go fix some stuff with the acceleration structure in our raytracer?". Unless your job is specifically to do these things you are not going to do them. Your second example, merging data into a sorted structure, what line of work requires such a thing?
[....ummm........](http://i.imgur.com/EYXQXRy.jpg)
Isn't std::shared_ptr thread safe? I don't get it
I do backend programming on large scale datasets and I sort stuff all the times. For instance if you need to compute the dot product over a large number of sparse vectors (and their combinations), sorting them saves you tons. That's because you can use simple data structure (i.e. use less RAM) but mostly thanks to the cache bonus.
Only partially, not fully: http://stackoverflow.com/questions/14482830/stdshared-ptr-thread-safety Or, in other words, "shared_ptr objects offer the same level of thread safety as built-in types." // http://gcc.gnu.org/onlinedocs/libstdc++/manual/shared_ptr.html See also: http://stackoverflow.com/questions/9127816/shared-ptr-thread-safety-explained http://stackoverflow.com/questions/441814/fully-thread-safe-shared-ptr-implementation Keeping the "wrapping a mutex and shared_ptr into a convenience class to automate locking" suggestion in mind, take a look: https://github.com/lastfm/libmoost/blob/master/include/moost/safe_shared_ptr.hpp https://github.com/lastfm/libmoost/blob/master/test/safe_shared_ptr/safe_shared_ptr.cpp 
out of curiosity, what kind of programming do you do? Whereas you cannot imagine a kind of programming where you need to sort things, I cannot imagine a kind of programming where you don't need to sort things.
Aww, I was hoping for actual music analysis code.
Yes, with databases of structured textual information I can see it being useful.
Besides failing to overwrite the marked memory, do I get any other advantages? (faster reading? or other performance advantages?)
I would have removed operator-&gt; from that class and only allow access to the pointee through their lock class. Also, get_shared should probably renamed to get_unsafe_shared. :-) The locking in use_count, unique, get_shared, and operator! is also unnecessary -- at least with std::shared_ptr. Maybe boost::shared_ptr makes weaker guarantees. But I don't think so. I believe their swap function invokes undefined behaviour because operator&lt; is not guaranteed to work as expected on pointers that are not from the same array. Instead std::less&lt;pointer_type&gt; should be used for 100% standard compliance. The rest looks fine. 
But you do see I hope that what you are writing here is not at all convincing that sorting is something that is actually used outside of database work?
build-systems need to use topological sorting to function properly, unless your build system doesn't use dependencies, in which case its not much of a build system. Visualizations of ALL kinds are graphics, where he said that makes sense. For example, you might build an 4-D octree (hextree?) out of 3D voxel data by sorting data points by their 4D morton-code representation. Such a tree would dramatically speed up level-of-detail rendering and culling for a large dataset, and also be useful for ray-traced rendering. Android apps don't help me narrow the category down at all, because thats a platform as opposed to a style of programming, but there are a ton of android apps that require sorting. Any time you need to find data in a set of data in less than linear time requires sorting if the data isn't hashable. Sometimes sorting is even required to present things to the user. For example, a shopping app needs to have the option 'sort by price, new, popular, etc.". A video game might need game lobbies to be sorted alphabetically so that a particular server can be found. In linear algebra, calculating the eigen-vectors and eigen-values, which is EXTREMELY useful for pretty much every area of machine learning, requires sorting to order the eigenvalues after they have been computed. Not knowing the order of the eigenvalues makes them much less useful.
"you might build an 4-D octree (hextree?) out of 3D voxel data by sorting data" I have to say after this discussion in this thread I am more convinced then ever that sorting is at best very non-essential and can be safely ignored for most jobs. 
I think you are very much non-persuasive. What you write in no way indicate searching being useful in the day to day life of a programmer. I do indeed work with voxel visualization and all i do is to tell vtk to volume render the data. No sorting needed on my part.
Ok, so you don't actually do graphics programming, you just use someone else's lib. No shame in that, but for actual graphics work its certainly something useful. I guess if you were the sort of programmer who solves problems by stringing together other people's libs and scripts, then I can see how you wouldn't need to use sorting for much. Again, there's no shame in that, but once you move past it to solving algorithmic problems of any kind, sorting is absolutely essential to pretty much everything.
Ok, so you are now so angry that you are jumping to conclusions and being insulting. I reiterate, you are in fact not persuasive.
I'm not angry, nor am I insulting, nor am I meaning to be. If I insulted you, then I'm very sorry, it was not my intent. Like I said, there is absolutely no shame in using libraries and frameworks to program. I do it, everyone does it. You said that nobody uses sorting in 3D graphics, I gave an example how how people actually use sorting in 3D graphics, and you responded "Well, I don't actually do that, I just call the function and they do it for me". Well, ok, so YOU don't use it directly because you don't write that kind of code, but many people don't have the luxury, so they DO write it themselves. Unless you implemented that function, or at least know how it is implemented and know alternate ways to implement it, then you aren't actually writing that algorithm yourself in any sense, you are just calling someone elses code. Again, its not an insult in any way: I don't really know how MySQL works, but I use it sometimes, and this is OK. I don't call myself a 'database programmer' because I don't program databases: I occasionally use someone else's database product lightly, without really understanding how it works internally. My claim is/was that if you were forced to write that code (maybe you didn't have that library available, or maybe it wasn't performing well with cache, or maybe you need to integrate some kind of data that vtk doesn't support, I don't know)...then you would be forced to consider using sorting yourself if you wanted it to be fast. However, since you said you have no interest, and also that you have never needed to sort anything, this leads me to assume that you rarely have to solve those kinds of problems on a regular basis...which means that you probably rarely get down-and-dirty to the scope where those problems exist. By using the tools available at your disposal, (libs and language builtins and frameworks that do that kind of stuff for you) then you can avoid a lot of that stuff. I get it, and I don't see anything wrong with it. It probably makes you a very efficient programmer! But the people who WROTE those things probably use sorting and searching and sets and trees on a REGULAR basis to make them function.
this is just a big block of text without any relevance to anything anyone previously wrote. do you have aspergers?
* You made the claim that sorting is useless, * I offered several cases where it is useful in the problem domains you work on. * You counter-claimed that sorting is still useless, because you don't think my cases were applicable. You said that you don't need to use sorting because you call library functions that do it for you. * That explained it to me, so I said "Oh, I see. That makes sense. Well, it might not be useful to you, but it is really useful to the people who have to write those things and actually solve problems at a lower level" * In response, you said I offended you. * I apologized for offending you, attempted to clarify, which you didn't read. &gt;do you have aspergers? Now who is being insulting? 
How could you possibly be a programmer and never need to sort anything? How do you effienciently retrieve a value from a dataset without first sorting the dataset? What type of programmer are you that requires not to effienciently organize a dataset? I can't think of any type of programmer that wouldn't need to. As a programmer, I am stunned that another programmer would say this. 
How does it render the data? What type of data structure does it use? And what if that library didn't exist? Or what if that library implemented their algorithms inefficiently? You need to understand sorting algorithms if you want to go beyond just using other people's libraries and treating their code as a magical black box.
"How do you effienciently retrieve a value from a dataset without first sorting the dataset?" Vertex *v = mesh.getVertex(selectedVertex);
 Vertex *getVertex(int vertexIndex) { return this-&gt;vertices[vertexIndex]; } 
When finding closeness relationships in an XOR address space (i.e. in a DHT routing table) then sorting is extremely useful. Sort your own routing table to a target to see which is address is closest to the target or in a particular space to see if you are close. In these cases the distance is not measured in any order that's ordered except from the view of the target (you need to see the network from the targets perspective), so sorting from that address is the way to do it (of course this may involve some big int library or some fancy string manipulation for the predicate). There may be another way but I cannot see a more efficient mechanism in this case.
Hmm, so the header files in the starter kit are not self contained (even depend on "using namespace std") and contain "#pragma once"...
That looks like something that would take a bit of time to actually finish.
I put my email in a while back but ever got anything. I assumed it was a joke or e-mail harvesting scam. 
Looks like something that would take a bit of time just to read through. 
Ok but can he at least rage on that comment and the code which follows it, if that code does what the comment implies?
Probably because the class doesn't start until March 1st.
Yeah but you'd expect some kind of acknowledgement when you register your e-mail address, wouldn't you?
These are C++ programmers, not normal people.
This is a quality of implementation issue with libstdc++ and not a C++ issue. The problem is the implementers of the std library tried to reuse the underlying C implementation took a Procrustean approach to the problem. This is not the fault of C++, but rather this particular implementation of the standard c++ library. Saying c++ is a sham in this circumstance is like saying the automobile is a sham after buying a lemon.
What do you mean by 'not self-contained'? If you mean it depends on the C++ standard library, then so what? The compiler doesn't have to implement everything from scratch in the parser, it just has to be able to bootstrap itself using any stdlib implementation. The tokenizer doesn't need to be completely standalone..it can use the host c++ stdlib during bootstrapping OR the one that is implemented by the cppgm
&gt; included in the header file, but in the enclosing cpp. The only time this is appropriate is if a header depends on something IN THE HEADER. In this case, the only thing IPPTokenStream.h depends upon is std::string. I agree this could be (should be) included in the header, but I can let it slide. &gt;Usually the common standard headers (string, vector, etc) are included in a global (precompiled) header along with "using namespace std" for large projects. precompiled header's are not standard C++, and 'using namespace' in a header is considered to be bad practice becuase of namespace pollution.
Very clean, well structured and written code base. Interesting and informative explanations and comments. (eg: class_logger.hpp) This is how C++ should be. ++++ 
Precisely. And of course I am nitpicking here - after all it's a "C++ Grandmaster Certification"
One other thought I had: the FAQ now mentions that the course will run for approximately 12-18 months with a workload of 10 hours/week. That still doesn't sound realistic (not even for the front-end).
Steve132 wasn't being insulting in any way. However, I will be: you have no business being a programmer if you don't understand the relevance and utility of sorting. Furthermore, accusing him of having a developmental disorder is childish and itself insulting to both him and those who do in fact suffer from such disorders.
Collisions against std are incredibly common actually. boost has many collisions, and std uses a lot of short/common names like min/max, find etc... There should definitely not be an exception made for std.
Specifically? I use tcmalloc pretty much every day.
The release notes indicate that the CPU and memory profilers are somewhat fragile on x86_64 platforms: since this is what we use at work, those warnings have kept me away from the tools. On the one hand I suspect that Google also uses x86_64 as their primary platform, so it surprises me that these issues would be there. Then again, perhaps they're so rare Google uses the tools regardless and the big warnings in the README are an abundance of caution and a way to head-off bug reports. 
Don't software developers usually get paid to develop software? Paying some company to develop software for them seems a little backwards.
Presumably the code is for instruction purposes only and they don't get to own it. Besides that, if they wanted a real commercial compiler they could just fork Clang and be done with it. I agree it's a lot of unpaid work, but purely educational things are like that.
IMO this only makes the code harder to read and has no benefits large enough so as to outweigh the costs. Given that code is a write-once &amp; read/maintain-many-times activity, optimizing for not-having-to-write-"std::" the first time is overall suboptimal . When I just want to understand what a piece of code does at a quick glance, I'd rather not have to wonder whether `vector&lt;T&gt;` means: (a) `boost::fusion::vector&lt;T&gt;` (b) `boost::numeric::ublas::vector&lt;T&gt;` (c) `boost::mpl::vector&lt;T&gt;` (d) `boost::container::vector&lt;T&gt;` (e) `std::vector&lt;T&gt;` (f) something else? *It just ain't worth it.*
I use it. And like it much better than dtl. I'd like it even more if it supported bool, and enums. Automatically converting to/from integer on database. 
Found another questionable bit: &gt; Start by drawing a DFA (deterministic finite automaton) for each token type. Recall that a DFA is a directed acyclic graph where the vertexes are states and the edges are code points (or sets of code points). While a DFA can be a DAG, requiring that all DFAs be acyclic is not particularly useful.
Modern idiomatic C++11 or C with classes? After watching the video, that's still my main question. Yes he said something about "generic programming", but even this varies from using simple generic containers to more sophisticated template metaprogramming.
Thanks, signed up!
Well I was using today's work as an example, I should have been more clear. I mean to say that I can read about programming, and learn the different methods and functions of C++, but when it comes to writing a program to use them, I can manage a shell of the what I want to get done, but I can't seem to see the way to implement it. Is that clearer?
its perfectly clear, but its hard to pinpoint where you're messing up without an example. If you type out the logic for the problem you mentioned (as an example) We can guide you through the steps needed. 
It's all about practice, write lots of code AND read lots of code. C++ is not any language to "get things done" when you are new to it. Stick at it.
(This will be a multi-part comment, due to reddit length limitations.) I'm a professional C++ programmer, but I can't remember ever having implemented the Towers of Hanoi. I'm not especially convinced it's a good problem for beginning programmers. But I taught myself C++ by writing a data compressor, so perhaps my perspective is somewhat unusual. So I just implemented this, and I'll walk you through my thought processes. Then you should put my solution away, and write your own (e.g. implement one of the iterative solutions explained on Wikipedia). The way I see it, if you wanted to be unethical, there are already thousands of implementations on the Internet you could unthinkingly copy, but if you're ethical (as you appear to be) and just need a little help, guided explanations from programmers who know what they're doing are very hard to find. First, of course, we need a compiler. You've got whatever one you're using (possibly something horribly ancient that your school makes you use), and I've got [my own build of GCC](http://nuwen.net/mingw.html) to use at home, modified to default to C++11. I'll use C++11 things in a couple of places to make my life easier, although nothing complicated. I'll explain what I wrote, in the order that I wrote it. First, include directives and a using-directive: #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; I included &lt;iostream&gt; because I knew I'd have to print stuff. I included &lt;vector&gt; after thinking about what data structures I'd want to use - the towers are stacks (disks are added/removed from the top only) which I could include &lt;stack&gt; for, but I quickly realized that I'd want to print all of the elements at once, so I'd better use a vector. More on this in a bit. Slightly later I went back and added an include for &lt;string&gt; because my print function could use that for convenience. (I'll use C-style const char * when necessary, but std::string is better.) About those data structures. This is one of the most important choices when solving any problem - choose the right data structures and your problems can almost solve themselves. C++ and in particular the STL is wonderful because it provides so many data structures and they are *extremely* composable (do you want a map with string keys and vector&lt;int&gt; values? Go for it!). The STL's data structure of first resort (the one you should use when you have no particular preference) is the vector: it is an extremely powerful sequence container and is extremely fast. We can view each peg in the Towers of Hanoi as a sequence of disks, with the bottom at one end and the top at the other. In fact, we can view the three-peg setup as a vector of three vectors of disks. This will actually come in handy, if you've already looked at Wikipedia's algorithm. Now, we also need to choose something to represent each disk with. The simplest choice is an int, representing the disk's weight (10 is heavy, 1 is light). I did all of that thinking while writing my include directives. Now I need to build some infrastructure. Good things to start with are functions that print your data structures. (I am not an advocate of relying on graphical debuggers, especially when learning how to program. I find that thinking about code carefully, and having your programs print detailed information so you can follow what they're doing, leads to deeper understanding.) void print(const string&amp; s, const vector&lt;int&gt;&amp; peg) { cout &lt;&lt; s; for (auto&amp; disk : peg) { cout &lt;&lt; disk &lt;&lt; " "; } } This function is for printing a single peg. It takes a string so I can label the peg, then it prints each element of the peg. I used a C++11 range-based for-loop (with auto&amp; which should always be used by default), but there are lots of other ways I could have printed each element. void print(const vector&lt;vector&lt;int&gt;&gt;&amp; pegs) { print("X: ", pegs[0]); print("Y: ", pegs[1]); print("Z: ", pegs[2]); } Then I wrote this function to print all three pegs at once. Having the single-peg printer (I used overloading, calling both print()) allowed me to avoid writing redundant code. Here you can see that my "pegs" data structure is a vector&lt;vector&lt;int&gt;&gt;, as promised. I am labeling each fixed peg as X, Y, and Z in that order (because the disks are numbers). I actually went back and changed stuff here. I started off labeling each peg as A, B, C, but then realized that Wikipedia's algorithm relabels pegs as it goes. So I gave the pegs "absolute" names of X, Y, and Z to avoid confusion. I also went back and forth on whether this function should print an endl (newline). Eventually I removed it, because I wanted to print stuff after this on the same line. Finally, although I hadn't actually implemented the algorithm yet, I wrote a program to test my printers: int main() { vector&lt;vector&lt;int&gt;&gt; pegs = { { 5, 4, 3, 2, 1 }, { }, { }, }; print(pegs); } Here I am using C++11 initializer lists to easily initialize my vector of vectors of ints. Each vector&lt;int&gt; starts off with the "bottom" containing the heaviest disks, and ends with the lightest disks. All the disks start, in heaviest-to-lightest order, on the first peg (peg X, at index 0). This prints: X: 5 4 3 2 1 Y: Z: (without a newline at the end, but that's okay). Now, I could have done more and better stuff here. It probably would have been a good idea to add paranoid checks for the vector&lt;vector&lt;int&gt;&gt; containing exactly 3 vector&lt;int&gt;s, and more checks for the disks to be in heaviest-to-lightest order (the C++11 STL's is_sorted() would be useful). These would be good ideas to detect programmer errors - if you corrupt your data structures (i.e. end up storing things that don't follow the rules you've set), you want to know about it as early and loudly as possible. Satisfied that I had correctly written printing functions, I then went to implement the algorithm. My reference was [Wikipedia's recursive solution](http://en.wikipedia.org/wiki/Tower_of_Hanoi#Recursive_solution), which of course I had heard of, but looking it up is easier than deriving it from first principles. When I write code, I tend to write it bottom-up: writing tiny helper functions first, then building them into larger functions, and then into functions that do real work, and finally calling them from test programs. Top-down code (writing code that calls stuff before it's been implemented) makes me a little uncomfortable because as I implement the helpers I might decide that a different interface is better, and I'd have to go change the code I've already written that "called" it. Programmers differ in technique here, but this is mine (and while I am far from the fastest programmer, I consider myself very good at writing code that works correctly on the first try). So I started writing the signature for my solver, before a main() to call it. Initially I took the pegs as the first argument, but later I put the pegs at the end, purely to mirror how I was printing them: void solve(const int a, const int b, const int c, const int n, vector&lt;vector&lt;int&gt;&gt;&amp; pegs) { cout &lt;&lt; "A=" &lt;&lt; a &lt;&lt; " B=" &lt;&lt; b &lt;&lt; " C=" &lt;&lt; c &lt;&lt; " N=" &lt;&lt; n &lt;&lt; " "; print(pegs); cout &lt;&lt; "Start!" &lt;&lt; endl; This defines the "interface" to solve() and is worth exploring in detail. The pegs data structure we've already seen. I am going to be modifying it (moving disks around!) so I am taking it by modifiable reference. (I don't want to copy the pegs, I want to work on them in-place.) Then I take a bunch of ints, all by const value because I'm paranoid and don't want to accidentally change them. The ints a, b, c are the *indices* of the A, B, and C pegs in Wikipedia's algorithm. Wikipedia says that the labels may move at different steps, and they sure do. The "absolute" names of my pegs, as displayed in the printer, are X for index 0, Y for index 1, and Z for index 2. But in solve(), a is the index of peg A, which could be 0, 1, or 2. b is the index of peg B, which could also be 0, 1, or 2, and same for c. Now, if I were being extremely careful, I should have written a check right here, verifying that a, b, and c are a permutation of 0, 1, and 2 (no repeats, no other numbers). I didn't, because I assumed I could get away with it, what with being a professional programmer (and I was right). As a beginner (or any skill level in production code!) you should not take such shortcuts. I also take n, the number of disks to move. Note that Wikipedia is specifying an algorithm with words and not code, while I am translating that into a signature in code (and trying to follow Wikipedia's wording, in order to avoid confusion). To show that I'm actually doing stuff, I print out the inputs to my function before I do anything, and the current state of the pegs. If my program misbehaved, I was prepared to inspect this carefully to see where I went wrong. Now I need to do actual work. The easiest work is nothing: if (n == 0) { return; // Nothing to do! } This is my "base case". (Some programmers would choose 1 as the base case, but 0 is superior. Again, I should have added a check to make sure I'm never asked to move negative numbers of disks.) I could have printed out "No work to do!" or something, but because I already printed out the inputs, N=0 makes it obvious that nothing will happen for this step.
This emits the following: A=0 B=1 C=2 N=5 X: 5 4 3 2 1 Y: Z: Start! A=0 B=2 C=1 N=4 X: 5 4 3 2 1 Y: Z: Start! A=0 B=1 C=2 N=3 X: 5 4 3 2 1 Y: Z: Start! A=0 B=2 C=1 N=2 X: 5 4 3 2 1 Y: Z: Start! A=0 B=1 C=2 N=1 X: 5 4 3 2 1 Y: Z: Start! A=0 B=2 C=1 N=0 X: 5 4 3 2 1 Y: Z: Start! A=0 B=1 C=2 N=1 X: 5 4 3 2 Y: Z: 1 Moved disk from A to C. A=1 B=0 C=2 N=0 X: 5 4 3 2 Y: Z: 1 Start! A=0 B=2 C=1 N=2 X: 5 4 3 Y: 2 Z: 1 Moved disk from A to C. A=2 B=0 C=1 N=1 X: 5 4 3 Y: 2 Z: 1 Start! A=2 B=1 C=0 N=0 X: 5 4 3 Y: 2 Z: 1 Start! A=2 B=0 C=1 N=1 X: 5 4 3 Y: 2 1 Z: Moved disk from A to C. A=0 B=2 C=1 N=0 X: 5 4 3 Y: 2 1 Z: Start! A=0 B=1 C=2 N=3 X: 5 4 Y: 2 1 Z: 3 Moved disk from A to C. A=1 B=0 C=2 N=2 X: 5 4 Y: 2 1 Z: 3 Start! A=1 B=2 C=0 N=1 X: 5 4 Y: 2 1 Z: 3 Start! A=1 B=0 C=2 N=0 X: 5 4 Y: 2 1 Z: 3 Start! A=1 B=2 C=0 N=1 X: 5 4 1 Y: 2 Z: 3 Moved disk from A to C. A=2 B=1 C=0 N=0 X: 5 4 1 Y: 2 Z: 3 Start! A=1 B=0 C=2 N=2 X: 5 4 1 Y: Z: 3 2 Moved disk from A to C. A=0 B=1 C=2 N=1 X: 5 4 1 Y: Z: 3 2 Start! A=0 B=2 C=1 N=0 X: 5 4 1 Y: Z: 3 2 Start! A=0 B=1 C=2 N=1 X: 5 4 Y: Z: 3 2 1 Moved disk from A to C. A=1 B=0 C=2 N=0 X: 5 4 Y: Z: 3 2 1 Start! A=0 B=2 C=1 N=4 X: 5 Y: 4 Z: 3 2 1 Moved disk from A to C. A=2 B=0 C=1 N=3 X: 5 Y: 4 Z: 3 2 1 Start! A=2 B=1 C=0 N=2 X: 5 Y: 4 Z: 3 2 1 Start! A=2 B=0 C=1 N=1 X: 5 Y: 4 Z: 3 2 1 Start! A=2 B=1 C=0 N=0 X: 5 Y: 4 Z: 3 2 1 Start! A=2 B=0 C=1 N=1 X: 5 Y: 4 1 Z: 3 2 Moved disk from A to C. A=0 B=2 C=1 N=0 X: 5 Y: 4 1 Z: 3 2 Start! A=2 B=1 C=0 N=2 X: 5 2 Y: 4 1 Z: 3 Moved disk from A to C. A=1 B=2 C=0 N=1 X: 5 2 Y: 4 1 Z: 3 Start! A=1 B=0 C=2 N=0 X: 5 2 Y: 4 1 Z: 3 Start! A=1 B=2 C=0 N=1 X: 5 2 1 Y: 4 Z: 3 Moved disk from A to C. A=2 B=1 C=0 N=0 X: 5 2 1 Y: 4 Z: 3 Start! A=2 B=0 C=1 N=3 X: 5 2 1 Y: 4 3 Z: Moved disk from A to C. A=0 B=2 C=1 N=2 X: 5 2 1 Y: 4 3 Z: Start! A=0 B=1 C=2 N=1 X: 5 2 1 Y: 4 3 Z: Start! A=0 B=2 C=1 N=0 X: 5 2 1 Y: 4 3 Z: Start! A=0 B=1 C=2 N=1 X: 5 2 Y: 4 3 Z: 1 Moved disk from A to C. A=1 B=0 C=2 N=0 X: 5 2 Y: 4 3 Z: 1 Start! A=0 B=2 C=1 N=2 X: 5 Y: 4 3 2 Z: 1 Moved disk from A to C. A=2 B=0 C=1 N=1 X: 5 Y: 4 3 2 Z: 1 Start! A=2 B=1 C=0 N=0 X: 5 Y: 4 3 2 Z: 1 Start! A=2 B=0 C=1 N=1 X: 5 Y: 4 3 2 1 Z: Moved disk from A to C. A=0 B=2 C=1 N=0 X: 5 Y: 4 3 2 1 Z: Start! A=0 B=1 C=2 N=5 X: Y: 4 3 2 1 Z: 5 Moved disk from A to C. A=1 B=0 C=2 N=4 X: Y: 4 3 2 1 Z: 5 Start! A=1 B=2 C=0 N=3 X: Y: 4 3 2 1 Z: 5 Start! A=1 B=0 C=2 N=2 X: Y: 4 3 2 1 Z: 5 Start! A=1 B=2 C=0 N=1 X: Y: 4 3 2 1 Z: 5 Start! A=1 B=0 C=2 N=0 X: Y: 4 3 2 1 Z: 5 Start! A=1 B=2 C=0 N=1 X: 1 Y: 4 3 2 Z: 5 Moved disk from A to C. A=2 B=1 C=0 N=0 X: 1 Y: 4 3 2 Z: 5 Start! A=1 B=0 C=2 N=2 X: 1 Y: 4 3 Z: 5 2 Moved disk from A to C. A=0 B=1 C=2 N=1 X: 1 Y: 4 3 Z: 5 2 Start! A=0 B=2 C=1 N=0 X: 1 Y: 4 3 Z: 5 2 Start! A=0 B=1 C=2 N=1 X: Y: 4 3 Z: 5 2 1 Moved disk from A to C. A=1 B=0 C=2 N=0 X: Y: 4 3 Z: 5 2 1 Start! A=1 B=2 C=0 N=3 X: 3 Y: 4 Z: 5 2 1 Moved disk from A to C. A=2 B=1 C=0 N=2 X: 3 Y: 4 Z: 5 2 1 Start! A=2 B=0 C=1 N=1 X: 3 Y: 4 Z: 5 2 1 Start! A=2 B=1 C=0 N=0 X: 3 Y: 4 Z: 5 2 1 Start! A=2 B=0 C=1 N=1 X: 3 Y: 4 1 Z: 5 2 Moved disk from A to C. A=0 B=2 C=1 N=0 X: 3 Y: 4 1 Z: 5 2 Start! A=2 B=1 C=0 N=2 X: 3 2 Y: 4 1 Z: 5 Moved disk from A to C. A=1 B=2 C=0 N=1 X: 3 2 Y: 4 1 Z: 5 Start! A=1 B=0 C=2 N=0 X: 3 2 Y: 4 1 Z: 5 Start! A=1 B=2 C=0 N=1 X: 3 2 1 Y: 4 Z: 5 Moved disk from A to C. A=2 B=1 C=0 N=0 X: 3 2 1 Y: 4 Z: 5 Start! A=1 B=0 C=2 N=4 X: 3 2 1 Y: Z: 5 4 Moved disk from A to C. A=0 B=1 C=2 N=3 X: 3 2 1 Y: Z: 5 4 Start! A=0 B=2 C=1 N=2 X: 3 2 1 Y: Z: 5 4 Start! A=0 B=1 C=2 N=1 X: 3 2 1 Y: Z: 5 4 Start! A=0 B=2 C=1 N=0 X: 3 2 1 Y: Z: 5 4 Start! A=0 B=1 C=2 N=1 X: 3 2 Y: Z: 5 4 1 Moved disk from A to C. A=1 B=0 C=2 N=0 X: 3 2 Y: Z: 5 4 1 Start! A=0 B=2 C=1 N=2 X: 3 Y: 2 Z: 5 4 1 Moved disk from A to C. A=2 B=0 C=1 N=1 X: 3 Y: 2 Z: 5 4 1 Start! A=2 B=1 C=0 N=0 X: 3 Y: 2 Z: 5 4 1 Start! A=2 B=0 C=1 N=1 X: 3 Y: 2 1 Z: 5 4 Moved disk from A to C. A=0 B=2 C=1 N=0 X: 3 Y: 2 1 Z: 5 4 Start! A=0 B=1 C=2 N=3 X: Y: 2 1 Z: 5 4 3 Moved disk from A to C. A=1 B=0 C=2 N=2 X: Y: 2 1 Z: 5 4 3 Start! A=1 B=2 C=0 N=1 X: Y: 2 1 Z: 5 4 3 Start! A=1 B=0 C=2 N=0 X: Y: 2 1 Z: 5 4 3 Start! A=1 B=2 C=0 N=1 X: 1 Y: 2 Z: 5 4 3 Moved disk from A to C. A=2 B=1 C=0 N=0 X: 1 Y: 2 Z: 5 4 3 Start! A=1 B=0 C=2 N=2 X: 1 Y: Z: 5 4 3 2 Moved disk from A to C. A=0 B=1 C=2 N=1 X: 1 Y: Z: 5 4 3 2 Start! A=0 B=2 C=1 N=0 X: 1 Y: Z: 5 4 3 2 Start! A=0 B=1 C=2 N=1 X: Y: Z: 5 4 3 2 1 Moved disk from A to C. A=1 B=0 C=2 N=0 X: Y: Z: 5 4 3 2 1 Start! Done! Here you can watch the disks being moved, always following the Hanoi rules (I sure hope I haven't screwed up). I printed the state at the beginning of every recursive call, instead of just when a disk is moved, so you can follow the recursion somewhat more easily. (Indentation would have made it even clearer, at the cost of additional complexity.) Hope that helps.
You're welcome. VS 2010's not bad (2012 would be better, of course). It's the places using ancient stuff like 2005, or worse VC6, that make me shudder.
Honest question (not a complaint): Why are inheriting constructors not in sight to be implemented?
Thanks for sharing. I have two questions for anyone who already did a coursera course: * What experiences did with coursera courses in general did you make? Are they well organized? Is the time estimation (x hours/week) realistic? * It is difficult for me to estimate the degree of familiarity of coursera in my country. Besides doing this (or other courses) for the fun of it, i'd like to keep the option to use my coursera certificate for (job/scholarship) applications (just to show: hey, i've done that, i am dedicated and whatnot). For what purpose did you use your certificate? What reactions did you experience?
"NO" in that table means "not yet", not "not ever". The table contains the version numbers for the releases that first had support for a feature, or "SVN" if it was not released yet. So this is not a roadmap, this is a "status" page. Here is the actual link instead of a screenshot: http://clang.llvm.org/cxx_status.html (I have no idea why Phoronix doesn't link to it).
(I'm a linux guy, I don't know how true what I'm saying is for win32) When you call new (or malloc) The OS is not handling individual chunks. The only OS systemcall for memory is brk, which changes the size of heap available. Allocation within the heap is managed by your implementation of malloc, provided (usually) by your libc. Different libc's use different allocators. Some *are* better than others. For example you may be able to get some benefit for little cost from using [tcmalloc](http://goog-perftools.sourceforge.net/doc/tcmalloc.html), a highly regarded allocator. Also knowing application specific info *can* make more efficient memory usage, not just because of speed of allocation and fragmentation but because you can have better cache usage. This is usually done by allocating a large block and laying stuff out inside that, rather than using a different allocator. However dicking around with this stuff is *hard* (as in hope you have some PhDs on the team). I would only go down this route if cachegrind says you have big cache efficiency problem, or you have some pathological memory usage that is killing malloc. i.e. serious evidence needed!
Allocating memory using a generic malloc is one of the slowest things a program can do. If this custom allocator is also a generic malloc, it could well be not that great. However, if it's actually a pool allocator or some other form of allocator designed for a specific memory allocation case, it can greatly improve performance. I have personally had cases where moving from raw new to placement new with a pool allocator gives ~10x performance increase. In general I don't use malloc for allocations that I expect to happen often and that have a lifetime bound to a single object.
What makes the default malloc (or c++'s new) so slow?
Research more into what the OS actually does to allocate you some memory -- it's a lot of work. If you have an in-app allocator you can special-purpose it to your application, and if nothing else save you a costly context switch into the kernel.
It's designed to handle all memory allocation cases, thus it makes trade offs. For example you have to be able to have memory allocations that will last a long time and allocations that will be freed very soon next to each other. You also have to deal with allocating on one thread and freeing in another (most allocators now use thread local heaps, implementations used to just lock the entire heap for allocation and deallocation). They must do all this while keeping fragmentation and waste low. This takes a lot of bookkeeping. Custom allocators don't have to do all this, as you know the exact case it will be used in. Taking a pool allocator as an example. Allocation is just a simple pointer addition with a check to see if you need to allocate a new page.
Pools like this are common in IO applications which often need a fixed-size buffer; implementing a free list can reduce the common cost of allocation to a few interlocked CPU instructions. 
&gt;What experiences did with coursera courses in general did you make? I'm doing the Algorithms I course, took a look at others too. Now, the professor of this specific course (C++ for C programmers) is known to have co-authored a thrash book about C++. So, it remains to be seen if the quality of his course will differ from the book. &gt; Are they well organized? The organization depends of the course, some teachers organize them well others not so much... The Algorithms one is a great one, and I find it well organized. I think the Udacity course platform has a better web structure overall, but less content in the courses. &gt; Is the time estimation (x hours/week) realistic? Yes, in general it's at-least the hours specified, and sometimes even more... The courses are, in my opinion, deeper/harder than the Udacity ones. &gt; For what purpose did you use your certificate? Nothing right now, I'm doing them for fun/learning. But both Udacity and Coursera are working on being more certificated. They both put success history's of students that got jobs thanks to their courses. In my country (Brazil) I think that the certificate will, at-most, serve as a technical course.
Really you shouldnt mix reference semantics and value semantics. Comparison is something of value semantics, but inheritance creates reference semantics. However, c++ is powerful enough language that you can do polymorphism with either value or reference semantics, so there is no need to mix the two.
Clang does not require patches to libstdc++ to work with it.
Kind of, Apple has a custom language (with two fully open source implementations) for interacting with their UI and other systems. There is ObjectiveC and ObjectiveC++, which is basically the smalltalk object model bolted onto C and C++. The difference is that Objective{C,C++} doesn't try to pretend it's C or C++.
Fair enough, though (and I know this is extra work so again I am not complaining) it would have been nice to get more specifics about its status from that page.
&gt; but i know too little to make an accurate judgement As always: make a test! Just temporarily replace your custom memory allocator with the default OS, operator new, malloc or even VirtualAlloc. If there is no significant performance benefit, then it's indeed the common NIH. Personally I've never seen the default C++ allocator, operator new, as a bottle neck in any program. Whether a custom allocator could speedup your application can also be determined by a test: Just create the fastest allocator possible - make it allocate some big junk, like 500 MB, then serve memory requests without bothering to release. If this makes your app faster, then this is a reason to roll your own allocator - but as mentioned, I've yet to see a case where this increases overall application speed except for a few percent. 
That's right, patches are no longer required - to clarify, clang worked around some problems with libstdc++ in 3.2.
You will either need to use your OS's sockets API, or use a 3rd party library like libcurl or boost.
The C++ standard library does not have support for sockets. There is [boost.asio](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio.html). But if you want to talk between different processes on the same machine, have you considered using [pipes](https://en.wikipedia.org/wiki/Named_pipe) instead? They are the standard way for inter-process communications. 
I want to use sockets because the java server is running on my mobile phone and there is the easy way to forward socket ports from an android device to a pc when it's connected by usb.
If you want to use low-level sockets, instead of a higher level wrapper, read [Beej's Guide to Network Programming](http://www.beej.us/guide/bgnet/)
Is not the http://www.linuxhowtos.org/C_C++/socket.htm tutorial about sockets? Leonid
Discussion at /r/programming: http://www.reddit.com/r/programming/comments/193o4p/the_dark_side_of_c_pdf_you_lucky_firefox_19_users/ tl;dr: this is a 6 year old document written by somebody who picked up C++ during one of its largest periods of standardization and change, and in many points is not relevant to C++11.
[listener.c](http://beej.us/guide/bgnet/examples/listener.c) [talker.c](http://beej.us/guide/bgnet/examples/talker.c)
This is the document you get if you follow the "C++ Bashing" link from the author's homepage. So, take it with a grainof salt. There's lots of overdramatization in there and a couple of errors as well.
Yeah, this was bogus in 2007 with respect to C++98/03 and it's even more bogus in 2013 with respect to C++11. Here is one example of a howling mistake: Slide 19 claims that an iterator can be invalidated if it pointed into a "balanced tree after rebalance". This is wrongity wrong. map/multimap/set/multiset (the tree containers) preserve all iterators during insertion and erasure (except obviously to erased elements themselves). Rebalancing relinks nodes, but the nodes themselves do not move. Therefore, the tree containers offer the highest level of iterator invalidation guarantees, just like list does. It is actually amazing how terrible these arguments are. Slide 20 apparently bashes vector op[] for not bounds checking in release. That's the whole point; it is actually at() that is the abomination. (If you're passing indices to a vector, you should be absolutely sure that they're valid. With good implementations, op[] does debug checks, but in release mode you want zero overhead.)
A lot of this goes away with reasonable coding standards/practices. The bit about "what namespace is baz in?" is a good example of why I wouldn't ever use "using namespace *" in a substantial program. Perhaps it's bad that C++ gives you the option to shoot yourself in the foot, but there are certainly cases when I'm trying something quick and dirty and it makes life simpler. That doesn't mean it's good practice. And maybe it's because I come from a Python background, but I consider the fact that the map [] operator inserts if no such element exists to be a feature, not a wart.
If you are completely uninterested in how sockets actually work at a lowish level, and just want to use some C/C++ sockets. You should check out libraries that wrap it all up for you. I really like this one: [ZeroMq](http://www.zeromq.org/)
There are too much arguments repeated and not all of them are really bad features. He cites iterators as a bad point, for example. But what if we didn't have iterators? What could be better? Ranges? I don't know if ranges are always better, but I do know that ranges can be created on top of iterators. He complains about the initialization order, but he don't seem to know why this initialization order was chosen. &gt; [...] then bar could be a virtual function. Which one is actually called? Is he insane? You do **not** want to know what is being called, you just want to know that **something** obeying a contract will be called. This is the whole purpose of OO polymorphism.
The only thing I really want from Java is the ability to have a template parameter have certain properties simple to specify. This is a great start.
I would go with ZMQ as well except that there is one catch: ZMQ has a small protocol on top. so If OP needs to read raw bytes from a writing socket then ZMQ is not the right way to go. If however the OP has control over the two endpoints and wants simple communication, ZMQ is the _best_ 
Java generics already have [bounded type parameters](http://docs.oracle.com/javase/tutorial/java/generics/bounded.html), though it may not be exactly to your satisfaction.
That is what I was talking about that I like in Java.
Lots of things: * System call overhead - context switching from the currently running process into the OS * All purpose allocator - can't make assumptions like "this is a small allocation" or "we'll be doing several allocations of this size in a row" or "this is a very temporary allocation". We have to handle fragmentation and very large allocations... not easy! * Even after you've got the memory, if you're doing lots of small allocations it's probably not laid out in a cache friendly manner That said, you're right to be skeptical. Malloc on most modern operating systems provides a *lot* of nice to have features, especially in debug where it will detect common errors (double free, memory leak tracking facilities via valgrind or whatever). It also only gets harder to implement a good (read: fast) allocator as machines get more complicated. If you're running in a multithreaded environment you're better off using Hoard than writing your own and if you're just addressing a performance problem you're better off just correcting the algorithm in question so that it does not call malloc at all (rather than reimplementing the whole memory system).
Oh I misunderstood. I read "want from Java" as something you wanted Java to give you, not as "want [C++ to have that] Java [already has]", and thought you were unfamiliar with the bounded parameters. My mistake.
Inheriting constructors were just about the last thing added to GCC as well. Out of curiosity, is it because this feature is simply not that desirable, or is there a fundamental implementation difficulty (perhaps compared to the perceived value) ?
I want to say one more metathing, and that's that the _business case_ for a custom memory allocator is almost always not there. "This system uses a custom C++ memory allocator" is not a particular selling point on its own. Yes, you might get somewhat better memory usage or a somewhat faster program this way, but that's generally not what your customers are interested in - as long as your program is usable they are interested in features and reliability. Far too much time is spent in what I call "worshipping the computer" - fancying things up that only the programmers really care about. Features and reliability, that's all you really should care about. "Using less memory" or "running faster" isn't really a feature unless you're using _a lot_ less memory or running _a lot_ faster.
Say "Bar" rather than Bar::Bar.
I like it. Simple and easy to implement.
i used beej's guide just last week. was great. 
Bar is the class, not Bar::Bar, though that may work in some instances.
There was a question if it was even implementable as worded. A major issue was variadic functions. Just search http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html for inheriting constru to see some of the issues and resolutions. This is one of the major problems with adding features to the language that have never been implemented before.
Why would you use a compiler so ancient?
You can compile your own compiler. 
When you're a beginner, it's not obvious that tools, libraries, and languages are evolving things - but they are, and it's important to use the latest ones (it'll save you lots of headaches). The age of your hardware is not especially important, except for the speed of compilation. If you're using the latest version of a compiler (e.g. GCC 4.7, VS 2012), great. In particular, you should be using the latest patchlevel (e.g. GCC 4.7.2, VS 2012 Update 1) although that is not as important. If you're using one before the latest version (e.g. GCC 4.6, VS 2010), that's okay, but you should upgrade soon. Anything older is an abomination. In this case, GCC 4.0 was released in April 2005 (and 4.0.1 on July 2005 with minor bugfixes). That's *8 years ago*, an eternity in the computer world. It had essentially no support for C++11 (then known as C++0x).
But producing an stl is part of the work required so when your compiler compiles your compiler its all your code
The sad thing is that it might only come in C++17, who knows if it will still matter?
The second notable attempt to embed documentation into source code. The first one was with 'throws' (turned to be of little real life coding use). Now its 'requires'... Also I much prefer the declarative form of the earlier concept proposals. Now it looks more chaotic and sluggish.
At least a study group for reflection (SG7) has been created at the Oct 2012 meeting - see http://isocpp.org/std/the-committee
There will always look similar. But any feature Java may have that is worth having will do it better and more.
`Bar::Bar` implies that class Bar is in namespace Bar, or that you're referring a member of class Bar called Bar, or that Bar is a nested class inside Bar. In the cpp for Bar you'll want to refer to functions as `Bar::myMemberFn()`, because they're inside the Bar class, but the type Bar itself is just Bar.
Wikipedia will give you a good overview of what has been added: http://en.wikipedia.org/wiki/C%2B%2B11 this reference has a good doc for all the library additions. http://cppreference.com Bjarne Stroustrup (Language originator) has a FAQ on the matter: http://www.stroustrup.com/C++11FAQ.html
I found the c++11 cheat sheet surprisingly helpful. Of course, it pays to know wtf is talking about there so reading a book or two will surely help. But, as cheat sheets go, this is a great one: Blog article link: http://isocpp.org/blog/2012/12/c11-a-cheat-sheet-alex-sinyakov PDF itself: http://j.mp/cpp11ref 
For the record, the way forward for this guy, considering he's using a Macbook, is to download a recent version of Xcode from Apple's Developer site, which includes Clang, the preferred compiler for OS X.
Take a look at the following lecture series by STL http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Standard-Template-Library-STL-/C9-Lectures-Introduction-to-STL-with-Stephan-T-Lavavej http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Advanced-STL http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C- For something you can read as an intro look at Stroustrup Tour of C++ http://isocpp.org/tour If you are interested in the new variadic templates added to C++11, the best overview is Alexandrescu's (of Modern C++ Design fame) presentation Variadic templates are funadic http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Variadic-Templates-are-Funadic
Ah. SIGSEGV. The beginning programmer's "Boy, you screwed up real good now."
That's him. See the link he posted to that same site for his GCC build.
What sort of project are you most interested in? I'm working on an open-source C++ 3D CAD library (https://bitbucket.org/ianmackenzie/opensolid) and I have no lack of things on the to-do list, if you're interested. It's really just me, though, not a big collaborative open-source project yet =) Otherwise, random thought but KDE might be a good choice - it's a large enough project that it shouldn't be too hard to find a little corner where you can usefully contribute, and I seem to remember the source being fairly readable (at some point several years back I hacked the screensaver code a bit to play more nicely with my dual-monitor setup, but that was just for my own use).
Strictly speaking, if someone is using my True Name and linking to my site, that doesn't prove they're me. Someone could impersonate me on a service I don't use (e.g. Twitter) that way. However, if someone is _additionally_ willing to write a 20 KB explanation like the one above, in my style, with my level of knowledge, they are welcome to impersonate me whenever and wherever they want (in fact, they should contact me about job opportunities).
Here is a complete, single list of my video lectures: http://blogs.msdn.com/b/vcblog/archive/2013/02/07/do-while-casts-odr-variadic-templates-core-c-part-8.aspx I try to write a post like this every once in a while just so I can have a single link to give to people when they ask.
If you're interested in C++11 and websockets and async code here's my shameless plug: https://github.com/matthewaveryusa/averyws I'm basically re-implementing a websocket server from scratch with access control and permissioning baked in. The backend is catered to distributing the data to any 'dealer'. My test code uses zmq but that's not locked in thanks to the power of inheritance. I'm currently making it conform to the RFC (hopefully by the end of this week) The project is one month old and there are a lot of core things to do as well as low hanging fruit. I'm also very open to spending time to explain things and I think I take criticism moderately well :)
If you're interested in compilers, join [Clang](http://clang.llvm.org/) and help make C++ better! Plus you could work with surprisingly neat C++ type tricks, learn the fifth use of the `static` keyword, and have your code reviewed (and eventually accepted) by wickedly smart and friendly people.
Lots of projects are awaiting you! http://code.google.com/soc/ http://www.google-melange.com/gsoc/homepage/google/gsoc2013 Short: there are many open source projects and Google is putting people, mostly students, for about half a year for improvements on them. Even if you don't take part in the GSoC those projects still are the ones you want to look at. E.g. a list from last year: http://www.google-melange.com/gsoc/projects/list/google/gsoc2012 My current favorite: http://www.blender.org/development/ It is a program for "modeling - shading - animation - rendering - compositing - interactive 3d - games". It has a gameengine in it. And that one needs lots of improvements.
http://www.cplusplus.com/reference/
Iso CPP is a great sight for resources and links to helpful blogs and articles. [http://isocpp.org](http://isocpp.org) I also really like the C++ Faq website. Its what got me started in wanting to learn more and it helped immensely: [http://www.parashift.com/c++-faq-lite/index.html](http://www.parashift.com/c++-faq-lite/index.html) 
There are five uses of static? I can only think of three...
Haha, that's true :) I merely thought that more_exercise wanted to rule out someone else who's called STL, not someone impersonating you, though.
See http://openhatch.org
Maybe the interviewer was trying to see if you were familiar with the problem that occurs when you have static objects with non-trivial constructors, i.e. a bunch of code that runs before `main()` in no specified order (other than file order.) 
If our wikis weren't down, I'd tell you to go look for a mentor here: http://community.kde.org/Getinvolved/development
Could also potentially be referring to using a static member function to call a protected/private constructor. I must admit, I don't recall what this technique is called.
Sockets is a software stack concept, not an on-the-wire concept. Just like you can have a host application written in Java talk with host application written in C, you can talk socket to non-socket. You can't look at what a host writes to the wire and determine whether or not it is communicating through a socket library or some other network library. There is no particular reason not to use a socket library, if that is what you are comfortable with, but you don't need to use a socket library just because the server is using one.
Which are, technically, "static (and global, whether they have external linkage or not) objects". And globals have to exist before main is called. 
Weird! I was expecting some c++11 magic from this library, but I have got lost along the way I reckon. This is a lib with backwards compatibility (c++03 plus some possible MS additions and gcc &gt; 4.7.2). Seems to use boost::asio for concurrency and with some thread cancellation (as it uses boost threads) which in itself seems to be a debate point in the community (at least standards community). Code looks very disjointed and it's very hard to pick out the advanced task management on offer. I have only spent half an hour so perhaps this is a bit harsh, I will happily stand aside to defenders of this in case I have missed something. Seems like nice enough code but very different from the expectation I had. Also very surprised there is no use of cmake or similar cross platform build system in play as that would certainly help cross platform adoption. It would also benefit from clang interoperability (let's osx use it as well). At least it's an open source contribution and has to be applauded for that I feel. Also great to see MS making use of boost (although in this case I feel it's wrong). This is possibly a missed opportunity for showcasing c++11 and advanced 'to be standardised (or at least take it down the path to asynchrony)' task management though. 
There is no static constructor in C++, but you can fake it like this: #include &lt;iostream&gt; class Class { public: static bool StaticConstructorCalled; static bool StaticConstructor(); }; bool Class::StaticConstructor() { std::cout &lt;&lt; "Static Constructor Called" &lt;&lt; std::endl; return true; } bool Class::StaticConstructorCalled = Class::StaticConstructor(); int main() { std::cout &lt;&lt; "Main Called" &lt;&lt; std::endl; return 0; } 
By not supporting even Vista, let alone XP, this won't have wide adoption for a while. 
What most people mean when they say this is probably "constructors for objects of namespace scope with static storage duration"
Anybody paying attention to that "__is_valid_expr" compiler built-in construct in the proposal ? I thought that was one of the holy grails of template meta-programming but it has a nothing but a secondary role in ... If it is required for performance for concepts, then, why not make it feature ?
*woosh* Did you hear that? That was the sound of this question going over your heard. Sorry, I don't mean to be an ass, but you, well, don't get it. As others have said, there is no such thing as a static constructor in c++. You may have static objects are initialized prior to main, but the order in which that occurs is non deterministic. In practice, it is in my experience that they are initialized in the order in which the object files appear to the linker. But, and this is a big but, this is not guaranteed or defined behavior. I've come to learn, via the hard way, that you should never have non-POD types declared/defined/initialized statically. This was via C++03; in *certain* contexts, C++11 may obliviate *some* of these concerns, but it does not fix all. One of my (least) favorite issues to debug is referrencing a std::string statically before it has been initialized. (might work for you, might not work for another).
I feel like a question like this is trying to get at whether you are familiar with concepts like [factories](http://en.wikipedia.org/wiki/Factory_\(software_concept\)) or having static methods that initialize a new instance of your class and return it. Obviously it doesn't make sense for the actual constructor itself to be static, but functions such as: class MyClass { static MyClass create(...) { /*...*/ return some_MyClass; } }; are probably what is meant by asking this kind of a question.
Thanks!
I said neither "I was asked at a C++ interview...", nor "I ask at C++ interviews...". "Someone may be asked at a C++ interview..." is just a kind of "dramatized" introduction. Can be reformulated as "Some C++ programmers may think that...". ;) Well, as said in my previous comment, the article intention is to show, especially to beginners, one clear statement "There is NO static constructor in standard C++ programming language". I wrote it not like a kind of "reinvented C++ wheel" but because more and more beginners are confusing terms and concepts between C++ and other programming languages. Of course, such article can be improved and completed. Every comment and remark can be really helpful in doing this. Thank you! 
I think it is called named constructor. Also usable when dealing with cross DLL boundaries, you call a static function (named constructor) to create an object (returns a pointer) and you call member function to delete the object. That's because operator new and operator delete can be implemented differently in each DLL - each can manage its own heap and deleting object created from other heap is not good.
this is c++, no need to even ask, your application WILL NOT be made slower because of features you do not use
On the codeplex page it mentions that it does support Vista. It also supports Linux. Now if it had supported writing REST servers, it would really be useful.
array size for a function parameter?
I don't know, can you provide an example of such a declaration?
haha, wow they actually use git... i was half-expecting visual sourcesafe *shudder*
I believe static constructors in other languages are used primarily to initialize static members, and to execute some code before constructors are called. I also believe the fake static constructor I posted will do that just fine. If not, please explain why? Also, the question didn't go over my head. The first sentence my original post acknowledges that there is no static constructor in C++, and I even referred to the code I posted as a way to fake it. 
Hi everyone, I am one of the Program Managers who worked on this project. If you have any specific questions or want to give feedback, feel free to reach out to me!
Yes, we actually removed the server side libraries because we didn't feel we were ready to release them yet. This first release focuses primarily on client side libraries. We are currently working on the HTTP listener, TCP listener, web sockets, and other service hosting related libraries. We hope to release them soon!
I would be interested in knowing if there is a possibility of an attempt at cross platform task handling / ppl type abstraction from this or a similar library. I would think there is some thought's in the library about doing this but I can see it would require msvc2012 and possibly even with ctp2 (which is potentially not production ready). I would also be keen to know if you will be looking at true cross platform capabilities including compilers/build systems etc. I really like different compilers and being able to code in any compiler we choose at work (mainly gcc/clang/msvc) we find the code becomes significantly more robust. Congrats on coming out to take comment's, it's a great sign.
But asserts don't "fail gracefully". Your program now gets out in the wild and either just dies because of the assert from an unexpected set of inputs or goes along it's merry way because the asserts are disabled.
If you refer to the code you have posted class Class { public: static bool StaticConstructorCalled; static bool StaticConstructor(); }; // ... bool Class::StaticConstructorCalled = Class::StaticConstructor(); ...then no, no "static constructor" is called but a static member function named "StaticConstructor". May be named "HumptyDumpty" as well. ;)
Eh, I think StaticConstructor is a fine name, since it indicates its purpose.
Great article. It is interesting to see tag-dispatching and SFINAE working together. One thing however worries me that in the case of make&lt;foo&gt;(some_input_iterator()), the input iterator will be silently ignored.
Forget the 2D/3D graphics examples. A much simpler example: Given a list of numbers (ints, floats doesn't matter), 1. Find the median 2. Find the mode How does one compute such things without sorting or partial-sorting? 
I found it on this guy's post: http://hamberg.no/erlend/posts/2013-02-18-static-array-indices.html
Pointers to functions : (void*) function (int,int) Just learned this today :p
Heh, thanks for that, but I need a definitive listing of all the possibilities. :) I've gathered a lot of the possible use cases, but the analyzer is ending up in industrial use, so it must be as complete as possible. ^^
After a quick Google search I came up with a working draft of the C++ specification from 2005: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf 
Thanks, but this isn't very helpful. Searching for all the possible uses for parentheses from that list is quite painful...
Consider using clang. Parsing C++ is the kind of job you want to get somebody else to do.
And we can add another thing to the list of stuff I have never had a need to do and never expect to do. I do wonder what kind of work the people writing in this thread actually does, it appears to be a very different kind of work from mine.
also lambda, catch, decltype, range-based-for, initializer list, exception specifications, (and pragma) I dont think there is such a thing as a simple parser for c++.
I fail to understand how this isn't helpful - it's the definitive list. There's too many use cases for parens that you won't be able to determine their use without respect to their context, because there are ambiguities. For example, how are you disambiguating `function_call(x)` from `MACRO(x)`? Or are you analyzing the code after preprocessing? Is `(x)(y)` calling function x or casting y to type x? Is `X Y(Z)` constructing a type X or is it a function prototype returning an X? There are others. I don't know how much you know about PLT, but the idea of trying to write an analyzer without using a proper parser sounds like madness to me. MADNESS.
You've got return 0 outside of a function, and an extra brace at the end. 
I can't use clang because of some licensing issues. Also, the analysis is based on quite a few things, so I don't think a complete parser is needed. I did some research prior to starting the implementation of the analyzer and ended up with a result that the only thing that could have done the job completely right would've been GCC.
void (*function) (int, int) - is a pointer yours is not even a legit expression, sorry )
We have done our research before choosing to do this, so I don't think I underestimate our project. It's not like we just decided "hey, let's make a C++ parser!" :) The goals we have do not care about preprocessor stuff and are quite "simple" in terms of parsing. This parenthesis thing is just about the only problematic thing that has come up so far. The parsing is done in a linear fashion, not caring whether or not we know what X or Y is at the time of reading. I've done my own listing of the parenthesis usage, but I fear I've missed some stuff. I've done it by analyzing big C++ projects (i.e. OGRE3D) and adding new definitions as they are found. Completeness cannot be ensured, that is a given, but we try to aim "as complete as possible" with our current resources. :)
If an assert is triggered it means my program is broken, there is no graceful way to fail, these edge cases should be picked up in testing and development phases. Asserting preconditions is not a replacement for exceptions it's a replace for no checks at all. Furthermore the libraries we use everyday like boost and the standard library are programmed in the exact same way. std::vector&lt;int&gt; v(2); v[6]; With __GCXX_DEBUG (or whatever your vendors flag is) this will assert as being in bounds is a precondition, without it silent fails or segfaults. So unless you have your own std:: lib then I guess your stuck with this manner or programming anyway.
I am surprised that clang/LLVM would cause licencing issues since it is a BSD style licence. http://llvm.org/docs/DeveloperPolicy.html#llvm-license "We believe this fosters the widest adoption of LLVM because it allows commercial products to be derived from LLVM with few restrictions and without a requirement for making any derived works also open source"
VC, GCC, clang, and EDG are all full-fledged front-ends, albeit with varying levels of conformance and bugs. That's at least four.
The customer has licensed the original project so that it can't make use of external OSS, which is just bullshit. We just have to conform.
The thing in using full-fledged front-ends is that either they are impossible to use in our environment due to licensing issues, uncompatible environments or for some other reason. Anyway, the original question was not about existing tools and front-ends.
You should talk to your customer and get them to have their lawyer take a look at the llvm/clang license. If you continue with your own parser, the project will likely fail. Here's why: C++ *isn't context free* (see the examples given by mshol). Therefore, what you're saying: &gt; The parsing is done in a linear fashion, not caring whether or not we know what X or Y is at the time of reading. is simply impossible. 
We explained ourselves already, but there's a whole chain of "project as a part of another project, which is a part of another project" and our customer doesn't have a direct control over the licensing.
Are you aware of issues like the [Most vexing parse](http://en.wikipedia.org/wiki/Most_vexing_parse)? Also there is the "&gt;&gt;" issue in templates. C++ is *very* hard to parse.
Those are not relevant for our purposes, and like in almost every comment here, this isn't relevant to the original question I had.
Is anyone aware of something similar for the gcc toolchain?
Yes, but if the interviewer uses the wrong terminology, what does that say? In a technical field, using the right terms for the right things matters immensely. 
You can write custom functionality for gcc in Python; there's an example using PIL which works with opencv at https://github.com/renatoGarcia/gdb-imshow; I've also got my own implementation based on the above somewhere on my laptop, if anyone wants me to dig it up.
I guess my point was that C++ is context sensitive in a number of places. So knowing what a particular parenthesis means depends **might** be impossible to deduce without doing a complete parse. 
Maybe it would be as-easy/easier to write a plugin/tool for ~~Clang~~ lldb, like that one since ~~Clang/LLVM~~ lldb philosophy of "Easy Tooling".
s/Clang,/lldb,/ ?
Thanks. 
This appeals to me greatly. I'm on my phone now, so I'll look at it in more detail later. What sparse storage formats does it support? How much setup boilerplate is required (like initializing mpi or creating processor maps, etc)? 
So what you're saying is that in your 20+years of programming experience, you have never come across a situation, where given a set of non-unique 'things' you need to identify the most common occurring 'thing'? If that is the case, then perhaps we have a different definition of programming. Yours seems to be one similar to a carpenter never having used wood, or a dentist that has never needed to interact with teeth. That said, I get the feeling that you're probably trolling more than anything else. 
Except this one: http://clang-developers.42468.n3.nabble.com/Problem-with-gnu-libc-4-7-s-chrono-in-Clang-3-2-td4029343.html --- condition_variable.orig 2013-01-05 23:37:45.487874692 -0800 +++ condition_variable 2013-01-05 23:37:09.709996129 -0800 @@ -107,8 +107,8 @@ // DR 887 - Sync unknown clock to known clock. const typename _Clock::time_point __c_entry = _Clock::now(); const __clock_t::time_point __s_entry = __clock_t::now(); - const chrono::nanoseconds __delta = __atime - __c_entry; - const __clock_t::time_point __s_atime = __s_entry + __delta; + const auto __delta = __atime - __c_entry; + const auto __s_atime = __s_entry + __delta; return __wait_until_impl(__lock, __s_atime); } EDIT: also these need to be manually defined on the command line for &lt;atomic&gt; to work on x86-64: -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 
Yes, the same code works for all the supported compilers. Go ahead and fork.
Can't think of any time that has happened. And I notice that you, as well as everyone else in this thread has not mentioned what they actually do where this stuff is useful. Are you guys all students or something? It's as if everyone in this thread has no idea what is actually useful in programming (not to mention that you all appear to be unable to stay away from insulting the person you are writing to).
This looks interesting, but I wonder, why the use of wide strings? Isn't the UTF-8 approach more general and flexible? Maybe it's supposed to ease the integration with the win and .net platforms?
Even if it were LGPL it'd be better than the situation it is. Sleepycat is a good license, but it's not really great for libraries, and nobody's going to pay for a commercial license when there are alternatives like Lua on the market. However, if it were BSD licensed and you offered commercial support services, it'd be a much easier sell. You'd be doing more for the health of the language if you relaxed this a bit (and gave the people who need it direct access to the unadulterated source so they can remove the bits of the language they would never use/is duplicated in their own platforms).
I wrote such a beast once, when I was just learning C++. The goal was to be fully STL compatible and relatively space-efficient. https://code.google.com/p/hwpp/source/browse/trunk/util/keyed_vector.h?spec=svn604&amp;r=604 And a unittest https://code.google.com/p/hwpp/source/browse/trunk/util/tests/keyed_vector_test.cc?r=604