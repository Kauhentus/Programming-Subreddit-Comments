It's kind of funny but I don't find Python an easy to learn language at all. In fact, I find it very hard coming from C++.
&gt; with a protocol to allow values to be extracted from user-defined types. I wonder what is the plan about that. It should be generic enough to work with `tuple`, that is not even required to be standard layout. 
Its funny you say that :) I just finished watching [Kate Gregory's Cpp Con!](https://www.youtube.com/watch?v=YnWhqhNdYyk) and as she says " One little using namespace std; won't hurt anyone." I'm going to go ahead and agree with her. 
Thank you so much for the feedback everyone! I'm glad I posted this link on reddit because based on your input I've decided to teach the course in an order inspired by Kate Gregory's talk. I think it will give my course an edge when it comes to usefulness and beginner friendliness. I'm quite excited to continue making the tutorials!
HIRING FOR MULTIPLE C++ DEVELOPER POSITIONS Akuna Capital is a fast-growing derivatives trading firm headquartered in downtown Chicago that specializes in market-making and arbitrage. [C++ Developer-Chicago](http://www.akunacapital.com/job-details/?jobid=86052&amp;gh_src=) [C++ Developer-Infrastructure Team-Chicago](http://www.akunacapital.com/job-details/?jobid=65800&amp;gh_src=) [C++ Developer-Performance Team-Champaign, IL](http://www.akunacapital.com/job-details/?jobid=80356&amp;gh_src=) [Gateway Developer C++ -Chicago](http://www.akunacapital.com/job-details/?jobid=86058&amp;gh_src=)
Kdevelop is missing too
&gt; Thanks to the genius that thought noexcept should terminate. Can't you get around that overwriting the terminate handler function with `set_terminate`?
If MS is asking these questions, let's hope that means they're considering VS for Linux... That would be spectacular. 
I agree. Does anybody know where to find the referenced D0144R0 paper for more details? It seems like this mechanism if general could do a lot of cool stuff.
Seems that way!
What would you want instead?
True. I think it's always what you learn &amp; get used to rather than any rules...
Interesting. This is a special use case where seeing something visually can make a bug difference. A lot of people say that visual programming methos can work well in domain specific areas. My thinking is that we can invent a visual programming system that is able to specialise to many different areas such as what you are mentioning here...
Thanks for the reference. I'll take a look.
Can you take them as a `const` ref? I.E.: for (const auto&amp; {a, b, c} : f()) { }
I passionately hate the idea of linking blocks with lines. That's 19th century programming. I hope I can come up with something better...
Qt Creator custom parser is garbage it doesn't resolve anything but basics (fails at simplest template/auto deduction). libclang plugin works reasonably well, delay is noticeable but very usable - I only have medium sized codebase (few hundred k loc + libs)
You can control the lines in UE4 with functional blocks and abstraction. You don't need wires running all over the place like spiderwebs.
GMock?
I had interview for a position at London and you can be sure that the first thing they did is an *extremely* language lawyer level test: protected inheriance, pointers of pointers of pointers and much more. More than any other interview I had before. That is the first test they did to me.
I wrote one in. :D
Take a look at pointers, inheritance and some tricky stuff. There were also macros. But I cannot guarantee you will have the same tests :D I must say that this test was advanced. I cannot qualify it otherwise, even for someone using C++ for many years.
Give up and pickup botany.
Cramming for a programming interview is usually harmful. You don't want to brag about false confidence in topics that you only learned in the last week. Looking dishonest is the worst thing an interviewer can notice. Just get a thorough night's sleep, eat a light breakfast, and be friendly and genuine. If you come across as junior-level, they'll simply offer a junior starting salary, if you have what they want. Bloomberg also seems very eager for C++ talent right now. So if you are a good match, they will probably make an offer. Good luck! 
That is even worse :P
Thank you
not sure what your idea of "preparing" for the interview is. you might be able to brush up on what you already know, but if you want to become a language expert by monday, that is impossible. be confident, get a good night's sleep, don't cram, i think it will be counter-productive. you obviously have something they are interested in if you got an interview with them. if it is a good fit, you'll get offered a job. if not, then keep preparing, read books, attend conferences, etc. eventually you'll get to where you want to be.
I had an interview with them some months ago and to be honest, they were really aggressive with their questions. Questions were more about C pointer/array arithmetic than C++ and btw, my interviewer had no clue about C++11/14 so don't try to argue with them about new features of the language or the situation will be quite uncomfortable, like "why are you using make_unique here, or why are you using make_shared here?". IMHO they were concerned about small stupid details and at the same time, they wanted me to do code that was allocating tons of small fragments..., yeah early optimization.... 
Was this in London? BB have an atmosphere of c++ mutual masteurbation to largely overcompensate for the fact most developers there write almost no code and that they have no real low latency requirements any more. A few of the guys spend their entire day arguing about language minutae 
Yes, it was London, glad I didn't get the job though xD.
I am writing a whitepaper. It's in my head.
Sadly no, that means the amount of weird people there, is big, really big.
Polymorphism is sometimes thrown in as a hard question on entry level tests.
I wonder how it would be with references. If you put auto &amp; you make all references? should not be this: for (auto &amp; {x, y, z} : f()) I think it should be: for (auto {&amp;x, &amp;y, z} : f()) to allow independent ref and non-ref binding. Or the first one could be a shorthand for: //same as for (auto &amp; {x, y, z}) for (auto {&amp;x, &amp;y, &amp;z} : f()) What do you think? 
In London they had me writing code into one of those online c++ websites; fibonacci sequence, finding greatest loss in a vector of ints.
My advice is brush up on algorithms and data structures, these are far more important than getting the grammar perfect on paper. Good luck, please let us know how you get along!
Read scott myers series on effective c++ (including effective stl) and you will be fine...
Read scott myers series on effective c++ (including effective stl) and you will be fine...
The funny part, as I mentioned, is not that I was asked about that, is that the guy asking the questions didn't have a clue about it, as I had to write some code and as I'm use to use C++14, I used it. Those new C++14 features were not part of the technical interview, but were introduced by myself as an habit of my daily code. I explained the reasons, the securities on make_unique, and he couldn't understand it. I think he was still migrating from 03 to 11 and didn't have a clue on 14. /facepalm Please don't take my opinion as something good or bad as is biased by the fact I was really pissed off by that guy, I know bloomberg has good developers(really good, they contribute on the standard etc).
I agree. Also CV qualifiers.
~~what a fucking stupid thing to say~~ *edit* navatwo didn't mean everyone in london is pedantic
Having interviewed for Bloomberg internships before, which I assume are similar, make sure you're solid on data structures and runtime complexity. Also they tend to ask language spec questions, some of which can be quite tricky so I hope you know C/C++ inside out
I used to "work" at BB, so bias incoming. I was also an intern (NYC), but I spent a lot of time with full time developers and got to know them. We talked about interviews a lot as most of them did a lot of them. To prepare for interviews, I really recommend Scott Meyers book like everyone else. Additionally, cracking the coding interview style questions outside of C++ semantics. For example, I was asked logic questions and asked to design a pointer for an OS and justify my decision on the matter. I was also asked about what I do in my spare time, leading into talking about reading Effective Advanced C++ and describing what I liked about 11 and 14. It was actually a pretty intense day, if I'm honest. However, the focus of interviews is less on perfect code and more on how you get there and justify your decisions. If you are doing a lunch interview, try to show your personality and how you interact outside of work in the culture. Talk about things outside work, but not red flag topics (eg politics, illegal activities). It's a measure of you for both social atmosphere and how well you'll mesh with their team. Feel free to PM me if you have any direct questions about the team you're applying for, I might be able to help out. Lastly, their culture, in NYC at least, is fantastic. It's like a start-up with billions in revenue who want to hold and caress you until you never retire. I bloody loved it there. Edit: they also told me they loved that I scape goat problems by using STL instead, but offered up solutions without it too. Know your STL api and how to use it, but don't expect a quiz on it. Additionally, data structure applications like caching. 
Nobody will ask you to do complex C++ stuff. The language is really irrelevant in these things. It will be an exercise in data structures/algorithms/pointer arithmetic. 
No it won't
I don't understand, you're upset that this unspecified behavior is now guaranteed? I understand that it was previously an easy bug trap, but now code can be read top-down, left-right and be completely intuitive, like: std::string s = “but I have heard it works even if you don’t believe in it”; s.replace(0, 4, “”).replace(s.find(“even”), 4, “only”).replace(s.find(“ don’t”), 6, “”); assert(s == “I have heard it works only if you believe in it”); Unspecified evaluation order just for the sake of premature optimization is pretty silly anyway.
&gt; pointers to pointers to pointers... 3 star programming. That way madness lies. EDIT: http://c2.com/cgi/wiki?ThreeStarProgrammer
AFAIK, committee did a search through some existing C++ codebases and found that these words were rather common, especially `yield`. That's why they decided to name them differently. 
The good news is, Bloomberg is very pro C++11/14. Modern idioms, clean code. The one gotcha, though, is that for me (extremely senior) they actually asked for explanations of underlying on language issues. Disclosure: I phone screened, got invited for an interview, but declined because my wife shot the New York relocation down.
Takes one to spot one?
This popped up in /r/programming: https://github.com/shyal/cracking-the-coding-interview
&gt; asked to design a pointer for an OS and justify my decision on the matter. A what?
Is there somewhere I can read more about that?
Thank god for the 2015 support. Had to have a machine just for UE because of Xamarin exploding with multiple VS versions installed.
Pointer layout, for an OS. Poor phrasing. 
Interesting... what was your paper ?
You mentioned that your team is familiar with dynamic languages. I would show them stuff that blows away some of the preconceived notions that C++ is inelegant and low-level especially for web stuff. For writing the web server, take a look at Crow (https://github.com/ipkn/crow). This is an example of a multithreaded REST/json web server that someone familiar with python could easily grok. For database, look at sqlpp11 (https://github.com/rbock/sqlpp11). For pattern matching take a look at simple_match (https://github.com/jbandela/simple_match, https://www.youtube.com/watch?v=9IVCVSwn-fI) (Disclosure: I wrote it) For a nice string formatting and output library without the verbosity that is std::iostream, take a look at cppformat(https://github.com/cppformat/cppformat) Also, show them how many companies are using C++ in the codebases When done right, C++ can look just as nice as any dynamic language yet provide far more safety with it's type checking and the potential for no-compromise performance. Dropbox - https://www.youtube.com/watch?v=5AZMEm3rZ2Y Facebook - https://github.com/search?utf8=%E2%9C%93&amp;q=language%3AC%2B%2B+user%3Afacebook&amp;type=Repositories&amp;ref=searchresults Google - https://github.com/search?utf8=%E2%9C%93&amp;q=language%3AC%2B%2B+user%3Agoogle&amp;type=Repositories&amp;ref=searchresults LastFM - https://github.com/search?utf8=%E2%9C%93&amp;q=language%3AC%2B%2B+user%3Alastfm&amp;type=Repositories&amp;ref=searchresults C++ is the only high-level language that is supported by the vendor on all mobile platforms. It is becoming more common to write the algorithmic/non-platform specific code in C++, and then use either Java (for android) or Object-C (iOS) to write the UI layer and interface with C++ code.
In order to get them on the same page, you need to justify why C++ is the right choice, not just by going over the pros of C++, but also by going over the requirements of your project and how C++ will meet those requirements. What are the language requirements of the part of the project you plan on using C++ for? Why do *you* think C++ is a good fit for the project? This info might make it easier to provide you with the answers you're looking for!
And if you think that code is unreasonable, Bjarne himself wrote it into TC++PL4 so it's an easy trap to fall into.
My impression was that it's a feature mainly to simplify generic code, where free functions seem to be the preferred way anyway these days. From this perspective the accepted proposal seems natural.
&gt;C++ is the only high-level language that is supported by the vendor on all mobile platforms. It is becoming more common to write the algorithmic/non-platform specific code in C++, and then use either Java (for android) or Object-C (iOS) to write the UI layer and interface with C++ code It is so funny to me that *c++* is the language used for platform agnostic code, while java is the one that is platform specific.
You are absolutely right, and I do plan on doing that. Without going too deep into requirements, we are settled on C++ client-side, and we are considering Go server-side. Performance is less important than rock-solid, well-structured code. I haven't built anything in Go, but I'm skeptical as to whether it can match C++ as far as type safety, error-handling, and overall flexibility. I *do* think we could make Go work, but in my heart I just don't think it's the best choice, and I want some ammo to make C++14 seem as shiny and new as Go does.
That python post looks really promising, and I'm going to have to go through these talks. I had already settled on Catch for testing :) Thanks!
Java was supposed to be Compile once, run anywhere (with a compatible virtual machine). Since many platforms don't have a compatible virtual machine by default, C &amp; C++ version of "Write once, Compile for platform" works where a virtual machine is not available or would be a pain to install.
CMake + ninja
I would show them resource management, scopes and the deterministic "garbage collection" of C++ (i.e. how resources are freed on "`}`"). That blows a lot of people away that come from Java.
Akuna Capital has internships open for summer. www.akunacapital.com 
Yeah, sorry about that -- my fault! We were part of another team that had more people, some of whom are sort of involved but not officially at this point.
They are 2 different things. re2 is regular expression matching. simple_match is pattern matching in the functional programming sense of the word. 
At tiny team sizes, I think momentum &gt; everything else. Literally whatever you can get the most momentum with the quickest -- which means whatever you two are passionate about. It will all likely be thrown out if you bring in a bigger team anyway... and then that will all be thrown out when that team is replaced by an even bigger team. :) 
Just ask your team how much they like generics. :) In all seriousness, Go really is excellent for server applications, but (in my albeit limited experience) it can quickly collapse under its own weight as the code base grows in size, simply because there aren't enough facilities for generic programming.
Is that a language with a weird replacement for RAII? Does that feature scale?
Go has [`defer()`](http://blog.golang.org/defer-panic-and-recover) but that's definitely not a replacement for full-blown RAII / destructors.
An idea might be to take an existing project they wrote; rewrite it (or a part of it) in C++14 and let them compare.
You don't need a VM for Java, there are plenty of commercial AOT compilers. The problem is mainly that Oracle just doesn't care.
The issue with C++ and web apps is that an unhandled exception or memory overwrite can blow the whole server in unexpected and difficult to understand ways. This doesn't normally happen with say Java.
I wanted to call out tooling specifically. There's so much amazing tooling for c++, if you use it from day one on a green field project you can make your life so much easier: - clang format and clang tidy for painless style enforcement, best practices - multiple unit testing suites to choose from - test coverage utilities: kcov I think is one - great static analyzers. Check YouTube for a cppcon talk called the state of free static analysis - memory sanitizers asan and msan. They only slow code down by a factor of 2 (not 20 like valgrind). This is absolutely huge, you can just stuff these in your build matrix and run them every single day. If you just set up these tools on day one and write unit tests, a huge chunk of the edge cases that c++ introduces over higher level languages are caught automatically by tools, saving many man hours. Combine with defensive programming that uses asserts liberally to cause clear crashes early in development at no cost in deployment and you're good to go. 
That's such a good advice. Thank you! 
Memory overwrites aren't really that much of a thing in modern C++. Range-based for loops have made iterators much more pleasant, there is not often a need to loop on an array index. I have overrun buffers many times when doing C programming (15 years ago) but I can't recall experiencing it while doing C++ game programming the last year and can't even think of anywhere in my code it is possible. I simply don't do pointer arithmetic, or other direct memory access. As for uncaught exceptions, I don't quite see your point. The Java server container catches your exceptions for you - if it didn't that program would exit. What is different in C++?
That's an interesting comment as one of Go's goal is to accommodate the kind of very large scale app (#LOC) that Google has.
Comparing to dynamic languages for appealing to them (not C) you could have: - type inference (show them the difference with dynamic languages and how handy it comes while maintaining type safety). - type safety vs dynamic languages. - speed and optimization opportunities due to type info that compiler uses. - how it scales without 100% testing coverage compared to dynamic languages (catches errors at compile-time vs dynamic languages). - RAII vs GC. Differences, benefits about memory use. vs C-style code examples with typical potential errors and compare against a simpler, safer modern approach and its benefits. - null pointers avoidance (vs references). - memory leaks. (smart pointers). - any other resource leaks (teach RAII for lock-guards, files) I think that could be a good start. 
&gt; Unspecified evaluation order just for the sake of premature optimization is pretty silly anyway. Read my post again: I did not say a single thing about performance, among other reasons because I am aware that no major compiler will actually use this to generate faster code. I want it to be unspecified in order to disallow bad code.
The first test is online and is: you know it or you do not know it. You can avoid replying.
I like cpp when I'm working on something that I need DirectX for - but it's one hell of a pain in the ass compared to Java, C#, etc.
&gt; Memory overwrites aren't really that much of a thing in modern C++. I disagree, especially when you have junior programmers, or Java guys that haven't written C++ in 10 years tossed onto your team because "they know C++". Sometimes these bugs get caught in code reviews and sometimes they don't. We're still seeing people using new and delete in open source projects that are supposed to be C++11 friendly. Also you're right about the Java server catching exceptions. In C++ the container might catch (...) - but you know, sometimes that (...) is something like a segmentation fault which should be terminal. In C++ you can throw any value. This isn't normal in managed languages. Personally I'd be comfortable with C++ web apps, but throw some inexperienced devs into it and I'll start to get a little nervous. 
that was a general comment, not directed at your comment in particular. and you still haven't explained why it's "bad" code.
&gt; but you know, sometimes that (...) is something like a segmentation fault which should be terminal. You need to do work to turn segfaults into exceptions, if you want them to be terminal, don't turn them into exceptions. 
Hence why my approach is to use JVM and .NET languages when I don't need to shave every ms or byte for the application's use case, and use C++ for the infrastructure work when required, or portability between mobile platforms.
&gt; more memory efficient and performant. And uses less characters at construction (no `new`, etc.) and usage (`.` instead of `-&gt;`)
Interesting article, although I'm really confused about this title...
Even the STL has a function called yield. (std::this_thread::yield)
Very good points. Thanks!
The companies are doing so because it's a great way to promote their product. There aren't many open-source applications of the same calibre. But yea, as for pressure, I think in a way it does the opposite... considering they're basically fixing bugs for them.
This is a sentiment, I do not share. C++ is at least as high level as C# and more high level than Java. There is no intrinsic reason that C++ should be "a pain in the ass", especially compared to Java. Your experience is probably due to sub-par/old C++ libraries that you are using. We don't have to accept horrible libraries that make C++ harder than other languages. There are already libraries out there that use Modern C++ features to make libraries that are "fun" and easy to use. With Modern C++ we can have the best of both worlds - high level, high performance code that is easy to write, read, and understand.
By adhering to a specific, limited set of patterns and paradigms, and with tools that enable sufficient static analysis. Basically, start off with not allowing any resource usage at all. That's one way to guarantee no resource leaks. But that's not a very useful language, so let's allow `std::unique_ptr` (but still prohibit any usage of `new` and `delete` directly). Then add `std::shared_ptr` ... but now it's harder to guarantee no leaks, so you build up a set of rules for how and where to use it. You get the idea.
And codelite and codeblocks ...
If you do end up using C++, and if your target allows for it, you should strongly consider using Clang over GCC. Everybody will be thankful for the better error messages.
Are Google that desperate to hire people? I thought they were scraping the barrel when they emailed me with a job offer but that seems way worse.
I don't understand, why is this code bad? Please explain (genuinely curious).
I worked there for a few of years (NY, Trading systems). In my experience (on both sides of the table), face to face interviews at Bloomberg are with actual programmers working on actual problems, and the question in their mind will be "if this guy sits next to me tomorrow, how much time will I waste teaching him programming in addition to explaining the development environment, the jargon, and the day to day operations? How soon will he start doing actual work?" When I was there, I always asked the candidates "how would you debug X?" (with no shortage of varying X's from recent experience), and occasionally "how would you design Y" (often something our team designed recently, so that all ideas and trade-offs were fresh in my mind). So for a real advice, ask your interviewer questions! Find out what it is they do and what they deal with as soon as possible, find the common language, use what you learned from the first pair of interviewers to convince the second pair that you'll know exactly what you're doing when you sit next to them tomorrow (assuming you do like what it is they do on that team). Even if they start off with C++ trivia, bend the answers into questions to them. "amortized complexity of unordered_set.insert? O(1) of course, and by the way, what kind of hash tables do you use here? Can they hash C strings? How about concurrent hash tables?". Interview is a dialogue.
The correct replacement for list::remove is Uniform Container Erasure (which would then need to be implemented with internal helpers).
What about when you have precompiled code and only the headers? This stuff sounds like it could become a horrible nightmare in such cases.
Who cares about backwards compatibility? People with old code should just use old compilers.
xvalue_cast doesn't really document the intent well. When you're reading code and you see std::move, you *know* that someone intended for the object to be moved.
Modify the headers? All of these changes could be made without breaking ABI compatibility.
Go vim and never look back. Do eet
Interesting. It seems that for this situation and many others (like interfacing between other languages and C++) a well defined stable ABI would be desirable.
Also, as a first step, it would be nice to have compilers configurable to throw warnings when a bad egg can be replaced with a better alternative. 
While we're talking about things that will probably never happen: `const` by default for member functions. Having it opt-in as it is now just means lazy developers write shitty interfaces by default. At least the other way would mean extra effort to make the interface horrible.
To be fair, I considered the other example to be the more problematic one: map["foo"] = map.size(); There really are two different, reasonable, execution orders that make it hard to reason about which one really was intentional. Making this UB unspecified basically disallows it which I consider a good thing. Regarding s.replace(0, 4, “”).replace(s.find(“even”), 4, “only”).replace(s.find(“ don’t”), 6, “”); That line does a lot of things, in my opinion a lot to much. Now it is true, you could write it as s.replace(0, 4, “”) .replace(s.find(“even”), 4, “only”) .replace(s.find(“ don’t”), 6, “”); But at that point we should already ask oursleves why we do this, because writing s.replace(0, 4, “”); s.replace(s.find(“even”), 4, “only”); s.replace(s.find(“ don’t”), 6, “”); Isn't really more to type and makes it clearer that these expressions really must be executed after each other. Basically: That example isn't outright horrendous, but there is still a better way that doesn't rely on execution order, so why allow it? I am aware of exactly one situation where guaranteed execution-order is a good thing and that is when working with template parameter-packs, where we do have fine alternatives for the typical use-cases that don't require a lot more code. And this is what my problem is: I have yet to see an example of normal, non expert-level-code, where the version that relies on the order is actually cleaner then the alternatives.
Maybe. No guarantees of that. The ABI is not part of the language standard.
It's true, people are increasingly learning not to upgrade software if they can avoid it, because you never know what will break. See Windows 10...
&gt; Follow the Rule of Zero and everything is crystal clear. Rule of Zero is great unless you're defining your own resource-owning container.
Please, please do this. Uninitialized memory was by far the single biggest source of issues for new programmers when I was helping teach C++ in school. I tried to patch a warning into clang a while back but there wasn't much interest due to backwards-compatibility concerns. I'd actually argue that uninitialized memory has a performance cost because anyone who cares about safety will zero-initialize all newly allocated memory just to be safe, so most memory is initialized twice.
til .so an .dll don't work
I'm surprised no one (including Scott) has mentioned the C++ Core Guidelines in all of this. It seems like the community is now on track to find all of these bad eggs in the language and automatically convert them. Many of these guidelines are probably going to end up in compilers as warnings, so transitioning them into errors in 10 years shouldn't be much of a problem.
Since we're making conversion constructors explicit by default, let's do the same for conversion operators. Next up are `switch` statements: no more default fall-through. The key behind all these breaking changes is that the compiler can tell you when it's broken. None of these are silent changes. That means we should be able to tell the compiler to use the "new defaults," get a bunch of new compilation errors, and then clean up the code ourselves. This is exactly what happens when you enable `-Wall -Werror` in a large code base. Yes, it might take a while to get things compiling again, but you're likely going to find (and fix) bugs along the way, so it's worth it.
&gt; `vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;(4, vector&lt;vector&lt;int&gt;&gt;(6, vector&lt;int&gt;(7)));` Well, even with explicit constructors, you can shorten this to `vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;{4, {6, vector&lt;int&gt;(7)}};`. And in most cases `vector&lt;vector&lt;vector&lt;X&gt;&gt;&gt;{4, {6, {7}}}` would be OK (sadly, it would behave differently if X is int, but I guess this ambiguity is a small fail of std::vector). Implicit constructors are great, until suddenly everything silently casts to everything else in weird ways.
Only runtime performance is measured. It is clearly stated in the benchmark description. Given the various HPC use cases where expressions are executed many times over run-time expression compilation is of little to no concern because it makes up a tiny fraction of the total execution time. 
Those are system features and not part of the language specification.
I don't see that as a problem. If `std::move()` ends up leading to a move or not doesn't really make much a difference, as it's always safe to just assume that the value of the object can no longer be depended upon after a `std::move()` call. It's not much different from regular copy-construction/assignment, `delete` and such, which also just give you a "most probably" guarantee of what is happening, but don't stop the class from doing something completely different.
Excellent idea to replace `explicit` with something like `implicit`! About the C++11 rules w.r.t. copy and move: They are not that hard. We just need to get rid of an exception that is just there for C++98 compatibility. This exception is the one that makes the whole thing error-prone (making the "rule of three" necessary). AFAIK, this exception is already deprecated since C++11. But no compiler warns about it so far -- unfortunately.
&gt; Requiring that overriding functions be declared override would cause umpty-gazillion lines of legacy C++ to stop compiling, even though all that code is perfectly correct. If it ain't broke, don't fix it, right? Wrong!, say I. I work in a C++ codebase that is at least twenty years old, contains about a thousand classes and has a "menu.c" that is not only C++ instead of C, not only handles *all* menu-related interactions but is also *over 20,000 lines long*. (Name fudged to protect the guilty.) If the compiler suddenly starts requiring that all virtual methods require override would not only be infeasible, it would be a shit-ton of work for *absolutely no benefit*. As such, we would never upgrade our compiler, because it would be too costly. We would be stuck on a C++14 compiler forever and that can't be the intended result. Language designers sometimes have no idea how their languages are actually used. 
I still don't see the benefit of this: x = static_cast&lt;float&gt;(cursorX) + (static_cast&lt;float&gt;(screenWidth) / 2.0f); over this: x = (float)cursorX + ((float)screenWidth / 2.0f); As both will be translated to a series of `fistp` instructions in assembly.
&gt; It's not much different from regular copy-construction/assignment, delete and such, which also just give you a "most probably" guarantee of what is happening, but don't stop the class from doing something completely different. Yes, and personnally I would change them to better reflect what is actually happening but this would be another language altogether, without so many operators, and mostly tracable function calls instead.
I think there would be a net gain from doing this. New comers to the language would see a lot more code that conforms to standards and a lot less bad code would be written. In the case of pace maker software, I'd like to think that the kind of code associated with maintaining someone's existence is thoroughly well tested to the point where running a migration script and checking its success would involve running a battery of tests. After all... There are always compiler flags to help highlight when you're writing shonky code right now.
Fantastic look
Pardon me, I am new to C++ and delighted if I will be corrected, but just today I came across this. In ruby: line = "some;;data;;separated;;by;;you;;see;;what" words = line.split(";;") words.each { |word| puts word } # or whatever In C++: vector&lt;string&gt; split(string line, string delimiter){ vector&lt;string&gt; retval; int index; while((index = line.find(delimiter)) &gt; 0) { retval.push_back( line.substr(0, index) ); line.erase(0, index + (delimiter.size())); } retval.push_back(line); return retval; } int main(){ string line = "some;;data;;separated;;by;;you;;see;;what"; vector&lt;string&gt; words = split(line, ";;"); for(int i=0; i&lt;words.size(); i++){ cout &lt;&lt; words[i] &lt;&lt; endl; } } I mean, what I wanted to tell here is that I was f*ing amazed that in 2015 I had to implement me a function that splits a string. I'm not into language wars and not comparing Ruby to C, but unless I'm totally missing out on some major big standard library that would handle everyday tasks from all walks of life in a consistent manner, then this stuff is screwed. I mean, of course we need low level languages and all that comes with it, but I understand why programmers prefer to use modern dynamic/interpreted languages to get their stuff done. 
Or even x = float(cursorX) + (float(screenWidth) / 2.0f);
Yes! And thank you for that, by the way. The remove-erase idiom is quite embarrassing to explain to new programmers.
Then you still define the two copy ones with "= delete" to make it explicit that it's not copyable.
Yup. I'm pretty sure the intention is to make the tools as trustworthy as the compiler itself.
Recursion is particularly useful for solving task that can be subdivided into smaller versions of that task, and following subdivisions will eventually produce tasks that are trivial. Simplest example would be printing elements of a tree (as in graph without cycles). The recursive procedure will print the root of the given tree and then call itself for each subtree if there are any. It's a nice abstraction for figuring out those kind of problems and designing nice algorithms, however, for some large tasks, where number of nested recursive calls would be large, you might run into some problems (e.g. stack overflow), but there are ways of removing recursion in an implementation (e.g. using stacks) - you can read up on that on the internet. edit: a word
Recursion is the concept of a function continuously calling itself until a certain condition is met, called a base case. This is can be useful if performance isn't a big issue for you because it can make for really clean and condensed code. For example, [Fibonacci](https://en.wikipedia.org/wiki/Fibonacci_number) is a recursive algorithm. It uses previous entries in the sequence to compute the current entry. Using recursion, it would look like the int fibo(int i) { if (i &lt;= 2) return 1; return fibo(i-1) + fibo(i-2); } So fibo(5), would eventually return 5. fibo(2) would return 1. fibo(10) would return 55. I would recommend going through the call tree to see what values of i that fibo() passes to the subsequent calls to fibo(). Just step through the code line by line. Recursion is a very complicated concept at first, but once you understand it, it'll come very easy to you. I don't think I explained it well since a short reddit post isn't a great way to do so, but I hope you can understand at least why it would be used.
Probably the most popular example for the use of recursion is the computation of the [Fibonacci series](https://en.wikipedia.org/wiki/Fibonacci_number) or factorial. That way one can compute them without using a loop. It's open for anybody to reason whether one want to use that or not. Just see it as another way of doing things. For a comparison of factorial computation see [this stackoverflow](http://stackoverflow.com/a/5721830).
Yes, but my point is that the ABI is defined and the mere fact that it's not part of the language standard certainly does not imply that there are 'no guarantees'.
What about UML?
static_cast's verbosity is a feature, not a bug. It's greppable, and it discourages overuse.
But I work in embedded where performance is critical. Zero initializing a big buffer takes time, time which may be in an isr that has to be fast. Or if you zero it during bss time then my system startup time increases by a few milliseconds, which may be too much as I am relying on a full system shut down to save power and then need a fast system boot up or else I am wasting more power. 
That's the factorial, not Fibonacci
Ehh... yeah... my bad. Although Fibbonacci is also something that is used as an example for recursion that is not what I meant to write and definitely not the code I wrote. Thanks for the correction.
Actually, you don't. If you define the move special member functions the compiler will not create copy.
Yeah, and the Fibonacci is also one that should be done without recursion. Truth is, recursion has very few special cases in which it is useful, but those cases it has an incredible advantage, and sometimes exclusively being the only option, but fibonacci and factorial? No thanks.
And AppCode
Yeah, that's what I like about it. Each time I write static_cast, I cringe and think that maybe I shouldn't really cast there and refactor my code instead. C style casts are easy to do and don't give you time to think about it. 
Please excuse my ignorance, but what's the hubbub about this library? I haven't seen much about it, in terms of projects using it, besides version announcements.
Is there a reason call stack size cannot be changed at runtime or at least program initialization? Recursive implementations usually are more elegant and clear than iterative. With a 64 bit executable, at compile time you can usually set the stack size large enough that blowing the stack will never realistically be a problem. But I don't know why it's not manipulable at execution time in some way.
Do you write `std::string("abc")` or `static_cast&lt;std::string&gt;("abc")` (ignoring custom literal)? Likewise, I use `float(i)`, it's the equivalent of a ctor call.
Fibonacci is just an easy example because it's recursive by nature. Recursion should not be used in most situations because it's so slow, but it's fine if performance isn't an issue and since it's so much cleaner in most cases to write.
Seems like bizarro universe when it happens. Even though it is just software, there seems to be the expectation that the compiler is infallible and then it says I am going home see you Monday.
If it's a UDT, the C-style behavior can't really lead to badness. But I'll never use that for built-ins, due to the risk of reinterpret.
When you want to iterate over a container or thing but you only know you've hit the end when you reach the end. For problems like that, recursion can be a useful and easy way to solve the problem.
Interesting aside: in D&amp;EC++ (published 1994), Stroustrup says he proposed both to deprecate C-style casts (p333) and change constructor-style notation to a synonym for object construction (p335) but the committee rejected both ideas because it would break old code. 
*really* well written, unusually so. Learned a fair few things from this. Thnaks for posting
So basically std::string_view?
&gt; These could easily be implemented as free functions Free functions would be great if it wasn't for trouble with chaining. Compare: Seq reader { "user@host:port" }; Seq user { reader.ReadToByte('@') }; Seq host { reader.DropByte(1).ReadToByte(':') }; with this: std::string_view reader { "user@host:port" }; std::string_view user { std::read_to_byte(reader, '@') }; std::string_view host { std::read_to_byte(std::drop_byte(reader, 1), ':') }; I find the chained version more readable. And this is not even unwieldy yet. Adding more levels of nesting, the free function version would start to look like LISP. This is one reason I *really* like Stroustrup's proposal to unify free functions and member functions, so that `f(x,a)` could be equivalent to `x.f(a)` in all circumstances. Then we could enjoy the benefits of free functions (can define them anywhere) and chaining (often more elegant). Unfortunately, Bjarne's proposal has only been half accepted in the last meeting &amp;#8211; and the crucial part that would allow for chaining of free functions did not make it. :( (Yet?) &gt; Just in a day I saved over a hundred lines from the endless repetitive pointer arithmetic that I inherited (there's a big arena there for super-speed), with no change to the generated code, and I've just started using it. Yes! Sounds similar to what I've been doing with parsing. If it's the right type of abstraction, it turns out elegant, powerful, and safe.
Except that only a C-style cast can generically (in a template function) cast either between a pointer or another integer to `intptr_t`. IOW: - To convert (any integer type) -&gt; `intptr_t` you need `static_cast`. - To convert (any pointer type) -&gt; `intptr_t` you need `reinterpret_cast`. C-style cast happily does both. EDIT: to further clarify, if you want to write the following function, `T` being an integral or pointer type: template&lt;typename T&gt; uintptr_t bits(T x) { return ???_cast&lt;uintptr_t&gt;(x); } your only option is a C-style cast. My particular case was a bit more complicated, but the example demonstrates the core of the issue. 
My largest complaint with CMake (outside of the dreadful language as the article notes), at present, is the really patchwork support for features. For example, compiler features are supported for Clang and GCC, but not Intel, Fortran is supported with Makefile-based builds but not Ninja-based builds, etc. This leads to lots of platform and toolchain specific code in CMakeLists.txt...
Another PVS-Studio advertisement?
Bjarne discussed the current status of this proposal here: [Kona Standards Meeting Trip Report](https://isocpp.org/blog/2015/11/kona-standards-meeting-trip-report) Search for "Unified call syntax" (at about 2/3 of the way through).
&gt; The other way, x.f() to f(x), will not be accepted for now; we will revisit that once we have **modules** It sounds like they want to wait until modules has been properly done before doing x.f() to f(x). But they are ok with f(x) to x.f() &gt; The extension methods proposal (P0079R0) was rejected; many thought decorating functions to make them callable was ugly, special purpose, and backwards. We may be able to do better with **modules**. They say ugly. I took a look at the proposal and to declare an extension method you declare the first variable name to be `this` like so bool begins_with(const std::string* this, const std::string&amp; substring) { return this-&gt;compare(0, substring.length(), substring) == 0; } Now you can do `string.begins_with("something")`. I don't know looks clean to me. The modules proposals are probably much better that they are waiting for modules. Thanks, My curiosity is satisfied, now I know why this hasn't been accepted yet.
In Windows\Visual Studio you can make NuGet work for native libraries, but it's kind of a pain in the ass, and you'll probably have to host them yourself.
Creating NuGet packages for native libraries is a pain in the dick, though.
Yea, unfortunately, biicode failed. I quite like msys2's pacman on Windows, it's really awesome, and has lots of software in the repo and it's kept up-to-date! (boost, eigen, libpng, opencv, etc). It's of course mingw-64 and not "native", so VisualStudio still needs another solution. So yea, something like bower/pacman on Windows is what we need. There's chocolatey, but I haven't tried it out yet. It looks kinda good though!
Holy!... Pacman on Windows is exactly what I dreamed about!
Hmm, so you're saying meson will require a lot less boiler plate? Biicode looks alive to me, although too commercial for my taste. 
Yes, msys2 is really awesome to do development with gcc and/or clang on Windows :-) And really easy to install all the required stuff &amp; libraries. Also works well with CLion, if you want an IDE. It doesn't help with VisualStudio library-dependencies and deployment though unfortunately.
I don't think that's quite right. Go is supposed to be helpful for large scale development, but not necessarily large monolithic applications. My understanding is it is designed to be useful for large numbers of developers each touching small parts of a fast changing environment. (e.g., someone makes a change to a shared internal library, and then the numerous client microservices are easily updated.)
How are compile times with mingw/cygwin on Windows vs the comparable environment in Linux? I attempted setting up CLion on Windows, but it seemed much much slower. I wouldn't put it past myself to have misconfigured either mingw or cygwin though.
I'm curious - do you use Intel compilers? If so what general line of work or field do you use them in?
I will look at the `CXX_STANDARD` one tomorrow. See what I can figure out. I was able to confirm the issue, at least.
In my opinion, UX. Working with biicode from scratch with new projects worked great (Was cmake simplified with magic), but integrating existing huge libs was a pain, even those which were already using cmake. (Disclaimer: I was part of biicode team) Edit: the dependency problem cannot be solved in C and C++ in a feasible (I.e. non tricky) way until the language itself would export metadata enough about dependencies, ABI, etc. The problem is not about inferring / detecting deps, that's easy. The problem is linking. What exact ABI are you using so we can decide what binary to download. That's one of the very first reasons why modules should make it into the language
Hello jpakkane: as a meson user, and I know it is not the place, but you already received my corresponding issues in the meson project. If you really want zero boilerplate, do justice to your own words and look at the cross-file issue I filled in: cannot set any variables. This generates *huge* boilerplate in developers machines (one for each developer/os combination worst case). Being able to use real meson code and setting options/env variables also in those cross files is what I recommended would be worth pursuing. I really want to keep using Meson, but I must have good reasons. CMake has a lot of appeal from the ecosystem point of view. This is constructive criticism, do not kill me. Meson is serving me very well up to now :)
&gt; I mean, what I wanted to tell here is that I was f*ing amazed that in 2015 I had to implement me a function that splits a string. This is indeed one of the use cases of string processing that is not covered by the standard library. That said, you do not have to implement anything. You can just use boost (which could be called a "major big standard library that would handle everyday tasks from all walks of life in a consistent manner"). The library is not really standard (but it seems to have become a de-facto standard) and the "consistent manner" is not universally consistent (boost is a collection of libraries, not a single one) but it is generally stable code, with a decent design. 
Doesn't cover the using-declaration, template alias, namespace alias, inline namespace, unqualified and qualified name lookup rules and their interaction with overload resolution, nor ADL. This is not even close to complete. And `&lt;conio.h&gt;`? Inexcusable. 
Clang seems to be [in the process of implementing some checks as part of `clang-tidy`](https://github.com/llvm-mirror/clang-tools-extra/tree/master/clang-tidy/cppcoreguidelines).
Any news of the static code analysis part on Windows yet? I've not managed to find such a thing.
If variables are zero initialized implicitly does that mean no more compiler warnings for uninitialized variables? Because that's worse.
Have you tried MXE to cross-compile Windows applications on Linux? We can probably do all dependency stuff on Linux, compile on Linux and then just bundle the whole thing with dependencies as Windows platform used to.
Yeah I'm not saying it's a good alternative, just mentioning it. We toyed around with using it for our native 3rd party dependencies at work, and it was just going to be prohibitively expensive to get everything working. And I don't know about good support, but there's no reason I'm aware of NuGet wouldn't work on any platform, the packages are just zip files with xml and files inside.
It is indeed accurate. And it is too long for a type that should be used everywhere. It discourages widespread use. There's a reason we have `char` instead of `character`, or `struct` instead of `structure`, or that Python has `dict` instead of `dictionary`. It's the same reason your friends might call you "Bill" instead of "William Henry Gates, the Third". Names in common use need to be practical. For common names, superfluous verbosity is a bug, and the accuracy is not a feature. When Bill is everywhere, everyone knows who "Bill" is. Everyone knows what `char` and `str` stand for. I don't care if `std::string_view` is `seq` or `sv` or `strv`, but it should be so common that everyone knows what it stands for.
Libstdc++ still doesn't do logarithmic index_sequence
I've never heard of MXE - thanks for mentioning it! I had a quick look. The packages seem to be a bit out-of-date (boost 1.57.0, OpenCV 2.4.10) and the website looks pretty stale. Their Github looks active OTOH! To be honest I only had a very quick look and haven't fully understood what it does and how stuff will then run on Windows. I guess I'd have to try it out :-)
My code-bases are rather small-ish, but it seemed fine to me with msys2-mingw64 and CLion. Then again I'm used to MSVC compile times and I think I've heard it's pretty slow. :-)
A sequence of characters in memory. You don't have to use this name, it's what I have chosen for myself, and it works for me. What I *am* saying is that we should have a lightweight reference (`string_view` works) and build a library of string reading functionality around it (rather than around null-terminated strings or `string const&amp;` references), and that we should use this lightweight reference universally. If you want to refer to this as `string_view` everywhere, I don't have a problem with it, but I do think it's going to hurt adoption.
There should be an "Other" option which could allow people to add other IDE-s, I'm using KDevelop.. and when Sublime is an IDE then Kate could be there also.
I have a preliminary patch to add `CXX_STANDARD` support: https://gist.github.com/morrisonlevi/55e6e336e8b11d6ecd3b. It seems to work but this is my first CMake contribution, so I don't really know what gotchas may be present. Going to try to send it to the ML and get feedback.
Perhaps a lesson can be taken from D, where the choice was made to initialize by default, while making uninitialized code possible but explicit: int i; // will initialize to 0 int j = void; // will remain uninitialized
Actually, they can be chained if you use streaming syntax (`operator&gt;&gt;` in this case).
I find basic overloading of `operator&lt;&lt;` and `&gt;&gt;` somewhat acceptable, since this pattern is well understood. However, what you seem to have in mind is instantiating function objects called by an overloaded `operator&gt;&gt;`. I find this to be closer to "abuse" than to "use" of the language. What would have been a simple function call now becomes a "neat trick" that a developer has to be familiar with, in order to properly understand what's going on. Since my main complaint about free functions is the loss of readability, I'm not sure that the solution is a trick that makes it even *more* difficult to plainly perceive the mechanics of what's going on.
&gt;To develop native Windows applications, for example, the best solution people have come up with is copying the source code of dependencies to your own project and hoping for the best. Funny, I never did this, and I needed to build and/or use dozens of dependencies. In fact, just recently I was salvaging one mess left exactly by people who thought what TFA thinks to be a good idea. I mean, really... 
That's fair enough. I only brought it up because a core part of your argument was the naming scheme, and I view it as a non-issue.
At its core, that is exactly what Meson has.
&gt;printf is faster than cout Turn off C and C++ streams synchronisation, increase buffer size and suddenly C++ streams can outperform C streams.
A good place to start is to ensure that the build system executable(s) only depends on the native tool(s) of the language itself. In this case a c++ compiler/linker.
&gt; Also CMake does not do dependency providing and downloading The ExternalProject module actually can download projects, in addition to configuring/building/installing them.
I think it's supposed to be a beginner's tutorial, isn't it? It should maybe more clearly say so. `conio.h` is indeed inexcusable ;-)
I don't know if that holds true if you use multiple &lt;&lt;s or if you invoke a flush via std::endl.
I agree with other commenters, this is the worst post I have read for a while. Just an additional note: He talks about algorithms and data structures to optimise code. That's not optimization, that's picking the right algos for optimal program **eficiency**. Performance, what optimising involves, is about how fast you can get a task done. Efficiency and performance, algorithms/data-structures vs optimizations, can be affected between (see the cache problem and how this makes us pick performance against theoretical algorithmic efficiency). But please don't confuse them. Picking the right algo or data structure is not an optimization. Period.
The problem is not the post itself but the title. Never title something as "all you have to know about X", mostly if X is one of most complex programming languages. Anyway, maybe I'm being a bit immature, but seeing conios always makes me happy...
&gt; I don't know if that holds true if you use multiple &lt;&lt;s It is just like several output statements. Potentially it can be inlined optimised and stuff like that. At least its speed will be comparable with printf. &gt; if you invoke a flush via std::endl. Same effect as if you did `fflush(stdout)` If you need flush using iostreams, you will need it using C streams. If you do not need it, then you should not use it in the first place. Honestly, `std::endl` is overused in learning materials. [cppreference](http://cppreference.com) agrees on that and takes care to not use it when not needed.
This is horrible.
That doesn't get you very far. You cannot use that for parameterized reads, like "read until this character", or "read until the first character that's not one of the following", or "read until this substring". This is unless you put the parameter into the object before using it to read; in which case you are using a function object scheme.
Oh yes you're right regarding the title, completely agree with you. Good point.
This looks like dunning Krueger syndrome. I'm not sure why this person thinks they should be writing an article on optimization. A lot of this stuff will never make a big enough to even be measurable. Modern processors have multiple pipelines so things like the intenger increment and comparison of a loop are essentially free. A better guide would be: Don't worry about it until you need it. Profile Probably take out lots of memory allocations Probably reorganize some things for cache locality Parallelize Look into SIMD The overarching rule of thumb ends up being to do things in larger batches.
Call me shallow, but I stopped reading after I saw #defined constants in the first snippet. 
I bet the author hasn't measured any of the items mentioned in the article.
Yeah, I use Netbeans more often than Eclipse, though I use all three major Java IDEs at times. Also, no differentiation between what languages developed in which editor/IDE, which is probably significant.
I really like the idea of a copying unique_ptr. I have trouble getting your multi-level template version to run, however. I assume you only tested it under C++14 given that you're using make_unique directly? Still, the instantation methods I have tried all failed for me. I have adapted it a bit and taken it back to be specific to unique_ptr and added a constructor from T*. This one works (or seems to work) in C++11 as well. The code is here: http://ideone.com/HyoDyq Can you comment on this? It should be as safe as your version, just less general (explicit for unique_ptr), am I right? Can you show an example construction of your version? edit: as you point out in the discussion here, both versions will require clone methods to support polymorphism, right?
I also did a [talk](https://github.com/taocpp/tuple/raw/master/Variadic%20Templates.pdf) about this on 2015-11-12 in the C++ User Group in Aachen, Germany.
I find that for generic c++ netbeans with the c++ support is great. At the time I started using it, it was the best option for c++ on Ubuntu Linux, and I've seen no reason to change. KDevelop was suggested to me but I couldn't get on with it. I've heard monodevelop supports it as well but I've not tried that.
I think he wanted to say "the easiest and laziest solution".
The problem is that when you do that it is hard to keep your deps up to date. Security vulnerabilities due to obsolete third party deps are quite common.
ahh, let me know if you find one :) that don't abuse the preprocessor
It depends on the libs, boost have autolinking so its easy, but usually is need to specify what lib file to use, is need to take in count /M[TD]d? linkage, Unicode/UTF8/ANSI charset etc., so is easier and lazier to just include library in your project and it will build with same options as the base project.
Where I work, we build our stuff in a dozen configurations. We also build some/most of our dependencies in same build configurations. We use the project "macros" $(Platform), $(Configuration) to select the correct library path (and include path, but occasionally). To me, this is all trivial and mechanical (and beats adding random 3rd party source files to the project!). What we do is obviously not standard across our 3rd party dependencies (as there's no "standard" on that level), but it is most certainly standard to us, we make it so. In the end, it boils down to "add include files in your include paths and your lib files in your lib paths".
http://en.cppreference.com/w/cpp/io/basic_streambuf/pubsetbuf I do not suggest using it, until you really sure it will do more good than harm.
Pheraps I should write a wrapped around std::string as any other user defined type... This would be dull but I haven't any good idea. This is the first time no one answer a question of mine so I think, the one presented above, is not the right way to move. Any comments? 
maybe, another option would be to allow using `_` as python and other languages do: auto {_, x} = f(); There is nothing in the paper about this particular situation, which I guess it is a fairly common one. Another thing missing IIRC is how to apply attributes to the different elements of a function that returns by tuple, since e.g. the `[[must_use]]`` attribute might be required only for some of the elements of the tuple. 
I don't have source right now. My copy of 03 is at home. But you could use classes and such within anonymous namespaces as template parameters, which required external linkage. So if it's not specified explicitly it's required by that requirement.
Seems that they forgot to escape the characters '&lt;' and '&gt;'. The title of P0092R1 looks strange :)
[P0158R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0158r0.html) "Coroutines belong in a TS" is probably the most entertaining one.
Indeed, in this scheme the object knows when to stop, not the `seq`. Then again, an `int` knows when to stop too... ... I see string splitting as another issue altogether, as ideally you want to get *both* strings (before and after the pattern).
I wonder if "Disappointment Handling" will catch on ([p0157r0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0157r0.html))
On the other hand, we have the poetic [broken_promise](http://en.cppreference.com/w/cpp/thread/future_errc), the optimistic [get_money](http://en.cppreference.com/w/cpp/io/manip/get_money), and the brutal, but sadly unused, [kill_dependency](http://en.cppreference.com/w/cpp/atomic/kill_dependency). It's not all bad.
Ya that is a good paper. I was also baffled why the committee pursued the none composable C# coroutine proposal instead of the good one.
Yea, it certainly looks like they are in a real rush to get coroutines into C++17, while other things, like ranges or filesystem, go forward very slowly...
How come you have Crungbang Linux in there (what the .... is that anyway? :D) and not Gentoo? I feel a bit offended ;-)
&gt; The standard library version from libstdc++, when trying to create index_sequence&lt;5000&gt; and with its O(N) implementation, requires ~30s, &gt;3GB of RAM and -ftemplate-depth=5100. Fun fact: just today libstdc++ trunk [got a minor patch](https://gcc.gnu.org/ml/gcc-patches/2015-11/msg02136.html) which, for me, improved time of `std::make_index_sequence&lt;5000&gt;` from 30s to 0.9s. No idea why it's still much slower than yours, though.
http://vignette3.wikia.nocookie.net/simpsons/images/c/cb/Comicbookguy.gif/revision/latest?cb=20120624090208
I suggest listening in class and then looking up the keywords and information given to you in the task, all the information for this can be found on cppreference and the like. Do not ask for assistance if you are not willing to take the time to attempt the task yourself, had you asked for for help on problems that you face while doing this I'm sure people would be must happier to help you. Reddit is not the source for your homework.
Great job with this EP. Andrei is entertaining, and you guys covered a nice gamut.
Not really a coincidence: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66059 Edit: You could add a comment with your timing of the current version vs. mine, maybe they'll reconsider. I'm actually a bit disappointed due to the lack of interest from libstdc++ and libc++. I offered to work on things (e.g. std::tuple, see https://github.com/taocpp/tuple), but I feel like I'm mostly ignored and they don't really care about getting more people involved. :(
I had the same reaction! WTH is Crungbang... and where is Gentoo ???
did you submit bug reports to gcc/clang? I also found the response time to seemingly simple bug reports rather long (considering that 66059 was filed 6 months ago!).
It's required by a lot of WinAPI functions, which is (whether you like it or not) the most popular API for the most popular OS.
Good video on how google is using clang to do refactoring like this at scale (e.g. transforming 100000+ calls to a function): https://www.youtube.com/watch?v=ZpvvmvITOrk
[Here my are exact results.](https://bpaste.net/show/cc954d268cb3) I can post them if you think they'll be useful. Edit: done.
Some time ago I bloged about compile time integer sequences here https://ngathanasiou.wordpress.com/2015/02/19/compile-time-integer-sequences/ (just a gentle introduction). While on this project I found an implementation by Xeo : http://stackoverflow.com/a/17426611/2567683 . Isn't this the one you use in the "logarithmic approach" ? 
no new features, just compatibility with VS2015. I cant see any advantage on develop native win32 ui
Please do. 
It's actually quite pleasant with WTL. What is really lacking is solid support for custom components. For instance, there's no grid control and the open source solutions aren't amazing. 
Unless the first 9 tips are "measure" and the last one is "use std::vector", I'm not sure I'm that interested... 
Yes, that's essentially the one from the initial logarithmic approach. The final form follows naturally once you know what to look for. I first ran into that logarithmic approach in the utility toolbox of Eric Niebler's Boost.Proto v5 [here](https://github.com/ericniebler/proto-0x/commit/c8d6d2bc0529c0a85d9deb08464fffa22b28a7a3#diff-d577da2e16b39628a18ba1946286efcaR208). He, in turn, got it from Dave Abrahams' research on a Boost.MPL11 [here](https://github.com/dabrahams/mpl11/commit/fa0b3f6e0fc31cb781dbba68a111db7ff8f73e12). If memory serves me right, it was somewhere during 2012.
See http://moderncpp.com/
Are there any serious projects developed using moderncpp? Can you still run executables on Windows XP?
Not that I disagree, but WTL is by far the best Win32 UI library I've worked with. Even Google uses it for Chrome browser, and (unlike MFC or even WPF) Microsoft uses it for a few of the Office products. It is very lightweight and does not impose a framework.
Thanks for the sources. It's very interesting to see how a good(++) idea propagates through different projects. I like your blog, wish it had space for comments or discussion because you touch upon interesting topics and it's hard(ish) to reach you. 
I knew something of this from before, but this is a nice and terse summary of the many issues in automatic C++ code transformation. What I've been wondering is how CLion does it? Unfortunately, I got distracted and ran through my demo month with them - I did get the impression it was using clang/LLVM to do some of the heavy lifting, does anyone know more?
Good question. Glad you asked! UML is now an outdated idea which nobody uses in practice. I have seen many talks where people are asked to raise their hand if they use it and nobody does! I never seen it used in real projects and it's worth thinking why. My own conclusion is that there are two major issues with UML: 1- It is literally only eyecandy for what you "already" have in Object Oriented languages. A 1 to 1 mapping. So no added value. 2- As a language, it is only Object Oriented. Guess what, most concepts in your/my head while we are coding are not really about classes and objects. They are about how we can tie up this functionality into that functionality and get a new feature. OOP is just there to make this easier but if I want to visualise and tell you about the programs I have written in the past 20 odd years I would certainly not talk about classes or objects. I would talk about functionalities and abstactions that have meanings for the Application's end users.
Great video. Just a few questions? * What version of Clang will be shipped with Update 1 for Clang/C2. Also, are there any work in progress limitations with Clang/C2 in terms of debug symbols, exception handling, etc * Which of these features will be "Go live" supported with update 1 * IIRC you mentioned having a goal of being able to compile Eric Niebler's Range library. Are we there yet with Update 1? What about with using Clang/C2? * Any ideas of when to expect variant in GSL? Thanks. 
Is Update 1 released?
Being good or great at a language depends on the context you're using it in. It's certainly not one size fits all. I feel like I have a proficiency for scientific computing but couldn't organize a GUI for the life of me. 
If anything, Visual C++ as a language would be C++ with MSVC language extensions.
You may try to partcipate in any well-established open-source project. There you can gain a lot of experience and see how well your skills fit the needs of real world projects. 
Proficiency to me would mean that you can find an efficient solution to a reasonably complex problem specifically in that language. For this, you would have to have an understanding of the standard (so you know what tool to go to, or what to search for that is in the standard), know how the language behaves in certain cases (so you know how to make the most of it), etc. This is not something that happens overnight, but through experience; i.e. writing code. Generally speaking, class projects are not enough by themselves to make you proficient in one language. A good source of experience is a complex codebase.
May it die a quick death
So it's not in Update 1 RC, but it will be in the final Update 1 (as a preview) - is that right? (So the instructions Steve gave here, are actually not possible to carry out yet)
http://clang.llvm.org It's decent C++ code, relatively easy to get into, and there's opportunity to learn as much about C++ as you could possibly care to.
Even if you are speaking of proficiency in C++ (as opposed to proficiency in programming as general, that's something completely different) I think in most cases 1.5 years of study in class is not enough to gain enough experience to be truly proficient, though probably you are on good path. C++ have many intricacies. I've heard a joke at work that most students estimate their knowledge of it as 90%, and after while graduates lower that to 40%. You can check out http://cppquiz.org/ - they have few tricky questions about language - some are bit pointless, some are somewhat important. Or think about some existing libraries - for example can you replicate std::function, or std::bind ? That being said, 'proficiency' is somewhat relative and inexact term. &gt; if not at what point can i say that? I think I've reached the conclusion that I'm proficient in C++ about 2-3 times till now, and shortly after each time I needed to reevaluate it, because I noticed that I still have many things to learn.
You are confusing `std::deque` with `std::queue` (or possibly `std::priority_queue` or `std::stack`, the only three container adapters in the standard, IIRC).
Works just fine, I use vagrant and shared folders for my source, so the CMakeLists.txt file is shared between vms. I created the GDB project manually, included it as an external project when running on windows, if(WIN32) #include windows project for debugging GDB INCLUDE_EXTERNAL_MSPROJECT(MSvcGDB "${CMAKE_CURRENT_SOURCE_DIR}/linux/MSvcGDB/MSvcGDB.vcxproj") set_property(TARGET MSvcGDB PROPERTY FOLDER "GDB") endif(WIN32) set up the project build with a shell script somewhere for build.sh, rebuild.sh and clean.sh build.sh pushd /build/linux/ make popd clean.sh pushd /build/linux/ make clean popd rebuild.sh pushd /build/linux/ rm -rf * cmake ../.. make popd then when you hit build it builds on both windows and linux simultaneously.. :-) you pick your start-up project to decide what to debug. apart from a few foibles about not being able to choose an ssh port, and the output from the debugger not converting to CRLF, it works a treat. 
What you think is best may not be what someone else thinks, just be consistent. I prefer void function(){ first_instruction(); second_instruction(); }
Sure. That's why I asked here, if this had been asked on SO it would have been closed right away.
For me arguments about spacing largely turn in to [bikeshedding.](https://en.wikipedia.org/wiki/Parkinson's_law_of_triviality) The most important aspect or utility of spacing is ignored. Spacing should be used to express grouped intent. For example: void function(){ /* these functions are placed together as it adds semantic meaning to the code */ function1() function2() /* this integer and it's functions are linked together */ int i someotherfucntion(i) cleanupfunction(i) /* I'm near the end of the function so it's clean up time */ totalcleanup() } By grouping things together you help the reader. This is much cleaner than the (false) doctrine of placing the two subblocks in the above function in to their own functions. Functions imply re-usability and that's not always the case. Even without the comments it's a great hint to the reader that there are three logical parts to this function. Basically the placement of braces is not important as long as it's **consistent**. As you get more experienced it makes no difference to how quickly you read the code. I've worked in all styles you could imagine and none are "better" once your beard is long and grey enough.
&gt; 6) GSL support Rules from which CppCoreGuidelines profiles will be initially supported? Will be supported lifetime safety profile?
The first release of the Core Guidelines Checkers will include checkers for the Bounds and Type profiles. We're working on the Lifetime profile checker--the tool demoed at CppCon--and hope to include that in the Update 2 timeframe. 
Do you use any open-source software in everyday life? If yes, the just fix bugs in it or add couple of new features. Otherwise, there are thousands of them (Github is full of them), pick what interests you most.
Amusing: clicking on "What is Recursion?" now links to this page.
I think we are arguing for the same team. What I mean is. &gt; void myfunc() { &gt; &gt; } vs &gt; void myFunc() &gt; &gt;{ &gt; &gt;} 
Having gone through both P0114R0 and P0057R0, I feel that Gor's proposal is more powerful and theoretically sound. * It looks to me P0114R0 is not actually a proposal for coroutines, but only for generators. You can implement coroutines on top of generators, but they are not very efficient. P0057R0 is definitely more efficient, since its easy to go the other way. * The await mechanism is much more theoretically sound. It is basically the do-notation of Haskell, with 20 years of theory behind it. Await can be used for any monad like optional / expected, not just the continuation monad. P0114R0 offers no such general mechanism. I am by no means an expert on this topic, so I would like to know why you prefer P0114R0.
&gt; You can check out http://cppquiz.org/[1] - they have few tricky questions about language - some are bit pointless, some are somewhat important. More in this spirit: * http://www.pvv.org/~oma/PubQuiz_ACCU_Apr2014.pdf * http://www.pvv.org/~oma/PubQuiz_ACCU_Apr2013.pdf * http://www.pvv.org/~oma/PubQuiz_ACCU_Apr2012.pdf * http://www.pvv.org/~oma/PubQuiz_CPP_Oct2011.pdf Also worth going through: http://www.pvv.org/~oma/DeepC_Geekup_Oct2013.pdf Source (with the links to videos): http://olvemaudal.com/talks/
[C++ Core Guidelines - Naming and layout rules](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-naming) is a good start.
&gt; &gt; &gt; Also worth going through: http://www.pvv.org/~oma/DeepC_Geekup_Oct2013.pdf Who the hell thinks that -Wall and -Wextra is enough ?
Thanks, oh just wanted to add that initialization lists make things even worse: Constructor() : init_var1(whatever), init_var2(whatever2) { ugly_as_hell(); } That is a case where I really would like to break the convention and use a less-space-sparing but surely better looking brace on the other line after the signature
I've personally found that the "be consistent at all times" rule for code formatting just leads to bad situations like the one you've listed here. I prefer "formatting is context-dependent, use whatever is most readable". For constructors I format like: Constructor() : init_var1(whatever), init_var2(whatever2) { less_ugly_as_hell(); } Although it works better [when combined with horizontal comment separator markers](https://gist.github.com/jrandom/08048c79ce0c752e9160).
nagol93, I'm assuming you are asking this in the context of a résumé/interview situation. If that is the case, I'd try to avoid a label (you can't alway avoid the label) and be specific about what experience you do have. You can say something like, "I've taken N classes in which C++ was the implementation language and I did M significant class projects." I would then try to paint of picture of what language experience/knowledge you have: "I'm comfortable using STL containers and algorithms, but I've not extended the library or created my own containers. I been using C++11 and Boost, but I've not done any meta-programming or used threading." Or whatever is appropriate for you. Notice that this is what you did in your question to give us a picture of your situation. You told us how many years of class experience you've had and then told us about a couple of specific skills you have mastered. That is what you are trying to do in an interview. You don't want to oversell. If you just say, I'm proficient in C++, the next question might be, "How would you solve this template meta programming problem...?" (You might also talk about the skills that you don't have, but that you consider your "next step." This shows that you are aware of your limits, but are interested in pushing them and learning more.) I very much like what Kaosumaru said about students estimating their knowledge of C++. In my interviewing experience, I would ask the candidate to self-describe their C++ knowledge before asking any C++ questions. Students almost universally grossly overestimated their language knowledge. In fact, the ones that knew the most were usually the most modest in their self-description. They knew what they didn't know. Just as you said in your question: "there [are] many things that [I] don't know how to do." Also, I wouldn't over emphasis how you compare to your peers. You can mention that "I'm at that the top of my class" without be-laboring it. You don't want to create the impression that you are not a team player because you think you are smarter than everyone else. (Even if you are smarter than all your classmates.) I know that you didn't ask this, but I want to give you some unsolicited advice. Programming involves a lot of skills and among the most important are written communication and attention to detail. In the question you posted here, I stopped counting at 15 errors in grammar, spelling, or syntax. What impression of you do I have from reading your question? * He is probably pretty smart (I get this from the content, not how it was written) * He is sloppy and doesn't pay much attention to detail * He doesn't think that clear written communication is important * He doesn't think the rules of syntax and grammar apply to him * He isn't respectful of other programmer's time even when he is asking for advice from more senior programmers Are these observations correct? Possible not. Are they fair based on what you wrote? You might say that you can write correctly and clearly in a detail-oriented way when it is appropriate, but this is just a reddit posting. Correct English isn't required for a reddit posting, right? Look at the answers that you've gotten from the professional programmers whose advice you sought--the people that you hope to work with some day. They have responded in complete sentences and with correct spelling and grammar. As I said, this was unsolicited advice, you can do with it what you will. Jon 
I agree with Centerius on this. Operations involving both signed and unsigned types have results that are sometimes surprising even to experienced programmers. This means that you should either use only signed or only unsigned in your code base. Since any non-trivial code will involved negative values at some point, using only signed types for numbers is the right choice. Save unsigned for bit masks and non quantitative uses. Or as Bjarne has said, "Only do math on signed types."
totalcleanup(), like all clean up code, should be in a destructor.
I'm not sure I understand your point. -Wall and -Wextra cover a great deal of the typical linting issues most programmers will encounter. Of course, there is a crazy long list of warnings you can enable (some of which, like -Wsign-conversion, I feel *should* be enabled by -Wextra), but they cover very specific issue that don't necessarily have an effect on correct code (e.g., -Wshadow).
It does not come with any string or collection classes. 
I like the idea about defining a simple format for defining programs. I have attempted to do this with the OovAide program, but I am sure it is very lacking and restricted except for certain types of programs. I still need to write up a document about how it works. Some of it is defined here [OovAide User Guide](http://oovaide.sourceforge.net/userguide/oovaideuserguide.html#mozTocId813985) and here [OovAide Build Design](http://oovaide.sourceforge.net/design/OovaideBuildDesign.html). I am curious about what the actual problems are that you are having with builds. It seems like two definitions are needed, and I am not sure which problem is more difficult. One is how to define something about how to incorporate a project into another (the external definition as in pkgconfig), and one is for how to build a project.
In my own experience, once I switched to a larger font size (12-14pt) due to getting older (+30y) I suddenly started to prefer less blank lines and the opening brace on the same line. Hence it's not too far fetched to think that in many cases when people prefer blank lines, it's just because the font they're using is too small to be comfortable. Currently I fit approximate the same amount of code in size 14pt on my 24" monitor as my colleagues who use 10pt fonts because they insist on blank lines everywhere (and double blank lines between functions!). Except that my screen is way more comfortable too stare at for 8h day.
Simply: `printf()` must parse format string at run-time, bind arguments, etc. In iostream all the format is already included in call tree. Iostream is only slow while using locales.
I'm glad to hear that care and want to be correct. English is much more difficult than C++. Here are some tips. "I" is always capitalized. "Just" is spelled with a "u." Some word processors have grammar checkers. You can use one of them to compose your message and then cut and paste it into reddit, source code, or anywhere that you want to write English.
I could not pass the interview. I was asked about the threading concepts in C++ and how they are implemented internally. I could explain from my basic comp science knowledge. I terribly failed how it's designed in C++ :(
Now you know what to teach for the next interview :-)
Worst, Terrible, Library?
Read this. Only the suspend up model is already a deal breaker for me (it is inherently non-composable), but there are more things: http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/p0158r0.html About efficiency, I am not sure I understand everything well, the topic is complex, but, look at this: http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/p0162r0.pdf
Why do do you consider P0057R0 model to be non-composable? Monads can be composed through bind. So I do not see why await cannot be composed. You should take a look at the paper "Monads and composable continuations" by Wadler if you feel you are interested in the the theory, its a good place to start. Honestly, p0158r0 reads a bit FUDish to me. It seems to say: "Lets wait for the perfect design". It ignores a) there is no perfect design and b) people have been using do-notation in Haskell for over 15years and await in C# for over 5. Everything in life has risks, whether the risks are worth the returns is the question. Lets take a look at the risks in the paper: * [2.8.1 Maintenance Risks] - This sounds familiar. The old "monads are viral" argument, around for as long as monads have. All monads are viral, not just the continuation monad. And its a **good** thing. One look at a type signature makes it clear what I am dealing with. In Haskell you even have to make side effects explicit in the function signature (the IO monad). * [2.8.2 Security and Performance Risks] The particular example they gave seems to be solvable by tweaking await_ready to return false after a set period of time. I am not sure how important the issue of jitter is in practice. * [2.8.3 Correctness Risks] Yes, there is no guarantee that a particular continuation will be called on the original thread. I doubt how critical this is in practice, except for GUI work. They talk about C#, but to my knowledge C# also only does it for GUI threads. Other continuations can be called on any threadpool thread. And its easy to do this for GUI work, since GUI's already have an event loop. So, in conclusion, both my earlier points stand. Await based designs are both more general and more performant than generator based designs. Await design is also more theoretically sound. I do not see why we should prefer P0114R0 over P0057R0.
&gt; The compiler offers more simplified development via single source execution, with both the CPU and GPU code in the same file. The compiler automates the placement code that executes on both processing elements for maximum execution efficiency. I'm really interested in what solutions they've come up with in terms of handling (or alleviating) data synchronisation between cores and so forth. That is pretty much the most problematic aspect of concurrent/parallel environments, both from a performance and thread safety perspective. [Unrelated rant: The implementation of that website is just piss poor. You can't even scroll the site with JS turned off. There is absolutely NO reason for doing that on a pure text article or blog content. If you're a developer who thinks implementing something like that is a good idea, consider becoming a gardener instead.]
it's probably also worth mentioning that we have detailed post about Expression SFINAE planned for when the bits are out that will show what works and what doesn't.
if you send me (scarroll at Microsoft) a simple but complete repro for that expression SFINAE issue and I'll get a dev to look at it. thanks!
It's extremely useful for testing. Imagine that you call a database service from some method. If you bind directly to it (or create it from inside the class), its much harder to test it by mocking out this service. If you are injecting your dependencies, your testing code can just provide a mock service. 
That is something I haven't ever heard before. Thanks for the new perspective.
Would you mind explaining this (dependency injection) to me? I'm a newer programmer and have never heard of this concept before. 
Still using WTL, ATL and ATL Server
A way to inject dependencies is through a constructor. In his database example, you could pass that database object to the class which uses it. It's nice when you want to unit test your code, you can pass a fake databse object, which won't do any connection, but will have the same methods. Or if you want to use another database engine (MySQL, CouchDB, etc...), you don't have to replace everywhere in your code. It's better to use this pattern instead of a singleton.
You cannot reuse any of the STL algorithms. They need to be await-aware. This is not true with suspend down model. U would need a family of await algorithms for STL with await. With suspend down u dnt need. That is what I mean by non-composable. Not compatible with normal sync functions.
&gt; [2.8.2 Security and Performance Risks] The particular example they gave seems to be solvable by tweaking await_ready to return false after a set period of time. I am not sure how important the issue of jitter is in practice. Well, I will give you a hint of how important jitter can be in practice: the SG14 group for real-time and low latency is investigating and there are many applications where they have network roundtrips of few milliseconds and they are measuring, as you can see in the paper for performance even at the nanosecond scale. There are even regulations for latency in the industries where they want to apply this kind of features. If you think this is not important in practice, you are negating or putting in doubt all these users of this feature. Namely: we cannot add things willy-nilly because they look nice for desktop or just average phone apps with no special requirements. If the feature can be made to escalate in the most demanding scenarios, including very restrictive real-time ones, that is the alternative that should be investigated, not one that is too experimental or subpar.
If you mean [This Third Manifesto](http://www.dcs.warwick.ac.uk/~hugh/TTM/TTM-2013-02-07.pdf) and [This Tutorial D](http://www.dcs.warwick.ac.uk/~hugh/TTM/Tutorial%20D-2013-05-23.pdf): This isn't really accessible material: they set no context, they are heavy on formal definitions that seem to reply on prior definitions, and there's a lot of *as seen before in this - or a completely different - book* references. So the questions may be asked: - why should one work through these? - What's so bad about persistence without relational theory? 
Hi. I am the author of joedb. Thanks for your feedback. Joedb is a relational database. It does not have a SQL query interpreter or compiler yet, but it would be possible to make one. It is even in the TODO list. The main point of joedb is not about being non-SQL. It is about storing a journal on disk, instead of storing tables. Right now, it is only a proof-of-concept prototype, and only the low-level stuff is implemented. High-level features will come later.
I did play with gigabase few years ago, but when I have try [Valentina db](http://www.valentina-db.com) I have to see real speed. It is columnar and that is one of reasons. It is SQL and it is nonSQL. They provide a lots of languages to support and one more magic - transparent switch between local embedded engine and true client-server. 
I wasn't really offering feedback on joedb, more making a general observation about the proliferation of DB systems that aren't relational. From what I can see JoeDB is really not relational in any sense as Cobb defined the term. SQLite is not even fully relational.
Useless bitching? Oh great thanks. 
You made me check the rules of Codd: https://en.wikipedia.org/wiki/Codd's_12_rules joedb will indeed never fullfill all these rules. I had no idea such fundamentalist relational religion existed. But I feel relieved that "no popular relational DBMSs could be considered fully relational", according to that page.
It just does some of that stuff for you.
It will pay off to learn to use Xcode for C++ on Mac (if that's what you're actually targeting). It's an awful IDE with finger twisting and difficult to memorize keybindings, but it's not practical to develop iOS apps without it. I know you didn't mention iOS specifically, but that's always a consideration. While you might not be considering doing that right now, you'll thank yourself later. Using Xcode on a laptop is pretty painful, so one trick to being productive with Xcode is using it on at least one large display and a full-sized keyboard. Also, the debugger is pretty good. 
I personally use Vim on Mac. If you want to develop apps for either OS X or iOS, it is worth your time to learn Xcode. I know some people use QT Creator as well.
Clion. It's spectacular 
I'm on linux, but I second vim. If you are willing to work with the terminal, and have the right plugins, it allows for an awesome workflow.
I use this config: https://gitlab.com/FJW/vimrc/tree/master
vim (MacVim), because I know what it takes to be cool
I use Qt Creator. It's a great C++ IDE, even for non-Qt code. It uses screen space efficiently, so it's usable on smaller screens. It's not perfect - no IDE is - but other than debugger support (which is, at best, tricky to configure on OS X) it's pretty solid. XCode is fairly complex, but if you're planning on doing GUI apps targeting OS X it's well worth learning. Eclipse is horrible. If you're learning C++, though, and aren't doing GUI apps right now, there's a lot to be said for using a (syntax highlighting) editor - I like emacs or sublime text, but anything that'll do basic syntax highlighting is fine. Then compile from the command line, build some hand-written make files, maybe pick up some lldb basics. You won't churn code out quite as quickly at first, but you'll get a much better understanding of the tools and process. With an IDE much of that complexity is hidden - which is great, until something breaks and you need to understand all the stuff it's hiding to diagnose it.
The key bindings are definitely annoying, but I'd hardly call Xcode an awful IDE. I spend all day at work with Visual Studio wishing I had Xcode's counterpart view (split view that automatically opens the corresponding .h file when you're editing a .cpp file). It's gold. 
I have a subscription to JetBrains' "Everything" subscription toolbox, so I've been using CLion. If you've used any of their other IDEs (IntelliJ IDEA, PyCharm, WebStorm, etc) it'll be very familiar.
Do you use any plugins? Do you use lldb within vim?
Anything but xcode
I'm new with c++, too. I'm starting using Eclipse that integrates gdb as debugger. It's not perfect but I'm getting used to it.
Linux/Mac/Window: Sublime Text 3 and [this](https://github.com/Dekken/maiken). It's works and it's simple.
Qt Creator or vim with proper plugins. Xcode is... well, Xcode. Qt Creator works very well with non qt projects too. 
I am not doing GUI apps. I will check out the Qt Creator.
&gt;I believe using the platform tools is the path of least resistance for avoiding bugs. If you use the tools used by the majority of the devs on that platform - in most cases any problems you're having someone else has already had and google will help. This is so true. 
I use SublimeText for basic text editing and QtCreator when I'm working with C++. IMO the best features of QtCreator are: * The generic project manager - the project file consists of a file that lists all the source files, a file that lists all the include directories and a file that has all the preprocessor definitions. I can generate these files programmatically for any subset of my otherwise large C++ project. I can also use any build system I want this way and even get compile errors as long as it acts like make. * Extremely fast indexing with good (not perfect) code completion - when using the default code completion model QtCreator can index tens of thousands of files in a minute or two on my PC. Other IDEs (Visual Studio, XCode, Eclipse) struggle with that number of files. * The Ctrl-K go to anything system - allows me to navigate files, symbols, do a git blame, etc. with one shortcut. * Cross-platform - On linux/osx QtCreator can use clang or gcc as the compiler and lldb or gdb as the debugger. On Windows it uses MSVC/cdb for compiling/debugging. * Basic refactoring that just works. I can rename symbols across multiple files which is so convenient. * The extra plugins have been implemented thoughtfully - there's a list of TODOs at the bottom, integration with VCS, etc. But no unnecessary plugins such as a terminal emulator.
YouCompleteMe is very good. 
You complete me with the clang plugin is good
Xcode for 'projects', so I can keep my header files organised. BBEdit for smaller stuff. GitHub Desktop and Cyberduck to supplement those when needed. Either way, I keep Terminal open for compiling, I found Xcode's compiler unreliable for projects I'm not building to an iOS device. There's no accounting for taste, but: * I find Eclipse bulky. * vim required so much set up to get it the way I wanted it, I lost interest as soon as the "project" of getting it configured was done. * Textmate's UI is ugly. * I don't remember why I didn't like Sublime. Xcode's autocomplete is beautiful, but I get along just fine with BBEdit's features, and I like the abilities to 'open terminal in this directory' and give really fine grained syntax highlighting for Python. 
+1 for CLion All of Jetbrains' products are incredible.
VS comes frustratingly close to having something comparable. The difference between having the header automatically displayed in the secondary editor and having an easy way to display the header in the secondary editor is pretty huge in practice. I bet it'd be relatively easy to write an addon to do it.
[yes, and exactly as you mentioned](http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/p0144r0.pdf)
I'm not a MAC user, but is there any reason why anybody would not want to use Xcode? I am genuinely interested in answers.
Probably because Sublime doesn't have great integration for C++ given that it doesn't do syntax-aware autocompletion. It used to have a plugin for autocompletion but it was discontinued.
[Updates from a recent revision](http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/p0151r0.pdf) * Syntax * `T&lt;M1 m1, M2 m2, ..., MN mn&gt; = (expression of type T);` * `T` and the `Mi...` are implicitly set to `auto` and may be omitted * Qualifiers of `T` will be inherited by each declarator * Can override qualifier by explicitly assigning one to a particular `M` * Declarators may be omitted * Example: `tuple&lt;int, float, const char*&gt;&lt;x, auto y, std::string z&gt; = f();` * Work w/ types that support `Sequence Decomposition` * So far, it looks like this could mean defining an overload for `std::get&lt;I&gt;` * `std::pair`, `std::tuple`, `std::array`, and simple POD structs are to support this * Nested Declarators * `struct Point { int row, col; };` `struct Rect { Point topleft, botright; };` `&lt;&lt;top, left&gt;, &lt;bot, right&gt;&gt; = get_rect()` * Copy Elision &gt; We also propose that given the variable t is not visible except through the sequence decomposition, that any copies should be available for copy elision. That is, if a temporary is created to hold t, and a copy construction is made from some ti to initialize mi, that copy construction may be elided (and so mi will just be a reference to the subobject within t).
When I d/l for linux it says "30 day trial".
Xcode - supports C++14, lets me group my files how I want (instead of forcing a tree-display split between headers and .cpp files). The last time I tried Eclipse I absolutely hated it (slow, bad UI design, etc...). Qt Creator is good (if a bit sluggish), but has the aforementioned forced split-files display. I'm looking at CLion as a possible replacement as I'll have to jump to Linux as a primary dev system if Apple decides to not implement Vulkan. Or if they continue this "we're going to replace how thread_local works but in the meantime we're going to disable it in our version of Clang before we have our replacement ready to go" nonsense, as I've got a thread-local freelist allocator I'm going to need fairly soon.
 Nerdtree, multiple-cursors, YouCompleteMe. Always within a tmux session. 
You have to register for an account with your university email. https://www.jetbrains.com/student/
But I'm not at uni! Damnit why can't I get cool free stuff :-( Just kidding. Thx for the info. Will give it a 30 day try. Intellij is fantastic so I have high hopes. edit: $89 - tempted even after seeing it autocomplete std::find with arg details.
I also own/love Clion. I have to admit that I can never remember the damn hotkeys in this thing though.
I use CMake so i switch between generating makefiles and xcode projects depending on what it is. I actually like xcode for cpp, but i might just be used to it from working with iOS on the side 
QtCreator default is very fast but linting breaks down for newer versions of C++, autocompletion is also very lackluster. QtCreator + libclang has really good linting and autocompletion but is super slow. Clion is super slow and also doesn't work with most of my c++14 code base, almost everything is red. Kdevelop5 looks promising but I haven't had the time to build it yet. 
Not objectively, but I, a spoiled one by Visual Studio, find it absolutely horrible.
Appcode works for that. It's what it is built for at the very least.
I don't use Mac, so this looks nice.
Yeah, I think that's correct. Do you know why people like Sublime?
It's a pretty powerful editor with very usable, sane defaults for most, and is also pretty customizable through its configurations and plugins. For beginners working on a project, it's easy to use Sublime's built-in project explorer and build system to get started and start typing out good code. For users looking to commit, it's very much a workflow thing. I much prefer (Neo)vim + tmux because it's what works the best for me and it's what stays out of my way the most, but someone who isn't into vim's modality and its "language" would be better-suited for Sublime.
what kind of apps are you doing?
I am learning C++ and I haven't dwelled on projects yet.
Thank you.
Had a problem installing it. I have heard of home-brew,might as well try it.
Linux: CLion, it has some minor issues as the memory, speed and other problems but in general is worth to buy it(or pay the subscription). WIndows: Depends, if I use UE4, Visual Studio, otherwise CLion. Mac: Xcode but honestly I ****** hate this son of a b***, slow, really slow but well I have to use it. 
PyCharm is probably the best IDE I've ever used for any language ever, and yes I have used Visual Studio
&gt; Yes, the static analysis tools show in Herb's keynote will be released in November. Are you guys still expecting a November release date? My team is anxious for the tool. :)
I just haven't tried, to be honest. Is it any good?
It does the job well enough, and then you wouldn't need to run rtags and irony at the same time. Though, irony shows the type which is really useful.
For Mac and Linux: I use Sublime 2 for all my programming, compiled via a makefile. For Windows: I have to the nearest Mac or Linux machine and never look back :) I find the multiple workspaces of Linux/Mac too useful. And while W10 has workspaces now, Ive not used a W10 system yet to test it out. I find that is works best for me because I move around a lot with my job, and its important that I can pickup my code anywhere and it will work. IDE's in my experience course more problems then they solve. Its just quicker for me to not use them.
My colleges oven quote me for saying: "I only know one vim command, how to quit." Sums up my experience on vim pretty well.
If you are learning C++ (or any other language) it is worth learning the details behind your IDE. That is, no autocompletion (muscle memory), no Project Manager (know your file tree structure), no autobuilds (learn Make or CMake or...), no any other autos until you learn some of the details IDEs tend to hide for you. That said, when you reach that point you can move to an IDE because you know what the tool is doing for you behind the curtain or use autocompletion just to save key strokes and not to "discover" names. P.S: a happy Vim user on every OS I manage.
Have a look at https://www.reddit.com/r/vim/comments/3sh7qo/vim_configuration_for_latex_writing_c_development/ and https://www.reddit.com/r/vim/comments/3pip79/are_you_willing_to_help_me_set_up_vim_for_my/ Plugins and vim configuration for C++ (and some other languages) were given in those threads
Have a look at https://www.reddit.com/r/vim/comments/3sh7qo/vim_configuration_for_latex_writing_c_development/ and https://www.reddit.com/r/vim/comments/3pip79/are_you_willing_to_help_me_set_up_vim_for_my/ Plugins and vim configuration for C++ (and some other languages) were given in those threads
I bought a license for CLion after working in IntelliJ IDEA in Scala. After seeing their products at work, I promptly bought three of them. CLion is still a bit new but I am super happy with my purchase. It is far superior to Xcode. Edit: Also, if your build system uses CMake already, everything works out of the box.
No KDevelop in IDE options :( 
&gt; The generic project manager - the project file consists of a file that lists all the source files, a file that lists all the include directories and a file that has all the preprocessor definitions. I can generate these files programmatically for any subset of my otherwise large C++ project. I can also use any build system I want this way and even get compile errors as long as it acts like make. It doesn't even have editable file system tree view which makes it extremely tedious. Creating files requires you to rerun CMake for it to appear in the project view and AFAIK you have to run CMake trough a custom modal dialog to pass CMake options &gt;Extremely fast indexing with good (not perfect) code completion - when using the default code completion model QtCreator can index tens of thousands of files in a minute or two on my PC. Other IDEs (Visual Studio, XCode, Eclipse) struggle with that number of files. Extremely bad code completion by default for modern C++, only usable when you enable Clang integration which is noticeably slow &gt;The Ctrl-K go to anything system - allows me to navigate files, symbols, do a git blame, etc. with one shortcut. It also doesn't have tabs and forces it's own paradigm that no other IDE follows. I use QTCreator on linux and I can't really say I'm thrilled. For me CLion is a superior IDE by most measures but it's still too young (only supports CMake, can't controll CMake output directory (which is actually important for me), renaming headers screws up include statements, etc.) and since it's not free it's not yet worth paying for - I suspect in a couple of versions it will be worth it, if they would integrate it in to IDEA I would buy it instantly even if it was a separate license - having a single IDE for my multilanguage project would be ideal. 
If you learn with an IDE you are able to get pretty far without learning how your code is translated and packed unto an executable. The good thing is you can concentrate on the language itself but you should make sure to go back at some point and learn about make, compiler and linker. QtCreator is a really nice IDE and pretty beginner friendly (aspecially on linux where it has always worked out of the box for me). I found Eclipse much more troublesome. 
&gt; It doesn't even have editable file system tree view which makes it extremely tedious. Creating files requires you to rerun CMake for it to appear in the project view and AFAIK you have to run CMake trough a custom modal dialog to pass CMake options. This plugin fixes this : https://github.com/h4tr3d/cmakeprojectmanager2 You can also pass options to cmake from the command line or the cmake gui, it will work all the same in QtC. 
If you're a student, email and ask 
Start from simple &gt; class X {}; &gt; X x; We have a single service, it requires nothing &amp; we can just use it. &gt; class X { X(Y&amp; yService) {} }; &gt; Y y; &gt; X x(y); We now have a service with a dependency. Where do you get it? You can just construct it just above it. Now assume that there are a few thousand of these services, all up to a point co-dependent. This file containing the startup logic is both fragile &amp; requires a lot of people changing it. But the dependencies between your services are actually relatively local - only the user of a class needs to mention it, and nobody else needs to know, strictly speaking. So we get a "dependency injection framework". Depending on how you do it or what your language allows, you can find an implementation for Y when your X is created, either created when needed, created beforehand in some order or similar. To start up a service you need, you don't necessarily need to know how to create its dependencies any more, nor how many it has, you can just use it.
I was using CLion for a bit, but I found it's error messages so difficult to follow, and it would frequently highlight non-errors as if they were errors. Xcode is far better with errors, but the editor is nowhere near as nice as CLion.. I'm so conflicted.
But you can't customize the code formatting like you can do in CLion. :(
I'm not a student, I was being facetious (which isn't exactly suitable for text forums!).
This is a better answer than everything in StackOverflow. I hate the "behavior is undefined so I won't explain the behavior you're seeing" brigade.
Feel free to contact me if you have any questions.
&gt; These strange values are things on the stack. Or in a register. Clang on 64 bit compiles that into just `callq print_int(int)`: first argument is passed through register per calling convention and foo is optimised away as unused. Or stuff that compiler decided to place there: GCC explicitely initializes register with 0 in this case. 
Xcode because I've been a Cocoa much longer than I've been doing C++ so it's what I know the most.
[removed]
`std:string s("hi");` isn't a syntax error; it's a label `std:` followed by `string s("hi");`
Why does cling care about svn metadata?
heh I don't know I would have caught that. somehow i've never encountered it.
Essentially what ROOT6 is built on. As a ROOT user for numerous years... this concept is fundamentally flawed.
incredible, but sloooooooww
What, you prefer doing COM without it?!
It probably embeds the SVN revision number into the version number in the binary. clang does the same sort of thing; if you build clang yourself and do `clang --version` you get something like `clang version 3.8.0 (trunk 253150)`. 
That is good to know - Cheers! I have very limited exposure to Windows 10, but next time I get a chance I will give it a decent chance. I've heard ssh is native too, I don't understand why its taken MS so long to add in these features.
Seastar is very cool but probably only necessary for extremely high-performance applications. Also much of the performance benefit comes from using DPDK, which requires special network cards. I would only use it if I was writing something with extremely low latency and high concurrency requirements, e.g. an order matching system. For a a run of the mill REST API server it may be overkill.
Whenever I just want to whip up a simple test, I just use one of the online compilers (my favorite being [ideone](http://ideone.com/))
Yeah, the samples and tutorials will have to come from the developers since I have not even seen the code myself yet. In all honesty, it will take me forever to even understand the code enough to write sample/tutorials myself anyway, considering my very limited background in C++. I agree that references should be there to sort of minimally cover all the bases for all existing functions, but realistically no one is gonna go through the references. I imagine almost all of my time being spent building the example pages. Any tools or resource pages you can point me to?
It's not a syntax error. It is correct syntax. The problem is that the identifier `string` -- *which was correctly parsed* is unrecognized. A syntax error is when the code does not comply with the grammar specification, i.e. doesn't get past the parsing stage. For example `x = y;` is not a syntax error - it may or may not be correct depending on whether things called `x` and `y` exist. However `a = ;` is a syntax error because there are no rules in the grammar that permit an expression followed by `=` without an expression to its right. 
I came here to mention how much better vim is with YouCompleteMe.
Yes, I forgot to mention Qt, even though I use it every day.
&gt; It could contain anything; garbage from memory, stuff from previous programs (although this is rare, and should be considered a security flaw) What does the OS do with freed memory? Ie in the case of this code: #include &lt;iostream&gt; int main() { int* ptr = new int(102); std::cout &lt;&lt; *ptr &lt;&lt; std::endl; delete ptr; std::cout &lt;&lt; *ptr &lt;&lt; std::endl; // If this didn't cause an access violation, what would it print out? return 0; } I assume the OS doesn't zero the memory once it's been freed, since if I didn't initialize `ptr` to a value, I just get random junk. But as you said, being able to read data from previous programs is a security flaw, even if it would be extremely difficult (or impossible) to exploit. If the OS scrambles the data in memory so that it actually is just random junk, why doesn't the OS just zero out the memory instead?
The author has been involved (among others) in the [CppMem](http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/) project, shared here before: https://www.reddit.com/r/cpp/comments/39u5hi/interactive_c11_memory_model_visualize_the/ Since the release, Mark Batty (coauthor) has also defended his PhD thesis, "The C11 and C++11 Concurrency Model", which is also a good read (at least thus far--haven't finished, yet :]) if you're into this topic: https://www.cs.kent.ac.uk/people/staff/mjb211/toc.pdf Notably, it has also received the [2015 SIGPLAN John C. Reynolds Doctoral Dissertation Award](http://www.sigplan.org/Awards/Dissertation/#2015): &gt; "Mark Batty’s dissertation makes significant contributions to the understanding of memory models for C and C++. The ISO C++ committee proposed a design for C and C++ concurrency that was not up to the task of capturing a realistic relaxed-memory concurrency model. Batty’s work uncovered a number of subtle and serious flaws in the design, and produced an improved design in completely rigorous and machine-checked mathematics. Using software tools to explore the consequences of the design, derived directly from the mathematics, it showed that it has the desired behavior on many examples, and developed mechanized proofs that the design meets some of the original goals, showing that for programs in various subsets of the language one can reason in simpler models. The standards committee have adopted this work in their C11, C++11, and C++14 standards. The members of the award committee were impressed with the quality of the work, the impact it has had on the standardization process for C++, and the clarity of the presentation." 
What about this one? https://github.com/ipkn/crow
How efficient it is, compared to fastCGI?
I wonder why it isn't much more efficient than netty. 
Actually at first I had curly braces in this example. I then removed them, because it seemed like I was intentionally adding noise to the hand-written loop code to bring my point across. So I removed them. In general I agree with you. Not using braces can become a mean trap.
&gt; alias. Sad to say I actually didn't know you could do this. Absolutely will be using this soon then. Thank you! 
And what about remote working?
this is crying out for a piping syntax of some sort, for example with the Collatz sequence example. The capitalized function names fly in the face of most coding conventions. The function names themselves don't seem that cleanly thought through. I get that it avoids clashes so you can import the whole namespace, but that doesn't seem worth the tradeoff. I like the concept, but the presentation makes it feel like a "this is a convenience tool for myself" than a robust library.
Qt Creator is pretty good. Xcode can be confusing for beginners due to the number of screen elements it has. 
We're looking for two experienced, modern C++ developers at [KCG](https://www.kcg.com/) to work on our automated trading system in Chicago: [C++ Engine Developer](http://chk.tbe.taleo.net/chk06/ats/careers/requisition.jsp?org=KCG&amp;cws=1&amp;rid=1762) [C++ Simulation Developer](http://chk.tbe.taleo.net/chk06/ats/careers/requisition.jsp?org=KCG&amp;cws=1&amp;rid=1763) I work on the simulation team - feel free to PM me with any questions about either role.
Managment by perkile
What was the reasoning for having predicate before container(s) in your function arguments compared to other libraries (`&lt;algorithms&gt;`, boost, Range-v3, etc) having container arguments before predicate?
Had a quick glance at the Readme, but not sure what it adds that boost range with boost Phoenix doesn't cover. Always nice to see some people pushing the use of algorithm vs hand written loops though
&gt; the presentation makes it feel like a "this is a convenience tool for myself" than a robust library. And you are [absolutely right with that thought](https://www.reddit.com/r/programming/comments/3u38pi/functionalplus_helps_you_write_concise_and/cxbgnih). :) Regarding the naming convention, there seems to be [some disagreement](https://www.reddit.com/r/programming/comments/3u38pi/functionalplus_helps_you_write_concise_and/cxca0wz). Personally I don't mind if something is written in snake_case or CamelCase. And I am surprised that this seems to be such a big deal for big parts of the community. Some operators would be nice, I agree. I did not write some yet, because I wanted to avoid #define. Would you mind telling me which function names could be improved, and do you have some suggestions? I'd like to improve the library.
I've started reading this. It definitely takes some time. But it's very well written -- certainly the most readable Ph.D. dissertation I have ever encountered (even counting my own :-). Based on what I have read so far, I would definitely recommend this to anyone who wants to learn about the modern C++ concurrency model.
Yeah. Redmond only at present
For API development I would only bother documenting public header files in detail and let Doxygen parse only those. It will keep your generated output free of clutter which users of the API would normally not care about.
I just don't know how to implement something like `|&gt;`, `&gt;&gt;` or `&gt;&gt;=` without #define. And since I have no idea idea of how macros really work, I simply assume it would be possible with them. :D I've yet a lot to learn in C++. So if you have any hints, just let me know.
There's also great cross-platform IDE from Jetbrains, https://www.jetbrains.com/clion/ . It's free for education.
Just to let you know, you convinced me to use snake_case instead of CamelCase. I just [changed the naming convention](https://github.com/Dobiasd/FunctionalPlus/commit/124644242fa0e12e425514422d66d8c5552b9e03).
Fun game, thank you! I had to give it a go, a bit hacky though: http://ideone.com/3P1wBz
C++ operators may be overloaded by defining regular C++ functions, the trick you appear to be missing is knowing what those functions are called. Every non-alphabetic operator (eg `+`, `*`, `&gt;&gt;=`, etc.) is declared as `&lt;return type&gt; operator&lt;op&gt;( &lt;params&gt; )` and alphabetic operators (eg `new`, `delete`, `sizeof`, casts, etc.) are declared as `&lt;return type&gt; operator &lt;op&gt;( &lt;params&gt; )`. For example, `==` may be something like `bool operator==( const YourType &amp; rhs )`, and new may be `void * operator new( std::size_t size )`. Note, this only applies to pre-existimg operators - to my knowledge, you cannot use this to define new operators (for example, I don't know of `|&gt;`, so you probably can't define an operator for it in this way - that would require some macro trickery). [See here](http://en.cppreference.com/w/cpp/language/operators) for at least a starting place for information, though there may be better sources out there. I find the tricky part with operator overloading is determining the parameter types and whether functions should be `friend` or member functions. `friend` vs member has implications on when implicit conversions may occur to match your function call. There's also certain ways certain operators should behave and matching that behavior is also usually a good idea if you don't want the behavior of your operators to be confusing or result in bug like behavior. Hope that helps! Macros are another story, but I'd recommend learning about operators first ;)
Awesome job! I like quite a few of the things you did. Using the make_index_sequence rather than doing it manually is a lot nicer than I did. I also REALLY like your trick in the FB type with the true/false specialization, thats a heck of a lot nicer than mine. Again, great job!
my favorite c++ ide. I especially love how fast it is.
Are these paid internships? Current grad student here.
To be honest, I wouldn't probably use the inheritance-based composition "in production", but rather like you did with `int_seq_combine`. I've researched the idea, and it seems safe to cast a struct to it's first member type and with char[] alignment of 1 there shouldn't be any padding, but I'm no expert in the standard.
I'm the author of CLBL. Any criticisms are much appreciated. Has this been done before? Do you think it could be useful? Edit: I just realized that I'm not perfect forwarding - I'll fix that ASAP and delete this edit. 2nd edit: This is going to be tricky... 
Indeed, I had never used std::bind. Indeed, this is incredibly similar. I suppose this answers the question "has this been done before?" Thanks for the reality check. :( I will look into the differences soon and give you a more in-depth answer, in case there is actually anything unique about this.
tried it to see if autocomplete now works with std::unique_ptr and was disappointed to see that it doesnt. Looked around and came across this bug report[1]. While basking in a pool of ignorance of what is needed to make it work,the problem seems simple enough,just look at what is between &lt;&gt; to get the type of the object being managed and autocomplete based on the discovered type.It seems simple enought. Tried it in linux with gcc 4.9.2 [1] https://bugreports.qt.io/browse/QTCREATORBUG-8937
In addition to `std::bind`, you should also compare it to perfectly forwarding generic lambdas. The pointer-only restriction seems excessively limiting.
Why write easier to read code?
My main argument would be readability. All the rest are added bonuses. Doesn't every programmer care about readability?
If I may extend your argument from 'C++11 vs 98' to 'C++98 vs C': Why is it worth investing time in moving to C++98 when you can do the same things in C, just with more code?
Everything C++11 do is doable with lot of code in C++98, or even more in assembly. ( I wouldn't repeat everything for me nullptr, thread linux/window compatible, auto everywhere, move smart ptr, and lot more are better tools to work with ) C++11 is available we should use it. One important thing. Would you think it'll be easier to recrut people to work on your C++98 or your C++11 project ?
Management usually understand/memorize explained like that Would you prefer to work with your mobile phone of 1998, the one of 2011, 2014 or the upcoming prototype of 2017 ? Now with C++ do you think people will come/stay to work with our code of 1998...
I admit the comparison might be taking it a bit too far, but only a bit. After working with C++11 for a while, going back to 98 feels incredibly limiting. All the new features really come together and make the whole thing feel like a new language. It changes the way you look at a problem. Lambdas have completely transformed `&lt;algorithms&gt;`. I would actively avoid it in C++98, but it's an amazing resource in C++11. Thanks to lambdas, writing code with `std` algorithms is easier, but it also becomes nicer to read and understand. The new `unique_ptr` and `shared_ptr` mean that you almost never need to write `new` and `delete` (or forget to write in the case of `delete`).
Another thing you might want to consider is that while newer standard is limiting your compilers, older standard can potentially limit your users/programmers working on your code, as code in older standard is more likely to be viewed and shunned as legacy code. And another good thing about newer standards - they well, define a standard. I was working on project that was created few years before C++11, and it had its own refcounted pointers, threads, etc. Most of them slightly or much worse that standard counterparts (from design and/or performance standpoint), all of them wound up as non-portable, and requiring nontrivial amount of time for new programmer to be familiar with. From that perspective, my opinion is that if back then somebody would look at then-upcoming standard, said "Hey, those things will be available in new standard, and their API will be based on boost equivalents, let's use that and switch on std version when able", it would be better for said project.
`auto` is probably one of the "best" features that were introduced. I can't even imagine how my template code would look without auto, especially for function return type deduction.
As far as books I would recommend: [Effective C++](http://www.amazon.com/gp/product/1491903996/ref=pd_lpo_sbs_dp_ss_1?pf_rd_p=1944687442&amp;pf_rd_s=lpo-top-stripe-1&amp;pf_rd_t=201&amp;pf_rd_i=0201704315&amp;pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_r=193Z3WS7NSRRMDWAR9J7) and [Effective Modern C++](http://www.amazon.com/gp/product/1491903996/ref=pd_lpo_sbs_dp_ss_1?pf_rd_p=1944687442&amp;pf_rd_s=lpo-top-stripe-1&amp;pf_rd_t=201&amp;pf_rd_i=0201704315&amp;pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_r=193Z3WS7NSRRMDWAR9J7) - This and the older edition have a great series of patterns that you should generally follow, or at least consider. The old book is by no means outdated by the new one as the new book focuses on how you should use the new C++11/14 constructs and the old book focuses on everything else [The C++ Programing Language](http://www.amazon.com/C-Programming-Language-4th/dp/0321563840/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1448645524&amp;sr=1-2&amp;keywords=the+c+programming+language+5th+edition) - Not to read cover to cover but its a great reference book when you are trying to understand why something is working differently then you think it should And web resources: http://en.cppreference.com/w/ - Best online reference for the standard library by far [STL's series on the core language](https://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-/Stephan-T-Lavavej-Core-C-1-of-n) - Series of videos about the core language features and how the language works. Its pretty comprehensive so don't worry too much if you don't get all the details [STL's series on the STL](https://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Standard-Template-Library-STL-/C9-Lectures-Introduction-to-STL-with-Stephan-T-Lavavej) - Same as above except focus on the library not the core language Edit: fixed links
Very nice article. You should explain that createInstance needs to return an unique_ptr&lt;A&gt; not just an A*. As per this old gotw http://gotw.ca/gotw/056.htm
I love Effective Modern C++ - I've read it three times and it's not been out that long - but it will very very likely be of no use to OP as many shops disallow most or all of these features - and it's also a fairly advanced book. Start with "Effective C++" and master that, then go to "Effective Modern C++" _if_ the development project you're on allows modern C++ features. There is no overlap between the two books, so you aren't wasting your time. EDIT: you do have a link to Effective C++, but it's under the name "The C++ Programming Language", which is a [different book](https://en.wikipedia.org/wiki/The_C%2B%2B_Programming_Language).
Ask them what you'll be working on... Then take that, dumb it down considerably and towards a more "fun" approach. And start creating your first project that meets some of the existing and/or new requirements similar to the MAJOR/COMPLEX project you'll be working on... that way your brain and code experience will already be adapted to the type of project and features you'll be using in your new job. Congrats...
Thanks for the feedback! I do use a perfect forwarding generic lambda in the can_call implementation. I'll experiment to see if I can make use of them elsewhere... Right now I'm assuming the callable object result has the same signature as the forwarded-to function, which is nice at first, until you realize that it means unnecessary copying. Perfect forwarding means the signature won't match at all. So I'll need to make some more adjustments to account for that. The infrastructure is pretty much all there to pass an object by reference, but I disallow it because it seems like it would be even easier for a less aware programmer to make it dangle. In what situation would the pointer restriction limit you, besides having to type the ampersand?
Writing some clean OpenGL code using C++, and making heavy use of the standard libs was a good exercise for me when trying to become more proficient in C++ Best of luck to you, I would honestly rather use literally any other language, so more power to you, but yeah, traders always use C++ for some reason. I see a lot of those guys in the coffee shops here in Charlotte, its always C++
I was recently in a similar position and I honestly find just practicing coding makes the biggest difference for me. If there's a personal project you can work on leading up to when you start, that would be perfect. If not, then don't sweat it - the company should realize that it takes some time to ramp up, and that includes getting into the swing of reading and writing code all day, especially if you're new to working full time in programming. I'd also concur with the common recommendation of effective C++ for learning about some best practices.
Thanks for your advice, I am really excited and hope to have a lot of fun and learn a ton. I really want to hit the ground running so I'll try to get some side projects going beside some books. About the ethics, I know that the trading world can get greedy. Something I really liked about the company that hired me was the amount of emphasis they put on integrity of character during the interviews. I think I'll be okay.
Learn RAII - "Resource Acquisition Is Initialisation". And don't just learn how to do it; learn how it works and why. This will give you an excellent insight into how C++ works as well as establishing a very good habit: use RAII whenever and wherever you can. Also I second the recommendation of the Effective C++ series; they'll help you avoid some of the most common mistakes, improve your understanding of the language, and show you how to do many things right the first time. Finally, get on Stack Overflow, find the C++ tag, sort the questions by votes, and start reading. If you have time to do all of this before your job starts, you'll be off to a pretty good start.
Well, it certainly seems so. Please take a look at the bug report E.Ziller linked under my comment (the first one) on the blog.
Read "A Tour of C++" (it is very short). Reimplement a project you have already done multiple times abusing a single aspect of the language each time. Learn as much as possible in the process (e.g. by comparing each approach against the others). For example you can try to: - abuse run-time polymorphism for everything, the next time use only static polymorphism for everything - go overboard with templates/solve your problem at compiletime/use expression templates to develop a DSL to solve your problem - write each attempt using an "each component goes into its own TU" as well as "all my code goes in headers" (learn about build systems and C++ unit testing frameworks along the way) - use a lot of global state vs try to solve your problem in a purely functional programming style... Each of these "approaches" is the right approach in some situations, and the worst possible approach in another. The only way to master when to use what is to have done so yourself. Of course all other tips people have given you here are nice (know the standard library inside out, know boost, know the libraries for the domains you are interested in, read books, watch talks...). The most important tip is probably "ask a lot of questions", e.g., on stackoverflow.
The problem with this post, IMHO is that it covers topics (like try catch initializer lists) that people should be learning long, long after they learn the simple rule of not using raw pointers for owning pointers. Ultimately I feel like the result is something I wouldn't recommend to either beginners (no need to cruft up their brain with things I haven't had to use once in years of programming) or experts (stuff they already know).
I agree with you one thousand percent. The fact that the poster does not seem to consider this a worthy goal is disconcerting. This is going to sound like a troll, but really it is not. The poster should do some soul searching and seriously consider the possibility that he/she is not actually very good at programming. 
Not being able to use a lambda without giving it a meaningless name, for one. Plus it's hard to move the resulting callable to another scope without using a dynamic allocation. Why not store the object by value, and let users who want reference semantics pass a `reference_wrapper`, like the standard library?
Memorize the [C++ FAQ](https://isocpp.org/faq). Even more important is writing code though. Do it as much as you can and good luck with your job.
Can you elaborate on "build tools"? I'm a c++ amateur, who just might be getting close to competent enough to work with the language, and I've used pretty much exclusively cmake and only dabbled with scons for a little while. Do you mean a much broader definition of build tools?
Think about the cases where the function doesn't *directly* call itself. Now the compiler has to follow the call tree to find loops.
Coming from strongly typed, type inferring languages like ocaml and Haskell, having to specify types everywhere is a royal pain. The compiler should be able to figure that out for you. auto isn't a total fix, but it helps a lot. Using it as much as possible makes, say, changing a vector to a list much easier to do.
I was talking about things like CMake, regular makefiles, Xcode or Visual Studio projects and so on. Also how the compiler and linker work Nd what the build process for a given project or file is.
SymbolHound
What I highly recommend (as someone who only really knew C++ from some game modding, and then got dumped in as a C++ dev at my current job) is that you just try to go out and build a bunch of programs. For example, try to build the things that come up in /r/dailyprogrammer in c++. If a particular task seems easy, then try to extend it. The other thing that is going to be very useful is to read other people's code and try to understand what it is doing. Once you can follow the logic, then see if there is anything that you would change to make it work. Try your thoughts and compare the final output. This will help you see multiple approaches to a problem, and start to give you an idea of what makes some approaches better than others. Lastly, don't try re-inventing the wheel. I do 95% of my programming using Qt and its libraries - I honestly don't know how I would go about multi-threading things, or building UI's without Qt. I'm sure I could figure it out, but there isn't really a point when I can just continue using the libraries. Boost is similar as well in that it is a huge library that can do 90% of the actual work, and you can then focus on working only on the parts specific to your problem.
Ok, good. I know all those words ; ) Thanks!
dunno, my first search was "C++ &amp;&amp; after function definition" and the [first result](http://stackoverflow.com/questions/15320015/what-does-mean-at-the-end-of-a-function-signature-after-the-closing-parenthe) explains it 
Is there a good source on tools you can recommend? I'm alright with the C++ code itself, but beyond my trial-and-error-discovered set of compiler options that lead to the fastest runtimes, I have very limited knowledge of tools surrounding the language.
I am gonna piggyback off this. Regarding the standard threads library, do you know of any solid comprehensive tutorials? I have an application that needs to run 2-3 processes asynchronously, and all of them should remain alive as long as the program leaves. Upon exit, I'd kill them one by one. None of these threads (processes) should block either the main thread or each other. I can do this seamlessly using pthreads. I struggled a lot with QThreads (and gave up on it because I was approaching a deadline). I resorted to std::thread eventually (needed a cross-platform solution) and used std::async to run those background tasks. I am not interested in what they return. But that's not what I want. I get an error each time I kill my program, because I never join/detach these threads. I know the problem sounds complicated but it's really not. I feel like the high-level approach of std::thread library tends to overlook some practical concurrency models.
You have to code. And you have to learn the best way to code. There are a lot of resources on C++. Starting with STL is a good way to start. Learning to debug using your next job IDE is a good idea. Refresh your template/memory management/inheritance/polimorphic/operator override/C++11-14 stuff. A good way to practice is by answering questions on stackoverflow (not easy) but you can get a lot of examples of people fucking up code in there...
I'm pretty sure he was saying he is the one basking in a pool of ignorance and would like to know why it's hard. He didn't appear to imply that of the Qt devs
CppCon http://youtube.com/cppcon
&gt; And don't get me started on `for (std::vector&lt;std::string&gt;::iterator it = vec.begin(); it != vec.end(); it++)` vs `for(auto &amp;str : vec)` To be fair, at least C++03 had `BOOST_FOREACH`. Even when applying `auto` elsewhere, it had `BOOST_AUTO`. Granted `auto` and range-based for loops are more powerful than those were in C++03, but I find those to be pretty cool for what the language offered at the time. 
First, you declared r before you declared x. How is the compiler supposed to know what r is if x is declared *after* r? What are you even doing with r? I don't see it referenced any where else in the program. Are you trying to cout r in that second to last statement?
There's a compromise if concepts can be used anywhere `auto` can. I'm still not sure what the answer to that is yet, but I know it's at least mostly true. Using concepts instead of `auto` offers the nice advantage of stating what you want to do with it as part of the "type", so you can still look at a variable and know that it fits a specific set of types, not any type like `auto` allows. For a simplistic example: void redraw_sprites(const GameObjectManager&amp; gameObjectManager, const GraphicsDestination&amp; destination) { for (const Drawable&amp; drawable in gameObjectManager.sprites()) { drawable.draw(destination); } } Any of `Drawable`, `GameObjectManager`, and `GraphicsDestination` could be concepts rather than concrete types, treated like OOP interfaces, but it doesn't matter to the reader whether they're concrete or not. The types say what they're used for and there's at least some indication of purpose, unlike `auto`. Now everyone loves this idea for function parameters. That's probably the really huge part of concepts. However, you might find it useful in other places, such as local variables or data members. As a non-concepts example (but made possible through the Concepts TS), consider partially specifying the type: std::vector&lt;auto&gt; things = get_things(); Now you have a crucial piece of information more than `auto` - the fact that it's a vector of something. This is especially useful if you're doing vector operations on it and don't care as much what the element type is.
Very generally order matters. C++ is within a function a mostly imperative language. This means that you have to partition a problem into consecutive steps. For example, you have to declare variables before use int x; int y = x + 3; This works. But it doesn't do what you want it to do. The type of y is integer. At the second line, y is assigned a nonsense value - x isn't initialised and could be anything - and that value won't change unless you directly change y! You can't store expressions in integers. So for example int x, y; cout &lt;&lt; "enter x, then y"; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; "sum is" &lt;&lt; x+y; This works. First, you tell the compiler that there are two integers called x and y. Then - order matters! - you print a string and ask the user for two values. At this point x and y aren't nonsense any more (provided the user didn't enter gibberish). Now you can add those two together. This changes neither, it simply calculates the sum and prints.
&gt; I have a very good understanding of pointers and memory allocation, polymorphism, algorithms and data structures. Congratulations. You know more than 90% of the developers I've interviewed over the years. You'll do fine. 
&gt; in the older language, I can use out parameters without any extra development or any additional object manipulation. You don't actually need to do anything different to benefit from move semantics: the exact same source code will produce faster programs. IIRC before Google started allowing C++11 in their codebase they switched to compiling their C++98 code as C++11 just for the performance improvement (while still disallowing code that was only legal as C++11 code). Although to get the most benefit from move semantics you may need to employ judicious use of the new syntax in a few places, for the most part using move semantics properly does not imply using different syntax. &gt; We also have lambdas but I can easily write functors, even in place for locality of reading. In standard C++98 you can't actually; A locally defined struct does not have external linkage and therefore cannot be used with templates in C++98. Compiler extensions may allow you to do so outside of standard C++, however. --- I still work on codebases that can't use the new features and my experience is that it's a huge pain not being able to use the new stuff. It's not really any one thing that makes a big difference so much as hundreds of small things that add up. As Stroustrup says, C++11/14 really does feel like a new language.
I didn't find it in my last search. Does this C++03 unique_ptr version have all features as the one from C++11?
tl;dr don't throw in constructor, not worth the pain IMO. Also, i've always read unique_ptr has no overhead whatsoever ?
&lt;Wall of text follows&gt; I'm a greybeard working in a prop shop(s) in Chicago, so I can tell you my thoughts on what makes a fresh grad stand out. You need to focus on the first two-four weeks only -- if you want to hit the ground running during these first few weeks, here's what you need to study over the next few months Trading: Know the terminology well -- bid/ask, market maker, market taker, what it means to buy the bid vs buy the offer, etc. You want people to be pleasantly surprised when they start explaining the basics and you already know them. Watch youtube videos of traders showing how they trade using TT -- ignore their "ideas" but pay attention to the terminology and concepts. You want to understand what people are explaining to you almost intuitively -- so put some effort into that -- ELI5 it to people over and over until you really get it. Environment: Most C++ prop shops in Chicago are Linux, so you need to know how to navigate around Linux command line, and some basic shell scripting, what SSH is, etc. It's very useful for you to pick up a scripting language like Python -- focus on working with text files, filtering, look at regex, get some basics of libraries like pandas, numpy, etc Daily, you may be changing text config files from the command line, so pick up enough VIM to be able to open a file, change a few lines, and save it. Development: Read up on GIT and CMake, again, nothing advanced, but start using both soon Be at least aware of (but good if you know these really well) networking -- TCP vs UPD, multicast, sockets threading -- manual thread management, thread pools, inter-thread communication locks -- lock-free vs wait-free vs mutex C++ (subjective, from my experience) not a lot of STL (most data structures and algorithms are trivial -- look stuff up, keep it ordered, remove, etc), not a lot of memory allocations (most memory is preallocated) not a lot of polymorphism (virtual, override) lots of templates and static polymorphism also, depending on the shop, there may be anything from all C++11/14 code, to old C++98, with layers written decades ago to last week, so, the best thing to do is to READ READ READ a ton of code on github until you are able to understand what you're seeing. watch youtube videos -- basically, you want to be able to LOOK at code intelligently, so any videos where people go over code and talk about it Do NOT worry about writing good code -- mostly you'll be assigned to fix bugs for the first few months, so the ability to read+understand+track code is critical for that. Personal: Pay attention to what people are explaining. look them in the eye, follow their fingers when they show you the apps and the source on the screen. Do NOT check your phone, do not show boredom, make sure you have enough sleep so you're not yawning, have a great attitude, lean forward, eyes bright, take notes, ask nonstop questions -- there are literally no question you can ask during the first few weeks that will be considered "stupid". This is the time when you will be categorized into a "dumb ass" or a "rising star", and it will be mostly based on your attitude and willingness to soak everything up. Be positive, laugh at people's jokes. Except -- there are always coworkers that people don't respect and are the butt of jokes -- NEVER laugh at these. I have seen people fired within their first day and week -- it was NEVER because of their knowledge -- it was always because of their attitude. One guy was assigned to just look at a trade GUI while we were in a meeting -- we came back and he was sleeping -- he was fired immediately. He tried explaining that he stayed up late for one reason or another -- doesn't matter. One guy talked non-stop, it was very difficult for people to concentrate around him -- gone by end of the week. One guy thought he was a know-it-all, and we could not convince him that he was only thinking about 3/4 of the problem -- gone. Other than that, I've seen a guy who completely sucked stay around for 2.5 years, with everybody having to fix up his crap, management knowing about his faults, people bitching in emails, etc. Good luck! EDIT: line formatting
Here's your original program: #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { int r=x*.60; char x; cout&lt;&lt;"How many tickets did you sell"; getline(cin, x); cout &lt;&lt; "Your total revenue is $"&lt;&lt; x &lt;&lt; "dollars"; return 0; } Here are the modifications I would make: #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { int x; float r=x * 0.60f; cout &lt;&lt; "How many tickets did you sell?"; getline(cin, x); cout &lt;&lt; "Your total revenue is $"&lt;&lt; r &lt;&lt; "dollars"; return 0; } Here are a list of the changes I made and why I made them: 1) Moved "char x" up one line and changed it to "int x" X is supposed to represent the total number of people attending the event. If you use a char variable, you can only store a value of up to 127 (255 if you use an unsigned char). This is due to the size of the variable- a one byte variable can only store 256 possible values. Also, as /u/breatheDrinkEatSleep mentioned, you have to define `x` before you can use it. 2) Changed "int r" to "float r" `r` is supposed to store the total revenue for the Theater. Integers can only store whole number values, so if your total revenue was something like $100.56, the value stored in the integer would actually be just 100. Changing it to a float allows r to also store the decimal part. 3) Changed "x * 0.60" to "x * 0.60f" This was only a minor change. By default, decimal values have the type `double`. Multiplying an int by a double results in a double returned. Since `r` is now a float, you should get a compiler warning for converting a double to a float. Adding 'f' to the end of 0.60 tells the compiler that 0.60 should be considered a float, not a double. 4) Changed the output line for revenue to print the value of `r`, not `x` Remember, `x` stores the total attendees. `r`stores the total revenue. You want to be printing out the total revenue, not the total attendees. One more thing to consider. In your program, you never assign a value to `x`. I don't know how you're supposed to do this, so I didn't make a change to that, but in order to get a valid result, you need to assign a value to `x` at some point. This could be done using user input, or by setting a value to `x` when you create it. For example, to use the number you used in your post, I would change the line `int x;` to `int x = 2776;`. Of course, this will make the program always return the same value every time you run it, which may or may not be what you need. If you can clarify what you need to do as far as getting the total attendees, I can offer some more help.
Perhaps you should read the rest of the posts. As I mentioned, I'm weighing up whether it's worth the effort of learning it given that i may be potentially limiting the target architectures that don't have the latest compilers. I didn't realize I'd be up for abuse just canvassing opinions of people who use c++11 on a day to day basis. I guess anyone who doesn't use your favourite language clearly knows nothing. Thanks for the kind words. Perhaps I should go work for mc Donald instead.
Thanks, I like that you put so much emphasis on the character aspect because honestly I feel that's what got me the job. This is a really great laundry list of things to become adept with.
Does calling it "push_back" instead of "append" count? =D
The thing is, you can't afford to pay the cost of debug iterators in games. A game needs to be playable in debug mode or you simply cannot debug the product at all, and for that reason debug performance is actually very important in games. Many game devs also choose not to use boost because of the bloat that comes with it, and also if you're shipping on platforms like xbox 360 or ps3, and especially the Nintendo consoles, you simply may not have enough memory.
Yes I know, I'm looking forward to the progress that will come from that. It will be good to see the standards committee at GDC this year. I'm really thankful that Sean has put in so much effort on this front.
The post was not intended as abuse. It is something you should really think about if you think that limiting target architectures is a valid long term reason to not learn the more readable progression of the language you already know. I know that if you had said a statement like this in an interview at my company you would find that the interview would have ended shortly after that. The fact that you are even weighing your options and not just learning the thing you are supposed to know indicates a lack of commitment to your craft. Sorry, if it bothers you that you are coming across that way, but that is how it is.
Since you replied twice. I will too. If you did not think that you were putting yourself up for abuse, maybe you have not used the Internet before? Generally, when you go into a forum where a bunch of people worked on something to make it better and say, "Hey guys. I know you did all of this work to make this thing better, but I am not sure it is worth it. Convince me." you wind up getting some responses that you will consider negative. Just a word to the wise.
I didn't reply to you. You got a notification because I mentioned you in my post.
you can throw with RAII. and yes, the overhead of unique_ptr is minimal compared to [shared_ptr.](http://stackoverflow.com/a/3630487) But the idea behind the smart pointers is to track ownership. If you need to use it in a tight loop, you can always dereference it in a local variable if you just want to access the pointed object, same if you need to pass it as a function parameter: const MyObject&amp; var = *my_shared_ptr;
Gotcha. First time. Thanks.
&gt; The thing is, you can't afford to pay the cost of debug iterators in games. A game needs to be playable in debug mode or you simply cannot debug the product at all, and for that reason debug performance is actually very important in games. Then you can turn off the debugging features. There's a macro for it. Simple. That's not a reason for a rewrite nor does it make the std c++ library too slow. Remember those debugging features are not defined by the standard; they are included by the implementation for your convenience. If that convenience comes with a higher cost than you are willing to pay, then turn that feature off, but don't go spreading FUD that the std library is too slow when really you're talking about the debug features of a particular implementation. &gt; Many game devs also choose not to use boost because of the bloat that comes with it, and also if you're shipping on platforms like xbox 360 or ps3, and especially the Nintendo consoles, you simply may not have enough memory. Define bloat?
I definitely respect all 3 of those. I write a blog with similar motivation, and plan to work on some contributions of my own. My perspective is that I can maximize 2 &amp; 3 if I can soak up what's already out there first though. E.g. I've often thought of trying to have a go at bringing python like iteration functionality to c++ (zip and product). But I wouldn't invest serious time into it without investigating e.g. Boost's solution, and Eric Niebler's ranges. If you read before you write, you can get perspective from people who are already experts, improving how quickly you learn. And you are much more likely to write something that addresses a genuine need, since by reading you've already figured out what's truly missing.
fortunately, the language is not so much important while developping a real world application. Readability is certainly a very important parameter. Knowing exactly what happens behind the code also. Functors (or function object) are verbose but when the function is no longer trivial with some parameters it is much cleaner than the lambda. You can be an efficient and very good programmers without accepting the new standards (functional + value semantics). You can live very well without them. 
Agreed :) "You don't have to know every detail of C++ to write good programs" Bjarne Stroustrup Still, this post and informative replies from *most* developers has convinced me of the benefits.
Valid point, I was only in jest on my previous comment. I've currently been working on purely my own code base for android and win32 with plans to go self employed. Longevity-wise I can see the merit in switching to C++11 now. Also, in all the companies I have worked for in my career up until this point (admittedly it has only been 4 positions in the last 20 years I've been in the industry), none have had a code base developed with C++11. I guess this is unsurprising for existing code bases I know but that's clearly not going to be a trend that lasts very long now.
[removed]
I'm sorry I don't think I could be of much help. However, is this something that could help you? http://libtins.github.io/ It claims to work on Windows as well.
Is that correct that Visual Studio 2015 still only supports OpenMP 2.0? ([link](https://msdn.microsoft.com/en-us/library/tt15eb9t.aspx)). Seems to me like Microsoft has some work to do?
I spent a good chunk of the morning working on this analysis and decided to show it. I would love to see others post the numbers they get. Also, any advice for improving the test would be most welcome.
I'm curious where [LZ4 HC (r101)](https://code.google.com/p/lz4/) fits on that chart
Try running nmap from another host with different scan types and seeing what kind of packets get logged by pcap.
I found that the most interesting result, would be very interested in seeing why.
Despite your attempts to dismiss my statements I did not start these replies with the intent to troll you, but I guess I am really hitting a nerve with you. I suspect I am just telling you something you do not want to hear, but perhaps you did not understand so I will try one more time. You say you are a C++ developer. From your comments I assume you do this professionally. For you there is no, "should I learn the new standard?" The whole question is silly as our your excuses for why you may not want to. The reality is that as a professional C++ developer it is your job to learn the new standard. If you wind up working on a platform that is C++03 then you use the features of C++03. It is your job to know both.
I have updated the code to throw -1 instead of new std::exception(). Here are the new results. gcc no-exceptions Average: 29,601,962 nanoseconds Standard Deviation: 1.82236e+06 nanoseconds gcc exceptions Average: 29,573,722 nanoseconds Standard Deviation: 1.61569e+06 nanoseconds clang no-exceptions Average: 21,028,872 nanoseconds Standard Deviation: 2.13722e+06 nanoseconds clang exceptions Average: 23,924,246 nanoseconds Standard Deviation: 1.98996e+06 nanoseconds
Great to see more benchmarking of exceptions. In my experience, on x86_64 exceptions are often faster then checking return values.
With move assignment to self, in the eyes of the standard it is legal for the object to be left in a valid but unspecified state, and compiler generated move assignment operators will not include checks for assignment to self. See discussion here: http://stackoverflow.com/a/9322542
I titled it that way because I investigated the performance of exception vs non exception code. My hypothesis said nothing about performance differences between gcc and clang.
I'm thankful that you did not show intent to troll me, how could calling someone inept possibly have cause for offence? And I'm glad that you are qualified to dictate what every C++ developers job is. I guess everyone working on older code bases should learn the new variations, even if they are not likely to use them. Otherwise they must be poor programmers. In light of your incisive revelation I feel compelled to inform my old colleagues who work on a legacy game engine code base how amateur and incompetent they truly are. They are clearly not in touch with reality and do not know their job. In fact I find it almost unbelievable that their product is the most successful in its domain given the lack of skilled developers! I'm not entirely sure if you've made up your mind as to what my profession or capability is. On the one hand I am 'not very good at programming' and on the other you assume I do this professionally. To set the record straight I do this professionally and to date I've worked on code bases that are all pre C++11. I'm currently going self employed and working on my own projects/code base. Sorry that you find my question silly. If I had been in your place then I'd just have declined to comment rather than to make unsubstantiated assessments with no supporting evidence other than a *subjectively* perceived foolish question about a newer version of a programming language. Sadly, a brief perusal of your other comments on this C++ forum show the same arrogant air of superiority; I bet you are a joy to work with. I sincerely hope you are a better programmer than you are a communicator. I suspect you will always be the one to get the last word in and I do not intend to waste further time attempting to demean you or show you for the patronising bigot you come across as. It's clear to me that you can do a far better job of this than I. So feel free to flame me further, without fear of reprisal. I also hope you don't find any responses that you will consider negative. I'm just trying to further understand the ways of the Internet. Just another word to the wise. With all that said I have taken your thoughts on-board regarding soul searching. As it turns out, I found a soul - right here on this very forum. &lt;/troll_slayer_out&gt; 
I definitely agree with you: I don't feel that using `std::unique_ptr` for non pointer-like handles is elegant/clean. However, I assumed that this was a limitation of `std::unique_ptr`, which is not true - that's why I added the corrections.
In theory, with the Itanium ABI exceptions should be slightly faster than checking return values in the non-error case, and much slower in the error case. Reality will sometimes diverge due to optimizers being imperfect.
Well. I once asked Chandler Carruth, why google isn't using exceptions. His answer was because of the optimizer doing a better job with out them. At the gamedev panel at CppCon, Michael Wong also admitted that exceptions aren't cost free. He said on stage, that even if no exception is thrown, exceptions handling still needs to be embedded, resulting in a larger binary. I think it depends which trade of you want to make, best performance or best code quality.
Could you link the post so that it could be (further) downvoted for stupidity? edit:found it: http://stackoverflow.com/a/1897998/273767
Just removing the *new* would have been sufficient. You should better not throw anything that doesn't derive from std::exception. 
Regardless of your intent, the title just feels misleading. It paints clang as the weaker choice.
Clang supports omp 3.5 and its support is improving fast. It's integration with Visual Studio is also being improved significantly so you might have a different alternative soon.
I like [gnuplot-iostream](http://www.stahlke.org/dan/gnuplot-iostream/), mainly because I already knew gnuplot before I started seriously coding in C++. Essentially, you're just writing your gnuplot scripts in your code, which is great if you already know the gnuplot syntax, since the library doesn't get in your way at all. You can also directly output EPS plots using the gnuplot "set terminal" and "set output" commands, which I can then embed directly in my LaTeX documents. Works great for my workflows.
And the gap appears to widen (at least locally) with LTO.
Going off the deep crazy end here and hopping onto op's question, but does anyone here have experience with embedding webkit or however it works and using a javascript/html based graphing library? It would be utterly amazing if I could use d3js for example. I don't care about code size, and am fine with it performing meh while taking a ton of ram. 
You can do it with CEF3 or e.g. awesomium (I'm sure a few others exist), but it's a huge pain in the ass and puts big constraints on portability (awesomium only allowed you to make 32-bit builds last time I checked, and CEF3 has an annoying multi-process model... and either bloats your distribution and adds lots of huge dependencies.) I messed around with it for a while, but gave up on both eventually.
Take a look at the nmap documentation. It describes various scanning techniques in detail. Maybe start with a simple SYN scan ? Edit: winpcap is a good starting point. You migth want to take a look at raw sockets when you want to reduce the overhead tho.
All of this discussion somewhat has me wondering why there hasn't been a "general purpose" graphing library with Python, R, C++, etc. bindings.
Python with matplotlib is the way to go 
Our scientific visualisation guy has a *passion* for VTK and hooks it into all kinds of code. 
Very nice article, thanks for sharing. I added a link to it in the tutorial :)
I had not, but it looks really cool, thanks. However, it doesn't solve the issues I had with 3D plotting, which is why I moved to Gnuplot and I'm now considering just calling Matplotlib directly.
Not throwing implies that your ctor does not fail. The only purposes of exception is to recover from it. Throwing in a ctor make this is really really hard, especially if you don't know your member object does. You can down vote me if you want, I still think it's not worth the pain nor the risk. 
There sadly isn't a good one IMHO. Not one with a modern C++ interface at least. So I'm really sad to say I write out text files from C++ and plot with Matlab... (or python's matplotlib) Please somebody make a C++11/14 plotting library, preferably header-only with minimal dependencies (maybe Qt5). It's a very hard task though, plotting is a really hard task with so many options. Just look at all you can do with Matlab.
A commercial IDE that does not seem to have any unique features and does not run on Linux natively... hmm... Why?
As far I know, you can [use it in QML with just some small tweaks.](https://johnflux.wordpress.com/2015/06/18/d3js-in-qml/)
Great post. There was a recent discussion on the reddit where STL mentioned that he had asked for compiler hooks for generating compile time indices, it followed very similar lines.
Since you already mentioned matplotlib, I think you cannot get simpler C++ plotting than this: https://github.com/lava/matplotlib-cpp It's not suited for complicated plots, though. Disclaimer: I'm biased because I wrote this myself.
Yup, in fact my patch is based on David Majnemer's patch that introduces the `__make_integer_seq` builtin in Clang.
Hi, I know both tools. The main idea is similar to protocol buffers but instead of using the protocol buffer representation for the input, it uses JSON. Cereal is good for serialize and as I said on the first edit the tool is to create De-serializers, I just mess up the title of the entry &gt;.&lt; So for example, you have one tool to measure data on social networks and you want to parse easily twitter responses, you can't do that with protocol buffers either Cereal, you will need to had write the parser of the json(using tool like janson or rapidjson e.g), at least as fast as if you use rapidjson. Thanks to this small utility you just create a template and it will create the datastructures + parsing for you. Edit: Plus this supports C++03.
Actually, it looks it does have clang. On the install dialog, Go to Cross Platform Mobile Development -&gt; Visual C++ Mobile Development -&gt; Clang with Microsoft CodeGen
don't forget a forum hosted on phpbb and a release in a .zip
I don't know of any automatic binding generators, but it shouldn't be too hard/lengthy to write something that parses the structures using libClang/pyClang/etc and automatically generates the required deselializer using what ever JSON lib you prefer (like rapidJSON). There is a useful tutorial on that [here](http://szelei.me/code-generator/).
I'm not aware of any special data structures (as in collections/containers) being planned for C++17. You can look at the C++17 proposals on the isocpp.org website. Boost might have something for you. See here: http://www.boost.org/doc/libs/
I've heard that Boost's `flat_map` containers might be proposed for standardization, though I'm not sure that counts as an "interesting data structure" in your case.
Hm, I get this when switching to v140_clang_3_7 toolset, as soon as I hit build: &gt; 2&gt;C:\Program Files (x86)\MSBuild\Microsoft.Cpp\v4.0\V140\Microsoft.Cpp.Clang.targets(206,5): error : Element &lt;DebugInformationFormat&gt; has an invalid value of "ProgramDatabase". &gt; 2&gt;C:\Program Files (x86)\MSBuild\Microsoft.Cpp\v4.0\V140\Microsoft.Cpp.Clang.targets(206,5): error : Element &lt;ExceptionHandling&gt; has an invalid value of "Sync". I tried "clean", didn't change anything. *Update*: Had to change exception and debug info settings in the project properties - it's now compiling. But lots of errors in Boost, Eigen and OpenCV. Most of them about C11 atomics and inline assembly. I guess that's kind of expected, since all the libraries probably have `#define`'s that assume the system is Linux or Mac if the compiler is clang. But I'm a bit surprised Microsoft didn't even test to compile boost, given it's Update 1 RTM and not an "alpha" anymore. But I'm still very glad they make it available. In this case, having something that's not useful yet beats not having it at all :-D *Update 2*: Workaround for parts of boost: https://llvm.org/bugs/show_bug.cgi?id=25384 
For an overview of the boost non-standard containers: http://www.boost.org/doc/libs/1_59_0/doc/html/container/non_standard_containers.html e: http://theboostcpplibraries.com/containers http://theboostcpplibraries.com/data-structures
What's wrong with .zip releases?
Yeah, fuckers should give it away for free because we're entitled to get free shit!
Looks like it. I thought that async await was going to be in C++17.
Well std::thread and concurrency::task are different and not compatible as I understand it. I'm pretty sure if it's in C++17, it would have to do with std::thread.
There's still a fair bit of unrest around the coroutines proposals. With the number of complaints and "whoa, hold on there"s there are, it's probably good that it's a TS. At least that means implementations will be encouraged to cover this feature. MSVC has it and Clang must be getting pretty close by now; there's been recent work on it.
It has an error on the &lt;&lt; operator when I want to insert the value[size] array
&gt;&gt; const int value[80] The above shows "value" array is constant and hence cant be changed.The best you can do with it is to read its values. &gt;&gt; cin &gt;&gt; value[size] The above will failed because it attempts to write to read only object. Its probably a good idea to make sure "size" is less that 80 to make sure you dont write past the end of the array. Your "isConsecutiveFour" function looks fine but it wont work the same consistently because it works on an uninitialized array.
Can you please be a little more specific? If you mean whether these tricks are applicable to a type list, indeed they are: template &lt;typename ...T&gt; struct type_list; template &lt;std::size_t Index, typename List&gt; struct at; template &lt;std::size_t Index, typename ...T&gt; struct at&lt;Index, type_list&lt;T...&gt;&gt; { using type = /* pick your implementation of nth_element */; }; Does this answer your question? 
I'm still confused as to what I need to change?
As per usual a half ..... release. When using clang (3.7 with ms code gen), the bigobj compiler param can't be passed through onto the linker. As a result when building it either complains because the compiler doesn't know what the param /bigobj is, and when it's removed the linker complains about too many sections and asks for the bigobj flag &gt; fatal error C1128: number of sections exceeded object file format limit: compile with /bigobj It's like they built hello world, got it to run then greenlit the whole thing for production release. **Note:** I also did try the gcc convention which clang supports but to no avail, eg: -Wa,-mbig-obj 
&gt;&gt; const int value[80] remove the "const" keyword.
Well that doesn't have anything to do with your consecutive function. That's more a question about input and output. You allocated an array of 80 elements, the size needs to be less than or equal to that. Also you can't index value[80] that is passed the end of the array. value[79] is the last element. I don't know how you intend to generate your list of values to check but "&gt;&gt; value[80]" is just writes to one value passed the end of the array.
The STL-like parts of the C++ Standard Library are supposed to be a **model** for how to build your own containers and algorithms, so that they will interact nicely. It's not supposed to contain everything you might ever possibly need, just the simplest and most common cases. And let's be honest, anything more complex would be unlikely to make it through the bikeshedding phase of the standardisation process. I believe that's what kept hash tables out for so long.
thanks for the update. I've setup a connect with an example project. https://connect.microsoft.com/VisualStudio/feedback/details/2077817/failed-to-compile-project-when-using-clang-codegen-toolset-due-to-bigobj
Use std::vector and std::array over low level arrays. Use std::string over C style char array strings. Avoid new. 
Thanks for the bug report. I want to make sure people see Andrew's comment below. We've done quite a bit of testing (ms codebases and many test suites) of this but it is still on a pre release eula. More details in a blog post soon. -steve msvc dev mgr
Give up and pickup botany.
You should probably get a book to learn! Don't follow online tutorials (if you want to do this professionally), they are fine if you just want to see what C++ is like. If you decide to get a book, get a modern C++ book that teaches C++11 or C++14. Actually make things. many people just read books, but that way you won't remember any of it! Start fun mini projects!
Have a specific question
So is it still only for mobile or...?
How can I see the result?
Hit me up if you have any questions, I've worked with both for around 1,5 years so I've at least been through the frequently occuring problems at least once
And the do notation of Haskell.
It works with std::future I believe. Threads are not required for this. Actually, its supposed to work with anything awaitable, and should work with std::optional / std::expected also, though I not sure if the last part is implemented yet.
Check [this](https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) out.
Why does it have to be in the standard library to be worth teaching? This thread makes no sense to me.
Seeking an experienced Freelance **Solutions Architect** on behalf of a Global Software Consultancy business for their end client who is a market pioneer in automotive infotainment. The contract is 100% on-site for 3 to 4 months with a planned extension. *Requirements* • Minimum of **5 years** of experience as a **Solution Architect** • Knowledge of **Automotive Infotainment technology** • Understanding of **Navigation applications** and **paradigms** • Very good **English**, both written and spoken *Desirable* • Familiarity with **FMEA** • Strong presentation and communication skills If you would like to apply for the role directly or know of anyone that would be suitable, please contact me directly at; Email: Jack.Kemp@darwinrecruitment.com Tel: 0044 1277638961 LinkedIn: https://uk.linkedin.com/in/jack-kemp-b4a756101 
&gt; versions. Well spotted, thanks!
One idea I had was to generate python bindings using swig for a c++ library I wrote and then just use websockets and d3js. 
Last time I tried matplotlib for 3d the performance was horrible. The larger the mesh the worse things got. Its great for 2d though. I ended up using mayavi for 3d stuff which is built on vtk. 
Yes, the internships are paid.
"Was" more than "is" mobile development. There is a better way to organize the VS install dialog. Clang/c2 is in preview, it didn't seem fitting to reorganize stuff in an update for a preview feature. This was close enough. There is nothing in our clang/c2 implementation that limits it to mobile development. The intended use case is that you'll add a clang-based library to your Windows code, and that the clang-based library probably came from some fruit-or-robot-based mobile app, but you can use whatever code you want. As VS moves more and more into cross-platform development we're certain to get a hierarchy that makes more sense. 
Sorry, no reliable ones. I mostly used it for the simple API. Though the largest file I run it over was a few hundred kbytes and the time to read it wasn't really noticable.
No.
https://www.youtube.com/watch?v=6PQ6335puOc
Thank you, that's exactly what I needed. I will have to think hard before recommending this technology to my client. I have had extremely positive experience with async/await in my C# code that is heavy on asynchronous hardware I/O. It dramatically simplifies the implementation. Now I'm looking at a medium-sided C++ code base that would benefit in a similar way from coroutines. But I can't ask my client to take on a large technical risk.
If you're Windows-only I'd consider it relatively low risk -- MS's implementation is pretty solid and well tested, and even if coroutines don't make it into C++17 I think it's likely that they'll at least continue to keep it working relatively indefinitely. I definitely wouldn't touch it for anything that may need to run on platforms other than Windows until it actually lands in the draft standard at the minimum.
Can I be paid in casino chips?
Promising. I'd like to see a benchmark compared to gold though
Beecode II - the revenge
Is there a project like this out there that aims to replace `sscanf` and input streams?
You can learn in just 21 days: http://abstrusegoose.com/249
Biicode
I'd find it really hard to believe that it was bikeshedding. The problem with hash tables is that there are many more critical design decisions involved than in a standard tree implementation. With a tree, you basically pick a balancing scheme, and that's about it. So you could do red-black, AVL, could do more exotic things as well, but they all have fairly similar performance. With hash tables right off the bat you need to decide closed vs open addressing. You need to decide on the expansion sizes of the hash table (power of 2 is faster, but prime number sizes better guard against bad hashes). If open addressing you need a probing scheme. If closed addressing you need a bucketing scheme. There is no real "best" for any of these decisions, it depends on the data and the use case. To say nothing of choosing hashes for your common data types. The practical difference in these choices is huge compared to RB vs AVL.
I recall observing in the past that there's a (presumably intentional) delay between Update N being released, and VS delivering notifications to install it.
A ring container would be very welcome (and would not load down the library overly much). I have a few times missed having a trie in the STL as well. But honestly I'd rather like having parallel data structures in such giving us access to a lock-free queue would be a great leap forward. They exist elsewhere and I think are underway so I can just sit and wait I suppose.
Stick around!
Can you post the rest of your code?
I like that conan seems to integrates well into existing CMake scripts. EDIT: and it seems that source files/binaries for package can be hosted anywhere, as long as you provide appropriate `conanfile.py`. Also a plus.
 The side bar says this is not a proper place for a cpp support questions like yours and you should ask your question at http://reddit.com/r/cpp_questions
Is there a list of packages already supported? 
I think that's it https://www.conan.io/search?q=*
Well, it's specifically format strings that I'm looking for. If I can't find anything, I'm probably going to make something myself and have it parsed with Spirit, but I'd rather go with something that already exists.
LLVM will generate bitcode for LTO, but the linker would still have to support it at some point to enable it (at least for LLVM). Gold currently supports it through a plugin.
Could someone explain to me why I would use a dependency manager like Conan instead of git submodules? I guess this could come in handy if I would have to manage shared/static libraries in a cross platform environment but I am currently only building from source.
Clang is a full blown high quality C++14 compiler. Microsoft's compiler is a buggy mess that just barely supports C++11.
&gt; this could come in handy if I would have to manage shared/static libraries in a cross platform environment I guess you answered yourself. Even if you don't want to have cross platform application, if you have ~10 static dependencies, package manager is handy to build/update all of them. Especially when there are more complicated dependencies.
I guess that's because format strings are more useful for output than for input. Much of the `scanf`'s format string is just redundant type information which can be obtained automatically. And without format strings you just get another parser framework. BTW some of the C++ Format machinery can be used to implement a safe `scanf`.
ah yes thanks, sorry about that!
Yes to all of those haha, it only occurs with it I will post it all again in the cpp_questions sub
Which is why it would be absolutely shocking if LTO isn't in the works already.
Imagine that I'm continuously developing two projects which have different dependencies of same package e.g. boost. Can I have two packages installed at once? Or do I need to reinstall this package every time I'm switching projects? Python has virtualenvs, ruby has rvm with gemsets... How conflicts are resolved? How is conan addressing debug/release/i-need-something-specific builds? I don't see anything in docs. I also don't see that Conan is addressing anyhow cross compilation. I think it is quite common in world of so many architectures and platforms that I want to develop on my x86_64 computer for arm target arch. And I want still to manage my C++ dependencies... Don't get me wrong, but there are still problems which needs to be addressed.
They will definitely implement LTO, don't know when though. I remember seeing Rui (one of the maintainers) saying that he tried to implement LTO in the old code base, and it took too much time because of the complexity, and that was the final push to redesign the linker. Note, the PE/COFF implementation already have LTO support.
How does this compare to gold?
I'm looking forward to this feature stabilizing so much. Gor was a pleasure to watch as well. 
Looks nice! I hope it goes well this time ;) ADD: By the way, do uploaders have to create packages for all platforms and build options(like MT/MD in VS) manually? Do you have any plan to provide build servers to automate the process?
I am not the dev, by the way.
C++ is a language that is capable of efficiency and high-level expressiveness by putting the onus on the programmer to know the underlining trade-offs between speed and convenience. Many high-level languages often hide details of how it, as a language, could or should be implemented and simply ask the programmer to "use it". If there are 100 different language constructs to accomplish the same thing, it's generally implied that they should all be treated as equally good (even if, efficiency-wise, they're not) and the programmer should pick whichever is more subjectively pleasing. However, to use C++ well, it requires the programmer to have at least a basic understanding of how "it does what it does". For instance, to optimize with move semantics (or to even know why you should), you have to know what temporary objects are and how they're returned by functions. To understand how blindly or naively using a templatized class hierarchy with many virtual functions might slow runtime performance, you would have to understand how templates are instantiated to define unique classes and how vtables are created and used. And if there are many similar language constructs to say the same thing, chances are there are subtle (and sometimes not so subtle) differences that would cause you to objectively favor one over the other for a particular purpose. These are the costs of dealing with a compiled language that places such a high priority on efficiency and optimizability (or at least allows the programmer to) while still allowing for high-level expressiveness and convenience. As you learn C++, learn its trade-offs. Always have some good reference sites at hand like [cplusplus.com](http://www.cplusplus.com/) and/or [cppreference.com](http://en.cppreference.com/w/). And stay the hell away from books with the title "Learn C++ in ?? Days". Anyone can learn C++ to write a simple program the same way anyone can learn architecture to design a doghouse. You just focus on a subset of the discipline. That doesn't mean you really "understand" the language.
Microsoft is still making breaking changes to their implementation as the proposal goes through the standardization process, though. I wouldn't recommend using it even in Windows-specific code when changes are still being made to the proposal like renaming all the keywords to have co_ in front. 
home: http://www.includeos.org/
Thats not true. You can force the source code build with conan install "--build" all or "--build missing". So, if you upload just the conanfile.py of your own lib, you can distribute it too, just with source code, without settings involved. Each user will build your library from source code. http://docs.conan.io/en/latest/reference/commands.html#conan-install I recommend you to read the experiment we did with a Go library. It's just source code and works like a charm. http://docs.conan.io/en/latest/examples/go.html
Hi! In our future plans could be collaborations between users and integrations with CI systems, we already do some experiments with Travis and appveyor and could be easy to automate the generation and upload of packages with them.
Have you tested SFINAE-friendliness of non-`__nth_element`-based approaches (say, [this recursive one](http://coliru.stacked-crooked.com/a/b41432db03d16f11) allows SFINAE)? If index is out of bounds, then it would be handy to be able to disable some function (constructor). Is there any plans to add a support of SFINAE ability for `__nth_element`?
Do you really need first type-parameter of `__nth_element`? It can be deduced.
Nice article! The part about QPA Back Ends is especially interesting since the **-platform** parameter isn't well documented. (Well, at least it wasn't the last time I looked around)
Not being a dead project is a pretty big plus.
A couple of questions: 1. When do MS expect to contribute the code back to upstream llvm/clang (or is MS' contribution already available somewhere)? 2. MS' clang distribution contains additional c2 backend dlls (not those coming with MSVC compiler). How tightly are they (clang and c2) coupled then? In other words, will it be possible to build open-source clang against some existing (closed-source) c2 binaries?
nice!
&gt;As /r/to3m[1] alludes to, Zeus has been around for years and in fact pre-dates Linux. Yep, it's *legacy software* with a big L.
The data file could be packed inside the .exe so that there wouldn't be a redundant step of having to unzip to install, as has been the standard for what, ten years already?
same developper, same mistakes, probably same future...
This is not standalone, but it is quite lightweight and has some general components. Header-only: https://github.com/mnmlstc/core 
It seems that binaries are for user convenience (building large libraries usually takes lot of time). I've tried building POCO (there isn't binary for VS14 x86), and it worked like a charm. Kudos for developers.
Steve, sorry to contact you like this - I couldn't think of a better option: I filed [this](https://connect.microsoft.com/VisualStudio/feedback/details/2081014/internal-compiler-error-when-compiling-eigen-with-openmp) bug in Connect yesterday, and I've narrowed it down more and wanted to update it. However, Connect always says _"Sign in to post a comment."_ - but I'm already logged in, and when I sign in again, the message doesn't disappear. I also tried a different browser. Connect seems to have a problem there. I've narrowed that ICE down to the following two lines in Eigen, which cause vc14 to produce an ICE: `#pragma omp atomic` `--(info[i].users);` You can find it all on http://eigen.tuxfamily.org/bz/show_bug.cgi?id=1125. Feel free to contact me if you need more information. *Edit: This is __not__ related to clang. It's a possible regression in the vc14 compiler.*
I don't like that `operator await` and it really feels like another microsoft extension to the language. If that's standard, I'll somehow win my disgust for it.
Can someone ELI5 please. What is this used for?
Cool! I like the inheritence composition that everyone has been playing with. Also an interesting mechanism with int2str
@awson, the majority of our changes have been contributed back to llvm/clang. Some of the work on exceptions, for example, was better done in the llvm/clang codebase than worked around in our codebase. There aren't many changes that we've made on our side--it's very few lines of code overall and none of it is interesting. We haven't pushed back Microsoft-specific changes to clang because it's kind of rude to shove vendor-specific stuff for a preview technology back into an existing open source project. Note that the clang maintainers have seen all of our changes. We kinda had to work with them to make some changes--there was design on both sides. Also note that some proposed changes are still in the pipeline to be pushed back: http://lists.llvm.org/pipermail/llvm-dev/2015-October/091847.html
No. But you can take any approach and make it SFINAE-friendly by wrapping it as follows: template &lt;std::size_t Index, typename ...T&gt; struct nth_element_impl { using type = your-favorite-non-sfinae-friendly-implementation; }; struct out_of_bounds { struct type { }; }; template &lt;std::size_t Index, typename ...T&gt; using nth_element = typename std::conditional_t&lt;Index &gt;= sizeof...(T) out_of_bounds, nth_element_impl&lt;Index, T...&gt; &gt;::type; Plus, you would never actually use `__nth_element` as a user. You'd use `std::tuple_element` or something else, whose interface may or may not be SFINAE-friendly. The advantage of `__nth_element` is that this library-based interface can be implemented at the compiler-level, and hence much more compile-time efficient.
Great, thanks Andrew! Hehe :-) It's quite annoying how Connect just doesn't recognise I'm logged in to post comments, but I'm clearly logged in since I can post new bugs and access my profile. You know, the situation where you want to help, but it just won't let you! And there's no real other way to contact Microsoft, the support-page requires a paid subscription.
Can you please elaborate? Which first type-parameter of `__nth_element` are you referring to?
Patrick, you can find Steve's email address and my email address all over the web (including Reddit). Mine is firstname.lastname@microsoft.com.
That's one of the issues I hand-waved in my very loaded usage of the words "Done correctly", because it's so easy to get wrong. The answer largely depends on the type of service being provided. It also touches on what "micro" really means. Ideally, they store little-to-no state and have no external dependencies (especially things like databases). Imagine, as a silly example, a service which does a ROT13 cypher of text for its users. You can spin up as many of them as you want to match the load, because they're 100% independent and don't require anything else. It gets much trickier when you start talking about services which aren't state-free or which have external dependencies. It's definitely not a solved design issue and is a hot topic of debate. 
Agreed. In some sense, it's just the web sphere/a new generation of programmers repeating the same mistakes/relearning the same lessons that the native/desktop people have been learning for the last 30 years. The distributed nature of it adds some interesting quirks (since most folk aren't experienced with HPC/other older distributed stuff, e.g. MPI) especially with respect to deploying and managing so much virtual infrastructure, but the problems and solutions are anything but new. 
I made one that is header only, and has the advantage of being completely const-expr! See: https://github.com/erichkeane/const_expr_string Unit tests are more of static_assert tests though.
&gt; Why does it have to be in the standard library to be worth teaching? It doesn't. I teach plenty of things that are not in the C++ Standard Library. I'm just curious. (Millions of people watch cat videos. I'm wondering about interesting data structures. Surely my interest is at least as worthwhile as theirs.)
I hear you there. Boost has it. When is the STL getting it? It's long overdue.
sounds like someone needs to invent a virtualized shared library
Touché... 
In general: typing less (that also means less bugs, typos but still less bugs) and be able to tell more about our intentions to the compiler to help us to catch some bugs at compilation time. 
Thanks for the shoutout! :)
It's not *like*. It *is* RPC. The convoluted nature is the unsurprising result of trying to add semantic meaning (and often state) to HTTP, a stateless protocol for delivering hypertext media.
Adding libraries with submodules+cmake is a pain. It'll be easier with a dependency manager.
You're forgetting two phase lookup. 
The more I read about C++, the more I feel like I just don't know anything. ....been developing in C++ for nearly a decade now...
More pvs-studio spam.
Get this crap out of here.
There is no C/C++ world. There is a C world and a C++ world. If you use memset in the C++ world, you need to be yelled at.
Expression SFINAE is really so important for your everyday tasks?
No. But I see progress in new language features in other open source compilers and see progress in proprietary VS. And this progress is not good.
Yes, it is the easiest way to emulate concept checking in C++ 11, which I basically use every day. A simple example of what you can do is concept-based overloading: template&lt;typename Int, REQUIRES_(Unsigned&lt;Int&gt;{})&gt; auto do_something(Int i) { ... } template&lt;typename Int, REQUIRES_(Signed&lt;Int&gt;{})&gt; auto do_something(Int i) { ... } but I also use it without overloading to get better error messages: template&lt;typename S, REQUIRES_(Serializable&lt;S&gt;{})&gt; auto serialize(S&amp;&amp; s) { ... } or if you have a template class you can also do: template&lt;class It&gt; struct my_range_view{ REQUIRES(RandomAccessIterator&lt;It&gt;{}) reference_type_t&lt;It&gt; operator[](std::size_t i) { ... } // the range view only provides operator[] if the iterator is random access }; The error messages produced are good! The compiler tells you all the overloads it tried, which one failed, and which check produced the error. They don't tell you within a concept hierarchy exactly what failed though. 
&gt; When is the STL getting it? It's long overdue. I hate to be _that guy_ but if you want them in the standard: - implement them in a single header library without any external dependencies (besides the standard library). - document the API of your library, that is, for each function, write down: - what does the function do - with what complexity guarantees in both space and time - with what exception safety (and if it has a wide/narrow contract, but people will help you with that) - write down half a page about why is your container important - write down why you choose that API, and if you had to made any tradeoffs what those trade offs were - a link to the github repo - put the API in the appendix - submit If you get at least this far, you have shown that you are willing to put up the work, and people will be happy to help. After a couple of revisions where people will help you make both your container and the paper better, it will land in some library fundamentals TS. Everybody agrees that we need these containers. Nobody has had time to put in the work. If you do it, people will be grateful. Just complaining about it won't fix the problem.
As I once wrote elsewhere, C++ is both awful and awe-ful. And I love it.
That would be fantastic. Flatmap is an extremely useful container probably second only to vector, which it complements so well.
consoles like sonys lineup have started to use clang in their toolchains, VS got support for clang, apples systems (OSX, iOS) all use clang, android uses gcc/clang, microcontrollers largely use gcc or clang these days, GPU vendors like AMD and intel are incoorporating clang/llvm in their driver toolchains, microsoft is open-sourcing .net compiler infrastructure (from what I understand)... I'm sure there will be enterprise projects too old and crufty to switch over for many decades to come (and other business opportunities for proprietary toolchains, like static analysis tools for instance), but it sure looks like it's going that way.
It would be near imposisble to get consensus on the particulars. Row column access or column row... single data allocation or multiple? The strength of a container like vector is that it covers the majority of use cases.
https://gist.github.com/anonymous/e78c3535e72d54208529
Modules and a decent package manager would make C++ a no brainer.
It's pretty easy to improve the `fmt::FormatInt` results by avoiding unnecessary size computation and reallocating strings: fmt::FormatInt f(edgeval[(max_i2s + i) &amp; 31]); s.assign(f.c_str(), f.size()); which gives the following on my machine (Linux x86-64 &amp; g++ 4.8.4): Integer To String Test [sprintf ] Numbers: 200000000 Total: 1729691849 Time: 21.1621sec Rate: 9450851.6493nums/sec [karma ] Numbers: 200000000 Total: 1729691849 Time: 7.3948sec Rate: 27046160.3580nums/sec [strtk ] Numbers: 200000000 Total: 1729691849 Time: 5.1372sec Rate: 38932047.2261nums/sec [so ] Numbers: 200000000 Total: 1729691849 Time: 6.9524sec Rate: 28767085.8511nums/sec [timo ] Numbers: 200000000 Total: 1729691849 Time: 6.2493sec Rate: 32003517.8267nums/sec [voigt ] Numbers: 200000000 Total: 1729691849 Time: 15.5855sec Rate: 12832463.4634nums/sec [hopman ] Numbers: 200000000 Total: 1729691849 Time: 4.9303sec Rate: 40565811.9450nums/sec [zverovich] Numbers: 200000000 Total: 1729691849 Time: 6.3156sec Rate: 31667491.3409nums/sec [jiaendu ] Numbers: 200000000 Total: 1729691849 Time: 5.2184sec Rate: 38325651.9145nums/sec However, the whole point of `fmt::FormatInt` and other C++ Format APIs is to **avoid** string construction which can easily give 2x performance improvement: [zverovich] Numbers: 200000000 Total: 1729691849 Time: 2.9385sec Rate: 68061588.9318nums/sec 
Does this work with templates?
Is this a MSVC-only feature? If so, and not standardized, it' a very scary one, since it's not portable. The alternatives are CMake and Conan.io for a module-like development.
Do modules in some sense violate the 'don't repeat yourself' maxim? If I currently have a header file that exposes a few functions, and I want each of those functions exported instead through module, will I have to repeat the function declarations in the module? In this setting could I simply replace the header with a module?
I know export and its intended use for templates, and that there has only been one compiler so far to support it, which is not one of the big three. Also, it's deprecated. I was wondering if this basically is the same thing, except for all things normally exported from a header, except now with modules. Or is it just classes, or is it just symbols?
How close is this to the work that the modules working group is doing?
@Elador, the .ifc file is needed by the compiler. It's a binary interface that makes the names of the exported entities available to the code in app.cpp. The .obj file is needed at link time--the .ifc's job is done by then. And the .ixx file is only needed to produce the .ifc. The compiler doesn't silently expect an .ifc and .ixx file under the same name to be present. You can call your file foo.ixx and call your module bar, that is, have a foo.ixx produce a bar.ifc. You can also supply search paths where the compiler will search for a module of the name you import. There are more details in the VC++ blog post: http://blogs.msdn.com/b/vcblog/archive/2015/12/03/c-modules-in-vs-2015-update-1.aspx 
This is the same C++ Modules that was approved to move to Core Working Group as a TS by the Evolution Working Group. It's currently under review for wording by the Core Working Group. So this is exactly the work the working group is doing. Please see the MSDN blog post for a link to the TS wording proposal. http://blogs.msdn.com/b/vcblog/archive/2015/12/03/c-modules-in-vs-2015-update-1.aspx 
The Evolution Working Group (EWG) approved the C++ Modules design as a Technical Specification. This will give us the chance to gain some experience with it. Rest assured that our good friends and Google are working with us (and we with them) in the context of EWG to make sure that when modules gets into the standard it's something everyone can accept. @blackibiza, &gt;&gt; Is this a MSVC-only feature? If so, and not standardized, it' a very scary one, since it's not portable. It's common for standards proposals to be implemented before standardization. Don't be scared. What MSVC has implemented is being published as a TS. 
You don't need to convince me any more - I was convinced of this approach when I learned that you already had C++11 lambdas in VS2010. Heck, I'm only looking forward to the first patch for GCC or Clang that also does await/async, or the first patch to MSVC that lets it output flat ELFs :-) Maybe that's a feature request to you guys - can you add ELF support? Then I can use MSVC to compile for Linux.
EDG were the ones that proposed removing it entirely.
I've heard and seen from people using it that VS can be slow and clunky as hell, but it's personal preference in the end
There's [rumprun](https://github.com/rumpkernel/rumprun/) as well, but I'm not sure it supports C++ as of yet. Unikernels are generally single address space and rely on a hypervisor though, so I think they are slightly different than minios. For example, Instead of memory protection through a page table it's enforced at compile time.
Because you're printing the address of the function, not the result of the call. Compile with `-Wall`. Fixed version: cout &lt;&lt; "containsOne: " &lt;&lt; containsOne(value, size) &lt;&lt; endl; Also note that top-level `using namespace std;` is usually frowned upon.
Wow. It would be a simple answer. Thanks so much! Also, using namespace std; is recommended by my prof. So I would rather not step on that :P
Err, it's not about the quantity of pollution. It's fundamentally different, one is interface, one is implementation. Bringing in entire namespaces is also rarely the correct way to do ADL, you would usually say e.g. using std::swap, not using namespace std. Frowned upon by whom? I've never seen this be a matter of broad consensus in cpp files, unlike in header files. Finally, while using namespace std is controversial, having statements like using std::vector are perfectly ok and even considered good form by some as they make it easier to change which class/function you're using later on.
Also, I'm being nit-picky here, but technically main should return something. Even though compiler returns 0 by default, I like to write it in, but you don't have to.
The thing that jumped out the most was this: &gt; Here, XType refers to the same type as in template&lt;Incrementable XType&gt; void foo(XType&amp;&amp; x);. It's as simple as that. However, this name can also be used outside of the function body. What exactly do you mean by outside the function body? You mean that this will essentially introduce a using XType = ... declaration to the surrounding scope? This doesn't seem acceptable to me. When you declare a template class or template function, you cannot use the template parameters outside the function. It's inconsistent, and leaks new names into the surrounding scope, which lambdas currently cannot do in any way. Other than that this seems ok to me; hopefully there's no corner cases involved with the parsing. As always, adding something to the core language rather than a library is a much higher bar. I don't have a strong opinion about it one way or the other, which puts this in the top 5 percent of core language changes suggestions on reddit etc that I've seen :-).
Thanks for the feedback! &gt; You mean that this will essentially introduce a using XType = ... declaration to the surrounding scope? Not at all! I simply mean it can be used everywhere in the function definition following its place in the parameter list, or following the whole parameter list if there's good reason to disallow use in the later parameters. Whereas a type alias within the function cannot be used in, say, a `noexcept` condition, this name can be used there. I definitely don't want these names polluting the surrounding scope! In any case, I'll be sure to reword that part. 
Well... *Technically* it doesn't have to.
Cool, that makes sense. Good luck with your proposal!
so they don't really use using namespace std? they type std:: each time? thats good to know
The point is, those are easy examples. I'd like to see more examples involving 3rd party libraries , such as MFC, Qt, etc. Generally, they are problematic when you pack them in a dll..it should be the same pain with modules
And currently, CMake already offer the Modularity. When you do add_library(Target MODULE source.cpp) It does create a library which might be loaded with dlopen
I soon came across a problem with template: I have a module interface `demo.ixx`: module demo; namespace demo { template&lt;class T&gt; void impl(T) {} export template&lt;class T&gt; void test(T t) { impl(t); } } And a module consumer `main.cpp`: import demo; int main() { demo::test(1); return 0; } When compiling `main.cpp`, the compiler told me: error C3861: 'impl': identifier not found Note that `impl` is internal to `demo` and not exported on purpose. Is it a bug in VS or is this usage ill-formed in the Module TS?
The TS states, in section 4.2.1, that no exported entity shall reference a non-exported entity. EDIT: /u/GabrielDosReis confirmed that this code should, in fact, work. It's a bug in the compiler and my interpretation of the TS was incorrect.
I suppose because `auto` already worked that way in lambdas from C++14 they had to keep that behaviour. But having to write `foo(ForwardIterator first, decltype(first) last)` seemed like it would be too awkward.
I wonder if there's any traction on the gnu compiler.
That seems unduly limiting doesn't it?
That's sad, so for template-heavy library you have to stick with headers or export *all* the templates in the module.
Which is even more clear if one look at the same discussion in /r/C_Programming (76% upvoted).
That is true only at the "declaration" level; definitions can still reference implementation details. I will add a clarifying note. Thanks!
That is correct. From programming perspective, we generally think of default arguments as being part of the interface of a function or a template.
where can I find a list of available packages?
First contact with the nugget system, seems useful.
Sure thing! Honestly, I was surprised to find it. Seemed like a strange limitation.
I know. Maybe you misunderstood my comment. Or maybe I worded it badly.
Kind of verbose, but it's all personal preference. I've seen sBar, s_Bar, etc. in the wild, so... But, if his names are mucking up a project/company naming convention, you might have a real beef there.
There are worse conventions. I don't like your coworker's approach at all, but I'd prefer that over a number of other things I've run into.
https://www.conan.io/search?q=*
Thanks, this looks really useful
&gt; plus it will be harder to refactor in case you have to. why ? In my IDE I can just select a symbol and it will rename all instances of this symbol. It'd be literally three key-strokes to migrate the whole codebase from StructFoo to Foo.
It's not even in C++17 drafts yet. You are talking about it because MS implemented this specific thing in some way. They are experimenting. Apparently, GCC guys want to experiment with something else (or at least doing current standard implementation right), modules aren't their proposal.
Paging /u/STL, can we expect a distro update in the next week or two? :)
It is also partly in clang (with `-fmodules`). According to the doc it should treat the headers as modules when building with libc++.
I plan to work on an update this weekend. Notably, libpng has received a security fix, and 7-Zip has finally updated after 5 years, also allowing me to remove FCIV.
Sadly no mention of await/async logic. Would have loved to see it.
Does it actually save the AST in that file or it is just some metadata?
In the pastebin code linked I do. I updated my post with an [ideone link instead](https://ideone.com/ogMvU5), maybe it is more appropiate.
Again though, clang's modules aren't necessarily the same as MSVC's modules. There is no current module document that's been accepted on by the standards committee so anything implemented by a specific compiler right now should only be expected to work on that specific compiler.
indeed, but it would be 6 lines of CMake to have a generic script :p
https://en.wikibooks.org/wiki/GNU_C_Compiler_Internals/GNU_C_Compiler_Architecture
"The compiler also produces a file with extension ".ifc"(called an IFC file) that contains a metadata description of the module interface. This is the only time that the module support produces anything additional to what a traditional compilation would do. The binary format of the IFC file will be open source; it is modelled after the Internal Program Representation work done by Gabriel Dos Reis and Bjarne Stroustrup a decade ago. The original implementation of the IPR is open source and can be found in the IPR repo on GitHub." See the MSDN post.
If you're concerned about the performance of the map lookup, you can use re2c or ragel etc to generate a DFA at compile time. 
&gt; assert(callbacks.count(cmd.type) &gt; 0); //Ugly and only run-time checking, not compile-time Is that _really_ the behavior you wanted when the command isn't found? It seems to me that if you specify that behavior, the rest will easily fall out and you won't have 2 map lookups anymore. Your solution looks needlessly complex (but was probably a fun learning exercise?) Edit: I see where you have 2 map lookups now, I didn't fully parse the code before.... Incoming String -&gt; Command Type , Command Type -&gt; Callback. It still seems like inconsequential amounts of overhead to me. Like /u/coke_is_it implies, you will still have to do something to check if a string is a command, a map lookup is as fine as anything at this point.
&gt; Both Types and Callbacks are set at compile time right? So there should be a compile-time method to link them How about a switch statement? :) That's about as efficient as you get, a straight up jump table!
I'm not sure about modules, but GCC does already have support for pre-compiled headers.
In this case, I'd argue it's pointless. Classes and structs in c++ are identical except for default member visibility. Not sure I'd start a war where one of the two of you gets fired, but it's unnecessary, obtuse and violates the DRY principle.
Ah, my IDE must be the complainer for missing switch cases, I assumed it was the compiler :)
&gt; The default mode for C is now -std=gnu11 instead of -std=gnu89. welcometothefuuutuuuuuuuureee
Welcome to the past; 4 years in the past. Granted it's a 22 year jump forward, but it's still **4 years** in the past.
http://nuwen.net/mingw.html
Yes. Internally GCC uses two intermediate representation (IR) languages called GIMPLE and RTL. GIMPLE is a form of SSA which is very C like, with direct references to the underlying internals. For example, the expression a[1] will be represented in GIMPLE as an expression with the type ARRAY_REF. Optimization passes may introduce accesses to that location as MEM_REF[($type *)a + $(sizeof(typeof(a))*1]. These two forms are equivalent but may not always be compared equal. RTL is the second backend produced by lowering GIMPLE. RTL looks quite like LISP. E.g. for MIPS the assembly instruction: add $3, $4, $5 (Add the contents of registers 4 &amp; 5 and write the result to register 3), in RTL would look like: (set (reg:SI $3) (add: (reg:si $4) (reg:SI $5))) The machine backend will then match these patterns against instruction patterns for the target architecture and produce instructions for the target architecture. Language front ends (FEs) in GCC which may perform some language specific optimizations, the result is then "lowered" or compiled to GIMPLE, which is optimized further, then lowered to RTL, optimized again, then matched against Machine Descriptor (md) patterns to produce instructions. There's some special casing in there and I've simplified some bits, but that's the broad flow of GCC's internal processing. For various reasons, technical and political, GCC has never really accepted it's own internal languages as a fully supported input due to how GIMPLE and RTL are produced and implemented. tl;dr: C-&gt;GIMPLE-&gt;(machine specific)RTL-&gt;asm LLVM on the other hand revolves around the LLVM IR, one SSA based IR which includes a data layout descriptor. This means any installation of LLVM which is IR compatible should be able to produce an object file for the target architecture. Having a single, target independent IR makes life easy for implementing optimizations. Also, LLVM accepts it's IR in textual or binary formats as inputs and can produce an object. The language front ends where are similar to GCC in that they produce LLVM IR, but middle and backend wise, the choice of backend is not wired into the compiler, so LLVM in its default configuration can act as cross compiler.
Still no c++11 as default?
Minor versions are only bugfixes under the new version scheme. I think GCC 6 will be switching to C++14 as a default though.
Thanks, awesome! Exactly what I wanted to know. 
Just been playing around adding constexpr into some of my C++11/14 testbeds, and I'm having some issues. this, for example, doesn't work with MSVC, but does with GCC and CLang (even the Visual Studio toolset). #include &lt;array&gt; #include &lt;iostream&gt; constexpr std::array&lt;char *, 1&gt; test{ {"Hello World!"} }; int main() { std::cout &lt;&lt; test[0] &lt;&lt; std::endl; return 0; } It compiles fine, but when run Visual Studio gives the error: &gt;Exception thrown: read access violation. and inspection of the variable gives &gt;test[0] 0x6c6c6548 &lt;error reading characters of string&gt; &lt;unable to read memory&gt; compilation with /FAs shows that the constant is definitely being generated, so I'm not entirely sure what the problem is. &gt;CONST SEGMENT ?test@@3V?$array@PAD$00@std@@B DB 'Hello World!', 00H ; test
Or perhaps the LLD (LLVM linker)'s new format? I know that at work we're running into limits of ELF (max number of sections in particular), and their approach circumvents the whole issue at its root. If you're hiring in the Netherlands I could apply for implementing it ;-)
How do you consider your distro different to [msys2-mingw64](http://msys2.github.io/)? Their default installation is as minimalistic as yours (or even more), and with pacman allowing to add more packages if needed. It contains cutting-edge packages as well, like gcc-5.2 (I suspect 5.3 will come very soon) and boost-1.59.0. Just curious since the amount of mingw distributions out there is a bit confusing.
I think that everyone should follow the naming-conventions from the standard-library and that it is childish to deviate from them. (This is language-agnostic!) In this case the stdlib doesn't do it, so neither should you.
What's so funny? Features of unreleased standards are available too. Or you are suggesting to put that mode by default?
Thanks for the elaboration! I think it's great what you're doing, I never said otherwise! Thank you for making everything available. The only reason I asked is that it can be quite confusing to see through the jungle of cygwin, msys, msys2, mingw, mingw-64, your distro, etc. I know about the differences now but even as an experienced user sometimes things pop up that are not that obvious, for example it took me quite a while to find a mingw version that would work with CLion. And when you install QtCreator, there's the option to install their mingw, and then you ask yourself - "I already have a mingw on my disk. Does it work with it?". I've found my favorite now in msys2, pacman is just unbeatable and their package repository rocks. But I like your point about static linking and grep in particular - I'm quite tempted to try your grep now ;-) If it's so good/different that you list it amongst your top 5 points, is there any info somewhere on what exactly is different? I quickly looked at the `.patch` files in your linked repo and saw some stuff about coloring changed, but not that much.
That triggers a debug assertion in our current development build. (We have "checked" builds that emit assertions, versus the "retail" builds we ship to customers.) Filed as VSO#170289 "constexpr ICE with std::array initialization: isAnyArray(), types.c 1052", marked for consideration in Update 2.
Yep. MS extensions like dllimport are supported only to the extent that they're needed for the CRT/STL headers, and dllexport isn't needed at all. We may support more extensions over time.
I'm totally guessing here, but I bet that when you move val to a constructor that the dllexport gets greatly simplified or even elided. My suggestion is to look at the generated assembly. Here's a SO post on many ways to do that: http://stackoverflow.com/questions/1020498/how-to-view-the-assembly-behind-the-code-using-visual-c
You can hit similar errors without any Windows-specific code, e.g. struct Foo { struct Bar { int x = 1; }; void bar(Bar=Bar()); }; gives "cannot use defaulted default constructor of 'Bar' within 'Foo' outside of member functions because 'x' has an initializer".
Awesome
Thanks. It's about time.
what is this "I just discovered tuples" thing?
&gt; For C++ questions, answers, help and advice see r/cpp_questions or StackOverflow.
I use Visual Studio and Xcode. Why wouldn't you?
Yes, almost all pros use an IDE. They can still write code without IDE, but it is simply less efficient. It's a tool to help you, not a necessity. It's like a carpenter and its workbench. Why not use it? I prefer Qt Creator. 
If you're on a unix system (Unix/Linux/Macintosh): Ensure you know how to do it without the IDE, then use the IDE to save time. That way when issues come up you understand what's going on.
In real world everyone are using various IDEs. It's not a privilege, since your result is code - no one cares how did you write this code. Only result matters.
That was really helpful Thanks!
You could write an SDL program without an IDE. It would just take forever. Before IDEs, you'd build your app with scripts, makefiles, etc. You edit in whatever non-helpful, no syntax highlighting editor you had , like vi (not vim), edit, notepad, etc. Since intellisense didn't exist, or the internet, you'd have a stack of books each about 300 pages, all references for the libraries you were using. If you didn't have books, there were always header files. You'd then finally get your code to compile, after all the syntax errors were fixed with repeated edits, and run it to get 'general protection fault'. Without a debugger, your best bet was to add print statements everywhere and see what printed out last before it crashed. It was horrible. Use an IDE.
I use vim exclusively for C++, and it suffices me. Not "all" pros use IDEs; where I work most people use CLion or Qt (or MSVS, saints preserve us), but there are three or four of us who eschew IDEs entirely, and we're no less productive than our coworkers. I *do* use an IDE for Java, because I haven't invested enough time into that language that its functionality is second nature to me yet (and I pray I never have to). 
IDEs are not a requirement, but they make some things easier. I've been writing C++ for years, mostly with the emacs text editor.
This answer is correct, *if* you consider properly configured shell with Vim/Emacs as “IDEs”. Otherwise you’re talking merely about a severely restricted subset of “all pros”.
far + cmake + g++ for windows mc + cmake + g++ for linux GL HF!
There's a chain of expertise which guides you to the editor best fit to your level of competence: 1. Novices and people forced by their noob managers: Visual Studio 2. Skilled programmers: emacs / vim 3. Extremely skilled programmers: notepad.exe Microsoft notepad (*notepad.exe*) is one of the best IDEs I've ever used. And yes, it's a complete IDE since it has everything: * Ignores the eternal *\r vs \n* battle and uses *\r\n* for everything * Comes with a non-monospace font by default so you can't read shit * Has a single-item undo history. For real men: you're allowed **one mistake** only. * Saves everything in .txt by default so you'll have to either rename it by hand or waste time specifying that you don't want a .txt file in the file save dialog. * This is one of the main strong points: **NO SYNTAX HIGHLIGHTING**! Real men just watch black on white. Real men might also like wordpad.exe, a full-fledged editor that inserts rich text formatting crap and many other stupid things which prevent your sources from compiling and you might love fixing by hand with a hex editor.
I sure consider a configured command line environment with VIM or Emacs an IDE. The amount of configuration/plugins makes it more or less of an IDE, so it's not completely clear. But in general, it is used as IDE. 
I've mostly been hanging around in game development circles since I started programming professionally, but I have yet to meet anyone (or any company for that matter) who works with codebases of substantial size (10k+ LOC) and doesn't use either Visual Studio, MonoDevelop or Xcode. Productivity for me is about much more than just rapid text-editing (á la Vim and Emacs) and the occasional auto-complete. I've relied heavily on the refactoring tools available in stuff like [Visual Assist](http://www.wholetomato.com/features/feature-refactoring.asp) and [ReSharper](https://www.jetbrains.com/resharper/features/code_refactoring.html) for the past seven years and can never see myself not using something of the same (or better) caliber. Once you really get into those tools your code starts to feel more malleable and you won't hesitate to rename stuff or move it around as needed. They're also life-savers when it comes to working with legacy or external code. I use the ``Find References`` functionality of the above mentioned tools at least a dozen times a day. Debugging is also something that IDEs tend to excel at. Being able to quickly place breakpoints, launch the application and inspect entire data structures by simply hovering over them, all from within in the IDE, is just fantastic. Lately I've tried getting into some of the new languages like Go, D and Rust, but regardless of their feature set or how much nicer they are syntactically compared to C++ I just can't move away from the tooling that Visual Studio provides me at the moment. One might argue that this is a bad thing, but I just see it as the bar having been raised for new languages to overcome before I can consider them equal to more established ones.
Atila Neves gave a [great talk at this year's CppCon](https://www.youtube.com/watch?v=5FQwQ0QWBTU) (it's only 15 min) about using emacs as an IDE
Yes, that's what I mean by lately. I wasn't a fan 10 years ago, but like it now. They'll have Linux support soon and are working on Clang support. Microsoft has been working hard to stay relevant. They really, really need to make a better build system though. The GUI based system they have is terrible.
Even if there are no special Doxygen format comments you can turn on options to generate the call graphs and inheritance diagrams and run Doxygen on the code base. This will allow you to navigate the logic flow across function calls. 
IDE is a bit of a red herring. What matters is that work is better done with tools. You can write all your code in ed, debug strictly in assembly, hex-edit any binary/images etc. You can "assemble" an IDE (most often people load all kinds of plugins into an editor). Or you can use a purpose-made program (an IDE). Finally, you can mix some/ all of the above. The four approaches are listed in ascending level of usefulness (IMO). Some people will argue that second is a better IDE than an IDE.
Woah, crazy! I never would have predicted Linux support. I'm honestly impressed. 
Agreed, I also use vim most of the time but I have nothing against ides.
I agree. The shell itself is the IDE, the environment that integrates all your development tools.
I don't think Visual Studio going to have Linux support, unless you mean Visual Studio Code, which has a far inferior subset of functionality.
Visual Studio 2015 Ultimate does this iirc.
I feel the same way. Visual studio is the best ide on windows, xcode kinda sucks but its your best bet on Mac, and CLION (Android studio) is a great, newer choice on multiple platforms
Qt is a really, I mean REALLY good IDE. With its many libraries and the awesome documentation, user (or programmer) friendly GUI, possibility to compile cross plattform and either make GUI with drag and drop or very easy code, Qt imo is THE IDE for cross plattform C++ and is a lot better than MS Visual Studio. Link to Qt: qt.io **Note:** When you pick your version, use first: the open source version and second: the version that says MinGW and NOT Visual Studio. When installing, explicity choose that you want to install MinGW if you haven't already.
My pet peeve about "IntelliSense": the term appeared around 1997, in VB5. At about the same time, Borland put out what they called CodeInsight in Delphi. CodeInsight was *way* better than the IntelliSense in the VB IDE, and that, for several years. But Microsoft prevailed, and with it, the name of the originally inferior functionality.
You can generate class diagrams in vs http://blogs.msdn.com/b/cdndevs/archive/2014/08/11/working-with-class-diagrams-let-visual-studio-2013-do-the-work.aspx
Sorry, I have to be more precise :) They are, if your format is very specific. They are not, if you have to handle all possible edge cases, which is often the case as soon as 'users' provide the input data. If all you care about is a simple state machine that checks for delimiters and linebreaks only (no escaping, no delimiter-valid-in-string, ...), yes, it's very simple to implement.
I had to implement "custom" CSV readers at a previous job. Indeed, non-standard CSV files are the worst. We had to customize the reader for just about every client we integrated with. Many of them basically didn't even try to format the output properly.
The red squiggly line indicates you've typed a hyphen ('-'), rather than an equals sign ('=').
More platform independent than Qt QProcess?
Thank you! I just started soo :)
This is probably a _nice to have_ feature. I would recommend providing a **wait_timeout** API for **Process**. We had to abandon [POCO](https://en.wikipedia.org/wiki/POCO_C%2B%2B_Libraries) because it doesn't provide such API [based on our observation](http://pocoproject.org/docs/Poco.Process.html).
I'd say Qt Creator is the best C++ IDE on both platforms, after having worked with both VC and Xcode (yuck) for years. May want to check it out.
Because Qt Creator.
This post was very helpful. I guess in some ways I'm looking to fast track something that can really only go at one speed. I've worked with OOP stuff before (assuming this project is OOP when I get into it) so really its just the idiomatic and new / unknown style that is throwing me off. I've pretty much been doing exactly what you're saying (perhaps not spending as much time on my questions as I should) but I'm immersing myself and slowly getting comfortable. Anyway, thanks for the post. 
Please, I don't want the proglang subreddits to start embracing that terrible idea. Any sufficiently thought out malice action will include feigned stupidity as a fall back. 
Is that functionality available for C++? The linked example is in C#. 
Do you know anything about internships?
What did you mean by this comment? ///Note: on Windows it seems impossible to specify which pipes to use. ///Thus, if read_stdout==nullptr, read_stderr==nullptr and open_stdin==false, ///the stdout, stderr and stdin are sent to the parent process instead.
There are a small collections of accidents waiting to happen in the Windows implementation. Referencing a process via process ID is not safe: your spawned process could exit, be completely cleaned up, and then another process could start and reuse the same PID. You need to keep a handle to the process to prevent this, rather than reopening it to get its exit status. Also, there's a race condition when spawning processes: creating both ends of a pipe and *then* marking one end as non-inheritable means there's a brief instant where another thread could create a process using the same code and end up with an inherited copy of the handle before the version in your process is marked as non-inheritable.
Sucks, delete the repository.
Remote working?
Back when I was doing C++ around 2006, the company moved into Java development and all C++ projects were off-shored to their Chinese and Indian sites. Nowadays most of the C++ job offers I see in Germany are game development, embedded, HPC and driver development. Not sure how open those industries are to remote working. One thing I have observed is that even if a company works a lot with outsourcing/off-shoring partners, they tend to not work with single developers remotely. 
Might that be a sign of being uncapable of distinguishing good C++ code from poor one? Or perhaps just because of organizational needs (i.e. need for a lot of meetings)?
Any kind of embedded development or any work that requires multiple hardware cannot be done remotely sadly. I've did it a few time and I always had to be at work.
In many cases it could be done so remotely quite easily, either by having one of the units with the developer or with a properly designed remote setup, for hardware that's easily reset/etc via a PC link.
And you couldn't do that with one of the units on your desk at your remote location?
Not really about C++, but I had a job where I worked in a remote team (with barely any team work) and I had to sit in an office. I couldn't see the difference either, but it was company policy.. not going to write anything more, or I'd diverge into a rant.
The same. Plus in another country (and I worked for a multi-national company which had an office in my homecountry too - that means they're paying salaries in my country and I couldn't really see a single reason why I couldn't be allowed to work remotely and I had to live far from family and girlfriend just to make some management guy happy)
So he took a for loop and rewrote it in c? Why even use c++ if you're that paranoid about constructors and operator overloading?
For the first loop, wouldn't using non-member functions for iterating (`cbegin()`, `cend()`) help clear up the intent? 
I'm not sure why it's cleaner, although it is more compact. Refactoring should be done with decent tools. I tend to agree with him.
 auto results = SortByName( input ); for ( auto i = results.begin( ); i &lt; results.end( ); ++i ) // ... StoreResults( results ); &gt;Please, tell me what the hell this for loop is doing. What does that = operator do? Is there a possible implicit case when we pass results to the StoreResults function? What is .begin, what is i, and how might the ++ operator behave. None of the questions can be answered since this code is operating on purely opaque data. What benefit is the auto keyword giving here? In my opinion absolutely none. * "results" is a container. * "begin" returns an iterator into the container. * "i" is an iterator. * "operator++" will advance the iterator to the next element. * "auto" is cleaning up the code. You don't need to know the exact type of the iterator in order to be able to trust its behaviour. In the future, concepts (proposed for C++17) will allow you to be able to say "iterator" instead of "auto", which gives better readability, as well as throwing compile errors if something doesn't match the type you expect. Personally I would rewrite it using a ranged-for, as that hides most of the unnecessary details: auto results = SortByName(input); for (auto&amp; element : results) // ... StoreResults(results);
Interactive Intelligence hires remote C++ developers.
He seems to have a problem with the entire concept of *abstraction*. I mean, what do `StoreByName` and `StoreResults` do, really? I can't tell because I can't see the code right in front of me! For all I know, they make a cup of the world's worst hot chocolate for a random person in Bangladesh. &gt; If I can’t immediately know what the hell is going inside of a piece of code the entire code is meaningless to me. Programming, from the top down, entirely relies on adhering to a contract. You do what you say you'll do, nothing more or less. Some of these contracts are enforced by the compiler, some are enforced only by common convention. That's why `StoreByName` and `StoreResults` don't bother us: we can infer what they do by their name. Without, dare I say it?, having *faith* that objects and functions do what they say they do, abstraction could never work. `begin` and `end` will return some sort of iterator by convention (otherwise they couldn't work in a ranged for loop). So I know that `results` in this code is some sort of collection and `i` is some sort of iterator. And if it's an iterator, I know it has an `operator++` to advance to the next item, `operator*` to get the item, and `operator!=` so I know if I'm at the end. (Interesting he uses `operator&lt;` instead, though, which implies that the iterator is a random access iterator.) Yes, a lot of this is because what a collection is and how it behaves and what an iterator is and how it behaves are primarily based on convention. *Is that so wrong?* And in the future, we'll have Concepts to enforce a bit more of that convention (enforcing semantics, if not behavior). One day we could write his code like: Container results = SortByName( input ); for ( RandomAccessIterator i = results.begin( ); i &lt; results.end( ); ++i ) // ... StoreResults( results ); For that matter, what about templates in general. Without Concepts, the problem is even worse than with `auto`!
True Placement New constructs an object at a given location. If you don't have a location, how can you possibly construct an object?
You can do this on Windows too. You have to pass all three of stdin, stdout and stderr, but you can get whichever ones you don't want to override via [GetStdHandle](https://msdn.microsoft.com/en-us/library/windows/desktop/ms683231.aspx). It's a small minefield—all the handles must be inheritable for it to work—but it's possible.
You could write a "placement new" function that takes your memory manager instead of an address: void* operator new(std::size_t count, MemoryManager&amp; mm) { void* a; MemoryManager::get_memory(&amp;a); return a; } Using it like this: Object* a = new(MemoryManager::Get()) Object(); Or you could use a magic tag like how std::nothrow works, if you don't have an actual "instance" of your memory manager.
I realized I misspoke: there's another race condition with inheriting handles, even if only one side is inheritable. You can still start a new process and end up with another unrelated process's inheritable pipe handle in it, because creating a process inherits *all* handles. The only way I know of to fix that properly is [explained by this Raymond Chen article](http://blogs.msdn.com/b/oldnewthing/archive/2011/12/16/10248328.aspx). (Although even .NET just "solves" this by putting a global mutex around the CreateProcess call.) Also I think there are a few memory leaks in the Windows implementation: every place you call `new char`.
Well, at this point I would just call the function on the manager :) I mean, the point is to hide the implementation details, and passing the memory manager on each instantiation is pretty ugly
Inside my manager I use the placement new with a location. The instantiation is done with the function Manager::instance(); but i really would like to call that function as it were a constructor...so to use the placement new I would do some hack like this: Object* a = new (nullptr) Object(); And the body of the constuctor would be: this = Manager.instance(); Would this work? Now you get why AT THIS STAGE I don't need the memory address? 
You can redefine `operator new` either for a specific class or even globally, see [on cppreference](http://en.cppreference.com/w/cpp/memory/new/operator_new).
You are aware that you can overload the `new` and `delete` operators, right? Either globally or for a specific type. There are a few funny rules to keep in mind, but it sounds like it would be fairly easy to write a `new` that allocated memory through your manager.
Have fixed the potential pid reuse issue I think, and the memory leak you just mentioned. I am still a bit unsure about the pipe handle issues, but hopefully I will understand it after reading your link. Thank you again.
Try `boost::optional` http://www.boost.org/doc/libs/1_58_0/libs/optional/doc/html/index.html
Given Randy Gaul's [resume](http://www.randygaul.net/resume/), why the fuck should we care if Randy Gaul hates auto? Especially since his argument is completely devoid of any technical substance.
we, the merciful mods, shall devise more stringent rules when posting job offers, and perhaps even make two, yes TWO, stickies, which shall differ only in whether the job can be done remotely or not. we might do this along with 2016 Q1 job megathread, so next year basically. may your pointers be smart, and your modules standardized and implemented prior to your natural death of old age. amen.
Thanks, magnificent mods!
Ok, i didn't know....I mean, I often do *this = *ref; in copy constructors, but i never tried to assign directly something to this, so probably you are right
What bugs do you care about? I don't know how browseable Connect is (since I interact with it from the other side). I can see open bugs by header, since I rename them appropriately (e.g. "&lt;scoped_allocator&gt;: This fills me with despair"), but VSO is an MS-internal database. I have thought about setting up a GitHub issues list to report STL bugs, but that would be one-way only (there's no way I would manually file VSO bugs on GitHub just so external users could see; not because our bugs are super secret, but because it would be a lot of manual work which I don't have time for).
That's good, because Clang/C2 is where the majority of our work went into for Update 1.
I've reported a few bugs on Connect over the years, and I must say the experience is rather unpleasant: the server seems very slow, there's no notifications for changes in items and no formatting options. Worst of all, the [favicon](https://connect.microsoft.com/favicon.ico) gives a 401, so I've had a broken icon in my toolbar for weeks now.
Connect is indeed unpleasant. I've heard they're working on improving it (and it seems to have gotten faster recently). Fortunately, there's another official way to file bugs against VS 2015: Send-A-Smile/Frown (the smiley face in the upper right corner of the window). Those reports are processed by humans and filed in our internal database, and you'll get email feedback if the resolver remembers to email you directly - the only downside is that the bugs aren't publicly viewable/linkable.
Good grief. This was posted as if we should already know who he is or something. No, he's a fresh graduate with little real-world experience. No wonder his view is so ... utterly naive.
I think I've used it before and it gave me a link to Connect, but I'm not sure anymore. I also remember not being able to attach images, but it looks like the interface has changed and is even able to record the screen, which is nice. However, I've used workarounds on other Connect bugs before, so I'd still prefer making mine public. Also, the smiley face has been replaced with a more "professional" icon now. Haven't you installed Update 1 yet? :)
I (we at work) try to report all the bugs we care about, so I assume they're already prioritized. It was mostly a lame attempt at humor with regards to how these threads sometimes turn out (people complaining that their pet bug wasn't fixed) :) But I do find the process of figuring out whether a (suspected) bug has already been reported/dealt with painful (but I realize that you're not the person responsible), and making that process easier would help me at least. Concretely (and I know I'm now addressing a pet bug) I was trying to figure out how I should proceed with my suspicion that std::promise doesn't handle abandoning the shared state correctly (at least according to my interpretation). According to https://connect.microsoft.com/VisualStudio/feedback/details/809632/destroying-a-packaged-task-does-not-abandon-the-shared-state the issue should be fixed, but it's hard to figure out if anybody has already reported the same issue/followed up for 2015 Update 1.
I have to ask - why? What kind of thing are you trying to accomplish or learn about?
Sorry, I must have accidentally confused packaged_task with promise when trying to find the bug report I was thinking about. The issue I'm actually think about is the following, which seems to work in clang/g++ ([ideone link](http://ideone.com/OjbjmV)), but hangs with MSVC 2015 U1: #include &lt;iostream&gt; #include &lt;thread&gt; #include &lt;future&gt; int main() { try { std::promise&lt;void&gt; p; auto f = p.get_future(); std::thread{[p = std::move(p)] () mutable { // p.set_value(); // Imagine the value isn't set (was: exception happens, but that's a bad example) }}.detach(); f.get(); } catch (const std::future_error&amp;) { // promise broken as expected. return 0; } std::cout &lt;&lt; "Promise not broken?\n"; return 1; } 
That's VSO#152487 "&lt;future&gt;: Bug in std::promise destructor for void and ref specializations" which I fixed for Update 2 on Nov 21.
Desire for clang: Better support for core C++14 language. Desire for libc++: Better C++ standard library implementation. 
&gt;Desire for libc++: Better C++ standard library implementation. Given that the OP is the STL maintainer for VC, I believe you owe him and us a more detailed explanation other than "libc++ is better." *** NB: I work in HPC where Windows is non-existent, so I have no interest in what compilers are available to those users. In fact, I rarely get to use clang (even though it sometimes produces higher quality AVX code than gcc) because only its most recent source tree supports OpenMP (i.e., there is no release version that supports it).
Well, everyone calls him "Mr. STL" so can't it be both? :-)
Let me start by saying that 2015 Update 1 is a really great release and that we're extremely happy with the new features and improvements. Anyway, it's more of a performance issue than a bug, but we see a very large slowdown going from boost::regex to MSVC 2015 Update 1 std::regex. Are there any plans to work on regex performance? Are there any particular regex patterns to avoid? 
I installed and tried out your IDE, just out of curiosity. I like the bare minimum, no nonsense, developer oriented interface. But I wonder how capable it really is. Would you honestly recommend it for moderately large projects, with dependent modules, mixed C and C++ and suchlike? Thanks!
&gt;VC's default_random_engine is way better than libc++'s, by the way. Do you know how it compares to libstdc++'s implementation?
Portability and uniformity. Standards are nice, standard compliance is nice but it's never perfect - if I can use the same implementation on all the platforms and don't have to ifdef stuff then that eliminates a lot of useless code on my side which means less chance for bugs in my code. Clang is basically spearheading development on all platforms I'm interested in - mobile (android/ios), browser (emscripten/webasm). Getting Windows mobile and windows in the same toolchain eliminates a lot of work. Getting clang to run on msvc runtime means I don't need to recompile stuff like python or blender when I use native dlls
libc++ uses `minstd_rand` and libstdc++ uses `minstd_rand0`, as observed in [Wandbox](http://melpon.org/wandbox/). They are both `linear_congruential_engine` types (which are notoriously bad quality) with a range of [1, 2147483646] which is obnoxious to scale. VC uses `mt19937` which, while not perfect, is far better than the Standard's non-MT engines.
fix for the SFINAE issue was checked in today. thanks for the report.
i fully intend to steal that :)
You can tell he's an early reddit user too, because he has such a short username
Happy to hear you like it. Mostly it is up to libclang and its file by file parsing. After saving a header file for instance, source files need to be reparsed (their parse cache is cleared), and this can consume some processing power and memory, especially if you switch between many source files right after saving the header file. We develop the ide within the ide, and that works fine, have not tried it on larger projects than that, but if you use it right with libclang in mind I do not see a problem, at least not yet. Additionally, rename refactor across many files have the same problem as it then include a header file. Hopefully we will announce the IDE this month, but without gdb/lldb and git integration yet, and most likely without python plugin module yet as well. 
Created a test for this purpose, multithread_test.cpp. It's not failing, but I will still have a closer look at this issue on Windows. 
&gt; I'm not a command-line type of person Become one. Seriously. There's only so good you can get with an attitude like this.
&gt; Also, this is a nitpick but: I appreciate that English may not be the author's first language, but having dozens of grammatical mistakes (starting with the maybe-not-strictly-incorrect-but-highly-dubious title) doesn't help make a good impression. Yep, he's Russian. There are links to his blog, Twitter and LinkedIn accounts on the last slide.
share your code, github
It seems pretty obvious to me. It takes a collection of results that are sorted by name, manipulates each result in the collection in some way, and then stores them. Replacing "auto" with "std::vector&lt;Result&gt;" in the snippet changes *nothing*.
For one thing, it prevents any conversions, especially when capturing *unspecified* return types, so you could argue its behaviour is cleaner. Using auto instead of explicit iterator declarations is visually cleaner too. Depends what "clean" means to you.
It is bad practice. The idea to add type information in a name has been tried before and it leads to bad habits. Microsoft attempted this (see the Hungarian naming convention) and proposed it as a good practice two decades ago (and it wasn't); they reversed that decision a few years ago, but after all those years, there are now a huge number of code bases that need to be maintained, that effectively impose it. After a few rounds of refactoring, you end up having to rename things just for consistency, and that consistency doesn't offer you anything in terms of better readability, correctness or anything similar; that is, you have to rename dwSize to ullSize, or FooStruct to FooObj and so on - and this takes a constant time/effort over the lifetime of your project, but doesn't actually improve things: your understanding of the logic and behavior of your code is not better because you find a FooStruct than of you found a Foo, but if you don't maintain this consistently, it will be worse if you find a FooEnum that is actually a class. This is similar to conventions like "prefix all member access with this-&gt;", or respecting the rule of five (and declaring all with =default), but not the rule of zero: in the end it is an unnecessary imposition, that you/your colleague/your team will have to put the time in, to support. 
Is there a minimal (non install) libs/includes of this being released?
Well, Randy Gaul is **wrong**. Meticulously spelling types out is less relevant to understanding the code than what he thinks. When reading this code, I **really** don't care about any of the considerations he has: * "What does that = operator do" - assigns a value, what did you think it does? * "Is there a possible implicit cast when we pass results to the StoreResults function?" - well, you don't know if there is an implicit cast in the example without "auto" either (albeit it is somewhat easier in the example without "auto"). And I do not care, not at the first sight. If profiling tells me there's e.g. a lot of conversion constructor calls (it's not implicit cast!), I'll have a look. * "What is .begin, what is i, and how might the ++ operator behave." - surely a C++ programmer heard of begin()/end() and consequently knows what i is, too (an iterator). * "What benefit is the auto keyword giving here?" - noise elimination. All this minutiae he wants to see increases cognitive load, which is not a good thing.
The symptom of a failure is not wrong output on a pipe. The child process will still know which is the correct pipe for it to use: the pipe handle will have been passed as the stdout or stdin pipe correctly. You'll just have this *other* pipe handle floating around unreferenced in the process. This only matters because that handle causes the pipe to remain open, even if all other handles are gone. If you are doing a blocking read on the other end of that pipe and waiting for the write end to close so that the read call returns, then if one handle to the pipe exists, unreferenced, in a long-running process that was spawned by your process, then the read call may not return when the process exits. In your case I think that would manifest as a deadlock in close_fds().
There are still flaws in how you open the pipes in unix implementation. Usually any file descriptors are inheritable, unless you pass some kind of flag or use newer (and less portable) versions of those calls and passing a special flag. This flag is O_CLOEXEC (close on exec) and similar for others. Once you call pipe(), you created 2 descriptors which can now 'leak' in another process (either the one you create by the library, or one which user of your library creates himself in another thread). Setting close-on-exec on each descriptor after you created them is no go, as this creates a race condition. These problems are sometimes impossible to avoid if the system doesn't have proper calls. At least on linux, however, there is a call pipe2(), which takes flags as second argument. Use it and set O_CLOEXEC flag there and you should be safe. The dup/dup2 call won't copy this flag so after exec() you are still left with valid descriptors AND you no longer have to explicitly close() the unused end of pipes, because they will be closed automaticaly by exec(), which is 2 wins. Why? Because you currently leak more descriptors than you think. After calling dup2(), you should close the original descriptors you dupped, as they would still be leaked into child process. And one last issue I can see, if exec() function fails for any reason, you should NOT really use perror() and you should NOT exit the process using exit() function. Why is that ... because after fork(), your child process may be left with unflushed buffers from the parent process. If that happens, perror() will print 'extra' garbage from parent process and/or exit() will flush the buffers before exiting. You should either use _exit() (POSIX) or _Exit() (C99) to terminate the child process - this will not flush any buffers. 
A friend of mine said that the place he started at mandated that the class name be a part of every member name. class Stuff { int StuffCount; string StuffName; } Shoot me now.
It may be possible.
My thoughts exactly. Randy Gaul hates auto and bloody well boo-hoo. He is yet another opinionated fool, who can't handle abstraction and clearly has no concept of the sheer ease auto brings to things like refactoring of algorithmic and data structure based code.
THANK YOU!
Actually I find the version with auto much easier to understand. In the auto version I can easily see that SortByName returns a Sequence (with begin and end). Now going by convention, the Sequence is either something that manages its own memory or it is a view (like array_view) into something else. Either way, I do not have to worry about memory management. With the C style loop, I see char** entries; and looking at the loop, I see no evidence of any type of encapsulation. Now, I have a lot more to figure out. How many allocations are represented by entries? I assume this is suppose to be a defacto array of 0 terminated "strings". Are the strings only just views into the data stored in input or did sort by strings actually copy the data? If it copied, did it use new [] and then copy, or did it use strdup? How about the entries itself, did SortByString allocate that too? With new [], or calloc, or malloc, or something else? Who is responsible for cleaning up this memory? In the name of "clarity", the author of this post has written a more unclear version with more potential bugs. I think this speaks volumes.
I've created a package with libpng few hours ago, and it basically boiled down to configuring cmake with python (although admittedly I'm not yet sure if my package will compile on linux). So far, I'm very positive about this project. I can confirm that on-site contact form is indeed currently broken, but on the plus side I've got response to my email in ~10 minutes, and that's kind of impressing.
It is RC1 or Update 1? There's no version information. Also, the "Join the Visual Studio Experience" checkbox is ticked and greyed out :\
my guess is it wont be freed and destructors wont be called unless you explicitly delete your objects 
Thanks, this says everything i needed to know. Yes I use placement new and I also make sure that everything starts at a (address%4=0). And i hoped that i didnt need to manually call constructors, but i guess i don't have a choice
Surely you're keeping your allocated objects in a smart pointer of some sort, and your allocator outlives all of them? In that case it should be a matter of defining a deleter for your smart pointer that does the right thing, ie. call the destructor.
I ran it and it printed "do your own homework" or use ideone.com
It doesn't call destructors, it just roll back the pointer, which is what I already do. However I need to call destructors (for example a std::list would leave leaking memory if I don't)
Also, make sure you learn how to format code on reddit. What you have in your post is unreadable.
 template&lt;class T&gt; class SmartPointer { T* data; Allocator* allocator; public: SmartPointer(Allocator&amp; alloc, const T&amp; t) : data(allocateNew&lt;T&gt;(alloc, t)), allocator(*alloc) {} SmartPointer(Allocator&amp; alloc) : data(allocateNew&lt;T&gt;(alloc)), allocator(*alloc) {} T&amp; operator *() {return *data;} ~SmartPointer() {deallocateDelete&lt;T&gt;(*allocator, *data);} }; Used as such: StackAllocator stackAlloc(...); ... { //create a local block SmartPointer&lt;MyClass&gt; myInstance(stackAlloc); myInstance-&gt;doSomething(); } //end of local block, ~myInstance() calls deallocateDelete&lt;MyClass&gt;() automatically
Wow that's better than i was hoping! Right now I was overloading the new operator depending on the allocator, this not only solves my problem, but also will lead me to a serious refactoring 
Keep in mind that any allocation being done automatically in the contained object (for example, when vectors resize or a string resizes) will not use your custom allocator - you will need a deeper solution if that is the behaviour you expect.
Thanks, I hadn't thought about its use for that purpose. Unfortunately*, Concepts are incredibly likely to be in C++17 and there's probably not enough time to adjust this behaviour based on an empty guarantee that this proposal would make it through. However, there is an existing alternative in this case, even without my addition, if my reading of the TS is correct: IndirectlyCopyable{I, O} auto copy(I first, Sentinel&lt;I&gt; last, O result); I feel like this is where the concept introduction shines - `I` makes more sense as one type only here because we're introducing one `I` up at the top. I saw the big debate on std-proposals and I personally find different types per concept instance to be more intuitive. I get that one argument for the behaviour is that a concept can act like a type. However, `auto` can also act like a type in the same way, and I feel concepts are closer to `auto` than a concrete type, with `auto` being logically equivalent to a `True&lt;Ts...&gt;` concept. I also find it easier to enforce the same type with a default of different than I do to rewrite a default of the same to use different types. --- *I'm super stoked for concepts in general.
yes that is exactly how you would do it!
[Take a look at the "Managed Pointers" section here.](http://www.cplusplus.com/reference/memory/) There are number of smart pointer types available in the standard library now (introduced in C++11, I believe). The idea is that you use a smart pointer type (like std::shared_ptr&lt;&gt;) instead of just using a raw pointer type (like char *). These smart pointers will help you with calling proper destructors when they go out of scope so you wouldn't have to handle clean-up manually.
I'm guessing the output is: Segmentation fault Do I get a cookie? ;)
You need a function that calls an object's destructor. Template it. template&lt;class T&gt; void CallDestructor(void *p) { ((T *)p)-&gt;~T(); } Each allocation needs a header containing a pointer to the previous allocation, a pointer to the destructor function, and (strictly speaking) a pointer to the actual memory. (You need the last item because there may have been additional alignment introduced after the header.) struct BlockHeader { BlockHeader *prev; void (*fn)(void *); void *mem; }; When creating a new allocation, presumably using a templated allocation function, include space for a `BlockHeader`, plus alignment, plus the object, plus trailing alignment. Set the header's `prev` to the last `BlockHeader` (if any), `fn` to `&amp;CallDestructor&lt;T&gt;` (unless T has a trivial destructor, in which case you could set it to NULL), and `mem` to the memory you've booked for the object proper. (Take care to handle alignment. You probably want to use `std::align` - which I've yet to use, so I'm not providing code.) Use scalar placement new to construct the object. (Of course, your allocator needs to track the last BlockHeader it created so it can link each new one in.) Then to destroy, run through each block header in turn and call the destructor, along these lines: for(BlockHeader *h=m_last_header;h;h=h-&gt;prev) { if(h-&gt;fn) { (*h-&gt;fn)(h-&gt;mem); } } (I personally recommend doing this stuff `malloc`-style, so you're just returning a `void *`. Then the whole destructor problem becomes moot! When you have a problem, punting it off to the caller can be a perfectly valid way of dealing with it, and sometimes they'll even thank you for it. Certainly - and you can suppose my experience as unique or commonplace as you please - every time I've done allocations in this manner, the objects have been POD types...) (EDIT: add note about trivial destructors)
I think this is a good implementation, but it only supports stack allocation within a single scope. If you want to use your "BigStack" through multiple real stack frames (which would be good for cache hits), you need a way to destroy only those objects allocated within the current real stack frame. This could be solved by moving the relevant info into a "fat pointer". Since C++ guarantees that local variables are destroyed in reverse order of construction, this should work. Note that **I'm ignoring alignment for now (not OK in practice!)** and leaving the stack size fixed at construction. In a complete implementation, if you want to support growing the stack beyond the initial size, you couldn't use `std::vector::push_back` because it invalidates pointers. Storing each object by itself in a linked list would work, but that destroys cache locality, so I would use a linked list of big heap blocks like the size of a memory page. Note: this is just quick-n-dirty code, probably contains errors, IRL I would figure out how to make the `Ref` ctor private and add const accessors. Also this wastes space by storing a reference to the stack in every `Ref`, not sure how to avoid that. class BigStack { public: BigStack(size_t size) : mem(size) { ptr = mem.data(); } template &lt;typename T&gt; class Ref { public: Ref(T *object, BigStack &amp;st) : obj(object), stack(st) {} ~Ref() { obj-&gt;~T(); stack.ptr -= sizeof(T); } T *operator-&gt;() { return obj; } T &amp;operator*() { return *obj; } private: T *obj; BigStack &amp;stack; }; template &lt;typename T, typename... Args&gt; Ref&lt;T&gt; alloc(Args... &amp;&amp;args) { T *pcopy = (T *)ptr; new (pcopy) T(std::forward&lt;Args&gt;(args)...); ptr += sizeof(T); return Ref&lt;T&gt;(pcopy, *this); } private: char *ptr; std::vector&lt;char&gt; mem; }; 
&gt; I hadn't thought about its use for that purpose. That feels like natural consequences of proposed syntax. &gt; Concepts are incredibly likely to be in C++17 and there's probably not enough time to adjust this behavior based on an empty guarantee that this proposal would make it through. If you'll actually make a proposal, and people will like it, then there will be a reason to change behavior. Right now, of course, no one is going to do that. &gt; IndirectlyCopyable{I, O} &gt; auto copy(I first, Sentinel&lt;I&gt; last, O result); It's actually will be: IndirectlyCopyable{I, O} auto copy(InputIterator&lt;I&gt; first, Sentinel&lt;I&gt; last, WeaklyIncrementable&lt;O&gt; result); besides that, it's correct. But, i don't think that I'd wrote it like that, because IndirectlyCopyable checks what can you do with I and O, and first thing I'd like to know what is I and O, and only then, what can i do with them. It looks like *use before declaration* for me. &gt; I saw the big debate on std-proposals and I personally find different types per concept instance to be more intuitive. I get that one argument for the behavior is that a concept can act like a type. However, auto can also act like a type in the same way, and I feel concepts are closer to auto than a concrete type, with auto being logically equivalent to a True&lt;Ts...&gt; concept. Yes. auto and concept-name are placeholders for a type. The difference is that auto is not constrained. &gt; I also find it easier to enforce the same type with a default of different than I do to rewrite a default of the same to use different types. I agree with you. I recently tried to play with concepts a little, kept forgetting about same type every time.
Thank you for this excellent explanation, this seems related to the Windows pipe handle issue. Sadly, OS X for instance is lacking the pipe2 function. However, I'll try to fully grasp what is happening on process creation and hopefully fix it soon. 
Randy Gaul will have to pry auto out of my cold, dead, carpal tunnelled hands.
But how can i call it on the ptr? I mean, i'll explain my problem... I'm making a system to switch scenes in a game engine. The whole idea about the stack allocator is to be able to free all the memory allocated in that scene without doing it manually or keeping references... Those smart pointers won't have their constructor called! 
Why not just use smart pointers or automatic storage for your objects and be done with it? I'm not sure what added benefit your extra allocator has.
/u/foonathan s answer is the correct one. Allocators allocate and de allocate, they don't construct or destruct. Object construction/destruction has a dependency on allocators but not vice versa, which means that allocators should be totally ignorant of construction/destruction. Simple example: template &lt;class T&gt; struct JustDestruct { operator()(T * p) { p-&gt;~T(); } }; template &lt;class T&gt; using stack_ptr = unique_ptr&lt;T, JustDestruct&lt;T&gt;&gt;; StackAllocator&lt;1000&gt; sa; stack_ptr&lt;SomeObject&gt; sp(new(sa.allocate(sizeof(SomeObject))) SomeObject); Some nasty syntax on that line, but I'll explain. We defined a unique_ptr with a custom deleter that only calls the destructor of the object, but does not call delete, and called it stack_ptr. Then, we initialize such a pointer, but instead of using a regular new call which uses the default allocator, we first call allocate on the stack allocator and pass the memory location it yields into placement new, constructing an object in place. Placement new in turn returns its pointer argument which we construct the smart pointer with. When end of scope is reached, the smart pointer gets destroyed before the stack allocator since it was constructed after. It calls its custom deleter, safely destroying the object just before the stack allocator is destroyed and returns its memory. Typically you'd hide the placement new details. If you need dynamic allocation for containers like vector, they already accept allocators and abstract those details for you. If you are using dynamic allocation for polymorphism, there's nothing really in the STL off the top of my head but I can follow up here and explain further if you like (it's fairly straightforward). 
&gt; It's actually will be: &gt; IndirectlyCopyable{I, O} auto copy(InputIterator&lt;I&gt; first, Sentinel&lt;I&gt; last, WeaklyIncrementable&lt;O&gt; result); I guess I was expecting `IndirectlyCopyable` to enforce `InputIterator` on `I` and `WeaklyIncrementable` on `O`. 
Another issue related to exec, you need to take into consideration that the path can contain "ugly" characters that have special meaning for the shell, such as quotes. If it does, your code will fail to spawn correct command. Lets say there is a folder called **A"'** (A, double quote, single quote) and your command is **ls**. Now your command passed to a shell is **cd "A"'"; ls** which the shell fails to execute, as there is opening single quote which is not terminated. Cases like this are rare and many people fail to test them. Solution is to do proper quoting. Use **single** quote for cd's argument and replace all occurences of **'** (single quote) in path by **'\''** (single quote, backslash, single quote, single quote). Note that you will need one extra backslash in C++ string literal to write the actual backslash. std::string shell_quote(std::string const&amp; what) { std::string quoted_what; quoted_what.reserve(what.size() + 2); quoted_what += '\''; for (char c : what) { if (c == '\'') quoted_what += "'\\''"; else quoted_what += c; } quoted_what += '\''; return std::move(quoted_what); } execl("/bin/sh", "sh", "-c", ("cd "+shell_quote(path)+" &amp;&amp; "+command).c_str(), NULL);
It depends a lot on the type of embedded device. I do embedded development and I haven't had to fiddle with wires (except Ethernet and power cables) for 3 years. In my about decade of remote embedded development, the number of times I have had to fiddle with wires I can count on my hands.
&gt; All this minutiae he wants to see increases cognitive load, which is not a good thing. hahahaha oh boy
is there a transcript somewhere ?
I don't see this as terribly useful but a good one nonetheless.
Slides will be uploaded once I have them :)
I'm sure we can arrange that. :)
Boost probably has some optimization that VC and libc++ don't have.
The proposed papers to the standard have some motivating examples. I see `static_if` as syntactic sugar for small and localized compile-time checks. [N4461: Static if resurrected](http://open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4461.html) [P0128R0: constexpr_if](http://open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0128r0.html) It is also "pretty powerful" when combined with other similar constructs (I'm working on a [`static_for`](https://twitter.com/supahvee1234/status/674275063785496576) that makes use of `static_if`.)
Probably the best slides and examples I've seen regarding cache-friendliness. Terse and "useful" examples, and easily understandable results. 
Oh boy what? I sometimes look at the assembly when debugging, doesn't mean I should write the assembly.
... I didn't know [`poly_collection`](http://bannalia.blogspot.com/2014/05/fast-polymorphic-collections.html) could even be implemented. This is fantastic. I've needed something exactly like this.
So when I saw the slide on Filtered Sum, I thought to myself that the following code is a better expression of the intent and just as smart performance-wise: auto g = [&amp;]() { auto m = std::partition(v.begin(), v.end(), [](int const i) { return i &gt; 128; }); return std::accumulate(v.begin(), m, 0); }; std::cout &lt;&lt; measure(n, g) &lt;&lt; "\n"; Interestingly, the performance was ever so slightly worse (~0.0007s vs. ~0.0006s) consistently. Since I'm not paid per-cycle-shaved I'd still go with my version, but that was an interesting result nonetheless. Day-later edit: two people noted that I'm not measuring the right thing: /u/mr-agdgdgwngo and myself this morning as I was stepping out of the bed. Indeed, the sorting was not measured in the original test. If we *do* measure the time taken to sort and accumulate and compare it with the time to partition and accumulate then the partition strategy offers better performance.
Most of that wasn't very new to me (yep, optimize for the cache), but using branch prediction to optimize virtual calls is! His poly_collection was also optimizing for the cache (by using vectors of objects rather than pointers), so I was curious how much the branch prediction actually helps. [Here are my results on an i7](https://gist.github.com/jasonmeisel/6351d131058a19e6c7a8): Shuffled Virtual Calls = 0.732676s Sorted Virtual Calls (not incl sort) = 0.530413s Sorted Direct Calls (not incl sort) = 0.026523s Reruns are consistent with those numbers. Looks like sorted calls take about 73% the time of shuffled calls. Of course, directly calling the virtual functions only takes 3.5% (partially because the functions are straight returning numbers, so the accumulate is hella optimized). I'm surprised he's not doing that in his poly_collection class :P
I suspect any compiler that supports r-value references would know to optimize "return std::move" away as well as it knows to optimize "return copy constructor" away. Yeah?
Nope, compiler is probably smart enough, but not allowed to by the standard (except under the as-if rule, when it can prove the move constructor has no side effects)
Ah, that's interesting! Seems like a dumb design decision (of course there may be a solid rationale for it). Thanks for the tip! #themoreyouknow
Thank you (again) for seeing this as well.
Does the same rule apply for copy construction? Correct me if I'm wrong, I understand that the compiler is allowed to do RVO even if the copy constructor has side effects. Is that correct? 
 struct particle_soa { std::vector&lt;int&gt; x,y,z; std::vector&lt;int&gt; dx,dy,dz; }; A `sizeof(vector)` is 24 bytes (3 pointers). This seems rather big. Is this something I should ever worry about?
You can rename `newl` to just `nl`! :)
That's better. 
Absolutely, but you generally have to invest more time than you would with C++, and if you invest even more time in your C++ solution, you really should beat C# in the end. That said, in line with what [drac667 said](https://www.reddit.com/r/cpp/comments/3w77so/can_c_ever_match_c_for_speed/cxtx6da), "use of std::endl in place of '\n', encouraged by some sources, [may significantly degrade output performance](http://en.cppreference.com/w/cpp/io/manip/endl)", and I think other bits of documentation elsewhere (e.g. MSDN) say the same).
C# got async/await a few years back, we are all envious! That said, is this... CORBA reborn? (Shudder ;-))
No, next question.
This is not really a concern: take into account that there's only *one* `particle_soa` object in the app, which references the many (thousands of millions) pieces of data allocated in dynamic memory. Briefly put, both AOS and SOA use basically the same amount of memory.
Maybe ask on https://www.reddit.com/r/cpp_questions ?
I read more thoughtfully your answer and I think now i got the point pretty well, and see why this works... The only problem I still have is that i never destroy the allocator, i just reset the pointer, so i should be careful to destroy the pointers before resetting the memory, if I do it after I guess that the destructors will be called on memory who is not allocated anymore (well it is, but not by my allocator, just a part of the whole big chunk)
no that is fine, the important thing is that the destructor will destroy those as well
Excel's .xlsx files are actually zip archives containing XML data, so you can always use a zip library and an XML library to examine the data. [Wikipedia](https://en.wikipedia.org/wiki/Office_Open_XML) has a good overview, with links to the spec's. 
IOstreams suck equally on GCC. printf usually is 2x - 3x faster. And I much prefer fopen to fstream for reading files anyways.
&gt; iostream&gt; is slow as hell Agree. But there are a couple of tricks to make it faster, at least some times or on some platforms. if (setvbuf(stdout, 0, _IOLBF, 4096) != 0) { abort(); } std::cout.sync_with_stdio(false); And of course avoid using std::endl. Of course it would be really great if current stream's will be made deprecated and replaced by something faster and more powerful whit better interface. 
The aos_vs_soa is especially impressive to me: compiled with -O3, I get a x3 performance improvement with soa. What's also interesting is that even if you use all member variables (dx, dy, and dz are ignored in the sum of the given example), you get a significant performance improvement (x2) with soa. edit: too bad that soa performs much worse than aos if you need random access (not unexpected though). Seems like the choice soa vs aos is not as simple as some say.
AFAIK std::async isslow on OS X because it creates one thread for every 'task'. On windows it uses PPL internally and creates roughly as many threads as there are CPU cores.
I stand corrected.
All file descriptors should now be correctly closed on Unix-like systems I think. Feel free to correct me if I am wrong. 
I watched the entire conference on youtube...sadly it doesnt answer how to make stl stuff compatible with it...I'll also study howard and yours allocator, because they also handle that
Please improve your English before submitting papers or slides. It's horrible reading through lots of mistakes (and you know the equation `if_cant_write_english_properly == cant_write_proper_code` shouldn't be valid but most people assume it's true..)
That function has to return a copy though, so isn't the move useless, and, by induction, has no side effect?
How many objects are we talking about here though? I didn't know about this either, and though it's good to know, I don't think I've ever faced a situation where I've had the need for it (I'm sure there's many places where there is), and if I had a large array of base classes, I'd probably question the design first.
You should worry about it if you're creating lots of those vectors. There are only ~~two~~ six there.
yeah, I don't really see the problem. It's more wordy than the usual 'm_&lt;name&gt;' approach, but it accomplishes the same thing.
see remotion4d's comment above, iostream is slow because it does more than you usually want it to (synchronising with stdio). Turning that off makes a huge difference
That doesn't makes sense, you are falling in the same hole. The point of C++ is to be able to use anything from C level to the highest levels of abstraction allowed by the language. He shouldn't complain about something that empowers the language and you shouldn't complaint that other people needs to use C++ in different ways. 
Excel has these apps you can put into the excel file, one of them being a stock quote app that gets data from yahoo finance and depending on your refresh rate, it updates the stock you put in the cell. Problem with this is that c++ can't read from an xlsx file, and other formats don't support the app so I can't do csv file either.
Interesting, I've been working with similar code just in the last few weeks. What a shame that it's so hard to tease out single pieces of Boost (and yes, I know that there's a tool that does some of that, and yet the transitive closure of even tiny parts ends up pretty big)! My current project needed `boost::string_ref` but we don't use boost. So I took Google's `StringPiece` and warped it to my own needs. `boost::string_ref` comes from Jeffrey Yaskin's `StringRef` and he's also an Old Googler, and you can see that these come from the same source. What's very interesting to me is that neither `StringPiece` nor `boost::string_ref` ended up being completely appropriate. The issue is simple; both of them take a `char const *` and sometimes I want to represent a region of characters that I'm going to write to. So I ended up with a base class called that's generic on the type of the data it's storing, and have two implementations - one which wraps `char const*` called `Bytes` and one which wraps `char*` called `MutableBytes`. Both of them are somewhat generically compatible with `StringPiece` and to a certain extent with `std::string` too. And I also have a series of generic functions to parse and consume various types off the front of a `StringPiece` - looking like: template &lt;typename Data&gt; void consume(StringPiece&amp;, Data&amp;); Really handy!
We'll look into using the CRT for FP parsing in the next major version (not an Update), for correctness and performance. Outside of that, no major improvements to iostreams are planned. It's an endless time sink, in both senses.
Ah, interesting. I wonder if compilers have gotten smarter in the 6 years since that article was posted. 
Ah ok you want it from yahoo, you should be able to get that information using the yahoo url api. i.e something like this: http://finance.yahoo.com/webservice/v1/symbols/IBM,AAPL/quote?format=json&amp;view=detail a quick google found me this library using libcurl, not sure how good it is but could maybe give you some ideas: https://github.com/aphenriques/quote or you could probably whip something up using boost asio fairly easily. 
I bet he'd love rust, it doesn't have an auto keyword! /s
That's true, I can't think of a situation where I actually had a set of base classes that I wanted to call a virtual function on. Generally I prefer eventing/messaging (ie. std::function), although the principle still stands (if there's a lot of overlap in the function pointers, running them sorted could be more performant). The code I posted is running over just 2^20 objects, so it's far from exact. I was just impressed that it worked at all :)
Far from it! IDL does not imply CORBA. IDL 4.0 is standalone. http://www.omg.org/spec/IDL/
I am not sure about this. Windows behavior may be different, I can't help here much.
Ah... actually, there are 3 vectors per line for a total of 6.
You can assign `'\n'` to `char const nl`! :)
[Hwo to get IOStream to perform better?](http://stackoverflow.com/questions/5166263/how-to-get-iostream-to-perform-better). In short: - disable synchronization with C I/O (to get better buffering) by calling `std::ios_base::sync_with_stdio(false);` - if necessary, ensure that the buffer is big enough And, OF COURSE, do not use `.flush()` or its wrapper `&lt;&lt; std::endl` as this completely kills buffering.
Max mtu is 65kb right? If I want to transfer a file larger than that and reassemble it on the receiver, do I need to build my own headers on the data I'm sending? And I thought that I should be limiting the size of what I send in a datagram? Or does the OS split it into packets for me?
Extremely useful blog post, thank you! As a not-so-well-experienced C++ programmer I still have a few questions though. Regarding points 11/16/17: Does that mean I **shouldn't** just put the mt19937 as a private member variable of a class like this? class MyClass { private: std::mt19937 mt; } Is it better to make it `thread_local std::mt19937 mt;`, or even `static thread_local`? Or even wrap it in a `std::unique_ptr`? I'm a bit confused. Regarding points 12/15: Does that mean I should initialize the mt19937 like this? std::array&lt;int, std::mt19937::state_size&gt; seed_data; std::random_device r; std::generate(seed_data.data(), seed_data.size(), std::ref(r)); std::seed_seq seq(std::begin(seed_data), std::end(seed_data)); std::mt19937 eng(seq); 
I'm surprised that the article doesn't even mention xorshift. Is there really any good reason not to use [xorshift1024* or at least xorshift128+](http://prng.di.unimi.it/) these days for all non-cryptographical uses? So far the xorshift variants are not included in &lt;random&gt; but as they are trivially to implement it's not really a big disadvantage. It merely makes the various PRNG implementations in &lt;random&gt; appear as some sort of UNESCO world heritage site.
Just out of curiosity, why UDP and not TCP?
Not much? I've written string_ref multiple times, and even the first time it took all of about an hour.
It's garbage, but it's only 6 characters. People will never completely jump to the new random library until there's a similar trivial random function in the standard library.
It's something out of my control, if I was allowed to, I would use TCP.
Hmm, is that the case? So if I want to send lets say half a megabyte, it would be fine to send a buffer that large with async send? What if packets drop? How do I do packet retransmission if that's the case?
What about sed, grep, cat, or type? The program I was writing was similar to sed (for a very specific and stupid use case). You're right that the OS API should be a faster choice. In my case, printf was good enough while cout wasn't.
You're probably right. I reserve the right to dislike iostreams for over-complicated design however.
&gt; Of course it would be really great if current stream's will be made deprecated and replaced by something faster and more powerful whit better interface. But how would we scare away new programmers without iostream?
Do you have a comment on the design of iostreams?
Dang, ic, thanks!
Good post, but the title was lame.
Ah, there are other systems who use it for interoperability?
Does anyone work for a company that offers C++ internships? I would really like to be able to receive one and earn experience in the field and be able to work with professionals!
No I just upvote it without watching it.
I'm a bit puzzled about people saying things like "the lower order bits are less random" for rand(). I'm under the impression that the implementation of rand is not defined by the standard. rand() could use a Mersenne twister internally, and still meet the standard. I understand that there are some implementations of rand that are complete trash - but surely it would be better to say that rand is unreliable rather than saying it is definitely bad.
The "explicit list" that they're talking about is PROC_THREAD_ATTRIBUTE_HANDLE_LIST, not the stdin/stdout/stderr handles, unfortunately.
I listen regularly to this podcast. It is very well done, interesting guests and topics. They provide links related to the podcast as well. Thumbs up!
Sadly InitializeProcThreadAttributeList, for instance, is not supported by MSYS2, so I went with the mutex lock as you explained was done in .NET. Hopefully, everything is ok with the Windows implementation now. 
rand is only "defined" to be a PRG returning values between 0 and RAND_MAX (which is "at least" 2¹⁵-1).
&gt; template&lt;class T&gt; &gt; class SmartPointer { &gt; T* data; &gt; Allocator* allocator; &gt; public: &gt; SmartPointer(Allocator&amp; alloc, const T&amp; t) : data(allocateNew&lt;T&gt;(alloc, t)), allocator(*alloc) {} &gt; SmartPoint I've started to work with your pointer, however I have a problem...when the pointers are deleted, they call the deallocation function of the stack allocator...and they should call it exaclty in the right order to work, because a deallocation fails if it is not done on the top object
You could always look into something other than MT. [PCG](http://www.pcg-random.org/) has a C++ header that meets the C++ standard's interface for RNGs.
I have no idea how people are able to follow highly technical topics like that on a podcast.
Great guests and content, though not as polished in terms of production as other technical podcasts (Security Now, FLOSS weekly).
If you want to implement error checking in your parent process, whether or not you changed directory successfuly and exec was successful, you could do it, but it woud require one extra pipe. This pipe should be marked as close-on-exec too. You would keep read end in your parent and write end in your child. Then on child side: When you fail to chdir(), you could write single byte to the pipe and _exit(). If you fail to exec, you can write different single byte. If both succeed, you don't write anything and the exec will just close the pipe. On parent side: You just do a blocking read (don't forget to loop on EINTR), waiting for response from a child. If you get one byte, you know an error happened (and you will know which one it was, by testing the byte). The read() will fail if exec in child was successful (because the pipe is now broken). This is basic error checking that comes into my mind, but it require extra resources. I am not aware of any other way to do this. There is simply no way to distinguish EXIT_FAILURE caused by failed exec and the same exit code of correctly execed process.
The answer is yes, you can do it without "libraries", but don't do it, especially not as a beginner. Use a nice cross-platform library like SDL, or I think SFML or possibly Cinder would be even more suitable.
Short and sweet. Thank you for posting these lightning talks!
That's a good point, I didn't think about those. I would still place them as fairly exotic as far as actually writing programs like that goes, but they are a definite candidates for string optimizations.
If that's true, then you need to rethink your entire approach, since you aren't going to be able to change the order objects are deleted in. EDIT - but that really shouldn't happen - objects are deleted in the reverse order from when they are constructed, so theres something else going on if the ordering is wrong for you.
As someone that does scientific programming, I don't think I'll have ton of use for ranges, but I really liked his CppCon talk showing how you can creatively compose ranges to create really compact code.
rand() is permitted to be terrible, and is indeed terrible on Windows. You might ask, "well, can't you make it better?". Changing the algorithm would be one thing (breaking applications which took a dependency on rand()'s exact output), but even if you did that, you'd be stuck with its abominably tiny range. Expanding the range would definitely break applications that weren't expecting 32 bits of output, or whatever. So rand() is effectively unfixable. (The CRT has to be more conservative about breaking users than the STL, where I can be far more aggressive.)
...and that's why we're going to have [randint](http://en.cppreference.com/w/cpp/experimental/randint)
This is cool but I'd be wary of writing code that uses it...
It uses macros and requires that you "declare each type", but [here's](http://cpp.sh/2tezu) a platform/compiler agnostic way to do the same thing: #include &lt;iostream&gt; template&lt;typename T&gt; const char *GetTypeName(); #define MAKE_TEMPLATE_NAME(T) \ template&lt;&gt; \ const char *GetTypeName&lt;T&gt;() { return #T; } struct Foo {}; class Bar {}; MAKE_TEMPLATE_NAME(int); MAKE_TEMPLATE_NAME(float); MAKE_TEMPLATE_NAME(Foo); MAKE_TEMPLATE_NAME(Bar); int main() { std::cout &lt;&lt; GetTypeName&lt;int&gt;() &lt;&lt; std::endl; std::cout &lt;&lt; GetTypeName&lt;float&gt;() &lt;&lt; std::endl; std::cout &lt;&lt; GetTypeName&lt;Foo&gt;() &lt;&lt; std::endl; std::cout &lt;&lt; GetTypeName&lt;Bar&gt;() &lt;&lt; std::endl; }
I have tried listening to cppcast twice, and both times it seems to have some technical problem where it starts repeating itself. Like I'll get 15 minutes in, then suddenly it is repeating something from 10 minutes ago. I try to restart it, and jump back to 15m mark, and it works briefly, then it randomly starts repeating again. Idk what this is about. I guess I could download it, this is probably just an issue with the web player 
&gt; What can we do with just C++ Standard library. anything, but from scratch
Would be great for time series in the natural sciences
I agree with most of what you said, except for the part where you dismissed AOP as a mere buzzword. I find cross-cutting concerns a topic worthy of study, and AOP is one of the more popular ways to address them for now.
Actually, this isn't that bad. I was expected a non-portable hack, but this is pretty clever. It forces the target typename to appear in `__FUNCTION__`, which is forced into .rodata. The memcpy copies it from .rodata into the static variable, and so you have a runtime string of the typename. Everything is linked in C++, so you're not just reading random memory. It looks okay. The downside is that you wind up two copies of the name: one in .rodata and the other in .data. I'm also not sure, but depending what you stick in as the template parameter, you could have several KiB of text in the raw `__FUNCTION__` macro; some of the Boost classes come to mind. Not a big deal in a big desktop app, but definitely a big deal if you've got an 8KiB microcontroller.
Yes, the author is basically using the wrong interface. If instead of politely returning a bool, the function threw an exception and cleaned up, we wouldn't be having this discussion. Still though, you need to be careful.
I wonder about the optimizer. That could be optimized away pretty trivially, while adding checks might fool the optimizer. I don't know that, but I've looked at some of the MS stl stuff from time to time and wondered if that's why it seems to be written in the most straight-forward way possible. /u/stl what's the deal?
How would a pass-the-end iterator be a useful hint for insert?
/u/STL explains why this happens in [Advanced STL part 4 of n](https://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Advanced-STL/C9-Lectures-Stephan-T-Lavavej-Advanced-STL-4-of-n), near the end. TL;DR: this is required if you don't give `insert` the exact element type of the `map` (`pair&lt;const K, V&gt;`). The comparison operator can only compare things of the right type, and because of perfect forwarding, conversion to the right type can only happen once.
What type is the linked code inserting? If you're right, it's not obvious. If it isn't `value_type` what is it? And why? 
Correct, better still if available use C++17 std::map::insert_or_assign which was introduced to avoid mistakes like this. http://en.cppreference.com/w/cpp/container/map/insert_or_assign
The map is a `std::map&lt;StateDesc, DeviceState&gt;`, so the `value_type` is `std::pair&lt;const StateDesc, DeviceState&gt;`. It's inserting `std::make_pair(key, DeviceState())`, which is a `std::pair&lt;StateDesc, DeviceState&gt;` (`key` is a `const StateDesc&amp;`).
This is the common deception. You think you wrote it in an hour, but you really wrote the square wheel version in an hour. 
In general, we assume that the optimizer's going to do its job, and see through the "usual" stuff. That is, we assume it can see through thin header-only functions, simplify arithmetic, etc. We're pretty familiar with its limitations, so we'll avoid doing things it can't handle (e.g. unnecessary allocations/deallocations won't be optimized away, can't see through separately compiled or most virtual function etc.). So the majority of our code is straightforward. We'll add library complexity when we have the high-level knowledge to be cleverer (e.g. sending plain pointers to memmove/etc., the Small Functor Optimization). The main thing that defeats optimizers, that is difficult to realize in source code, is pointer aliasing.
FYI, try_emplace() and insert_or_assign() are supported in VS 2015 RTM.
I've worked on multiple C++ projects that use boost extensively, and if I still had to target pre-TR1 C++ I'd probably insist on using it for everything. Fortunately my current job is mostly c++14 and happens to not particularly need anything from boost (I could delete ~20 lines of some hand-rolled intrusively-linked-list code, but that's about it). The jobs where I wrote string_ref were before it existed in boost.
If you don't care about visual studio would you ever choose this over Boost.Hana?
Absolutely agree with you, maybe I should have put a big "for the love of god, please only ever use this for logging the result of GetTypeName in a dev-only build!" into the blog post. The only instances I use this are when something can't be statically asserted, and I want to have some sort of identification what the template argument T was in e.g. a failed assertion. 
Do you know what the "build host" problem is in net beans?
No, sorry. I don't use netbeans. Were you able to get CDT to work?
`boost::string_ref` might be header-only, but it does depend a LOT of other boost headers. You can use bcp to copy them but who wants one third of Boost in their project directory? (I'm exaggerating of course, but you get the idea). Also, there are many situations when you can't opt to use Boost as dependency (for example, if you are developing a library, a Boost dependency is undesirable).
Apple did not "open source LLVM."
This will set stdout buffer to 4096 bytes. In my test this seems to speedup stdout only on Windows. On OS X I could not see any speedup using this. 
Why not start with something like CppFormat ? https://github.com/cppformat/cppformat Or may be even something like C# WriteLine() and CO. ?
First, MTU's are for the IP layer, not UDP. The MTU dictates how many IP packets a UDP datagram might get split up in to. You are responsible for keeping the buffers you send to async_send_to to within the UDP protocol's datagram size limit (for IPv4, that'd be 65K). The OS will handle splitting up the UDP datagram in to MTU sized IP packets.
I did not know about this series. Thanks very much, looks good!
Ooh... that's sweet. And a slightly nicer solution. But he suggested simply *erasing* one of the strings in the original implementation by hacking the binary. That's what I was talking about.
You can change your mind after watching [a talk](https://meetingcpp.com/index.php/br/items/ranges-for-numerical-problems-402.html) about using ranges together with [odeint](http://www.boost.org/doc/libs/1_59_0/libs/numeric/odeint/doc/html/index.html) to express time ranges in simulation.