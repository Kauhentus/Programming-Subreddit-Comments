That's a half-hour you'll never get back. If you had read the article, you might have found out that nobody (here) is saying C++ is satanic, or that Rust is perfect, and you might have learned something besides.
Please use max() though, it clarifies your intentions.
/r/cpp_questions *
[Image](http://imgs.xkcd.com/comics/technically.png) [Mobile](http://m.xkcd.com/1475/) **Title:** Technically **Title-text:** "Technically that sentence started with 'well', so--" "Ooh, a rock with a fossil in it!" [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/1475#Explanation) **Stats:** This comic has been referenced 324 times, representing 0.3324% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_czegleq)
I work on an older codebase that I had to explicitly update to make it build cleanly under C++11. Among other things, we had strings being concatenated together with macros that sometimes expanded to literals. Those macros were being parsed as user-defined literal syntax.
Heap allocation **must** be implemented in terms of an OS call on any protected-mode OS – how can this possibly be optimized out? As far as the compiler is concerned, this is a volatile side-effect.
&gt; the rest of the program is thoroughly optimized Not really. The rest of the program is just a run-of-the-mill code that just doesn't do much. It's obvious that it's dominated by IO, but still it doesn't even appear in my profile (on the level of 1-2%). You have to be an incredible "optimizer" to minimize the run time down to almost zero.
I didn't downvote, but while Boost is very cross-platform, Folly is not, so it's not a general replacement.
This is the difference between `google.com` and `google.fr` – different countries have different indexes.
I think he meant that the comparison between languages is meaningless, it's really the compiler you're using (and the optimizations it is capable of performing) that will generally cause the differences in performance between these two.
Here's a related write-up which shows how accounting for undef values can inhibit optimization: http://www.playingwithpointers.com/problem-with-undef.html
We're talking about an unused variable. You're talking about a heap allocation that isn't used after the memory is requested. Those are different things. One is just a declaration that isn't accessed, and can be safely stripped out prior to actual compilation. The other is a statement call requesting memory from the operating system and the associated assignment.
&gt; And declaring a variable doesn't use any cycles, it just allocates extra stack/heap. You're the one who brought up the fact that the unused variable can allocate from the heap. Allocating from the heap is an observable side-effect, thus any "unused" variable that does so **cannot** be optimized away. I really don't understand where the confusion is coming from here.
That's because I was referring to uninitialized global variables, not heap-allocated local variables. I do a lot of embedded work, and oftentimes the data/bss/const sections reside as a part of the "heap". And holy shit, why are you trying so hard to prove a point about heap-allocated variables not being stripped out by the compiler, as if that somehow invalidates my point? Can you not grasp what I meant from my original reply??
&gt; Yeah that's great, I code in c89 and c99 as well as c++. Oh, sorry, I thought this was /r/cpp... &gt; There are plenty of platforms that don't wipe memory for you at startup. If the _language_ is C++, then any platform that behaves this way is broken. &gt; You are trying way too hard to win an argument. I'm trying to prevent misinformation; C++ is already hard enough as it is. &gt; Calm down. You're the one swearing at people on the internet, friend.
No problem. Next time don't try so hard.
You do realize this thread _is_ in /r/cpp, right?
How often? Is this a once a year thing? I've been thinking of making this my next project. I've always loved the idea of coding an AI, but I never know it made it this far. Last time I looked into it (maybe 5 years after SC1 came out), people had come out with tools to tweak AIs like the campaign, set how many of what to build and when, but never saw anyone actually take it this far.
Callgrind from the Valgrind suite would generally be my go-to. It's free, and it's very effective for most cases. It can deal pretty well with across-the-board types of slowdowns as well (such as a slow call within a commonly used destructor that isn't much by itself but adds up tremendously). Edit: Thanks to /u/wichtounet, I completely forgot to mention Very Sleepy if you have code that can run on Windows. The tool is incredibly lightweight and can give you some quick results to work off of. If you're limited to Linux, I believe the closest equivalent that I've used is RotateRight's Zoom. I highly recommend those *before* digging in with callgrind. They're incredibly efficient, and they're generally good enough for most people (aside from ultra low-latency applications).
I mostly use perf to profile applications. When perf is not enough, I use VTune. 
If you're on linux, try perf. perf record ./my_program perf annotate https://perf.wiki.kernel.org/index.php/Main_Page 
So you have no other way of sanitising except running a live system? Fair enough, didn't expect that. My code needs speed in prod, but not FPS.
I use Windows Performance Analyzer mostly. It's very powerful - and free too.
gprof and oprofile.
That's true. I completely forgot! Very Sleepy was one of my favorite tools back when I had to do some hard-core optimization (measuring in the microsecond level). It worked incredibly well, and it was practically instant. I wouldn't even consider callgrind/kcachegrind before I've picked all the low hanging fruit off Very Sleepy.
I didn't know about Very Sleepy. I don't use Windows for development, but this seems like a very interesting profiler with a good interface. 
Didn't know about that one. Is it standard, or is it vendor-specific?
I use very often "Very Sleepy": http://www.codersnotes.com/sleepy/ it's free, light, and works weel
As far as I remember (was interested last year), this tournament happens once a year but there is some others (at least 1). But the most important thing is that sscait runs ladder for bots nonstop whole year, so there's no need to wait to put your bot in action against the most powerful ones currently. From my experience - writing bot is definetily not easy but very interesting and API for this stuff is very well made.
Why is that unlikely to happen? Did they abandon CMake development and maintenance??
Standard since C++11, available from Boost before that.
Built-in profiler from visual studio. Not perfect but the tree view with %-ages of time spent + source code view with %-ages of time spent are golden.
One of my favourite tricks if you don't have a profiler installed: run the application, then break when you'd like to know what's going on. Observe the callstack. Now repeat a handful of times. You'll very quickly get a feel for where your application is spending a lot of its time. This works well for unoptimised code because there's usually a severe bottleneck that the application is spending 99% of its time in.
If you have no experience in profiling, I highly suggest you to watch [Chandlers video from cppcon2015](https://www.youtube.com/watch?v=nXaxk27zwlk) He presents google benchmark along common usage of **perf** (which is free) It's really easy to follow and go straight to the point
Java requires less from the developer than C++ for having an efficient code. VMs are really efficient nowadays. Ok C++ will gain mainly because there is no indirection for all data, but how much? 20% from my benchmarks (non trivial)
I have used perf, valgring. I tried to use oprofile... But, I'd rather use VTune. It is just that good in terms of performance, data provided and ease of use. Plus it runs everywhere. Of course, I stopped to use it after the trial period... Kcachegrind and massif visualizer are good valgring frontends. Qt creator have some integration too. Also, you mention chrome dev tools. I imagine you could use that as an ui on top of perf with a bit of script voodoo.
Random pausing. I first heard about it through http://stackoverflow.com/a/378024/1942027 by Mike Dunlavey. He got multiple other answers about it and always recommends it, might be worth checking out his profile if someone wants more info about it.
You'll get no argument from me about the different levels of investment needed for writing idiomatic software in either Java or C++ - but this is a parallel different issue to my core premise: The writing of high performance software requiring low scheduling jitter is fundamentally flawed in a stop the world GC VM (of which the SE Java VM is one). In fact writing such low jitter performance applications in Java requires a different specific skill set and discipline (compared to idiomatic code) equivalent to writing regular idiomatic software in systems that don't have a STW GC - but something like idiomatic C++ offers more maintainable code than writing highly contorted "avoid allocations everywhere" Java. Gaming is just one such domain in which high performance low scheduling jitter is needed - and Minecraft is a prime example of what goes wrong when using such a platform. Had Minecraft been written in C++ in the same memory burning manner as Java Minecraft - it would have shared the cost of those memory allocations across all frames - instead of having lag spikes after some period of time. &gt; VMs are really efficient nowadays. Until there are free implementations of pause-less garbage collectors all this "efficiency" is moot (I'm talking about Java - apparently Nim has a pause-less garbage collector, but I'd be lying to say I'm experienced with it). 
Google perf tools, perf, callgrind, spam gstack.
Nice write-up. The proper C++ solution is infinitely more maintainable than strtok and even outperforms it. Good work!
Great post! Could you please also try the improved boost version which was posted here for the original post? Just so that we know how it fares against the STL.
Remotery is fantastic: https://github.com/Celtoys/Remotery
Well his code showed a 29.5% improvement, whereas [the X3 code I posted](https://www.reddit.com/r/cpp/comments/42ua25/a_quick_study_on_tokenizing/czds61v) showed a 23.1% improvement. So it stands to reason that Tristan's approach will still be the fastest; _and_ it's the most generic, thus generally useful.
AMD CodeXL isn't too bad. Mostly works on Intel, too.
I use Visual Studio tooling.
I don't feel like this a fair argument. I don't think this happen offently in code, event though you are right that this is something that could happen. In the second example, the compiler will understand that the new i is a string and will then consider it as a string (not an int) till the end of scope.
Another thing: how is it possible to *replace* boost with Folly while Folly *depends* on boost?
Have you profiled your code? As it is, I am afraid that: [&amp;cout] (auto first, auto second) { if (first != second) cout &lt;&lt; string(first, second); } completely dominates the time: - you build a `string` per token - streams are slow (in general) - `cout` is possibly even slower than streams (synchronization is necessary, both for multi-thread and potential C interleaved output) If profiling is not to your liking, I suggest that you redo a timing pass with an empty callback to check the overhead of it.
Generally Kitware does what customers need/pay for. If no customer pays for overhauling onboarding documentation, then it's unlikely Kitware will do it. That's also why the creation of 'Modern CMake' was done by me out of KDE needs, not by Kitware. So, if the community wants better onboarding documentation, the community has to create it.
A relative newcomer to the cmake development community recently overhauled the documentation of cmake commands adding many cross-links. https://cmake.org/gitweb?p=cmake.git;a=commitdiff;h=c3f40f4f More opportunities for cross links exist if you want to take them. http://public.kitware.com/Bug/view.php?id=15587
They work a lot on it since 1.0 and it improved a lot. But it is still mentioned as a pain point (I don't really care since all my projects are little). Big improvements are planned.
The SSCAI is once a year. The other major yearly StarCraft AI tournaments are CIG and AIIDE which usually take place in the summer. These bots are programmed with the BWAPI. So unlike the scripted AI that you refer to, these bots can do everything a human player can.
&gt; Again? Rust again on this sub? There is not much rust on this sub. The last post about rust in this sub is 4 month old : https://www.reddit.com/r/cpp/search?q=rust&amp;restrict_sr=on &gt; If it wasn't for the syntax, I would still avoid Rust like the plague because of its users. This is the first I heard someone complain about rust community. They are always ready to help, avoid zealotery and are very aware of the limit of their language. 
The author probably have discovered them recently, hence think they are underrated. Happens way too often
Alexander Stepanov spends his retirement on /r/cpp, nodding in the affirmative at posts like this.
But frankly, they confuse people. For example it took me a while to figure out that someone at a project I work for aliased `bmi` to `boost::multi_index` (especially that `bm` itself is a thing at this project). It might be a cool thing to do when you're the only developer, but when there are more people involved, figuring out what a particular abbreviation (introduced by someone else) means is, lightly said, irritating. And ctags doesn't seem to index namespace aliases so even they're not a big help here. I agree however that there's a problem that some people like to invent `very_long_and_meaningful_names` and of course expose `even_longer_sub_namespaces` as a part of their public API. Yeah, thanks for all these `project::userspace::common::alghorithm::find()`. Or why does said `multi_index_container`, very long name for its own, has to be part of `boost::multi_index`? Why can't it be inside short and nice `boost`? I think however that the solution to this problem is having a set of coding guidelines and doing a proper code reviews, not using namespace aliases.
&gt;As for the peppered variable declarations, I simply think it's bad form and all code that I've read has seemed less readable as a result. That is a personal preference. I used to share this opinion but I've seen to many bugs involving uninitialized variables (often by a maintainer who changed some code between declaration and initialization). This has nothing to do with 'auto'. Declaring a variable only when it can legitimately be initialized establishes a contract that actively discourages uninitialized variables. It is only less readable when switching from one style to the other much like switching between code bases using camelCase and separated_by_underscores.
&gt; those features are there to help organize big programs and libraries, something irrelevant to this exercise. I don't agree. He said almost immediately that he could speed it up with multi-threading and from what I can see, Rust and C++ do that very differently. That's going to be a really good indication of how both languages handle it, especially at the system level. That alone would be worth seeing.
Technically this lets _the standard library implementation_ make that determination, not the compiler. But agreed, those type aliases exist for a good reason.
Genie horse !
I guess a good solution would be a header `namespaces.hpp` that contains all the aliases and only the aliases. Since it is a good idea to keep the number of dependencies low, that file can be relatively short and will give a complete list of aliases: namespace boost { namespace file_system{} } namespace bfs = boost::file_system; namespace boost{ namespace program_options{} } namespace bpo = boost::program_options; namespace some_other_lib{} namespace sol = some_other_lib; Note that this file doesn't need any includes and should therefore be extremely cheap, allowing every other file to include it. And since it should only very rarely change, it also wouldn't be to much pain for incremental builds.
&gt;But frankly, they confuse people. [...] I disagree partly. Some libraries use weird abbreviations for their namespaces already. There is not much of a difference between an externally introduced weird name and an internally introduced one. But the aliased name should be clear, without ambiguity and property communicated. One thing that helps is using them - just like using declaratives - only file or even function local and not in header. If the library provides a namespace alias, this is not the case. &gt;I agree however that there's a problem that some people like to invent `very_long_and_meaningful_names` and of course expose `even_longer_sub_namespaces` as a part of their public API. Which might be necessary. But only for the top level namespace, it should be as unique as possible. The sub namespaces only need to be unique in the library scope. &gt; Or why does said `multi_index_container`, very long name for its own, has to be part of `boost::multi_index`? Why can't it be inside short and nice `boost`? I am strongly in favor of dividing unrelated components into different namespaces (ADL issues, coupling,..) So `multi_index` gets its sub namespace. And since names should be meaningful on their own, the class name should be `multi_index_container`, not just `container` or sth like that. 
Yeah, there was a problem with the video encoding it seems. Working on correcting that, should be up by tomorrow.
I agree that for low scheduling jitter applications, it is certainly better to use C++ than Java. However, without an efficient way to manage the memory, and I do not speak about the GC, it is difficult to have an efficient code in Java and in C++. In addition a GC may perform better than some ad-hoc allocators. There are also a lot of parameters that you can modify in the Java GC nowadays. In my domain (combinatorial optimization) you have to try to reduce as much as possible the allocations during the computation. That's true for any language. Every system reuses memory. The strong advantage of C++ over Java is RAII and the existence of destructor. When moving to Java these thing are missing. The strong advantage of Java is that the language is easy to read and easy to use (whereas C++ becomes a nightmare needed guidelines having hundreds of pages which is ridiculous) 
note that the use of cout is common to all of the solutions, from what i can tell. so replacing it for this example would make the comparisons unfair
Honestly, because your argument just isn't very strong technically. The "good design principle" in modern C++ is generally not to use factories at all unless you have a specific need for them. Why not just: class MyClass { // as before // A delegating constructor to replace the factory MyClass() : MyClass(make_big_string(), std::make_unique&lt;int&gt;(10), ThrowingCtor{}) {} } Your code may be simpler than the try catch stuff in the article, but that is orthogonal to the choice between a constructor and a factory. In practice, people very rarely write such try catch blocks because there's so little you can do (really just change which exception is thrown). Looking through your bullet points, I don't see how a single one of them applies when comparing your solution and the constructor based one that I showed.
agreed on all points. the cout is there to validate the output of each algorithm, when that should be split out into a corresponding unit test
Yes, template specialization. An inline namespace is "invisible" to the compiler, you can specialize things by just putting them into the top-level namespace.
Check out /r/ReverseEngineering as well.
I can recommend the C++ Primer, from this list of books [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list)
Just a quick note that I'm currently rewriting my lexer using your solution. So far, so good. Thanks a lot for a brilliant solution based on stl.
I'm not sure I follow. My example is: namespace MyBizNamespace { namespace v1 { // v1 code } namespace v2 { // v2 code } using namespace v2; } vs namespace MyBizNamespace { namespace v1 { // v1 code } inline namespace v2 { // v2 code } }
This reminded me of http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3593.html and then I noticed that it depends on both Ranges and `string_view` and hasn't really gone anywhere since that initial proposal. And then I was sad.
The compilers aren't the only difference – tcbrindle is using libstdc++ while jbarczak and I are using two different versions of VC++'s licensed Dinkumware. The differences in standard library implementations may account for the different relative performance of iterators_right.
[Just do it!](https://www.youtube.com/watch?v=xSBWklPLRvw) (That's a relevant CppCon talk, by the way.)
It has the same name as the standard output stream, which most people appear to have mistaken it for.
Thank You!
awesome library! it's nice to see how C++14 is improving compilation times :) Anyway, interesting finding that clang is not always the faster compiler! http://boost-experimental.github.io/msm-lite/overview/index.html#performance
For a high resolution timer on Windows, you want QueryPerformanceCounter()
All agreed, except this: &gt; As long as the user doesn't run into a collision, it can be used without hassle. If there is a collision, the alias can simple be #define'd out. You should never require the user to edit any file in the library. - They might not be able to: if the library is part of a `-dev` package, or admin installed, it could well be read-only. - When they later upgrade, they have to remember to make the same changes all over again.
Kitware does do development and maintenance, but bigger projects need a reason to be done - someone paying for it is an easy justification for getting bigger things done. Other times Kitware has invested in larger cmake improvement, such as the Sphinx documentation system I assume. Most of the improvements in CMake come from the community however $ git log --since "3 years ago" --no-merges --format="%ae" | grep -v kwrobot | sort | uniq -c | sort -n | tail -n 20 24 konstantin@podsvirov.pro 25 paroga@paroga.com 27 daniel@pfeifer-mail.de 27 matt.mccormick@kitware.com 28 mathstuf@gmail.com ### Actually Kitware 30 zack.galbreath@kitware.com 31 chuck.atkins@kitware.com 38 gillesk@microsoft.com 38 robert.maynard@kitware.com 45 neundorf@kde.org 48 domen.vrankar@gmail.com 52 bill.hoffman@kitware.com 59 gjasny@googlemail.com 67 clinton@elemtech.com 101 daniele.domenichelli@iit.it 114 eike@sf-mail.de 116 nilsgladitz@gmail.com 161 ben.boeckel@kitware.com 1890 brad.king@kitware.com 2203 steveire@gmail.com so I thinking Kitware is responsible for the improvements you find in CMake oversimplifies dramatically. It seems that most people think it is true though unfortunately. CMake is definitely community-made software. Improving the onboarding documentation is a community task. 
Uh.
I wrote a small, generic [string splitting class](https://github.com/bysin/random/blob/master/string_split.h) that uses string_view and find_first_of.
This is an excellent and thought-provoking article. Thanks for posting. One of the thoughts it provokes -- in my head, anyway -- is that the STL, and generally the C++ way of doing things, has some glaring deficiencies. (Please note that, below, I mean no criticism of the article or its code at all. Rather, I'd like to see C++ offer better support for algorithms of the kind that is discussed.) Near the end of the article: &gt; ... what if we don’t want to output a vector? A generic solution should surely let us use whatever container we like. What if we are streaming in the input via istream_iterator? How do we pass the output to an ostream? &gt; This problem is pretty tricky, but it’s not insurmountable. Why should it be tricky? Operating on a stream of data, and then doing some other operation on the result, is a very natural idea. &gt; Actually, the answer is obvious: we should let the caller do whatever they like, ... Certainly. &gt; ... by letting them pass in a function which we will call every time we find a token. That's an interesting answer. A more traditional STL-ish way of doing things would be for the caller to pass in an output iterator. But of course an output iterator is really just a wrapper around a function call. And a function call can easily just be a wrapper around `*iter++ = ...` on some output iterator. So the functionality allowed by the two options is identical. But neither is really satisfactory -- as I explain below. Elsewhere in the post: &gt; The beauty of the STL is that it provides composable, low-level algorithms from which you can build up complex behavior. Well, kind of. When I say that `f` and `g` are *composeable*, what I want to be true is that I can do `g(f(...))`. Having `f` save its output somewhere, and then applying `g` to the saved data, is a bit icky. So I can pass `g` to `f` as a callback -- the solution chosen in the post -- but that's still a bit icky. After all, what if what I really want to do is `h(g(f(...)))`. Using the callback style, I guess `g` would need to take `h` as a callback. Then I would do a `std::bind` to create a version of `g` for which the callback parameter is fixed, and pass this bind expression to `f` as a callback. This style of code can easily become insane. But there is a much cleaner and truly *composeable* alternative -- in other programming languages. In Python, the above issue is not tricky at all. If I want some function to output a data stream that the caller can manipulate arbitrarily, then I make it a generator. Then operations really do become *composeable*. In Haskell, it's not tricky either: my function returns a list, which, despite the name, is really a lazy stream, just like a Python generator. Once again, *composeable*. But this idea of having a function return a lazy stream often has serious costs. We need something like coroutines (Python) or thunks (Haskell), and temporary storage for stream data needs to be managed somehow. Doing all this in a transparent, you-don't-need-to-think-about-it way adds significantly to both time and space usage. In languages like Python and Haskell, we simply say that this extra time/space is the price you pay for getting these cool programming constructs. But the C++ community -- for good reason -- does not accept arguments like that. So, how can we improve C++ and/or the STL to make things like this work? The interface I would really like to see for this code would be something like the following: lazy_stream split(const string &amp; str, const string &amp; delims); Then, to make a `vector` (say) of tokens, I would do vector&lt;string&gt; tokens(split(str, delims)); To iterate over the tokens, I would do: for (const auto &amp; token : split(str, delims)) ... We can already do the above, by having `lazy_stream` mean `vector`. But we don't want to do that. How can we make it work so that the above is just as time/space efficient as the posted callback-based code?
I didn't mean edit the file. The namespace alias is provide like so: #ifndef FOO_NO_NAMESPACE_ALIAS namespace foo = long_name; #endif The the user only needs to #define the macro to prevent the alias.
Hmm, the history states are actually pretty useful, but it seems that they will be dropped in this library. Is there a replacement for that functionality?
In the current version the history states are not available, however, it doesn't mean they won't be implemented in the future versions (as a policy/extension). The only replacement, for now, is to simulate history states yourself by adding additional logic to the state machine.
Multithreading would tell you about something completely different. What it could tell you would also be interesting, but not as a substitute for what I set out to explore. Adding in multithreading would have made it longer than the constraint, and more dependent on runtime environment and implementation, and would obscure precisely the details of low-level single-thread performance characteristics I needed. A multithreaded program is a set of single-threaded programs interacting when it can't be avoided.
The default alias will potentially conflict with my (or other libraries') names. Having to #define it out sounds to me like having to #define NOMINMAX before being allowed to include windows.h. With a local alias, I can use pretty short names (namespace fbm = foo::bar::memory) without having to worry about clashes anywhere else than in this one file.
... and deadline for submitting talks is tomorrow! Don't miss it!
Sorry, I didn't realise you were the author in my previous reply. I think what threw me in the article is in your opening paragraph, you state : &gt; What’s fast, what’s slow? **What’s harder to do, what’s easier?** I know that later you clarify that it's the "nitty-gritty of coding" but these days, single-thread performance is only a small part of the picture and dealing with multiple threads is just as "nitty gritty" as anything else. I think ignoring multi-threading was a big oversight, as newer languages all focus highly on making multi-threaded code simpler and easier to write (Not just rust, but things like Go and even higher level languages like C# with its fancy TPL). I understand now where you've come from with your article, it was an interesting read and I agree that you've set out what you intended to do, there was just a bit of leeway with interpretation how you've set that up. I would be all over a follow-up article detailing what we've talked about here, though!
&gt; 1st sentence: "we need to know how well it does what C++ does best" Threads is not among the things C++ is known for doing best, in either sense. But now I am intrigued.
A good read, if slightly breathless. :-) I've been looking for a chance to use these since I first heard about 'em a few years ago - but haven't really found any reason to do so. It's rare that I need all of a namespace. So far I've always just brought any specific types I need into my scope with a `using` class. And I'm not sure that this is a good idea! I read a huge amount of code. With all due respect, I don't want to learn your TLAs (Three-Letter-Acronyms) when I read your library code! You don't have to explicitly use namespaces very often at all if you use them well. Looking at the two C++ projects I have open my editor right now, all the code is in a common namespace which is fairly flat - you see lots of clear, terse symbols like `file::open()` (meaning `::ourcompany::file::open()`) or even `copy::copy()` (which is perhaps _too_ terse but is certainly fairly clear). Lots of third party stuff but generally each one is handled in a small number of files with local `using`. So I consider namespace aliases to be "correctly rated" - they're an interesting feature that is _never_ necessary, but can be useful for certain problems. A detail that the author might want to mention is that using a very short namespace alias is not as subject to name collisions as using, say, a very short name for a global variable (shudder). There are only a few places in the C++ grammar where a namespace is legal, and C++ is good about avoiding accidental collisions between namespaces and other token types. 
I argue elsewhere on the page that you perhaps shouldn't be using this feature! I love C++ but it has an awful lot of features and that puts a burden on even a technically-advanced reader. Some features should perhaps be "left in the box" for most projects, and it might be that this is one of them. EDIT: one of the things I hate about /r/cpp is that people downvote without actually commenting. I spent quite some time [preparing and presenting an argument](https://www.reddit.com/r/cpp/comments/432oo0/one_of_c_most_underrated_features_namespace/czfoik6) - if you feel I am wrong, then actually tell me why, don't just click the downvote...
I found that part of the article particularly entertaining, but also a feature to particularly avoid! :-) Making sure you get the right resolution of a name by using obscure namespace magic like that is risky. Your average reader has no idea how this works. You need to write an article like the one above even to understand it! That alone is an excellent reason not to use the feature unless there's no other way to do it... and there are half a dozen ways to get this effect, from lowly `#ifdef`s on up. But more - how sure are you that you didn't screw it up? If the two versions are "quite similar", how sure are you that you really got v2 and not v1? If you make a tiny mistake in the spelling or the signature or just one of the functions in v2, it seems to me that you might resolve just that function to be in v1 - completely silently. So you'd see everything apparently in v2, and it'd all be working in v2, except that one function was still on v1... 
There are flags to essentially wipe the include path and define your own. Maybe not as convenient as you'd like, but it works.
Fair enough. My apologies, I hadn't understood that that's what you were describing.
That was an interesting talk. I've considered trying out Objective-C++, but I'm always put off by how fragile the whole architecture seems. I like my compiler to yell me when I do something bad, not compile a program that will blow up at runtime.
For what it's worth, I agree with you that over use of auto isn't a good idea 
If you're using GCC5.x, then yes, it selects the new `std::string` ABI, which will make your code incompatible with other libraries using the old ABI. Likewise for `std::list`, IIRC, though that's less common in public interfaces than strings. But right now, there's a transitional period where selecting one or the other will make your code incompatible with code using the other option. The other issue is that `-std=c++14` is a GCC-specific option which is shared with clang. What about other compilers? CMake knows how the "enable C++14" request maps onto the compiler-specific option (if required), so that I don't need to hardcode it. MSVC, for example, has no option.
Out of curiosity, what's holding up getting that in?
My favorite part of Objective-C++ is that the following is valid code and does exactly what it appears to: struct Config { std::string foo = "a"; int bar = 5; }; void func(Config); func({.bar = 3}); Glorious C99 features in C++ (and better than they are in C99, where you'd have to explicitly cast the initializer to the struct type).
&gt; those features are there to help organize big programs and libraries, something irrelevant to this exercise Maybe templates were not relevant to speeding up your specific exercise, but using templates to remove indirection and optimize is basically a religion in this language. I'm kind of shocked you even said that.
To be fair, he directly compared the two languages, and it wasn't particularly biased. I don't see any point getting annoyed at him. Save your anger for when people post purely Rust related stuff in this sub; there was a rash of it a few months back and it was very annoying.
&gt; Then, we use make unique, which is basically the same but even more memory efficient. Under the hood, make unique does only one malloc call and calls all the space you need for developer and for the pointer at once. My understanding is that this is true for `std::make_shared`, but is not the case for `std::make_unique`. A `shared_ptr` has some bookkeeping to do, and so it needs to allocate memory for both the object and the bookkeeping. A `unique_ptr` is the same size as a C-style pointer, and has no memory overhead. That said, you should still use `make_unique`, because it provides better exception safety when the order of construction of multiple objects is unspecified.
Looking forward to this one. And going to submit a talk. See you in Aspen!
&gt;It's rare that I need all of a namespace. So far I've always just brought any specific types I need into my scope with a `using` class. Yes, that's one solution. An alias would still help there though. &gt;And I'm not sure that this is a good idea! I read a huge amount of code. With all due respect, I don't want to learn your TLAs (Three-Letter-Acronyms) when I read your library code! If the alias is provided by the library it is well-documented of course. By making the alias file or function local it helps as well. Look at the reply given to /u/virgoerns. &gt;You don't have to explicitly use namespaces very often at all if you use them well. Looking at the two C++ projects I have open my editor right now, all the code is in a common namespace which is fairly flat - you see lots of clear, terse symbols like `file::open()` (meaning `::ourcompany::file::open()`) or even `copy::copy()` (which is perhaps _too_ terse but is certainly fairly clear). Yes but that might not be the case everywhere. &gt;A detail that the author might want to mention is that using a very short namespace alias is not as subject to name collisions as using, say, a very short name for a global variable (shudder). There are only a few places in the C++ grammar where a namespace is legal, and C++ is good about avoiding accidental collisions between namespaces and other token types. But it is still confusing for the user if the same name is used multiple times. I should have mentioned it though. 
Overall, I'd really be interested in seeing examples of this technique in use in a real project - that might really be convincing one way or the other. &gt; &gt; It's rare that I need all of a namespace. So far I've always just brought any specific types I need into my scope with a using class. &gt; Yes, that's one solution. An alias would still help there though. I (very politely) disagree. New names aren't free. Each new name is a cognitive load on the person reading the code - a tiny one, but they really do add up when you have hundreds of names, as a mature project will. Remember that successful code is written once, but read dozens of times... I mean, if you're talking about some local namespace alias with limited scope, that's fine - but I get the impression you're talking about symbols universal to your code, namespace aliases that are valid in multiple compilation units or .cpp files. These symbols are something global you have to "know" to read the code. I'd like to have as few of these pieces of global knowledge as these as possible, because I want people to read and understand the code, because having other people reading and understanding the code reduces the bug count. I think of taking on additional complexity like spending money - I'm willing to do for some actual benefit, but an alias for `some_long_namespace`is pretty tenuous for me. My belief is in well-segmented code, you probably won't be using namespace aliases a lot - though I'd welcome real-world examples... &gt; Yes but that might not be the case everywhere. If many compilation units all have to pull in so many symbols from another long namespace that it becomes worthwhile to use this trick, then it might be a code smell. There are all sorts of rules like "separation of concerns" and the [Law of Demeter](https://en.wikipedia.org/wiki/Law_of_Demeter) which basically say, "Everything shouldn't have to know about everything." Again, some real-world code examples would be extremely interesting here! All these hypotheticals are a bit wearing... &gt; But it is still confusing for the user if the same name is used multiple times. What I meant rather is that if you're using 3-letter namespaces, it's going to be hard to make sure that there isn't ever any literal collision in any code that includes yours, if you're a library or API... so it's a relief that C++ handles this very well and is a positive feature of the "namespace alias" strategy.
I know a lot of people what uses C++ as "C with classes". I mean it is not bad if code-base limits to some basic subset of a language and STL is for some reason forbidden. Because of this way of working with language it could be more natural to write C/C++ in CV for them. It was for me at least. 
&gt;I mean it is not bad if code-base limits to some basic subset of a language and STL is for some reason forbidden. Embedded systems for example...
Thanks for explaining.
Ouch. That's soon. I hope I can come this year! :) Looks like tons of fun!
Frankly, this would be a bit of a red flag for me. Do yourself a favor, don't do that
I just put C++11 to my resume. Not C, not C++14, why? Simply because currently I can only say that I somewhat know C++11. It's a huge language that's just getting larger and more complex... And C is completely different and I have very little experience with it.
As an embedded software person, I admit there are many people doing a somewhat bad job. There are **many** features C++ offers for embedded systems, even without STL. References instead of pointers, namespaces, templates (not done wrong!), compile-time polymorphism, all the `*_cast&lt;&gt;`, etc. Also stuff introduced in C++11 is very useful (e.g. `enum class stuff : uint32_t {}`). I just wish, some people would want to evolve, instead of clinging to the past, to "what they know". 
There was a time when knowing C++ meant you knew C (to a point, it still does) and knowing C meant you knew C++. The last part is no longer true, as working practices in C make for very poor working practices C++. When somebody is fluent in "C/C++", this is either a developer who formed their working experience with C++ 10-20 years ago (when C++ was newer and most people using it came from C), or somebody laboring under the "I can write C in any language" syndrome. Writing that you are fluent in "C/C++" on your resume, may close some doors for you these days.
There are other limitations. For example, I still work on our own proprietary chip, using our own proprietary toolchain. There is no C++11 for me and there never will be because it is simply too much work to expand our compiler. That means that many of the other products that run on our ARM target (where we use gcc) will also have to be this way because they were ported from our proprietary chip and share a common source. We do use all the other stuff you mentioned though...
In fact, [`make_unique()`](http://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique) is C++14 while [`make_shared()`](http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared) is C++11. It was added for consistency: ["That C++11 doesn’t include make_unique is partly an oversight, and it will almost certainly be added in the future."](http://herbsutter.com/gotw/_102/)
C/C++ - "I know better, but I'll dumb it down if required." 
Actually, modern C has many features that C++ does not, such as designated initializers, so modern C++ is not a superset of modern C.
So true! I used to write the same, nowadays I just realized it doesn't make sense. C++ is such a different beast it shouldn't be compared to C. If someone who interviews you think differently - uhh, watch out, antic codebase is waiting to consume another poor soul...
I think one of the major culprits of this expression was the "The C Users Journal", which with the uptake of C++ among C developers eventually got renamed into "The C/C++ Users Journal". However given that it doesn't exist any longer, this is a kind of trivia for old time coders like myself.
Are you willing/able to share the C++11 build script? I've never gotten on with python, which has always made waf and scons more awkward to learn, but is love to see a good example of it in use
Basically 20 years ago knowing one meant knowing the other. 10 years ago that was only half true. Today, that's not even remotely the case and is equivalent to saying C/C++/C#/Objective-C/Rust/Go/Java for all they have in common with each other.
&gt; &gt; Rust is closer to C, performance-wise, than it is to C++. &gt; So it's worse? Seriously, this C is faster than C++ thing is an annoying myth that is not true for any real program optimized on a modern implementation. Even sorting is faster in C++ than in C. I hate English. Or natural languages in general I guess. My point was not that C is faster than C++, it was than C is more *explicit* about performance cost than C++. C++ has a number of *implicit* operations which can clog down the performance of a program and yet are literally invisible in the source code: - copy constructors - implicit constructors - implicit conversion operators As a simple example, a couple years ago Google started committing "AST Matchers" into Clang. One of their first automatic source transformation was to spot instances of `some_string.c_str()` being passed as argument to `std::string const&amp;`. Originally, the function likely took a `char const*` and then was migrated to be more C++-like. Except that silently a temporary `std::string` was introduced, which allocates memory. Rust, unlike C++, emphasizes explicitness. Obtaining a copy requires an explicit `.clone()`. There are implicit operations (`Deref` being a prime candidate) but those are either zero-cost or O(1). &gt; Get some variadics, get some compile time reflection, kick macros to the curb. I agree that macros are a placeholder, waiting for better language facilities. However, given that said facilities are non-trivial to implement and may be insufficient once implemented, I would argue that macros are a *pragmatic* choice: in a simple costs/benefits analysis, they allow emulating those features for only a small portion of the cost. I have not seen any really good proposal for either variadics or compile-time reflection yet; they are wished for, but they are also intimidating I guess.
Weird. That's exactly what I have on my resume. Except I have Java/JavaScript. I mean, they're similar too, right?
Of course, depending on the rest of the resume, I will go further. But at this point, I feel compelled to ask whether the candidate think that C++ is a super-set of C, or if they would use C++ like they would use C, etc. C/C++ is not a thing, The two language are art this point very dissimilar. It is uniquely a candidate master both of them at a similar level. /u/kmhofmann 's anwers is where I am going. Probably a sign they are mediocre C developers too. 
Because developing, testing and implementing an improved toolchain for proprietary technology that doesn't have huge amounts of use cases is really expensive with little value added. Just consider that a huge part of embedded systems work is related to controlling specific bits in memory. These bits are then mapped out to actual pins or another physical thing. Yeah, you could abstract a layer between the pin and which bit you need to control... but if you're doing this on a valve that controls a large volume of oil, need to make so damn well make sure it's been so thoroughly tested that any time saving for the developers is actually not worth it. Now, new embedded systems that are created definitely should utilize the latest tools available... but that's a different story.
I'd say the slash means or and the comma means and. Whether or not the usage makes sense I leave to your judgement. 
C++ is currently missing entire C libraries like threading and atomics. C++ has its own, sure, but they're not compatible. I would say that's pretty big, though there is a proposal to make the C11 standard a normative reference instead of the C99 standard.
I know the difference, but the recruiters don't. You get bonus points in your interview when you point this out to your interviewer. 
C++11 is so different and so much better that someone reconizing that fact is a good sign.
[boost::hana](https://boostorg.github.io/hana/group__group-functional.html) has those
I always just match the language that the job posting uses.
Would the first person reading the resume even know what C++11 is?
Not always but I haven't seen that as a bad thing. The thing is that they probably won't even know what C++ is, if we assume it's the recruitee of the company who reads it first. Today I was in an interview that went well, the interviewees asked me why I had put it like that and I answered similarly to what I wrote here and both agreed. I don't know then what's the best way to put it in your resume, but that's what I do and will do.
&gt; C/C++ is not a thing, The two language are art this point very dissimilar. True, but on the other side most people do not program in perfect nice standard ANSI C or C++, real world applications tend to be a colorful mix of C libraries and C++ code and a whole bunch of platform specific hackery and extensions.
surely you can't expect that libraries are the same!? By that logic, you could say that the difference between C and C++ is that printer and std::four are not the same.
Yeah, now all we need is someone to implement those for our compiler.
Your phone's autocorrect burned you. ;-)
Maybe Daniel doesn't have motivation to finish it: http://thread.gmane.org/gmane.comp.programming.tools.cmake.devel/12589/focus=14821 If you want to help, then read that thread, figure out if there are unresolved design questions, see if there's a resolution to them, and then work on the implementation or ping Daniel about it.
If a 6000 line of 3rd party cmake code are needed for something, then something must be missing from cmake (in the Platform files). I don't know why you think someone would need your gcc-4.8.cmake file with a reasonably recent cmake version or why it would even be appropriate to use that file? If there is a reason, then it must be a cmake bug or limitation, right?
I bloody sure I hope so, otherwise I would not want to work with them. 
Heh, ~~nuggets~~buggers! I'm not fixing it!
Thinking of C++ as a super-set of C and being aware the two languages are quite dissimilar are not mutually exclusive. Why not take it as a sign that they recognise the differences, but instead code in the common areas these languages share becasue they prefer modularity/portability?
What about C11/C++14? :p
&gt;but this is perfectly accurate You have missed at least VLA's. 
&gt; Why not take it as a sign that they recognise the differences, but instead code in the common areas these languages share becasue they prefer modularity/portability? Because unfortunately that's not *usually* what it means when someone conflates the languages on their resume/CV. It *might* be what the applicant meant, but someone with a long list of 30 CVs to review for a position and a half-hour to short list 4 or 5 for interview is unlikely to give someone the benefit of the doubt unless they see something else compelling in the few seconds they'll have to review that document before moving on. My advice to anyone applying for programming jobs is never to use the C/C++ notation. There are lots of people who are going to see negative connotations if they read it. It has no upside compared to listing C and C++ separately if you really do have solid skills in both. If you don't really have solid idiomatic experience with both languages but mix them up anyway, you're risking a default no-hire decision as soon as that shows up at interview because you've lost credibility.
&gt; Why does it decrease their chances? Someone reviewing a resume/CV without prior knowledge of the candidate typically forms their opinion within the first few seconds, and rarely changes their mind after that point. If they're going to spend say 20 seconds trying to get a feel for the candidate, and of those 20 seconds they're going to waste 5 wondering what skill level the candidate *really* has with each of C and C++ and then another 5 wondering whether the candidate is trying to cover gaps or inflate their apparent skill set, that's more than half the time to make that first impression gone, and the reader hasn't even looked at most of those things you think they should be judging a candidate on yet. Thanks for reading to the end of this post. That's more time than most CVs/resumes get before the important decision has been made, and that's why you don't want *anything* that could be distracting or give a negative impression on there.
Every single time one of his blog posts or papers gets posted, I hit myself for not taking any of his classes when I had the chance.
Oh no worries; I am glad that someone spotted the ambiguity and got me a chance to clarify.
I know the opposite is true, but what features are in C that aren't in C++?
Such list carries little meaning. It may be useful for a recruiter looking for keyword and having no technical knowledge, but, beyond that... So you have a flat, loosely sorted list containing everything and anything. Il looks like cheap SEO for buzzfeed. Do you have the same level of skill in all these techs ? Do you know how large the domain of each tech is ? Like, are you well versed in CSS media queries ? xml namespaces ? how about java 8 ? C++14 ? Somehow you should clarify how much knowledge you have in each language and tech. Put a version number when relevant. If you apply for a C++ job, be sure to extend on c++. Chances are, no one will care that you toyed with c# or php 10 years ago during a rainy day at college. and, what the heck is "etc" ? But, be reassured, I have seen worse. stuff like C++/java/html/excel/windows/mysql 
While there are traditionally quite a few advanced talks, there are usually also plenty of tutorials. In fact, normally, there is a tutorial track. Also, if for some slots you don't see any talks that interest you, you can always hang out and chat at the coffee area. I found that sometime this is better than a talk ;-). Overall, I would say go for it, it is a very nice atmosphere (figuratively speaking; the altitude does sting).
But you think they'll type "C/C++"? That seems likely to miss lots of cases; they'll probably type "C++"
There's long long in C++.
~~`long long` is not part of any C++ standard. Many things are available as compiler-specific extensions, but I'm not counting those as part of the language, obviously.~~ Actually, it seems `long long` was standardised as part of C++11. TIL!
As compared to cppcon (http://cppcon.org/), this conference is smaller, more speculative, more experimental, and has a more academic feel. There are many talks about what _could_ be in the language rather than just what _is_ in the language.
long long is part of C++11. See table 10 of [this](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf) document. But you are right of course that there are standard C features which are not in standard C++.
re:{then something must be missing from cmake (in the Platform files)} probably yes for Android but not in general. For example user can set libc++ for Xcode (&lt;6) by CMAKE_CXX_FLAGS="-stdlib=libc++" CMAKE_EXE_LINKER_FLAGS="-stdlib=libc++" CMAKE_SHARED_LINKER_FLAGS="-stdlib=libc++" without toolchain or just download collection and run CMAKE_TOOLCHAIN_FILE=libcxx.cmake. Another example is iOS (some variables not supported by CMake for now): IOS_SDK_VERSION=9.2 IOS_SDK_DEPLOY=9.2 MACOSX_BUNDLE_GUI_IDENTIFIER=com.example CMAKE_MACOSX_BUNDLE=YES CMAKE_XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY="iPhone Developer" IPHONEOS_ARCHS=armv7;armv7s;arm64 IPHONESIMULATOR_ARCHS=i386;x86_64, compare it to CMAKE_TOOLCHAIN_FILE=ios-9-2.cmake. It's an open question about generalizing such approach and I have some ideas for future improvements but it's not a point now. I'm just saying that pre-made toolchain make perfect sense to me and I see no reason why they should contain only paths local to my system. I'm not sure but I think something similar happens in Qt: https://github.com/hunter-packages/Qt/tree/hunter-5.5.1/qtbase/mkspecs re:{then it must be a cmake bug or limitation} it's a workaround for limitation actually, not of CMake but Travis VM: https://github.com/travis-ci-tester/travis-test-gcc-cxx-11
&gt;what the heck is "etc" Seriously? You do not know what 'etc' means? Etcetera. It is a verb used to convey that similarly listed items can be assumed to follow. As in, I would put any other relevant languages there also. And as I covered all the languages I know in detail in a comp sci degree, I feel like listing every single thing is ridiculous (namespaces, why not also list which operators I currently can recall? -_-). How about you assume when I say I am competent in them, that I mean it and it doesn't reference some rainy day thing you may have done? And I was just giving an example of a general resume, of course if I was going for a technical position I would add the relevant details. 
FYI, i write like this on my cv C, C++, D, Erlang, F#, Go, Haskell, Java, Lisp, Rust, Scala Is this better for landing a job than write C/C++. And yes i forget add C# in between of C and C++, and for all of those lang had at least a year exp on real shipped project. Sorry that is a little bit lie, should except Rust.
Sorry, I misunderstood you. I have seen people putting "etc" verbatim in their resume. I have seen candidate where the interview goes as follow "I see that you indicate XML in the list of things you are familiar with" "yes, I know all about XML " "Can you tell me what a DTD is?" *blank stare* "It's a schema to validate an xml document" "Oh but, I have actually only used HTML a few times but XML is basically the same thing, right ?" I had no intention of speaking about XML with the candidate, because it's not relevant to the job and I'm the opposite of an expert on the subject, but putting stuff you don't actually know can end up incriminate yourself. Doing interview is extremely stressful as a candidate. But it is also very much mind crushing for the interviewer. The "people can't FizzBuzz" thingy is not a myth. And all we have to start with is a pile of resume that could as well be a description for a generic CS course somewhere. You may be the best, most motivated C++ developer and I would never know if your resume do not catch the eye. Which is a sad loose-loose situation 
&gt; There are a few instances I said 'few instances' and 'are examples'. I did not indicate this was an exhaustive list.
For those who are interested, here are the results on my system using Boost 1.60, incorporating the fix for [this problem](https://www.reddit.com/r/cpp/comments/432n9h/a_quicker_study_on_tokenising/czf0mtp) to /u/tcbrindle's approach, and adding [my Spirit.X3 approach](https://www.reddit.com/r/cpp/comments/42ua25/a_quick_study_on_tokenizing/czds61v): - Intel C++ 16.0 Update 1 on top of VC++ 2015 Update 1, x64, /O3: 0. boost_spiritx3 (4 statements, 5 if counting namespace alias): 294ms 0. josh (14 statements, 20 total including IsDelim): 389ms 0. strtok (7 statements): 405ms 0. josh_stdfind (14 statements, 17 total including IsDelim_STDFind): 451ms 0. tristan (4 statements, 10 total including for_each_token): 477ms 0. boost_tokenizer (4 statements): 713ms 0. iterators_right (4 statements): 766ms 0. iterators (6 statements): 1031ms - Clang/C2 Jan 2016 on top of VC++ 2015 Update 1, x64, -O3: 0. boost_spiritx3: 320ms 0. josh: 375ms 0. josh_stdfind: 427ms 0. tristan: 438ms 0. strtok: 451ms 0. boost_tokenizer: 689ms 0. iterators_right: 739ms 0. iterators: 1012ms Clearly /u/tcbrindle's approach performs much better with GCC/libstdc++; I'm not sure which makes the difference, the compiler or the standard library implementation. That being said, despite the poorer relative performance in my testing, I still consider his approach objectively "best", even if X3 turns out to be consistently fastest on all platforms/toolsets (which I expect it to be). The full code is [here](https://gist.github.com/dodheim/fb61441d1630327dd842).
&gt; (to a point, it still does) Sure you have to know a small subset of the language and standard library, but that is all. * I wouldn't know the first thing about C best practices * I only know a subset of the C standard library and even the parts I know are full of holes ( portable format specifiers for printf?, argument order of memset, ... ) * Even "essential" libraries for C, like boost or Qt for C++, are not something I would know about. * C style ~~bufferoverflow~~ string manipulation is mostly alien to me, either not done at all or solved using c++ solutions. 
At a large company with a functional hiring process the HR person can ask the hiring manager for clarification, and filtering out companies that don't do that isn't really a bad thing.
Zero people actually use C11 threads and musl is the only libc I'm aware of that's implemented them, so they're basically irrelevant trivia.
I suppose you're right, although in my previous comment I stated my anger isn't directed at the OP &amp; author personally.
Fair point. As I said, I'm more of a C guy and some of the minutia of C++ is not used every day so I forget some things from time to time :-) 
I'm saying that articles that deliberately paint C++ in a bad light shouldn't be posted to this sub. And because of how this article ended, it felt like a subtle Rust advertisement. Which shouldn't be posted in this sub, but its own sub instead.
I do this on my resume: C/C++, C, C++. A lot of companies have these stupid automated parsers for resumes, I split it up this way to cover all forms. I work at one of the big 3. Didn't fail me I guess.
Because they actually mean C+ https://gist.github.com/bkaradzic/2e39896bc7d8c34e042b#file-orthodoxc-md
If you can wait until Tuesday, you will be able to try it...
It could a be a sign that the person writing it could be treating C++ as a superset of C without knowing the differences, for example somebody took a class on C++ and automatically assumes he knows C. This could also be a sign that the user prefers to write a dumbed down C++ as C with classes and depending on your project/needs this might not be the kind of code you want written and the person in question might not know how to write idiomatic C++ because he has been using it as a better C. Of course, I can be very much wrong, but personally it would raise questions and I would ask why he wrote it like this and how he uses C++. Either way, I wouldn't use either notation, I would list each language with the amount of experience and notable projects I've used it for. I say notable because nobody wants to see "Wrote 1 line of code in C for project X".
&gt;Very sleepy Too bad I couldn't get it to show symbols when I compiled my code with clang, I loved it in the past when I used it with MSVC. Iirc it's open source, so it can probably be extended to support executables compiled with clang.
I was going to say C++ is near compatible with C99 libraries, but after thinking about it, the ccomplex header has none of the C99 stuff in it. That kills my point :) 
I kind of figured as much. A new embedded project with a compiler supporting C11 and the choice to use its threads over a more popular library adds up. I'm not afraid to use C11, but the only thing I use C for is small test code things. And my OS course, but C11 in there? Good luck. 
I second protobufs. I use the text format as config files for all of my research code. Protobuf extensions are also a powerful tool when used with inheritance trees.
Think of HR as an attempt at a filtering system to minimize the amount of work required by a developer who will spending more time looking at resumes. They may be removing hundreds for each that makes it through to the developer/hiring manager. Turnover in HR may be high (or they may be contract, etc). In general, hiring managers who receive a large number of resumes may have HR tend towards overly aggressive filtering. As an applicant, you want to make it past the filter. Thats where you end up with resumes that list a massive number of keywords since HR may be operating in an extremely basic pattern matching instructions. I agree that ideally the HR person asks the manager if there is ambiguity but why risk it?
Seriously, they automatically parse resumes and for example automatically reject candidates where they can't find "C/C++" in their resumes?
I thought that might be the case but didn't hurt to ask. How does that work on different platforms with different compilers?
It's pretty straightforward to write a small script to do the job (especially if you plan to do this more often). At work we use JSON files to describe data models. It's a bit different than your example, but the principle is the same. We have python scripts to parse those data model descriptions and generate class files automatically, in whatever target language. This is especially useful if you want to auto-generate correct class methods (equals, hash, string, serialization, etc.) or helper classes (e.g., visitors) for a large number of types. Need a new serialization method or fix a bug? Simply update the generator and it is automatically applied to dozens and dozens of classes.
Do recruiters search with Ctrl+F?
waf looks through your env for known compiler chains. Your compiler flags may be specific to the platform so you can check or indicate which platform your are building for. [WafTools](https://bitbucket.org/Moo7/waftools) are written for more specific uses like NASM.
&gt; Usually there are better ways to tell if someone is full of crap than by whether or not they separated C and C++ with a slash or a comma. Yeah, if a work experience section shows major work in C and/or C++ then it should be pretty obvious. &gt;I've also worked somewhere where we mostly wrote C but compiled wit a C++ compiler. Maybe one or two C++ features were allowed, but mostly they didn't pass code review. It would be somewhat accurate to call this C/C++, I think. I work in scientific computing, and for the vast majority of "C++" code bases I'd say they're basically "C with classes" like where you worked and the occasional template, and probably 95%+ of actual lines of code are legal C. I've been in this environment (and using a smattering of C++11 stuff recently) for 5+ years now, but I've never actually had to be restricted to pure C in any work. I've been writing CUDA where the bulk of the (functional) code looks like C, uses CUDA parallelization instructions, and general program flow and organization is C++ OOP. Not sure what you'd even call that in a half-sentence resume blurb. I write "CUDA, C, C++" but I wouldn't automatically discount someone for writing "C/C++".
C++ was originally called "C with Classes". So it's a legitimate phrasing. You can get a C++ programmer coding C in 20 seconds with this speech: "This is the C Language. You don't have classes, and you use printf instead of cout. Any questions?"
Judging by the way you phrased the question, you know full well why, and this is just another pedantic circlejerk of C++ purists hating on people who also code in C and sometimes don't give two shits if they have some C mixed in with their C++ if it gets the job done.
It's pedantic to make a distinction between two different languages that are, by definition and standards, _two different languages_? Really?
Sometimes using a forward slash is semantically the same as using a comma; sometimes it isn't. Given that the whole topic here is about programming _languages_, as a sometimes-employer, I find people's attention to detail in the _English_ language a good first indicator of their attention to detail in the relevant programming language(s) I'm hiring for. For C++ in particular, attention to detail is a necessity, and I expect a CV to be written as such.
Devil's advocate here: &gt; So template functions and constexpr are cool?
~~Variable length arrays (using [dynarray](http://en.cppreference.com/w/cpp/container/dynarray/dynarray)) are possible with C++14. Objects can be allocated on the stack.~~ Edit: I guess these were voted out.
No; quoting the same site: &gt; After reviewing national body comments to n3690, this library component was voted out from C++14 working paper into a separate Technical Specification. This container is not a part of the draft C++14 as of n3797. And implementation of such a type would require special compiler hooks.
I'm working exactly on this ;) but I have no time to release yet
This is besides the point since the term "variable-length array" refers to a particular C feature, with a specific syntax and semantics, which isn't in C++. The original question was about differences between C and C++, not about the reproducibility of some feature of one inside the other.
Hahaha I don't know. I don't want to even suggest that. What I AM suggesting in that people MAY leak through holes because some HR person saw "C/C++" once on the internet and figured that's the right way to 'spell it'. I'd hate to miss an opportunity because of that.
I was using libstdc++ with clang.
I'm just asking because who constitutes the "big 3" or "big 4" tends to change depending on who's replying.
Thanks for you comment. Why do you think there is a gradual trend in the industry to move towards C++? Thanks 
Also some incompatible code changes. `sizeof('a')` is different in both languages. Using it in a buffer? Good luck!
It's 11th dan mastery of C++. It's two above black belt, and one below rock star.
There's some hefty irony for you
Thanks. :)
&gt; rust allows shadowing inside a scope What's the intent behind this? It seems pretty gross to me. 
The smartest ones might, the dumbest might search with a magnifying glass.
I don't know what they will type, but I am sure they won't match commas. I have been offerred several jobs for "Ruby/Cucumber" as though the two were completely inseparable. I have also had to explain the recruiters that "Ruby/rails" and "Ruby on on rails" are not two different things. That reminds me of this one time I had to convince a recruiter that "C/C++/C#" really didn't belong together.
There's still a C-like subset of C++; similarly there's a subset of C that does translate directly into C++; This is why I think the term C/C++ actually means something other than 'an expression of ignorance'. It could mean that: if you dropped back to 'C', you'd only use the compatible-with-C++ subset - to keep you options open. (I've still heard of recent cases where people aren't allowed to use C++). Similarly, many languages have a C FFI; so if you want to write a C++ library useable elsewhere, knowing 'how to work in a c-like way' can still be useful.
That is great as an option. That is not great as a requirement. It means that I have to copy this file around for every single project I want to use waf for. If I want to use a newer version of waf, I have to replace it in all of my projects. I have to include it in version control. Running waf litters my directory with a .waf-16e1644c17ba46b94844133bac6e2a8c directory, because it has to unpack the waf file. Waf should be part of the infrastructure I can assume, not something that I have to manually think about. CMake is everywhere, partly because I can do 'apt-get install cmake'.
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
But they all start with C! /s
-Wno-error=pedantic.
Then again I work in a smaller company where HR consists of actual human beings capable of thinking (and emotions and other human stuff), so you probably won't miss out because you separated C and C++ more strongly. But really, we should fix our hiring process if the first filter requires things resented by the technical staff.
Well if all languages are separated by slashed I'm okay with C/C++ because of Java/Javascript/C/C++/... But if you write Java, JavaScript, C/C++, ... I and some others get the first impression of a person who doesn't exactly know what they're talking about. I know both C and C++ quite okay and while the both syntaxes are mostly compatible, they're separate languages. Modern C certainly won't compile directly as C++ anymore. The one thing which connects those languages a bit more than others is that you can use C functions directly in C++ code without special compiling, but even there you have to watch out for the `restrict` keyword, for example. And that is the case since 1999, 17 years ago! So you wouldn't mix Java and C#, so please don't mix C and C++.
Build systems are one of those things that everyone uses but which are not thought about all that much. There probably were a bunch of papers on it the late 70s/early 80s. It's not a particularly glamorous thing to work on because 80% of all work is just working around bugs and incompatibilities in compilers/linkers/etc, especially before the year 2000 or so. If you want to know how to do it you probably want to write simple projects (exe, lib, using an external dep) and then seeing what process invocations it does. Once you get a grip on that, look into the code. Meson is probably among the easiest in this regard because it is in Python which is nice to read. As an example a large portion of CMake is written in the CMake macro language, which is not particularly pleasant.
While I do take more than 20 seconds to review a resume, and I try to not let my initial opinion be the deciding factor on whether a candidate goes forward or not, it's a fact that candidates lumping together C and C++ have almost always not been up to the task. I'm usually looking for people with an excellent grasp of modern C++. What am I supposed to make of a list like "C/C++, Java, Python"? I'm not going to think: "Oh, this person probably knows C++11 inside out, and has considerable expertise in template metaprogramming." :D
You are using a package manager to provision your build machine with 'apt-get install cmake'. Committing waf-1.8.19 in my git repo means I have one less dependency I need to hunt down. Not a problem if I am only building on my workstation but when I need to support continuous integration on multiple platforms this becomes quite difficult, especially when 'apt-get' isn't an option. Consider having your build machine isolated from the internet to protect your code signing certificate.
Of course they don't like c++. The reason why rust has been created is because Mozilla was frustrated to work with c++ !
I think the smartest ones probably search with "\bC\b"
I'm not looking for that specifically, but if I'm considering a candidate for a programming position, I'm probably looking for a general idea of the languages/tools/ecosystems they've worked with, their overall level of experience, and what sort of field(s) they've worked in, so those are the parts of the resume/CV I'm going to scan first. I wouldn't personally hold a claim of C/C++ against an applicant as much as I know many other people would, but it still wouldn't instill confidence in their level of experience with either language. You might not like this or think it's appropriate, but no-one ever said the initial short-listing process for job interviews was 100% fair. The reality is that a lot of people in both the C and C++ communities consider conflating the languages a warning sign, and on average they're probably right and they're unlikely to change their view on this, so why risk needlessly putting off someone reviewing your application this way?
Well, clearly we need a schema definition for those JSON files, and then we can create tooling from that, right? :-)
I have never met a recruiter that even know what a regex was. Also, is+ a word boundary or are you hating on C++?
I was kidding. I just meant that would probably be the best way to do it. And actually, this would match both "I know C" and "I know C++", though I don't think you really need it if you are looking for C++, that's a pretty unique string.
I totally missed the joke, sorry.
No worries. I just meant not a lot of recruiters are using regular expressions, like you said.
Pluralsight, Kate Gregory has a great series on there about modern C++
One of the single biggest mental adjustments you'll need to make is with regards to objects and methods. In C++ it's preferred to implement functionality as a free function where it doesn't require privileged access. The main purpose of objects (that aren't simple structs) is to maintain invariants. Inheritance is not generally your automatic go to for abstraction. Generally the emphasis on OO is both different and weaker compared to C# (at least, as far as I can tell from talking to C# people).
If there was a clean interface to access static reflection data (By clean I mean no variadic template recursion and the like, but C++ common constructs such as loops) I would have chosen static reflection. Anyway, as the post says this is not an optimal approach to reflection but one that tries to have a simple API, suitable for teaching.
Since C# 4 (I think), you can use `dynamic` to resolve things at runtime. It makes things like working with JSON and COM somewhat easier in many cases. If you're expecting a structure such as `{ a: "abc", b: 5 }` without any chance of null values, it could be useful to say `dynamic foo = GetJson();` and use `foo.a` and `foo.b` as if they existed while associating `null` with the member not existing.
I'll make a deal with you... Send me any cpp question and I'll make a video and put it on YouTube explaining the answer... I'll keep making them as long as you keep asking.
Some examples from my work in game engine development where runtime reflection is nice: In a property editor. There are non technical game designers (or even technical ones that don't touch c++ and just work in something like lua) who use an editor and need to modify things. With static reflection the editor won't easily support types that aren't defined at compile time because they are in scripts. It is still useful to have access to all of these types through the same reflection system though. Extension via scripting. If designers want to add members to a class that is extended in scripts with script functions and members, you can't do that statically. Runtime compiled c++. By having a runtime reflection system, I can aid my runtime compiled c++ as when a source file is changed, it gets recompiled and the class could be different now. Fortunately I can serialize all instances of the class, link to the new version of the class, and deserialize all the instances back, now with support for all the new stuff that was added in the runtime recompilation, and it still works with the meta system. Also this is an example where runtime reflection is good for serialization. As always, there are pros and cons of both approaches, and you should design your code for the project it is written for with your own constraints and problems in mind. Hopefully I have given you some examples of when runtime reflection can be useful.
I don't know your use cases, but in game engines I have some good uses for runtime reflection, primarily due to the existence of a property editor, extension via scripting, and runtime c++ compilation. For more details see my [other comment on this thread]( https://www.reddit.com/r/cpp/comments/43fk0q/reflection_intro/czib9wp).
&gt;For example I am lost at what a struct... A struct is a class in which all members are public by default. A "member" is a variable or method which is defined in the class definition. When you declare a class in Java, you typically have a series of variables that you declare `private` explicitly, right? That's because class members in Java have package-private visibility when you do not specify `private`, `public`, or `protected`. In C++, the implicit visibility of members depends on whether the object is a struct or a class. That is if you say: struct Foo { int bar; } Then you can access `bar` from any `Foo` object by simply saying `var.bar` anywhere. And if you say: class Foo { int bar; } Then you can only access `bar` from any getters and setters. `var.bar` would generate an error because `bar` is private by default. &gt;...template... In general, templates are the mechanism in C++ by which you allow functions and classes to be generic. For example, in Java if you say `List&lt;String&gt; arr = new ArrayList&lt;&gt;();` then you are utilizing generics. The ArrayList class is actually defined for a "generic" class and so can take any number of types. The equivalent in C++ uses templates. So where in Java you'd say: class Foo&lt;E&gt; { // ...do some stuff using E as the type Foo operates on } In C++ you'd say: template&lt;typename T&gt; class Foo { // ...do some stuff using T as the type Foo operates on } /u/TheCreat already answered your question about operators/methods. Hope that clears some stuff up for you.
Another two good ones are [Tour of C++](http://www.stroustrup.com/Tour.html) and [Programming: Principles and Practice Using C++](http://www.stroustrup.com/Programming/). Both from Bjarne.
People that criticize JEE usually have no idea how CORBA and DCOM looked like.
Oh ha, well I don't even want to really mess with graphics man. I prefer the code-behind.
If you are thinking about becoming a professional programmer you shouldn't think about it in terms of learning a single language. You should be able to program serveral (and be able to use them together in the same system) e.g. use c# &amp; wpf as the frontend and c++ as you business logic layer and python as a scripting language for your business logic layer. That being said learning C++ (again) is never the wrong idea and will bring you ahead even if you do not use it in your job. You learn to manage your resources (especially memory resources) much better which also helps you in garbage collected languages. You learn the similar constructs and patterns which fit in different languages which allows you to reason about programs in a language agnostic way. If been programming in C++ since 2007 and Java/C# since 2000/2003. And as the need arose I leaned JavaScript, Python, Lua, Cmake Script which all became easier and easier the more languages I knew. (Actually the hard part about learning languages was not learning the syntax and the libraries but how to write code efficiently with language specific patterns) 
this one here helped me a lot, if you have a good knowledge of another OOP langauge you will get it quick and understand it well: http://www.cplusplus.com/doc/tutorial/ i would not recommend it to a bloody-beginner. And after reading it from a - z i would just start a "small" project to train these new learned skills. Practice as you will know is the best learning source ;-) EDIT: A good habit as what i have learned is to never use "new" and "delete". Just use the [RAII](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization) idiom to do this for you and smart pointers. It's easier than you might think. This is not Objective-Pascal :D
Awesome response! I have noticed I feel much more comfortable with programming since I learned a bit of C#. I'm looking at Python right now, and I think I'm going to put some time into it as well as C++. Python won't take too long to be comfortable with, from what it seems like, so I'll do it a little on the side just to see how cool some of the things are you can do so quickly with it. Do you program as a career, or do anything like that? I appreciate that advice, and I would definitely like to keep learning more languages. After I become a bit better at C++, I would like to look into a little web development as well. I would like to be well rounded for sure. Thanks!
std::sort only works with random-access iterators. There will be benchmarks against std::list::sort and std::forward_list::sort but the truth is that regular sorting algorithms can't really beat those except sometimes for small objects: the sort member functions of std::list and std::forward_list don't move data around, they only relink nodes, which means that they are automatically better than the algorithms in cpp-sort for lists when moving objects is more expensive than relinking a few pointers. Algorithms aren't allowed to modify the iterators, only the values these iterators reference, so the sorting algorithms in cpp-sort can't take advantage of nodes relinking (unfortunately). If you think you really need the fastest sorting algorithm, the best technique is still to benchmark them on your own typical data and to comee to your own conclusions :)
C++ was my favourite language after Turbo Pascal, back in 1993. I looked shortly into C, but compared with TP was just too primitive and unsafe for me to really care about. Luckily this was around the time C compiler vendors were starting to adopt C++, so I immediately took C++'s side on the C vs C++ wars. In all these years I have used an endless list of programming languages. Nowadays C++ is my tool for portable code across mobile OSes or when I need to step out of my comfy higher abstraction languages. At least until OS vendors start offering other options on their tools for the same use cases. Never become a "X language developer" rather learn from them all and try to apply the concepts into your current language, whatever it might be. Good luck with learning C++.
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Yeah Python is fantastic, it is a joy to program with it. Programming was quite long just a hobby for me, only later did I start with a formal education. Though university did not teach me programming, I did that myself, with the help of books, the mighty internet and lots of practice and even more practice. Your own involvement is key to learning. What I like about the curricula at universities is that they provide you with a great overview of topics which I'd never have gotten on my own. Let alone all the topics which are kinda PITA but still important. Know your algorithms and data structures well. Even when you are using a library, that knowledge will help you in structuring your code and data structures to apply the algorithms in an efficient way. Sometimes it will help you find a complete different solution to a problem which is both easier and magnitudes faster. It is about asking the right question. Some high level knowledge of hardware will help you in understanding that the constants in O(c*n...) do matter in practice. Effects of cache misses for example, or branch mis-prediction. Sometimes doing more work (sorting first e.g.) can lead to great speed-ups. Yet avoid (!) to get bogged down in details, most of the times it makes no difference. After all it is about getting a job done and using the tools that help you to do that. I work in the field of air traffic control systems. We use mainly C++ there. Scripting languages are mostly used for automation and acceptance tests.
Also game engines. Especially in this busyness you should know: *performance matters*. For everything you mentioned, there **is** a concept with static reflection, except runtime c++ compilation which is a point where your performance commits hara-kiri. For use cases, the autor referenced paper [n3996](https://isocpp.org/files/papers/n3996.pdf). There is also a paper about some cases of static reflection: [n4452](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4452.pdf)
Since you already know C# learning C++ is fairly easy. You need to learn modern C++ (iterators, memory management) then get really comfortable with pointers, understanding that everything you allocate has the possibility of creating large bugs and write code in a very "I know where everything is" manner. You will get a ton of bullcrap errors, and knowing what is causing them will take you the most time. C# is fairly nice when it comes to error reporting, C++ although getting there can still produce some really nasty errors for forgetting a semicolon. I went from VB-&gt;C#-&gt;C++ and it took me awhile to grasp the memory management concepts and how the compiler can optimize things but overall you should be fairly "ok" in your endevours. No less learning the different styles of writing C++ is a personal choice but can make a vast difference in how you learn. Pretty much if you read crap, you produce crap when learning. You will see the same effect in C# with learning, you will get better the longer you work at it so don't give up :) https://github.com/kiwidoggie/FrostbiteKeyRetrieval/blob/master/FrostbiteKeyRetrieval/src/Source.cpp Some examples of my coding style. Which most people write off because it looks like type-ish style of writing but it really improves my speed for looking around large projects. Admittedly there are many things I would change about that NOW but the code works, and it isn't the worst thing I've written, but it shows it's age (from my current coding style). Reddit, don't get your pitchforks yet I'm just stating that everyone has their own style and you will figure out what is good for you. Here is a community project that I've done a ton of work for as well written in C++ that you can look at. It's still in it's infancy stages so keep that in mind. https://github.com/AnvilOnline/AnvilClient/tree/feature/base_v1_0 EDIT: Also C++ has multiple inheritance which C# does not which is a blessing and a curse. EDIT2: Bookmark http://cplusplus.com and open that site with like 5 browser tabs and you will be able to have quick referencing to anything you need to use with examples in most cases!
corba is dead and its good that it is.
My implementation currently supports member functions with a fixed signature (i.e. no templates nor C variadics). Check the repo, there are some examples like calling a free function like this: void freeFunction(int a, char b) { return a + b; } int i = freeFunction( myObject.instanceReflection().function("f")(1,2,3), myObject.instanceReflection().field("field") ); About metaprogramming and static reflection, one of the goals of the course is to learn to deal with multi-platform C++ development; so all code there works in Linux GCC/Clang, WIndows MSVC/MinGW GCC/Cygwin, etc. Sadly, Hana is not currently an option if you have multi-platform in mind; and I don't want to reinvent all the Hana wheel and make if work with VS.
I have updated the benchmarks page in the wiki to add quick benchmarks for the few relevant sorting algorithms that are able to sort bidirectional and forward iterators. Unfortunately, there is no obvious winner in the end.
Take a look at gtkmm, unlike Qt it is allows you to write modern C++ instead of almost forcing you to write leaky code.
Not up to me
&gt; std::sort only works with random-access iterators. There will be benchmarks against std::list::sort Sorry I meant random-access. &gt; Unfortunately, there is no obvious winner in the end That's fine. It's about which ones is good at which purpose. You have a nice library to make it easy to test out different sorting algorithms to pick a best fit.
Thank you for the very informative response, I couldn't have asked for more! I do agree that I should focus more on one language than another, that language will be C++. I want it to be my core language. I had a lot of fun learning it when I started it a while back, so I'm very excited to be programming in it again. I believe I can put ninety percent of my time in C++ and then take Python as more of a hobby type deal. All I do at home anymore is program and play with Proxmox on my server box haha. I used to game, but lately I've been having too much fun with this type of stuff. I'm not sure if you mentioned it, but did you get a degree before you got your job? What is it that you actually do? You mentioned most of it was Python based work? As basically a noob to the programming world, aside from actually writing code, I am blown away by how many different types of jobs are out there and all the different types of industries they're in! I've heard people program for insurance companies, games of course, a guy in this thread posted about air-traffic control. I'm always curious what different programmers actually do, because I'm looking for ideas. I love programming and computers and learning, I just want to get into it as a career. I just don't know how long it will take me to even get a foot in the door. I also have a felony for some drug distribution when I was nineteen. I'm twenty three now, but I know that could definitely be a big factor in employment, but then again I'm not sure how much it will matter in the programming world if I can write good code and show a clean track record since then. Anyways, thanks for all the advice brother, I appreciate it a lot!
And as of C++11, smart pointers make any dynamically memory allocation that you do have to do a much nicer and safer proposition.
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0158r0.html
Nice with a function exploiting the bits. I am again and again amazed by what is computable with a few instructions by looking closer at the bits. Explanation for those lesser strong in bit hacks. `(ch &amp; 0xe0) == 0` return false if `ch &gt; 31`. As we decremented `ch` it is `ch &gt; 32`. We now use the fact that `' '` is the delimiter with the highest ascii value, namely 32 and 0 is not the ascii value of any of the the other delimiters. By subtracting 1 from each delimiter and `ch` they now fit into 32 bit values. `0b10000000000000000001101100000000` is the five delimiters bitwise OR'ed together. By bitwise AND'ing it with `1 &lt;&lt; ch ` we get a positive value if and only if `ch` is one of the delimiters. Example with `ch='A'`: | 0b01000000 ('A'-1) &amp; | 0b11100000 (0xe0) -------------- 0b01000000 So 'A' is not a delimiter as the result was equal to 0. Another example with `ch='\r'`: | 0b00001100 ('\r'-1) &amp; | 0b11100000 (0xe0) -------------- 0b00000000 | 0b00000000000000000001000000000000 (1 &lt;&lt; ('\r'-1)) &amp; | 0b10000000000000000001101100000000 (the delimiters) -------------------------------------- 0b00000000000000000001000000000000 So `'\r'` is a delimiter.
I think you should have a read of it again - coroutines are a very desired feature in C++ - no one is denying that, we all want coroutines. What the paper is saying from a design POV is that the proposed implementation has MANY glaring faults - as explained in the paper and the linked/associated papers at the bottom. The intention was for the author of the proposal to rectify these problems via a TS (technical specification), and only once all the issues have been resolved for the proposal to move forward in the standardisation committee. The technical specification process is the process by which ALL major new additions to the C++ standard must go through(language or library), eg: File System, Networking, Ranges, Concepts etc etc etc etc. But for reasons passing understanding the coroutines proposal has somehow been able to circumvent this very singular requirement. And that is the crux of argument, so to recap: * Proposal with provable/demonstrable flaws * Proposal proposing major changes to the C++ language inexplicably circumventing the standardisation process. 
I read it twice. First to get the gist, second to read it more carefully. I'm not saying it's entirely without merit, just that some of the points are just stabs in the dark looking for something to be wrong. There are straight up logical fallacies like saying that a later revision is indicative of the requirement for more careful review. If the point is that it should be a TS like all the other additions, than just make it that. No need for all the cruft which dilutes the main point, which is a salient one.
I'd recommend starting with zlib, which is one of the smallest, simplest, and most useful libraries. You can either get it from whatever package manager is available on your system, or you can learn how to build it from scratch. For the latter, you can use configure/make, or you can even compile and archive it manually - see https://github.com/StephanTLavavej/mingw-distro/blob/master/zlib.sh for how I do this for my MinGW distro on Windows (`gcc -s -O3 -c *.c` compiles, `ar rs ../dest/lib/libz.a *.o` archives to produce the `libz.a` library). Then you just need to include "zlib.h", call its functions as documented, and link with `-lz` at the end of your command line. If that seems overwhelming (and it is; figuring out libraries was one of the last things I did while beginning with C++), then step back and try to make a Hello World library of your own. Simply have a header and a source file, compile the source file, and use `ar` to produce `libmeow.a`. Then you can have another source file link against that library with `-lmeow`. This should grant you a thorough understanding of how libraries are built and used, which is sadly lacking in most programmers. (I should note that these commands are for GCC/binutils; if you're using Clang on OS X then certainly the compiler is different, not sure what they use for static libraries.)
So clear something about about coroutines for me. What I have been reading makes me think that they are (to the best of my knowledge, as I'm not THAT familiar with Python) similar to how generators work in Python? That is to say, you create a function you can call, and at a certain point you *yield* control back to the caller. If you call that generator again, it will resume execution from the last yield point. Is that about what C++'s coroutines will do?
Aww sorry, I really missed the repository somehow. Really impressive work there, not only on reflection!
&gt; but is anyone actually working on an alternate proof-of-concept * https://github.com/chriskohlhoff/resumable-pp * https://github.com/chriskohlhoff/resumable-expressions More information at the end of the paper with links to papers and implementations &gt; So far there doesn't seem to be any alternate implementation of C++ coroutines besides just blah blah blah Lack of complete counter implementations is not a good reason to allow any old thing through the door.
Yes, generators in Python are a form of coroutine with syntax that makes them convenient for their intended purpose but awkward for others (e.g. doing async i/o with Python generators reads really weirdly if you aren't used to it.)
The http://www.cppreference.com is a much better reference site. IIRC, professionals regard cplusplus.com as a scourge.
If they don't, they are not qualified to deal with the resume. I mean - come on, if you're acting in recruiting capacity, you can't be that ignorant.
&gt; I wouldn't be surprised to find competent C++ programmers who weren't competent C programmers Exactly. Even myself I become less competent in C if I don't use it for a long stretch (12+ months) and only stick to C++.
The I would really recommend the newer book. As Stroustrup himself wrote: &gt;C++11 feels like a new language C++11 was a pretty major change. C++14 less so, but it still has some quite nice stuff.
If you listed "felony conviction for drug distribution at age 19" on your resume it would make me more interested in you, not less. 
Thabks for the advice i will try from scratch again :)
Microsoft very very clearly is pushing this through without any proper evaluation. We don't need next-gen range-for. We declare our variables in C++. What we need are suspend-down coroutines.
Users don't need to understand how it works, because from a user's perspective it's very, very clear.
&gt;And since names should be meaningful on their own Ew, god no. No. Fully-qualified names certainly should be. But repeating the namespace in a name is awful. `library::multi_index::container` or `library::multi_index_container`. Not both.
I had read and posted about that paper earlier [here.](https://www.reddit.com/r/cpp/comments/3t5wum/201511_postkona_mailing_available/cx6t835) I don't see the "MANY glaring faults". There are some tradeoffs, obviously, most engineering decisions involve tradeoffs. Anyways, I'll quote my previous post: &gt; Honestly, p0158r0 reads a bit FUDish to me. It seems to say: "Lets wait for the perfect design". It ignores a) there is no perfect design and b) people have been using do-notation in Haskell for over 15years and await in C# for over 5. Everything in life has risks, whether the risks are worth the returns is the question. Lets take a look at the risks in the paper: &gt; * [2.8.1 Maintenance Risks] - This sounds familiar. The old "monads are viral" argument, around for as long as monads have. All monads are viral, not just the continuation monad. And its a good thing. One look at a type signature makes it clear what I am dealing with. In Haskell you even have to make side effects explicit in the function signature (the IO monad). &gt; * [2.8.2 Security and Performance Risks] The particular example they gave seems to be solvable by tweaking await_ready to return false after a set period of time. I am not sure how important the issue of jitter is in practice. &gt; * [2.8.3 Correctness Risks] Yes, there is no guarantee that a particular continuation will be called on the original thread. I doubt how critical this is in practice, except for GUI work. They talk about C#, but to my knowledge C# also only does it for GUI threads. Other continuations can be called on any threadpool thread. And its easy to do this for GUI work, since GUI's already have an event loop. &gt; So, in conclusion, both my earlier points stand. Await based designs are both more general and more performant than generator based designs. Await design is also more theoretically sound. I do not see why we should prefer P0114R0 over P0057R0.
&gt; What we need are suspend-down coroutines. We need coroutines for sure, but why specifically "suspend-down" ? BTW, I could not find any literature on coroutines using the term "suspend-down" / "suspend-up" as used by Kohlhoff et al. Can you refer me to any paper on the differences between the two?
By that rationale, neither are list, vector, etc.
I suppose there are plans of integrating it with upstream, right? Is there any date/milestone when we can expect it to happen? How complete is work at this point?
That completely defeats the purpose of namespaces. Obviously `container` is a bad name. Call it `boost::multi_index_container`. It doesn't need to be in a subnamespace. Deeply nested namespaces are shit.
We have just released [an updated version 5.5.15.1](https://sourceforge.net/p/sobjectizer/news/2016/02/sobjectizer-v55151-released/)
Coroutines is a 50 year old field in computer science. Surely Kohlhoff would not be the first person to discover this "suspend-down" model? He cites no references for this in his paper. Where should I look if I find Kohlhoff's explanations inadequate ?
It is not sensible if it actually *means* `multi_index_container`.
If you read sections 2.1 and 2.2 in p0158r0, where Kohlkoff defines suspend-up and suspend down, he does not seem to be talking about C++ in particular. I quote from section 2.2: &gt; The suspend-down model works by delegating the mechanics of suspension to what looks like an ordinary function. In other words the "suspension point" is encapsulated by normal scope boundaries allowing the caller to interact safely with coroutines without needing special modifications. What is C++ specific in this? Further, he goes on talk about call chains. Things like stack and function and call chain exists in lots of programming language, nothing C++ specific. So, again: * Why should we prefer this "suspend-down" model of coroutine, whatever that model is? * Where should I look for literature about this "suspend-down" model if I find Kohlhoff's explanations inadequate?
We didn't build it. We had it made by [those](http://www.devtools.com/) people. 
&gt;Where should I look for literature about this "suspend-down" model if I find Kohlhoff's explanations inadequate? An English language textbook, given that you clearly lack basic reading comprehension.
&gt;Yes, deeply nested namespaces aren't that great, but sometimes necessary. No I disagree. I don't think they're ever necessary. &gt;But this also applies w/o nesting, e.g I have memory::memory_pool instead of memory::pool. I disagree in this place. It should be in `foo::memory_pool`. Libraries shouldn't be called `memory`. 
What has the year got to do with anything? If you want to use tools BECAUSE 2016 then why are you using C++, which is old and crufty? 
Why don't you just explain all of what you just posted to your students? EXPLAIN why `rand()` is problematic (don't just say it's bad, EXPLAIN WHY it's bad). EXPLAIN why `&lt;random&gt;` is worth using.
I'm currently looking for collaborators to integrate it upstream and maintain it. Hopefully those collaborators would be developers of editors/IDEs and have expertise about what they need. Kitware is unlikely to put effort or investment into it. I'm trying to drum up interest in the community to make it happen! 
&gt;No I disagree. I don't think they're ever necessary. You shouldn't put unrelated things into the same namespace, this increases coupling and has name lookup consequences. There is thus an "umbrella" namespace like `boost` for bigger libraries and a sub-namespace for the components. &gt;I disagree in this place. It should be in `foo::memory_pool`. Libraries shouldn't be called `memory`. The actual name is `foonathan::memory::memory_pool` with `foonathan` being the umbrella name and `memory` the component name. 
That's like saying comparing two types of apples doesn't make sense.
The fact that you can call functions containing suspension points as ordinary functions in so-called "suspend-down" model is important. It allows you to use the same code for both resumable &amp; ordinary function. That said, I like await-based design much more than generator-based design. I hope we can have a suspend-down+await design eventually, I have a [dream](https://gist.github.com/jamboree/e2abdd404daf5e7eac05)...
Your third paragraph is gold. Such a great list of things of what it _really_ means to know a language.
Performance matters, but not all games have so much going on that we need to go the most optimal route every time. When we write our own stuff, sometimes we write code for "elegance", sometimes we write it once to just work, sacrificing speed in the process. These solutions are not *bad*, they're simply not optimal. When speed is an issue we can do performance analysis. incidentally it's possible that my use of runtime type informations during loading will soon be my biggest (if it's not already) bottleneck, but I'm going to write a multi-threaded content system first, as it will be a more interesting problem, and is more valuable in the long run than me spending time rewriting a reflection library that comes with our chosen scripting language. Edit: And thanks for those links!
Um, OK :) More seriously, though: when you're dealing with a lot of stuff, it's very easy to forget little things. I usually deal with some software (usually on the spec/interface side), some firmware, some circuit design, some design-for-manufacturability, some standards compliance, and whatever else comes my way. If you have to deal with a sizable portion of a large standard like IEC 61158, something has to go away to make room. Once you get back to that C code you last worked on 20 months ago, there is a relearning process, and there are indeed some idioms you forget. It's no different than with a human language: you *will* forget some idioms/phrases/figures of speech in as little as a year - student or not :)
Yes, Paradigm bought the code from Borland. It is for x86.
Next thing you'll tell me your stuff runs on NEC V20 or something. Sweet memories :)
We are moving towards embedded Linux on ARM targets since last year. We also have Power PC targets. Things die slow in the embedded world... :)
* suspend-down == stackful context switch == suspend by call * suspend-up == stackless context switch == suspend by return 
Both these papers are talking about stackless coroutines. Stackful coroutines is a different proposal.
I've got Visual Studio, but i'm having a hard time configuring it. Could you explain to me how to get started with that.
As they say, 'The 90s are calling, they want their compiler back'. I guess you should be thankful that they don't use Cfront... Assuming you use windows, VS Community is good. BTW r/cpp_questions is better place to ask questions.
In Visual Studio 2015, click on New Project. Then choose Visual C++. select Win32 Console Application, and Click OK. Then click on Application Settings and Uncheck Precompiled headers and SDL checks. Check Empty Application. Click on Finish. Then right click on Sources and select Add New Item. Select C++ file and click Add. You can then type in your C++ program and Click on the Build-&gt;Build Solution menu to build your solution. By the way, if the school you are learning in uses Turbo C++, they are teaching C++ very, very badly, and you will be a horrible C++ programmer when you are done with that course. If you want to learn decent C++, you will need to take it upon yourself to learn Modern C++.
Not on Reddit. There are a lot of "getting started" guides for visual studio. Unless you have a very strange computer, though, it should just work. May I suggest the 1-2 punch of being a programmer? Google and Stack Overflow.
Its actually VS 2015 Community nowadays (as u/STL corrected me last time). [here](https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx)
my english is fine, but i really can't follow this guy. 
Thanks for the interesting link. Going through the thread, my impression is that list monad may work with pure functions, but there is no way to ensure purity in C++. I need to give that thread a through read, Regarding await and suspend-down, one of Kohlhoff's criticism of the await based design is the viral nature of monads. If you add await to what proposal, what makes the two proposals different?
I thought it was enlightening when you explained: modules are orthogonal to namespaces.
A compound-requirement does not *evaluate* the expression. It merely determines if it is valid (for a set of template arguments). The example does indeed work. x.Stuff("") is valid when x is a Foo. Concepts are designed to reflect the way that templates use their arguments. If you write a concept that passes a string literal to a function, then any class that accepts std::strings (by conversion) would also work with that template. Concepts are not a general purpose, compile-time introspection tool. Nor are they a general purpose template metaprogramming tool. If you *really* want that, then you could do this: template&lt;typename t, typename U&gt; concept bool Same_as() { return std::is_same&lt;T, U&gt;::value; } template &lt;typename T&gt; concept bool CheckStuff() { return requires { { &amp;T::Stuff } -&gt; Same_as&lt;void(T::*)(std::string)&gt;; }; } But that won't help you if you're looking for overloads. 
Instructions for making your own PDF version are [here](https://github.com/isocpp/CppCoreGuidelines/issues/23).
C++ Modules has been in the works for a while.
Interesting and useful stuff, but: &gt; [...] and a companion library called Turf. Turf is an abstraction layer over POSIX, Win32, Mach, Linux, Boost, C++11, and possibly other platform APIs. Seriously?! Not another layer again, please.
I came here to say the same thing, and even cmake isn't really reasonable. A data structure like this could easily be one .hpp file that would work with C++11.
Too late! :)
My problem was more with the interviewer, who only let the guy speak a snippet and then repeated it over whatever he was trying to say. 
&gt; the school i'm learning in what is your school ? seriously there should be a class action against; it's a prejudice against the entire industry
&gt; Is that about what C++'s coroutines will do? Yes, with added benefit of being very, very cheap.
The interviewer was at least understandable for me, but yes he indeed interrupted him a lot repeating the exact thing he was trying to say.
Yeah sure, like Boost. And what about those without a C++98 compiler?! And did you think about people without a C++ compiler AT ALL!?!
Ok but I mean, was it really necessary to add another dependency to an interesting piece of code that could have been easily re-used? Every single company I worked for already has its own "100% Homebrew better-than-everyone-elses Platform Abstraction Layer". And there are already hundreds of similar open-source projects, most of which maintained by a single person. Don't people have better things to do that rewrite PAL again and again, and on top of each other?
Thanks, bold text is easier on my tiny brain. Who out there has the flexibility to use a random project off the internet but doesn't have the flexibility to be able to use a C++11 compiler?
"Awesome" As someone who deals with people thinking `iostream.h` is still a thing, "awesome" isn't the word I'd use.
Then it's only "new" as in it hasn't been around for very long, but it's not really modern.
Heh, I agree. I didn't mean "Awesome! Turbo C++ is Awesome", I meant more like... "Awesome! I remember when that was a thing!"
CMake was indispensable for developing Junction and actually testing it on different platforms. Couldn't have happened without it. And developing it was a very iterative process. I honestly didn't know what the end result was going to look like. I just had some ideas I wanted to try. Now that it exists, you're right, the data structures could probably be pulled out and converted to a nice header-only C++11 lib. I can totally see that helping with its adoption. But it's still alpha software. There might still be bugs and there are definitely possible optimizations remaining. So perhaps it's a blessing that, for the moment, a bit of commitment is required to drop it in. :) 
They still would be with local imports allowed: the declarations made available by an import would still be the same in terms of the namespace they exist in; the difference is just that the declaration wouldn't be available to the whole translation unit: void foo() { import std.iostream; ::std::cout &lt;&lt; "foo\n"; } void bar() { ::std::cout &lt;&lt; "bar\n"; // error, cout not available } The current language allows a limited form of this for some kinds of entities: you can put an extern declaration for a variable or function in a function scope: void foo() { extern int i; void bar(); i = 10; bar(); } This is bad practice but only because of the limitations. Generalized importing of symbols could be a worthwhile addition. Of course keeping things simple for the initial spec is also reasonable.
Okay, sure. At the time, there was nothing wrong with it per se AFAIK. I think that compiler is older than I am, though, so I consider myself lucky to not have unlearned things when ISO standardization happened.
I'm not going to comment on libraries in general. Only Turf. Also, keep in mind we're talking about a free library developed on personal time. Was it necessary? Yes. Turf's hidden agenda is to help the person who develops concurrent data structures. It's already let me: * Route 3rd party concurrent maps through DLMalloc to compare precise memory stats. * Set thread affinities to get more stable benchmark results. * Compare the precision of different CPU timers. * Test different implementations of synchronization primitives (condition variable, semaphore, futex based) side-by-side. * Make an in-memory thread log, critical for debugging Junction, that write sensible TIDs on each platform. * Other stuff... you get the idea. Does it introduce a runtime penalty? No. Check the benchmark results. Are there developers who can't use C++11? Yes. See [this talk](https://www.youtube.com/watch?v=lVBvHbJsg5Y) at 6:00. That was given at a major C++ conference barely 4 months ago. 
C++ Modules have been designed given the (unique?) constraints we that: (a) it has a fairly involved set of name lookup rules (anybody knows exactly how many we have?); (b) it has been intense industrial use over 30+ years. This may not end up being the exact replica of a module system in anyone's favorite language (I have a few that I like), but the primary focus has been on solving C++ problems under the constraints that the language and its usage impose, with an eye toward simplicity and ease of use. See the design paper for more elaboration. I am curious though: how do you envision a "scoped imports" would speed-up compilation? I would have imagined that a scoped import require *more*, no less, possibly repeated work from the compiler.
steve, the interviewer here. good feedback. thanks. this was a new format for us and we're listening and I see what you mean after a re-watch. I think I know how to improve next time, so thanks much. hopefully my over-repetition at least helped out the person who had trouble with Gaby's accent :)
That sounds reasonable, although it's a shame it ended up here when it is still alpha. Things like this are needed in a big way however, having done a lot of concurrency myself, I feel like I end up 'discovering' lots of very generic templates that I haven't seen anywhere. One thing I can't say enough good things about is the moodycamel concurrent queue. That was made by 'some guy' but it is the backbone of all the concurrency I've done. 
Some major differences between the 2 proposals: * [Gor] reference semantic v.s. [Kohlhoff] value semantic - With reference semantic, you can only manipulate the "handle" to the coroutine, copy the handle doesn't copy the coroutine state; with value semantic, you manipulate the coroutine itself, if you copy the coroutine, the whole state gets copied. * [Gor] await v.s. [Kohlhoff] plain-suspend (break resumable) - `await` is a higher level abstraction than plain-suspend, it has a nice feature that ensures the coroutine is safely resumable before you register it as the callback. * [Gor] suspend-up v.s. [Kohlhoff] suspend-down - suspend-down: let the callee implicitly suspend the caller; suspend-up: the caller has to explicitly suspend itself. Personally, I like the combination of reference semantic + await + suspend-down, like what I [dreamed](https://gist.github.com/jamboree/e2abdd404daf5e7eac05). 
And how many who are working on codebases so old and large that they can't migrate them to a modern compiler, are actually going to integrate a _concurrent_ hash map?
 ::std::cout &lt;&lt; "foo\n"; People don't actually prefix `std` with `::` in real life, do they? I can understand prefixing individual function names with `::` if you want to turn off ADL explicitly, but `::std::` seems a bit verbose. --- Anyway, I don't think there's really a relationship here. Just because you import everything in `boost::asio` by doing `import boost.asio;` at the top of your file, they're still qualified. import std.cppio; import boost.asio; void foo(...) { using boost::asio::ip::tcp; std::fstream f(...); tcp::socket s; } void bar(...) { using std::fstream; fstream f(...); boost::asio::ip::tcp::socket s; } Just because you import something that doesn't automatically do a `using namespace` on some namespace associated with that import like it does in C# or Java. 
I guess my English doesn't work on low power platforms.
Edit: the answer to my question was no. 
&gt; My question is: What exactly do you hope to gain from such a review? Design is hard. It's always good to see how real applications have solved certain challenges. I particularly enjoyed [The Architecture of Open Source Applications](http://aosabook.org/en/index.html).
Sorry for the format , updated it. I believe many people would be enthusiastic about UE4 ( I might be wrong , perhaps not everyone would be as much interested as me ) . UE4 is a real time AAA game engine. It is just not any other game engine. It is widely used. Therefore I would be interested in tons of things , for example : - how they designed spin locks or what kind of locks or lockfree methods they are using for different scenarios etc.. ( after a quick browse, i noticed they have both intelTBB and obviously their own thread safe containers etc, ofcourse that is not a big deal as real time core engine devs and tool developers will use different techniques ) - How they designed their memory allocators , how it scales as the number of CPU cores increase... - Template usage in order to avoid code bloat - The data structures they implemented and why - Any signs of build time optimisation except obvious ones such PCH, perhaps PIMPL , but perhaps some leads in comments. As the documentation states, it might take between 10-40 minutes to build it depending on your system - STL usage - Inline assembly usage , SIMD/AVX usage, CPU prefetching , cache oblivious algorithms etc... - As it is multi platform how they are doing platform abstraction , there was a 1 hour video from Microsoft last year in Cppcon14 regarding developing MS Office for multiple platforms. Obviously UE4 is supporting even more ! - For people who are interested in GFX, to what degree they are using low level APIs, any d3d12 or Vulkan etc... - Tons of others things I can`t think of at the moment...
PVS-Studio did UEEngine as another of their interesting marketing pieces around their static analysis toolchain: https://www.unrealengine.com/blog/how-pvs-studio-team-improved-unreal-engines-code http://www.viva64.com/en/b/0249/
Yeah thanks, and sorry forgot to mention that one as I was more into to inner workings.
I can't believe the moaning on here. Jeff's blogs and code samples have been invaluable to me and many others. He educates, measures and writes damn good code. Turf is actually something useful to me as I was just needing atomics in a backport to C++03 compiler in a legacy codebase. MoodyCamel's concurrent queue actually uses some of Jeff's primitives. Thank you Jeff
You can certainly write in shared-nothing style in C++ where the threads communicate using message passing and heaps are thread-local. If done right, for some workloads this has tremendously positive performance and code comprehension benefits. It's also fundamentally impossible to do on a JVM, because there's no way of instructing the VM that it should keep a thread-local heap...
Of course you are perfectly free to spend your time on whatever you want, reinventing a free wheel during your personal time if you like. Don't get me wrong, I didn't complain about runtime performance or availability for non-C++11 compilers. Just that other PAL already exist that do all of this, and that are more popular, more maintained, more available. Boost for example. I work for a company that does not use C++11-compliant compiler most of the time. And instead of rewriting our own PAL, I think we definitely should have spent time on porting Boost instead, it's not that hard and it would have been so much beneficial. (Or even better, porting libc++) 
The more important question is: what is the benefit of *not* leaking it. How does not leaking help? It doesn't :)
&gt; If you want to use the delete operator to delete them manually, don't give a parent. That's false. The following code works just fine: #include &lt;QtWidgets&gt; int main(int argc, char ** argv) { QApplication app(argc, argv); QWidget window; QVBoxLayout layout(&amp;window); QPushButton button1("Top"); QPushButton button2("Bottom"); layout.addWidget(&amp;button1); layout.addWidget(&amp;button2); // at this point both widgets have parents window.show(); return app.exec(); } When `main()` returns, the objects are destructed in the reverse order: button2, then button1, layout, window, finally app. It works just fine. By the time `window` is destructed, it has no children. What you don't want is double destruction or attempting to free objects that weren't allocated on the heap. This is invalid, for example: #include &lt;QtWidgets&gt; int main(int argc, char ** argv) { QApplication app(argc, argv); QPushButton button1("Top"); QPushButton button2("Bottom"); QWidget window; QVBoxLayout layout(&amp;window); layout.addWidget(&amp;button1); layout.addWidget(&amp;button2); window.show(); return app.exec(); } When `window` is destructed, it will attempt to delete its children button1 and button2, **since they exist at that point in time**, and that's UB: you can't `delete` objects that weren't allocated by `new`. Thankfully, C++ has a well defined order of object destruction - as long as the code you write is correct, it will all work.
I agree with all you wrote but I was explicitly talking about objects allocated on the heap using 'new'. Stack allocated objects are destructed like you explained, as expected when they go out of scope/whatever. Please elaborate if I missed your point. I just quickly read your text at school.
Your entire post reads like a for hire piece written by an intern in HR who doesn't fully understand programming but knows enough to sound like they know what they're doing. If you can't tell you're using Buzzwords then you really don't know what you're talking about, no offense.
Thank you very much for such a thorough reply! I will go ahead and read the first edition as it is what I have. 
It works exactly the same with `delete`. The `QObject` doesn't care how it gets destructed. In fact, there's no way for a destructor to detect whether it got invoked through `delete` or by falling out of scope. #include &lt;QtWidgets&gt; int main(int argc, char ** argv) { QApplication app(argc, argv); QScopedPointer&lt;QWidget&gt; window(new QWidget); QScopedPointer&lt;QVBoxLayout&gt; layout(new QVBoxLayout(window)); QScopedPointer&lt;QPushButton&gt; button1(new QPushButton("Top")); QScopedPointer&lt;QPushButton&gt; button2(new QPushButton("Bottom")) layout-&gt;addWidget(button1.data()); layout-&gt;addWidget(button2.data()); // at this point both widgets have parents window-&gt;show(); return app.exec(); } The scoped pointers will `delete` button2, button1, layout, window, in this order. Both button1 and button2 have parents, and it's perfectly fine to delete them *and* their parent widget! I'm not doing manual deletions here because that's bad style and completely unnecessary. If `QScopedPointer` is confusing, think of it as doing auto window = new QWidget; ... int result = app.exec(); ... delete window; return result; See how clunky it is? UGH. Furthermore, the explicit heap allocations aren't necessary either: use automatic storage (stack isn't a thing in C++). Or as member variables in your class, or its PIMPL. It's very rare that you need to allocate any `QObject` or `QWidget` explicitly on the heap. The only times you should do it is when they dynamically come and go or are in variable numbers. After lots of old code cleanups in a 100k line codebase I have maybe 50 heap instantiations of QObject or QWidget, while there's thousands of them created as members or local variables.
Who cares about spin locks? It's just an atomic test and set in a while loop. No STL, no PIMPL, their own custom build system called Unreal Build Tool, look in ${PLATFORM_NAME}_platform.[ch]pp. That will basically answer most of your questions. As for inline assembly I'm pretty sure they got rid of it since they started supporting more platforms. If they use SIMD, which I'm pretty sure they do, look in their math library, that's the likeliest place you're going to find SIMD.
This looks great thank you. I already used your simple hash free structure in a fluid simulator toy project if mine. Was nice and simple to learn and use.
Thanks for the clarification, it works kinda like I expected, should've just read about it more in-depth a while ago when I was creating an OPC UA protocol to MQTT protocol gateway client in C++ as my first Qt program. I have a lot of unnecessary heap allocations in that program, it works fine, doesn't seem to have memory leaks whatsoever because I made really sure of things like that but the code is kinda messy / stupid because of them. So yeah, I should definitely fix my bad habits and instead think a bit more of my decisions, heap pointer wrappers like QScopedPointer seem great.
Rust already expresses most (or all) of the STL2, or what I am missing?
A few answers: * There is very little in the way of lockfree algorithms in UE4, because for the most part it's coarse-threaded not fine-threaded. I don't think TBB is used for its threaded algorithms, only its multithreaded allocator. * Templates are primarily used by the containers. If you want to see something horrifying, look at the old non-variadic-template implementation of UE4's delegates based around #include/macro stamping, it's awesome (and mostly deprecated). * The primary build time optimisation is from Unity builds (somewhat of an unfortunate name) where multiple cpp files are automatically #included into larger units, which dramatically cuts compilation times on large projects. Incredibuild is also supported in UE4's build tool, which allows a build to be network-distributed and reduces the build time to only ~5 minutes for a full rebuild! * No inline assembly, little in the way of SIMD ops (mostly in a few bits of math-heavy code, e.g. the FTransform and FMatrix classes). * UE4 has its own graphics abstraction layer which sits on top of the different APIs, but that does mean that it treats them all largely the same and uses little in the way of API-specific features.
I think the Rust community is very aware of all the limits of its language (no HKTs, no variadics, no abstract return types, worst constexpr than C++, no inheritance, no specialization, no overloading, verbosity, slow compile times, lack of dependent types, no type level integers ...). While some people think that "no overloading" is a good thing, I have yet to see anybody arguing that any of the other points above is a good thing. They know Rust lack these features, and for each of those features above an issue is filled, one or more RFCs have been proposed, and most of them have already been implemented at one point or another. The root of the problem is that the harder or more powerful a feature is, and the less experience one has with it from other languages, the harder it is to know that including that feature into the language "is the right thing to do", so consensus becomes very hard to achieve. The Rust community is very conservative with new features, it is more proud of the features that Rust doesn't have than of the features that Rust does actually have. Example 1: probably the next new Rust language feature is going to be specialization for generics, and a big part of the discussion revolves around whether the proposed features is sound in the PL sense. I have not seen language soundness addressed on any ISO C++ paper, ever. IMO the standards seem to be a bit higher for Rust than for C++ when it comes to new features. Example 2: consider type-safe variadic arguments. Everybody thinks Rust needs to support one form or another of these. However, AFAIK C++ is the only language that has a pragmatic implementation of these (Haskell doesn't have them). C++11 variadics are still evolving (e.g. with C++17 fold expressions), and while they are pretty good they are far from perfect (e.g. their interaction with constructors and initializer lists is a bit messy). This makes developing a type-safe variadic feature for Rust more of an open research problem for a PhD thesis than just a "do what language X does" since they already got it right. 
&gt;MoodyCamel's concurrent queue actually uses some of Jeff's primitives. Huh that's neat. I'm quite interested in MoodyCamel's concurrent queue. Didn't really expect to run into anyone talking about it.
Thanks a lot for the answer. Regarding coarse-grained part , I was expecting fine grained heavy , I have been following Jeff Preshing`s blog for a while after his Cppcon 14 talk about multicore, he also has articles about lock contention and lock free programming as well so perhaps I was influenced by that with that expectation. As for the build one , then "Unity" the custom build tool is the reason why I am seeing cs files in directories. I`ll definitely look at as well. 
Thanks four your response Gabriel. I am really willing to see the build times of C++ reduced aggressively. Currently it is, in my opinion, one of the biggest flaws in language's everyday experience.
It's great and you should try it out. 
&gt; you have to use an alternative exception-free library Yes. &gt; pass it to all the standard containers This will not work as safe as it should, because standard containers simple do not support this.
iostreams have quite a few problems. These are often overstated, but honestly "iostreams are shit" is really shorthand for all the problems they have, and doesn't mean they're useless. Honestly, EVERY SINGLE API IN EXISTENCE for I/O is pretty bloody shit. Especially file I/O. Iostreams have sooo many problems: ^(If you reply to any of these points, please reply to them individually so we can have separate comment chains for separate concerns) --- Their interface is a product of its time. We've seen a move in the Standard library from C-style interfaces to an idiomatic Modern C++ style, and iostreams aren't even close to Modern C++. Modern C++ doesn't use names like `seekg` or `tellg`. The operator overloading is very, very obnoxious. It doesn't seem that bad at first until you try to do anything with it, and it's just so awful. e.g. s &lt;&lt; (x + 1) &lt;&lt; '\n'; where you have to wrap internal operations in parentheses because `&lt;&lt;` was never intended to be used as a loosely bound streaming operator, but instead it was intended as a very tightly bound bit-shift operator. Its precedence reflects that. e.g. s &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")"; instead of a theoretical API like: format(s, "({}, {})", x, y); --- Locales. Oh locales. While locales can do some very cool stuff, as soon as you get into any of the nitty-gritty of it, they are just so obviously written by someone that loves abstraction but is designing for abstraction they foresee instead of abstraction they need, which almost never gives satisfactory results. The APIs are just so awful that getting the really cool stuff to work requires an insane amount of effort, which means nobody does that cool stuff! And that's a pity, because that cool stuff is, well... really cool! `codecvt` is a fucking nightmarish hellhole of a thing, btw. --- They're entirely synchronous. Entirely. Synchronous. In. 2016. I hate the 'c'mon people it's 2016, why don't we have flying cars and vote for {whoever I voted for in the last election}' meme as much as anyone, but concurrency is more important than ever and the main API for I/O in the highest performance general-purpose language, C++, doesn't support asynchronous I/O. It's sad. --- I'm not saying that stdio is better. In fact, it's worse. It's way less complicated, but as far as I know it's only barely faster. I'm not trying to say it's the best we could have. I think we should have a good, powerful, modern, asynchronous-by-default input/output library for C++. Thankfully, `std::experimental::net` says this: &gt;Features that are considered outside the scope of this proposal include: &gt;... &gt;* Other forms of asynchronous I/O, such as files. (However, the asynchronous model defined below is capable of supporting these facilities.) And the asynchronous model defined below that is awesome. It uses special 'completion tokens' which allow you to choose which async model you want to use. You can pass `std::use_future` in, which makes the function return a `std::future`. Or you can pass in something that makes it use coroutines, for example. Or something that uses plain callbacks. Or, y'know, something that simply blocks. i.e. you get synchronous versions of everything for free. ---
Not only for embedded systems. Try to use outdated `libstdc++` with Xcode. Of course you using it not because you want but because you need to link to libraries that are build with it.
Thanks for your comment. A couple of comments about leaving out the types. 1. I think a lot of problems go away by having an editor that understands C++. The editor can tell you what the types actually are. Visual Studio already does this, and with clang and the cmake daemon (https://github.com/steveire/cmake/tree/cmake-daemon) we should be able to have plugins that do this for all the editors. 2. I think concepts will be a huge help here. I think the plan is for you to be able to put in a concept where you put auto. This way, we will get the best of both worlds. We will be able to commit to a concept (what we want to do with the type) without worrying about the actual type.
I would have answered with "can we make it something like python?" Why do you think python should be avoided (serious question)
I don't think anyone is denying the implementation quality, it's just that the dependencies are unfortunate. 
Unfortunately, you can't use that with for loops. But of course another macro might make it work: FOR(var, range) for(auto&amp;&amp; _for_var:range) if (bool _for_done = false) {} else for(var = _for_var;!_for_done;_for_done=true) 
Well the /u/berenm comment you answered above was criticizing that it depends on Turf instead of (i guess) depending only on the standard concurrency primitives so I thought you were also commenting on that. At the end of the day if you are doing concurrency you or your standard library are going to need to depend on something anyways, and you cannot ignore what that is (e.g. pthreads) since the only way to do certain things via the standard library is to use the handles to the platform specific APIs... From the number of platforms supported I can only but guess that Turf dependency can be probably removed only at the cost of a lot of `#ifdef`s for the platform specific functionality. /u/preshing can probably answer in more detail of what that would take. I kind of would prefer for the Turf features that aren't in the standard to be proposed for standardization so that Turf won't be necessary in the future.
They use C++, but also C, Go, JavaScript, Ruby, Python, Perl and probably a bunch more depending on where you end up. So yeah, I don't think it'll be a problem
&gt; And their for (x : y) syntax idea was horrid. How is this "*horrid*"?
The C++ community I find is a bit negative in general, even about their own ecosystem. What generally irritates me the most is when criticism is delivered without seriously considering what the alternatives are. C++ is arguably the most flexible language in existence. Of course it will have syntactic warts. The whole point is that if something is ugly, you can just build an abstraction layer (or use another programming language)
It specifies the `noalias` attribute (which is LLVM equivalent) and I seem to recall it might even pass some integer to `noalias` like `noalias(3)` but I may be remembering wrong. I think this ought to help Rust achieves Fortran-like performance on numeric code, but I am not sure whether it does achieve it.
Yep: Google is usually very open minded about languages and platforms, you'll surely find something that suits you.
This is a slightly ugly hack to get the really beautiful behavior of a future language feature.
I personally much prefer it to old for syntax...
Evidently I did. Care to explain?
they love C++98 so much, they forbid you to cheat on her with C++11/14/17 
It's not an issue with Dubai, just the syllabus i'm learning is bullshit.. I'll try to convince my tutor, and thanks a lot for your time and help!
You have to use namespace aliases BECAUSE it is unergonomic. 
That's why we have `auto`. C++ isn't Haskell. 
&gt;I think a lot of problems go away by having an editor that understands C++. The editor can tell you what the types actually are. Visual Studio already does this, and with clang and the cmake daemon (https://github.com/steveire/cmake/tree/cmake-daemon) we should be able to have plugins that do this for all the editors. Visual Studio is Windows only, and I don't use Windows. And I've never used an IDE for C++ that had anywhere near the performance I require. If someone comes up with a great `vim` plugin that uses `clang`, I'd probably quite happily use that. &gt;I think concepts will be a huge help here. I think the plan is for you to be able to put in a concept where you put auto. This way, we will get the best of both worlds. We will be able to commit to a concept (what we want to do with the type) without worrying about the actual type. Yeah Concepts will help but they still won't cover local variables. It will improve this: template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator&gt; void sum_entries(InputIterator1 lbegin, InputIterator1 lend, InputIterator2 rbegin, InputIterator2 rend, OutputIterator obegin, OutputIterator oend) { ... } as: template &lt;InputIterator I1, InputIterator I2, OutputIterator O&gt; void sum_entries(I1 lbegin, I1 lend, I2 rbegin, I2 rend, O obegin, O oend) { ... } which will of course be further improved with ranges. But they don't fix this: auto foo(auto x) { auto bar = baz(x); return [] (auto&amp;&amp; y) { return fam(bar(forward(y))); }; } And as much as people say "oh well don't write that", I don't control what code I read, only what code I write. At the same time, it is much better than writing `std::vector&lt;int&gt;::const_iterator`, so it's ALL worth it.
Well you can say that as much as you like, but from my perspective it's Microsoft that have the track record of being distracted by syntax and ignoring real issues. Both the suggested range-for syntax and `async`/`await` are very clearly "make the syntax work" proposals. They're intended to port a particular syntax to C++, regardless of correctness or what is idiomatic or necessary in C++. It doesn't solve a correctness problem to add `async`/`await`. It's purely a syntax-focused change.
So if I had to use it daily, would it put a stain on my experience working there?
&gt;And because of that, I've suggested an alias provided by the library. In the case of conflicts it can be disabled but otherwise everyone gets a short namespace. If someone wants to enable it, they can type `namespace mem = foonathan::memory;`. And if they want it disabled, they do nothing. That's normal standard C++. Changing it to be there by default but disabled if you do something in CMakeLists.txt (CMake's language is horrible btw), is a weird unnecessary inversion.
Is that actually in the TS, or is it a future thing?
And to write that in C++ we use `auto`. range-for loops like this work: for (auto&amp;&amp; x : y) ... but this doesn't: for (x : y) for the same reason that this works: auto x = foo(); but this doesn't unless x already exists: x = foo();
&gt; Experts recommend carving out 20% of your time to coding skills development. [[citation_needed]] Also: &gt; real-time, high performance, mission critical applications &gt; JavaScript day made
&gt; At the same time, it is much better than writing std::vector&lt;int&gt;::const_iterator I never understood the reluctance to declaring a type instead of repeating all that template stuff. 
You are simply wrong about range-for. I started with the semantics, then decided on syntax.
That's because it's not really anything specific, it's just general utility stuff. &gt; Folly, a collection of reusable C++ library artifacts developed and used at Facebook. &gt; [https://www.facebook.com/notes/facebook-engineering/folly-the-facebook-open-source-library/10150864656793920](https://www.facebook.com/notes/facebook-engineering/folly-the-facebook-open-source-library/10150864656793920)
&gt;But wasn't until C++11. Yes it was. It has always been true. Whenever you declare a variable in C++ in absolutely any context, it is of the form `SOME_TYPE VAR_NAME`. In C++11, this is extended to being able to replace `SOME_TYPE` with `auto`. But the general structure is still THERE. It's still `SOMETHING SOMETHING_ELSE`. &gt;STL makes these exact arguments in his proposal: auto &amp;&amp; is just noise, is confusing for beginners, and the fact that you might use auto or auto &amp; or const auto &amp; and be slightly wrong (either now or in the future when the type-in-question changes) just makes the whole thing even more wild. No it doesn't. It's not wrong to use `auto&amp;`, it's not wrong to use `const auto&amp;`, it's not wrong to use `auto&amp;&amp;` and it's not wrong to use `auto`. They have different semantics and sometimes you want one, and sometimes you want another. `auto&amp;&amp;` isn't confusing to beginners because beginners don't need to write it. Beginners write this: std::vector&lt;int&gt; v = { 1, 2, 3, 4, 5 }; for (int x : v) { std::cout &lt;&lt; x &lt;&lt; std::endl; } And let me tell you, it's not having to write `int` there that is unergonomic. If you want to make C++ easier for beginners, replace iostreams. It's the language's biggest wart by FAR. It's weird and confusing to write `for (x : v)` because where is that `x` being declared? It's not declared anywhere. That's highly confusing. All variables in C++ are declared somewhere, except for one weird little exception? That's really weird.
They're not, because the proposal was rejected. It's highly confusing to have one specific place in the language where variables are automatically declared for you. That's weird. It's not C++. In C++, we declare our variables before using them. 
I currently use apply to give names to tuple elements: std::set&lt;std::tuple&lt;int,std::string,char,double&gt;&gt; myset; std::experimental::apply([](auto iterator,auto success) { if(success) std::experimental::apply([](auto&amp; id,auto&amp; name,auto&amp; grade,auto&amp; gpa) { std::cout &lt;&lt; "Successfully inserted " &lt;&lt; id &lt;&lt; " " &lt;&lt; " " &lt;&lt; name &lt;&lt; " " &lt;&lt; grade &lt;&lt; " " &lt;&lt; gpa &lt;&lt; "\n"; },*iterator); },myset.insert(std::make_tuple(2,"Raja",'B',3.1)));
I agree. If I can't figure out what a project does within a couple of minutes of opening its homepage, odds are I'm going to spend my time doing something else unless I'm actively searching for a library that solves a problem I don't want to solve myself.
&gt; Whenever you declare a variable in C++ in absolutely any context, it is of the form SOME_TYPE VAR_NAME. In C++11, this is extended to being able to replace SOME_TYPE with auto. But the general structure is still THERE. It's still SOMETHING SOMETHING_ELSE. And now it's being extended again so in one place where there's no ambiguity whatsoever you don't have to type a superfluous `SOMETHING`. &gt;Beginners write this: Which behaves just fine until you try to modify the element (or until the element is something expensive to copy, like `std::string`), so then you teach the beginners about references, which works just fine until the elements are immutable, in which case you teach them about constness, which works just fine until the elements are prvalues... `auto &amp;&amp; variable_name` is the only thing you can use in a range-based for loop that's correct by default in every situation. &gt;It's weird and confusing to write for (x : v) because where is that x being declared? It's not declared anywhere. That's highly confusing. How is that highly confusing? You can't do anything **but** declare a variable in that part of the range-based for loop syntax. That's like saying that the syntax for a regular for loop is confusing because there's no explicit syntax that tells you the middle part is a branch.
I forgot to include implementation in my comment, thanks. Regarding perfect hash thats why i said hash for sequential data.
Folly futures looked cool, I was considering using it for a while (it's ability to daisy chain results was enticing), but I ended using the STL's implementation for code portability. I might give it a once over again to see if there's anything else I can use now. FWIW, my friends who work at Facebook rave about it.
That's a hefty gorilla, holding the entire jungle.
If someone wants other people to use their library or code then he needs to at least write a short summary about what it does. The current website is totally useless.
It's open source and we can raise this issue with them directly. I've added an issue, y'all can post there. I believe that they will end up improving the documentation if they see that we want it. https://github.com/facebook/folly/issues/360 
So the question is: if you hate C++, and you had to use C++ on a daily basis, would you enjoy it? Well, if you hate it then probably not, but then I'm not sure why you'd apply for a job doing something you hate.
&gt; Whats the advantage over similar systems like conan.io or hunter? It is written in C++(11)? Seriously, though, I think it's like choosing an scm: some people like git, or bazaar, or mercurial. It all depends on what you value and the best way is to read through the Intro and see if you like the approach. We want to be git, though ;-) &gt; When will you offer more packages? (5 is a bit low) Those 5 are special: they are the build system and package manager themselves. As for "offering" packages, we have a slightly different philosophy: we want people to package and submit their own libraries/tools in the spirit of one, grand C++ package repository. We will (eventually) package all of [our own stuff](http://codesynthesis.com/projects/), that I can promise.
How it differs from biicode ?
May be because it support for Windows and Visual Studio is not that great compared to other systems ?
Does it work on Windows ? Does it work on OS X ?
&gt; Does it work on Windows ? Not yet, but it will. Also see the last example in the Intro (cross-compiling to Windows) &gt; Does it work on OS X ? Yes, like a champ. All you need is Command Line Tools from Xcode. While we've tested this release on various Linux'es, Mac OS, and FreeBSD, it should work on any POSIX platform with a C++11 (with a little bit of C++14) compiler.
It's in the TS.
Why should anyone switch from CMake?
Don't think Alexandrescu wrote it. It's a bunch of stuff that Facebook employees wrote. Alexandrescu is but one such employee.
That's not the reason we use git. We use git because git and cvs/svn are TERRIBLE compared to git.
Thank you!
&gt; I don't really have any interest in coding C++ is almost certainly the wrong language for you. You will never be a good programmer if you have no interest in it. Most video game designers don't start in that position. Honestly being a designer is kind of a privilege you get after proving yourself in the industry doing other tasks. You want to be the guy with the brilliant ideas about a new game and how it should work? Almost everyone wants to be that guy... I run a indie game company and I constantly get asked by friends to help them make their brilliant ideas... Honestly most of the ideas suck and they have no idea how much work is involved, that massive financial risk etc... If you have no interest in code. I would suggest you find another way to get into the industry. Art, level design, business, etc... Find something you are interested in that you can offer a company besides game design. Maybe in the mean time find a game engine that allows for game creation with minimal coding and create as many cool unique games as you can. Everyone thinks they have amazing ideas. You will need to prove that however, before getting a job like that.
&gt; Also, the interaction of complex features like parallel builds, auto-generated sourse code, and automatic header dependency extraction can lead to order-dependent behavior. For example, a C++ preprocessor is sometimes executed on a header file as it is being generated. That's either a severe bug in make, or (much more likely) a bug in a user's Makefile. As long as dependencies are properly expressed, make's DAG should not permit such behavior.
Why should anyone switch *to* CMake? CMake is not all sunshine and rainbows. We're building a huge embedded project with it, "because it's there". The makefile structure it generates is horrible: on an XP PC, it took five minutes to find the single file that needs recompilation which a good makefile would find in seconds. Its internals are sparsely documented, and if it decides that your compiler cannot generate executables, you're pretty much lost. So, there's a lot of room for improvements.
Effective qt is an oxymoron. Stupid library is full of bad surprises and twenty year old design decisions. From the moc to implicitly shared resources that react funny to the presence of multithreading.
It is a completely different workflow compared to CMake, just like git compared to cvs. You can say "git is better than cvs because it is a distributed VCS while cvs is not". But that doesn't get you any further; imagine someone told you this just at the beginning of that era, when nobody knew what DVCS exactly is? So I will make you a deal: spend 10-15 minutes going through the [Intro](https://build2.org/build2-toolchain/doc/build2-toolchain-intro.xhtml) -- you don't even need to install `build2`, complete terminal output is included -- then, if you say it was a complete waste of time and you are no further in understanding what makes `build2` different, I will buy you a beverage of your choice. How's that?
Is this a toolchain, as in compiler + libraries &amp; stuff, or just a build system and package/deps manager?
Progress is made by people who do something new, not by people who do only things everyone else does. Why would a 1990's programmer have tried C++ when everyone else was doing C? :-) I don't advocate build2 in particular (actually I don't know it yet), I just oppose the "use CMake and forget everything else" attitude that seems common these days. I just had enough pain with CMake that, given the opportunity to choose a build system again, I would love to examine alternatives.
&gt; As long as dependencies are properly expressed Yes, that, however, is easier said than done. Here is what happens (you probably know all/most of it): the way to automatically extract header dependencies in GNU `make` is by using the C/C++ compiler's `-M*` option family to generate little makefile fragments (usually with the `.d` extension) that get automatically included into the main `makefile`. Essentially, when `make` sees one or more included makefiles that are out-of-date, it tries to update them all, in parallel, and then re-executes itself (so that the updated versions can be loaded). The clever part in all this (and which actually gets us into trouble) is that those generated `.d` files also include dependency information for themselves. So if, say, we have `foo.cpp` that includes `foo.hpp` that includes `bar.hpp` and `bar.hpp` gets changed, then `foo.d` will get updated. Ok, I think we have setup the stage for our problem. Imagine in the above example that `bar.hpp` is an auto-generated header and we just added `bar.cpp` to our project (so there is no `bar.d` yet) which also includes `bar.hpp`. We also `touch` whatever `bar.hpp` is generated from. Now we run `make -j` and here is what happens: `make` notices that both `foo.d` and `bar.d` are out-of-date so it needs to update them. `foo.d` is out-of-date because the dependency information that it contains leads all the way to auto-generated `bar.hpp`. So `make` starts updating `foo.d` by first re-generating `bar.hpp`. While this is going, it can also update `bar.d` (nothing indicates yet that in order to update it `make` first needs to wait for `bar.hpp` -- remember, there is no `bar.d` yet). So `make` launches the compiler with `-M*` to generate `bar.d`. The compiler starts preprocessing `bar.cpp` which includes `bar.hpp` we are busy generating. So the C++ compiler reads a half-generated `bar.hpp`, find something like `#if/#endif` mismatch (e.g., the include guard) and fails. The funny thing is, if you use `-include` (which is non-fatal if the file is missing and cannot be remade), this will still work: `make` will re-exec itself, and then re-try updating `bar.d` which this time will succeed (and `make` will then re-exec itself, again). This is why we call it an *aberration* -- you still get the correct build, just see some uncomfortable diagnostics in the process. 
Hey guys. One thing in asynch programming is that its not easy to use exceptions, since the execution stack is different every time.. Does exceptions function with coroutines? If so, then coroutines will be a very big deal for me and probably many others. I can see that futures have exception support, but we don't have them in our environment. We may implement suppoer for one or the other (or both).
Programmers used C++ because it allowed them to do things that were harder or less elegant to do in C. You can write a complex number type in C, but you can't overload the operators so that you can just write 'num = 4 - 64i;' and have it automatically turned into a complex number by the compiler. That is just a simple example of why programmers choose C++ over C. Now, back to the question, what is different about *build2*? Is its main feature just that it isn't CMake? If it is that's OK, but if it isn't then what is it better at than CMake or some other buildsystem that's already out there? What progress does it make?
I'm not a huge CMake fan, but when I started my current project I actually spent a fair amount of time looking at alternatives and came to the conclusion that CMake was the best thing out there. Despite its faults, I think that until the lack of modules gets fixed in C++, CMake is likely about as good as it's going to get in the C++ build world.
&gt; From the moc What is your current cross-compiler non-C++11 alternative for reflection ?
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Look, if you need a reason *not* to use `build2`, you will find it. Just two sentences before the list you are quoting, it says that this is alpha-quality/technology preview release and those limitations are temporary. But let's leave it at that. You are happy to use CMake. We are happy not to have you as a user. Everyone's happy.
Can you please compare your build system with http://gittup.org/tup/ ? How does it differ? Why is better/worse? How does build2 works? Can I use tup with bpkg? Can bpkg install packages locally (i.e. in ./third_party)? How to prepare package? How to cross compile?
Why? What's your use case? 
You are incorrectly implementing automatic dependency generation. It should be emitted as a byproduct of actual compilation, not as a separate step. The makefile should not list dependency files as targets.
Thanks. Well if it in the future would create proper and clear Visual Studio and Xcode projects that it would be really great, with relative path of course.
I never said I was happy using CMake, I just haven't found anything better yet. I don't see how most users could find a reason to use build2 simply because of the limitations. It seems to me that the **only** reason to use it is because it isn't CMake, but only if you can work within its limitations. I'll look elsewhere, because I don't see this as going in a useful direction, I'm sure some will love it.
Can you recommend a better UI library?
&gt; I can write a CMake file from scratch but it'll take me like an hour or two. So a Cmake file like this: add_executable(foo foo.cpp) Takes about 2 minutes per keystroke?
I did read it, but I didn't see a compelling reason to drop cmake to use it. Having a package manager would be nice, but there are plenty of package managers for cmake as well. Plus, cmake is quite mature, and there is a lot of tooling already available for it.
&gt; I repeat, declarations require you to write a type or auto before them **literally everywhere in the entire language**. It's a universal rule, and it makes declarations very recognisable. What about lambda captures? [x=y, z=foo(bar)](){}; `x` and `z` have no declared type: there is an implied `auto` there, just as there is (would have been) an implied `auto&amp;&amp;` in declaration of the new for-loop syntax. Yet these are still variable declarations.
&gt; Why should anyone switch to CMake? Because it's the most mature cross-platform build system generator there is, with the most community support and functionality, and continues to improve. Even if you're not cross-platform, it's still generally more useful than straight makefiles for anything but the smallest projects. &gt; on an XP PC, it took five minutes to find the single file I've *never* seen recompilation times even *vaguely* approaching that long. It sounds like you might have bigger problems with the project organization or how the build is configured than just CMake. &gt; if it decides that your compiler cannot generate executables, you're pretty much lost Or you could [setup your toolchain properly for cross-compilation](https://cmake.org/cmake/help/v3.4/manual/cmake-toolchains.7.html) or worst-case [just force it to believe it works](https://cmake.org/cmake/help/v3.4/module/CMakeForceCompiler.html). 
That's interesting. It'll be funny if everyone suddenly starts writing code that looks like Java: void generate(Range r, Callable C) { ... } 
If Qt is so bad as you say then why is it so widely used and why does it seem to get more popular as time goes by?
Your counter-argument here is an example of [argumentum ad populum](https://en.wikipedia.org/wiki/Argumentum_ad_populum) - the popularity of something neither argues for or against the quality of it. 
It wasn't an argument it was a question.
Personally I think lambda captures and confusing and shouldn't exist as they do today. I don't see how "every other instance of this being used is shit" does anything but REINFORCE my point.
The problem I always had was cmake makes it very hard to know what is and isn't needed in a cmake file. The documentation isn't geared towards small projects.
Are you sure that clang is using the same standard library than gcc ? It might try to use libc++ instead of libstdc++, which will cause link errors like that one. In any case, I strongly suggest that you recompile your boost using the compiler your intend to use for your project, with the same flags for the standard (-std=c++11 for example).
I am using libstdc++ from GCC. I've read somwhere that gcc introduced an abi change with the new libstdc++ so I guess that's why it's not working with clang. But it's been months and I used a self compiled clang from source (SVN) to compile sources with no success linking to libstdc++5.3.
Can build2 emit Visual Studio, Xcode, or other IDE projects? I find that to be a super useful feature with CMake -- only one project to maintain, but contributors can use their favorite toolset.
&gt; QtQuick is more like '20 years into the future' design decision. I'm honestly not that impressed. It's cool that they are going for a kind of platform/interface independence that includes web applications and such, but they still force a tighter coupling than they should, only now it's in javascript instead of c++. &gt; Btw, signals make multithreading so easy. It's one of the best interfaces to the message queues. Signals as Qt implements them are horrible. They now allow lambdas for slots, which is a vast improvement, but trying to disconnect a lambda is not trivial. And then there's the simple issue of signals/slots only allowing for explicit connections, not ones based on traits or tags. You can't just say class Account { class AccountChanged : QtSignalTag { const char* identifier = "account::changed"; } account_changed; ... void deposit( int money ) { money_ += money; signal( account_changed ); } }; and elsewhere ... connect( any, Account::AccountChanged, this, printAccount ); or even connect( any, ".*::changed", [](){ cout &lt;&lt; "something's changed!"; } ); That's how signals and slots should work. It shouldn't be the case that either the signalling or receiving object needs to have the pointer to the respective other object, or alternatively some management class having both, this should be entirely implicit and based on tags and traits. The way it's done now forces tight coupling. 
Apparently the definition of `std::ios_base::failure::failure` has changed in C++11, and it is now required to inherit from `std::system_error`. Of course this is an ABI breaking change, and can only work with the new libstdc++ (see [here](https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html)). So you might indeed be mixing the two ABIs or using libc++ (which also implements the new behavior). Check if _GLIBCXX_USE_CXX11_ABI is defined.
Offtopic, about FrostbiteKeyRetrieval, why `auto s_Memory = std::make_shared&lt;void*&gt;(malloc(s_ModuleSize));`? Why not just `std::vector&lt;uint8_t&gt; s_Memory(s_ModuleSize);` or `auto s_Memory = std::make_unique&lt;uint8_t[]&gt;(s_ModuleSize);`
~~There's a [proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0135r0.html) out there to make copy and move elision mandatory, allowing us to do things like `noncopyable foo = init;`.~~ (This proposal doesn't handle RVO.) Currently, all compilers worth their salt elide copies and moves by default. If (N)RVO is allowed, it's likely going to happen. If you're worried about something more particular view the disassembly and/or measure before resorting to other tricks like out parameters. Also make sure you can't change the code a bit to make (N)RVO allowed. For example, using an explicit `return std::move(foo);` is almost always the wrong thing to do for this reason.
huge render distances was my primary goal for two years, and i more or less have it down now.. I started at the bottom, though, so I'm sure you'll be up at no time.. I think the biggest things for me that I learned was: 1. No need for octtree, you can brute-force the terrain faster without the extra lookups, of course theres drawbacks and such for everything, for example I had some some compression-gain by processing my terrain with some shitty RLE algorithm before using LZO2 when saving to disk. I think the gain would be bigger with octtrees. I don't think octtree matters for rendering, although it might. It would only matter if it guaranteed that the step where you connect similar quads would go faster.. I think! 2. I generated the terrain vertices on CPU, so ignore this if you want to do it on the GPU: 2a. Indices don't matter.. instead they just add yet-another-terrain-processing step for no gain. I couldn't see that I lost or gained FPS. In the end, indices might be some minor gain if the world is very homogenous. 2b. Design the voxel pipeline such that you support at least 2 types of vertices: textured and procedural (water, lava, portals).. I designed mine such that I only used one type of vertex, which is a little bit wasteful with RAM, although it probably won't affect performance. 3. SSAO is not a thing. It was so ugly even when I tried the very best versions with maxed out numbers that I just removed it completely again. I just use vertex-colors for faking AO now, where minecraft uses textures. It's almost the same thing although in my case its much faster to do it by vertex at the cost of a single case where it doesn't look good (diagonally connected AO corners). I see alot of voxel worlds with SSAO and I can't say I'm a fan there either. Maybe someone will find a way, who knows? 4. Lens works really well from the start without much processing. Render some circle to a greyscale image where you discard samples that are blocked by your scenes depthmap (eg. the depth value is not equal to 1.0). Maybe a stencil-based shader could be even faster? I'm not sure. After that just blur it and then apply lens stuff. 5. Shadows are definitely doable, and I plan on adding simple shadowmapping. I have no idea how good it would look when you combine top-down voxel-fill lightning with realtime sun-based lighting, but it's probably not so bad that you have to choose one or the other. We're also a little bit dependent on having the voxel-lighting information for quickly doing many light-based algorithms. Therefore the sun-based shadows probably won't be a factor for those purposes. Still, fairly easy to add. 6. Reflections are, I think, doomed to be casual reflected-constant-plane (eg. at 64 on Y-axis). World simulators like this where you have huge scale and modification by players who will push boundaries, trying to get "realtime reflections" is a project in itself. 7. Animated stuff is something that I personally will just have "tacked on", eg. rendered in its own step. It's just too important to render the world with static data in its own step, sorted front to back. 8. Sectors of the world can be split however you want, but I found that simply storing them only in (X,Z) so they are as tall as the world made no difference. Slightly more ram usage, I guess. If I'd split them in two I'd halve my RAM usage on storing blocks, but in the end it complicates something that can be straightforward. 9. When processing these blocks (sectors) for generating terrain you must make full copy of the entire sector, WITH border, and then process that copied part (let's just call it BorderedSector) in a threadpool. It's important to not try to use mutexes to avoid this copy and try to work on this part of the world using locks to avoid concurrency issues. The reason is that it slows the whole thing down to a bog. You absolutely must use a schedule-and-forget scheme so that the rest of the engine has zero waiting. 10. For maximum speed you can use many tricks to make everything appear as its going much faster than it is. For example, by generating terrain outwards from the player, and sorting it (and this is the important part) by whatever is needed to be able to start the terrain generation step. In other words if you need to do 3 things before you can do terrain generation, then sort by criteria and distance, so that you're always keeping things moving. I could probably go on forever. :) Hope you get far! For comparisons only - I'm running with 64 sectors (64*16 blocks) view distance, whereas minecraft is maxing out at something much less. HOWEVER, the number of sectors loaded on the server matters too, so they can't be the same. The client must then have more sectors loaded than the server, as there's bound to be scalability issues if all the clients are running around with massive view distances and the server has to keep all these things loaded and "ticking." EDIT: I should probably add about octtrees and rendering - I just wrote my own faster version where I test bounding box against smaller and smaller boxes (but height is always the Y-value of the topmost non-air block!). It's the same thing, just not with blocks stored in an actual octtree.
I agree 100%, and that is a better way of saying what I was trying to say. I kept talking about typedef because I was being lazy in my comments. 
It finished compiling. I didn't expected much and well it didn't work.
`std::move` isn't usually the same use case as RVO. That trap specifically is when you try to optimize your code to move a named variable out, but you end up forcing a move when it would have been handled by NRVO. The kicker is that the move would have been done by the compiler if it couldn't do NRVO anyway. Now that's not to say that returning by `std::move` is a bad idea 100% of the time (see Effective Modern C++ for an example), but it is nearly all of the time. In general, though, you use `std::move` when you want a move instead of a copy, and you're sure the variable is no longer used. In every other case, that's going to be a context where NRVO doesn't apply, such as moving into a parameter or the common `Foo(Type t) : t_(std::move(t)) {}` to initialize members with only one constructor that doesn't have the problems that one taking a forwarding reference would have. &gt; though I guess std::move() could be called implicitly... `std::move` doesn't do any moving. It's simply a cast to turn a named variable into an unnamed one. Making it an rvalue allows a move to happen because rvalues are never used again. Since it's not actually `std::move` doing the moving, it shouldn't ever need to be called implicitly. The actual moves are built into the compiler and often done behind the scenes where a beginner would assume a copy.
Well, I'm just nitpicking ;) And I was wondering if you would write this different way now. Heap allocating a pointer instead of writing `void* s_Memory = malloc(s_ModuleSize);` did strike me as bit weird. Just wanted to point out that pointer to pointer is redundant in this case AFAIK.
What's an engine? I have no javascript experience. I'm completely new.
An engine is a collection of pre-written code that will allow you to easily set up a simple game. Instead of having to manually write code for every platform and different kind of video driver, that is already done for you and should allow you to create basic things such as a moving rectangle, etc. fairly easily. To put it in an analogy, an engine is basically the nails and glue and screws in a woodworking project. You didn't forge the nails and screws yourself and you didn't make the glue or collect the wood either. That was provided, now its up to you what to do with it.
Probably not here. C++ is overkill for what you're describing. You'd be better off using Javascript, that way you're at least leveraging your existing HTML knowledge.
From the very beginning. Crawl, walk, then run. You've barely learned the basics of crawling, let alone actually doing it. You have a long road ahead, but as long as you've comfortable with your task taking years of learning and effort, you'll make your game. Look into Unreal Engine 4 or Unity, start making tiny little games to get used to the language and the scripting, gaze deeply at the challenge ahead of you, and let it fill you with DETERMINATION.
If that's the scope of your program, sure it'd only take a minute. But if you need 3 or so libraries for your project and are trying to set it up beforehand, the documentation can make things quite complicated. Sure, it's often as simple as a find_package call, but sometimes it isn't that straightforward. And then if you want to make separate CMakeLists files in a project module structure things become even more complicated.
I think I understand, makefiles are easier to write if you know all the flags already. CMake has a bunch of functions that require a fair amount of investigation to make work correctly.
There are cases where elision is permitted but I don't think you can really elide the copy. The permission still has an effect, because the move constructor gets selected, but actually constructing the object in the function return location seems very hard. eg. auto f() { X x, y; /* modify x and y */ if (/* condition depending on x and y */) { return x; // RVO, moves out of x... } else { return y; // RVO, moves out of y... } //... but since you need x and y to exist before you know // which one will be returned, you can't know which one // one to place in the return value slot }
I don't have much to add to what people have already said, but I thought I'd summarize it: * When compiling with optimizations on, every compiler you care about will perform RVO if possible, so you shouldn't worry about the copy. * If you really don't believe point one, remember that `return x` performs a move, not a copy, so instead of returning a pointer, just make sure x's type has a proper move constructor defined, and you'll be running optimally even on nonoptimized builds.
True, and I haven't verified more complex cases like that. It's good to be aware of where the compiler will have a hard time as you get more experience. 
No, and there are no immediate plans to support this (though maybe in the future).
You'll want to learn to program first. HTML is not programming. Once you understand the logic and syntax, you'll have a better understanding of what you need to do to continue. The specific language you first learn isn't really important, just start with one.
&gt; trying to disconnect a lambda is not trivial auto c = std::make_shared&lt;QMetaObject::Connection&gt;(); *c = connect(this, &amp;QObject::s, [c] { disconnect(*c); }); 
For a long time, MSVC did not perform copy elision in Debug mode. I think they changed this with the 2015 release.
Cool, that's good to know, thanks.
I often use wxWidgets which I personally prefer. Give it a try maybe you like it. And maybe not. But it is an alternative.
Nice thanks. The aligned_union was in at sometime but i removed it again because it caused problems with some compiler, though can't remember correctly what the exact problem was. But you are right no reason for not using it, thanks. 
I, for one, don't like your question because functionally, copy/move elision should be irrelevant to the way you write code, if it is not you have a bigger problem. The aspect to worry about is the performance, which one needs to look at from the profiler data anyhow.
Thanks for explaining. &gt;It's a struggle to work with Qt if your code base is designed for modern C++ Thanks for the warning, I might have to work with Qt in the near future.
&gt; That way on average the linear search could benefit from O(n/2) instead of O(n). I get triggered by this.
Well, you can't really elide that now can you since the exact return is undefined at compile time. What you could do is to assume x will be returned and construct it outside. If it gets returned, great, no need to use a move constructor. If on the other hand y gets returned, then yea, you'll need to use the move constructor. So from a 0% chance of eliding a copy/move you moved to a 50% chance (assuming normal distribution of returns) 
Looks like you might be right! That seems a bit counter-intuitive to me, but it appears to be the case.
Of course, for the last one, you could create `begin` and `end` functions to make it compatible with range-for. struct QtListWidgetIterator { /* the usual iterator interface */ }; QtListWidgetIterator begin(QtListWidget&amp; widget) { return QtListWidgetIterator { &amp;widget, 0 }; } QtListWidgetIterator end(QtListWidget&amp; widget) { return QtListWidgetIterator { &amp;widget, widget.count() }; } 
Elision is not allowed there &gt; [Elision is allowed] in a `return` statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (_other than a function or catch-clause parameter_) but it does move &gt; When the criteria for elision of a copy operation are met or would be met _save for the fact that the source object is a function parameter_, [the move constructor is used].
Gtkmm
Yes, you always can setup a facade, I linked to a possible solution.
It's interesting that the extra scope inhibits the NRVO in GCC. Was that your point? Normally, NRVO does happen on GCC. See http://coliru.stacked-crooked.com/a/6bbd54e4a5d366d1
I like these videos and also recommend (though less videos) youtube.com/user/thenewboston His videos got me started into Qt and also made me realized it's not pronounced "cutie" :(
I also used these videos when I first started programming with Qt. One of the things that I really l liked about them was that they were very concise. I could usually squeeze two or three of them into a normal work day; One in the morning, one before or after lunch, and one before I left in the afternoon. Before long I was well versed enough in Qt to start building useful applications. 
Code generators are good. The more, the merrier, to an extent. By definition, they are there to do what is tedious for humans to do. If you're not adept at leveraging code generation in your job, you're missing out big time. If you want to write metaobjects by hand, you're welcome to do so without moc.
That only means that you don't know what you're talking about. Metaobject and metaclass are rather established language-design terms, found in plenty of literature. These are objects that describe the non-meta objects and classes. Some languages support their generation natively. No version of C++ does so.
It's a detail, but any reason why you explicitly state the * after auto? 
What you propose is simple enough to implement, but arguably shouldn't be a default functionality. Recall that to implement it, you must either: 1. thread-safely keep track of all `QObject` instances in your process, at a tremendous overhead, or 2. treat these "signals" as events that are posted to a per-thread dispatcher, at a cost of unconnected signals having nominal overhead and memory pressure. I don't think you quite thought it through.
More overhead than metaobjects and about twelve function calls that at produces for firing a signal? That is default, as are shared strings.
As it turns out [Pluralsight](https://www.pluralsight.com) has three Qt courses: * [Introduction to Qt: A C++ Cross Platform Application Framework](https://www.pluralsight.com/courses/introduction-qt-cplusplus-framework) * [Qt Quick Fundamentals](https://www.pluralsight.com/courses/qt-quick-fundamentals) * [Integrating Qt Quick with C++](https://www.pluralsight.com/courses/integrating-qt-quick-cpp) I was pleasantly surprised to see any Qt content on Pluralsight. I was expecting none :)
Is that how you argue generally? Somebody doesn't like a thing you like, so they must be ignorant? Q_OBJECT injects code that has to be completed by a third-rate tool. The translation unit/object the programmer sees and is cognisant of will not link. The same is true in the opposite fashion for uic, but that at least it's telly optional. 
There are a couple things to think about when betting on (N)RVO. 1. You need to use either RVO or NRVO; not both. Consider: object fun() { object o; if (some_quick_out_test) return object(); // RVO // ... process o return o; // NRVO } You're not likely to see copy elision here. 2. You can't return parameters. Consider: object adjust(object o) { // process o return o; } You won't see copy elision here either. One of the parameter or return may be elided, but neither might be as well. The thing to understand is how function calling conventions work and how (N)RVO does its thing. Parameters are generally put on the stack, with the return being a final parameter. The compiler then accesses that part of the stack frame for the either named, or unnamed variable. Parameters can be copy elided as well in a similar manner. Here's a great article on the topic: https://web.archive.org/web/20140205194657/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value
What Qt does is a pragmatic matter. There's no other way of reasonably achieving it without having [more functionality in the language itself](http://www.computing.surrey.ac.uk/research/dsrg/fog/FogThesis.pdf). They had two choices: 1. Generate separately-compiled code that holds metadata, and inject missing declarations into the classes via a macro, or 2. Write a translator that injects the declarations without the need for any macros. The #2 possibility is, according to your criteria, even worse. What the programmer sees is always an abstraction. You seem to argue that the higher level the abstraction is, the worse it gets. Are you "cognizant" of how exactly the compiler translates your declarations into code? Taking your line of thinking to its conclusion, the programmer should deal with machine code only, preferably after post-processing it with processors microcode so that they'd *really know* what's going on.
if it's a pointer (or any trivial type) I don't think that using or not using auto will change anything in performance such as it would for a map iterator for instance (which will convert if const is forgotten IIRC).
Not to mention those idiots using a web browser to read a web article :)
A possible argument for [tilde notation](http://introcs.cs.princeton.edu/java/41analysis/).
(and yes, I know that it's actually "... when `std::is_enum&lt;Enum&gt;` has a static boolean variable named `value` that's false", but that makes it _worse_...)
&gt;&gt; on an XP PC, it took five minutes to find the single file &gt; I've never seen recompilation times even vaguely approaching that long. It sounds like you might have bigger problems with the project organization or how the build is configured than just CMake. The problem is that CMake generates recursive makefiles. Take that, a build using about 100 CMakeLists files building 50 artifacts, and a slow file system. Recursive makefiles have been considered harmful for ages for this very reason. And CMake sneaking a "cmake.exe" call into every other line, doubling the number of processes started, doesn't make it better. I actually tried to make a generator that generates just a single makefile. This worked up to a point, but I couldn't keep up with adding CMake sparsely documented special cases in the speed my coworkers started using them... This was three years ago; I believe CMake has at least improved at that point. &gt;&gt; if it decides that your compiler cannot generate executables, you're pretty much lost &gt; Or you could setup your toolchain properly for cross-compilation or worst-case just force it to believe it works. Hey, I finally got it to work for most of our compilers (except for the one that needs to be passed an option to generate any output at all). But the amount of hackery was uncomfortable at least.
Yes you are right, but my point was not related to performance, but rather about correct usage of auto on raw pointer const auto make sense, because you can't go wrong with that one (and also it help compiler to make clever choice), but auto* might result into implicit conversion (which you want to avoid) Also it doesn't bring additional value, except stating explicitly that it's a pointer, but I feel like stating explicitly the underlying type is contradictory of the usage of auto
&gt; you probably shouldn't be programming in Qt anyway I don't. Just tried reading an article called "Raw loops vs. STL algorithms" and pointed out why using "auto" can be a bad thing when writing code snippets for articles.
If understanding of how it works in detail is not required, you can use a macro (yes, they are evil, but this is one of the more legit ones): #define REQUIRE(...) typename = std::enable_if_t&lt;(__VA_ARGS__)&gt; After that you can write your requires-clauses like this: template&lt; typename Enum, typename Functor, REQUIRES(std::is_enum_v&lt;Enum&gt;) // C++17 will allow _v &gt; void for_each(... It is not exactly ideal, but relatively close to how concepts will look and most of all easy to use right and relatively hard to use wrong. Regarding concepts: They will provide something similar that is part of the language, but will work much better with regards to corner-cases. A big advantage will also be that you can use them in much more Convinient Ways void inplace_sort(Container&amp; c); // this is a template if Container is a concept 
http://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-12133 &gt;There is one major problem with your reasoning, and it can be nicely summed up in this sentence: &gt;“Zilch. Not a single specific type appears anywhere in this code, and the lack of exact types makes it much more powerful and doesn’t significantly harm its readability.” &gt;The code sample you gave is very non-typical. That is generic, template-based code usually written by library implementers. I write code like that in my open-source project, but never at work. Code I write at work is full of types and except in a few corner cases such as declarations of iterators explicit types do improve reliability and robustness of code. &gt;In short, I think I agree with your advice to use “auto” as much as possible, but only for template libraries. For all other code, “auto” should be used only in very few cases.
This isn't a homework help forum. You may have some luck over at /r/cpp_questions, but they'll expect you to have at least tried something and have some code to work from.
What about [std::array](http://en.cppreference.com/w/cpp/container/array)?
&gt; What Qt does is a pragmatic matter. There's no other way of reasonably achieving it without having more functionality in the language itself. There's also no way to reasonably achieve nuclear fission in standard C++, but Qt doesn't implement *that*. I am and have been claiming that the entire existence of moc is spurious because what Qt's meta object model is used for is primarily and often exclusively signals and slots. This is evidently the reason for moc's existence, because the little reflection it provides doesn't help. I can't implement automatic serialisation with it, for example, at least not trivially. But what is it good for exactly, then? Signals and slots. Which are implemented in a far too literal and tightly coupling fashion and can't do the thing I actually want from them, namely letting me message pass on tags or strings. &gt; What the programmer sees is always an abstraction. You seem to argue that the higher level the abstraction is, the worse it gets No, I'm not arguing that. I'm saying there should not be invisible requirements without which the object produced by compiling a translation unit will not link (or compile in the case of uic). I'm saying there should be no injection of unnecessary code because you want to extend a QWidget. &gt; Are you "cognizant" of how exactly the compiler translates your declarations into code Of course, I'm a programmer. It's my job. I know what the magic is that qt injects also, I just don't like it, and moc isn't the only reason. It's also the design of the entire framework. &gt; Taking your line of thinking to its conclusion, the programmer should deal with machine code only, preferably after post-processing it with processors microcode so that they'd really know what's going on. No, they just shouldn't have to deal with Qt. 
&gt; `void inplace_sort(Container&amp; c); // this is a template if Container is a concept` What happens if one has `class Container` then ?
&gt; I'm saying there should not be invisible requirements without which the object produced by compiling a translation unit will not link (or compile in the case of uic). How are they invisible? Are you arguing that the documentation is insufficient? Are you arguing that the tools let you produce an executable that doesn't work? What satisfies your criterion of "visibility"? I think you're just unreasonable towards Qt. And that comes from a person who doesn't like everything in Qt either. The alternatives are almost universally worse.
I personally do: #define REQUIRE(...) std::enable_if_t&lt;std::conjunction&lt;(__VA_ARGS__)&gt;::value, std::uint_least32_t&gt; = __LINE__ As that permits SFINAE on functions that have the exact same signature, but do different things based on the given traits, as long as they are mutually exclusive. `std:conjunction` is C++17, but easy to implement in C++11 or C++14. I also add a negation form as well, since the above doesn't permit adding the unary not operator. :v
In my opinion that's a very big problem then, that's an immediate no-go for me. I hope you reconsider this position in the future. Edit: Ok, at least you have a good explanation for it and directly mention it under _"Warnings"_ :-)
&gt; How are they invisible? Are you arguing that the documentation is insufficient? Are you arguing that the tools let you produce an executable that doesn't work? What satisfies your criterion of "visibility"? That particular problem (it's really the least of my issues with Qt, but for some reason that's what you focused on) could actually be solved if the translation unit wouldn't compile without the `moc_translation_unit.cpp`-file or ideally if Q_OBJECT injected only inline functions and non-statics. &gt; I think you're just unreasonable towards Qt. I'm not exactly hiding that I dislike Qt, but my main contention isn't moc, but that the paradigms evident in the library are really pre-C++98. It's the tight coupling, the deep inheritance, the naked pointers, the heap-heaviness, the implicitly shared memory, the std-library-reimplementations. 
The problem with this definition of REQUIRE is that it works to simply disable one function, but this will not work if you have two mutually exclusive functions. For this reason I'd prefer #define REQUIRE(con) std::enable_if_t&lt;con, int&gt; = 0 Compare both approaches when you try to do: template &lt;class T, REQUIRE(std::is_integral&lt;T&gt;::value)&gt; void f(T t) {}; template &lt;class T, REQUIRE(!std::is_integral&lt;T&gt;::value)&gt; void f(T t) {}; 
That's a good rule of thumb. The "full" solution is to reason in terms of *overlap*: if two potentially returned variables have overlapping lifetimes, then at least one of them cannot be fully RVO'ed. I am not sure that any compiler does this, though, but even in the case of overlapping lifetimes you could privilege one variable: - privilege the first, and in case the second is returned, destroy the first before moving the second - privilege the second (easier), and in case the first is returned, move it
I wish this wasn't downvoted into oblivion for stating an opinion, the resulting discussion could be valuable. :/
Thanks for pointing this out, didn't know about that new function. I thought about boost::fs, but didn't really explore the full options of boost::filesystem for this case. So I implemented it in this way. If I ever need the functionality, I'll take a look at it. Because, once I was done with the code I realized it had major flaw. Links are not files, and hence I don't need to link in the menu with relative links. The full qualified link is enough. This also means, I have to generate the menu only in the different depths, but not for every directory.
OK, but regardless, you'd be better of by wrapping the code lines into a named function that makes it self-evident what the code is doing. That is the main lesson from "no raw loops": use vocabulary algorithms (from STL or Boost), or invent your own :)
there is no such thing as infinitely deep, without flooding all the way from the top.. and to do that you would have to start from the top anyway. If, say, you have no movement on the X,Z axis then sure, have a 128x128 area of sectors and infinite depth. No problem. Once you go full 3D you lose several important simplifications that I can't see how you can live without, or even try to fake. As stated, the lighting has to be propagated without any errors. You also need to know where the ground level is (which blocks are exposed to atmosphere) so that you can have grass, snow, rain and other weather things. As cool as that idea sounds, there's a reason it's just an idea. Feel free to prove me wrong, of course. Perhaps some theorem could be used to prove that some area is exposed to atmosphere given any 3D waveform, but I doubt it. Even then you still have procedural objects, such as trees and villages that also contribute to the overall voxel volume. The cost of the procedural generation is by far the most expensive. It is completely ridicolously unbelievably expensive. That's why you do things such as trilinear interpolation on the terrain density functions. So, while its possible to generate unseen terrain upwards just to get that extra information, it's also unreasonable to expect the clients and the server will do it in any realtime fashion. My project is in hiding atm because im rewriting stuff (and im really bored of the whole thing so im not actually working on it either). At some point i will make it public again. It's an open-source project, of course. 
You can't generally put an argument on top of the return value because you don't get to pick where the argument is placed. The caller will construct the parameters and reserve space for the return value, but elision is done by the callee. The object already exists when the callee gets it. The stack frame looks like caller frame | | |ret val | | | =============|========| callee frame |argument| | |
You're right, but I think you are placing too much emphasis on accuracy/realism. I'd just come up with something that sorta works and roll with it. After all, we're talking about a game where blocks heal the moment you stop attacking them. I wouldn't have a problem just saying something like "if there are 16 vacant chunks above this chunk, it is considered exposed". After all, we have things like satellites in our atmosphere way over our heads, but they don't cast gigantic shadows on us or block precipitation. There is plenty of room for "good enough" here.
As someone else who's working with Qt and modern C++, I'd say my experience has been relatively pleasant, so YMMV. True, the widgets get assigned to parents by raw pointers, but it's not a big deal and ideally, you'd use either Qt designer or Qt quick for building the UI.
Thanks for also sharing your experience.
First, its better to use `std::enable_if` directly instead of a template alias: #define REQUIRE(...) typename = typename std::enable_if&lt;(__VA_ARGS__)&gt;::type You will get better diagnostics from the compiler(this includes clang) with that because it is quite compilicated to trace template parameters and most compilers don't have the infrastucture to do that easily either. Secondly, in C++14 type traits can be used directly: template&lt; typename Enum, typename Functor, REQUIRES(std::is_enum&lt;Enum&gt;()) &gt; void for_each So there is no need for the `_v`. 
Why add the `std::conjunction`? You can use the boolean operators directly: template&lt; typename Enum, typename Functor, REQUIRES(std::is_enum&lt;Enum&gt;() &amp;&amp; !std::is_class&lt;Enum&gt;()) &gt; void for_each No need for metaprogramming.
Because I like doing it my way :v
As far as we are concerned, you don't have to speak german at all. 
Interesting. Have you done any benchmarks to compare luabind and swig?
I tried to fix range-for!
To default to &amp;?
The small difference here is that you'd call the other macro like `REQUIRES(std::enum, std::negation&lt;std::is_class&gt;)`. That is, the macro accepts the classes themselves rather than boolean values. `std::conjunction` also does short-circuiting, meaning that later traits you pass can depend on the first trait being true. This is the main difference between the macro using `std::conjunction` vs. a fold expression. Now I'm not saying one is better than the other. Those are just reasons to consider when creating such a utility.
&gt; LuaBridge LuaBridge is my favourite, even though it is not currently maintained. It supports 5.1, and can support 5.2 by changing [one line in stack.h](https://eliasdaler.wordpress.com/2014/07/18/using-lua-with-cpp-luabridge/).
Hey good work! A few friendly criticisms. You have a habit of not labeling your x-axis. Sometimes it obvious other times it means I need to study the text in detail to get what it is. Additionally object size would likely be a more interesting metric on the x-axis than number of objects for this comparison. Most of the data is fairly linear for number of objects. However I'm betting the performance benefit is highly dependent on object size. i.e. as the size of an object increases the performance difference will approach 0; And as noted in your comments shared_ptr is a poor choice...
The purpose behind short circuiting a boolean expression isn't performance, it's correctness. This is true regardless of whether we're discussing templates or ordinary code.
I use intrusive linked lists all the time. 
Your question is conveniently related to my recent StackOverflow question [here](http://stackoverflow.com/questions/34705962/should-decltype-on-a-template-value-parameter-trigger-a-sfinae-context). Specifically, see the last part of Potatoswatter's answer: template&lt; typename T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; * = nullptr &gt; using Pointer = T; template&lt; typename T &gt; void foo( Pointer&lt;T&gt; ); There is one major disadvantage to this, which is related to what prompted me to ask this question in the first place. Because of the special substitution ordering for template aliases, I don't know how to make this technique prevent implicit conversions like function reference decay. If anyone knows how to prevent these, please tell me! The bulk of his answer is essentially 'A Brief History Of SFINAE As Told By Potatoswatter', which is awesome, and might be a useful reference for your friend (especially if he already understands the implementation of std::enable_if itself). Edit: Does anyone know where this technique was first used? Despite its simplicity, for some reason it strikes me as especially creative. Edit 2: More details
Short-circuiting for `std::conjunction` is not the same type of short-circuiting done for ordinary expressions. `std::conjunction` is just lazily instantiating templates. As for boolean expressions in `enable_if` or `requires`, correctness comes from SFINAE. Furthermore, substitution failure has a well-defined order for substitutions, which already allow for a type of "short-circuiting" Plus, its composable, so that substitution failure in one expression will cause substitution failure in another.
&gt; Short-circuiting for std::conjunction is not the same type of short-circuiting done for ordinary expressions. std::conjunction is just lazily instantiating templates. Which is the same thing as short-circuiting for ordinary expressions.
Thanks. I tried asking this on another website, and all I got was hate for asking a question "easily googlable". I tried for about two hours (I didn't even realize i spent that much time), and just kept finding stuff from like 2005-2011, which wouldn't work with newer versions of c++. Edit: So I need MS Visual Studio Community Edition 2015, even if I am using a different IDE? Which is the best IDE? Is Eclipse okay, because I have already used it with Java. Or should I use no IDE? I have seen people use like notepad++ and compile and run in CMD.
I have no idea what your example has to do with anything that's being said. Short circuiting was never about optimization, it is and has always been about avoiding the evaluation of side-effects if a precondition fails. A compiler can optimize away any unnecessary/non-observable evaluation for the sake of performance regardless of whether `a &amp;&amp; b` short circuits. This same principle applies just as much to short circuiting in templates as it does in ordinary expressions. Short circuiting in `std::conjunction` is not intended for performance as if its presence is intended to speed up compile times (?!?!?), it's intended for correctness to avoid instantiating a template if a precondition fails. I'm not sure how else to express this to you so I think I'll just leave it at that.
&gt; SFINAE is excellent and works extremely well. I would say the reverse - that it's obscure and fragile. Let's put it another way - try to explain it to a bright C programmer in less than 10 minutes... :-)
If you want to learn language, install Visual Studio Community Edition. It is free. Supports almost all new features, easy to install and configure.
I throw an exception to that statement!
Interesting! What are the downsides?
I am using sol for my hobby project and it's really nice, I recommend it. By the way, is there anything similar to sol but for some javascript engine? V8 binding is so much more elaborated than the sol one...
Hi, People from /r/programming suggested I post this here too. 
thanks
It does look like you submitted an https link and for some reason destroy the style. I would recommend: http://jguegant.github.io/blogs/tech/thread-safe-multi-type-map.html
The page you are linking is not about *those* concepts. It's about the concepts that exist purely legally in the standard. The ones we are talking about are [here](http://en.cppreference.com/w/cpp/language/constraints) I am very sure that I saw in the naming-conventions I mentioned in the standardization papers which get's more plausible if you consider that Bjarne said that he really dislikes all forms of camelCase. However: Even if concepts were PascalCase, that would still prove my point.
yeah, i'm sorry. You have to load the unsafe script. Anyway nice piece :)
Thanks a bunch. I've done a bunch of dynamically typed languages and just started with cpp. Qt seems like the go to ui toolkit :)
No problems. I did a temporary fix, but I guess I have to fix pelican framework!
Paging /u/STL ... 
Swapping with the last element is not cache friendly either. It's actually worse than the VS2015 version. Moving on the place of your right neighbor is the answer :), just like insert_n does it. That is, after you reserve the required space. But r-value refs are a bit tricky (i'm by no means experimented with the new c++ features :) ) so there might be things to be be careful about too there i suppose. It is fixable nonetheless, because real-life problems like CPU cache are more important :). Also, it uses just one rotate and rotate calls reverse three times(only 2 calls actually do something for the parameters they get called with). I suppose it was just a case of reusing things.
I've never had trouble explaining it. Maybe you're not very good at explaining things?
QJsEngine?
It is tied to Qt library, isn't it? Or there is a stand alone version?
I didn't get the message the talk wants to convey (maybe there is none). It seemed more like a demonstration of two things where Qt has a very unintuitive API and most often doesn't do what the user would expect, and in case of the examples with the strings, a jungle very hard to see through. But the title is weird then - "Effective Qt". For me personally the talk gave me a demonstration of where Qt's API sucks and reasons not to use it.
Honestly? No huge caveats that I know of. The framework is as fast as plain C for get/set operations, but has a bit of overhead regarding the fetching of functions (calling them is still plenty fast): I'm working on fixing that up right now. A feature that I need to add in the next two weekends is Operator Overloading based on Arity (that is, you should be allowed to set a function called `foo` multiple times if they have a different number of arguments. So `foo(1)` calls into a 1-argument function, `foo(1, 2)` calls into a 2-argument C++ function, etc...) (Note: we do this for constructors already, it should be generalized to the rest of the framework). Problem with this feature for me is that up until now the `usertype`s and `userdata` made by sol can be 100% legit replaced by lua code (or C/C++ backend code) without requiring magic. If I add this, this claim becomes a bit harder to make (you CAN implement this kind of selective processing for function calls in lua and C++, but... you know. A tad weird to do so, since lua doesn't natively support that kind of stuff). There's some micro-optimizations to be had from more efficient stack usage where (on modern i7-level 64-bit hardware) we can gain some 100-200+ nanoseconds in access time by taking advantage of grouped queries to "dig" into tables with less push/pops on the lua stack (e.g. `mytable["a"]["b"]["c"]` makes some unnecessary temporary stack references in C++ code). Everything else has been specifically designed to be clean, fast, and easy to use. EDIT: It's important to mention we don't specifically add abstractions for debug data and threads/coroutines. The implementation details of that might (?) be mucky, so we decided to just leave it be for now.
I feel you. I wanted to bind V8 to my C++, took one look at the C++ tutorials and just decided that maybe pybind11 and Python would be a lot more.... interesting!
Why does it matter what the type is? 
 Page* p = node-&gt;get&lt; Page &gt;(); What the hell is this? Using raw pointers? Hope that motherfucker doesn't leak.
Qt Creator can be used without having Qt SDK installed. You can use it with CMake + Ninja / autotools. I have been using Qt Creator with a [Visual C++ and Visual Assist keyboard bindings](http://cristianadam.blogspot.de/2012/08/qt-creator-visual-c-keyboard-shortcuts.html) since 2012. It fulfills my IDE needs nicely. 
No, this is fine. Nothing leaks in this model. Node is a TreeItem, which contains the actual node, which is a boost variant. TreeItem is shared_from_this, providing the treestructure, of which the Types in the variant have no idea it exists. get&lt;Type&gt; returns a pointer to the type in the variant, which is in node in TreeModel. The pointer is not owning anything. You might want to read the blog post on the tree structure where this is based on: http://meetingcpp.com/index.php/br/items/trees-treemodels-and-treeviews-in-qt.html 
codelitte is a great IDE QtCreator and Kdevelop are fantastic
If you're a student, you can [get JetBrains tools for free](https://www.jetbrains.com/student/) (i.e., CLion).
Who is he?
Yep. Would avoid stl vector like the plague. On ms I would either use a mfc class or a 3rd party library. 
Ah, I somehow missed that part and only read the part about purchasing it. 
You might want to check out the lightweight C++ IDE juCi++: https://github.com/cppit/jucipp.
Oh of course. I'm not faulting him, just wanting people to be aware.
NetBeans is a decent ide, but I don't think you will find something as effective as visual studio. 
Ubuntu is somewhat a resource hog. But for speed, you don't need to switch to a bizarre window manager like i3. Have you tried a lightweight ^^normal distribution like [Lubuntu](http://lubuntu.net/) or [Xubuntu](http://xubuntu.org/)?
You can usually get a free copy of Windows education and Visual Studio via your university.
Thankyou, I'm currently trying it. Someone else has also pointed out minimal cmake files to try out with it.
NetBeans is slow on my system :/ I've tried it in windows and it was slow there, idk will it gain any performance gains on linux.
&gt; Now, in the case where someone was insane enough to invent his own naming-conventions that clash, it will likely be a compiler-error. Like, all of Google. Or Mozilla. Or [Juce](http://juce.com). Or Qt. Gosh, the programming world is simply littered with insane programmers, isn't it? Actually, all of the above use a convention very similar to this: * `lower_snake_case` for STL classes, variables, templates and etc. * `lowerCamelCase` for methods, variables and functions. * `UpperCamelCase` for classes, structs and enum types. And that's more or less what I personally use. But I guess I'm just [another insane programmer.](https://www.youtube.com/watch?v=hnzHtm1jhL4)
I've not tried codelite but does it supports debugging and code-completion. Also it seems to be nodejs/php ide :/
They have a issue with arch linux. debugging not working, I'll wait for it because it looks perfect :/ Thanks anyways :)
This has been quite illuminating for me, and I don't think there's any clear best answer on this page: I suppose this shows that it isn't a solved problem. But now I do believe that Concepts are, long-term, the direction that C++ will be going to in order to solve these issues. Thanks for a fascinating discussion!
Try Lubuntu. It's Ubuntu meant to run faster. Doesn't use that Unity bullshit. I think you'll find that the situation in your OP is exactly the opposite. You don't even come close to the tools available for Linux on Windows unless you download the driver development kit and start working with wdb, umdh, etc... Even these tools are sad counterparts to gdb, valgrind, dtrace, et. al. The VS debugger integration is really the only thing going for it and it's actually fairly limited if you go beyond the basic, trace through this and break here, type of debugging.
Perhaps so, but my theory is that it's actually hard. In order to understand it, you need to understand template substitution, deduced types, and overload resolution. That last one is [both detailed and tricky](http://en.cppreference.com/w/cpp/language/overload_resolution). And if you don't understand overload resolution in at least moderate detail, you're going to have a bad time implementing SFINAE-based code. I _believe_ I know everything in that last link. I am not _sure_ I do. I certainly _know_ that there are enough rules there that I can never confident in my ability to fully understand overload resolution in a moderately large or larger codebase. But I'd really be interested to see you try to explain all of this to a bright C programmer in 10 minutes enough to have them be able to do it themselves...
Thanks for the details - I'm sold.
"pointer-to" isn't part of the type per se. If you have a T* the type is still a T. IMHO auto* is good style as (a) it makes it explicit you expect a pointer, and (b) it's an error if you assign a non-pointer by accident. Can you describe how auto* risks an accidental implicit conversion?
Raw pointers are fine for *non owning* pointers (ie. Observers). The reason is because you don't want people thinking something has ownership when it doesn't. Anything that has ownership needs a smart pointer behind it.
MSVC and ICC most certainly do, though the former only when optimizations are enabled.
That is true for all but MSVC.
Okay, thank you. I asked my programming teacher who recommended me learn C++, since I already know everything being taught in the class (java), and he said Visual Studio too. My friend, who also knows C++, told me to get C++ profession/enterprise (I forget which), and since I am a student, I will get it for free. He said that is what he did, but I doubt it will work, because I'm pretty sure "students" refer to college students, not high school.
I know this is not what you want to hear, but IDE's in my opinion are a great tool for people that already know how the compile and build system work. For a student, it is my opinion that you will wind up in a much better place in you career if you just continue to use vim, make or cmake, and gdb. Once you are comfortable with these tools (and this will take several years) you will be able to take advantage of the productivity gains that you get from an IDE. There are hard problems that happen in building and debugging software and IDE's generally only help you with the easy ones. If you never get comfortable solving the easy problems you will not have the tools needed to solve the hard ones when they appear.
The compiler and library teams have been working really hard on conformance, both in terms of missing features and bugs. Take another look, I think you'll be pleasantly surprised with the progress we've made.
&gt; But a short name like REQUIRE which might easily collide If you write it as part of a library, you will of course have to prefix it, I just skipped that, like I skip namespaces when I write this kind of samples. If you are an application-programmer, you can use it, because libraries use prefixed names (and if they don't, it's a reason to not use them, for they will be to dangerous). Otherwise I agree with you, we should try to use less macros. But considering some of the other suggestions, something like that might also work well enough (untested): template&lt;bool B&gt; using require = typename std::enable_if&lt;B, int&gt;::type; template&lt; typename Enum, typename Functor, require&lt; conditions &gt; = 1 &gt; void whatever(...){...}
I think the problem here is a missunderstanding of what the term SFINAE refers to. SFINAE itself really is very easy and the name really does say it all: Substitution failure is not an error It means that when you try to instantiate a template and there would be an error somewhere in the signature, that the template will simply not be considered when picking an overload, but it will not itself produce a compiler-error itself. (I hopw you can follow.) That really is everything that SFINAE really means. The hard part is combining SFINAE with type-inference and the creation of a suitable overload-set.
That's interesting, thank you.
A reasonable response. :-] However, I feel it's worth pointing out that I was _only_ responding to this statement: &gt; Personally I'm not a fan of the vector of uint_8's it just doesn't sit well with me. In any case, I agree that it's rarely worth the effort to "fix" working code.
Looks nice, I think I'll give it a try. Maybe you should mention the changes undergoing in the readme, it currently says compatibility with Lua 5.2 only, VS support "possible" etc.
Bizzare?! I think I should feel insulted! ;) But quite seriously, tiling window managers have many advantages for developers. And once you learn how to move around they feel more natural than constant mouse clicking in floating WMs. I think i3 is great choice but maybe that's because what I use.
That is true. Getting tired of all these 'Visual Studio operators'. The debugging techniques is a wider topic: at least unit tests, valgrind, strace, gdb, nm, tcpdump/wireshark, netcat/socat, bash/python prototyping/data-transformation/output-comparison or bug search the commit history.
Very cool ! Still early in its development but I'll definitely keep an eye on it.
vim, or even better emacs, are fine editors which can be extended to do most of what VS does but more efficiently, reliably and transparently. I did Studio for 10 years and I hate the POS with a passion. It is terrible for C++. Where there is certainly a lack in Linux is in the default debugger. gdb is very powerful but the default user experience is horrific. cgdb addresses that problem fairly decently though, if you take the time to configure it.
Keep up the good work. It really is true. It is far easier to write portable C++ code and build it on Windows than it was two or even three years ago.
&gt; every compiler you care about will perform RVO if possible Unfortunately not true if you work in the embedded world. :(
https://www.reddit.com/r/cpp/comments/445939/raw_loops_vs_stl_algorithms/ 
https://www.reddit.com/r/cpp/comments/43u77e/emulating_c17_structured_bindings_in_c14_makes/
That's really clever. Thanks for sharing that. Are there any cases where this isn't equivalent to regular SFINAE? The one disadvantage is that it makes it slightly harder to read at the call site (is Pointer a real templated type or SFINAE magic).
That's shit programming. Don't write shit programs and paper over the shittiness with an IDE. Write good programs.
Uh, no. NetBeans is slow on any system when you're used to good software like vim. 
They might not be beginner-friendly, but I guarantee in time you will realise how rigid development on Windows is.
ah, the ones I pointed out are absolutely not minimal. Here is a minimal example : https://github.com/eugenkiss/7guis/tree/master/Qt5/OnlyCPP/counter
If you wanna use a wrapper without much framework and be able to change the behavior you could have a look at: nlua -- namespace lua nlua is a binding between C++ and Lua. The main idea is to have a C++ API which follows the 'table' approach: the C++ code should look a little bit like Lua code. Another goal is to have an easy to understand and maintain code base. Using templates couldn't be avoided but not much meta-programming is used. In the test directory are examples how the example binding of the book "Programming in Lua" could be transformed into nlua code. https://github.com/syntheticpp/nlua 
Cache misses doesn't matter?
From http://codelite.org/ &gt;A Free, open source, cross platform **C,C++**,PHP **and** Node.js IDE emphasis mine.
wew lad
&gt; You don't need to know how it works underneath to use it or to understand code that uses it. You _do_ need to understand how it works underneath to use it beyond a cut'n'paste baby level. &gt; That's the point of an abstraction. SFINAE is not "an abstraction" in any sense of the word. It's literally "a property of overload resolution in C++ compilers". Even as a technique, nothing is abstracted away. There's nothing abstract about `typename std::enable_if_t&lt;std::is_enum&lt;Enum&gt;::value, int&gt; = 0&gt;` - this is full of detail, and unimportant detail to boot - for example, what are `int` and `0` doing there? The truth is that they could be almost any type and value, because they're ignored and don't result in any generated code, even though "it wouldn't work without them" - a truth which isn't very satisfying to someone seeing this for the first time. The fact that there are three ways to do this, one as a function parameter, one as a template parameter, and one as a return type - and that there are non-obvious advantages between these techniques - this also shows the lack of abstraction, and the necessity to dive into specifics. If it were "abstract" it might look _like_ `if&lt;std::is_enum&lt;Enum&gt;&gt;` (I'm not proposing this of course, can't break `if`, but showing you what abstraction would look like...)
I'm not sure. Better ask 3 billion Java programmers ;-)
Only for historical reasons. Largely from conventions established in a less connected time when each company had their own adhoc rules. To start a new C++ code base today and not use C++ naming conventions would be odd indeed. Of course C++ is odd in that people don't use the standard library conventions like all other languages do. At least the community is slowly converging on the "Modern C++ convention" of * `snake_case` for variables and functions * `PascalCase` for types
&gt;You do need to understand how it works underneath to use it beyond a cut'n'paste baby level. No, you don't. &gt;Even as a technique, nothing is abstracted away. There's nothing abstract about typename std::enable_if_t&lt;std::is_enum&lt;Enum&gt;::value, int&gt; = 0&gt; - this is full of detail, and unimportant detail to boot - for example, what are int and 0 doing there? The `int` is only there because `enable_if` can be used in the return type of a function, and you still need somewhere to put the return type. It's actually really important, you can't just use anything, or your function will have the wrong return type. That example actually looks like it comes from the last argument to a template parameter list, where you could take away the `int` - it's an optional argument - and it would work fine. In fact, you only need the int there when it's absolutely necessary and important and absolutely does result in generated code. &gt;SFINAE is not "an abstraction" in any sense of the word. It's literally "a property of overload resolution in C++ compilers". So? I didn't say SFINAE was an abstraction, but the way people use SFINAE doesn't require you to know how it works. You put `typename = std::enable_if_t&lt;SOME BOOLEAN HERE&gt;`. It's really quite easy to use. That's why it's beloved.
Looks like a race condition to me. Might need a condition variable and a ready-to-read flag to ensure that it doesn't happen Edit: Also a condition variable would avoid the spin lock if that is not desirable
&gt; That example actually looks like it comes from the last argument to a template parameter list, where you could take away the `int` - it's an optional argument - and it would work fine. Not when you need to default the argument – `, int&gt; = 0` is shorter than `&gt;* = nullptr` and arguably clearer.
Rust is certainly faster than Java ( when both are written idiomatically ). Rust uses a lot of the original llvm optimizations ( as clang itself ). Compile-times are slow ( on par with C++), but performance is comparable.
No, thanks. "Run this custom incomprehensible tool to automatically fail" is not easy to use.
I can probably discuss only the Qt of what libraries you've mentioned. There is nothing to add to the CMake configuration. Add another step of downloading Qt? Complex projects really need a custom build system. I've encountered some of these: one of them can't even build outside of the home directory.
Have you tired CMake's ExternalProject_Add? And that's just the basics, there are plenty of CMake scripts out there that allow you to use CMake do download your project's dependencies.
CMake is increasingly becomming the de-facto standard and if you want to encourage programmers to participate, ues it. If you clearly document your dependencies (and don't use anything to exotic), installing them on a free OS should be trivial (`sudo aptitude install foo bar baz` or something similar). Windows might be harder, but I assume that Programmers on Windows are used to the pain to begin with, so it may not be to bad there as well. That being said: The fewer dependencies you have, the better (and not just because of the development-process). Dependency-Hell is something that should be left to web-developers. ;-)
&gt; for printf! to die and be replaced by variadic printf in Rust Note that variadics are insufficient to replace the functionality of the `print!` macros. In particular, you'll get a *compile time* error if any of the given arguments don't match the type expected by the formatting specifier, which is embedded in a string. Moving this functionality (which is very desirable and something I personally love) to the type system is non-trivial. There have been [papers published on it](http://www.is.ocha.ac.jp/~asai/papers/tr08-2.pdf).
An up-and-coming "competitor", for lack of a better word, to [biicode](http://www.biicode.com/) is [conan.io](http://conan.io). Both integrate with CMake seamlessly, but while biicode is [basically](http://blog.biicode.com/) [dead](http://forum.biicode.com/), conan is pretty fresh, if lacking in some packages. It is, however, relatively [simple](http://docs.conan.io/en/latest/packaging.html) to create your own packages.
Are you advocating finding bigger, more comprehensive libraries, or writing more custom code? I generally see having more work done by third party libraries as a good thing.
Another option I have seen for managing the externals is to have a second repository that contains them. This isn't usually needed for Linux (unless you need newer versions than are in the repos) but makes downloading everything easier for the windows devs. As for build systems: cmake is pretty standard, but if you want something simpler you could go with qmake.
I would go with CMake only because it's one of the most widely used, especially for open source projects.
why is this allowed? is there a lint for disallowing shadowing a variable within the same scope?
While this is not true in general, lots of Rust developers are not familiar with C++, something that I find surprising. For some reason those not familiar with C++ still compare every now and then Rust to C++/C/C-with-classes and their lack of modern C++ knowledge shows up, which ends up sounding more like C++ hate. In the same way most C++ devs think that Rust is a C++ with uglier syntax and stronger static analysis which couldn't be more wrong. Never attribute to malice that which is adequately explained by _ignorance_.
According to: http://en.cppreference.com/w/cpp/compiler_support they aren't that far behind on C++1y
Well Rust allows a couple of compiler optimizations that in C++ are impossible (variants with the size of the largest type) or require compiler intrinsics (e.g. aliasing's `__restrict`), so if Rust code doesn't match or outperform C++ I would consider that a bug in Rust's compiler. It also has some "more versatile" abstractions like fat pointers for run-time polymorphism (it's getting also thin pointers soon) which are faster for some uses cases than C++'s thin pointers. OTOH error handling in Rust is more like C's error handling so it might be slower than C++ due to this in some cases. Using "exceptions" in Rust (panics) is well, not idiomatic at all, but those should have the same performance as C++ exceptions. 
rip biicode :(
Could someone ELI5 what Concepts are?
&lt;http://accu.org/index.php/journals/2160&gt;: &gt; Concepts are an extension to the C++ Programming Language, defined as an ISO Technical Specification [TS]. The Concepts extension allows the specification of constraints on template arguments in a straightforward, and often minimal way. While templates can be restricted using SFINAE tricks with `enable_if`, Concepts provide a more readable notation and vastly improved support for overloading. &lt;http://accu.org/index.php/journals/2157&gt;: &gt; The Concepts TS includes a number of improvements to better support generic programming by: &gt; - allowing the explicit specification of constraints on template arguments as a part of a template’s declaration, - supporting the ability to overload function templates and partially specialize class and variable templates based on those constraints, - providing a syntax for defining concepts and the requirements they impose on template arguments, - unifying auto and concepts to provide uniform and accessible notation for programming generically, - dramatically improving the quality of error messages resulting from the misuse of templates, and - doing all of this without imposing any runtime overhead or significant increases in compile times, and also - without restricting what can be expressed using templates. 
Seconded. Concise, well structured, does not go too much into details that you can easily find elsewhere. Just a full overview of the whole language and how to use it best.
You can use the modulus operator to determine if a number is even or odd.
Yes, I can use modulus to check if the number itself is even or odd, but I need to check if the first digit is even or odd, f.e. how do I check if number 4015 first digit (4) is even or odd?
Can't think of anything ATM, will need to ask my teacher tomorrow.
Additionally, to find the first (leftmost, most significant) digit of a number, you can divide by 10 repeatedly until you get something that's less than 10. THAT IS THE SOLUTION!!! Thanks man or ma'am :)
It does not take "several years" to take advantage of the productivity gains you get form an IDE. That's a flat out lie. If it took you that long, then that has nothing to do with the IDE, that has to do with you. There's nothing true about this post. Getting tired of all these '70's-era CLI operators.' (See what I did there). You people are giving advice based on disdain for Microsoft Visual Studio simply because it is the leading IDE on that platform and typically is the bar by which all others are compared (unless they are Java developers - those are typically cross platform and available across all OSes). It isn't ironic that communities around editors like vim and emacs have been for years lifting functionality out of IDEs to implement in their editors... Why, so it can take a developer "several years" to become productive? You do realize that your post gave a glowing endorsement of using the Integrated Development Environment as opposed to a loosely clobbered together collection of unrelated CLI and GUI tools, right? You just tried to justify the lack of user friendliness, the low productivity, and the inferiority vis-à-vis an IDE by somehow idiotically positioning it as some sort of "prerequisite" to using an IDE productively... Which is 100% false. You're basically lying. IDEs are used to develop large software systems all the time. You don't know what you're talking about.
:-&gt; I am this guy: https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful
&gt; Say you need a function that checks whether some string begins with a certain substring: If you already use boost, don't hesitate to use their solution. But if you don't already use it, write it yourself, don't add a new dependency. You will *eventually* need something else that is already in boost. By this course of mind you end up reinventing all their small libs, but with more bugs.
The regression-only policy allows newly discovered bugs in recently introduced features to persist far too long. Because any such bug didn't break anything that worked in the previous release (because the feature wasn't present!), there's no regression. The entire GCC 5 series has been plagued by bugs in C++14 `constexpr`, variable templates and whatnot. This prevents it from compiling cutting-edge libraries such as `range-v3` and Boost.Hana. Clang OTOH, fixes such things in their point releases. This is a much more pleasant experience for users. With GCC, it takes up to a full calendar year to get things fixed.
Yes. It's not 100% out of question that c++17 might come without concepts. In fact only a small amount of the planned new features were already voted to be part of the next standard. The reports of the last meeting of isocpp members stated that they will discuss it in the next meeting (Feb 29) but the final decision may have to wait until June when they plan to finalize the feature list. (Probably) The most recent news on the current state: * https://botondballo.wordpress.com/2015/11/09/trip-report-c-standards-meeting-in-kona-october-2015/ * https://isocpp.org/blog/2015/11/kona-standards-meeting-trip-report * http://herbsutter.com/2015/10/25/2568/ Unfortunately, I can't find the list of features that will definitely be part of c++17 anymore.
This is because Andrew is professor and needs to focus more on his research program in to improve his case for tenure. For some reason, his university does not recognize software maintenance as a form of scholarship. Also, your claim isn't quite true. Andrew *clearly* submitted a patch to a performance issue within the last year, and if you browse all of the comments related to that issue you posted, you'll find it (I can't find it). He is also currently working on performance-related issues in a separate implementation, and I'm sure that he will back port when he's comfortable with it. Adoption of a language feature doesn't correlate with the length of a issue list for its only working implementation. That would be like saying `supply == demand`. Source: I'm Andrew.
Web developers usually solve their "dependency hell" problems with "npm|bower|pip|gem install &lt;library&gt;" and they're ready to go.
What is supposedly incorrect?
I like to think of them as a sort of type-checking for template parameters which I think is similar to putting trait types in generics in Rust. e.g. impl Foo&lt;T: Num + Copy&gt; {} where compilation will fail if T does not implement the Num and Copy traits.
&gt; I dont really see the problem with changing the arity of the template. The biggest limitation is the fact that the function must be templated, so that means you can't add constraints to special member functions such as copy constructors and assignment operators. Well, with Concepts, you can constrain special member functions. With enable_if, you can't. Changing the meta-arity of any template may change the validity/meaning of code that expects to use it with any given meta-arity, so I don't think that's a palatable cost to pay for being able to constrain a function template. &gt;&gt;it's possible to mix and match Concepts and traits &gt;This is not true. Concepts do not work with traits directly. And its just not the fact that you have to use requires bool { ... } with traits that the problem. I don't know what you mean by that, because I can use requires trait&lt;T&gt;::value or requires trait_v&lt;T&gt; directly without any wrapping into bool.
Almost, the concepts that are being proposed for C++ are just syntactic-based instead of semantic-based like in Rust or Haskell. So in C++ they just check that the type fulfill the syntactic requirements with no way to enable(or disable) a type to fulfill the concept, like in Rust or Haskell.
In alot of cases you should use a library that provides what you need. E.g. CSV parsing, because so many people made their own implementation, the CSV format is fairly useless when interoperating with different applications. A CSV implementation is easy and takes less than 300 lines of code, so I can see for this case it's easy to make the wrong decision and reimplement it. I do agree with /u/F-J-W about not using a library for everything. It's hard to come up with a good example of when you shouldn't use a library, for the case of the example provided you should import boost for sure. One good example is Rx-Java. The library itself is good. But not needed in all my projects when the simpler Java Executors/Futures does everything I need elegantly. And I see people using Rx-Java when they really should be using Java Executors. 
It is a judgement call and depends on what you gain vs what you lose. There is no way to generalize it, but everyone should know by now that dependencies have a very real cost associated with them. 
How do you even get started modifying gcc? The source code is very hard to read. Terrible variable names and few comments.
Booger juice.
Well nowadays people tend to only discuss about clang, gcc and msvc++. Back when I started with C++ there where dozens of C++ compilers per OS to chose from, each with its own set of quirks playing catchup with the ongoing standardization efforts.
Why downvoting? Live example: today, Monday, I come to the office and try to make the OpenWebRTC work. It uses cerebro build and package system - a pile of python scripts. I edit the source code of the OpenWebRTC to test a thing. That crap tells me that it won't build because it's up to date. I dig other custom commands: it wipes out my source modifications and builds a package. Thanks.
This is where [hunter](https://github.com/ruslo/hunter) comes into place. If you have a hunterized dependency then the find_package will always work :) Unfortunately the [list](https://github.com/ruslo/hunter/wiki) of such packages is not that long.
Go for CMake. Clion uses it and Microsoft has their [own branch](https://github.com/Microsoft/CMake?files=1). [Hunter](https://github.com/ruslo/hunter) could do the "push this button and everything builds automagically" task one day. * Qt is [supported](https://github.com/ruslo/hunter/wiki/pkg.qt) * protobuf is issue [#97](https://github.com/ruslo/hunter/issues/97) * ZeroMQ is issue [#310](https://github.com/ruslo/hunter/issues/310) 
&gt; with no way to enable(or disable) a type to fulfill the concept, like in Rust or Haskell. Well.. there is a way.. and it sucks (at least on paper). I know you know this, but for completeness, one just has to define an opt-out trait and check for it in the concept definition: template&lt;typename T&gt; struct not_an_it : false_type {}; template &lt;typename T&gt; concept bool Iterator = /* constraints */ and !not_an_it&lt;T&gt;{}; Then if you have something that looks like an iterator but isn't one, you can opt out of modeling the concept by specializing that trait: struct ILookLikeAnIteratorButAintOne; template&lt;&gt; struct not_an_it&lt;ILookLikeAnIteratorButAintOne&gt; : true_type {}; The problem is that this requires whoever is defining the concept to offer you a way to opt out of it. If that person doesn't do that, and you cannot modify the concept to add it yourself, as /u/pfultz2 says you are out of luck. Still, in practice this isn't "that big of an issue". It turns out that real-world concept definitions are pretty specific, e.g., if something really does look like a RandomAccessIterator the chances that it isn't one are zero. AFAIK range-v3 and STL2 have very few concepts that provide an opt-out way because it turned out that in the real world these things don't happen that often at least for the STL.
Whoa, that seemed like a rant you were burning in with and just needed to let out on somebody :D With that said, I would like to point you to the "When learning a new language" part of my statement. Have a nice day, friend
&gt; This response is so factually incorrect that I can only believe it was written to be purposefully misleading. I hope you answer properly later if you get the time to do so since without clarification this doesn't help.
I work on a build system/dependency manager called [Meson](http://mesonbuild.com). Last week I did a presentation at LCA 2016 on dependencies, deployments and building on multiple platforms which is pretty much what you describe. [The video has just been published](http://youtu.be/CTJtKtQ8R5k) and might be of interest to all people here (though we don't support Qt, ZeroMQ or Protobuf yet).
CMake also can create MSVC and XCode project files (`cmake -G "Visual Studio 14"`). Of course, that sometimes requires some compiler specific ifdefs to project. (to configure bundle on XCode, for example)
the two authors have been exchanging such barbs for a while now, I think they need to get together for coffee or something stronger to get past the apparent confusion in terminology.
Lots of `printf`s and patience :) That's been my experience working in any large code base. GCC's internals are pretty actually well documented. There's still a significant learning curve, but you get used to it after a while.
I wish they would have met at cppcon and done that but I've seen similar issues from other people involved in the coroutines discussion and the problem is deeper than that. From the other discussion, to me it is clear that /u/pfultz2 doesn't like parts of the concepts proposal. The proposal is not perfect, there are parts that I like and parts that I don't like (so I can sympathize with him) and I guess everybody would like for it to be better. Still, /u/andrewsutton and many others have put a lot of work into making this. It solves a lot of problems without introducing new ones and we need this now (or 10 years ago). &gt; We need something. This is something. Therefore we must do this. is a fallacy, but the truth is we actually need something now and this is the only baked up thing that we have. We won't have anything significantly better in the foreseeable future. Concept maps and Type checking definitions might come afterwards but something more radical probably won't come, ever. In the analogy with coroutines, we don't really need coroutines _now_, but the same feeling applies. Still I actually like the alternative proposals for both concept and coroutines more than the proposals that got "picked" by the committee as "winners" and from my POV if you don't is because you are either a moron (which none of you are) or because you know something that I don't and we are failing to communicate. Why did the alternative proposals die? This wasn't really communicated by the committee in any form. Both alternative proposals were one man efforts, with the authors having already other papers on their plate. In the case of the resumable expressions proposal the author wasn't even at the meeting when the proposal got discussed. What happened? Didn't they got funding to attend the meeting? Where they in another room at the same time? Finally after a winner gets "picked" (at least for big language features) it seems to get a lot of man power behind it, while the one-man efforts fade silently into oblivion. Of course people are going to argue and be annoying. This situation adds a lot of doubt to the winning proposals [*], and to me it seems like it is just due to a lack of communication. I wish these things could be improved in the future by either communicating better what happened to the alternative proposals, providing funding/travel expenses to the authors, and continuing to encourage/fund the authors to work in the alternative proposals further even if a winner has been picked (e.g. at least for the duration of the TS, if the winner is put into one). [*] hell some comments in the coroutines discussions argue that microsoft owns the committee which is nuts.
The problem with templates performing differently based on optimizations being enabled is trivially solved by having a macro forcing optimizations on on a per function basis, which GCC/Clang/MSVC all support. Always inline is your friend. RTTI not giving the names you want is annoying, but GCC/Clang provide APIs to convert this to the name you do want. Suspect MSVC does as well. You don't have to expose your class guys if you use PIMPL or placement new, and then things work just like C. TL;DR Guy who is annoyed other people think he doesn't know C++ in fact doesn't. Shows you can ship 4 AAA games and still not learn this stuff. Edit: it gets better, then he tries to say with-* macros from lisp are equivalent to RTTI. You can't store those as members. It is strictly not as powerful. You make any resource reference counted in C++ by combining an RAII class with shared pointer. with doesn't let you do that sort of thing. This is the same thing Blow missed when he advocated defer. You can also create dependencies between resources by having them store each other as members.
I wanted to answer, but I accidentally the whole compiler
So you mean an IDE? On Windows, I'd say Visual Studio. Code::Blocks is pretty decent if you want something that works on Linux, and I haven't found an equivalent to XCode on OSX.
&gt; That concepts don't work with traits From 14.10.1 in n4377: &gt; After substitution, E shall have type bool. The constraint is satisfied if and only if E evaluates to true. No conversions are applied to predicate constraints. With an example that clearly demonstrates that type traits cannot be directly used with the `requires` clause. &gt; That you have to write constraints as bool { ... } You do if you want to write the same clauses as you did for `enable_if`. &gt; That partial ordering doesn't work with type traits Well, this can't be true from the previous, since it only accepts expressions of type `bool`. Either way, from 14.10.3, it states: &gt; A constraint P is said to subsume another constraint Q if, informally, it can be determined that P implies Q, up to the equivalence of types and expressions in P and Q. Since it is using `bool` rather than the type, both constraints would be considered equivalent. &gt; That predicates need to be wrapped in bool_constant&lt;&gt; They do. How do you write a function that takes the result of a concept predicate and returns `T` when true or `U` when false? Here's how I write it using type traits: template&lt;class BoolConstant&gt; constexpr std::conditional_t&lt;BoolConstant{}, T, U&gt; pick(BoolConstant) { return {}; } T x = pick(std::is_integral&lt;int&gt;()); U y = pick(std::is_integral&lt;float&gt;()); If its a concept bool, you need to call it like this: T x = pick(bool_constant&lt;(Integer&lt;int&gt;())&gt;()&gt;; U y = pick(bool_constant&lt;(Integer&lt;float&gt;())&gt;()); Being able to write functions like this enables us to do the amazing things that are done in libraries such as Boost.Hana. Plus, it leads to very natural syntax in C++ and avoids the warts such as `typename` and `template` disambiguations. 
**Very** funny question for a "trainer" ;-).
With the information you've given (or lack thereof) I would suggest visual studio 2015. You have to manually tick the c++ module to be installed during setup though.
Why make a mcro when you could wrap it in a class and have value semantics?
at around [39 minute](https://youtu.be/ph7FP0LnmcA?t=39m11s) there is a slide of how to use **differential timing**... can someone show me some basic code with this approach? It was only mentioned for a second, but I think that's an interesting idea.
On Linux, you should definitely try KDevelop. It has its rough edges, but once you get used to the code navigation features, there is no alternative ;)
I have Windows and am downloading VS 2015
VC's `typeid(MEOW).name()` returns demangled names. This is intelligible, although it has downsides of its own.
I'm not sure about the technical reason, I've been fairly active in the rust community and have read a bunch of criticisms of rust, and this is the first time I've seen anyone complain about shadowing. It can be a gotcha in some situations but it almost never comes up. My guess is that it comes from the ML heritage of rust where shadowing is a useful way to simulate mutability where everything is immutable. Personally I've found it useful with Rust's `if let` and `while let` constructs. For instance, let foo: Option&lt;i32&gt; = could_return_i32(); if let Some(foo) = foo { // use foo as an i32 } [Clippy](https://github.com/Manishearth/rust-clippy) which is a community maintained linter has a [shadowed variable lint](https://github.com/Manishearth/rust-clippy/wiki#shadow_reuse), which is default allow but can be configured.
True, but when you need the O(1) runtime properties for specific problems, it's often the best solution. Replacing a doubly linked list with an array can be okay, but the mem copies become a non-negligible overhead. A better compromise would be an unrolled LL. 
Qt Creator's a pretty lightweight IDE and will get you going. You should really keep your beginner questions on /r/learnprogramming though. /r/cpp is for people who already know C++ and look to keep up with new developments, not to help people with their homework. And for the record, a compiler almost never has a GUI, and in programming, there's no such thing as a 'best' anything. All tech has tradeoffs.
The layout of the `world` structure is not really all that great from cache latency perspective. You're likely to wish to access the position and velocity of a given object at the same time: they should be adjacent in memory. The world should be a struct with two members: a vector of `moveable_object` and a vector of `entity`.
That's not his responsibility though.
Probably /u/spongo2 ?
Yes I know I was just hoping as he is quite active and works in a related team he might have a bit of information he can share regarding it is all.
I think this might be better, and avoids macros struct file_closer{ void operator()(FILE* f){fclose(f);} }; using unique_file = std::unique_ptr&lt;FILE,file_closer&gt;; unique_file f{ fopen("filename","r")}; auto c = fgetc(f.get());
Last time I checked, Templight was limited to an older version of Clang. This seems to no longer be the case - how exciting! I will toy around with this soon. Does anyone know whether/how it handles variable templates?
I was to say that D Lang would better choice for fast heavy-metaprograming, but I just saw that you ave some posts about D Lang.
I haven't personally tested it, but I imagine it would. It doesn't really care that much about the uninstantiated functions, it times each separate instantiation separately...and after the instantiation what's the difference between a variable template and a regular one?
Writing CMakeLists.txt. 
Just because you can, doesn't mean you should ( but sometimes it's great fun, if frustrating, to find the boundaries ).
Share what you have already? Also, /r/cpp_questions may be more appropriate.
I've had my fair share of issues with other peoples' CMakeLists.txt that has forced me to fix them.
 I have very little. Its more of a skeleton of it but not meat to it. Im just lost
This is incorrect. The design presented here will likely perform very well if the access pattern is not random; ie: iterating across the arrays in parallel. Especially if you're using velocity to transform position because the velocity cache line will be read only. Random access, on the other hand, will be slower *if you need both components*, but you probably don't most of the time, so it'll be faster there too.
You're still essentially doubling the number of cache lines needed to access any one complete record, and cache experiences memory pressure just like any other level of storage... Even if you sequentially iterate over them, you'll be needing twice as many cache lines full of your data at any given point. Furthermore, prefetch units aren't an unlimited resource.
I'm removing this post because it's off-topic for /r/cpp. If you want help on /r/cpp_questions, you'll need to (1) make an actual effort, (2) post the exact code you've gotten so far (*not* a screenshot, but text that can be copied and pasted so others can compile it), (3) explain in clear terms what you're stuck on ("I'm just lost" doesn't help people help you), and (4) if you're lucky, others will give you advice in English, but you should not expect to receive a fully worked solution. You've got to do your own homework.
Double the cache lines, but the same amount of data. In my experience, doing this is a win, especially if you're only writing to 1/2 of the data. If both items are on the same cache line, you're wasting 1/2 of the write bandwidth by storing back something that hasn't changed. 
This is basically exactly what I do, and it is awesome. Defining an empty struct makes the use of `unique_ptr` very easy (as you don't have to specify `fclose` every time you use it), and it also makes the `unique_ptr` smaller since it does not have to store the function pointer.
Right on mate! If you intend on using Qt for creating a GUI, the Qt5 way of doing that is using QML, as opposed to the old method of using QWidgets. Cheers!
&gt; C is completely different *completely* different?
You want libraries with build tools? It's build tools only :-)
Really, you should create an "HTTP" locale which uses `"\r\n"` as the newline terminator.
Yes, you can use a pretty recent version of Clang, but you have to be careful because the patch is not always up to date. Check the issues on the templight project page to check. I used a trunk 3.8 version. I just changed the example to use variable templates instead of struct templates and it works quite well. There is a difference in the graph though, the memoization nodes are not the same and the right node is evaluation before the left node. Very interesting I believe :)
Can you imagine how /r/Java would react if someone posted a library with `class_names_like_this`. 
Some classes are closely related to stl features and therefore named like them (e.g. nytl::function_traits like std::type_traits). There are also c++14 stl features implemented in nytl if one can only use a c++11 compiler but need e.g. std::integer_sequence. Those classes are therefore also named with the stl naming scheme. Wasn't quite sure about this, do you think i should always use CamelCase even if the classes are related to stl concepts (so use e.g. FunctionTraits instead)?
Read the sidebar: &gt;For C++ questions, answers, help and advice see r/cpp_questions or StackOverflow.
I hope this was example how Not to do such things. Usually one would be use atomic's instate. 
The listing issue is fixed in update 2
I think that being internally consistent is more important than being consistent with external libraries and/or standards. BTW: [real](http://en.cppreference.com/w/cpp/concept) C++ concepts use camel case.
The only note known about next edition is in [book's FAQ](http://www.josuttis.com/tmplbook/faq.html): &gt; **New Edition / C++11 Edition** &gt; **Q**: I am wondering if a 2nd/C++11 edition of your book "C++ Templates" will be coming out any time soon? &gt; **A**: Currently we are starting to organize the work for a C++14 or even C++17 edition (together with Doug Gregor as third author). However, such an edition will probably take until 2016
oops sry didn't mean concepts in this way but yeah you are right. Will fix that during the next days :)
Ivor Horton has a book out called using the C++ standard library. I read only a small part of it so cannot comment on quality but it does use the C++14 standard.
Hi, I'm new to C++ too. OOP is a broad term. Maybe you should search for features one by one: * classes, privacy, friendship, inheritance * semantics of constructors and operator= * static vs dynamic dispatch, virtual tables (vtables) * operator overloading * templates, specialization, template meta programming. * compiler optimizations (how the compiler collapses all these abstractions in order to generate very efficient code): inlining, constant propagation, dead code elimination, devirtualization, vectorization...
Build tools are build tools. Give it libraries of your choice. What will be next? "Hey MS, ship boost and Qt with Build Tools!"
ATL/MBCS is owned and built by Microsoft. Comparing to Qt is disingenuous.
&gt; I know all the syntax for C++ That's a bold claim!
I just tried conan.io and like it a lot! I now have a CMake-based build-system that uses conan to gather the Thirdparty. With just a little more effort I can make it in a way that Conan is optional, so if someone wants to use their own Thirdparty, they can easily do that. It made my life as a developer a lot easier.
Glad I could help :) I saw a guy wearing the T Shirt during a Meeting C++ talk and I _had_ to check it out. Haven't had the chance to actually use it in anything yet but browsing the docs it seemed like something I wanted to use.
I posted via msvs 2015 including my workaround. Didnt get any feedback or a web link to the issue. Which is a shame because posting an update to it isnt possible.
Me too. C++14 metaprogramming is turning out to be different than even C++11 metaprogramming. These two are at the forefront of new style metaprogramming. For some new stuff - take a look at lambda tuples from Joel's talk at Meeting C++ https://www.youtube.com/watch?v=idPThkw2p6c (go to the 52 minute mark)
[This](http://blog.biicode.com/biicode-just-the-company-post-mortem/index.html) blog post from a while ago was just the closing of the _organisation_, now the actual service is closing down. Replacement seems to be [conan.io](https://www.conan.io/) for now. On the plus side, people won't be able to complain about all the biicode posts.
I get your point one problem I have with old languages are pointers, structures and the way data structures are designed I feel more comfortable using data structures using Java and C# Maybe its just me 
If you're using pointers in C++ you're doing it wrong. This is a slight exaggeration, but the point is, you clearly have some misguided ideas about what modern C++ looks like. Really, you should assume more like LINQ and less like C.
You've been trolled. Follow the link that the OP provided and you'll see: &gt;If you want to build your C++ projects targeting Windows desktop without having Visual Studio installed on your computer, Visual C++ Build Tools 2015 provides the requisite C++ compilers, libraries, build scripts, and Windows SDKs. MBCS is a separate download as far as I know. They don't include it with VS anymore.
&gt; Replacement seems to be [...] Or [build2](https://build2.org)/[cppget](https://cppget.org).
The included benchmarks only appear to compare to Microsoft [1], does anyone have a sense for how the performance compares to libc++ and libstdc++? [1] https://github.com/electronicarts/EASTL/blob/master/doc/EASTL%20Benchmarks.html
I'm curious to know what developers at EA generally set for their tab widths in their editors.
Are you saying that each team requires members to set the width of a tab in their editors to a specific width or that each team has a specific convention for indentation (i.e. tabs vs spaces, number of spaces, etc.)?
If you only develop for Windows there is no point in using wx as its quite similar to MFC with way worse tooling and IDE integration. It's licensing is a lot more cut and dry than Qt, though, and parts of it aren't hidden behind a paywall like Qt. 
Shameless plug: my [Pluralsight course](https://www.pluralsight.com/courses/design-patterns-cpp-creational) on C++ Creational Design Patterns. 4 more courses in the pipeline!
How useful and what quality level are these, now that we can see the source code &amp; try it out?
The latter. Each team has their own conventions, but its almost always 4 spaces an indent.
great news for the gaming community!
The repo includes a [clang-format file](https://github.com/electronicarts/EASTL/blob/master/_clang-format), which describes the formatting they use. In particular, they use tabs for indentation (with a width of 4 spaces).
I find fixed_vector, at least, useful in non-game contexts.
&gt; One of the reasons EA has their own is the implementations will be the EXACT same across platforms in memory and handling. (Which the STL takes care of, but at the time it didn't have some features that the EASTL had) iirc. It's hard to optimize code in a cross platform way if your fundamental algorithms have different performance. For example if I optim something for Microsoft consoles (MSVC), it could end up being slower on Sony consoles (clang) due to their library implementations. Using the same libs on MS, Sony, Nintendo, etc. consoles means the profiles will look similar. This allows you profile and optimize on any platform with risk of performance regression. No one wants to get numbers from each platform on every change. Also, with multiple programs using the same libs across all skus, EA can perform low level optimization for all their franchises at the same time. That's good value for money. Even if EASTL is slower than STL and boost it provides a layer of safety where EA are not at the mercy of design/performance changes of other libs. 
Thanks for the suggestion. I've got a dev looking into chaining Clang/C2 into the SKU.
Is this a way to repost a question? r/cpp_questions would be better subreddit for this. Either way, you can transform `T&amp;` into `const T&amp;`, for example like this: using Type = std::remove_reference_t&lt;decltype(arg)&gt;; using ConstType = std::add_const_t&lt;Type&gt;; using ConstTypeReference = std::add_lvalue_reference_t&lt;ConstType&gt;;
If your CTO is dictating tab conventions, you might have a serious problem. 
Great! Looking forward to read it.
What's the difference between that and std::array?
Also, I've been e-mailing some ex-EA people, and seemly Paul Pedriana might end contributing to EASTL again. If this actually happen it would be awesome. Seemly he is planning to use EASTL for his projects at his current job (he works at Oculus now).
A bit offtopic but: &gt;Handheld: Android (ARM, x86 MIPS), **iOS (ARM and x86)**, and their 64-bit variants I thought iOS only ran in ARM devices.
awesome, have been waiting for these vids
I understand what you mean. But you'll find that this subreddit is focused on language design progress and bleeding edge library development. I expect that only a small subset of people on here could make the claim to know *all* the syntax of C++. Most of those would either be involved in the standardization process, or compiler front-end engineers. C++ has an unbelievably complex grammar.
That guy is legendary. He basically wrote EASTL for the most part. He's one of the few engineers I know of who's praised by everyone he's worked with.
[std::array](http://www.cplusplus.com/reference/array/array/) has this implementation now.
This is exactly the point raised by Kate Gregory in this CppCon talk: https://www.youtube.com/watch?v=YnWhqhNdYyk Point being: it's taught wrong.
I can write an entire program without touching pointers once. That's not the type of fundamentals that need to be taught with modern C++. Granted learning that does give you a different appreciation but its definitely not necessary anymore. 
Or you could add: using ConstTypeReferenceOrRReference = std::conditional_t&lt; std::is_rvalue_reference&lt;T&gt;::value, T, ConstTypeReference &gt;;
Yup, that's the general strategy with the type trait I wrapped this into.
You can, but then why are you using c++? I don't agree with the mentality of stunting yourself because it's too hard to learn how to use your tools.
The core library looks to be the same. Difference is in the build system and the addition of the bonus stripped packages. 
There was [an interesting thread](https://www.reddit.com/r/cpp/comments/3zfsz9/the_array_problem/) about this last month.
I knew it existed and found the idea very interesting, never got around to playing with it. And never will unfortunately, I'll replace it with conan.io on my list of things to look at.
I'd emphasize speed python is about 100 fold slower than cpp. If you want to do math/numerical analysis without the weirdness of fortran its also useful.
I don't. True my students spend the first semester on Python and then the majority of them transition to C++ which makes things easier. I have them start off with strings, vectors and stl arrays which have good Python analogues and it's then three weeks before I mention pointers and dynamic allocation. Even then pointers are only introduced so that we can talk about why they are bad and then should be using references and smart pointers instead. A big challenge with this approach is that the old c pointer syntax is much easier and gives much better errors that the smart_pointer syntax. Have you tried to dynamically declare an array using smart pointers from inside a class constructor? Unless you use templates (have to teach students templates) you CAN'T use STL arrays unless you have a compile time size. Shared pointers are out unless you talk about declaring default destructors when you declare the arrays (not going to happen) Unique pointers mean wrapping the new array[] syntax inside a unique pointer declaration also you've got to talk about consts and how consts and initialised in a class constructor (not a good topic for week 4). With "bad" pointers it's just: class Thing { int *array; Thing( int size ) { array = new int[size]; } } With smart pointers it's: class Thing { unique_ptr&lt;int[]&gt; array; Thing( int size ) : array( unique_ptr&lt;int[]&gt;( new int[size] ) {} } (anyone know how to format code for reddit?)
Most of your rant makes no sense: * pointers aren't "bad". They're a tool, it's just a matter of learning when to use it. * "dynamically declare an array" is nonsensical; * `std::array` needs a constant size, but so do arrays; * _Shared pointers are out unless you talk about declaring default destructors_: I don't even know what that means; * _consts and how consts and initialised_: what on earth are you talking about? Your code is full of typos and mistakes. I'm hoping you're not actually a teacher. Your examples should look like this: class Thing { int* array; Thing(std::size_t size) : array(new int[size]) {} }; class Thing2 { std::unique_ptr&lt;int[]&gt; array; Thing2(std::size_t size) : array(new int[size]) {} }; [_edit: yes, this leaks, and yes, these constructors are private, it's the same code as in the parent post but with the proper initialization, with the missing brackets and semicolons, and the proper type for `size`_] As you can see, except for the definition of `array`, the code is identical. As for formatting on reddit, try clicking "formatting help" below the textbox.
If you only mean raw pointers, I can agree with you. The use of raw pointers can be restricted to the authors of low-level libraries, and maintainers of legacy code. If you are saying that pointers, even smart pointers, are not fundamental *for a beginner's programming course*, I would slightly disagree with you. But if you are making the broader statement that smart pointers are "definitely not necessary any more", that is surely wrong. (Other than in the trivial sense of "necessary". Of course, we can write any program in any Turing-complete language, with or without pointers.) To program efficiently and effectively in C++ following object-oriented principles, it is necessary to use heap-allocated storage. For example, if you're going to create a factory method for an abstract class, that factory method will be returning a smart pointer. Smart pointers are a fundamental part of modern C++. Other languages with garbage collection that deal purely with references to heap-allocated objects can hide memory management details from their programmers. But the tradeoff with C++ is that you must manage your own heap-allocated memory. I don' think you can do that effectively without understanding the smart pointer types. 
Goto would be good in an evolution of programming context, starting from assembly jumps and subroutines and progressing to modern control structures and on.
I'm sure the reasons made sense 13 years ago. But you were specifically answering a question as to why to use it today. 
&gt; pointers aren't "bad". They're a tool, it's just a matter of learning when to use it. This entire topic was about how we should be avoiding teaching this low level stuff that can go wrong when starting people off in C++. Yes in this context raw pointers are "bad". &gt; "dynamically declare an array" is nonsensical; Fine! "dynamically allocate an array" &gt; std::array needs a constant size, but so do arrays; But you can declare a pointer for a c array without having to specify the eventual size of that array. Try that with an STL array. &gt; Shared pointers are out unless you talk about declaring default destructors: I don't even know what that means; Want to dynamically allocate an array with a shared pointer? This is the syntax shared_ptr&lt;int&gt; array( new int[10], default_delete&lt;int[]&gt;() ); &gt; consts and how consts and initialised: what on earth are you talking about? consts and how consts are initialised 
I agree that C++ is mostly taught wrong. I also think a high level approach is the best way. First impressions matter, and teaching students how to use C++ inefficiently and wrongly is very bad. The nice thing is that it C++ also allows us to teach the "how" of low-level programming after they understand the "why". What do I mean by this? Many times students are taught how to do low-level programming without knowing where it is applicable. C++ provides us a nice framework where we can show how low-level stuff fit into the high level code. If I designed a course, I would use string, vector, tuple, range-for, unique_ptr, and shared_ptr and show how C++ is just as high-level as pretty much any other language. I would emphasize RAII and how it is the centerpiece for all of C++'s resource management. Then you can teach low-level stuff in the context of implementing standard library features that the students already know how to use. They get to look at under the hood. * RAII and move semantics - implement unique_ptr * Operator overloading - implement complex * Raw arrays and pointers - implement vector * Memory management and intro to atomics - implement shared_ptr and weak_ptr * Unions and pointers and c-style strings - implement string with small string optimization * Bit operations - implement bitset * Memory allocation strategies - implement allocator * Template metaprogramming - implement tuple * Algorithms - implement sort * Multithreading, concurrency, locks, condition variables - implement future and async * Exceptions - discuss the various exception safety guarantees and how to fulfill them when implementing the above features. * Cache friendly structures - have student use/measure std::map and std::unordered_map. Implement map as a sorted array. Implement unordered_map using various hashing strategies - measure performance and discuss tradeoffs. This shows C++ as high level language. Unlike many other high-level languages, in C++ you can show how these high level features are implemented in terms of low-level features such as raw pointers and bit-flipping. Doing this, you will probably teach the student low-level stuff better, because by the time you get to low-level stuff, the student will be familiar with C++, and know why the low-level stuff matters. Because of this you will also be able to go into more details that you could not before. 
&gt;But you can declare a pointer for a c array without having to specify the eventual size of that array. Try that with an STL array. `std::array` is meant to be a drop-in replacement for an array, but you're comparing it to a pointer. I fail to see how this is relevant. &gt;Want to dynamically allocate an array with a shared pointer? No, why would I want to do that? Use a vector. It sounds like you're trying to map features from C to C++ one-to-one. Instead of talking about a `shared_ptr&lt;int&gt;` that actually points to an array, use the appropriate container classes.
Stack + `std::vector` + (rarely) `std::unique_ptr` + (almost never) `std::shared_ptr`. It's trivial, less code and relatively hard to get wrong (as opposed to (owning, naked) pointers, which are almost impossible to get right).
I think some profs feel that glossing over the inner workings of the computer (memory management, etc.) can lead to students developing flawed mental models of various programming concepts. In my case, I never really grokked pointers until I took a computer-organization/arhitecture course; before that, I memorized the rules but didn't really understand why they were needed or what a pointer really *was*. On the other hand, my above anecdote is a bad argument for the teaching style in question, since it means that my own intro to C++ course tried and failed to teach me that "fundamental" adequately.
Yes obviously you would just use a vector or templates in real code, but there are good reasons for not just jumping straight to that when you're doing an introduction to C++. The low level C with classes approach to C++ is still taught in a lot of places because trying to do things in higher level C++ requires that your students learn a whole series of interdependent aspects.
The usual "opensource" from google. Messy, poor documented and probably unusable (unless you have thousands of money to invest in maintaining it.. ~ 3 programmers per 40 lines of code). 1/10.
A lot of MACROS. This is why we need compile-time reflections for C++ !
C++11's minimal allocator interface improved things substantially.
I think the reason is that the goal of C++ classes is to teach low-level fundamentals, and the goal is not to teach you how to program in C++. In my experience, a C++ class came after a couple high level language classes, where the basics of programming were taught.
Thanks a lot.
I’m not seeing the ability to fallback to heap allocation upon overflowing the fixed size in std::array. That’s the really useful bit about fixed_vector.
The ability to fallback on heap allocation when the fixed size is exhausted. If you have a situation where 90% of the time you know the data will fit in a known, small size and it is worth avoiding the cost of heap allocation; but you are willing to take the hit to keep from truncating 10% of the time. Of course, you could implement that logic explicitly, but fixed_vector can make it so much cleaner.
Thanks for pointing that out. I think boost::static_vector is what std::array should have been. But it doesn’t look like it has the ability to fall back on heap allocation when necessary like fixed_vector. Or did I miss that?
Your class Thing leaks memory.
Oh I see, thanks for that. In one mode it's like boost::static_vector, and in the other, like boost::small_vector, which expands if necessary beyond the initial static size.
Thanks for the formatting hints, I hadn't realised that a blank link was needed as well.
What is it for? What it does?
*Accelerated C++*. Major shortcoming: it only covers C++ 98, not newer (but there's currently nothing comparable for newer C++).
I like a lot of these ideas but to fully replicate bitset is a tad advanced due to the [] operator. Implementing allocator would be interesting. I don't think I have had much reason to look into the specifics but I feel as if I should. 
&gt;you still kind of need to know C style arrays so you "get" square bracket notation If this were true, then C would be the first language learned by everyone. How could you understand array notation in Perl without C? The argument is a nonsequiter. If someone came from, say, a Python class, they would have no issue with the square bracket notation where it is used for both lists and dictionaries. &gt;you still kinda sorta need to know what a char array is all about even in this world of strings Interestingly, I was having this argument with someone over on the cpp_questions subreddit. I disagreed with it there, and I disagree with it here. `std::string` is overwhelmingly easier to use (at a cost, of course) than C-style strings and completely obviates any knowledge of how they are implemented. &gt;Also introducing vectors early means introducing template syntax, and oh lord template errors, early, which are also not good for new programmers. There is a partial truth to this. It's really hard to mess up `std::vector&lt;int&gt; v;`, but calling STL functions with the iterators from your container *can* cause problems when certain operators are assumed to be overloaded for your type (not a problem with primitives, of course). I think the more fundamental issue is tying types, containers, iterators, and algorithms all together. It's truly the heart of C++ and is a lot to take in. But it can be done! &gt;the chicken and egg problem There were things laying eggs long before anything resembling a chicken existed. Settled. :D &gt;Our local four year prohibits C++11 syntax entirely, from what my friends have told me. I just died a little.
Arguing that size is overhead is silly when you have to keep track of it anyways. 
After gaining a passing familiarity with the basics of C++ the books I'd recommend to help gain a more in-depth understanding are: _Effective C++_, _Effective STL_, _Exceptional C++_, and _C++ Coding Standards_. These aren't really textbooks with exercises or anything, so you should be reading them while also writing your own programs, to put the content of these books into practice. For algorithms and data structures, I don't know of any textbooks that use what I would call good C++ style, so I think your best bet is just to learn the subjects separately; get a good book on algorithms and data structures and then try to work through it by applying C++ style learned from other sources. A couple books that might not be quite what you're looking for, but which are nonetheless good are _Elements of Programming_ and _From Mathematics to Generic Programming_.
Sorry, I got carried away. Too much coffee. If anything, I find smart pointers *harder* to teach than raw pointers, because they force the acknowledgment of ownership issues that are often not explicitly considered by beginners using raw pointers.
It kind of sounded to me like /u/F-J-W was talking about for personal projects.
&gt;definitely not big projects then things like reddit are made in such languages
This would be a nice addition. What's the impact likely to be on performance? Would the compiler optimize via RVO?
Javaish (Or maybe C#ish?). Pointers (including smart ones) everywhere. Very bad C++ generally. 0/10 I should have given it 1/10. But it's from Google. Code from Google are mostly messy. So -1 for impression penalty.
If you're interested in 2D games, check out http://orx-project.org/, Orx is a desktop/mobile (and HTML5 is also talked about in the community) lightweight game engine with a small but active and friendly community :) Orx is written in C, but it's easy to work with it using C++ (which I do in my game). You can also come chat with us on gitter: https://gitter.im/orx/orx
I have OCD. It's not a cute tendency for organization. It's more like 9 hours of repetitive and obsessive behaviors and rituals. Then shame and guilt.
Using stringstream is likely to be an improvement. Your existing code calls for dozens of `std::string` construction and destruction. Also for dozens of allocations, if the length goes past what fits in the Small String Optimization.
The confusion arises from the annoyingly close name for the "correct" disorder: [Obsessive-compulsive personality disorder](https://en.wikipedia.org/wiki/Obsessive%E2%80%93compulsive_personality_disorder). Everybody just ends up saying "I have OCD!"
I can also use unique or shared ptr there *and* get better overall code out of them there.
I would disagree that knowing C is actually necessary. As a professional C++ programmer for the last 4 years or so I can count the times I have had to touch any C code on one hand. I also don't see how learning C after C++ makes less sense than the other way. Either way the time spent learning C is 90% caring about stuff you will never actually care about in C++.
oh noes! dynamic resizing!
I have had to re-teach so many interns/new hires at my company who were taught with the C first mentality. It generally takes at least a month before they can actually manage to write passable C++.
Are you saying that Qt compiles for more platforms than platforms on which standard lib is available!? 'Cause that is just false. Qt does something else. EASTL also does something else.
Why would looking at the C subset (AKA the stuff that you will proceed to never use again) be a good place to start learning C++? As for looking at char* as a string, are you aware of how much frustration trying to combine two "strings" (That are both variables of type const char*) causes to new C++ programmers that are taught the wrong way?
Even for C++11 it should be shortened to `: array( new int[size] )`. Putting the type in the initialization is redundant at best, and confuses the issues surrounding proper initialization (since what you had is direct-move-initializing instead of just direct-initializing).
Trying to learn C at /any/ point is an exercise in frustration. It is easily the worst programming language in popular usage. Also, while operating systems is still a requirement for some programs it is quickly becoming something optional and something that strong knowledge of is not needed. I will also note that although Linux is written in C, there are popular operating systems written in C++ (Such as the NT kernel)
So this is a "small-string optimisation" then. I guess a name vector\_with_\small\_string\_optimisation was considered too long, but "fixed" is misleading. By the way, if the edge case is to go slightly over the preallocated case, then this has pretty terrible space usage. Compromises are hard :-)
The NT kernel isn't open source though, how are you going to learn from it? If you are going to learn OS, then it's best to learn from the primary open source OS, which is Linux. Learning C isn't particularly frustrating if that's the first language you learn. It's low level, so it's concepts generally match the way computers work. If you going to learn C after learning a high level language (especially one as similar to it as C++), it's going to be hugely frustrating. At least if you learn C++ while knowing C, you can still use some C code to help you if you're stuck. You can't do it if you go from C++ to C. 
I can see the argument, but honestly, looking at the code for CFS is going to be an exercise in frustration if trying to see how schedulers work. (to pick on something I know to be complex) Going over the logic and then implementing a simple one that plugs into a custom os seems way more useful.
No
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Is there such a thing as an introductory course where you (largely) don't implement what already exists?
Would this also support the case that one of the variables you want to assign to has already been declared and the other not?
I found STL's lecture series on STL to be really useful. Hope it turns out the same for you. The series can be found at https://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Standard-Template-Library-STL-
It would be as good as if you implemented without this new feature. In other words, no change in performance.
Agreed – as-is, stringstream would probably be faster. However, fixing the current code to avoid all extraneous constructions/destructions/allocations is trivial: change `path += s + "/";` to `path += s; path += '/';` and `path += p-&gt;getName() + ".html";` to `path += p-&gt;getName(); path += ".html";`. Now there's only a single string (`path`) and this would _certainly_ be faster than stringstream.
OMG. I've been working since 7am this morning (midnight 30 here now) and yesterday was 5am to 10pm. I know I have problem. Hopefully this link provides real answers to life.
Indeed, the proposed wording for [dcl.spec.auto] says that this syntax _introduces_ the identifiers.
Indeed, I've always considered "the Josuttis book" to be the only answer to this question (excepting standard streams, which are better covered by ["the Langer book"](https://www.amazon.com/dp/0321585585/)).
&gt; The NT kernel isn't open source though, how are you going to learn from it? By reading books like "Inside Windows" series, MSDN articles, Microsoft Magazine, attending seminars and trainings. Not everything needs to be free.
`std::array` size must be known at compiletime
We could also discuss if there is a thing that's not already being done and that would just be going away from the point.
Yes, Williams' book is a favorite of mine. That and Williams' posts on SO are 100% of the reason I feel comfortable/confident writing lock-free code without sequential ordering. Joe Duffy's material was seminal for me, but it never 'clicked' with me in quite the same way.
Why not ? 
&gt; operator. Is there an actual proposal for this? Is there a paper I can read on it? I'd be somewhat concerned about adding it.
Maybe you should start writing code: https://www.hackerrank.com/domains
I think this is out of scope of this library. However, you can always use some identifier or something as additional data (as I did with option name and description in command-line example) and then handle localization based on this identifier in your code.
Yeah. I live in Romania and students are allowed to use STL in competitions, but not at tests, exams and other things like this. Thanks for answer
That looks interesting. Thanks
They went away at some point? I honestly hadn't noticed. Could it be that the languages disappeared from the public eye for some time, but stayed strong in actual development cycles?
For b-tree there is Google b-tree http://google-opensource.blogspot.com/2013/01/c-containers-that-save-memory-and-time.html (Note now that code.google is shut down, you have to use the export to github button, or find a clone of that on github https://github.com/jbandela/cpp-btree). Google also has the sparse_hash and dense_hash. You can find a github clone of the code.google repository at https://github.com/sparsehash/sparsehash
Wow. Never heard of boost::xpressive. That is crazy!
I examined this library in detail for private use and opened some issues on it. It's really good stuff. One other thing that I was meaning to open an issue about that I haven't had a chance yet: when converting to and from string, you are basically doing linear search. I realize this probably seemed like a reasonable choice, because for many people a typical enum size is only 4-5. But where I work it's not uncommon to have enums with over 100 values. For converting from enum to string, this is easy to solve: you can replace your macros generating if else, to a switch case. It's really exactly as easy but it will be faster. Unfortunately, from string to enum is much harder. My main thought: generate an array of pairs of string literals + enum. In your initialization logic, sort this list. Then you can do binary search on this array to get from string to enum.
References can be *used* polymorphically, but it is not easy to *create* them polymorphically. If you have a factory method for your abstract type, it's going to need to return a smart pointer to the abstract type.
An example of canonical, but not very useful attribute : the classical "property". For instance : [[property: rate]] class Foo { public: int getRate() const { return m_rate; } void setRate(int v) { if(v != m_rate) m_rate = v; } private: int m_rate; } would add outside of Foo some kind of static introspectability : struct Foo_rate { static const constexpr auto name = "rate"; static const constexpr auto getter = &amp;Foo::getRate; static const constexpr auto setter = &amp;Foo::setRate; static const constexpr auto member = &amp;Foo::m_rate; using property_t = int; } 
http://ideone.com/qFEJdc //=== adapted from the https://github.com/foonathan/string_id hash function ===// #include &lt;cstdint&gt; using hash_t = std::uint64_t; constexpr hash_t fnv_basis = 14695981039346656037ull; constexpr hash_t fnv_prime = 1099511628211ull; // FNV-1a 64 bit hash constexpr hash_t sid_hash(const char *str, hash_t hash = fnv_basis) { return *str ? sid_hash(str + 1, (hash ^ *str) * fnv_prime) : hash; } //=== auto generated macro stuff ===// enum foo { a, b, c }; foo from_string(const char *str) { switch (sid_hash(str)) { case sid_hash("a"): return a; case sid_hash("b"): return b; case sid_hash("c"): return c; } throw "ups"; } //=== example ===// #include &lt;cassert&gt; int main() { auto val = from_string("a"); assert(val == a); } If there is a collision, multiple of the switch-cases will have the same value. This is illegal, so the compiler will complain.
I doubt many people will find that an acceptable approach. Maybe use an unordered_map to handle collisions gracefully.
Are there compilers that support it? If so we could make some library around them.
In C++, you need to model ownership of data, high you largely don't need to do in C# (you only need to avoid leaks and handle disposal of disposable objects. But designing that ownership has been massively simplified in C++11 and 14. You are wrong that it makes C++ a reference counted language, refcounted pointers should in fact rarely be used. Reasons to use C++ didn't change much over time, but techniques did, towards simpler/safer. As for better assembly, you know you are wrong, don't you? unique ptr really is stripped down to a naked pointer by all optimisers, it is trivial nowadays.
[Yup](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4173.pdf), and it has a real possibility of making it into C++17.
Just as the STL contains memory leaks. All I'm trying to say is, raw pointers aren't a mythical, dangerous beast you should never ever use. Like floats, they're just a tool that you have to be a bit careful about.
Sorry, no, I am not wrong. You said *better* code. You will never see better code generated for it. As for all optimizers stripping it down... if you're thinking about clang/gcc/VC, indeed, it will even be in their test suite. But there are a lot of other compilers (or modified versions of the previous ones) that are a lot less mature. Console compilers before launch, GPU compilers, etc... And nothing is a given in optimizing compilers, it's amazing what can trip them up (I work on them). It is never trivial.
If you want something in the standard you have to propose it. Nobody has. Have at it.
I want to have as much `constexpr` as possible and reason for `if`s instead of `switch` was that `switch` didn't work as `constexpr` (I don't remember if it was MSVC 2015?). But I will check if I can do something with it. For `from_string` I have some ideas (really, really crazy macro wizardry), but is it really worth it? I mean, having 100 values isn't so much and linear search should be good enough IMHO...? (Of course, if you parse file with millions of them then I understand.)
Yup totally agree with you on that one! Unfortunately I don't get to ship with exceptions :( So many different kinds of C++ software I suppose :)
The reality is that people are going to learn C++ in school whether you like it or not.
Oh, that's totally not what I'm saying. I love seeing students learn C++, and I think C should be mandatory. I need to hire them for that after all. What I am saying, is that teaching C++ without pointers is in my opinion, a bad idea.
Well, the binary search solution I suggested isn't that bad, mostly because very little of it needs to be done with macros. You just initialize the array with the literal/enum pairs. After that everything is regular coding. I can explain in more detail if you want.
I think there are two possible improvements: 1. take 'text' by value. Taking by const&amp; prevents move assigment. Remove 'textHtml' variable. 2. use flat_set::emplace instead of insert
CLion is great for Windows or OS X.
As noted, that requires the the variables in question be declared previously, and possibly redundant initialization
A bit of background: https://isocpp.org/blog/2016/02/a-bit-of-background-for-the-structures-bindings-proposal
I don't see how that comparison is relevant to the overall discussion. Why bother with an example that doesn't matter in the context of teaching students then? You're saying that unique_ptr is cumbersone to students but raevnos is saying that you don't need to use unique_ptr at all when teaching students, at least in the case you present.
I disagree. Even an old textbook should teach you about auto_ptr, which has been part of the STL since basically forever, and is a (crappy) precursor to current, superior, automatic pointers. But a good textbook even from 2003 should make it clear that in many cases it's possible to get away without using any heap-allocated memory at all.
It is possible to teach more than one thing... `unique_ptr` has its place, and `unique_ptr&lt;T&gt;` for other types is certainly something that would be taught to students. 
That's a good question that I don't know the answer to.
&gt; Yes, a 2003 book is TOO old to be useful &gt; &gt; [but] ... &gt; &gt; Once you are well-versed in Modern C++, you can look at older books and be able to get useful techniques Case in point: [Modern C++ Design](https://www.amazon.com/dp/0201704315/).
&gt; Not learning new features like lambdas, auto, and foreach aren't a huge deal. Disagreed, at least on lambdas: not knowing about lambdas (or libraries to emulate them in C++03, e.g. Boost.Phoenix) makes the standard library algorithms a **lot** less appealing. And the standard library algorithms need to be as appealing as possible, IMO, for someone new to the language, so they don't constantly reinvent the wheel.
I'm not sure if this wording is enough to allow variadic template usage or what would be the exact syntax. What if I'm writing a template function taking a function returning an arbitary tuple? How to I use this syntax to decompose the tuple elements? Or do I have still have to use eyebrow-upping stricks with get&lt;&gt;() calls to iterate through the unknown count of elements of the tuple?
It says std::pair would fall into case 3 (public data), but then says it would prefer case 2 to case 3 when possible. std::pair works with std::get&lt;&gt;, what am I missing here?
I think the only time it would matter would be when the return type of the function being called was a dependent type. It's not really an ambiguity though and the check could be post-poned until instantiation-time. I might be missing your point, do you have an example in mind?
&gt; Delays when opening C++ projects By delays I hope they mean the ridiculous 10-15 minute non-responsiveness and memory leak that freezes my entire system. That would be swell.
It's actually perfect for things like inserting to an already sorted list, especially if you make it work from the back to the front.
[This might have what you're looking for?](https://blogs.msdn.microsoft.com/vcblog/2016/02/11/compiler-improvements-in-vs-2015-update-2/)
Your post has been automatically removed because it appears to be help/homework related. If this has been in error please message the moderators. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Hmm, I can't see any mentions of EBO in the blog post.
I don't blame you; I'm deeply appreciative of all you do! It's just that information about the releases are sometimes spread out on different pages. /u/playmer pointed me to the VC blog entry that does mention improved module support in the CTP.
From concrete experience, I don't think it would have been faster or better done in Clang. It would just have been a different experience. I have been working on GCC since 1997 and I could instantly transfer "tribal" knowledge (every single compiler has some, and I have now worked with the four major C++ compilers) to Andrew for the parts I knew. Jason Merrill offered assistance as backup. As a true gentleman, he honored his words when Andrew was nearing the end of his first pass on the implementation and I was leaving academia. I am grateful for that. I am personally impressed that Andrew could achieve so much in so short term, and GCC made that possible. By the way, Andrew was using C++ since day 1 in the GCC implementation. So, that was not a barrier. 
The age is not the issue. The author is. I kept all my programming books used in school. Except the book by Walter Savitch and anything by Dietel &amp; Deitel. If you want a book to teach you modern C++, get Stroustrup's The C++ Programming Language, like u/SuperV1234 said. It does not have any exercises but it is a vital reference. I also own C++ Primer. It does have exercises and is geared more for a college class on C++. Get them both. If you plan on using C++ for advanced projects, get [The C++ Standard Library: A Tutorial and Reference, 2nd Edition](http://www.amazon.com/Standard-Library-Tutorial-Reference-2nd/dp/0321623215/) by Nicolai M. Josuttis.
All you've done is prove you didn't watch the video.
or [cpm](http://www.cpm.rocks/)
Yes, unfortunately, the reason for that not working is as before: however we are working on the infrastructure needed. It is very high on the stack of things the VC++ team is working on.
Life pro tip: Avoid downvotes by watching things before you criticise them! The talk is done as pure entertainment, and to illustrate some points about refactoring and good coding practice. It's not a serious attempt to depose zlib, and I think towards the end I say pretty much exactly what you commented here. However.. Although zlib gets a high score on the "if it ain't broke" scale, you've got to balance that with its massive score on the "how much better could this be if we re-wrote it" scale. Yes, probably the "ain't broke" score still wins, but it's a close call!
I've found most of those are usually caused by extensions.
&gt; VS 2015 probably has sufficiently good C++11/14 support, but does not yet support UTF-8 source code This been addressed in VC++ 2015 Update 2.
P4VS is always the main culprit for me.
&gt; So you still kind of need to know C style arrays so you "get" square bracket notation C style arrays and strings get you 1["Hello World"]; Since the definition for C style ~~arrays~~ pointer math masquerading as an operator is just that uniquely insane. Try it with a C++ object 1[std::string("Hello World")]; and you get a compile time error. It does not help either that std::map also uses square bracket notation for keys that are completely unrelated to pointer math. 
Isn't something like this enough? SMART_ENUM(some_enum, (a, b, c)) std::map&lt;std::string, some_enum&gt; name_value_map; for(auto e : range&lt;some_enum&gt;()) { name_value_map[to_string(e)] = e; }
Good stuff! I find that so far, variable templates in C++14 don't seem quite ready for prime time. Up until now they weren't in any MSVC version - but they also behave differently in clang and gcc (gcc seems to accept code that probably shouldn't be well-formed). There also doesn't seem to be a way to externally declare them and then define them in a separate compilation unit or .cpp, which dramatically limits their usefulness. I find myself using so-called Meyers singletons in preference every time!
And there is not such thing as O(1/2 n). It is the same (by definition) as O(n).
u/philipcraig, please send me mail with more detail on your scenario and I'll see what we can do. My email is firstname.lastname@microsoft.com. 
&gt; Or did I miss that? See [`boost::small_vector`](http://www.boost.org/doc/libs/master/doc/html/container/non_standard_containers.html#container.non_standard_containers.small_vector)
Go read the [definitive list](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) from the sidebar. In particular, you want to start with A Tour of C++ to make sure you have all of the basics covered (this book can be read in a couple of hours, but studied for a lifetime). Then you want to read Effective Modern C++ to get a deeper understanding of the new features in C++11/14. Of course, no C++ programmer is complete without a copy of The C++ Programming Language (get the 4th edition for the C++11 updates). As for games, a quick search on amazon for "C++ game development" brings up many sources.
If I didn't watch the video, how would I know he was talking about zlib? I know he said it was just an exercise, and I was fine with it at that point. I have no problem with refactoring it as an exercise. But then at the end Jules said he was considering actually putting this code into Juce. That's the part I disagree with.
 Hi, Thank you very much for your feedback. As for my first 'serious' hard-copy of a book I'll probably stick to c++ primer and attempt to go cover to cover. As you mentioned there are 'many sources' of game development books in c++, what I want to know is if you guys have any specific advice on which are actually good. :)
 Hey. Thanks for the advice. I've looked at Amazon and found some decently priced versions of Effective c++ (I assume you were referring to this: (http://www.amazon.co.uk/Effective-Modern-Specific-Ways-Improve/dp/1491903996)? Would you advise me to get that before having finished c++ primer or rather wait with that until a later stage?
API seems a lot better than ICU. ICU drives me nuts.
Big O is just a indicator of the complexity (in time or space ) of your algorithm. It's not enough to decide what is the best one for your need, cache miss is another indicator that I usually use. But you should remember that it's dependent of your computer specs. But the best thing to do is to test, some optimizations are harder to see than SIMD usage or cache hits.
Thanks for doing this. This is really cool. It has been embarrassing for C++ not to have a modern C++ Unicode library for so long. Just a few questions 1) One of the dependencies is PCRE. Any chance, you could get rid of that dependency by using std::regex? In terms of portability, any compiler with sufficient C++11/14 features to compile the library, probably already has support for std::regex (I think GCC started in 4.9) 2) You mentioned that you plan on doing a VC++ port. Any chance you could add a CMake build option for both Windows and Linux at that time. CMake would simplify cross platform building a lot, and you would only have to maintain a single build system.
&gt;As for my first 'serious' hard-copy of a book I'll probably stick to c++ primer and attempt to go cover to cover I've not read that book, but I know it's a top-recommended one for newcomers to the language. As you go through it, I encourage you to carefully read the sections on the standard library and eschew the sections on dynamic memory allocation, pointers, and arrays until after you have a feel for manipulating collections of data (e.g., using a `std::vector`). &gt;what I want to know is if you guys have any specific advice on which are actually good Oh, sorry. I don't work in the games industry, so there may be folks around here or over at /r/programming that are better suited to answer that.
I did watch it - the whole thing! In fact, right up until near the end, I was totally on board. In the introduction, you made it sound like you were just doing this as an exercise for good coding practices, which is great! &gt; It's not a serious attempt to depose zlib, and I think towards the end I say pretty much exactly what you commented here. I got exactly the opposite impression based on what you said towards the end: &gt; Eventually I'd like to pop it into Juce as a replacement for zlib - &gt; When it's definitely all my code, I'll probably put it into Juce This gives me the opposite impression. Sorry if you didn't mean it that way, but, well, you pretty much said that you did. I'd say the "how much better could this be if we re-wrote it" value is actually negative. "Definitely bug-free" is better than "likely bug-free", regardless of how readable the code is. Sure, cleaner code is better in the sense that it makes it easier to find bugs or easier to extend - except do you really expect to do either of these things with zlib? It isn't worth the tradeoff of possibly introducing a bug because your refactor forgot to account for a trailing /0 or an intentional integer overflow, while losing the thousands of people who would look at every single change. (Yeah, Juce is open source and has many people looking at it - but how many are looking into the fine details of the compression code, especially compred to zlib?)
Is there a complete change log for the update, or would that be too big? I'm hoping stat() has finally been fixed in v140_xp, as it's not been working since v120_xp. Comments on the official blog suggest v140_xp might not be working correctly with Update 2, so I think I'll hold off!
Do you ever get the error that it can't find a library that's in the same directory as others? It finds every damn one other than SDL2.lib. Funny thing is that the same setup works on my windows 7 machine but not the windows 8.1 machine.
Me too, that's why I wrote it :)
Because a .cpp including that header can pick up a file near the cpp rather than the intended header. Think of adding a `-I.` to the CPPFLAGS but only for double quotes includes.
IIRC they're dropping XP support for the next version of VS, so you might want to prepare yourself.
What would you suggest for a project with 200gb of source code, assets and binaries that gets about 4-500 updates a day across a hundred people? 
I'm really excited for the File System TS for some reason. Maybe I'm traumatized from recently writing a program with C posix API wrappers
Clang version numbers aren't consistent; different distributions of the compiler use their own numbering. I'm using Apple Clang 7.0.2 from the latest Xcode; I don't know which version number it corresponds to in other releases of Clang. Output of `clang --version`: Apple LLVM version 7.0.2 (clang-700.1.81) Target: x86_64-apple-darwin15.3.0 Thread model: posix
I made a similar reddit at https://www.reddit.com/r/cpp/comments/40lllo/reasons_why_c_sucks_are_these_points_true/. Why and how is it that C++ can take criticism, and not just defend, but admit to its faults, yet still survive? Other communities seem to react quite differently. Also, I don't mind someone attacking a programming language I like. Part of what makes a language robust is that sheer versatility to stand up to stand up to people whose only gripe appears to be rooted in lack of muscle memory. That said, complexity sucks. On a multitude of a levels! Is there such a thing as a tool that scans C++ open source projects to see how many of the c++ features are actually used in the wild?
&gt; I learned C++ when I was in 11th grade, and I kept learning for years. yeah, according to these, I'd say no. &gt; Right now, C++ is less portable than Java or C# &gt; It’s almost impossible to understand how you keep in standard containers objects created by some libraries &gt; you never know if you should create containers on the heap or not, &gt; STL is unusable, is counterproductive and makes your programs unreadable.
Take a look at what the same guy wrote 2 years later: http://dorinlazar.ro/c-going-forward-2015/ 
After. Scott Meyer's books are more about common practice and avoiding pitfalls. You will definitely want them, but there's plenty of basics to be learned beforehand.
I hadn't seen re2 before, thanks for the pointer. It looks nice, I'll take a closer look.
Still using the original at the moment, but I plan to update to pcre2 at some point.
16.2 7 [ Note: Although an implementation may provide a mechanism for making arbitrary source files available to the &lt; &gt; search, in general programmers should use the &lt; &gt; form for headers provided with the implementa- tion, and the " " form for sources outside the control of the implementation. For instance: #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include "usefullib.h" #include "myprog.h" — end note ] Although honestly I prefer &lt;&gt; for anything that is a project unto itself (example, my personal game engine will get included with &lt;&gt; from my game, but to access its own headers it uses "")
If all you want to do with your strings is an ends-with test, then yes, that imposes an overhead. But most of the time you'll be doing a lot of other processing on strings, and it doesn't take many function calls before it becomes much more efficient to do normalisation once rather than add the overhead to every string operation.
for a template argument `x`, writing `f(x)` requires a declaration (forward or through header inclusion) of function `f`, whereas `x.f()` doesn't. So UFCS makes it easier to write generic (i.e. templated) code by eliminating header dependencies. I'd still prefer to also have the opposite (i.e. `x.f()` finding `f(x)`) since writing function calls infix instead of prefix allows for much easier to read code (e.g. `x.f().g().h()` vs `h(g(f(x)))`). 
I would suggest considering whether or not there is another version control software that can handle that. Perhaps breaking it up into smaller repositories would work, but I don't know. Git can handle it for smaller repos, and mercurial is developed with the intention of scaling better than git, but it doesn't seem to be there now. If perforce works great other than a terrible visual studio plugin, then I wouldn't migrate away from it. I would disable the plugin so it doesn't ruin my day.
infix function calls are much easier to debug and modify than prefix function calls. It's no coincidence that such diverse languages as C#, D and R (through the `%&gt;%` operator) all have them. 
This isn't true, unfortunately.
&gt; (example, my personal game engine will get included with &lt;&gt; from my game, but to access its own headers it uses "") Seems like a reasonable approach.
`template&lt;class T&gt; void fun(T const&amp; x) { f(x); }` won't compile unless `template&lt;class T&gt; f(T const&amp; x)` has been declared. OTOH, `template&lt;class T&gt; void fun(T const&amp; x) { x.f(); }` will compile. Only when that template is instantiated, does the compiler go looking for a member function `f()` of object `x`. However, only the caller has to supply that, not the library writer. This is why UFCS makes it easier to write generic code. And BTW, member function calls like `x.f()` for objects `x` of class type `T` are under-the-hood transformed to `f(T*)` with the `this` pointer as its first argument.
Overall I would say that branch (if, switch) could be faster in some cases, because it does not need vtable that can cause cache misses. Also vtable will make class/struct bigger and this can cause even more cache problems. So if some struct can be created million times (nodes in BVH tree for example ) then vtable will add really huge overhead and make everything unnecessary slower and memory hungry. Of course benchmark can some times show pretty unexpected result, but it is some times difficult to create proper benchmarks. 
First thing that comes to mind for me is something like insert(structure, data) //replaces structure.insert(data) I kind of like it, but I do get a bit scared when something might implicitly fall back on another method if I don't realize there's one in scope (ideally you'd have total control over scope but it's not always an ideal world...)
The VC++ implementation [just doesn't support most of them](https://msdn.microsoft.com/en-us/library/dn823774.aspx). Implementing only the minimal common subset of filesystem functionality would leave you with nothing at all, so you inherently have to have optional things that aren't implemented on all platforms.
Maybe I'm missing something but I figured that variable templates worked the same as normal templates. Basically you are just missing the specialization in your header. template &lt;typename T&gt; extern char const* className; template &lt;&gt; extern char const* className&lt;Foo&gt;; 
POSIX is mentioned in the standard a few times, and is specifically supported by some of the more recent additions - the error code library (system_error) and the regex library in particular. But there's plenty of influence elsewhere: the signature of main, taking a sequence of strings and returning an integer; environment variables; the three standard input/output streams; text mode using a single-character line terminator. Also, while chrono is epoch-agnostic, ctime is most certainly not. 
I once wrote a C++ program that used the Windows API to read through a directory and grab files. Once.
Thanks for the info. Very interesting. I guess in some (limited) ways the windows platform mimics posix. That's not really surprising. 
I remember seeing somewhere that they'd definitely drop XP support soon but were not sure yet if it'll be next, or next+1 release.
That's just Apple. It's a bit annoying that they change the version numbers of the compiler to be honest. There's a [gist](https://gist.github.com/yamaya/2924292) showing the different clang versions that were included with Xcode. Before Xcode 7.0 they at least also reported the upstream version, compare: # Xcode 6.4 (6E35b) Apple LLVM version 6.1.0 (clang-602.0.53) (based on LLVM 3.6.0svn) Target: x86_64-apple-darwin14.3.0 Thread model: posix # Xcode 7.0 beta (7A120f) Apple LLVM version 7.0.0 (clang-700.0.53) Target: x86_64-apple-darwin14.4.0 Thread model: posix
&gt; `template&lt;class T&gt; void fun(T const&amp; x) { f(x); }` won't compile &gt; unless `template&lt;class T&gt; f(T const&amp; x)` has been declared. What? It compiles just fine. The `f` is dependent since overloads can be picked up by ADL at the point of instantiation.
I lost all the file templates from the "Add -&gt; New Item..." dialog after updating. Tried to fix it with running WDExpress /resetsettings and WDExpress /installvstemplates (with evaluated rights), but nothing did the work. Uninstalled everything and am now reinstalling everything... *After the reinstall it still doesn't work* File templates are still missing. My initial reaction was laughing, but it's not healthy laugh... EDIT: Also the File -&gt; New Project -&gt; Win32 Project screen is messed up: [screenshot](http://prntscr.com/a2kiz9) EDIT2: Also seems (is) a lot slower than the RTM. Loading projects with only couple files hang the IDE for couple seconds and projects with hundreds of files hang for like 30 seconds. This didn't happen in RTM as projects pretty much loaded immediately, no matter what size. By immediate I mean I never saw a progress dialog once. This is on a high end system with SSD disks.
I'm stuck between wanting new language features and supporting old versions, so v140_xp is a lifeline for me. I maintain a bunch of legacy tools so I have a disproportionate number of users on old Windows versions. Some are even still on W2K.
Sorry never had an issue like that. 
Consider `std::string`, where most of the member functions could be non-friend free functions. This further encourages making functions free when they don't need private access because template code can call `size(x)` and get `x.size()` if the free version is not found. On a personal note, I'm disappointed that the other direction was taken out. 
It was _your_ example...
go cry to your mommy wittle baby
This is not true. We have no plans. Source: am the dev mgr
Contrary to the audience, i like your blog article. Not that I will stop using c++, but because *most* of the problems are real. In the updated one, you managed to show better that your critiques are targeted to help the language. It is good for all c++ developers to acknowledge the bad side from time to time. Your blog shows some directions for improvements.
Disappointed on the changes to the Universal Function Call Syntax proposal, it seemed to me that most of the arguments were for the other way around. As it is I'll probably end up not using it :/
It seems that the primary argument against it was that it made code fragile. For example, if I start with: // In ThirdPartyLibrary.h struct MyThing { void foo(); void bar(); }; // In MyUtils.cpp void quux(MyThing &amp;T) { // Critical important functionality missing from // MyThing for our use-case of ThirdPartyLibrary } // In app.cpp int main() { MyThing Instance; Instance.quux(); return 0; } ...And the authors of ThirdPartyLibrary add `quux` to `MyThing` with different semantics, your code now silently calls the new `quux`. Now, you could *probably* make tooling to detect this (e.g. by making code that detects overloads that resolve differently in the presence of new methods), or make warnings to say "quux will always be shadowed by `MyThing`", or [...], but this was the argument I was able to find. Given that the name of the method would *probably* be more meaningful than `quux`, you would probably be fine in the vast majority of cases. This problem also exists e.g. whenever an overload is added to an overload set, so I'm not sure if I think it's a solid argument. Bjarne tried to argue against it (AFAICT), so we may see UFCS uncrippled in C++2x (much like how `constexpr` was introduced in 11, and had restrictions lifted/features added in 14). Personally, I just want to be able to type `myVector.count(foo)` and have it magically work as in D, so I'm sad to see UFCS get changed like this. :(
You know, there's this license plate someone has right near my house with "WNDROC" on it. Every time I look at it, I misread it.
The weird thing is, when I look at the [proposals group](https://groups.google.com/a/isocpp.org/forum/#!forum/std-proposals), I feel like some people already have the mindset "people are now going to use free function much more often and they are going to LIKE it". I even see arguments about IDE autocompletion being dismissed with suggestions that editors could transform `x.f()` to `f(x)` as I type it (as if that wasn't weird at all).
Have you ever done it in MS-DOS as well? I did and the Windows API is certainly an improvement over that one.
This can already basically happen if you just have two cpp files definitions of equally-declared functions. If member functions and static functions were interchangeable, it shouldn't make a difference. The only issue with this is backwards compatibility, but hey, fuck anyone who has two functions foo(bar) and bar.foo() that do different things, right? Plus, it's an issue for the proposal, too!
I've checked the progress made in this CTP by compiling Howard Hinnant's date library with 'constexpr' enabled and running date's test suite. Result: All tests supposed to fail do fail. Most tests supposed to pass compile and do pass. But there are 3 ICEs, 4 overload resolution errors, and one failed assert. Still room for improvement...
&gt; It seems that the primary argument against it was that it made code fragile. &gt; And the authors of ThirdPartyLibrary add `quux` to `MyThing` with different semantics, your code now silently calls the new `quux`. Thats why compiler should throw ambiguity error instead of silently picking one over the other. There is no problem here...
 LPCTSTR lpszResponse = _T("I see what you did there.");
I thought this was a good counter to the "The day I gave up C++" article.
The autor of the ["The day I gave up C++"](http://dorinlazar.ro/the-day-i-gave-up-on-cpp/) has published an update namely: ["Why C++ sucks (2016.02 edition)"](http://dorinlazar.ro/why-c-sucks-2016-02-edition/).
Making OS in a language does not necessarily make it native tho. You could probably write OS in Python, if you bootloaded the interpreter with assembly or something before executing the OS code, but that does not make Python native language.
Thanks.
How could that possibly be a good idea? You want to be able to break any class by making a free-function with the same name as a member function?
Feeding a troll is rarely productive.
&gt; That’s the case for my instant crush for C# ... moron friendly, so it was a natural match. Indeed...
&gt; Namespaces are useless and make the code way too verbose. The entire article is comedy gold. There is like one valid complaint out of 100 of them. &gt; I like to call myself stupid. It’s obvious that I am, that’s why I became a programmer – to make computers do the work for me, because I’m not to be trusted. 10/10 
C++ really sucks, but it sucks less than any other language.
Definitely the best. VS only beats it at debugging 
It really makes sense now. C++ absolutely does suck for those who are too stupid to understand it.
Reminds me of Churchill's quip about democracy. I guess it applies to many things.
The 'C' in C# makes idiots love to compare it to C++ and treat it like an evolution to C++, when it is really just a better Java. Not that this is a knock against C# -- I love working with it -- but the portability and easiness of C# comes from the fact that it is interpreted and has a GC, both of which make it entirely inappropriate for most of the things people use C++ for.
Actually, proper modern C++ code is much less prone to have such subtle errors and bugs. So it's a win on that part. Additionally, it's much easier to reason about, and there are tools (e.g. static analyzers) that can help even more. And, well, progress has never been made by keeping things the way are and not challenging them.
It's a shame he doesn't release the code. What he says in the end is basically: "zlib has a liberal licence, and I don't want to release my code under a liberal licence. Thus, I will maybe change all of it so I can _change_ the licence and release it under a less liberal one, or I will probably not have time for that and not release it at all." I bet there's a lot of demand for a header-only, modern zlib drop-in replacement, and this would be an awesome starting point.
Same name, matching call signature and taking that class as first parameter. How is it not ambiguity error if two callables match?
So you're agreeing that it's a terrible idea then?
I find namespaces incredibly useful. It's just a matter of choosing good ones and not to nest em too deeply. If verbosity is a concern, try coding on Objective-C. Its lack of namespace support forces you to prefix class names in a manner such as, `@class FakeNamespacePrefixObjectNameGoesHere` and so forth.
Good point. I suppose this was exactly why c# did extension methods the way they did. Maybe c++ will either have to do something similar or if will be feature of little use.
Unlike Java, C# is never interpreted, it’s always JIT-compiled. This doesn’t detract from your overall point, of course.
Yeah maybe it's too late for c++ for simple solution. Maybe that's why C# oggot extension methods instead of UCS
This is a very good point, however I always thought that the two functions implement the same functionality, and the vector begin was simply a crutch to allow v.begin() \*. With UFCS, you would get rid of these helper functions as std::begin would be callable from v.begin(). This also throws up another issue, with namespaces, which may be why the reverse was chosen. Would I have to be using namespace std; in order to have v.begin(); translate to std::begin(v); \* EDIT: actually I realise it is probably the other way around, std::begin() will be the crutch for container.begin()
Yes, been thinking on this now for quite a time. emplace with iterators should be as good or better, so thats what I'm using now.
One who down voted you is wrong. Clion indeed has worse debugging experience. Idk what is at fault but it's much slower to step through code. Also no memory or disassembly views. Not everyone digs gdb commands..